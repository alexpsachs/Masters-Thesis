[
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17432125",
        "pull_request_review_id": null,
        "id": 17432125,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDMyMTI1",
        "diff_hunk": "@@ -41,10 +47,34 @@ func NewWatcher() (*Watcher, error) {\n \t\tpaths:   make(map[int]string),\n \t\tEvents:  make(chan Event),\n \t\tErrors:  make(chan error),\n-\t\tdone:    make(chan bool, 1),\n+\t\tdone:    make(chan bool),\n+\t\tclosed:  make(chan bool),\n+\t}\n+        w.cv = sync.NewCond(&w.mu)\n+\n+\trp, wp, err := os.Pipe() // for done\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tepfd, err := syscall.EpollCreate1(0)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_create1\", err)\n+\t}\n+\tevent := &syscall.EpollEvent{syscall.EPOLLIN, int32(w.fd), 0}\n+\tif err = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, w.fd, event); err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", err)\n \t}\n+\tevent = &syscall.EpollEvent{syscall.EPOLLIN, int32(rp.Fd()), 0}",
        "path": "inotify.go",
        "position": null,
        "original_position": 52,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "cc35f83ef0e427761df53d9a7ce61e15c9c0f8ab",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm not familiar with this stuff. Some comments would help.\n\nSo you're setting up epoll on the file descriptor for inotify events... and then this os.Pipe() file descriptor as well\n",
        "created_at": "2014-09-11T16:43:56Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17432125",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17432125"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17432125"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17432812",
        "pull_request_review_id": null,
        "id": 17432812,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDMyODEy",
        "diff_hunk": "@@ -237,3 +263,53 @@ func newEvent(name string, mask uint32) Event {\n \t}\n \treturn e\n }\n+\n+func (w *Watcher) length() int {",
        "path": "inotify.go",
        "position": 239,
        "original_position": 229,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "cc35f83ef0e427761df53d9a7ce61e15c9c0f8ab",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It looks like this method is only used in tests. Perhaps it should just be a helper function in the tests?\n",
        "created_at": "2014-09-11T16:58:05Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17432812",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17432812"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17432812"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17460575",
        "pull_request_review_id": null,
        "id": 17460575,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDYwNTc1",
        "diff_hunk": "@@ -41,10 +47,34 @@ func NewWatcher() (*Watcher, error) {\n \t\tpaths:   make(map[int]string),\n \t\tEvents:  make(chan Event),\n \t\tErrors:  make(chan error),\n-\t\tdone:    make(chan bool, 1),\n+\t\tdone:    make(chan bool),\n+\t\tclosed:  make(chan bool),\n+\t}\n+        w.cv = sync.NewCond(&w.mu)\n+\n+\trp, wp, err := os.Pipe() // for done\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tepfd, err := syscall.EpollCreate1(0)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_create1\", err)\n+\t}\n+\tevent := &syscall.EpollEvent{syscall.EPOLLIN, int32(w.fd), 0}\n+\tif err = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, w.fd, event); err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", err)\n \t}\n+\tevent = &syscall.EpollEvent{syscall.EPOLLIN, int32(rp.Fd()), 0}",
        "path": "inotify.go",
        "position": null,
        "original_position": 52,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "cc35f83ef0e427761df53d9a7ce61e15c9c0f8ab",
        "user": {
            "login": "chamaken",
            "id": 4514661,
            "node_id": "MDQ6VXNlcjQ1MTQ2NjE=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/4514661?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/chamaken",
            "html_url": "https://github.com/chamaken",
            "followers_url": "https://api.github.com/users/chamaken/followers",
            "following_url": "https://api.github.com/users/chamaken/following{/other_user}",
            "gists_url": "https://api.github.com/users/chamaken/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/chamaken/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/chamaken/subscriptions",
            "organizations_url": "https://api.github.com/users/chamaken/orgs",
            "repos_url": "https://api.github.com/users/chamaken/repos",
            "events_url": "https://api.github.com/users/chamaken/events{/privacy}",
            "received_events_url": "https://api.github.com/users/chamaken/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "So you know though readEvents() blocks so that we need to break it to close gracefully.\nepoll can be used which descriptor can be handled from which it was registerd like select(2)\nbut FdSet which is params of syscall.Select() has no handling function - FD_SET macro. \n\nI introduced epoll and os.Pipe() just notifying to epoll that watcher.Close() method is called. \nThe flow is - watcher.Close() send bool through watcher.done channel, inline go routine receives it and closes the pipe, then epoll notices the pipe is closed and breaks loop, returns.  \n\nIntroducing epoll seems overdoing but I could not find more better way, sorry.\n",
        "created_at": "2014-09-12T02:18:04Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17460575",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17460575"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17460575"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17460628",
        "pull_request_review_id": null,
        "id": 17460628,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDYwNjI4",
        "diff_hunk": "@@ -237,3 +263,53 @@ func newEvent(name string, mask uint32) Event {\n \t}\n \treturn e\n }\n+\n+func (w *Watcher) length() int {",
        "path": "inotify.go",
        "position": 239,
        "original_position": 229,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "cc35f83ef0e427761df53d9a7ce61e15c9c0f8ab",
        "user": {
            "login": "chamaken",
            "id": 4514661,
            "node_id": "MDQ6VXNlcjQ1MTQ2NjE=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/4514661?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/chamaken",
            "html_url": "https://github.com/chamaken",
            "followers_url": "https://api.github.com/users/chamaken/followers",
            "following_url": "https://api.github.com/users/chamaken/following{/other_user}",
            "gists_url": "https://api.github.com/users/chamaken/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/chamaken/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/chamaken/subscriptions",
            "organizations_url": "https://api.github.com/users/chamaken/orgs",
            "repos_url": "https://api.github.com/users/chamaken/repos",
            "events_url": "https://api.github.com/users/chamaken/events{/privacy}",
            "received_events_url": "https://api.github.com/users/chamaken/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You are true, I introduced length() and isRunning just for test.\n",
        "created_at": "2014-09-12T02:20:55Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17460628",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17460628"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17460628"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17509204",
        "pull_request_review_id": null,
        "id": 17509204,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTA5MjA0",
        "diff_hunk": "@@ -41,10 +47,34 @@ func NewWatcher() (*Watcher, error) {\n \t\tpaths:   make(map[int]string),\n \t\tEvents:  make(chan Event),\n \t\tErrors:  make(chan error),\n-\t\tdone:    make(chan bool, 1),\n+\t\tdone:    make(chan bool),\n+\t\tclosed:  make(chan bool),\n+\t}\n+        w.cv = sync.NewCond(&w.mu)\n+\n+\trp, wp, err := os.Pipe() // for done\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tepfd, err := syscall.EpollCreate1(0)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_create1\", err)\n+\t}\n+\tevent := &syscall.EpollEvent{syscall.EPOLLIN, int32(w.fd), 0}\n+\tif err = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, w.fd, event); err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", err)\n \t}\n+\tevent = &syscall.EpollEvent{syscall.EPOLLIN, int32(rp.Fd()), 0}",
        "path": "inotify.go",
        "position": null,
        "original_position": 52,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "cc35f83ef0e427761df53d9a7ce61e15c9c0f8ab",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It might be just the right thing, I'm just still learning Linux stuff since taking over maintenance of the project. Thanks for explaining the choice of epoll rather than select.\n\nI do want to make sure that the code is understandable and maintainable going forward.\n\nBefore I merge this in, take a look at #5 and the links to when @howeyc added and remove select(). Let me know what you think.\n",
        "created_at": "2014-09-13T00:54:45Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17509204",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17509204"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17509204"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17512132",
        "pull_request_review_id": null,
        "id": 17512132,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTEyMTMy",
        "diff_hunk": "@@ -41,10 +47,34 @@ func NewWatcher() (*Watcher, error) {\n \t\tpaths:   make(map[int]string),\n \t\tEvents:  make(chan Event),\n \t\tErrors:  make(chan error),\n-\t\tdone:    make(chan bool, 1),\n+\t\tdone:    make(chan bool),\n+\t\tclosed:  make(chan bool),\n+\t}\n+        w.cv = sync.NewCond(&w.mu)\n+\n+\trp, wp, err := os.Pipe() // for done\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tepfd, err := syscall.EpollCreate1(0)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_create1\", err)\n+\t}\n+\tevent := &syscall.EpollEvent{syscall.EPOLLIN, int32(w.fd), 0}\n+\tif err = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, w.fd, event); err != nil {\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", err)\n \t}\n+\tevent = &syscall.EpollEvent{syscall.EPOLLIN, int32(rp.Fd()), 0}",
        "path": "inotify.go",
        "position": null,
        "original_position": 52,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "cc35f83ef0e427761df53d9a7ce61e15c9c0f8ab",
        "user": {
            "login": "chamaken",
            "id": 4514661,
            "node_id": "MDQ6VXNlcjQ1MTQ2NjE=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/4514661?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/chamaken",
            "html_url": "https://github.com/chamaken",
            "followers_url": "https://api.github.com/users/chamaken/followers",
            "following_url": "https://api.github.com/users/chamaken/following{/other_user}",
            "gists_url": "https://api.github.com/users/chamaken/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/chamaken/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/chamaken/subscriptions",
            "organizations_url": "https://api.github.com/users/chamaken/orgs",
            "repos_url": "https://api.github.com/users/chamaken/repos",
            "events_url": "https://api.github.com/users/chamaken/events{/privacy}",
            "received_events_url": "https://api.github.com/users/chamaken/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "it seems that FD_ macros were wrong. using original, 660b1c4c2fcd8232a4def9d5b571b99f0e612273 did not work but refering http://play.golang.org/p/rIuaDUzLXw, 0ab96cb1c86f29e698000e828d35add9b1c35ea9 worked. I will rewrite using select, timeout if you prefer.\n\nBy the way patches I've posted has strange EOF handling and needs a bit clean up, could you let me rewrite it? you can see these https://github.com/chamaken/fsnotify/commit/d6718be69144ca1dacdf2b6d51035b85f16c0e16#diff-9dee340ab29d1c1db9e272db38706348 and https://github.com/chamaken/fsnotify/commit/3687df3d3566cecd3590797d12ba21762e90b22e#diff-9dee340ab29d1c1db9e272db38706348\n",
        "created_at": "2014-09-13T13:00:06Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17512132",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17512132"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17512132"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17527414",
        "pull_request_review_id": null,
        "id": 17527414,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTI3NDE0",
        "diff_hunk": "@@ -17,16 +17,21 @@ import (\n \t\"unsafe\"\n )\n \n+const EPOLL_MAX_EVENTS\t= 16\n+\n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents   chan Event\n \tErrors   chan error\n \tmu       sync.Mutex        // Map access\n+        cv       *sync.Cond        // sync removing on rm_watch with IN_IGNORE",
        "path": "inotify.go",
        "position": null,
        "original_position": 11,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "3687df3d3566cecd3590797d12ba21762e90b22e",
        "user": {
            "login": "dmitshur",
            "id": 1924134,
            "node_id": "MDQ6VXNlcjE5MjQxMzQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1924134?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dmitshur",
            "html_url": "https://github.com/dmitshur",
            "followers_url": "https://api.github.com/users/dmitshur/followers",
            "following_url": "https://api.github.com/users/dmitshur/following{/other_user}",
            "gists_url": "https://api.github.com/users/dmitshur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/dmitshur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/dmitshur/subscriptions",
            "organizations_url": "https://api.github.com/users/dmitshur/orgs",
            "repos_url": "https://api.github.com/users/dmitshur/repos",
            "events_url": "https://api.github.com/users/dmitshur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/dmitshur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It looks like it needs to be `gofmt`ed.\n",
        "created_at": "2014-09-15T06:21:30Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17527414",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17527414"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17527414"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17527882",
        "pull_request_review_id": null,
        "id": 17527882,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTI3ODgy",
        "diff_hunk": "@@ -17,16 +17,21 @@ import (\n \t\"unsafe\"\n )\n \n+const EPOLL_MAX_EVENTS\t= 16\n+\n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents   chan Event\n \tErrors   chan error\n \tmu       sync.Mutex        // Map access\n+        cv       *sync.Cond        // sync removing on rm_watch with IN_IGNORE",
        "path": "inotify.go",
        "position": null,
        "original_position": 11,
        "commit_id": "5092cdeab017ea448b2c7e95db7a43b9c05fff90",
        "original_commit_id": "3687df3d3566cecd3590797d12ba21762e90b22e",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't mind doing minor cleanup as part of my [merging process](http://blog.spreedly.com/2014/06/24/merge-pull-request-considered-harmful/). More concerned with functionality, structure and maintainability.\n\nOf course, running gofmt and checking for typos is always appreciated. :-)\n",
        "created_at": "2014-09-15T06:42:44Z",
        "updated_at": "2014-10-03T02:40:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17527882",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/17527882"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/39#discussion_r17527882"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/39"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24219302",
        "pull_request_review_id": null,
        "id": 24219302,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjE5MzAy",
        "diff_hunk": "@@ -101,9 +125,14 @@ func (w *Watcher) Add(name string) error {\n \n // Remove stops watching the the named file or directory (non-recursively).\n func (w *Watcher) Remove(name string) error {\n-\tname = filepath.Clean(name)\n \tw.mu.Lock()\n \tdefer w.mu.Unlock()\n+\treturn w.remove(name)\n+}\n+\n+// Only call this when w.mu is locked, like from Remove or Close.",
        "path": "inotify.go",
        "position": null,
        "original_position": 101,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "b81db084b35e1d7832bd93fab63f764beda1391f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm not in love with having a function that requires the mutex to be done outside of it, but I don't have any better ideas right now.\n\nAlso not sure about taking a Mutex around the entirety of remove vs. just some part of it.\n",
        "created_at": "2015-02-06T02:38:55Z",
        "updated_at": "2015-02-06T08:48:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24219302",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24219302"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24219302"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24219462",
        "pull_request_review_id": null,
        "id": 24219462,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjE5NDYy",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2010 The Go Authors. All rights reserved.",
        "path": "inotify_test.go",
        "position": null,
        "original_position": 1,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "b81db084b35e1d7832bd93fab63f764beda1391f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\u00a9 2015 for new files, old files can rename the same\n",
        "created_at": "2015-02-06T02:44:10Z",
        "updated_at": "2015-02-06T08:48:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24219462",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24219462"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24219462"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24219498",
        "pull_request_review_id": null,
        "id": 24219498,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjE5NDk4",
        "diff_hunk": "@@ -101,9 +125,14 @@ func (w *Watcher) Add(name string) error {\n \n // Remove stops watching the the named file or directory (non-recursively).\n func (w *Watcher) Remove(name string) error {\n-\tname = filepath.Clean(name)\n \tw.mu.Lock()\n \tdefer w.mu.Unlock()\n+\treturn w.remove(name)\n+}\n+\n+// Only call this when w.mu is locked, like from Remove or Close.",
        "path": "inotify.go",
        "position": null,
        "original_position": 101,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "b81db084b35e1d7832bd93fab63f764beda1391f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "How about a seperate method to return a slice of watches, or a method to simply remove all watches?\n\nSince the watcher is closed when Closing anyway, no new ones will be added, and we could do more fine-grained locking in remove.\n",
        "created_at": "2015-02-06T02:45:45Z",
        "updated_at": "2015-02-06T08:48:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24219498",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24219498"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24219498"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24220009",
        "pull_request_review_id": null,
        "id": 24220009,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjIwMDA5",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2010 The Go Authors. All rights reserved.",
        "path": "inotify_test.go",
        "position": null,
        "original_position": 1,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "b81db084b35e1d7832bd93fab63f764beda1391f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Got it. Sorry.\n",
        "created_at": "2015-02-06T03:06:06Z",
        "updated_at": "2015-02-06T08:48:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24220009",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24220009"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24220009"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24220052",
        "pull_request_review_id": null,
        "id": 24220052,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjIwMDUy",
        "diff_hunk": "@@ -101,9 +125,14 @@ func (w *Watcher) Add(name string) error {\n \n // Remove stops watching the the named file or directory (non-recursively).\n func (w *Watcher) Remove(name string) error {\n-\tname = filepath.Clean(name)\n \tw.mu.Lock()\n \tdefer w.mu.Unlock()\n+\treturn w.remove(name)\n+}\n+\n+// Only call this when w.mu is locked, like from Remove or Close.",
        "path": "inotify.go",
        "position": null,
        "original_position": 101,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "b81db084b35e1d7832bd93fab63f764beda1391f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm not convinced fine-grained locking is an option here. It seems a trap for race conditions at first glance. Maybe it's even a mistake in Add.\n",
        "created_at": "2015-02-06T03:07:50Z",
        "updated_at": "2015-02-06T08:48:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24220052",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24220052"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24220052"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290549",
        "pull_request_review_id": null,
        "id": 24290549,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNTQ5",
        "diff_hunk": "@@ -116,6 +136,21 @@ func (w *Watcher) Remove(name string) error {\n \treturn nil\n }\n \n+// Called from Close(); remove all watches.\n+func (w *Watcher) removeAll() int {\n+\tsuccessful := 0\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\tfor name, watch := range w.watches {\n+\t\tsuccess, _ := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": 113,
        "original_position": 113,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "do we need `name = filepath.Clean(name)` here?\n\nIt was added to make ./path and path equivalent.\n",
        "created_at": "2015-02-07T16:40:52Z",
        "updated_at": "2015-02-07T16:40:52Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290549",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290549"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290549"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290556",
        "pull_request_review_id": null,
        "id": 24290556,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNTU2",
        "diff_hunk": "@@ -116,6 +136,21 @@ func (w *Watcher) Remove(name string) error {\n \treturn nil\n }\n \n+// Called from Close(); remove all watches.\n+func (w *Watcher) removeAll() int {\n+\tsuccessful := 0\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\tfor name, watch := range w.watches {\n+\t\tsuccess, _ := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": 113,
        "original_position": 113,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "no, sorry, we don't use the name except for delete, so it's fine.\n\n(actually that may have caused a bug in Remove) I'll come back to that in a moment #64.\n",
        "created_at": "2015-02-07T16:41:26Z",
        "updated_at": "2015-02-07T16:44:59Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290556",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290556"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290556"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290613",
        "pull_request_review_id": null,
        "id": 24290613,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjEz",
        "diff_hunk": "@@ -149,20 +183,31 @@ func (w *Watcher) readEvents() {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// syscall.Read might have been woken up by Close. If so, we're done.\n+\t\tif w.isClosed() {\n+\t\t\treturn\n+\t\t}\n+\n \t\t// If EOF is received\n \t\tif n == 0 {\n-\t\t\tsyscall.Close(w.fd)\n-\t\t\tclose(w.Events)\n-\t\t\tclose(w.Errors)\n+\t\t\tclose(w.done)\n \t\t\treturn\n \t\t}\n \n \t\tif n < 0 {\n-\t\t\tw.Errors <- os.NewSyscallError(\"read\", errno)\n+\t\t\tselect {",
        "path": "inotify.go",
        "position": 167,
        "original_position": 167,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "these 3 selects make me curious.\n\nwe are sending an error or checking if the done channel is closed, whichever happens first?\n",
        "created_at": "2015-02-07T16:49:24Z",
        "updated_at": "2015-02-07T16:49:44Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290613",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290613"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290613"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290621",
        "pull_request_review_id": null,
        "id": 24290621,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjIx",
        "diff_hunk": "@@ -116,6 +136,21 @@ func (w *Watcher) Remove(name string) error {\n \treturn nil\n }\n \n+// Called from Close(); remove all watches.\n+func (w *Watcher) removeAll() int {\n+\tsuccessful := 0\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\tfor name, watch := range w.watches {\n+\t\tsuccess, _ := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": 113,
        "original_position": 113,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We don't need removeAll at all, actually. closing the fd will get rid of everything.\n",
        "created_at": "2015-02-07T16:49:53Z",
        "updated_at": "2015-02-07T16:49:53Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290621",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290621"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290621"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290624",
        "pull_request_review_id": null,
        "id": 24290624,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjI0",
        "diff_hunk": "@@ -116,6 +136,21 @@ func (w *Watcher) Remove(name string) error {\n \treturn nil\n }\n \n+// Called from Close(); remove all watches.\n+func (w *Watcher) removeAll() int {\n+\tsuccessful := 0\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\tfor name, watch := range w.watches {\n+\t\tsuccess, _ := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": 113,
        "original_position": 113,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "In fact, we don't need watches at all.\n",
        "created_at": "2015-02-07T16:50:18Z",
        "updated_at": "2015-02-07T16:50:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290624",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290624"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290624"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290632",
        "pull_request_review_id": null,
        "id": 24290632,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjMy",
        "diff_hunk": "@@ -149,20 +183,31 @@ func (w *Watcher) readEvents() {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// syscall.Read might have been woken up by Close. If so, we're done.\n+\t\tif w.isClosed() {\n+\t\t\treturn\n+\t\t}\n+\n \t\t// If EOF is received\n \t\tif n == 0 {\n-\t\t\tsyscall.Close(w.fd)\n-\t\t\tclose(w.Events)\n-\t\t\tclose(w.Errors)\n+\t\t\tclose(w.done)\n \t\t\treturn\n \t\t}\n \n \t\tif n < 0 {\n-\t\t\tw.Errors <- os.NewSyscallError(\"read\", errno)\n+\t\t\tselect {",
        "path": "inotify.go",
        "position": 167,
        "original_position": 167,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "so if the consumer of this library isn't ready to receive an Error or Event for some reason, we don't continue blocking if Close() is called., \n",
        "created_at": "2015-02-07T16:51:24Z",
        "updated_at": "2015-02-07T16:51:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290632",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290632"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290632"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290635",
        "pull_request_review_id": null,
        "id": 24290635,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjM1",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestInotifyCloseRightAway(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Close immediately; it won't even reach the first syscall.Read.\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLater(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Wait until readEvents has reached syscall.Read, and Close.\n+\t<-time.After(50 * time.Millisecond)\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLaterWithWatch(t *testing.T) {\n+\ttestDir := tempMkdir(t)\n+\tdefer os.RemoveAll(testDir)\n+\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\tw.Add(\"testDir\")",
        "path": "inotify_test.go",
        "position": 53,
        "original_position": 53,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": ":bug: testDir without quotes?\n",
        "created_at": "2015-02-07T16:52:20Z",
        "updated_at": "2015-02-07T16:52:20Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290635",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290635"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290635"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290639",
        "pull_request_review_id": null,
        "id": 24290639,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjM5",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestInotifyCloseRightAway(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Close immediately; it won't even reach the first syscall.Read.\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLater(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Wait until readEvents has reached syscall.Read, and Close.\n+\t<-time.After(50 * time.Millisecond)",
        "path": "inotify_test.go",
        "position": 37,
        "original_position": 37,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is there any advantage/difference of time.After vs. time.Sleep?\n",
        "created_at": "2015-02-07T16:53:37Z",
        "updated_at": "2015-02-07T16:53:37Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290639",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290639"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290639"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290665",
        "pull_request_review_id": null,
        "id": 24290665,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjY1",
        "diff_hunk": "@@ -149,20 +183,31 @@ func (w *Watcher) readEvents() {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// syscall.Read might have been woken up by Close. If so, we're done.\n+\t\tif w.isClosed() {\n+\t\t\treturn\n+\t\t}\n+\n \t\t// If EOF is received\n \t\tif n == 0 {\n-\t\t\tsyscall.Close(w.fd)\n-\t\t\tclose(w.Events)\n-\t\t\tclose(w.Errors)\n+\t\t\tclose(w.done)\n \t\t\treturn\n \t\t}\n \n \t\tif n < 0 {\n-\t\t\tw.Errors <- os.NewSyscallError(\"read\", errno)\n+\t\t\tselect {",
        "path": "inotify.go",
        "position": 167,
        "original_position": 167,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah. This solves the problem of when someone Closes the watcher and moves on, but there is still an error waiting to be sent. Without those selects, it would block forever. Which is, in fact, what was happening in a lot of cases.\n",
        "created_at": "2015-02-07T16:57:06Z",
        "updated_at": "2015-02-07T16:57:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290665",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290665"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290665"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290670",
        "pull_request_review_id": null,
        "id": 24290670,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjcw",
        "diff_hunk": "@@ -149,20 +183,31 @@ func (w *Watcher) readEvents() {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// syscall.Read might have been woken up by Close. If so, we're done.\n+\t\tif w.isClosed() {\n+\t\t\treturn\n+\t\t}\n+\n \t\t// If EOF is received\n \t\tif n == 0 {\n-\t\t\tsyscall.Close(w.fd)\n-\t\t\tclose(w.Events)\n-\t\t\tclose(w.Errors)\n+\t\t\tclose(w.done)\n \t\t\treturn\n \t\t}\n \n \t\tif n < 0 {\n-\t\t\tw.Errors <- os.NewSyscallError(\"read\", errno)\n+\t\t\tselect {",
        "path": "inotify.go",
        "position": 167,
        "original_position": 167,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Er, anyway it still blocks on sending the error or event, unless we closed it. Only then will w.done return a value.\n",
        "created_at": "2015-02-07T16:57:54Z",
        "updated_at": "2015-02-07T16:57:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290670",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290670"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290670"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290674",
        "pull_request_review_id": null,
        "id": 24290674,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNjc0",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestInotifyCloseRightAway(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Close immediately; it won't even reach the first syscall.Read.\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLater(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Wait until readEvents has reached syscall.Read, and Close.\n+\t<-time.After(50 * time.Millisecond)\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLaterWithWatch(t *testing.T) {\n+\ttestDir := tempMkdir(t)\n+\tdefer os.RemoveAll(testDir)\n+\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\tw.Add(\"testDir\")",
        "path": "inotify_test.go",
        "position": 53,
        "original_position": 53,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Heh. OOPS\n",
        "created_at": "2015-02-07T16:58:42Z",
        "updated_at": "2015-02-07T16:58:42Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290674",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290674"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290674"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290716",
        "pull_request_review_id": null,
        "id": 24290716,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNzE2",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestInotifyCloseRightAway(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Close immediately; it won't even reach the first syscall.Read.\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLater(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Wait until readEvents has reached syscall.Read, and Close.\n+\t<-time.After(50 * time.Millisecond)\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLaterWithWatch(t *testing.T) {\n+\ttestDir := tempMkdir(t)\n+\tdefer os.RemoveAll(testDir)\n+\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\tw.Add(\"testDir\")",
        "path": "inotify_test.go",
        "position": 53,
        "original_position": 53,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I can fix it, don't worry about it.\n",
        "created_at": "2015-02-07T17:04:56Z",
        "updated_at": "2015-02-07T17:04:56Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290716",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290716"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290716"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290735",
        "pull_request_review_id": null,
        "id": 24290735,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwNzM1",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestInotifyCloseRightAway(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Close immediately; it won't even reach the first syscall.Read.\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLater(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Wait until readEvents has reached syscall.Read, and Close.\n+\t<-time.After(50 * time.Millisecond)\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLaterWithWatch(t *testing.T) {\n+\ttestDir := tempMkdir(t)\n+\tdefer os.RemoveAll(testDir)\n+\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\tw.Add(\"testDir\")",
        "path": "inotify_test.go",
        "position": 53,
        "original_position": 53,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ok, thanks.\n",
        "created_at": "2015-02-07T17:06:54Z",
        "updated_at": "2015-02-07T17:06:54Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290735",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290735"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290735"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290849",
        "pull_request_review_id": null,
        "id": 24290849,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwODQ5",
        "diff_hunk": "@@ -116,6 +136,21 @@ func (w *Watcher) Remove(name string) error {\n \treturn nil\n }\n \n+// Called from Close(); remove all watches.\n+func (w *Watcher) removeAll() int {\n+\tsuccessful := 0\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\tfor name, watch := range w.watches {\n+\t\tsuccess, _ := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": 113,
        "original_position": 113,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Don't we still need to remove things from our internal map? Otherwise a later Add will think it's already being watched.\n",
        "created_at": "2015-02-07T17:23:09Z",
        "updated_at": "2015-02-07T17:23:09Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290849",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290849"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290849"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290854",
        "pull_request_review_id": null,
        "id": 24290854,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwODU0",
        "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestInotifyCloseRightAway(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Close immediately; it won't even reach the first syscall.Read.\n+\tw.Close()\n+\n+\t// Wait for the close to complete.\n+\t<-time.After(50 * time.Millisecond)\n+\tisWatcherReallyClosed(t, w)\n+}\n+\n+func TestInotifyCloseSlightlyLater(t *testing.T) {\n+\tw, err := NewWatcher()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create watcher\")\n+\t}\n+\n+\t// Wait until readEvents has reached syscall.Read, and Close.\n+\t<-time.After(50 * time.Millisecond)",
        "path": "inotify_test.go",
        "position": 37,
        "original_position": 37,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Not really.\n",
        "created_at": "2015-02-07T17:23:41Z",
        "updated_at": "2015-02-07T17:23:41Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290854",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290854"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290854"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290932",
        "pull_request_review_id": null,
        "id": 24290932,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkwOTMy",
        "diff_hunk": "@@ -116,6 +136,21 @@ func (w *Watcher) Remove(name string) error {\n \treturn nil\n }\n \n+// Called from Close(); remove all watches.\n+func (w *Watcher) removeAll() int {\n+\tsuccessful := 0\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\tfor name, watch := range w.watches {\n+\t\tsuccess, _ := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": 113,
        "original_position": 113,
        "commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "original_commit_id": "39ff4d1c4608874d28b2a4161ba7612e40c22c3f",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We only use removeAll when we've already closed.\n\nAh, and we do need watches for the inotify handles. Sorry.\n",
        "created_at": "2015-02-07T17:31:04Z",
        "updated_at": "2015-02-07T17:31:04Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290932",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24290932"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/63#discussion_r24290932"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/63"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292488",
        "pull_request_review_id": null,
        "id": 24292488,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNDg4",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 28,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think InotifyInit should remain in NewWatcher and pass the fd into newFdPoller.\n",
        "created_at": "2015-02-07T20:19:55Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292488",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292488"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292488"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292511",
        "pull_request_review_id": null,
        "id": 24292511,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNTEx",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()\n+\tif poller.fd == -1 {\n+\t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 30,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I found that wrapping with NewSyscallError breaks comparisons with the underlying error. Ended up removing them in 719fef588d53f4ccdf94803732cc34a6097ce1b7 but I missed this one.\n",
        "created_at": "2015-02-07T20:23:07Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292511",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292511"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292511"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292539",
        "pull_request_review_id": null,
        "id": 24292539,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNTM5",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()\n+\tif poller.fd == -1 {\n+\t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)\n+\t}\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\tsyscall.Close(poller.fd)\n+\t\treturn nil, os.NewSyscallError(\"epoll_create\", errno)\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 39,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": ":lipstick: Should this be `err` rather than `errno` in this case?\n",
        "created_at": "2015-02-07T20:25:22Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292539",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292539"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292539"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292565",
        "pull_request_review_id": null,
        "id": 24292565,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNTY1",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 28,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Likewise, NewWatcher should be responsible for closing the inotify fd if poller has an error.\n\nPoller could in theory work for any fd passed in and only clean up its own resources.\n",
        "created_at": "2015-02-07T20:29:16Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292565",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292565"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292565"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292581",
        "pull_request_review_id": null,
        "id": 24292581,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNTgx",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()\n+\tif poller.fd == -1 {\n+\t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)\n+\t}\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\tsyscall.Close(poller.fd)\n+\t\treturn nil, os.NewSyscallError(\"epoll_create\", errno)\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 39,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Maybe for EpollCtl too?\n",
        "created_at": "2015-02-07T20:32:14Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292581",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292581"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292581"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292607",
        "pull_request_review_id": null,
        "id": 24292607,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNjA3",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()\n+\tif poller.fd == -1 {\n+\t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)\n+\t}\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\tsyscall.Close(poller.fd)\n+\t\treturn nil, os.NewSyscallError(\"epoll_create\", errno)\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\treturn nil, os.NewSyscallError(\"pipe\", errno)\n+\t}\n+\n+\t// Register inotify fd with epoll\n+\tevent := syscall.EpollEvent{\n+\t\tFd:     int32(poller.fd),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.fd, &event)\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\tsyscall.Close(poller.pipe[0])\n+\t\tsyscall.Close(poller.pipe[1])\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", errno)\n+\t}\n+\n+\t// Register pipe fd with epoll\n+\tevent = syscall.EpollEvent{\n+\t\tFd:     int32(poller.pipe[0]),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.pipe[0], &event)\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 67,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "maybe cleanup could be put in a `defer func() {}` that checks if err is != nil and calls close()? Might be cleaner, maybe not. `close` would need to handle pipe not yet being setup and stuff like that.\n\nNot that the duplication is too terrible. :stuck_out_tongue_winking_eye: \n",
        "created_at": "2015-02-07T20:34:12Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292607",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292607"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292607"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292643",
        "pull_request_review_id": null,
        "id": 24292643,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNjQz",
        "diff_hunk": "@@ -188,10 +184,14 @@ func (w *Watcher) readEvents() {\n \t\t\treturn\n \t\t}\n \n-\t\t// If EOF is received\n+\t\t// If EOF is received. This should really never happen.",
        "path": "inotify.go",
        "position": null,
        "original_position": 163,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": ":heart: :hear_no_evil: \n",
        "created_at": "2015-02-07T20:38:14Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292643",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292643"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292643"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292659",
        "pull_request_review_id": null,
        "id": 24292659,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyNjU5",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()\n+\tif poller.fd == -1 {\n+\t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)\n+\t}\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\tsyscall.Close(poller.fd)\n+\t\treturn nil, os.NewSyscallError(\"epoll_create\", errno)\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\treturn nil, os.NewSyscallError(\"pipe\", errno)\n+\t}\n+\n+\t// Register inotify fd with epoll\n+\tevent := syscall.EpollEvent{\n+\t\tFd:     int32(poller.fd),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.fd, &event)\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\tsyscall.Close(poller.pipe[0])\n+\t\tsyscall.Close(poller.pipe[1])\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", errno)\n+\t}\n+\n+\t// Register pipe fd with epoll\n+\tevent = syscall.EpollEvent{\n+\t\tFd:     int32(poller.pipe[0]),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.pipe[0], &event)\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\tsyscall.Close(poller.pipe[0])\n+\t\tsyscall.Close(poller.pipe[1])\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", errno)\n+\t}\n+\n+\treturn poller, nil\n+}\n+\n+// Wait using epoll, then read from inotify.\n+// Returns true if something is ready to be read,\n+// false if there is not.\n+func (poller *fdPoller) wait() (bool, error) {\n+\tevents := make([]syscall.EpollEvent, 7)",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 81,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "why 7?\n",
        "created_at": "2015-02-07T20:39:20Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292659",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292659"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292659"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292990",
        "pull_request_review_id": null,
        "id": 24292990,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkyOTkw",
        "diff_hunk": "@@ -0,0 +1,181 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller() (*fdPoller, error) {\n+\tvar errno error\n+\tpoller := new(fdPoller)\n+\n+\t// Create inotify fd\n+\tpoller.fd, errno = syscall.InotifyInit()\n+\tif poller.fd == -1 {\n+\t\treturn nil, os.NewSyscallError(\"inotify_init\", errno)\n+\t}\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\tsyscall.Close(poller.fd)\n+\t\treturn nil, os.NewSyscallError(\"epoll_create\", errno)\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\treturn nil, os.NewSyscallError(\"pipe\", errno)\n+\t}\n+\n+\t// Register inotify fd with epoll\n+\tevent := syscall.EpollEvent{\n+\t\tFd:     int32(poller.fd),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.fd, &event)\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\tsyscall.Close(poller.pipe[0])\n+\t\tsyscall.Close(poller.pipe[1])\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", errno)\n+\t}\n+\n+\t// Register pipe fd with epoll\n+\tevent = syscall.EpollEvent{\n+\t\tFd:     int32(poller.pipe[0]),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.pipe[0], &event)\n+\tif errno != nil {\n+\t\tsyscall.Close(poller.fd)\n+\t\tsyscall.Close(poller.epfd)\n+\t\tsyscall.Close(poller.pipe[0])\n+\t\tsyscall.Close(poller.pipe[1])\n+\t\treturn nil, os.NewSyscallError(\"epoll_ctl\", errno)\n+\t}\n+\n+\treturn poller, nil\n+}\n+\n+// Wait using epoll, then read from inotify.\n+// Returns true if something is ready to be read,\n+// false if there is not.\n+func (poller *fdPoller) wait() (bool, error) {\n+\tevents := make([]syscall.EpollEvent, 7)",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 81,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "384d09e1b82c912202d6dece528e978e3d0292a9",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "There should be 3 possible events for each fd; hangup, error, and input. With two events, that's 6 maximum events if they all come in at once.\n\nI don't know if epoll returns the number of events it wrote to the buffer, or the number of events TOTAL. But I'm catching both by making the buffer one larger than the maximum amount of events.\n\nThis should probably be a comment.\n",
        "created_at": "2015-02-07T21:17:14Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292990",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24292990"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24292990"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293799",
        "pull_request_review_id": null,
        "id": 24293799,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzNzk5",
        "diff_hunk": "@@ -19,28 +20,39 @@ import (\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n-\tEvents  chan Event\n-\tErrors  chan error\n-\tmu      sync.Mutex        // Map access\n-\tfd      int               // File descriptor (as returned by the inotify_init() syscall)\n-\twatches map[string]*watch // Map of inotify watches (key: path)\n-\tpaths   map[int]string    // Map of watched paths (key: watch descriptor)\n-\tdone    chan struct{}     // Channel for sending a \"quit message\" to the reader goroutine\n+\tEvents   chan Event\n+\tErrors   chan error\n+\tmu       sync.Mutex // Map access\n+\tfd       int\n+\tpoller   *fdPoller\n+\twatches  map[string]*watch // Map of inotify watches (key: path)\n+\tpaths    map[int]string    // Map of watched paths (key: watch descriptor)\n+\tdone     chan struct{}     // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneresp chan struct{}     // Channel to respond to Close",
        "path": "inotify.go",
        "position": null,
        "original_position": 27,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "a2be4cf96907cfebe9dd11282331eeabdad3ef96",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Maybe `doneResp` instead? Or `doneResposne`?\n\nI was thinking of sending a signal one way over the done channel and then sending one back, but that won't work if the first signal is to close. Looking at the code more closely, I think we need to keep the two separate channels.\n",
        "created_at": "2015-02-07T23:04:38Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293799",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293799"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293799"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293813",
        "pull_request_review_id": null,
        "id": 24293813,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzODEz",
        "diff_hunk": "@@ -175,6 +167,20 @@ func (w *Watcher) readEvents() {\n \t\t\treturn\n \t\t}\n \n+\t\tok, errno = w.poller.wait()\n+\t\tif errno != nil {\n+\t\t\tselect {",
        "path": "inotify.go",
        "position": 158,
        "original_position": 146,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "a2be4cf96907cfebe9dd11282331eeabdad3ef96",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm starting to wonder if we should have a helper function to send an `error` down the channel or err/abort if done.\n",
        "created_at": "2015-02-07T23:06:37Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293813",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293813"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293813"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293907",
        "pull_request_review_id": null,
        "id": 24293907,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTA3",
        "diff_hunk": "@@ -0,0 +1,161 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller(fd int) (poller *fdPoller, errno error) {\n+\tpoller = new(fdPoller)\n+\tdefer func() {\n+\t\tif errno != nil {\n+\t\t\tpoller.close()\n+\t\t}\n+\t}()\n+\tpoller.fd = fd\n+\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\treturn nil, errno\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Register inotify fd with epoll\n+\tevent := syscall.EpollEvent{\n+\t\tFd:     int32(poller.fd),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.fd, &event)\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Register pipe fd with epoll\n+\tevent = syscall.EpollEvent{\n+\t\tFd:     int32(poller.pipe[0]),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.pipe[0], &event)\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\treturn poller, nil\n+}\n+\n+// Wait using epoll, then read from inotify.",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 65,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "035939db7976151f7f21cb3055949c9fcbaaceee",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "~~then read form inotify~~\n",
        "created_at": "2015-02-07T23:20:45Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293907",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293907"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293907"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293931",
        "pull_request_review_id": null,
        "id": 24293931,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTMx",
        "diff_hunk": "@@ -0,0 +1,161 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller(fd int) (poller *fdPoller, errno error) {\n+\tpoller = new(fdPoller)\n+\tdefer func() {\n+\t\tif errno != nil {\n+\t\t\tpoller.close()\n+\t\t}\n+\t}()\n+\tpoller.fd = fd\n+\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\treturn nil, errno\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Register inotify fd with epoll\n+\tevent := syscall.EpollEvent{\n+\t\tFd:     int32(poller.fd),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.fd, &event)\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Register pipe fd with epoll\n+\tevent = syscall.EpollEvent{\n+\t\tFd:     int32(poller.pipe[0]),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.pipe[0], &event)\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\treturn poller, nil\n+}\n+\n+// Wait using epoll, then read from inotify.\n+// Returns true if something is ready to be read,\n+// false if there is not.\n+func (poller *fdPoller) wait() (bool, error) {\n+\t// 3 possible events per fd, and 2 fds, makes a maximum of 6 events.\n+\t// I don't know whether epoll_wait returns the number of events returned,\n+\t// or the total number of events ready.\n+\t// I decided to catch both by making the buffer one larger than the maximum.\n+\tevents := make([]syscall.EpollEvent, 7)\n+\tfor {\n+\t\tn, errno := syscall.EpollWait(poller.epfd, events, -1)\n+\t\tif n == -1 {\n+\t\t\tif errno == syscall.EINTR {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn false, errno\n+\t\t}\n+\t\tif n == 0 {\n+\t\t\t// If there are no events, try again.\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n > 6 {\n+\t\t\t// This should never happen. More events were returned than should be possible.\n+\t\t\treturn false, errors.New(\"epoll_wait returned more events than I know what to do with\")\n+\t\t}\n+\t\tready := events[:n]\n+\t\tepollhup := false\n+\t\tepollerr := false\n+\t\tepollin := false\n+\t\tfor _, event := range ready {\n+\t\t\tif event.Fd == int32(poller.fd) {\n+\t\t\t\tif event.Events&syscall.EPOLLHUP != 0 {\n+\t\t\t\t\t// This should not happen, but if it does, treat it as a wakeup.\n+\t\t\t\t\tepollhup = true\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLERR != 0 {\n+\t\t\t\t\t// If an error is waiting on the file descriptor, we should pretend\n+\t\t\t\t\t// something is ready to read, and let syscall.Read pick up the error.\n+\t\t\t\t\tepollerr = true\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLIN != 0 {\n+\t\t\t\t\t// There is data to read.\n+\t\t\t\t\tepollin = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif event.Fd == int32(poller.pipe[0]) {\n+\t\t\t\tif event.Events&syscall.EPOLLHUP != 0 {\n+\t\t\t\t\t// Write pipe descriptor was closed, by us. This means we're closing down the\n+\t\t\t\t\t// watcher, and we should wake up.\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLERR != 0 {\n+\t\t\t\t\t// If an error is waiting on the pipe file descriptor.\n+\t\t\t\t\t// This is an absolute mystery, and should never ever happen.\n+\t\t\t\t\treturn false, errors.New(\"Error on the pipe descriptor.\")\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLIN != 0 {\n+\t\t\t\t\t// This is a regular wakeup, so we have to clear the buffer.\n+\t\t\t\t\terr := poller.clearWake()\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn false, err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif epollhup || epollerr || epollin {\n+\t\t\treturn true, nil\n+\t\t}\n+\t\treturn false, nil\n+\t}\n+}\n+\n+// Close the write end of the poller.\n+func (poller *fdPoller) wake() error {\n+\tbuf := make([]byte, 1)\n+\tn, errno := syscall.Write(poller.pipe[1], buf)\n+\tif n == -1 {\n+\t\treturn errno\n+\t}\n+\treturn nil\n+}\n+\n+func (poller *fdPoller) clearWake() error {\n+\tbuf := make([]byte, 100)\n+\tn, errno := syscall.Read(poller.pipe[0], buf)\n+\tif n == -1 {\n+\t\treturn errno\n+\t}\n+\treturn nil\n+}\n+\n+// Close all poller file descriptors, but not the one passed to it.\n+func (poller *fdPoller) close() {\n+\tsyscall.Close(poller.pipe[1])",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 158,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "035939db7976151f7f21cb3055949c9fcbaaceee",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "if EpollCreate fails then pipe hasn't been used it. Is this going to break?\n",
        "created_at": "2015-02-07T23:22:43Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293931",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293931"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293931"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293938",
        "pull_request_review_id": null,
        "id": 24293938,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTM4",
        "diff_hunk": "@@ -0,0 +1,161 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller(fd int) (poller *fdPoller, errno error) {\n+\tpoller = new(fdPoller)\n+\tdefer func() {\n+\t\tif errno != nil {\n+\t\t\tpoller.close()\n+\t\t}\n+\t}()\n+\tpoller.fd = fd\n+\n+\t// Create epoll fd\n+\tpoller.epfd, errno = syscall.EpollCreate(1)\n+\tif poller.epfd == -1 {\n+\t\treturn nil, errno\n+\t}\n+\t// Create pipe; pipe[0] is the read end, pipe[1] the write end.\n+\terrno = syscall.Pipe(poller.pipe[:])\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Register inotify fd with epoll\n+\tevent := syscall.EpollEvent{\n+\t\tFd:     int32(poller.fd),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.fd, &event)\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Register pipe fd with epoll\n+\tevent = syscall.EpollEvent{\n+\t\tFd:     int32(poller.pipe[0]),\n+\t\tEvents: syscall.EPOLLIN,\n+\t}\n+\terrno = syscall.EpollCtl(poller.epfd, syscall.EPOLL_CTL_ADD, poller.pipe[0], &event)\n+\tif errno != nil {\n+\t\treturn nil, errno\n+\t}\n+\n+\treturn poller, nil\n+}\n+\n+// Wait using epoll, then read from inotify.\n+// Returns true if something is ready to be read,\n+// false if there is not.\n+func (poller *fdPoller) wait() (bool, error) {\n+\t// 3 possible events per fd, and 2 fds, makes a maximum of 6 events.\n+\t// I don't know whether epoll_wait returns the number of events returned,\n+\t// or the total number of events ready.\n+\t// I decided to catch both by making the buffer one larger than the maximum.\n+\tevents := make([]syscall.EpollEvent, 7)\n+\tfor {\n+\t\tn, errno := syscall.EpollWait(poller.epfd, events, -1)\n+\t\tif n == -1 {\n+\t\t\tif errno == syscall.EINTR {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn false, errno\n+\t\t}\n+\t\tif n == 0 {\n+\t\t\t// If there are no events, try again.\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n > 6 {\n+\t\t\t// This should never happen. More events were returned than should be possible.\n+\t\t\treturn false, errors.New(\"epoll_wait returned more events than I know what to do with\")\n+\t\t}\n+\t\tready := events[:n]\n+\t\tepollhup := false\n+\t\tepollerr := false\n+\t\tepollin := false\n+\t\tfor _, event := range ready {\n+\t\t\tif event.Fd == int32(poller.fd) {\n+\t\t\t\tif event.Events&syscall.EPOLLHUP != 0 {\n+\t\t\t\t\t// This should not happen, but if it does, treat it as a wakeup.\n+\t\t\t\t\tepollhup = true\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLERR != 0 {\n+\t\t\t\t\t// If an error is waiting on the file descriptor, we should pretend\n+\t\t\t\t\t// something is ready to read, and let syscall.Read pick up the error.\n+\t\t\t\t\tepollerr = true\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLIN != 0 {\n+\t\t\t\t\t// There is data to read.\n+\t\t\t\t\tepollin = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif event.Fd == int32(poller.pipe[0]) {\n+\t\t\t\tif event.Events&syscall.EPOLLHUP != 0 {\n+\t\t\t\t\t// Write pipe descriptor was closed, by us. This means we're closing down the\n+\t\t\t\t\t// watcher, and we should wake up.\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLERR != 0 {\n+\t\t\t\t\t// If an error is waiting on the pipe file descriptor.\n+\t\t\t\t\t// This is an absolute mystery, and should never ever happen.\n+\t\t\t\t\treturn false, errors.New(\"Error on the pipe descriptor.\")\n+\t\t\t\t}\n+\t\t\t\tif event.Events&syscall.EPOLLIN != 0 {\n+\t\t\t\t\t// This is a regular wakeup, so we have to clear the buffer.\n+\t\t\t\t\terr := poller.clearWake()\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn false, err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif epollhup || epollerr || epollin {\n+\t\t\treturn true, nil\n+\t\t}\n+\t\treturn false, nil\n+\t}\n+}\n+\n+// Close the write end of the poller.\n+func (poller *fdPoller) wake() error {\n+\tbuf := make([]byte, 1)\n+\tn, errno := syscall.Write(poller.pipe[1], buf)\n+\tif n == -1 {\n+\t\treturn errno\n+\t}\n+\treturn nil\n+}\n+\n+func (poller *fdPoller) clearWake() error {\n+\tbuf := make([]byte, 100)",
        "path": "inotify_poller.go",
        "position": null,
        "original_position": 148,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "035939db7976151f7f21cb3055949c9fcbaaceee",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "why 100? :smirk: \n",
        "created_at": "2015-02-07T23:23:10Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293938",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293938"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293938"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293953",
        "pull_request_review_id": null,
        "id": 24293953,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTUz",
        "diff_hunk": "@@ -0,0 +1,221 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+type testFd [2]int\n+\n+func makeTestFd(t *testing.T) testFd {\n+\tvar tfd testFd\n+\terrno := syscall.Pipe(tfd[:])\n+\tif errno != nil {\n+\t\tt.Fatalf(\"Failed to create pipe: %v\", errno)\n+\t}\n+\treturn tfd\n+}\n+\n+func (tfd testFd) fd() int {\n+\treturn tfd[0]\n+}\n+\n+func (tfd testFd) closeWrite(t *testing.T) {\n+\terrno := syscall.Close(tfd[1])\n+\tif errno != nil {\n+\t\tt.Fatalf(\"Failed to close write end of pipe: %v\", errno)\n+\t}\n+}\n+\n+func (tfd testFd) put(t *testing.T) {\n+\tbuf := make([]byte, 10)\n+\t_, errno := syscall.Write(tfd[1], buf)\n+\tif errno != nil {\n+\t\tt.Fatalf(\"Failed to write to pipe: %v\", errno)\n+\t}\n+}\n+\n+func (tfd testFd) get(t *testing.T) {\n+\tbuf := make([]byte, 10)\n+\t_, errno := syscall.Read(tfd[0], buf)\n+\tif errno != nil {\n+\t\tt.Fatalf(\"Failed to write from pipe: %v\", errno)",
        "path": "inotify_poller_test.go",
        "position": null,
        "original_position": 49,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "035939db7976151f7f21cb3055949c9fcbaaceee",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "read\n",
        "created_at": "2015-02-07T23:24:40Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293953",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293953"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293953"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293970",
        "pull_request_review_id": null,
        "id": 24293970,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTcw",
        "diff_hunk": "@@ -0,0 +1,161 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller(fd int) (_ *fdPoller, errno error) {",
        "path": "inotify_poller.go",
        "position": 31,
        "original_position": 22,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "63adf2d12fc32ea6f5bf903d40f486191e6bcd4b",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "no need for the `_`\n",
        "created_at": "2015-02-07T23:30:25Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293970",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293970"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293970"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293980",
        "pull_request_review_id": null,
        "id": 24293980,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTgw",
        "diff_hunk": "@@ -0,0 +1,161 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller(fd int) (_ *fdPoller, errno error) {",
        "path": "inotify_poller.go",
        "position": 31,
        "original_position": 22,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "63adf2d12fc32ea6f5bf903d40f486191e6bcd4b",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh. Mixing named and unamed. Mind you errno isn't really needed here for readability of the API. Could move it to var.\n",
        "created_at": "2015-02-07T23:34:04Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293980",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293980"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293980"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293989",
        "pull_request_review_id": null,
        "id": 24293989,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjkzOTg5",
        "diff_hunk": "@@ -0,0 +1,161 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package fsnotify\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+type fdPoller struct {\n+\tfd   int    // File descriptor (as returned by the inotify_init() syscall)\n+\tepfd int    // Epoll file descriptor\n+\tpipe [2]int // Pipe for waking up\n+}\n+\n+// Create a new inotify poller.\n+// This creates an inotify handler, and an epoll handler.\n+func newFdPoller(fd int) (_ *fdPoller, errno error) {",
        "path": "inotify_poller.go",
        "position": 31,
        "original_position": 22,
        "commit_id": "ab25aa3138832d596c2ac57e8ec1203dcb7f9a52",
        "original_commit_id": "63adf2d12fc32ea6f5bf903d40f486191e6bcd4b",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "But it is required to reference the return value in the deferred function two lines below.\n",
        "created_at": "2015-02-07T23:35:47Z",
        "updated_at": "2015-02-08T02:50:57Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293989",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/24293989"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/66#discussion_r24293989"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26414081",
        "pull_request_review_id": null,
        "id": 26414081,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NDE0MDgx",
        "diff_hunk": "@@ -132,20 +134,19 @@ func (w *Watcher) Remove(name string) error {\n \tif !ok {\n \t\treturn fmt.Errorf(\"can't remove non-existent inotify watch for: %s\", name)\n \t}\n-\t// inotify_rm_watch will return EINVAL if the file has been deleted;\n-\t// the inotify will already have been removed.\n-\t// That means we can safely delete it from our watches, whatever inotify_rm_watch does.",
        "path": "inotify.go",
        "position": null,
        "original_position": 22,
        "commit_id": "6fe7b20ac08c0cd5a456e7a212d992bfd48e31fd",
        "original_commit_id": "d04deab4598aded1f79989332f2b7c8c8b6785fd",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Not a big fan that all these comments were removed.\n",
        "created_at": "2015-03-13T19:04:05Z",
        "updated_at": "2015-03-16T00:32:32Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26414081",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26414081"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26414081"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26414107",
        "pull_request_review_id": null,
        "id": 26414107,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NDE0MTA3",
        "diff_hunk": "@@ -132,20 +134,19 @@ func (w *Watcher) Remove(name string) error {\n \tif !ok {\n \t\treturn fmt.Errorf(\"can't remove non-existent inotify watch for: %s\", name)\n \t}\n-\t// inotify_rm_watch will return EINVAL if the file has been deleted;\n-\t// the inotify will already have been removed.\n-\t// That means we can safely delete it from our watches, whatever inotify_rm_watch does.\n-\tdelete(w.watches, name)\n \tsuccess, errno := syscall.InotifyRmWatch(w.fd, watch.wd)\n \tif success == -1 {\n-\t\t// TODO: Perhaps it's not helpful to return an error here in every case.\n-\t\t// the only two possible errors are:\n-\t\t// EBADF, which happens when w.fd is not a valid file descriptor of any kind.\n-\t\t// EINVAL, which is when fd is not an inotify descriptor or wd is not a valid watch descriptor.\n-\t\t// Watch descriptors are invalidated when they are removed explicitly or implicitly;\n-\t\t// explicitly by inotify_rm_watch, implicitly when the file they are watching is deleted.\n \t\treturn errno",
        "path": "inotify.go",
        "position": null,
        "original_position": 32,
        "commit_id": "6fe7b20ac08c0cd5a456e7a212d992bfd48e31fd",
        "original_commit_id": "d04deab4598aded1f79989332f2b7c8c8b6785fd",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Or these\n",
        "created_at": "2015-03-13T19:04:27Z",
        "updated_at": "2015-03-16T00:32:32Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26414107",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26414107"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26414107"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26414205",
        "pull_request_review_id": null,
        "id": 26414205,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NDE0MjA1",
        "diff_hunk": "@@ -132,20 +134,19 @@ func (w *Watcher) Remove(name string) error {\n \tif !ok {\n \t\treturn fmt.Errorf(\"can't remove non-existent inotify watch for: %s\", name)\n \t}\n-\t// inotify_rm_watch will return EINVAL if the file has been deleted;\n-\t// the inotify will already have been removed.\n-\t// That means we can safely delete it from our watches, whatever inotify_rm_watch does.\n-\tdelete(w.watches, name)\n \tsuccess, errno := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": null,
        "original_position": 24,
        "commit_id": "6fe7b20ac08c0cd5a456e7a212d992bfd48e31fd",
        "original_commit_id": "d04deab4598aded1f79989332f2b7c8c8b6785fd",
        "user": {
            "login": "PieterD",
            "id": 821733,
            "node_id": "MDQ6VXNlcjgyMTczMw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/821733?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PieterD",
            "html_url": "https://github.com/PieterD",
            "followers_url": "https://api.github.com/users/PieterD/followers",
            "following_url": "https://api.github.com/users/PieterD/following{/other_user}",
            "gists_url": "https://api.github.com/users/PieterD/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/PieterD/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/PieterD/subscriptions",
            "organizations_url": "https://api.github.com/users/PieterD/orgs",
            "repos_url": "https://api.github.com/users/PieterD/repos",
            "events_url": "https://api.github.com/users/PieterD/events{/privacy}",
            "received_events_url": "https://api.github.com/users/PieterD/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oops! Was this a race condition? Looks like :)\n",
        "created_at": "2015-03-13T19:05:30Z",
        "updated_at": "2015-03-16T00:32:32Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26414205",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26414205"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26414205"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26431467",
        "pull_request_review_id": null,
        "id": 26431467,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NDMxNDY3",
        "diff_hunk": "@@ -132,20 +134,19 @@ func (w *Watcher) Remove(name string) error {\n \tif !ok {\n \t\treturn fmt.Errorf(\"can't remove non-existent inotify watch for: %s\", name)\n \t}\n-\t// inotify_rm_watch will return EINVAL if the file has been deleted;\n-\t// the inotify will already have been removed.\n-\t// That means we can safely delete it from our watches, whatever inotify_rm_watch does.\n-\tdelete(w.watches, name)\n \tsuccess, errno := syscall.InotifyRmWatch(w.fd, watch.wd)",
        "path": "inotify.go",
        "position": null,
        "original_position": 24,
        "commit_id": "6fe7b20ac08c0cd5a456e7a212d992bfd48e31fd",
        "original_commit_id": "d04deab4598aded1f79989332f2b7c8c8b6785fd",
        "user": {
            "login": "chamaken",
            "id": 4514661,
            "node_id": "MDQ6VXNlcjQ1MTQ2NjE=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/4514661?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/chamaken",
            "html_url": "https://github.com/chamaken",
            "followers_url": "https://api.github.com/users/chamaken/followers",
            "following_url": "https://api.github.com/users/chamaken/following{/other_user}",
            "gists_url": "https://api.github.com/users/chamaken/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/chamaken/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/chamaken/subscriptions",
            "organizations_url": "https://api.github.com/users/chamaken/orgs",
            "repos_url": "https://api.github.com/users/chamaken/repos",
            "events_url": "https://api.github.com/users/chamaken/events{/privacy}",
            "received_events_url": "https://api.github.com/users/chamaken/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Would you tell me a story?\n",
        "created_at": "2015-03-13T23:57:05Z",
        "updated_at": "2015-03-16T00:32:32Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26431467",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/26431467"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/73#discussion_r26431467"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/73"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45122033",
        "pull_request_review_id": null,
        "id": 45122033,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMDMz",
        "diff_hunk": "@@ -153,7 +154,8 @@ var keventWaitTime = durationToTimespec(100 * time.Millisecond)\n \n // addWatch adds name to the watched file set.\n // The flags are interpreted as described in kevent(2).\n-func (w *Watcher) addWatch(name string, flags uint32) error {\n+// Returns the real path to the file which was added, if any, which may be different from the one passed in the case of symlinks.",
        "path": "kqueue.go",
        "position": 15,
        "original_position": 15,
        "commit_id": "4dc42d07d916c3aa2a40614372f2925e59420b9e",
        "original_commit_id": "190ad62e4dd847e2e1fcec89b818e519de9cb1ec",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't see where this new return value is being used.\n",
        "created_at": "2015-11-17T21:16:30Z",
        "updated_at": "2015-11-17T21:24:20Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45122033",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45122033"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45122033"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45122190",
        "pull_request_review_id": null,
        "id": 45122190,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMTkw",
        "diff_hunk": "@@ -195,18 +197,26 @@ func (w *Watcher) addWatch(name string, flags uint32) error {\n \t\tif fi.Mode()&os.ModeSymlink == os.ModeSymlink {\n \t\t\tname, err = filepath.EvalSymlinks(name)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil\n+\t\t\t\treturn \"\", nil\n \t\t\t}\n \n \t\t\tfi, err = os.Lstat(name)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil\n+\t\t\t\treturn \"\", nil\n+\t\t\t}\n+\n+\t\t\tw.mu.Lock()\n+\t\t\t_, alreadyWatching = w.watches[name]",
        "path": "kqueue.go",
        "position": 59,
        "original_position": 65,
        "commit_id": "4dc42d07d916c3aa2a40614372f2925e59420b9e",
        "original_commit_id": "190ad62e4dd847e2e1fcec89b818e519de9cb1ec",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": ":+1: \n\nthis check could probably even come before the Lstat.\n",
        "created_at": "2015-11-17T21:17:42Z",
        "updated_at": "2015-11-17T21:24:20Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45122190",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45122190"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45122190"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45123193",
        "pull_request_review_id": null,
        "id": 45123193,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTkz",
        "diff_hunk": "@@ -153,7 +154,8 @@ var keventWaitTime = durationToTimespec(100 * time.Millisecond)\n \n // addWatch adds name to the watched file set.\n // The flags are interpreted as described in kevent(2).\n-func (w *Watcher) addWatch(name string, flags uint32) error {\n+// Returns the real path to the file which was added, if any, which may be different from the one passed in the case of symlinks.",
        "path": "kqueue.go",
        "position": 15,
        "original_position": 15,
        "commit_id": "4dc42d07d916c3aa2a40614372f2925e59420b9e",
        "original_commit_id": "190ad62e4dd847e2e1fcec89b818e519de9cb1ec",
        "user": {
            "login": "illicitonion",
            "id": 1131704,
            "node_id": "MDQ6VXNlcjExMzE3MDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/1131704?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/illicitonion",
            "html_url": "https://github.com/illicitonion",
            "followers_url": "https://api.github.com/users/illicitonion/followers",
            "following_url": "https://api.github.com/users/illicitonion/following{/other_user}",
            "gists_url": "https://api.github.com/users/illicitonion/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/illicitonion/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/illicitonion/subscriptions",
            "organizations_url": "https://api.github.com/users/illicitonion/orgs",
            "repos_url": "https://api.github.com/users/illicitonion/repos",
            "events_url": "https://api.github.com/users/illicitonion/events{/privacy}",
            "received_events_url": "https://api.github.com/users/illicitonion/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Lines 378 and 384\n",
        "created_at": "2015-11-17T21:24:42Z",
        "updated_at": "2015-11-17T21:24:42Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45123193",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45123193"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45123193"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45123200",
        "pull_request_review_id": null,
        "id": 45123200,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjAw",
        "diff_hunk": "@@ -195,18 +197,26 @@ func (w *Watcher) addWatch(name string, flags uint32) error {\n \t\tif fi.Mode()&os.ModeSymlink == os.ModeSymlink {\n \t\t\tname, err = filepath.EvalSymlinks(name)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil\n+\t\t\t\treturn \"\", nil\n \t\t\t}\n \n \t\t\tfi, err = os.Lstat(name)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil\n+\t\t\t\treturn \"\", nil\n+\t\t\t}\n+\n+\t\t\tw.mu.Lock()\n+\t\t\t_, alreadyWatching = w.watches[name]",
        "path": "kqueue.go",
        "position": 59,
        "original_position": 65,
        "commit_id": "4dc42d07d916c3aa2a40614372f2925e59420b9e",
        "original_commit_id": "190ad62e4dd847e2e1fcec89b818e519de9cb1ec",
        "user": {
            "login": "illicitonion",
            "id": 1131704,
            "node_id": "MDQ6VXNlcjExMzE3MDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/1131704?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/illicitonion",
            "html_url": "https://github.com/illicitonion",
            "followers_url": "https://api.github.com/users/illicitonion/followers",
            "following_url": "https://api.github.com/users/illicitonion/following{/other_user}",
            "gists_url": "https://api.github.com/users/illicitonion/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/illicitonion/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/illicitonion/subscriptions",
            "organizations_url": "https://api.github.com/users/illicitonion/orgs",
            "repos_url": "https://api.github.com/users/illicitonion/repos",
            "events_url": "https://api.github.com/users/illicitonion/events{/privacy}",
            "received_events_url": "https://api.github.com/users/illicitonion/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Done\n",
        "created_at": "2015-11-17T21:24:46Z",
        "updated_at": "2015-11-17T21:24:46Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45123200",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45123200"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45123200"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45125946",
        "pull_request_review_id": null,
        "id": 45125946,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1OTQ2",
        "diff_hunk": "@@ -153,7 +154,8 @@ var keventWaitTime = durationToTimespec(100 * time.Millisecond)\n \n // addWatch adds name to the watched file set.\n // The flags are interpreted as described in kevent(2).\n-func (w *Watcher) addWatch(name string, flags uint32) error {\n+// Returns the real path to the file which was added, if any, which may be different from the one passed in the case of symlinks.",
        "path": "kqueue.go",
        "position": 15,
        "original_position": 15,
        "commit_id": "4dc42d07d916c3aa2a40614372f2925e59420b9e",
        "original_commit_id": "190ad62e4dd847e2e1fcec89b818e519de9cb1ec",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Gotcha. Thanks.\n",
        "created_at": "2015-11-17T21:44:49Z",
        "updated_at": "2015-11-17T21:44:49Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45125946",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/45125946"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/101#discussion_r45125946"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/101"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50351262",
        "pull_request_review_id": null,
        "id": 50351262,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMjYy",
        "diff_hunk": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9,!solaris,!windows\n+\n+// Package fsnotify provides a platform-independent interface for file system notifications.\n+package fsnotify\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestOpStringify(t *testing.T) {\n+\tif Create.String() != \"Create\" {\n+\t\tt.Fatalf(\"Stringify failed for: Create Op.\")",
        "path": "fsnotify_test.go",
        "position": null,
        "original_position": 16,
        "commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "original_commit_id": "f45b88e9df5da251ec22b7d4a9b7be1ac2a151c8",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You can just use t.Error() in this test, reporting on any errors rather than failing immediately. \n",
        "created_at": "2016-01-21T01:54:08Z",
        "updated_at": "2016-01-21T04:31:14Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50351262",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50351262"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50351262"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50351336",
        "pull_request_review_id": null,
        "id": 50351336,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMzM2",
        "diff_hunk": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9,!solaris,!windows\n+\n+// Package fsnotify provides a platform-independent interface for file system notifications.\n+package fsnotify\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestOpStringify(t *testing.T) {\n+\tif Create.String() != \"Create\" {\n+\t\tt.Fatalf(\"Stringify failed for: Create Op.\")\n+\t}\n+\tif Write.String() != \"Write\" {\n+\t\tt.Fatalf(\"Stringify failed for: Write Op.\")\n+\t}\n+\tif Remove.String() != \"Remove\" {\n+\t\tt.Fatalf(\"Stringify failed for: Remove Op.\")\n+\t}\n+\tif Rename.String() != \"Rename\" {\n+\t\tt.Fatalf(\"Stringify failed for: Rename Op.\")\n+\t}\n+\tif Chmod.String() != \"Chmod\" {\n+\t\tt.Fatalf(\"Stringify failed for: Chmod Op.\")\n+\t}\n+}\n+\n+func TestEventStringify(t *testing.T) {\n+\te0 := &Event{\"foo0\", 0}\n+\t// TODO: while the foo0 output is consistent with the previous",
        "path": "fsnotify_test.go",
        "position": null,
        "original_position": 34,
        "commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "original_commit_id": "f45b88e9df5da251ec22b7d4a9b7be1ac2a151c8",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Feel free to come up with more elegant output. No need to uppercase them.\n",
        "created_at": "2016-01-21T01:54:56Z",
        "updated_at": "2016-01-21T04:31:14Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50351336",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50351336"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50351336"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50351433",
        "pull_request_review_id": null,
        "id": 50351433,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNDMz",
        "diff_hunk": "@@ -4,3 +4,4 @@\n \n .vagrant\n *.sublime-project\n+*_stringer.go",
        "path": ".gitignore",
        "position": null,
        "original_position": 4,
        "commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "original_commit_id": "f45b88e9df5da251ec22b7d4a9b7be1ac2a151c8",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "please check in op_stringer.go instead of excluding the file.\n\nplease don't use go generate on Travis either.\n\nplease read https://blog.golang.org/generate for more information.\n",
        "created_at": "2016-01-21T01:56:34Z",
        "updated_at": "2016-01-21T04:31:14Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50351433",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50351433"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50351433"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50364622",
        "pull_request_review_id": null,
        "id": 50364622,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NjIy",
        "diff_hunk": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9,!solaris,!windows",
        "path": "fsnotify_test.go",
        "position": 5,
        "original_position": 5,
        "commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "original_commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "why not on Windows?\n",
        "created_at": "2016-01-21T06:25:11Z",
        "updated_at": "2016-01-21T06:25:11Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50364622",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50364622"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50364622"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50364678",
        "pull_request_review_id": null,
        "id": 50364678,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0Njc4",
        "diff_hunk": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9,!solaris,!windows\n+\n+// Package fsnotify provides a platform-independent interface for file system notifications.\n+package fsnotify\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestOpStringify(t *testing.T) {\n+\tif Create.String() != \"Create\" {\n+\t\tt.Error(\"Stringify failed for: Create Op.\")\n+\t}\n+\tif Write.String() != \"Write\" {\n+\t\tt.Error(\"Stringify failed for: Write Op.\")\n+\t}\n+\tif Remove.String() != \"Remove\" {\n+\t\tt.Error(\"Stringify failed for: Remove Op.\")\n+\t}\n+\tif Rename.String() != \"Rename\" {\n+\t\tt.Error(\"Stringify failed for: Rename Op.\")\n+\t}\n+\tif Chmod.String() != \"Chmod\" {\n+\t\tt.Error(\"Stringify failed for: Chmod Op.\")\n+\t}\n+}\n+\n+func TestEventStringify(t *testing.T) {\n+\te0 := &Event{\"foo0\", 0}\n+\tif s1, s2 := `\"foo0\": nil`, e0.String(); s1 != s2 {\n+\t\tt.Errorf(\"Stringify expected: `%s`; got: `%s`.\", s1, s2)\n+\t}\n+\te1 := &Event{\"foo1\", Chmod}\n+\tif s1, s2 := `\"foo1\": Chmod`, e1.String(); s1 != s2 {\n+\t\tt.Errorf(\"Stringify expected: `%s`; got: `%s`.\", s1, s2)\n+\t}\n+\te2 := &Event{\"foo2\", Write + Chmod}\n+\tif s1, s2 := `\"foo2\": Write|Chmod`, e2.String(); s1 != s2 {\n+\t\tt.Errorf(\"Stringify expected: `%s`; got: `%s`.\", s1, s2)\n+\t}\n+\te3 := &Event{\"foo3\", Create + Write + Remove + Rename + Chmod}",
        "path": "fsnotify_test.go",
        "position": 45,
        "original_position": 45,
        "commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "original_commit_id": "b580a4ed762f00607c290aa2593fd9a3897a9c69",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Even though + works, I think using bitwise & makes more sense because they are bits. :smile:\n",
        "created_at": "2016-01-21T06:26:35Z",
        "updated_at": "2016-01-21T06:26:44Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50364678",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/50364678"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/113#discussion_r50364678"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/113"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/60174571",
        "pull_request_review_id": null,
        "id": 60174571,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTc0NTcx",
        "diff_hunk": "@@ -23,7 +23,7 @@ type Watcher struct {\n \tErrors chan error\n \tdone   chan bool // Channel for sending a \"quit message\" to the reader goroutine\n \n-\tkq int // File descriptor (as returned by the kqueue() syscall).\n+\tkq int // File descriptor (as returned by the kqueue() unix..",
        "path": "kqueue.go",
        "position": null,
        "original_position": 14,
        "commit_id": "2a1fda269079c5593cc55fd58ab9b85503839b81",
        "original_commit_id": "bd338d7083519e3e91b8c1ee3c6da35f1831729f",
        "user": {
            "login": "anthonyfok",
            "id": 1274764,
            "node_id": "MDQ6VXNlcjEyNzQ3NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/1274764?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/anthonyfok",
            "html_url": "https://github.com/anthonyfok",
            "followers_url": "https://api.github.com/users/anthonyfok/followers",
            "following_url": "https://api.github.com/users/anthonyfok/following{/other_user}",
            "gists_url": "https://api.github.com/users/anthonyfok/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/anthonyfok/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/anthonyfok/subscriptions",
            "organizations_url": "https://api.github.com/users/anthonyfok/orgs",
            "repos_url": "https://api.github.com/users/anthonyfok/repos",
            "events_url": "https://api.github.com/users/anthonyfok/events{/privacy}",
            "received_events_url": "https://api.github.com/users/anthonyfok/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "One too many \"syscall\" string is changed to \"unix\" here in this comment?  :grin: \n",
        "created_at": "2016-04-19T05:25:41Z",
        "updated_at": "2016-04-19T08:11:13Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/135#discussion_r60174571",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/135",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/60174571"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/135#discussion_r60174571"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/135"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81890883",
        "pull_request_review_id": 2837564,
        "id": 81890883,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODkwODgz",
        "diff_hunk": "@@ -36,7 +37,7 @@ type Watcher struct {\n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n \t// Create inotify fd\n-\tfd, errno := unix.InotifyInit()\n+\tfd, errno := unix.InotifyInit1(syscall.IN_CLOEXEC)",
        "path": "inotify.go",
        "position": 13,
        "original_position": 13,
        "commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "original_commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We need to be careful with this change, possibly testing it manually as Travis CI doesn't give us coverage of `arm` and `ppc64` architectures that fsnotify currently supports.\n",
        "created_at": "2016-10-05T02:16:55Z",
        "updated_at": "2016-10-05T02:27:08Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81890883",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81890883"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81890883"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81890952",
        "pull_request_review_id": 2837564,
        "id": 81890952,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODkwOTUy",
        "diff_hunk": "@@ -157,92 +156,105 @@ func TestInotifyCloseCreate(t *testing.T) {\n func TestInotifyStress(t *testing.T) {\n \ttestDir := tempMkdir(t)\n \tdefer os.RemoveAll(testDir)\n-\ttestFile := filepath.Join(testDir, \"testfile\")\n+\ttestFilePrefix := filepath.Join(testDir, \"testfile\")\n \n \tw, err := NewWatcher()\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to create watcher: %v\", err)\n \t}\n \tdefer w.Close()\n \n-\tkillchan := make(chan struct{})\n-\tdefer close(killchan)\n-\n \terr = w.Add(testDir)\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to add testDir: %v\", err)\n \t}\n \n-\tproc, err := os.FindProcess(os.Getpid())\n-\tif err != nil {\n-\t\tt.Fatalf(\"Error finding process: %v\", err)\n-\t}\n+\tkillChan := make(chan struct{})\n+\tdefer close(killChan)\n \n-\tgo func() {\n-\t\tfor {\n-\t\t\tselect {\n-\t\t\tcase <-time.After(5 * time.Millisecond):\n-\t\t\t\terr := proc.Signal(unix.SIGUSR1)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Signal failed: %v\", err)\n-\t\t\t\t}\n-\t\t\tcase <-killchan:\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}()\n+\tdoneChan := make(chan struct{})\n+\terrChan := make(chan error, 1000)",
        "path": "inotify_test.go",
        "position": 54,
        "original_position": 54,
        "commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "original_commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "does this channel need to be buffered?\n",
        "created_at": "2016-10-05T02:18:01Z",
        "updated_at": "2016-10-05T02:27:08Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81890952",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81890952"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81890952"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81891037",
        "pull_request_review_id": 2837564,
        "id": 81891037,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODkxMDM3",
        "diff_hunk": "@@ -157,92 +156,105 @@ func TestInotifyCloseCreate(t *testing.T) {\n func TestInotifyStress(t *testing.T) {\n \ttestDir := tempMkdir(t)\n \tdefer os.RemoveAll(testDir)\n-\ttestFile := filepath.Join(testDir, \"testfile\")\n+\ttestFilePrefix := filepath.Join(testDir, \"testfile\")\n \n \tw, err := NewWatcher()\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to create watcher: %v\", err)\n \t}\n \tdefer w.Close()\n \n-\tkillchan := make(chan struct{})\n-\tdefer close(killchan)\n-\n \terr = w.Add(testDir)\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to add testDir: %v\", err)\n \t}\n \n-\tproc, err := os.FindProcess(os.Getpid())\n-\tif err != nil {\n-\t\tt.Fatalf(\"Error finding process: %v\", err)\n-\t}\n+\tkillChan := make(chan struct{})\n+\tdefer close(killChan)\n \n-\tgo func() {\n-\t\tfor {\n-\t\t\tselect {\n-\t\t\tcase <-time.After(5 * time.Millisecond):\n-\t\t\t\terr := proc.Signal(unix.SIGUSR1)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Signal failed: %v\", err)\n-\t\t\t\t}\n-\t\t\tcase <-killchan:\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}()\n+\tdoneChan := make(chan struct{})\n+\terrChan := make(chan error, 1000)\n \n \tgo func() {\n+\t\tafter := time.After(3 * time.Second)\n+\t\ti := 0\n \t\tfor {\n \t\t\tselect {\n-\t\t\tcase <-time.After(11 * time.Millisecond):\n-\t\t\t\terr := w.poller.wake()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Wake failed: %v\", err)\n-\t\t\t\t}\n-\t\t\tcase <-killchan:\n+\t\t\tcase <-killChan:\n+\t\t\t\tclose(doneChan)\n \t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}()\n+\t\t\tcase <-after:\n+\t\t\t\tfor ; i > 0; i-- {\n+\t\t\t\t\ttestFile := fmt.Sprintf(\"%s%d\", testFilePrefix, i)\n+\t\t\t\t\terr = os.Remove(testFile)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\terrChan <- fmt.Errorf(\"Remove failed: %v\", err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttime.Sleep(time.Millisecond)",
        "path": "inotify_test.go",
        "position": 81,
        "original_position": 81,
        "commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "original_commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm curious why the 1ms sleep is needed.\n",
        "created_at": "2016-10-05T02:19:32Z",
        "updated_at": "2016-10-05T02:27:08Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81891037",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81891037"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81891037"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81891125",
        "pull_request_review_id": 2837564,
        "id": 81891125,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODkxMTI1",
        "diff_hunk": "@@ -36,7 +37,7 @@ type Watcher struct {\n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n \t// Create inotify fd\n-\tfd, errno := unix.InotifyInit()\n+\tfd, errno := unix.InotifyInit1(syscall.IN_CLOEXEC)",
        "path": "inotify.go",
        "position": 13,
        "original_position": 13,
        "commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "original_commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Hoping the Go team will help us out with that, but I'm not sure when they'll have time. https://github.com/golang/go/issues/17312\n",
        "created_at": "2016-10-05T02:21:04Z",
        "updated_at": "2016-10-05T02:27:08Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81891125",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81891125"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81891125"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174"
            }
        },
        "in_reply_to_id": 81890883
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81891446",
        "pull_request_review_id": 2837564,
        "id": 81891446,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODkxNDQ2",
        "diff_hunk": "@@ -157,92 +156,105 @@ func TestInotifyCloseCreate(t *testing.T) {\n func TestInotifyStress(t *testing.T) {\n \ttestDir := tempMkdir(t)\n \tdefer os.RemoveAll(testDir)\n-\ttestFile := filepath.Join(testDir, \"testfile\")\n+\ttestFilePrefix := filepath.Join(testDir, \"testfile\")\n \n \tw, err := NewWatcher()\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to create watcher: %v\", err)\n \t}\n \tdefer w.Close()\n \n-\tkillchan := make(chan struct{})\n-\tdefer close(killchan)\n-\n \terr = w.Add(testDir)\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to add testDir: %v\", err)\n \t}\n \n-\tproc, err := os.FindProcess(os.Getpid())\n-\tif err != nil {\n-\t\tt.Fatalf(\"Error finding process: %v\", err)\n-\t}\n+\tkillChan := make(chan struct{})\n+\tdefer close(killChan)\n \n-\tgo func() {\n-\t\tfor {\n-\t\t\tselect {\n-\t\t\tcase <-time.After(5 * time.Millisecond):\n-\t\t\t\terr := proc.Signal(unix.SIGUSR1)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Signal failed: %v\", err)\n-\t\t\t\t}\n-\t\t\tcase <-killchan:\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}()\n+\tdoneChan := make(chan struct{})\n+\terrChan := make(chan error, 1000)\n \n \tgo func() {\n+\t\tafter := time.After(3 * time.Second)\n+\t\ti := 0\n \t\tfor {\n \t\t\tselect {\n-\t\t\tcase <-time.After(11 * time.Millisecond):\n-\t\t\t\terr := w.poller.wake()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"Wake failed: %v\", err)\n-\t\t\t\t}\n-\t\t\tcase <-killchan:\n+\t\t\tcase <-killChan:\n+\t\t\t\tclose(doneChan)\n \t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}()\n+\t\t\tcase <-after:\n+\t\t\t\tfor ; i > 0; i-- {\n+\t\t\t\t\ttestFile := fmt.Sprintf(\"%s%d\", testFilePrefix, i)\n+\t\t\t\t\terr = os.Remove(testFile)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\terrChan <- fmt.Errorf(\"Remove failed: %v\", err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttime.Sleep(time.Millisecond)",
        "path": "inotify_test.go",
        "position": 81,
        "original_position": 81,
        "commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "original_commit_id": "3e9e138b2ebaf7480698fd6f14011d28d6250f38",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This stress test is pretty lengthy, so it might be nice to add a few more comments for future maintainers.\n",
        "created_at": "2016-10-05T02:26:37Z",
        "updated_at": "2016-10-05T02:27:08Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81891446",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81891446"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/174#discussion_r81891446"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/174"
            }
        },
        "in_reply_to_id": 81891037
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81896717",
        "pull_request_review_id": 2842923,
        "id": 81896717,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODk2NzE3",
        "diff_hunk": "@@ -36,7 +37,7 @@ type Watcher struct {\n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n \t// Create inotify fd\n-\tfd, errno := unix.InotifyInit()\n+\tfd, errno := unix.InotifyInit1(syscall.IN_CLOEXEC)",
        "path": "inotify.go",
        "position": null,
        "original_position": 13,
        "commit_id": "de4b113b9f5d6824fa696080bf3723484bb6e674",
        "original_commit_id": "6a484b417674743a46d108bc6e7d1c520d069641",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This should be `unix.IN_CLOEXEC` since `unix` is a more up-to-date version of the `syscall` package.\n",
        "created_at": "2016-10-05T03:49:04Z",
        "updated_at": "2016-10-05T03:51:37Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/178#discussion_r81896717",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/178",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/81896717"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/178#discussion_r81896717"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/178"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/83760873",
        "pull_request_review_id": 4582805,
        "id": 83760873,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgzNzYwODcz",
        "diff_hunk": "@@ -245,6 +245,15 @@ func (w *Watcher) readEvents() {\n \n \t\t\tmask := uint32(raw.Mask)\n \t\t\tnameLen := uint32(raw.Len)\n+\n+\t\t\tif mask&unix.IN_Q_OVERFLOW != 0 {\n+\t\t\t\tselect {\n+\t\t\t\tcase w.Errors <- errors.New(\"inotify queue overflow\"):",
        "path": "inotify.go",
        "position": null,
        "original_position": 7,
        "commit_id": "d3a56b4d3a5e05e379616dd322ec5bbeadc2ec31",
        "original_commit_id": "9ebc264811d1b462d31a22159cbb7d54d9e18364",
        "user": {
            "login": "tsuna",
            "id": 128281,
            "node_id": "MDQ6VXNlcjEyODI4MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/128281?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/tsuna",
            "html_url": "https://github.com/tsuna",
            "followers_url": "https://api.github.com/users/tsuna/followers",
            "following_url": "https://api.github.com/users/tsuna/following{/other_user}",
            "gists_url": "https://api.github.com/users/tsuna/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/tsuna/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/tsuna/subscriptions",
            "organizations_url": "https://api.github.com/users/tsuna/orgs",
            "repos_url": "https://api.github.com/users/tsuna/repos",
            "events_url": "https://api.github.com/users/tsuna/events{/privacy}",
            "received_events_url": "https://api.github.com/users/tsuna/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This needs to be a well-defined error otherwise it's not easy for client code to determine that this condition has occurred without inspecting the error string (gasp!).\n\nHow about something like:\n\n``` go\n  var ErrEventOverflow = errors.New(\"fsnotify queue overflow\")\n```\n\n(this needs to be placed in a platform-independent file)\n\nso that the client code than check `if err == fsnotify.ErrEventOverflow {`\n",
        "created_at": "2016-10-18T00:11:58Z",
        "updated_at": "2016-10-26T18:23:41Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/149#discussion_r83760873",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/149",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/83760873"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/149#discussion_r83760873"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/149"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/83766526",
        "pull_request_review_id": 4587884,
        "id": 83766526,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgzNzY2NTI2",
        "diff_hunk": "@@ -245,6 +245,15 @@ func (w *Watcher) readEvents() {\n \n \t\t\tmask := uint32(raw.Mask)\n \t\t\tnameLen := uint32(raw.Len)\n+\n+\t\t\tif mask&unix.IN_Q_OVERFLOW != 0 {\n+\t\t\t\tselect {\n+\t\t\t\tcase w.Errors <- errors.New(\"inotify queue overflow\"):",
        "path": "inotify.go",
        "position": null,
        "original_position": 7,
        "commit_id": "d3a56b4d3a5e05e379616dd322ec5bbeadc2ec31",
        "original_commit_id": "9ebc264811d1b462d31a22159cbb7d54d9e18364",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Agreed that we should change this. There is no precedent in the code right now, which contains several other errors that are just strings. I would be willing to merge this as is and improve error handling as a followup pull request.\n\nI do think that the error should report that it's the inotify queue that overflowed, as it isn't a queue that's part of fsnotify that had a problem.\n",
        "created_at": "2016-10-18T01:12:20Z",
        "updated_at": "2016-10-26T18:23:41Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/149#discussion_r83766526",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/149",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/83766526"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/149#discussion_r83766526"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/149"
            }
        },
        "in_reply_to_id": 83760873
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/83766891",
        "pull_request_review_id": 4588194,
        "id": 83766891,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgzNzY2ODkx",
        "diff_hunk": "@@ -245,6 +245,15 @@ func (w *Watcher) readEvents() {\n \n \t\t\tmask := uint32(raw.Mask)\n \t\t\tnameLen := uint32(raw.Len)\n+\n+\t\t\tif mask&unix.IN_Q_OVERFLOW != 0 {\n+\t\t\t\tselect {\n+\t\t\t\tcase w.Errors <- errors.New(\"inotify queue overflow\"):",
        "path": "inotify.go",
        "position": null,
        "original_position": 7,
        "commit_id": "d3a56b4d3a5e05e379616dd322ec5bbeadc2ec31",
        "original_commit_id": "9ebc264811d1b462d31a22159cbb7d54d9e18364",
        "user": {
            "login": "zeldovich",
            "id": 828308,
            "node_id": "MDQ6VXNlcjgyODMwOA==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/828308?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/zeldovich",
            "html_url": "https://github.com/zeldovich",
            "followers_url": "https://api.github.com/users/zeldovich/followers",
            "following_url": "https://api.github.com/users/zeldovich/following{/other_user}",
            "gists_url": "https://api.github.com/users/zeldovich/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/zeldovich/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/zeldovich/subscriptions",
            "organizations_url": "https://api.github.com/users/zeldovich/orgs",
            "repos_url": "https://api.github.com/users/zeldovich/repos",
            "events_url": "https://api.github.com/users/zeldovich/events{/privacy}",
            "received_events_url": "https://api.github.com/users/zeldovich/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Just FYI, the Windows code already has its own special way of handling overflows (see sysFSQOVERFLOW).  It might be worth unifying handling of overflow on Linux and Windows.  That said, I'm a bit swamped in the next week or two, so I'm unlikely to revise this patch until next month at the earliest.  It might make sense to merge this as-is (since it seems no worse than the current behavior), and perhaps unify overflow handling as a separate patch later.\n",
        "created_at": "2016-10-18T01:17:03Z",
        "updated_at": "2016-10-26T18:23:41Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/149#discussion_r83766891",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/149",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/83766891"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/149#discussion_r83766891"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/149"
            }
        },
        "in_reply_to_id": 83760873
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/86232279",
        "pull_request_review_id": 6900264,
        "id": 86232279,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg2MjMyMjc5",
        "diff_hunk": "@@ -41,6 +41,36 @@ Please refer to [CONTRIBUTING][] before opening an issue or pull request.\n \n See [example_test.go](https://github.com/fsnotify/fsnotify/blob/master/example_test.go).\n \n+## FAQ\n+\n+**When a file is moved to another directory is it still being watched?**\n+\n+No (it shouldn't be, unless you are watching where it was moved to).\n+\n+**When I watch a directory, are all subdirectories watched as well?**\n+\n+No, you must add watches for any directory you want to watch (a recursive watcher is in the works [#56][]).",
        "path": "README.md",
        "position": 21,
        "original_position": 21,
        "commit_id": "00337a47c1cdf11d3904437b32c70581b520da29",
        "original_commit_id": "00337a47c1cdf11d3904437b32c70581b520da29",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "we should change this to point to https://github.com/fsnotify/fsnotify/issues/18\n\n(sadly it's not in the works yet)\n",
        "created_at": "2016-11-02T20:14:22Z",
        "updated_at": "2016-11-02T20:14:22Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/186#discussion_r86232279",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/186",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/86232279"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/186#discussion_r86232279"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/186"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/86232473",
        "pull_request_review_id": 6900452,
        "id": 86232473,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg2MjMyNDcz",
        "diff_hunk": "@@ -41,6 +41,36 @@ Please refer to [CONTRIBUTING][] before opening an issue or pull request.\n \n See [example_test.go](https://github.com/fsnotify/fsnotify/blob/master/example_test.go).\n \n+## FAQ\n+\n+**When a file is moved to another directory is it still being watched?**\n+\n+No (it shouldn't be, unless you are watching where it was moved to).\n+\n+**When I watch a directory, are all subdirectories watched as well?**\n+\n+No, you must add watches for any directory you want to watch (a recursive watcher is in the works [#56][]).\n+\n+**Do I have to watch the Error and Event channels in a separate goroutine?**\n+\n+As of now, yes. Looking into making this single-thread friendly (see [#7][])\n+\n+**Why am I receiving multiple events for the same file on OS X?**\n+\n+Spotlight indexing on OS X can result in multiple events (see [#62][]). A temporary workaround is to add your folder(s) to the *Spotlight Privacy settings* until we have a native FSEvents implementation (see [#54][]).",
        "path": "README.md",
        "position": 29,
        "original_position": 29,
        "commit_id": "00337a47c1cdf11d3904437b32c70581b520da29",
        "original_commit_id": "00337a47c1cdf11d3904437b32c70581b520da29",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "FSEvents issue https://github.com/fsnotify/fsnotify/issues/11\n",
        "created_at": "2016-11-02T20:15:22Z",
        "updated_at": "2016-11-02T20:15:22Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/186#discussion_r86232473",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/186",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/86232473"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/186#discussion_r86232473"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/186"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/87697027",
        "pull_request_review_id": 8301744,
        "id": 87697027,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3Njk3MDI3",
        "diff_hunk": "@@ -0,0 +1,66 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+\t//\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)\n+\t\t\tnotifications += 1\n+\t\t\tcontinue\n+\t\tcase err := <-watcher.Errors:\n+\t\t\tlog.Println(\"error:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func writeFiles(dir string) {\n+\tindex := 0\n+\tfor {\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tif index > 10 {\n+\t\t\treturn\n+\t\t}\n+\t\tindex += 1",
        "path": "kqueue_test.go",
        "position": null,
        "original_position": 47,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "68caeccecc97c640d968f9e1031dde93be5f9b34",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should replace index += 1 with index++\n",
        "created_at": "2016-11-12T17:57:05Z",
        "updated_at": "2016-11-24T01:37:33Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r87697027",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/87697027"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r87697027"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/87697028",
        "pull_request_review_id": 8301745,
        "id": 87697028,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3Njk3MDI4",
        "diff_hunk": "@@ -0,0 +1,66 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+\t//\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)\n+\t\t\tnotifications += 1",
        "path": "kqueue_test.go",
        "position": null,
        "original_position": 31,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "68caeccecc97c640d968f9e1031dde93be5f9b34",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should replace notifications += 1 with notifications++\n",
        "created_at": "2016-11-12T17:57:05Z",
        "updated_at": "2016-11-24T01:37:33Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r87697028",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/87697028"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r87697028"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99492907",
        "pull_request_review_id": 20172613,
        "id": 99492907,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk5NDkyOTA3",
        "diff_hunk": "@@ -6,32 +6,274 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t from_file_obj(struct file_obj *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// struct file_obj*to_file_obj(uintptr_t ptr) {\n+//   return (struct file_obj*)ptr;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int\n+\twg   *sync.WaitGroup\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.struct_file_obj\n+\n+\tclosed bool\n }\n \n-// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.watches = make(map[string]*C.struct_file_obj)\n+\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tw.wg = new(sync.WaitGroup)\n+\tw.wg.Add(1)\n+\tgo w.run()\n+\n+\treturn w, nil\n }\n \n-// Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.closed {\n+\t\treturn nil\n+\t}\n+\tw.closed = true\n+\n+\tC.close(w.port)\n+\tw.wg.Wait()\n+\n+\tclose(w.Events)\n+\tclose(w.Errors)\n \treturn nil\n }\n \n-// Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n+}\n+\n+func (w *Watcher) Remove(path string) error {\n+\tif !w.watched(path) {\n+\t\treturn nil\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+func (w *Watcher) run() {\n+\tdefer w.wg.Done()\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\tif err.(syscall.Errno) == C.EBADF {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tw.Errors <- err\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfinfo := (*C.struct_file_info)(pevent.portev_user)\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, finfo)\n+\t\tif err != nil {\n+\t\t\tw.Errors <- err\n+\t\t}\n+\t}\n }\n \n-// Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// And finally handle the directory itself.\n+\treturn handler(path, stat)\n+}\n+\n+func (w *Watcher) handleEvent(obj C.uintptr_t, events C.int, finfo *C.struct_file_info) error {\n+\tfobj := C.to_file_obj(obj)\n+\tpath := C.GoString(fobj.fo_name)\n+\tfmode := os.FileMode(finfo.mode)\n+\n+\tswitch {\n+\tcase events&C.FILE_MODIFIED == C.FILE_MODIFIED:\n+\t\tif fmode.IsDir() {\n+\t\t\tif err := w.updateDirectory(path); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\tw.Events <- Event{path, Write}\n+\t\t}\n+\tcase events&C.FILE_ATTRIB == C.FILE_ATTRIB:\n+\t\tw.Events <- Event{path, Chmod}\n+\tcase events&C.FILE_DELETE == C.FILE_DELETE:\n+\t\tw.unwatch(path)\n+\t\tw.Events <- Event{path, Remove}\n+\t\treturn nil\n+\tcase events&C.FILE_RENAME_TO == C.FILE_RENAME_TO:\n+\t\tw.Events <- Event{path, Rename}\n+\tcase events&C.FILE_RENAME_FROM == C.FILE_RENAME_FROM:\n+\t\tw.Events <- Event{path, Rename}\n+\t\tw.unwatch(path)\n+\t\t// as the file was renamed to something else, the new\n+\t\t// file (based on something watched) will be be ignored\n+\t\treturn nil\n+\tdefault:\n+\t\treturn errors.New(\"unknown event received\")\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn w.associateFile(path, stat)\n+}\n+\n+func (w *Watcher) updateDirectory(path string) error {\n+\t// The directory was modified, find unwatched entites and\n+\t// watch them. If something was removed from the directory\n+\t// nothing will happen, as everything else should still be\n+\t// watched.\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor _, finfo := range files {\n+\t\tpath := filepath.Join(path, finfo.Name())\n+\t\tif w.watched(path) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr := w.associateFile(path, finfo)\n+\t\tif err != nil {\n+\t\t\tw.Errors <- err\n+\t\t}\n+\t\tw.Events <- Event{path, Create}\n+\t}\n \treturn nil\n }\n+\n+func (w *Watcher) associateFile(path string, stat os.FileInfo) error {\n+\tfobj := buildFileObj(path, stat)\n+\tw.watch(path, &fobj)\n+\n+\tvar finfo C.struct_file_info\n+\tfinfo.mode = C.uint(stat.Mode())\n+\n+\tvar mode C.int = C.FILE_MODIFIED | C.FILE_ATTRIB | C.FILE_NOFOLLOW",
        "path": "fen.go",
        "position": null,
        "original_position": 233,
        "commit_id": "f72044f20555dbd2a27fca59b366609483639818",
        "original_commit_id": "34a9f2ea15cd9e967fb5f566afd632f59c30a5cf",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should omit type C.int from declaration of var mode; it will be inferred from the right-hand side",
        "created_at": "2017-02-05T16:24:46Z",
        "updated_at": "2017-02-05T21:19:28Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99492907",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99492907"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99492907"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99492908",
        "pull_request_review_id": 20172614,
        "id": 99492908,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk5NDkyOTA4",
        "diff_hunk": "@@ -6,32 +6,274 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t from_file_obj(struct file_obj *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// struct file_obj*to_file_obj(uintptr_t ptr) {\n+//   return (struct file_obj*)ptr;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int\n+\twg   *sync.WaitGroup\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.struct_file_obj\n+\n+\tclosed bool\n }\n \n-// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.watches = make(map[string]*C.struct_file_obj)\n+\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tw.wg = new(sync.WaitGroup)\n+\tw.wg.Add(1)\n+\tgo w.run()\n+\n+\treturn w, nil\n }\n \n-// Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.closed {\n+\t\treturn nil\n+\t}\n+\tw.closed = true\n+\n+\tC.close(w.port)\n+\tw.wg.Wait()\n+\n+\tclose(w.Events)\n+\tclose(w.Errors)\n \treturn nil\n }\n \n-// Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n+}\n+\n+func (w *Watcher) Remove(path string) error {",
        "path": "fen.go",
        "position": null,
        "original_position": 99,
        "commit_id": "f72044f20555dbd2a27fca59b366609483639818",
        "original_commit_id": "34a9f2ea15cd9e967fb5f566afd632f59c30a5cf",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "exported method Watcher.Remove should have comment or be unexported",
        "created_at": "2017-02-05T16:24:46Z",
        "updated_at": "2017-02-05T21:19:28Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99492908",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99492908"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99492908"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99492909",
        "pull_request_review_id": 20172615,
        "id": 99492909,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk5NDkyOTA5",
        "diff_hunk": "@@ -6,32 +6,274 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t from_file_obj(struct file_obj *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// struct file_obj*to_file_obj(uintptr_t ptr) {\n+//   return (struct file_obj*)ptr;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int\n+\twg   *sync.WaitGroup\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.struct_file_obj\n+\n+\tclosed bool\n }\n \n-// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.watches = make(map[string]*C.struct_file_obj)\n+\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tw.wg = new(sync.WaitGroup)\n+\tw.wg.Add(1)\n+\tgo w.run()\n+\n+\treturn w, nil\n }\n \n-// Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.closed {\n+\t\treturn nil\n+\t}\n+\tw.closed = true\n+\n+\tC.close(w.port)\n+\tw.wg.Wait()\n+\n+\tclose(w.Events)\n+\tclose(w.Errors)\n \treturn nil\n }\n \n-// Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {",
        "path": "fen.go",
        "position": null,
        "original_position": 87,
        "commit_id": "f72044f20555dbd2a27fca59b366609483639818",
        "original_commit_id": "34a9f2ea15cd9e967fb5f566afd632f59c30a5cf",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "exported method Watcher.Add should have comment or be unexported",
        "created_at": "2017-02-05T16:24:46Z",
        "updated_at": "2017-02-05T21:19:28Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99492909",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99492909"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99492909"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99499648",
        "pull_request_review_id": 20178569,
        "id": 99499648,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk5NDk5NjQ4",
        "diff_hunk": "@@ -231,7 +231,7 @@ func (w *Watcher) associateFile(path string, stat os.FileInfo) error {\n \tvar finfo C.struct_file_info\n \tfinfo.mode = C.uint(stat.Mode())\n \n-\tvar mode C.int = C.FILE_MODIFIED | C.FILE_ATTRIB | C.FILE_NOFOLLOW\n+\tmode := C.FILE_MODIFIED | C.FILE_ATTRIB | C.FILE_NOFOLLOW",
        "path": "fen.go",
        "position": null,
        "original_position": 5,
        "commit_id": "f72044f20555dbd2a27fca59b366609483639818",
        "original_commit_id": "312ce4b06f1e918c80d2efee826f50ed6cf846b8",
        "user": {
            "login": "gfrey",
            "id": 519838,
            "node_id": "MDQ6VXNlcjUxOTgzOA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/519838?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/gfrey",
            "html_url": "https://github.com/gfrey",
            "followers_url": "https://api.github.com/users/gfrey/followers",
            "following_url": "https://api.github.com/users/gfrey/following{/other_user}",
            "gists_url": "https://api.github.com/users/gfrey/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/gfrey/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gfrey/subscriptions",
            "organizations_url": "https://api.github.com/users/gfrey/orgs",
            "repos_url": "https://api.github.com/users/gfrey/repos",
            "events_url": "https://api.github.com/users/gfrey/events{/privacy}",
            "received_events_url": "https://api.github.com/users/gfrey/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Well type inference doesn't seem to work as houndci-bot expected. Now I need to cast the usage of mode. Not sure I like that better. Will have a closer look later.",
        "created_at": "2017-02-05T21:01:33Z",
        "updated_at": "2017-02-05T21:19:28Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99499648",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/99499648"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/196#discussion_r99499648"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/196"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124446068",
        "pull_request_review_id": 46733587,
        "id": 124446068,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyNDQ0NjA2OA==",
        "diff_hunk": "@@ -71,10 +71,8 @@ func (w *Watcher) Close() error {\n \t\treturn nil\n \t}\n \tw.isClosed = true\n-\tw.mu.Unlock()\n \n \t// copy paths to remove while locked\n-\tw.mu.Lock()\n \tvar pathsToRemove = make([]string, 0, len(w.watches))\n \tfor name := range w.watches {",
        "path": "kqueue.go",
        "position": 27,
        "original_position": 27,
        "commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "original_commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "user": {
            "login": "omeid",
            "id": 1453118,
            "node_id": "MDQ6VXNlcjE0NTMxMTg=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1453118?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/omeid",
            "html_url": "https://github.com/omeid",
            "followers_url": "https://api.github.com/users/omeid/followers",
            "following_url": "https://api.github.com/users/omeid/following{/other_user}",
            "gists_url": "https://api.github.com/users/omeid/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/omeid/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/omeid/subscriptions",
            "organizations_url": "https://api.github.com/users/omeid/orgs",
            "repos_url": "https://api.github.com/users/omeid/repos",
            "events_url": "https://api.github.com/users/omeid/events{/privacy}",
            "received_events_url": "https://api.github.com/users/omeid/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The loop can be simply replaced with `pathsToRemove = append(pathsToRemove, w.watches...)`.",
        "created_at": "2017-06-28T03:35:30Z",
        "updated_at": "2017-06-28T03:35:31Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124446068",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124446068"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124446068"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124446116",
        "pull_request_review_id": 46733637,
        "id": 124446116,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyNDQ0NjExNg==",
        "diff_hunk": "@@ -71,10 +71,8 @@ func (w *Watcher) Close() error {\n \t\treturn nil\n \t}\n \tw.isClosed = true\n-\tw.mu.Unlock()\n \n \t// copy paths to remove while locked\n-\tw.mu.Lock()\n \tvar pathsToRemove = make([]string, 0, len(w.watches))\n \tfor name := range w.watches {",
        "path": "kqueue.go",
        "position": 27,
        "original_position": 27,
        "commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "original_commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "user": {
            "login": "omeid",
            "id": 1453118,
            "node_id": "MDQ6VXNlcjE0NTMxMTg=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1453118?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/omeid",
            "html_url": "https://github.com/omeid",
            "followers_url": "https://api.github.com/users/omeid/followers",
            "following_url": "https://api.github.com/users/omeid/following{/other_user}",
            "gists_url": "https://api.github.com/users/omeid/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/omeid/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/omeid/subscriptions",
            "organizations_url": "https://api.github.com/users/omeid/orgs",
            "repos_url": "https://api.github.com/users/omeid/repos",
            "events_url": "https://api.github.com/users/omeid/events{/privacy}",
            "received_events_url": "https://api.github.com/users/omeid/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "And I am not sure the make is really needed there, so the whole thing can be `pathsToRemove := append([]string{}, w.watches...)`.",
        "created_at": "2017-06-28T03:36:07Z",
        "updated_at": "2017-06-28T03:36:24Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124446116",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124446116"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124446116"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211"
            }
        },
        "in_reply_to_id": 124446068
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124447236",
        "pull_request_review_id": 46734893,
        "id": 124447236,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyNDQ0NzIzNg==",
        "diff_hunk": "@@ -71,10 +71,8 @@ func (w *Watcher) Close() error {\n \t\treturn nil\n \t}\n \tw.isClosed = true\n-\tw.mu.Unlock()\n \n \t// copy paths to remove while locked\n-\tw.mu.Lock()\n \tvar pathsToRemove = make([]string, 0, len(w.watches))\n \tfor name := range w.watches {",
        "path": "kqueue.go",
        "position": 27,
        "original_position": 27,
        "commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "original_commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "user": {
            "login": "tsuna",
            "id": 128281,
            "node_id": "MDQ6VXNlcjEyODI4MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/128281?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/tsuna",
            "html_url": "https://github.com/tsuna",
            "followers_url": "https://api.github.com/users/tsuna/followers",
            "following_url": "https://api.github.com/users/tsuna/following{/other_user}",
            "gists_url": "https://api.github.com/users/tsuna/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/tsuna/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/tsuna/subscriptions",
            "organizations_url": "https://api.github.com/users/tsuna/orgs",
            "repos_url": "https://api.github.com/users/tsuna/repos",
            "events_url": "https://api.github.com/users/tsuna/events{/privacy}",
            "received_events_url": "https://api.github.com/users/tsuna/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I thought the same thing initially but `w.watches` is a map, so we can't `append()` directly, we need to iterate over its keys.",
        "created_at": "2017-06-28T03:50:58Z",
        "updated_at": "2017-06-28T03:50:58Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124447236",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124447236"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124447236"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211"
            }
        },
        "in_reply_to_id": 124446068
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124447355",
        "pull_request_review_id": 46735019,
        "id": 124447355,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyNDQ0NzM1NQ==",
        "diff_hunk": "@@ -71,10 +71,8 @@ func (w *Watcher) Close() error {\n \t\treturn nil\n \t}\n \tw.isClosed = true\n-\tw.mu.Unlock()\n \n \t// copy paths to remove while locked\n-\tw.mu.Lock()\n \tvar pathsToRemove = make([]string, 0, len(w.watches))\n \tfor name := range w.watches {",
        "path": "kqueue.go",
        "position": 27,
        "original_position": 27,
        "commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "original_commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "user": {
            "login": "omeid",
            "id": 1453118,
            "node_id": "MDQ6VXNlcjE0NTMxMTg=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1453118?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/omeid",
            "html_url": "https://github.com/omeid",
            "followers_url": "https://api.github.com/users/omeid/followers",
            "following_url": "https://api.github.com/users/omeid/following{/other_user}",
            "gists_url": "https://api.github.com/users/omeid/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/omeid/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/omeid/subscriptions",
            "organizations_url": "https://api.github.com/users/omeid/orgs",
            "repos_url": "https://api.github.com/users/omeid/repos",
            "events_url": "https://api.github.com/users/omeid/events{/privacy}",
            "received_events_url": "https://api.github.com/users/omeid/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "That makes sense.",
        "created_at": "2017-06-28T03:52:40Z",
        "updated_at": "2017-06-28T03:52:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124447355",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/124447355"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r124447355"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211"
            }
        },
        "in_reply_to_id": 124446068
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/149981477",
        "pull_request_review_id": 75461373,
        "id": 149981477,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTk4MTQ3Nw==",
        "diff_hunk": "@@ -71,10 +71,8 @@ func (w *Watcher) Close() error {\n \t\treturn nil\n \t}\n \tw.isClosed = true\n-\tw.mu.Unlock()\n \n \t// copy paths to remove while locked\n-\tw.mu.Lock()\n \tvar pathsToRemove = make([]string, 0, len(w.watches))\n \tfor name := range w.watches {",
        "path": "kqueue.go",
        "position": 27,
        "original_position": 27,
        "commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "original_commit_id": "d4ce214df1cdb0751ab4d65daef77b2605334b99",
        "user": {
            "login": "cpuguy83",
            "id": 799078,
            "node_id": "MDQ6VXNlcjc5OTA3OA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/799078?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/cpuguy83",
            "html_url": "https://github.com/cpuguy83",
            "followers_url": "https://api.github.com/users/cpuguy83/followers",
            "following_url": "https://api.github.com/users/cpuguy83/following{/other_user}",
            "gists_url": "https://api.github.com/users/cpuguy83/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/cpuguy83/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/cpuguy83/subscriptions",
            "organizations_url": "https://api.github.com/users/cpuguy83/orgs",
            "repos_url": "https://api.github.com/users/cpuguy83/repos",
            "events_url": "https://api.github.com/users/cpuguy83/events{/privacy}",
            "received_events_url": "https://api.github.com/users/cpuguy83/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Make also ensures you make only one allocation for exactly what you need rather than continuously allocating on append (though append is smart and requests more than is needed to prevent multiple alloc requests)",
        "created_at": "2017-11-09T14:48:22Z",
        "updated_at": "2017-11-09T14:48:59Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r149981477",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/149981477"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/211#discussion_r149981477"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/211"
            }
        },
        "in_reply_to_id": 124446068
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158904980",
        "pull_request_review_id": 85774970,
        "id": 158904980,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNDk4MA==",
        "diff_hunk": "@@ -266,16 +264,24 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n func (w *Watcher) readEvents() {\n \teventBuffer := make([]unix.Kevent_t, 10)\n \n+\tdefer func() {\n+\t\t// cleanup\n+\t\terr := unix.Close(w.kq)\n+\t\tif err != nil {\n+\t\t\tselect {\n+\t\t\tcase w.Errors <- err:\n+\t\t\tcase <-w.done:",
        "path": "kqueue.go",
        "position": 32,
        "original_position": 32,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "given the only way this function can return is if `w.done` is closed, I think this should instead be the default case.",
        "created_at": "2017-12-28T07:03:52Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158904980",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158904980"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158904980"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905226",
        "pull_request_review_id": 85774970,
        "id": 158905226,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTIyNg==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)",
        "path": "kqueue_test.go",
        "position": 13,
        "original_position": 13,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "debugging line should be removed.",
        "created_at": "2017-12-28T07:06:58Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905226",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905226"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905226"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905248",
        "pull_request_review_id": 85774970,
        "id": 158905248,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTI0OA==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)\n+\t\t\tnotifications++\n+\t\t\tcontinue\n+\t\tcase err := <-watcher.Errors:\n+\t\t\tlog.Println(\"error:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func writeFiles(dir string) {\n+\tindex := 0\n+\tfor {\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tif index > 10 {\n+\t\t\treturn\n+\t\t}\n+\t\tindex++\n+\t}\n+}\n+func TestWatcherClose(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"./\", \"example\")\n+\tif err != nil {\n+\t\tpanic(err)",
        "path": "kqueue_test.go",
        "position": 50,
        "original_position": 50,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "this panic and the others should be t.Fatal",
        "created_at": "2017-12-28T07:07:17Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905248",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905248"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905248"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905346",
        "pull_request_review_id": 85774970,
        "id": 158905346,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTM0Ng==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)\n+\t\t\tnotifications++\n+\t\t\tcontinue\n+\t\tcase err := <-watcher.Errors:\n+\t\t\tlog.Println(\"error:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func writeFiles(dir string) {\n+\tindex := 0\n+\tfor {\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tif index > 10 {\n+\t\t\treturn\n+\t\t}\n+\t\tindex++\n+\t}\n+}\n+func TestWatcherClose(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"./\", \"example\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tvar wg sync.WaitGroup\n+\twatcher, err := NewWatcher()\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\terr = watcher.Add(dir)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\t_, err = ioutil.TempFile(dir, \"example\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tioutil.TempFile(dir, \"example\")",
        "path": "kqueue_test.go",
        "position": 65,
        "original_position": 65,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "extraneous line.",
        "created_at": "2017-12-28T07:08:16Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905346",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905346"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905346"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905372",
        "pull_request_review_id": 85774970,
        "id": 158905372,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTM3Mg==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)\n+\t\t\tnotifications++\n+\t\t\tcontinue\n+\t\tcase err := <-watcher.Errors:\n+\t\t\tlog.Println(\"error:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func writeFiles(dir string) {\n+\tindex := 0\n+\tfor {\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tif index > 10 {\n+\t\t\treturn\n+\t\t}\n+\t\tindex++\n+\t}\n+}\n+func TestWatcherClose(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"./\", \"example\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tvar wg sync.WaitGroup\n+\twatcher, err := NewWatcher()\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\terr = watcher.Add(dir)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\t_, err = ioutil.TempFile(dir, \"example\")",
        "path": "kqueue_test.go",
        "position": 61,
        "original_position": 61,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "unnecessary line.",
        "created_at": "2017-12-28T07:08:37Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905372",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905372"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905372"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905464",
        "pull_request_review_id": 85774970,
        "id": 158905464,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTQ2NA==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")",
        "path": "kqueue_test.go",
        "position": 17,
        "original_position": 17,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "debugging line.",
        "created_at": "2017-12-28T07:09:42Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905464",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905464"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905464"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905496",
        "pull_request_review_id": 85774970,
        "id": 158905496,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTQ5Ng==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")",
        "path": "kqueue_test.go",
        "position": 22,
        "original_position": 22,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "debugging line.",
        "created_at": "2017-12-28T07:09:55Z",
        "updated_at": "2017-12-28T07:20:06Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905496",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905496"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905496"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905528",
        "pull_request_review_id": 85774970,
        "id": 158905528,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTUyOA==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)",
        "path": "kqueue_test.go",
        "position": 27,
        "original_position": 27,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should use `t.Log`.",
        "created_at": "2017-12-28T07:10:13Z",
        "updated_at": "2017-12-28T07:20:07Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905528",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905528"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905528"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905667",
        "pull_request_review_id": 85774970,
        "id": 158905667,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTY2Nw==",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+package fsnotify\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+func consumeEvent(t *testing.T, watcher *Watcher, wg *sync.WaitGroup) {\n+\tdefer func() {\n+\t\t//time.Sleep(time.Second)\n+\t\twatcher.Close()\n+\t\twg.Done()\n+\t}()\n+\tlog.Println(\"Came here\")\n+\tnotifications := 0\n+\tmaxNotifications := 1\n+\tfor {\n+\t\tif notifications >= maxNotifications {\n+\t\t\tlog.Println(\"Reached max notifications\")\n+\t\t\treturn\n+\t\t}\n+\t\tselect {\n+\t\tcase event := <-watcher.Events:\n+\t\t\tlog.Println(\"event:\", event)\n+\t\t\tnotifications++\n+\t\t\tcontinue\n+\t\tcase err := <-watcher.Errors:\n+\t\t\tlog.Println(\"error:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func writeFiles(dir string) {\n+\tindex := 0\n+\tfor {\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tioutil.TempFile(dir, \"example\")\n+\t\tif index > 10 {\n+\t\t\treturn\n+\t\t}\n+\t\tindex++\n+\t}\n+}\n+func TestWatcherClose(t *testing.T) {",
        "path": "kqueue_test.go",
        "position": 47,
        "original_position": 47,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "this test could be made much simpler. We just need the watcher to be listening on some file, modify the file and then close the watcher without listening on either the errors or events channels.",
        "created_at": "2017-12-28T07:12:00Z",
        "updated_at": "2017-12-28T07:20:07Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905667",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905667"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905667"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905846",
        "pull_request_review_id": 85774970,
        "id": 158905846,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODkwNTg0Ng==",
        "diff_hunk": "@@ -89,8 +87,8 @@ func (w *Watcher) Close() error {\n \t\t}\n \t}\n \n-\t// Send \"quit\" message to the reader goroutine:\n-\tw.done <- true\n+\t// send a \"quit\" message to the reader goroutine\n+\tclose(w.done)",
        "path": "kqueue.go",
        "position": 18,
        "original_position": 18,
        "commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "original_commit_id": "df405ac10f44db9d1bbb57b6ffcb1cb5166d146c",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "we should change w.done to be a `chan struct{}`.",
        "created_at": "2017-12-28T07:14:08Z",
        "updated_at": "2017-12-28T07:20:07Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905846",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/158905846"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/188#discussion_r158905846"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/188"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162136778",
        "pull_request_review_id": 89541595,
        "id": 162136778,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjEzNjc3OA==",
        "diff_hunk": "@@ -119,6 +121,16 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Clean(filepath.Dir(name))",
        "path": "kqueue.go",
        "position": null,
        "original_position": 21,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "8a767f3698e3a57734e38ce27778e35ed022080a",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I believe the filepath.Clean() is unneeded. From my look at https://golang.org/src/path/filepath/path.go?s=13376:13404#L452 it seems Dir() already cleans it.",
        "created_at": "2018-01-17T18:22:27Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162136778",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162136778"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162136778"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162138285",
        "pull_request_review_id": 89541595,
        "id": 162138285,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjEzODI4NQ==",
        "diff_hunk": "@@ -119,6 +121,16 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Clean(filepath.Dir(name))\n+\tparentWatches := w.watchesByDir[parentName]\n+\tfor i, fd := range parentWatches {\n+\t\tif fd == watchfd {\n+\t\t\tw.watchesByDir[parentName] = append(parentWatches[:i], parentWatches[i+1:]...)",
        "path": "kqueue.go",
        "position": null,
        "original_position": 25,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "8a767f3698e3a57734e38ce27778e35ed022080a",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "why don't we turn parentWatches into a `map[int]struct{}` or a `map[string]int`? then it'll be a lot easier to remove a child watch.",
        "created_at": "2018-01-17T18:27:49Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162138285",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162138285"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162138285"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162139451",
        "pull_request_review_id": 89541595,
        "id": 162139451,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjEzOTQ1MQ==",
        "diff_hunk": "@@ -231,7 +241,9 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Clean(filepath.Dir(name))",
        "path": "kqueue.go",
        "position": null,
        "original_position": 54,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "8a767f3698e3a57734e38ce27778e35ed022080a",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "no need for clean()",
        "created_at": "2018-01-17T18:32:33Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162139451",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162139451"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162139451"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162351",
        "pull_request_review_id": 89571787,
        "id": 162162351,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE2MjM1MQ==",
        "diff_hunk": "@@ -127,12 +136,10 @@ func (w *Watcher) Remove(name string) error {\n \tif isDir {\n \t\tvar pathsToRemove []string\n \t\tw.mu.Lock()\n-\t\tfor _, path := range w.paths {\n-\t\t\twdir, _ := filepath.Split(path.name)\n-\t\t\tif filepath.Clean(wdir) == name {\n-\t\t\t\tif !w.externalWatches[path.name] {\n-\t\t\t\t\tpathsToRemove = append(pathsToRemove, path.name)\n-\t\t\t\t}\n+\t\tfor fd, _ := range w.watchesByDir[name] {",
        "path": "kqueue.go",
        "position": null,
        "original_position": 54,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "3818e04f8ee85a947cc9c0b10a44dfb5eae030c4",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should omit 2nd value from range; this loop is equivalent to `for fd := range ...`",
        "created_at": "2018-01-17T19:57:23Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162351",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162351"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162351"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162360",
        "pull_request_review_id": 89571797,
        "id": 162162360,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE2MjM2MA==",
        "diff_hunk": "@@ -119,6 +121,16 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Clean(filepath.Dir(name))",
        "path": "kqueue.go",
        "position": null,
        "original_position": 21,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "8a767f3698e3a57734e38ce27778e35ed022080a",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "you're right! fixed",
        "created_at": "2018-01-17T19:57:24Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162360",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162360"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162360"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162136778
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162386",
        "pull_request_review_id": 89571826,
        "id": 162162386,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE2MjM4Ng==",
        "diff_hunk": "@@ -119,6 +121,16 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Clean(filepath.Dir(name))\n+\tparentWatches := w.watchesByDir[parentName]\n+\tfor i, fd := range parentWatches {\n+\t\tif fd == watchfd {\n+\t\t\tw.watchesByDir[parentName] = append(parentWatches[:i], parentWatches[i+1:]...)",
        "path": "kqueue.go",
        "position": null,
        "original_position": 25,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "8a767f3698e3a57734e38ce27778e35ed022080a",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done",
        "created_at": "2018-01-17T19:57:30Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162386",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162386"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162386"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162138285
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162419",
        "pull_request_review_id": 89571877,
        "id": 162162419,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE2MjQxOQ==",
        "diff_hunk": "@@ -231,7 +241,9 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Clean(filepath.Dir(name))",
        "path": "kqueue.go",
        "position": null,
        "original_position": 54,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "8a767f3698e3a57734e38ce27778e35ed022080a",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done",
        "created_at": "2018-01-17T19:57:38Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162419",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162162419"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162162419"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162139451
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162170126",
        "pull_request_review_id": 89581289,
        "id": 162170126,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE3MDEyNg==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir) == 0 {",
        "path": "kqueue.go",
        "position": null,
        "original_position": 37,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "4243f4651867aedff21225c184d6381e11666104",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "do we need this if statement?",
        "created_at": "2018-01-17T20:30:58Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162170126",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162170126"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162170126"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162194075",
        "pull_request_review_id": 89609564,
        "id": 162194075,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE5NDA3NQ==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir) == 0 {",
        "path": "kqueue.go",
        "position": null,
        "original_position": 37,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "4243f4651867aedff21225c184d6381e11666104",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "it depends on what you mean by \"need\"? i think it's a nice invariant that Remove inverts the state of Add",
        "created_at": "2018-01-17T22:08:34Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162194075",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162194075"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162194075"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162170126
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162194670",
        "pull_request_review_id": 89610261,
        "id": 162194670,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE5NDY3MA==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir) == 0 {",
        "path": "kqueue.go",
        "position": null,
        "original_position": 37,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "4243f4651867aedff21225c184d6381e11666104",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't understand. I don't see how we need the if statement, it doesn't seem to be really checking for anything relevant. If the length of watchersByDir is 0, then there is nothing to delete?",
        "created_at": "2018-01-17T22:11:12Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162194670",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162194670"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162194670"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162170126
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162194808",
        "pull_request_review_id": 89610440,
        "id": 162194808,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE5NDgwOA==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir[parentName]) == 0 {",
        "path": "kqueue.go",
        "position": null,
        "original_position": 37,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "412053d515d2c58df3f6954a369474044ddf8983",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Feel free to add more commits instead of amending so its easier for me to tell whats changed between reviews. We can squash at the end.",
        "created_at": "2018-01-17T22:11:50Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162194808",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162194808"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162194808"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162195180",
        "pull_request_review_id": 89610440,
        "id": 162195180,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjE5NTE4MA==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir[parentName]) == 0 {\n+\t\tdelete(w.watchesByDir, parentName)",
        "path": "kqueue.go",
        "position": null,
        "original_position": 38,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "412053d515d2c58df3f6954a369474044ddf8983",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Still not quite understanding the point of this. If the parentName has no child watches, why do we want to delete it from watchesByDir?",
        "created_at": "2018-01-17T22:13:30Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162195180",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162195180"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162195180"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162245121",
        "pull_request_review_id": 89667650,
        "id": 162245121,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjI0NTEyMQ==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir[parentName]) == 0 {\n+\t\tdelete(w.watchesByDir, parentName)",
        "path": "kqueue.go",
        "position": null,
        "original_position": 38,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "412053d515d2c58df3f6954a369474044ddf8983",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "_shrug_, i don't mind removing it.",
        "created_at": "2018-01-18T04:03:47Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162245121",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162245121"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162245121"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162195180
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162246086",
        "pull_request_review_id": 89668808,
        "id": 162246086,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjI0NjA4Ng==",
        "diff_hunk": "@@ -231,7 +235,16 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Dir(name)\n \t\tw.watches[name] = watchfd\n+\n+\t\twatchesByDir, ok := w.watchesByDir[parentName]\n+\t\tif !ok {\n+\t\t\twatchesByDir = make(map[int]struct{})",
        "path": "kqueue.go",
        "position": null,
        "original_position": 67,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "217b853db6a72616f6e2f32096318039c5691fa7",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "we can set the initial size of the map to 1 because we know we're going to insert one element.",
        "created_at": "2018-01-18T04:13:59Z",
        "updated_at": "2018-01-19T02:46:18Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162246086",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162246086"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162246086"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162526797",
        "pull_request_review_id": 89999705,
        "id": 162526797,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjUyNjc5Nw==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir[parentName]) == 0 {\n+\t\tdelete(w.watchesByDir, parentName)",
        "path": "kqueue.go",
        "position": null,
        "original_position": 38,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "412053d515d2c58df3f6954a369474044ddf8983",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "ok, i'll add it back?",
        "created_at": "2018-01-19T02:46:23Z",
        "updated_at": "2018-01-19T02:46:23Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162526797",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162526797"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162526797"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162195180
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162526812",
        "pull_request_review_id": 89999721,
        "id": 162526812,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjUyNjgxMg==",
        "diff_hunk": "@@ -231,7 +235,16 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Dir(name)\n \t\tw.watches[name] = watchfd\n+\n+\t\twatchesByDir, ok := w.watchesByDir[parentName]\n+\t\tif !ok {\n+\t\t\twatchesByDir = make(map[int]struct{})",
        "path": "kqueue.go",
        "position": null,
        "original_position": 67,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "217b853db6a72616f6e2f32096318039c5691fa7",
        "user": {
            "login": "nicks",
            "id": 278641,
            "node_id": "MDQ6VXNlcjI3ODY0MQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/278641?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nicks",
            "html_url": "https://github.com/nicks",
            "followers_url": "https://api.github.com/users/nicks/followers",
            "following_url": "https://api.github.com/users/nicks/following{/other_user}",
            "gists_url": "https://api.github.com/users/nicks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nicks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nicks/subscriptions",
            "organizations_url": "https://api.github.com/users/nicks/orgs",
            "repos_url": "https://api.github.com/users/nicks/repos",
            "events_url": "https://api.github.com/users/nicks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nicks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "oh, good point!",
        "created_at": "2018-01-19T02:46:30Z",
        "updated_at": "2018-01-19T02:46:30Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162526812",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162526812"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162526812"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162246086
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162245534",
        "pull_request_review_id": 89668160,
        "id": 162245534,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjI0NTUzNA==",
        "diff_hunk": "@@ -119,6 +121,13 @@ func (w *Watcher) Remove(name string) error {\n \tw.mu.Lock()\n \tisDir := w.paths[watchfd].isDir\n \tdelete(w.watches, name)\n+\n+\tparentName := filepath.Dir(name)\n+\tdelete(w.watchesByDir[parentName], watchfd)\n+\tif len(w.watchesByDir[parentName]) == 0 {\n+\t\tdelete(w.watchesByDir, parentName)",
        "path": "kqueue.go",
        "position": null,
        "original_position": 38,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "412053d515d2c58df3f6954a369474044ddf8983",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah I finally got the purpose of this. ~~We also need to check if the watchesByDir is empty for the current name and if so, to delete it there.~~ - no we don't because the watchesByDir by dir cannot be empty for the current name as if it was, it was already deleted.",
        "created_at": "2018-01-18T04:08:34Z",
        "updated_at": "2018-01-19T02:51:13Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162245534",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162245534"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162245534"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162195180
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162528091",
        "pull_request_review_id": 90001115,
        "id": 162528091,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjUyODA5MQ==",
        "diff_hunk": "@@ -231,7 +239,16 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Dir(name)\n \t\tw.watches[name] = watchfd\n+\n+\t\twatchesByDir, ok := w.watchesByDir[parentName]",
        "path": "kqueue.go",
        "position": 69,
        "original_position": 69,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "we don't need to do any of this stuff if `name` ends in the file separator as that means it is the root directory and the root directory as no parent. Likewise a similar thing should happen in Remove().\r\n\r\nWe could leave it and add a entry to the map anyway but just feels wrong to say the parent of the root is the root directory.",
        "created_at": "2018-01-19T02:58:54Z",
        "updated_at": "2018-01-19T02:59:30Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162528091",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162528091"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162528091"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162528240",
        "pull_request_review_id": 90001262,
        "id": 162528240,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjUyODI0MA==",
        "diff_hunk": "@@ -231,7 +239,16 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Dir(name)\n \t\tw.watches[name] = watchfd\n+\n+\t\twatchesByDir, ok := w.watchesByDir[parentName]",
        "path": "kqueue.go",
        "position": 69,
        "original_position": 69,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You know what, I just realized thats how it works. If you type `cd ..` at the root of the FS, you remain in the root so the root is the parent of itself. \ud83e\udd14 ",
        "created_at": "2018-01-19T03:00:09Z",
        "updated_at": "2018-01-19T03:00:17Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162528240",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162528240"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162528240"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162528091
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162528572",
        "pull_request_review_id": 90001633,
        "id": 162528572,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjUyODU3Mg==",
        "diff_hunk": "@@ -231,7 +239,16 @@ func (w *Watcher) addWatch(name string, flags uint32) (string, error) {\n \n \tif !alreadyWatching {\n \t\tw.mu.Lock()\n+\t\tparentName := filepath.Dir(name)\n \t\tw.watches[name] = watchfd\n+\n+\t\twatchesByDir, ok := w.watchesByDir[parentName]",
        "path": "kqueue.go",
        "position": 69,
        "original_position": 69,
        "commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "original_commit_id": "7b52f2a51cf849114394420e807ba7db6cd7f6c4",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "So lets just leave it the way it is.",
        "created_at": "2018-01-19T03:03:42Z",
        "updated_at": "2018-01-19T03:03:42Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162528572",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/162528572"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/233#discussion_r162528572"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/233"
            }
        },
        "in_reply_to_id": 162528091
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/170363917",
        "pull_request_review_id": 99047706,
        "id": 170363917,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MDM2MzkxNw==",
        "diff_hunk": "@@ -303,12 +303,15 @@ func (e *Event) ignoreLinux(mask uint32) bool {\n \t\treturn true\n \t}\n \n-\t// If the event is not a DELETE or RENAME, the file must exist.\n+\t// If the event is MODIFY or CREATE, the file must exist.\n \t// Otherwise the event is ignored.\n \t// *Note*: this was put in place because it was seen that a MODIFY\n \t// event was sent after the DELETE. This ignores that MODIFY and\n \t// assumes a DELETE will come or has come if the file doesn't exist.\n-\tif !(e.Op&Remove == Remove || e.Op&Rename == Rename) {\n+\t// A CHMOD event (triggeded by IN_MODIFY) can arrive when an open file is",
        "path": "inotify.go",
        "position": null,
        "original_position": 11,
        "commit_id": "877935a3e4085210e34cf31d023550f2082ea8d1",
        "original_commit_id": "3da4b9170cb16d4c6a467d369062a84c7a3553fb",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "typo, should be `triggered`",
        "created_at": "2018-02-23T20:49:02Z",
        "updated_at": "2018-03-03T01:43:38Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r170363917",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/170363917"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r170363917"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/171450940",
        "pull_request_review_id": 100303474,
        "id": 171450940,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MTQ1MDk0MA==",
        "diff_hunk": "@@ -303,12 +303,15 @@ func (e *Event) ignoreLinux(mask uint32) bool {\n \t\treturn true\n \t}\n \n-\t// If the event is not a DELETE or RENAME, the file must exist.\n+\t// If the event is MODIFY or CREATE, the file must exist.\n \t// Otherwise the event is ignored.\n \t// *Note*: this was put in place because it was seen that a MODIFY\n \t// event was sent after the DELETE. This ignores that MODIFY and\n \t// assumes a DELETE will come or has come if the file doesn't exist.\n-\tif !(e.Op&Remove == Remove || e.Op&Rename == Rename) {\n+\t// A CHMOD event (triggeded by IN_MODIFY) can arrive when an open file is",
        "path": "inotify.go",
        "position": null,
        "original_position": 11,
        "commit_id": "877935a3e4085210e34cf31d023550f2082ea8d1",
        "original_commit_id": "3da4b9170cb16d4c6a467d369062a84c7a3553fb",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Lets also link to this issue in the comment.",
        "created_at": "2018-03-01T02:48:08Z",
        "updated_at": "2018-03-03T01:43:38Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r171450940",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/171450940"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r171450940"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205"
            }
        },
        "in_reply_to_id": 170363917
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/172001166",
        "pull_request_review_id": 100959030,
        "id": 172001166,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MjAwMTE2Ng==",
        "diff_hunk": "@@ -303,12 +303,15 @@ func (e *Event) ignoreLinux(mask uint32) bool {\n \t\treturn true\n \t}\n \n-\t// If the event is not a DELETE or RENAME, the file must exist.\n+\t// If the event is MODIFY or CREATE, the file must exist.\n \t// Otherwise the event is ignored.\n \t// *Note*: this was put in place because it was seen that a MODIFY\n \t// event was sent after the DELETE. This ignores that MODIFY and\n \t// assumes a DELETE will come or has come if the file doesn't exist.\n-\tif !(e.Op&Remove == Remove || e.Op&Rename == Rename) {\n+\t// A CHMOD event (triggeded by IN_MODIFY) can arrive when an open file is",
        "path": "inotify.go",
        "position": null,
        "original_position": 11,
        "commit_id": "877935a3e4085210e34cf31d023550f2082ea8d1",
        "original_commit_id": "3da4b9170cb16d4c6a467d369062a84c7a3553fb",
        "user": {
            "login": "vladlosev",
            "id": 6958642,
            "node_id": "MDQ6VXNlcjY5NTg2NDI=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6958642?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vladlosev",
            "html_url": "https://github.com/vladlosev",
            "followers_url": "https://api.github.com/users/vladlosev/followers",
            "following_url": "https://api.github.com/users/vladlosev/following{/other_user}",
            "gists_url": "https://api.github.com/users/vladlosev/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vladlosev/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vladlosev/subscriptions",
            "organizations_url": "https://api.github.com/users/vladlosev/orgs",
            "repos_url": "https://api.github.com/users/vladlosev/repos",
            "events_url": "https://api.github.com/users/vladlosev/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vladlosev/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Added the issue link and fixed the typo.",
        "created_at": "2018-03-03T01:44:28Z",
        "updated_at": "2018-03-03T01:44:28Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r172001166",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/172001166"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r172001166"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205"
            }
        },
        "in_reply_to_id": 170363917
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/187784647",
        "pull_request_review_id": 119638237,
        "id": 187784647,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Nzc4NDY0Nw==",
        "diff_hunk": "@@ -447,3 +447,63 @@ func TestInotifyOverflow(t *testing.T) {\n \t\t\tnumDirs*numFiles, creates)\n \t}\n }\n+\n+func TestInotifyDeleteOpenFile(t *testing.T) {",
        "path": "inotify_test.go",
        "position": 5,
        "original_position": 5,
        "commit_id": "877935a3e4085210e34cf31d023550f2082ea8d1",
        "original_commit_id": "877935a3e4085210e34cf31d023550f2082ea8d1",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should have t.Parallel()",
        "created_at": "2018-05-12T22:28:35Z",
        "updated_at": "2018-05-12T22:29:58Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r187784647",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/187784647"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/205#discussion_r187784647"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/205"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/214102214",
        "pull_request_review_id": 151084883,
        "id": 214102214,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDEwMjIxNA==",
        "diff_hunk": "@@ -444,7 +444,7 @@ func TestFsnotifyDeleteWatchedDir(t *testing.T) {\n \t// Receive errors on the error channel on a separate goroutine\n \tgo func() {\n \t\tfor err := range watcher.Errors {\n-\t\t\tt.Fatalf(\"error received: %s\", err)\n+\t\t\tt.Error(\"error received: %s\", err)",
        "path": "integration_test.go",
        "position": 5,
        "original_position": 5,
        "commit_id": "bbf0d10b0456ed3d22ca8a9c2578538ef26b7207",
        "original_commit_id": "bbf0d10b0456ed3d22ca8a9c2578538ef26b7207",
        "user": {
            "login": "gdey",
            "id": 14805,
            "node_id": "MDQ6VXNlcjE0ODA1",
            "avatar_url": "https://avatars0.githubusercontent.com/u/14805?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/gdey",
            "html_url": "https://github.com/gdey",
            "followers_url": "https://api.github.com/users/gdey/followers",
            "following_url": "https://api.github.com/users/gdey/following{/other_user}",
            "gists_url": "https://api.github.com/users/gdey/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/gdey/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gdey/subscriptions",
            "organizations_url": "https://api.github.com/users/gdey/orgs",
            "repos_url": "https://api.github.com/users/gdey/repos",
            "events_url": "https://api.github.com/users/gdey/events{/privacy}",
            "received_events_url": "https://api.github.com/users/gdey/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This should be `t.Errorf(\"error received: %s\",err)`",
        "created_at": "2018-08-30T16:44:42Z",
        "updated_at": "2018-08-30T16:44:43Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/234#discussion_r214102214",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/234",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/214102214"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/234#discussion_r214102214"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/234"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/185158641",
        "pull_request_review_id": 116493230,
        "id": 185158641,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTE1ODY0MQ==",
        "diff_hunk": "@@ -23,13 +23,19 @@ func ExampleNewWatcher() {\n \tgo func() {\n \t\tfor {\n \t\t\tselect {\n-\t\t\tcase event := <-watcher.Events:\n+\t\t\tcase event, ok := <-watcher.Events:\n \t\t\t\tlog.Println(\"event:\", event)\n \t\t\t\tif event.Op&fsnotify.Write == fsnotify.Write {\n \t\t\t\t\tlog.Println(\"modified file:\", event.Name)\n \t\t\t\t}\n-\t\t\tcase err := <-watcher.Errors:\n+\t\t\t\tif !ok {",
        "path": "example_test.go",
        "position": null,
        "original_position": 11,
        "commit_id": "e15902b2d159a08a8293fd5f7962613cb2d94804",
        "original_commit_id": "135d0ae32454c0b45de5467060b7536fe4b101c0",
        "user": {
            "login": "omeid",
            "id": 1453118,
            "node_id": "MDQ6VXNlcjE0NTMxMTg=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1453118?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/omeid",
            "html_url": "https://github.com/omeid",
            "followers_url": "https://api.github.com/users/omeid/followers",
            "following_url": "https://api.github.com/users/omeid/following{/other_user}",
            "gists_url": "https://api.github.com/users/omeid/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/omeid/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/omeid/subscriptions",
            "organizations_url": "https://api.github.com/users/omeid/orgs",
            "repos_url": "https://api.github.com/users/omeid/repos",
            "events_url": "https://api.github.com/users/omeid/events{/privacy}",
            "received_events_url": "https://api.github.com/users/omeid/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Check the `ok` before reading from the `event`. Essentially, this needs to happen before line 27.",
        "created_at": "2018-05-01T02:48:53Z",
        "updated_at": "2018-08-30T21:53:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/244#discussion_r185158641",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/244",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/185158641"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/244#discussion_r185158641"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/244"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/185158695",
        "pull_request_review_id": 116493282,
        "id": 185158695,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTE1ODY5NQ==",
        "diff_hunk": "@@ -23,13 +23,19 @@ func ExampleNewWatcher() {\n \tgo func() {\n \t\tfor {\n \t\t\tselect {\n-\t\t\tcase event := <-watcher.Events:\n+\t\t\tcase event, ok := <-watcher.Events:\n \t\t\t\tlog.Println(\"event:\", event)\n \t\t\t\tif event.Op&fsnotify.Write == fsnotify.Write {\n \t\t\t\t\tlog.Println(\"modified file:\", event.Name)\n \t\t\t\t}\n-\t\t\tcase err := <-watcher.Errors:\n+\t\t\t\tif !ok {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\tcase err, ok := <-watcher.Errors:\n \t\t\t\tlog.Println(\"error:\", err)\n+\t\t\t\tif !ok {",
        "path": "example_test.go",
        "position": null,
        "original_position": 16,
        "commit_id": "e15902b2d159a08a8293fd5f7962613cb2d94804",
        "original_commit_id": "135d0ae32454c0b45de5467060b7536fe4b101c0",
        "user": {
            "login": "omeid",
            "id": 1453118,
            "node_id": "MDQ6VXNlcjE0NTMxMTg=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1453118?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/omeid",
            "html_url": "https://github.com/omeid",
            "followers_url": "https://api.github.com/users/omeid/followers",
            "following_url": "https://api.github.com/users/omeid/following{/other_user}",
            "gists_url": "https://api.github.com/users/omeid/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/omeid/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/omeid/subscriptions",
            "organizations_url": "https://api.github.com/users/omeid/orgs",
            "repos_url": "https://api.github.com/users/omeid/repos",
            "events_url": "https://api.github.com/users/omeid/events{/privacy}",
            "received_events_url": "https://api.github.com/users/omeid/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Same as above, check for close before reading the error. :)",
        "created_at": "2018-05-01T02:49:40Z",
        "updated_at": "2018-08-30T21:53:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/244#discussion_r185158695",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/244",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/185158695"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/244#discussion_r185158695"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/244"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/185159565",
        "pull_request_review_id": 116494200,
        "id": 185159565,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTE1OTU2NQ==",
        "diff_hunk": "@@ -23,13 +23,19 @@ func ExampleNewWatcher() {\n \tgo func() {\n \t\tfor {\n \t\t\tselect {\n-\t\t\tcase event := <-watcher.Events:\n+\t\t\tcase event, ok := <-watcher.Events:\n \t\t\t\tlog.Println(\"event:\", event)\n \t\t\t\tif event.Op&fsnotify.Write == fsnotify.Write {\n \t\t\t\t\tlog.Println(\"modified file:\", event.Name)\n \t\t\t\t}\n-\t\t\tcase err := <-watcher.Errors:\n+\t\t\t\tif !ok {",
        "path": "example_test.go",
        "position": null,
        "original_position": 11,
        "commit_id": "e15902b2d159a08a8293fd5f7962613cb2d94804",
        "original_commit_id": "135d0ae32454c0b45de5467060b7536fe4b101c0",
        "user": {
            "login": "alexeykazakov",
            "id": 620087,
            "node_id": "MDQ6VXNlcjYyMDA4Nw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/620087?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/alexeykazakov",
            "html_url": "https://github.com/alexeykazakov",
            "followers_url": "https://api.github.com/users/alexeykazakov/followers",
            "following_url": "https://api.github.com/users/alexeykazakov/following{/other_user}",
            "gists_url": "https://api.github.com/users/alexeykazakov/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/alexeykazakov/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/alexeykazakov/subscriptions",
            "organizations_url": "https://api.github.com/users/alexeykazakov/orgs",
            "repos_url": "https://api.github.com/users/alexeykazakov/repos",
            "events_url": "https://api.github.com/users/alexeykazakov/events{/privacy}",
            "received_events_url": "https://api.github.com/users/alexeykazakov/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Right :)\r\nFixed.",
        "created_at": "2018-05-01T03:02:10Z",
        "updated_at": "2018-08-30T21:53:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/244#discussion_r185159565",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/244",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/185159565"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/244#discussion_r185159565"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/244"
            }
        },
        "in_reply_to_id": 185158641
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/190848865",
        "pull_request_review_id": 123314258,
        "id": 190848865,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MDg0ODg2NQ==",
        "diff_hunk": "@@ -62,5 +62,5 @@ func (e Event) String() string {\n \treturn fmt.Sprintf(\"%q: %s\", e.Name, e.Op.String())\n }\n \n-// Common errors that can be reported by a watcher",
        "path": "fsnotify.go",
        "position": 4,
        "original_position": 4,
        "commit_id": "7e91f74f4de950c59d99656a46b86dd75ba06b11",
        "original_commit_id": "145685f622f41080ec5217cdb62839d5f1d5926e",
        "user": {
            "login": "nhooyr",
            "id": 10180857,
            "node_id": "MDQ6VXNlcjEwMTgwODU3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/10180857?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nhooyr",
            "html_url": "https://github.com/nhooyr",
            "followers_url": "https://api.github.com/users/nhooyr/followers",
            "following_url": "https://api.github.com/users/nhooyr/following{/other_user}",
            "gists_url": "https://api.github.com/users/nhooyr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nhooyr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nhooyr/subscriptions",
            "organizations_url": "https://api.github.com/users/nhooyr/orgs",
            "repos_url": "https://api.github.com/users/nhooyr/repos",
            "events_url": "https://api.github.com/users/nhooyr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nhooyr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I believe this comment is meant for multiple errors. Could you change the comment to `ErrEventOverflow can be reported by a watcher.`",
        "created_at": "2018-05-25T10:06:35Z",
        "updated_at": "2018-12-14T18:18:16Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/247#discussion_r190848865",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/247",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/190848865"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/247#discussion_r190848865"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/247"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/257832737",
        "pull_request_review_id": 204960004,
        "id": 257832737,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NzgzMjczNw==",
        "diff_hunk": "@@ -87,6 +87,27 @@ func (w *Watcher) Close() error {\n \treturn nil\n }\n \n+// CheckPath checks if a path is being watched by the watcher or not\n+func (w *Watcher) CheckPath(name string) bool {\n+\tname = filepath.Clean(name)\n+\n+\tif _, ok w.watches[name]; ok {",
        "path": "inotify.go",
        "position": 8,
        "original_position": 8,
        "commit_id": "02cb398f229c547c4a52f420e6997264a8321d4d",
        "original_commit_id": "02cb398f229c547c4a52f420e6997264a8321d4d",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "expected 1 expression",
        "created_at": "2019-02-18T21:38:10Z",
        "updated_at": "2019-02-18T21:38:10Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/283#discussion_r257832737",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/283",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/257832737"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/283#discussion_r257832737"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/283"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/263850289",
        "pull_request_review_id": 212376065,
        "id": 263850289,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2Mzg1MDI4OQ==",
        "diff_hunk": "@@ -3,29 +3,35 @@ language: go\n \n go:\n   - \"stable\"\n-  - \"1.10.4\"\n+  - \"1.11.x\"\n+  - \"1.10.x\"\n   - \"1.9.x\"\n   - \"1.8.x\"\n \n matrix:\n+  include:\n+    - go: \"stable\"\n+      env: GOLINT=true\n   allow_failures:\n     - go: tip\n   fast_finish: true\n \n-before_script:\n-  - go get -u golang.org/x/lint/golint\n+\n+before_install:\n+  - if [ ! -z \"${GOLINT}\" ]; then go get -u golang.org/x/lint/golint; fi\n \n script:\n   - go test --race ./...\n \n after_script:\n   - test -z \"$(gofmt -s -l -w . | tee /dev/stderr)\"",
        "path": ".travis.yml",
        "position": 28,
        "original_position": 28,
        "commit_id": "7141d0edcf3f8b3f88c421ff4288199adede38d9",
        "original_commit_id": "7141d0edcf3f8b3f88c421ff4288199adede38d9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This looks good. Thanks Brian!\r\n\r\nIt does make me wonder if we need to run `gofmt` or `go vet` on anything but the stable release too, but for now it doesn't hurt.",
        "created_at": "2019-03-08T16:55:25Z",
        "updated_at": "2019-03-08T16:55:37Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/284#discussion_r263850289",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/284",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/263850289"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/284#discussion_r263850289"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/284"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220777570",
        "pull_request_review_id": 159264447,
        "id": 220777570,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDc3NzU3MA==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error",
        "path": "fen.go",
        "position": null,
        "original_position": 88,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\"send an **error**\"",
        "created_at": "2018-09-27T02:28:36Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220777570",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220777570"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220777570"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220778147",
        "pull_request_review_id": 159264447,
        "id": 220778147,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDc3ODE0Nw==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {",
        "path": "fen.go",
        "position": null,
        "original_position": 122,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think it's best to use `Add(name string)` to match the function signature used on other platforms. \r\n\r\nThis matches `os.Open` and so on, but even if we change it, we should change it independent of this pull request across all platforms.",
        "created_at": "2018-09-27T02:33:07Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220778147",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220778147"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220778147"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220778426",
        "pull_request_review_id": 159264447,
        "id": 220778426,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDc3ODQyNg==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {",
        "path": "fen.go",
        "position": null,
        "original_position": 139,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Likewise.",
        "created_at": "2018-09-27T02:35:52Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220778426",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220778426"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220778426"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220779276",
        "pull_request_review_id": 159264447,
        "id": 220779276,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDc3OTI3Ng==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)",
        "path": "fen.go",
        "position": null,
        "original_position": 205,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This list of of files includes subdirectories.\r\n\r\nIs this the behaviour you want? To call associateFile/disassociateFile on a subdirectory?\r\n\r\n(keeping it non-recursive for now is probably best, as the other platforms are not recursive yet)",
        "created_at": "2018-09-27T02:44:20Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220779276",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220779276"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220779276"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220779709",
        "pull_request_review_id": 159264447,
        "id": 220779709,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDc3OTcwOQ==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// And finally handle the directory itself.\n+\treturn handler(path, stat)\n+}\n+\n+func (w *Watcher) handleEvent(obj C.uintptr_t, events C.int, user unsafe.Pointer) error {\n+\tfobj := C.uintptr_to_file_obj(obj)\n+\tfmode := os.FileMode(C.ptr_to_uintptr(user))\n+\tpath := C.GoString(fobj.fo_name)\n+\n+\tvar toSend *Event\n+\treRegister := true\n+\n+\tswitch {\n+\tcase events&C.FILE_MODIFIED == C.FILE_MODIFIED:\n+\t\tif fmode.IsDir() {\n+\t\t\tif err := w.updateDirectory(path); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttoSend = &Event{path, Write}\n+\t\t}\n+\tcase events&C.FILE_ATTRIB == C.FILE_ATTRIB:\n+\t\ttoSend = &Event{path, Chmod}\n+\tcase events&C.FILE_DELETE == C.FILE_DELETE:\n+\t\tw.unwatch(path)\n+\t\ttoSend = &Event{path, Remove}\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_TO == C.FILE_RENAME_TO:\n+\t\t// We don't report a Rename event for this case, because\n+\t\t// Rename events are interpreted as referring to the _old_ name\n+\t\t// of the file, and in this case the event would refer to the\n+\t\t// new name of the file. This type of rename event is not\n+\t\t// supported by fsnotify.\n+\n+\t\t// inotify reports a Remove event in this case, so we simulate\n+\t\t// this here.\n+\t\tif w.watched(path) {\n+\t\t\ttoSend = &Event{path, Remove}\n+\t\t}\n+\t\t// Don't keep watching the file that was removed\n+\t\tw.unwatch(path)\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_FROM == C.FILE_RENAME_FROM:\n+\t\ttoSend = &Event{path, Rename}\n+\t\t// Don't keep watching the new file name\n+\t\tw.unwatch(path)\n+\t\treRegister = false\n+\tdefault:\n+\t\treturn errors.New(\"unknown event received\")\n+\t}\n+\n+\tif toSend != nil {\n+\t\tif !w.sendEvent(*toSend) {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\tif !reRegister {\n+\t\treturn nil\n+\t}\n+\n+\t// If we get here, it means we've hit an event above that requires us to\n+\t// continue watching the file",
        "path": "fen.go",
        "position": null,
        "original_position": 272,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "file or directory, yes? (updateDirectory falls through to here too)\r\n\r\nso on every modify/attrib event, it's necessary to reregister the file that the event was on? (I don't know FEN)",
        "created_at": "2018-09-27T02:48:46Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220779709",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220779709"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220779709"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220780000",
        "pull_request_review_id": 159264447,
        "id": 220780000,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDc4MDAwMA==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// And finally handle the directory itself.\n+\treturn handler(path, stat)\n+}\n+\n+func (w *Watcher) handleEvent(obj C.uintptr_t, events C.int, user unsafe.Pointer) error {\n+\tfobj := C.uintptr_to_file_obj(obj)\n+\tfmode := os.FileMode(C.ptr_to_uintptr(user))\n+\tpath := C.GoString(fobj.fo_name)\n+\n+\tvar toSend *Event\n+\treRegister := true\n+\n+\tswitch {\n+\tcase events&C.FILE_MODIFIED == C.FILE_MODIFIED:\n+\t\tif fmode.IsDir() {\n+\t\t\tif err := w.updateDirectory(path); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttoSend = &Event{path, Write}\n+\t\t}\n+\tcase events&C.FILE_ATTRIB == C.FILE_ATTRIB:\n+\t\ttoSend = &Event{path, Chmod}\n+\tcase events&C.FILE_DELETE == C.FILE_DELETE:\n+\t\tw.unwatch(path)\n+\t\ttoSend = &Event{path, Remove}\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_TO == C.FILE_RENAME_TO:\n+\t\t// We don't report a Rename event for this case, because\n+\t\t// Rename events are interpreted as referring to the _old_ name\n+\t\t// of the file, and in this case the event would refer to the\n+\t\t// new name of the file. This type of rename event is not\n+\t\t// supported by fsnotify.\n+\n+\t\t// inotify reports a Remove event in this case, so we simulate\n+\t\t// this here.\n+\t\tif w.watched(path) {\n+\t\t\ttoSend = &Event{path, Remove}\n+\t\t}\n+\t\t// Don't keep watching the file that was removed\n+\t\tw.unwatch(path)\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_FROM == C.FILE_RENAME_FROM:",
        "path": "fen.go",
        "position": null,
        "original_position": 253,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "placing FILE_RENAME_FROM before FILE_RENAME_TO would read a bit better, especially giving the caveat in the prior comments.",
        "created_at": "2018-09-27T02:51:15Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220780000",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/220780000"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r220780000"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/222513967",
        "pull_request_review_id": 161418592,
        "id": 222513967,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMjUxMzk2Nw==",
        "diff_hunk": "@@ -62,5 +62,5 @@ func (e Event) String() string {\n \treturn fmt.Sprintf(\"%q: %s\", e.Name, e.Op.String())\n }\n \n-// Common errors that can be reported by a watcher\n+// ErrEventOverflow: Common errors that can be reported by a watcher",
        "path": "fsnotify.go",
        "position": null,
        "original_position": 5,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "46dac7092901365a34dbb83040b162a312d270c9",
        "user": {
            "login": "houndci-bot",
            "id": 6697940,
            "node_id": "MDQ6VXNlcjY2OTc5NDA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/6697940?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/houndci-bot",
            "html_url": "https://github.com/houndci-bot",
            "followers_url": "https://api.github.com/users/houndci-bot/followers",
            "following_url": "https://api.github.com/users/houndci-bot/following{/other_user}",
            "gists_url": "https://api.github.com/users/houndci-bot/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/houndci-bot/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/houndci-bot/subscriptions",
            "organizations_url": "https://api.github.com/users/houndci-bot/orgs",
            "repos_url": "https://api.github.com/users/houndci-bot/repos",
            "events_url": "https://api.github.com/users/houndci-bot/events{/privacy}",
            "received_events_url": "https://api.github.com/users/houndci-bot/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "comment on exported var ErrEventOverflow should be of the form \"ErrEventOverflow ...\"",
        "created_at": "2018-10-04T01:16:33Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r222513967",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/222513967"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r222513967"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223461541",
        "pull_request_review_id": 162593916,
        "id": 223461541,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQ2MTU0MQ==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error",
        "path": "fen.go",
        "position": null,
        "original_position": 88,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done.",
        "created_at": "2018-10-08T18:40:07Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223461541",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223461541"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223461541"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220777570
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223461587",
        "pull_request_review_id": 162593984,
        "id": 223461587,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQ2MTU4Nw==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {",
        "path": "fen.go",
        "position": null,
        "original_position": 122,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done.",
        "created_at": "2018-10-08T18:40:17Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223461587",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223461587"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223461587"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220778147
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223461623",
        "pull_request_review_id": 162594034,
        "id": 223461623,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQ2MTYyMw==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {",
        "path": "fen.go",
        "position": null,
        "original_position": 139,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done.",
        "created_at": "2018-10-08T18:40:25Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223461623",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223461623"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223461623"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220778426
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223462043",
        "pull_request_review_id": 162594588,
        "id": 223462043,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQ2MjA0Mw==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// And finally handle the directory itself.\n+\treturn handler(path, stat)\n+}\n+\n+func (w *Watcher) handleEvent(obj C.uintptr_t, events C.int, user unsafe.Pointer) error {\n+\tfobj := C.uintptr_to_file_obj(obj)\n+\tfmode := os.FileMode(C.ptr_to_uintptr(user))\n+\tpath := C.GoString(fobj.fo_name)\n+\n+\tvar toSend *Event\n+\treRegister := true\n+\n+\tswitch {\n+\tcase events&C.FILE_MODIFIED == C.FILE_MODIFIED:\n+\t\tif fmode.IsDir() {\n+\t\t\tif err := w.updateDirectory(path); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttoSend = &Event{path, Write}\n+\t\t}\n+\tcase events&C.FILE_ATTRIB == C.FILE_ATTRIB:\n+\t\ttoSend = &Event{path, Chmod}\n+\tcase events&C.FILE_DELETE == C.FILE_DELETE:\n+\t\tw.unwatch(path)\n+\t\ttoSend = &Event{path, Remove}\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_TO == C.FILE_RENAME_TO:\n+\t\t// We don't report a Rename event for this case, because\n+\t\t// Rename events are interpreted as referring to the _old_ name\n+\t\t// of the file, and in this case the event would refer to the\n+\t\t// new name of the file. This type of rename event is not\n+\t\t// supported by fsnotify.\n+\n+\t\t// inotify reports a Remove event in this case, so we simulate\n+\t\t// this here.\n+\t\tif w.watched(path) {\n+\t\t\ttoSend = &Event{path, Remove}\n+\t\t}\n+\t\t// Don't keep watching the file that was removed\n+\t\tw.unwatch(path)\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_FROM == C.FILE_RENAME_FROM:\n+\t\ttoSend = &Event{path, Rename}\n+\t\t// Don't keep watching the new file name\n+\t\tw.unwatch(path)\n+\t\treRegister = false\n+\tdefault:\n+\t\treturn errors.New(\"unknown event received\")\n+\t}\n+\n+\tif toSend != nil {\n+\t\tif !w.sendEvent(*toSend) {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\tif !reRegister {\n+\t\treturn nil\n+\t}\n+\n+\t// If we get here, it means we've hit an event above that requires us to\n+\t// continue watching the file",
        "path": "fen.go",
        "position": null,
        "original_position": 272,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Comment fixed.\r\n\r\nCorrect - the receipt of an event unregisters the file/dir being watched. If we want to keep watching a file/dir after receiving an event, we need to re-register.",
        "created_at": "2018-10-08T18:42:09Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223462043",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223462043"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223462043"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220779709
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223462087",
        "pull_request_review_id": 162594650,
        "id": 223462087,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQ2MjA4Nw==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// And finally handle the directory itself.\n+\treturn handler(path, stat)\n+}\n+\n+func (w *Watcher) handleEvent(obj C.uintptr_t, events C.int, user unsafe.Pointer) error {\n+\tfobj := C.uintptr_to_file_obj(obj)\n+\tfmode := os.FileMode(C.ptr_to_uintptr(user))\n+\tpath := C.GoString(fobj.fo_name)\n+\n+\tvar toSend *Event\n+\treRegister := true\n+\n+\tswitch {\n+\tcase events&C.FILE_MODIFIED == C.FILE_MODIFIED:\n+\t\tif fmode.IsDir() {\n+\t\t\tif err := w.updateDirectory(path); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttoSend = &Event{path, Write}\n+\t\t}\n+\tcase events&C.FILE_ATTRIB == C.FILE_ATTRIB:\n+\t\ttoSend = &Event{path, Chmod}\n+\tcase events&C.FILE_DELETE == C.FILE_DELETE:\n+\t\tw.unwatch(path)\n+\t\ttoSend = &Event{path, Remove}\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_TO == C.FILE_RENAME_TO:\n+\t\t// We don't report a Rename event for this case, because\n+\t\t// Rename events are interpreted as referring to the _old_ name\n+\t\t// of the file, and in this case the event would refer to the\n+\t\t// new name of the file. This type of rename event is not\n+\t\t// supported by fsnotify.\n+\n+\t\t// inotify reports a Remove event in this case, so we simulate\n+\t\t// this here.\n+\t\tif w.watched(path) {\n+\t\t\ttoSend = &Event{path, Remove}\n+\t\t}\n+\t\t// Don't keep watching the file that was removed\n+\t\tw.unwatch(path)\n+\t\treRegister = false\n+\tcase events&C.FILE_RENAME_FROM == C.FILE_RENAME_FROM:",
        "path": "fen.go",
        "position": null,
        "original_position": 253,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done.",
        "created_at": "2018-10-08T18:42:20Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223462087",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223462087"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223462087"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220780000
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223463554",
        "pull_request_review_id": 162596463,
        "id": 223463554,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQ2MzU1NA==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)",
        "path": "fen.go",
        "position": null,
        "original_position": 205,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "My understanding is that, if we add a watch to a directory, we want to watch all of its immediate children for changes - this would include children that are directories. This isn't recursive in that we don't _descend_ into those subdirectories and watch the files/directories therein, walking down the entire tree - we just watch the subdirectory vnode itself and stop there.\r\n\r\nIs this incorrect? Should children that are directories be explicitly omitted?",
        "created_at": "2018-10-08T18:47:51Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223463554",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223463554"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223463554"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220779276
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223512814",
        "pull_request_review_id": 162658871,
        "id": 223512814,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzUxMjgxNA==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)",
        "path": "fen.go",
        "position": null,
        "original_position": 205,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "That's correct.",
        "created_at": "2018-10-08T22:20:11Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223512814",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223512814"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223512814"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220779276
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223811269",
        "pull_request_review_id": 163030274,
        "id": 223811269,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzgxMTI2OQ==",
        "diff_hunk": "@@ -6,32 +6,363 @@\n \n package fsnotify\n \n+// #include <errno.h>\n+// #include <strings.h>\n+// #include <unistd.h>\n+// #include <stdio.h>\n+// #include <stdlib.h>\n+// #include <port.h>\n+// #include <sys/stat.h>\n+//\n+// uintptr_t file_obj_to_uintptr (file_obj_t *obj) {\n+//   return (uintptr_t)obj;\n+// }\n+//\n+// file_obj_t *uintptr_to_file_obj(uintptr_t ptr) {\n+//   return (file_obj_t *)ptr;\n+// }\n+//\n+// uintptr_t ptr_to_uintptr(void *p) {\n+//\treturn (uintptr_t)p;\n+// }\n+//\n+// void *uintptr_to_ptr(uintptr_t i) {\n+//\treturn (void *)i;\n+// }\n+//\n+// struct file_info {\n+//   uint mode;\n+// };\n+import \"C\"\n import (\n \t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n )\n \n // Watcher watches a set of files, delivering events to a channel.\n type Watcher struct {\n \tEvents chan Event\n \tErrors chan error\n+\n+\tport C.int // solaris port for underlying FEN system\n+\n+\tmu      sync.Mutex\n+\twatches map[string]*C.file_obj_t\n+\n+\tdone     chan struct{} // Channel for sending a \"quit message\" to the reader goroutine\n+\tdoneResp chan struct{} // Channel to respond to Close\n }\n \n // NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.\n func NewWatcher() (*Watcher, error) {\n-\treturn nil, errors.New(\"FEN based watcher not yet supported for fsnotify\\n\")\n+\tvar err error\n+\n+\tw := new(Watcher)\n+\tw.Events = make(chan Event)\n+\tw.Errors = make(chan error)\n+\tw.port, err = C.port_create()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tw.watches = make(map[string]*C.file_obj_t)\n+\tw.done = make(chan struct{})\n+\tw.doneResp = make(chan struct{})\n+\n+\tgo w.readEvents()\n+\treturn w, nil\n+}\n+\n+// sendEvent attempts to send an event to the user, returning true if the event\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendEvent(e Event) (sent bool) {\n+\tselect {\n+\tcase w.Events <- e:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+// sendError attempts to send an event to the user, returning true if the error\n+// was put in the channel successfully and false if the watcher has been closed.\n+func (w *Watcher) sendError(err error) (sent bool) {\n+\tselect {\n+\tcase w.Errors <- err:\n+\t\treturn true\n+\tcase <-w.done:\n+\t\treturn false\n+\t}\n+}\n+\n+func (w *Watcher) isClosed() bool {\n+\tselect {\n+\tcase <-w.done:\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // Close removes all watches and closes the events channel.\n func (w *Watcher) Close() error {\n+\tif w.isClosed() {\n+\t\treturn nil\n+\t}\n+\tclose(w.done)\n+\tC.close(w.port)\n+\t<-w.doneResp\n \treturn nil\n }\n \n // Add starts watching the named file or directory (non-recursively).\n-func (w *Watcher) Add(name string) error {\n-\treturn nil\n+func (w *Watcher) Add(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.associateFile)\n+\tdefault:\n+\t\treturn w.associateFile(path, stat)\n+\t}\n }\n \n // Remove stops watching the the named file or directory (non-recursively).\n-func (w *Watcher) Remove(name string) error {\n+func (w *Watcher) Remove(path string) error {\n+\tif w.isClosed() {\n+\t\treturn errors.New(\"FEN watcher already closed\")\n+\t}\n+\tif !w.watched(path) {\n+\t\treturn fmt.Errorf(\"can't remove non-existent FEN watch for: %s\", path)\n+\t}\n+\n+\tstat, err := os.Stat(path)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase stat.IsDir():\n+\t\treturn w.handleDirectory(path, stat, w.dissociateFile)\n+\tdefault:\n+\t\treturn w.dissociateFile(path, stat)\n+\t}\n+}\n+\n+// readEvents contains the main loop that runs in a goroutine watching for events.\n+func (w *Watcher) readEvents() {\n+\t// If this function returns, the watcher has been closed and we can\n+\t// close these channels\n+\tdefer close(w.doneResp)\n+\tdefer close(w.Errors)\n+\tdefer close(w.Events)\n+\n+\tfor {\n+\t\tvar pevent C.port_event_t\n+\t\t_, err := C.port_get(w.port, &pevent, nil)\n+\t\tif err != nil {\n+\t\t\t// port_get failed because we called w.Close()\n+\t\t\tif w.isClosed() {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// There was an error not caused by calling w.Close()\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif pevent.portev_source != C.PORT_SOURCE_FILE {\n+\t\t\t// Event from unexpected source received; should never happen.\n+\t\t\tif !w.sendError(errors.New(\"Event from unexpected source received\")) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = w.handleEvent(pevent.portev_object, pevent.portev_events, pevent.portev_user)\n+\t\tif err != nil {\n+\t\t\tif !w.sendError(err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (w *Watcher) handleDirectory(path string, stat os.FileInfo, handler func(string, os.FileInfo) error) error {\n+\tfiles, err := ioutil.ReadDir(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Handle all children of the directory.\n+\tfor _, finfo := range files {\n+\t\terr := handler(filepath.Join(path, finfo.Name()), finfo)",
        "path": "fen.go",
        "position": null,
        "original_position": 205,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "62cfb90cd26d34c37e316703ffb1ca94025e7ca0",
        "user": {
            "login": "isaacdavis",
            "id": 12563707,
            "node_id": "MDQ6VXNlcjEyNTYzNzA3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/12563707?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/isaacdavis",
            "html_url": "https://github.com/isaacdavis",
            "followers_url": "https://api.github.com/users/isaacdavis/followers",
            "following_url": "https://api.github.com/users/isaacdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/isaacdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/isaacdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/isaacdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/isaacdavis/orgs",
            "repos_url": "https://api.github.com/users/isaacdavis/repos",
            "events_url": "https://api.github.com/users/isaacdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/isaacdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "fixed.",
        "created_at": "2018-10-09T18:20:51Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223811269",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/223811269"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r223811269"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 220779276
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/263928842",
        "pull_request_review_id": 212478167,
        "id": 263928842,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2MzkyODg0Mg==",
        "diff_hunk": "@@ -62,5 +62,5 @@ func (e Event) String() string {\n \treturn fmt.Sprintf(\"%q: %s\", e.Name, e.Op.String())\n }\n \n-// Common errors that can be reported by a watcher\n+// ErrEventOverflow: Common errors that can be reported by a watcher",
        "path": "fsnotify.go",
        "position": null,
        "original_position": 5,
        "commit_id": "f701e660adb657adee91ab3848488db2c5b900fd",
        "original_commit_id": "46dac7092901365a34dbb83040b162a312d270c9",
        "user": {
            "login": "nathany",
            "id": 4566,
            "node_id": "MDQ6VXNlcjQ1NjY=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4566?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nathany",
            "html_url": "https://github.com/nathany",
            "followers_url": "https://api.github.com/users/nathany/followers",
            "following_url": "https://api.github.com/users/nathany/following{/other_user}",
            "gists_url": "https://api.github.com/users/nathany/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nathany/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nathany/subscriptions",
            "organizations_url": "https://api.github.com/users/nathany/orgs",
            "repos_url": "https://api.github.com/users/nathany/repos",
            "events_url": "https://api.github.com/users/nathany/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nathany/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "note: if you rebase on master, this was resolved",
        "created_at": "2019-03-08T21:02:34Z",
        "updated_at": "2019-03-11T18:23:40Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r263928842",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/263928842"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/263#discussion_r263928842"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/263"
            }
        },
        "in_reply_to_id": 222513967
    },
    {
        "url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/274690012",
        "pull_request_review_id": 225823590,
        "id": 274690012,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NDY5MDAxMg==",
        "diff_hunk": "@@ -298,6 +298,9 @@ func (w *Watcher) remWatch(pathname string) error {\n \tw.mu.Lock()\n \twatch := w.watches.get(ino)\n \tw.mu.Unlock()\n+    if e := syscall.CloseHandle(ino.handle); e != nil {",
        "path": "windows.go",
        "position": 4,
        "original_position": 4,
        "commit_id": "f8445c956a2a9a2fa124e8a4855a7130c5c78dcb",
        "original_commit_id": "f8445c956a2a9a2fa124e8a4855a7130c5c78dcb",
        "user": {
            "login": "Code0x58",
            "id": 9309570,
            "node_id": "MDQ6VXNlcjkzMDk1NzA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/9309570?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Code0x58",
            "html_url": "https://github.com/Code0x58",
            "followers_url": "https://api.github.com/users/Code0x58/followers",
            "following_url": "https://api.github.com/users/Code0x58/following{/other_user}",
            "gists_url": "https://api.github.com/users/Code0x58/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/Code0x58/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/Code0x58/subscriptions",
            "organizations_url": "https://api.github.com/users/Code0x58/orgs",
            "repos_url": "https://api.github.com/users/Code0x58/repos",
            "events_url": "https://api.github.com/users/Code0x58/events{/privacy}",
            "received_events_url": "https://api.github.com/users/Code0x58/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "the leading whitespace here is spaces rather than a tab",
        "created_at": "2019-04-11T22:29:23Z",
        "updated_at": "2019-04-11T22:36:28Z",
        "html_url": "https://github.com/fsnotify/fsnotify/pull/288#discussion_r274690012",
        "pull_request_url": "https://api.github.com/repos/fsnotify/fsnotify/pulls/288",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/comments/274690012"
            },
            "html": {
                "href": "https://github.com/fsnotify/fsnotify/pull/288#discussion_r274690012"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/fsnotify/fsnotify/pulls/288"
            }
        }
    }
]