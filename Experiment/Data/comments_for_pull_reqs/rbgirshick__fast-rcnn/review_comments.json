[
    {
        "url": "https://api.github.com/repos/rbgirshick/fast-rcnn/pulls/comments/32863010",
        "pull_request_review_id": null,
        "id": 32863010,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyODYzMDEw",
        "diff_hunk": "@@ -0,0 +1,330 @@\n+# --------------------------------------------------------\n+# Fast R-CNN\n+# Copyright (c) 2015 Microsoft\n+# Licensed under The MIT License [see LICENSE for details]\n+# Written by Ross Girshick\n+# --------------------------------------------------------\n+\n+import datasets, math\n+import datasets.ms_coco\n+import os\n+import datasets.imdb\n+import xml.dom.minidom as minidom\n+import numpy as np\n+import scipy.sparse\n+import scipy.io as sio\n+import utils.cython_bbox\n+import cPickle\n+import subprocess\n+\n+class ms_coco(datasets.imdb):\n+    def __init__(self, image_set, year = 2014, coco_path=None):\n+        datasets.imdb.__init__(self, 'coco_' + image_set + year)\n+        self._year = year\n+        self._image_set = image_set\n+        self._coco_name = image_set + year\n+        self._coco_path = self._get_default_path() if coco_path is None \\\n+                            else coco_path\n+        self._COCO = self._load_coco_json()\n+\n+        cats = self._COCO.loadCats(self._COCO.getCatIds())\n+        self._classes = tuple(['__background__'] + [cat['name'] for cat in cats])\n+        self._class_to_ind = dict(zip(self.classes, xrange(self.num_classes)))\n+        self._image_index = self._load_image_set_index()\n+        self._validate_image_index()\n+        # Default to roidb handler\n+        self._roidb_handler = self.selective_search_roidb\n+\n+        # PASCAL specific config options\n+        self.config = {'top_k'    : 2000}\n+\n+        assert os.path.exists(self._coco_path), \\\n+                'VOCdevkit path does not exist: {}'.format(self._coco_path)\n+\n+    def _validate_image_index(self):\n+        # training requirs at least one object in the image, remove those without\n+        if int(self._year) == 2007 or self._image_set != 'test':\n+            roidb = self.gt_roidb(False) #disable caching, because we are going to rebuild index\n+\n+            image_index = []\n+            for rois, index in zip(roidb, self._image_index):\n+                if rois['gt_overlaps'].size != 0:\n+                    image_index.append(index)\n+            self._image_index = image_index\n+\n+\n+    def image_path_at(self, i):\n+        \"\"\"\n+        Return the absolute path to image i in the image sequence.\n+        \"\"\"\n+        return self.image_path_from_index(self._image_index[i])\n+\n+    def _get_image_filename(self, index):\n+        return self._COCO.loadImgs(index)[0]['file_name']\n+\n+    def image_path_from_index(self, index):\n+        \"\"\"\n+        Construct an image path from the image's \"index\" identifier.\n+        \"\"\"\n+        image_path = os.path.join(self._coco_path, 'images', self._coco_name, self._get_image_filename(index))\n+        assert os.path.exists(image_path), \\\n+                'Path does not exist: {}'.format(image_path)\n+        return image_path\n+\n+    def _load_image_set_index(self):\n+        \"\"\"\n+        Load the indexes listed in this dataset's image set file.\n+        \"\"\"\n+        # Example path to image set file:\n+        # self._devkit_path + /VOCdevkit2007/VOC2007/ImageSets/Main/val.txt\n+        image_index = self._COCO.getImgIds()\n+        return image_index\n+\n+    def _load_coco_json(self):\n+        import sys\n+        sys.path.append(os.path.join(self._coco_path, 'PythonAPI'))\n+        try:\n+            from pycocotools.coco import COCO\n+        except:\n+            raise Exception(\"can't find coco API in the coco path: %s\" % self._coco_path)\n+\n+        ann_file = os.path.join(self._coco_path, 'annotations', 'instances_' + self._coco_name + '.json')\n+        return COCO(ann_file)\n+\n+    def _get_default_path(self):\n+        \"\"\"\n+        Return the default path where PASCAL VOC is expected to be installed.\n+        \"\"\"\n+        return os.path.join(datasets.ROOT_DIR, 'data', 'coco')\n+\n+    def gt_roidb(self, caching = True):\n+        \"\"\"\n+        Return the database of ground-truth regions of interest.\n+\n+        This function loads/saves from/to a cache file to speed up future calls.\n+        \"\"\"\n+        cache_file = os.path.join(self.cache_path, self.name + '_gt_roidb.pkl')\n+        if caching and os.path.exists(cache_file):\n+            with open(cache_file, 'rb') as fid:\n+                roidb = cPickle.load(fid)\n+            print '{} gt roidb loaded from {}'.format(self.name, cache_file)\n+            return roidb\n+\n+        gt_roidb = [self._load_coco_annotation(index)\n+                    for index in self.image_index]\n+\n+        if caching:\n+            with open(cache_file, 'wb') as fid:\n+                cPickle.dump(gt_roidb, fid, cPickle.HIGHEST_PROTOCOL)\n+            print 'wrote gt roidb to {}'.format(cache_file)\n+\n+        return gt_roidb\n+\n+    def selective_search_roidb(self):\n+        \"\"\"\n+        Return the database of selective search regions of interest.\n+        Ground-truth ROIs are also included.\n+\n+        This function loads/saves from/to a cache file to speed up future calls.\n+        \"\"\"\n+        cache_file = os.path.join(self.cache_path,\n+                                  self.name + '_selective_search_roidb.pkl')\n+\n+        if os.path.exists(cache_file):\n+            with open(cache_file, 'rb') as fid:\n+                roidb = cPickle.load(fid)\n+            print '{} ss roidb loaded from {}'.format(self.name, cache_file)\n+            return roidb\n+\n+        if int(self._year) == 2007 or self._image_set != 'test':\n+            gt_roidb = self.gt_roidb()\n+            ss_roidb = self._load_selective_search_roidb(gt_roidb)\n+            roidb = datasets.imdb.merge_roidbs(gt_roidb, ss_roidb)\n+        else:\n+            roidb = self._load_selective_search_roidb(None)\n+        with open(cache_file, 'wb') as fid:\n+            cPickle.dump(roidb, fid, cPickle.HIGHEST_PROTOCOL)\n+        print 'wrote ss roidb to {}'.format(cache_file)\n+\n+        return roidb\n+\n+    def _load_selective_search_roidb(self, gt_roidb):\n+        filename = os.path.abspath(os.path.join(self.cache_path, '..',\n+                                                'selective_search_data',\n+                                                self.name + '.mat'))\n+        assert os.path.exists(filename), \\\n+               'Selective search data not found at: {}'.format(filename)\n+        images, boxes = self._load_v73_ss_boxes(filename)\n+\n+        box_dict = {}\n+        for img, box_tmp in zip(images, boxes):\n+            box_dict[img] = box_tmp[:, (1, 0, 3, 2)] - 1\n+\n+        box_list = []\n+        for index in self._image_index:\n+            file_name = self._get_image_filename(index)\n+            box_list.append(box_dict[file_name])\n+\n+        return self.create_roidb_from_box_list(box_list, gt_roidb)\n+\n+    #http://stackoverflow.com/a/28259682\n+    #ss file is saved by matlab with -v7.3\n+    #two variables: boxes and images\n+    # images: cell array of filenames\n+    # boxes: cell array of boxes:\n+    #   each cell is a n_boxes * 4 (y1,x1,y2,x2 in Selective Search Code) matrix\n+    def _load_v73_ss_boxes(self, path):\n+        import h5py\n+\n+        with h5py.File(path) as reader:\n+\n+            images = []\n+            for column in reader['images']:\n+                row_data = []\n+                for row_number in range(len(column)):\n+                    row_data.append(''.join(map(unichr, reader[column[row_number]][:])))\n+                images.append(row_data[0])\n+\n+            boxes = []\n+            for column in reader['boxes']:\n+                row_data = []\n+                for row_number in range(len(column)):\n+                    box_tmp = reader[column[row_number]][:]\n+                    row_data.append(np.transpose(box_tmp))\n+                boxes = row_data",
        "path": "lib/datasets/ms_coco.py",
        "position": 194,
        "original_position": 194,
        "commit_id": "c9b15d0f079680f6363ec0f12911d22696b31b94",
        "original_commit_id": "c9b15d0f079680f6363ec0f12911d22696b31b94",
        "user": {
            "login": "rohitgirdhar",
            "id": 1893429,
            "node_id": "MDQ6VXNlcjE4OTM0Mjk=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/1893429?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rohitgirdhar",
            "html_url": "https://github.com/rohitgirdhar",
            "followers_url": "https://api.github.com/users/rohitgirdhar/followers",
            "following_url": "https://api.github.com/users/rohitgirdhar/following{/other_user}",
            "gists_url": "https://api.github.com/users/rohitgirdhar/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rohitgirdhar/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rohitgirdhar/subscriptions",
            "organizations_url": "https://api.github.com/users/rohitgirdhar/orgs",
            "repos_url": "https://api.github.com/users/rohitgirdhar/repos",
            "events_url": "https://api.github.com/users/rohitgirdhar/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rohitgirdhar/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Shouldn't this be `boxes.append(row_data)`?\n",
        "created_at": "2015-06-19T19:50:34Z",
        "updated_at": "2015-06-19T19:50:34Z",
        "html_url": "https://github.com/rbgirshick/fast-rcnn/pull/13#discussion_r32863010",
        "pull_request_url": "https://api.github.com/repos/rbgirshick/fast-rcnn/pulls/13",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rbgirshick/fast-rcnn/pulls/comments/32863010"
            },
            "html": {
                "href": "https://github.com/rbgirshick/fast-rcnn/pull/13#discussion_r32863010"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rbgirshick/fast-rcnn/pulls/13"
            }
        }
    }
]