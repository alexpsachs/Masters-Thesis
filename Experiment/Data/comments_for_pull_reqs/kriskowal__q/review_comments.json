[
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/86197",
        "pull_request_review_id": null,
        "id": 86197,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg2MTk3",
        "diff_hunk": "@@ -91,14 +91,25 @@ var keys =\n             keys.push(key);\n         return keys;\n     };\n-var reduce =\n-    Array.prototype.reduce =\n-    Array.prototype.reduce || function (callback, basis) {\n+var defineProperty =\n+    Object.defineProperty =\n+    Object.defineProperty || function(obj, prop, descriptor) {\n+        // sadly, this one can't be faked very well\n+        obj[prop] = descriptor.value;\n+    };\n+var reduce = Array.prototype.reduce;",
        "path": "q.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "f37f62a557ebd0fc5f676ab570a480961b9c5178",
        "original_commit_id": "f37f62a557ebd0fc5f676ab570a480961b9c5178",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh, wait. Why are we doing this?\n\nAnywhere Object.defineProperty exists, Array.prototype.reduce will also exist.\n\nSo, if we shim reduce, we are guaranteed that it will place an enumerable property on the Array prototype, since it would use the shimmed defineProperty.\n\nSo, this solution does not help anyone.\n\nPerhaps we need to just not shim Array.prototype.reduce and instead replicate the reduce method in QQ instead of depending on Array.prototype.reduce.\n",
        "created_at": "2011-08-09T00:16:44Z",
        "updated_at": "2011-08-09T00:16:44Z",
        "html_url": "https://github.com/kriskowal/q/pull/25#discussion_r86197",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/25",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/86197"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/25#discussion_r86197"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/25"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/86224",
        "pull_request_review_id": null,
        "id": 86224,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg2MjI0",
        "diff_hunk": "@@ -91,14 +91,25 @@ var keys =\n             keys.push(key);\n         return keys;\n     };\n-var reduce =\n-    Array.prototype.reduce =\n-    Array.prototype.reduce || function (callback, basis) {\n+var defineProperty =\n+    Object.defineProperty =\n+    Object.defineProperty || function(obj, prop, descriptor) {\n+        // sadly, this one can't be faked very well\n+        obj[prop] = descriptor.value;\n+    };\n+var reduce = Array.prototype.reduce;",
        "path": "q.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "f37f62a557ebd0fc5f676ab570a480961b9c5178",
        "original_commit_id": "f37f62a557ebd0fc5f676ab570a480961b9c5178",
        "user": {
            "login": "csosborn",
            "id": 180079,
            "node_id": "MDQ6VXNlcjE4MDA3OQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/180079?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/csosborn",
            "html_url": "https://github.com/csosborn",
            "followers_url": "https://api.github.com/users/csosborn/followers",
            "following_url": "https://api.github.com/users/csosborn/following{/other_user}",
            "gists_url": "https://api.github.com/users/csosborn/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/csosborn/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/csosborn/subscriptions",
            "organizations_url": "https://api.github.com/users/csosborn/orgs",
            "repos_url": "https://api.github.com/users/csosborn/repos",
            "events_url": "https://api.github.com/users/csosborn/events{/privacy}",
            "received_events_url": "https://api.github.com/users/csosborn/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah, I didn't realize that those two things are always found together. Given that, then this solution is overkill. I think all we need is to avoid the assignment shorthand that you had originally:\n\n```\nvar reduce =\n    Array.prototype.reduce =\n    Array.prototype.reduce || function (...\n```\n\nThat code has the effect of overwriting the original non-enumerable property with an enumerable property with the same value. My change effectively solves the problem, but not in the way I thought it did; it's the conditional on line 101 that is important, not the use of defineProperty(). \n",
        "created_at": "2011-08-09T00:42:56Z",
        "updated_at": "2011-08-09T00:46:00Z",
        "html_url": "https://github.com/kriskowal/q/pull/25#discussion_r86224",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/25",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/86224"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/25#discussion_r86224"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/25"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/363827",
        "pull_request_review_id": null,
        "id": 363827,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNw==",
        "diff_hunk": "@@ -217,7 +223,7 @@ foo()\n     throw new Error(\"Can't bar.\");\n })\n .fail(function (error) {\n-    // We get here with either foo\u2019s error or bar\u2019s error\n+    // We get here with either foo's error or bar's error",
        "path": "README.md",
        "position": 33,
        "original_position": 33,
        "commit_id": "b1da24c30c714f219f38f4e5fd83e065cee12e76",
        "original_commit_id": "b1da24c30c714f219f38f4e5fd83e065cee12e76",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I actually use smart-quotes deliberately, but I won\u2019t make a big deal out of it :P\n",
        "created_at": "2012-01-18T17:27:54Z",
        "updated_at": "2012-01-18T17:27:54Z",
        "html_url": "https://github.com/kriskowal/q/pull/38#discussion_r363827",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/38",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/363827"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/38#discussion_r363827"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/38"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/363856",
        "pull_request_review_id": null,
        "id": 363856,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Ng==",
        "diff_hunk": "@@ -217,7 +223,7 @@ foo()\n     throw new Error(\"Can't bar.\");\n })\n .fail(function (error) {\n-    // We get here with either foo\u2019s error or bar\u2019s error\n+    // We get here with either foo's error or bar's error",
        "path": "README.md",
        "position": 33,
        "original_position": 33,
        "commit_id": "b1da24c30c714f219f38f4e5fd83e065cee12e76",
        "original_commit_id": "b1da24c30c714f219f38f4e5fd83e065cee12e76",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oops! I saw the non-smart quote in `\"Can't bar\"` just above, but I see now it's probably a comment-vs.-JS-string distinction.\n",
        "created_at": "2012-01-18T17:33:37Z",
        "updated_at": "2012-01-18T17:33:37Z",
        "html_url": "https://github.com/kriskowal/q/pull/38#discussion_r363856",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/38",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/363856"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/38#discussion_r363856"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/38"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/363864",
        "pull_request_review_id": null,
        "id": 363864,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NA==",
        "diff_hunk": "@@ -217,7 +223,7 @@ foo()\n     throw new Error(\"Can't bar.\");\n })\n .fail(function (error) {\n-    // We get here with either foo\u2019s error or bar\u2019s error\n+    // We get here with either foo's error or bar's error",
        "path": "README.md",
        "position": 33,
        "original_position": 33,
        "commit_id": "b1da24c30c714f219f38f4e5fd83e065cee12e76",
        "original_commit_id": "b1da24c30c714f219f38f4e5fd83e065cee12e76",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It\u2019s ridiculous for me to expect people to maintain them, especially since I\u2019ve only recently committed the keybindings to memory. But, yeah, that was my thinking.\n",
        "created_at": "2012-01-18T17:35:33Z",
        "updated_at": "2012-01-18T17:35:33Z",
        "html_url": "https://github.com/kriskowal/q/pull/38#discussion_r363864",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/38",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/363864"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/38#discussion_r363864"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/38"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430664",
        "pull_request_review_id": null,
        "id": 430664,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY2NA==",
        "diff_hunk": "@@ -66,27 +70,29 @@ try {\n }\n \n // useful for an identity stub and default resolvers\n-function identity (x) {return x;}\n+function identity(x) { return x; }\n \n // shims\n-var shim = function (object, name, shim) {\n-    if (!object[name])\n-        object[name] = shim;\n+function shim(object, name, shimmed) {\n+    if (!object[name]) {\n+        object[name] = shimmed;\n+    }\n     return object[name];\n-};\n+}\n \n var freeze = shim(Object, \"freeze\", identity);\n \n var create = shim(Object, \"create\", function (prototype) {\n-    var Type = function () {};\n+    function Type() { }",
        "path": "q.js",
        "position": 32,
        "original_position": 32,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "JSHint calls for this? I recall that @kangax explicitly mentioned that I should not depend on nested functions. They behavior isn\u2019t specified, and implementations vary. I do not recall which ancient browser definitely broke this though.\n",
        "created_at": "2012-02-08T23:29:28Z",
        "updated_at": "2012-02-08T23:29:28Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430664",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430664"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430664"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430674",
        "pull_request_review_id": null,
        "id": 430674,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY3NA==",
        "diff_hunk": "@@ -158,7 +165,7 @@ function defer() {\n     var pending = [], value;\n \n     var deferred = create(defer.prototype);\n-    var promise = create(Promise.prototype);",
        "path": "q.js",
        "position": 97,
        "original_position": 97,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This borders on bizarre. Perhaps we should separate the `Promise` constructor from the `makePromise` function and export them both.  They are effectively the same, but `makePromise` doesn\u2019t imply that `new` is required.\n",
        "created_at": "2012-02-08T23:32:05Z",
        "updated_at": "2012-02-08T23:32:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430674",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430674"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430674"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430675",
        "pull_request_review_id": null,
        "id": 430675,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY3NQ==",
        "diff_hunk": "@@ -66,27 +70,29 @@ try {\n }\n \n // useful for an identity stub and default resolvers\n-function identity (x) {return x;}\n+function identity(x) { return x; }\n \n // shims\n-var shim = function (object, name, shim) {\n-    if (!object[name])\n-        object[name] = shim;\n+function shim(object, name, shimmed) {\n+    if (!object[name]) {\n+        object[name] = shimmed;\n+    }\n     return object[name];\n-};\n+}\n \n var freeze = shim(Object, \"freeze\", identity);\n \n var create = shim(Object, \"create\", function (prototype) {\n-    var Type = function () {};\n+    function Type() { }",
        "path": "q.js",
        "position": 32,
        "original_position": 32,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah no, this is part of 231c6cf \"Uniformizing function declaration pattern.\" For example `var shim = function () { }` versus `function identity() { }`.\n\nI had no idea it actually made a difference in ancient browsers! What a privileged world I live in.\n",
        "created_at": "2012-02-08T23:32:21Z",
        "updated_at": "2012-02-08T23:32:21Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430675",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430675"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430675"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430686",
        "pull_request_review_id": null,
        "id": 430686,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4Ng==",
        "diff_hunk": "@@ -158,7 +165,7 @@ function defer() {\n     var pending = [], value;\n \n     var deferred = create(defer.prototype);\n-    var promise = create(Promise.prototype);",
        "path": "q.js",
        "position": 97,
        "original_position": 97,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah. What's confusing is that `Promise` wasn't \"really\" a constructor, but instead a factory function---but `Promise.prototype` was used as the exemplar inside that factory function.\n",
        "created_at": "2012-02-08T23:35:02Z",
        "updated_at": "2012-02-08T23:35:02Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430686",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430686"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430686"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430700",
        "pull_request_review_id": null,
        "id": 430700,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwMA==",
        "diff_hunk": "@@ -158,7 +165,7 @@ function defer() {\n     var pending = [], value;\n \n     var deferred = create(defer.prototype);\n-    var promise = create(Promise.prototype);",
        "path": "q.js",
        "position": 97,
        "original_position": 97,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The trouble is that it is potentially useful to export the promise prototype and the idiomatic way of doing so is to export the constructor\u2014with a big first letter. It\u2019s also useful to normalize the constructor so it can function with or without `new`.  But we really only need to export the prototype and the `makePromise` function; the constructor doesn\u2019t even have to exist. We live in the strange world between `new` and `create`.\n",
        "created_at": "2012-02-08T23:38:54Z",
        "updated_at": "2012-02-08T23:38:54Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430700",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430700"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430700"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430775",
        "pull_request_review_id": null,
        "id": 430775,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NQ==",
        "diff_hunk": "@@ -66,27 +70,29 @@ try {\n }\n \n // useful for an identity stub and default resolvers\n-function identity (x) {return x;}\n+function identity(x) { return x; }\n \n // shims\n-var shim = function (object, name, shim) {\n-    if (!object[name])\n-        object[name] = shim;\n+function shim(object, name, shimmed) {\n+    if (!object[name]) {\n+        object[name] = shimmed;\n+    }\n     return object[name];\n-};\n+}\n \n var freeze = shim(Object, \"freeze\", identity);\n \n var create = shim(Object, \"create\", function (prototype) {\n-    var Type = function () {};\n+    function Type() { }",
        "path": "q.js",
        "position": 32,
        "original_position": 32,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "kangax",
            "id": 383,
            "node_id": "MDQ6VXNlcjM4Mw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/383?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kangax",
            "html_url": "https://github.com/kangax",
            "followers_url": "https://api.github.com/users/kangax/followers",
            "following_url": "https://api.github.com/users/kangax/following{/other_user}",
            "gists_url": "https://api.github.com/users/kangax/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kangax/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kangax/subscriptions",
            "organizations_url": "https://api.github.com/users/kangax/orgs",
            "repos_url": "https://api.github.com/users/kangax/repos",
            "events_url": "https://api.github.com/users/kangax/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kangax/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Hm, don't recall anything about nested _function declarations_. Those work fine everywhere as far as I know. There are problems with _named function expressions_ though, as outlined in http://kangax.github.com/nfe (but that doesn't seem to apply here).\n\nOr if we're talking about functions declarations in _blocks_ (e.g. `if (...) { function foo(){ } }`) then yes, that's not something to rely on. It's non-standard, varies across browsers, banned in ES6 and is also starting to get banned in some current edge browsers in strict mode (Firefox, IIRC).\n",
        "created_at": "2012-02-09T00:01:49Z",
        "updated_at": "2012-02-09T00:02:17Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430775",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430775"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430775"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/430781",
        "pull_request_review_id": null,
        "id": 430781,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MQ==",
        "diff_hunk": "@@ -66,27 +70,29 @@ try {\n }\n \n // useful for an identity stub and default resolvers\n-function identity (x) {return x;}\n+function identity(x) { return x; }\n \n // shims\n-var shim = function (object, name, shim) {\n-    if (!object[name])\n-        object[name] = shim;\n+function shim(object, name, shimmed) {\n+    if (!object[name]) {\n+        object[name] = shimmed;\n+    }\n     return object[name];\n-};\n+}\n \n var freeze = shim(Object, \"freeze\", identity);\n \n var create = shim(Object, \"create\", function (prototype) {\n-    var Type = function () {};\n+    function Type() { }",
        "path": "q.js",
        "position": 32,
        "original_position": 32,
        "commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "original_commit_id": "231c6cf8f6bb92c7ca770a5bf3df7914589cbbba",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@kangax Ah, right. Thanks for clarifying. I\u2019ll accept the normalization of named function declarations.\n",
        "created_at": "2012-02-09T00:04:36Z",
        "updated_at": "2012-02-09T00:04:36Z",
        "html_url": "https://github.com/kriskowal/q/pull/46#discussion_r430781",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/46",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/430781"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/46#discussion_r430781"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/46"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/730184",
        "pull_request_review_id": null,
        "id": 730184,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDczMDE4NA==",
        "diff_hunk": "@@ -23,50 +23,49 @@\n \n     // RequireJS\n     if (typeof define === \"function\") {\n-        define(definition);\n+        define([\"exports\"], definition);",
        "path": "q.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "3175d1cfa2596ab2caf9c562f395b15377fcddf6",
        "original_commit_id": "d27c0fb5ee458b6830a124798f99c85c681ee33b",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I presume that this is necessary and has been tested with RequireJS or maybe even a derivative of RequireJS?\n",
        "created_at": "2012-04-25T00:37:31Z",
        "updated_at": "2012-04-25T02:14:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/59#discussion_r730184",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/59",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/730184"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/59#discussion_r730184"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/730187",
        "pull_request_review_id": null,
        "id": 730187,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDczMDE4Nw==",
        "diff_hunk": "@@ -23,50 +23,49 @@\n \n     // RequireJS\n     if (typeof define === \"function\") {\n-        define(definition);\n+        define([\"exports\"], definition);",
        "path": "q.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "3175d1cfa2596ab2caf9c562f395b15377fcddf6",
        "original_commit_id": "d27c0fb5ee458b6830a124798f99c85c681ee33b",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh, it\u2019s because of the omission of `require`\u2026\n",
        "created_at": "2012-04-25T00:38:01Z",
        "updated_at": "2012-04-25T02:14:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/59#discussion_r730187",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/59",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/730187"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/59#discussion_r730187"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/730196",
        "pull_request_review_id": null,
        "id": 730196,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDczMDE5Ng==",
        "diff_hunk": "@@ -23,50 +23,49 @@\n \n     // RequireJS\n     if (typeof define === \"function\") {\n-        define(definition);\n+        define([\"exports\"], definition);",
        "path": "q.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "3175d1cfa2596ab2caf9c562f395b15377fcddf6",
        "original_commit_id": "d27c0fb5ee458b6830a124798f99c85c681ee33b",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Right, exactly. It's in the <a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD#wiki-define-dependencies\">AMD spec</a> so it should be good across AMD loaders.\n",
        "created_at": "2012-04-25T00:40:15Z",
        "updated_at": "2012-04-25T02:14:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/59#discussion_r730196",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/59",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/730196"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/59#discussion_r730196"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/730201",
        "pull_request_review_id": null,
        "id": 730201,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDczMDIwMQ==",
        "diff_hunk": "@@ -23,50 +23,49 @@\n \n     // RequireJS\n     if (typeof define === \"function\") {\n-        define(definition);\n+        define([\"exports\"], definition);",
        "path": "q.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "3175d1cfa2596ab2caf9c562f395b15377fcddf6",
        "original_commit_id": "d27c0fb5ee458b6830a124798f99c85c681ee33b",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Sounds good to me. I believe @jrburke has a vested interest in this continuing to function properly, so I\u2019m name-dropping him here :P\n",
        "created_at": "2012-04-25T00:42:06Z",
        "updated_at": "2012-04-25T02:14:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/59#discussion_r730201",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/59",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/730201"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/59#discussion_r730201"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/730295",
        "pull_request_review_id": null,
        "id": 730295,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDczMDI5NQ==",
        "diff_hunk": "@@ -23,50 +23,49 @@\n \n     // RequireJS\n     if (typeof define === \"function\") {\n-        define(definition);\n+        define([\"exports\"], definition);",
        "path": "q.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "3175d1cfa2596ab2caf9c562f395b15377fcddf6",
        "original_commit_id": "d27c0fb5ee458b6830a124798f99c85c681ee33b",
        "user": {
            "login": "jrburke",
            "id": 73359,
            "node_id": "MDQ6VXNlcjczMzU5",
            "avatar_url": "https://avatars3.githubusercontent.com/u/73359?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jrburke",
            "html_url": "https://github.com/jrburke",
            "followers_url": "https://api.github.com/users/jrburke/followers",
            "following_url": "https://api.github.com/users/jrburke/following{/other_user}",
            "gists_url": "https://api.github.com/users/jrburke/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jrburke/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jrburke/subscriptions",
            "organizations_url": "https://api.github.com/users/jrburke/orgs",
            "repos_url": "https://api.github.com/users/jrburke/repos",
            "events_url": "https://api.github.com/users/jrburke/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jrburke/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Looks good to me, and yes, I definitely want to still use q.\n",
        "created_at": "2012-04-25T01:17:00Z",
        "updated_at": "2012-04-25T02:14:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/59#discussion_r730295",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/59",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/730295"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/59#discussion_r730295"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/790357",
        "pull_request_review_id": null,
        "id": 790357,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc5MDM1Nw==",
        "diff_hunk": "@@ -200,6 +200,165 @@ if (typeof ReturnValue === \"undefined\") {\n     };\n }\n \n+// long stack traces\n+\n+// The following license covers the ``formatStackTrace`` and\n+// ``formatSourcePosition`` functions:\n+\n+// Copyright 2006-2008 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// Stylistic modifications were made to keep with the Q style guidelines.\n+// Insertions are noted inline.\n+\n+function formatStackTrace(error, frames) {\n+    var lines = [];\n+    try {\n+        lines.push(error.toString());\n+    } catch (e) {\n+        try {\n+            lines.push(\"<error: \" + e + \">\");\n+        } catch (ee) {\n+            lines.push(\"<error>\");\n+        }\n+    }\n+    for (var i = 0; i < frames.length; i++) {\n+        var frame = frames[i];\n+        var line;\n+\n+        // <Inserted by @domenic>\n+        if (typeof frame === \"string\") {\n+            lines.push(frame);\n+            continue;\n+        }\n+        // </Inserted by @domenic>\n+\n+        try {\n+            line = formatSourcePosition(frame);\n+        } catch (e) {\n+            try {\n+                line = \"<error: \" + e + \">\";\n+            } catch (ee) {\n+                // Any code that reaches this point is seriously nasty!\n+                line = \"<error>\";\n+            }\n+        }\n+        lines.push(\"    at \" + line);\n+    }\n+    return lines.join(\"\\n\");\n+}\n+\n+function formatSourcePosition(frame) {\n+    var fileLocation = \"\";\n+    if (frame.isNative()) {\n+        fileLocation = \"native\";\n+    } else if (frame.isEval()) {\n+        fileLocation = \"eval at \" + frame.getEvalOrigin();\n+    } else {\n+        var fileName = frame.getFileName();\n+        if (fileName) {\n+            fileLocation += fileName;\n+            var lineNumber = frame.getLineNumber();\n+            if (lineNumber !== null) {\n+                fileLocation += \":\" + lineNumber;\n+                var columnNumber = frame.getColumnNumber();\n+                if (columnNumber) {\n+                    fileLocation += \":\" + columnNumber;\n+                }\n+            }\n+        }\n+    }\n+    if (!fileLocation) {\n+        fileLocation = \"unknown source\";\n+    }\n+    var line = \"\";\n+    var functionName = frame.getFunction().name;\n+    var addPrefix = true;\n+    var isConstructor = frame.isConstructor();\n+    var isMethodCall = !(frame.isToplevel() || isConstructor);\n+    if (isMethodCall) {\n+        var methodName = frame.getMethodName();\n+        line += frame.getTypeName() + \".\";\n+        if (functionName) {\n+            line += functionName;\n+            if (methodName && (methodName !== functionName)) {\n+                line += \" [as \" + methodName + \"]\";\n+            }\n+        } else {\n+            line += methodName || \"<anonymous>\";\n+        }\n+    } else if (isConstructor) {\n+        line += \"new \" + (functionName || \"<anonymous>\");\n+    } else if (functionName) {\n+        line += functionName;\n+    } else {\n+        line += fileLocation;\n+        addPrefix = false;\n+    }\n+    if (addPrefix) {\n+        line += \" (\" + fileLocation + \")\";\n+    }\n+    return line;\n+}\n+\n+/**\n+ * Retrieves an array of structured stack frames parsed from the ``stack``\n+ * property of a given object.\n+ *\n+ * @param objWithStack {Object} an object with a ``stack`` property: usually\n+ * an error or promise.\n+ *\n+ * @returns an array of stack frame objects. For more information, see\n+ * [V8's JavaScript stack trace API documentation](http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).\n+ */\n+function getStackFrames(objWithStack) {\n+    var oldPrepareStackTrace = Error.prepareStackTrace;\n+\n+    Error.prepareStackTrace = function (error, frames) {\n+        // Filter out frames from the innards of Node and Q.",
        "path": "q.js",
        "position": 143,
        "original_position": 143,
        "commit_id": "8f2bc5e88b8e7b388c2d7c88331f2f4974927969",
        "original_commit_id": "2ccccb7c1ddf76d7dbd726df22981bfa9ce3537f",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I am curious whether we could make this less anti-social. Consider folks who have provided their own overrides, or folks debugging Node core. Good enough for now though!\n",
        "created_at": "2012-05-08T18:56:49Z",
        "updated_at": "2012-05-08T19:19:55Z",
        "html_url": "https://github.com/kriskowal/q/pull/66#discussion_r790357",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/66",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/790357"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/66#discussion_r790357"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/790396",
        "pull_request_review_id": null,
        "id": 790396,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc5MDM5Ng==",
        "diff_hunk": "@@ -200,6 +200,165 @@ if (typeof ReturnValue === \"undefined\") {\n     };\n }\n \n+// long stack traces\n+\n+// The following license covers the ``formatStackTrace`` and\n+// ``formatSourcePosition`` functions:\n+\n+// Copyright 2006-2008 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// Stylistic modifications were made to keep with the Q style guidelines.\n+// Insertions are noted inline.\n+\n+function formatStackTrace(error, frames) {\n+    var lines = [];\n+    try {\n+        lines.push(error.toString());\n+    } catch (e) {\n+        try {\n+            lines.push(\"<error: \" + e + \">\");\n+        } catch (ee) {\n+            lines.push(\"<error>\");\n+        }\n+    }\n+    for (var i = 0; i < frames.length; i++) {\n+        var frame = frames[i];\n+        var line;\n+\n+        // <Inserted by @domenic>\n+        if (typeof frame === \"string\") {\n+            lines.push(frame);\n+            continue;\n+        }\n+        // </Inserted by @domenic>\n+\n+        try {\n+            line = formatSourcePosition(frame);\n+        } catch (e) {\n+            try {\n+                line = \"<error: \" + e + \">\";\n+            } catch (ee) {\n+                // Any code that reaches this point is seriously nasty!\n+                line = \"<error>\";\n+            }\n+        }\n+        lines.push(\"    at \" + line);\n+    }\n+    return lines.join(\"\\n\");\n+}\n+\n+function formatSourcePosition(frame) {\n+    var fileLocation = \"\";\n+    if (frame.isNative()) {\n+        fileLocation = \"native\";\n+    } else if (frame.isEval()) {\n+        fileLocation = \"eval at \" + frame.getEvalOrigin();\n+    } else {\n+        var fileName = frame.getFileName();\n+        if (fileName) {\n+            fileLocation += fileName;\n+            var lineNumber = frame.getLineNumber();\n+            if (lineNumber !== null) {\n+                fileLocation += \":\" + lineNumber;\n+                var columnNumber = frame.getColumnNumber();\n+                if (columnNumber) {\n+                    fileLocation += \":\" + columnNumber;\n+                }\n+            }\n+        }\n+    }\n+    if (!fileLocation) {\n+        fileLocation = \"unknown source\";\n+    }\n+    var line = \"\";\n+    var functionName = frame.getFunction().name;\n+    var addPrefix = true;\n+    var isConstructor = frame.isConstructor();\n+    var isMethodCall = !(frame.isToplevel() || isConstructor);\n+    if (isMethodCall) {\n+        var methodName = frame.getMethodName();\n+        line += frame.getTypeName() + \".\";\n+        if (functionName) {\n+            line += functionName;\n+            if (methodName && (methodName !== functionName)) {\n+                line += \" [as \" + methodName + \"]\";\n+            }\n+        } else {\n+            line += methodName || \"<anonymous>\";\n+        }\n+    } else if (isConstructor) {\n+        line += \"new \" + (functionName || \"<anonymous>\");\n+    } else if (functionName) {\n+        line += functionName;\n+    } else {\n+        line += fileLocation;\n+        addPrefix = false;\n+    }\n+    if (addPrefix) {\n+        line += \" (\" + fileLocation + \")\";\n+    }\n+    return line;\n+}\n+\n+/**\n+ * Retrieves an array of structured stack frames parsed from the ``stack``\n+ * property of a given object.\n+ *\n+ * @param objWithStack {Object} an object with a ``stack`` property: usually\n+ * an error or promise.\n+ *\n+ * @returns an array of stack frame objects. For more information, see\n+ * [V8's JavaScript stack trace API documentation](http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).\n+ */\n+function getStackFrames(objWithStack) {\n+    var oldPrepareStackTrace = Error.prepareStackTrace;\n+\n+    Error.prepareStackTrace = function (error, frames) {\n+        // Filter out frames from the innards of Node and Q.",
        "path": "q.js",
        "position": 143,
        "original_position": 143,
        "commit_id": "8f2bc5e88b8e7b388c2d7c88331f2f4974927969",
        "original_commit_id": "2ccccb7c1ddf76d7dbd726df22981bfa9ce3537f",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm not sure I understand 100% of the concerns, but perhaps we could blacklist only specific function name + filename combinations.\n",
        "created_at": "2012-05-08T19:00:51Z",
        "updated_at": "2012-05-08T19:19:55Z",
        "html_url": "https://github.com/kriskowal/q/pull/66#discussion_r790396",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/66",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/790396"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/66#discussion_r790396"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/790431",
        "pull_request_review_id": null,
        "id": 790431,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc5MDQzMQ==",
        "diff_hunk": "@@ -200,6 +200,165 @@ if (typeof ReturnValue === \"undefined\") {\n     };\n }\n \n+// long stack traces\n+\n+// The following license covers the ``formatStackTrace`` and\n+// ``formatSourcePosition`` functions:\n+\n+// Copyright 2006-2008 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// Stylistic modifications were made to keep with the Q style guidelines.\n+// Insertions are noted inline.\n+\n+function formatStackTrace(error, frames) {\n+    var lines = [];\n+    try {\n+        lines.push(error.toString());\n+    } catch (e) {\n+        try {\n+            lines.push(\"<error: \" + e + \">\");\n+        } catch (ee) {\n+            lines.push(\"<error>\");\n+        }\n+    }\n+    for (var i = 0; i < frames.length; i++) {\n+        var frame = frames[i];\n+        var line;\n+\n+        // <Inserted by @domenic>\n+        if (typeof frame === \"string\") {\n+            lines.push(frame);\n+            continue;\n+        }\n+        // </Inserted by @domenic>\n+\n+        try {\n+            line = formatSourcePosition(frame);\n+        } catch (e) {\n+            try {\n+                line = \"<error: \" + e + \">\";\n+            } catch (ee) {\n+                // Any code that reaches this point is seriously nasty!\n+                line = \"<error>\";\n+            }\n+        }\n+        lines.push(\"    at \" + line);\n+    }\n+    return lines.join(\"\\n\");\n+}\n+\n+function formatSourcePosition(frame) {\n+    var fileLocation = \"\";\n+    if (frame.isNative()) {\n+        fileLocation = \"native\";\n+    } else if (frame.isEval()) {\n+        fileLocation = \"eval at \" + frame.getEvalOrigin();\n+    } else {\n+        var fileName = frame.getFileName();\n+        if (fileName) {\n+            fileLocation += fileName;\n+            var lineNumber = frame.getLineNumber();\n+            if (lineNumber !== null) {\n+                fileLocation += \":\" + lineNumber;\n+                var columnNumber = frame.getColumnNumber();\n+                if (columnNumber) {\n+                    fileLocation += \":\" + columnNumber;\n+                }\n+            }\n+        }\n+    }\n+    if (!fileLocation) {\n+        fileLocation = \"unknown source\";\n+    }\n+    var line = \"\";\n+    var functionName = frame.getFunction().name;\n+    var addPrefix = true;\n+    var isConstructor = frame.isConstructor();\n+    var isMethodCall = !(frame.isToplevel() || isConstructor);\n+    if (isMethodCall) {\n+        var methodName = frame.getMethodName();\n+        line += frame.getTypeName() + \".\";\n+        if (functionName) {\n+            line += functionName;\n+            if (methodName && (methodName !== functionName)) {\n+                line += \" [as \" + methodName + \"]\";\n+            }\n+        } else {\n+            line += methodName || \"<anonymous>\";\n+        }\n+    } else if (isConstructor) {\n+        line += \"new \" + (functionName || \"<anonymous>\");\n+    } else if (functionName) {\n+        line += functionName;\n+    } else {\n+        line += fileLocation;\n+        addPrefix = false;\n+    }\n+    if (addPrefix) {\n+        line += \" (\" + fileLocation + \")\";\n+    }\n+    return line;\n+}\n+\n+/**\n+ * Retrieves an array of structured stack frames parsed from the ``stack``\n+ * property of a given object.\n+ *\n+ * @param objWithStack {Object} an object with a ``stack`` property: usually\n+ * an error or promise.\n+ *\n+ * @returns an array of stack frame objects. For more information, see\n+ * [V8's JavaScript stack trace API documentation](http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).\n+ */\n+function getStackFrames(objWithStack) {\n+    var oldPrepareStackTrace = Error.prepareStackTrace;\n+\n+    Error.prepareStackTrace = function (error, frames) {\n+        // Filter out frames from the innards of Node and Q.",
        "path": "q.js",
        "position": 143,
        "original_position": 143,
        "commit_id": "8f2bc5e88b8e7b388c2d7c88331f2f4974927969",
        "original_commit_id": "2ccccb7c1ddf76d7dbd726df22981bfa9ce3537f",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I should try this in a browser too. I bet I want to filter out \"native code\" or something like that.\n",
        "created_at": "2012-05-08T19:04:28Z",
        "updated_at": "2012-05-08T19:19:55Z",
        "html_url": "https://github.com/kriskowal/q/pull/66#discussion_r790431",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/66",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/790431"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/66#discussion_r790431"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/66"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/870128",
        "pull_request_review_id": null,
        "id": 870128,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3MDEyOA==",
        "diff_hunk": "@@ -873,13 +873,17 @@ function when(value, fulfilled, rejected) {\n \n     nextTick(function () {\n         resolve(value).promiseSend(\"when\", function (value) {\n-            if (done) {\n-                return;\n-            }\n-            done = true;\n             resolve(value).promiseSend(\"when\", function (value) {\n+                if (done) {\n+                    return;\n+                }\n+                done = true;\n                 deferred.resolve(_fulfilled(value));\n             }, function (exception) {",
        "path": "q.js",
        "position": 14,
        "original_position": 14,
        "commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "original_commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "user": {
            "login": "danfuzz",
            "id": 1090235,
            "node_id": "MDQ6VXNlcjEwOTAyMzU=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1090235?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/danfuzz",
            "html_url": "https://github.com/danfuzz",
            "followers_url": "https://api.github.com/users/danfuzz/followers",
            "following_url": "https://api.github.com/users/danfuzz/following{/other_user}",
            "gists_url": "https://api.github.com/users/danfuzz/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/danfuzz/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/danfuzz/subscriptions",
            "organizations_url": "https://api.github.com/users/danfuzz/orgs",
            "repos_url": "https://api.github.com/users/danfuzz/repos",
            "events_url": "https://api.github.com/users/danfuzz/events{/privacy}",
            "received_events_url": "https://api.github.com/users/danfuzz/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Since this rejection function and the other rejection function are now identical, does it make sense to refactor it such that it's just passing (say) a direct reference to a suitably-modified `_rejected`?\n",
        "created_at": "2012-05-23T18:48:11Z",
        "updated_at": "2012-05-23T18:48:11Z",
        "html_url": "https://github.com/kriskowal/q/pull/76#discussion_r870128",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/76",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/870128"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/76#discussion_r870128"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/76"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/870221",
        "pull_request_review_id": null,
        "id": 870221,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3MDIyMQ==",
        "diff_hunk": "@@ -873,13 +873,17 @@ function when(value, fulfilled, rejected) {\n \n     nextTick(function () {\n         resolve(value).promiseSend(\"when\", function (value) {\n-            if (done) {\n-                return;\n-            }\n-            done = true;\n             resolve(value).promiseSend(\"when\", function (value) {\n+                if (done) {\n+                    return;\n+                }\n+                done = true;\n                 deferred.resolve(_fulfilled(value));\n             }, function (exception) {",
        "path": "q.js",
        "position": 14,
        "original_position": 14,
        "commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "original_commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You have prompted me to wonder why I\u2019m sending nested when messages at all. All the tests pass with a single layer.\n\nRather than factor out the common rejection, I think I will factor out the nested \"when\".\n\nGood eye.\n",
        "created_at": "2012-05-23T19:04:05Z",
        "updated_at": "2012-05-23T19:04:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/76#discussion_r870221",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/76",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/870221"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/76#discussion_r870221"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/76"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/871736",
        "pull_request_review_id": null,
        "id": 871736,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3MTczNg==",
        "diff_hunk": "@@ -873,13 +873,17 @@ function when(value, fulfilled, rejected) {\n \n     nextTick(function () {\n         resolve(value).promiseSend(\"when\", function (value) {\n-            if (done) {\n-                return;\n-            }\n-            done = true;\n             resolve(value).promiseSend(\"when\", function (value) {\n+                if (done) {\n+                    return;\n+                }\n+                done = true;\n                 deferred.resolve(_fulfilled(value));\n             }, function (exception) {",
        "path": "q.js",
        "position": 14,
        "original_position": 14,
        "commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "original_commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "user": {
            "login": "ForbesLindesay",
            "id": 1260646,
            "node_id": "MDQ6VXNlcjEyNjA2NDY=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/1260646?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ForbesLindesay",
            "html_url": "https://github.com/ForbesLindesay",
            "followers_url": "https://api.github.com/users/ForbesLindesay/followers",
            "following_url": "https://api.github.com/users/ForbesLindesay/following{/other_user}",
            "gists_url": "https://api.github.com/users/ForbesLindesay/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/ForbesLindesay/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ForbesLindesay/subscriptions",
            "organizations_url": "https://api.github.com/users/ForbesLindesay/orgs",
            "repos_url": "https://api.github.com/users/ForbesLindesay/repos",
            "events_url": "https://api.github.com/users/ForbesLindesay/events{/privacy}",
            "received_events_url": "https://api.github.com/users/ForbesLindesay/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I have to confess to being confused, but without the nested when, it would've 'resolved' to a rejected promise in @danfuzz 's example (see issue #75)?\n",
        "created_at": "2012-05-23T22:29:38Z",
        "updated_at": "2012-05-23T22:29:38Z",
        "html_url": "https://github.com/kriskowal/q/pull/76#discussion_r871736",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/76",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/871736"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/76#discussion_r871736"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/76"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/872140",
        "pull_request_review_id": null,
        "id": 872140,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3MjE0MA==",
        "diff_hunk": "@@ -873,13 +873,17 @@ function when(value, fulfilled, rejected) {\n \n     nextTick(function () {\n         resolve(value).promiseSend(\"when\", function (value) {\n-            if (done) {\n-                return;\n-            }\n-            done = true;\n             resolve(value).promiseSend(\"when\", function (value) {\n+                if (done) {\n+                    return;\n+                }\n+                done = true;\n                 deferred.resolve(_fulfilled(value));\n             }, function (exception) {",
        "path": "q.js",
        "position": 14,
        "original_position": 14,
        "commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "original_commit_id": "3063bd7023c2ff869503919055b25a543fd40ce6",
        "user": {
            "login": "danfuzz",
            "id": 1090235,
            "node_id": "MDQ6VXNlcjEwOTAyMzU=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1090235?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/danfuzz",
            "html_url": "https://github.com/danfuzz",
            "followers_url": "https://api.github.com/users/danfuzz/followers",
            "following_url": "https://api.github.com/users/danfuzz/following{/other_user}",
            "gists_url": "https://api.github.com/users/danfuzz/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/danfuzz/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/danfuzz/subscriptions",
            "organizations_url": "https://api.github.com/users/danfuzz/orgs",
            "repos_url": "https://api.github.com/users/danfuzz/repos",
            "events_url": "https://api.github.com/users/danfuzz/events{/privacy}",
            "received_events_url": "https://api.github.com/users/danfuzz/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah, I am similarly confused. I've been poking and prodding at the code today to try to really get what's going on. Still not there\u2026\n",
        "created_at": "2012-05-24T00:08:41Z",
        "updated_at": "2012-05-24T00:08:41Z",
        "html_url": "https://github.com/kriskowal/q/pull/76#discussion_r872140",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/76",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/872140"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/76#discussion_r872140"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/76"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/1276442",
        "pull_request_review_id": null,
        "id": 1276442,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyNzY0NDI=",
        "diff_hunk": "@@ -1032,6 +1032,48 @@ describe(\"node support\", function () {\n \n });\n \n+describe(\"decorator functions\", function () {\n+    describe(\"promised\", function () {\n+        var exception = new Error(\"That is not the meaning of life.\");\n+        it(\"resolves promised arguments\", function () {\n+            var sum = Q.promised(function add(a, b) {\n+                return a + b;\n+            });\n+            return sum(Q.resolve(4), Q.resolve(5)).then(function (sum) {\n+                expect(sum).toEqual(9);\n+            });\n+        });\n+        it(\"resolves promised this\", function () {",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 15,
        "commit_id": "c28c072e07e479cbadc34d03fc1a6e97a26cbffc",
        "original_commit_id": "9b5034069d27f97784330f350a9de867402a757b",
        "user": {
            "login": "michaelficarra",
            "id": 218840,
            "node_id": "MDQ6VXNlcjIxODg0MA==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/218840?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/michaelficarra",
            "html_url": "https://github.com/michaelficarra",
            "followers_url": "https://api.github.com/users/michaelficarra/followers",
            "following_url": "https://api.github.com/users/michaelficarra/following{/other_user}",
            "gists_url": "https://api.github.com/users/michaelficarra/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/michaelficarra/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/michaelficarra/subscriptions",
            "organizations_url": "https://api.github.com/users/michaelficarra/orgs",
            "repos_url": "https://api.github.com/users/michaelficarra/repos",
            "events_url": "https://api.github.com/users/michaelficarra/events{/privacy}",
            "received_events_url": "https://api.github.com/users/michaelficarra/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Isn't this another `this`?\n",
        "created_at": "2012-07-31T18:53:17Z",
        "updated_at": "2012-08-01T10:35:36Z",
        "html_url": "https://github.com/kriskowal/q/pull/101#discussion_r1276442",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/101",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/1276442"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/101#discussion_r1276442"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/101"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/1846549",
        "pull_request_review_id": null,
        "id": 1846549,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDY1NDk=",
        "diff_hunk": "@@ -1439,7 +1440,14 @@ function end(promise) {\n                 throw error;\n             }\n         });\n-    });\n+    }\n+\n+    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n+    var promiseToHandle = fulfilled || rejected || progress ?\n+                              when(promise, fulfilled, rejected, progress) :\n+                              promise;",
        "path": "q.js",
        "position": null,
        "original_position": 40,
        "commit_id": "16c913dbff60c26214a6650bcde7c1bd23325dcc",
        "original_commit_id": "0c674805546e2f88d2fa09cf433c7c2e05645a53",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "My preferred style is to only advance one indent on subsequent lines. I don\u2019t align with an operator on the previous.\n",
        "created_at": "2012-10-15T20:03:35Z",
        "updated_at": "2012-10-16T04:00:14Z",
        "html_url": "https://github.com/kriskowal/q/pull/126#discussion_r1846549",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/126",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/1846549"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/126#discussion_r1846549"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/126"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2271904",
        "pull_request_review_id": null,
        "id": 2271904,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNzE5MDQ=",
        "diff_hunk": "@@ -24,3 +38,29 @@ jasmine.Block.prototype.execute = function (onComplete) {\n     }\n };\n \n+/**\n+ * Tests and documents the behavior of the above extension to jasmine.\n+ */\n+describe('jasmine-promise', function() {\n+  it('passes if the deferred resolves immediately', function() {\n+    var deferred = Q.defer();\n+    deferred.resolve();\n+    return deferred.promise;\n+  });\n+  it('passes if the deferred resolves after a short delay', function() {\n+    var deferred = Q.defer();\n+    setTimeout(function() {deferred.resolve();}, 100);\n+    return deferred.promise;\n+  });\n+  // These are expected to fail. Remove the x from xit to test that.",
        "path": "spec/lib/jasmine-promise.js",
        "position": null,
        "original_position": 51,
        "commit_id": "6d8a164eb4b6dd2130d6b4aefbb432c0989981eb",
        "original_commit_id": "aa5155c143e7ab2b261b6753ec61150563507e4d",
        "user": {
            "login": "rictic",
            "id": 1659,
            "node_id": "MDQ6VXNlcjE2NTk=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1659?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rictic",
            "html_url": "https://github.com/rictic",
            "followers_url": "https://api.github.com/users/rictic/followers",
            "following_url": "https://api.github.com/users/rictic/following{/other_user}",
            "gists_url": "https://api.github.com/users/rictic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rictic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rictic/subscriptions",
            "organizations_url": "https://api.github.com/users/rictic/orgs",
            "repos_url": "https://api.github.com/users/rictic/repos",
            "events_url": "https://api.github.com/users/rictic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rictic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is hacky, but I didn't see a better way of doing it.\n",
        "created_at": "2012-11-29T22:20:02Z",
        "updated_at": "2012-11-29T23:08:42Z",
        "html_url": "https://github.com/kriskowal/q/pull/147#discussion_r2271904",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/147",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2271904"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/147#discussion_r2271904"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/147"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2271921",
        "pull_request_review_id": null,
        "id": 2271921,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNzE5MjE=",
        "diff_hunk": "@@ -24,3 +38,29 @@ jasmine.Block.prototype.execute = function (onComplete) {\n     }\n };\n \n+/**\n+ * Tests and documents the behavior of the above extension to jasmine.\n+ */\n+describe('jasmine-promise', function() {\n+  it('passes if the deferred resolves immediately', function() {\n+    var deferred = Q.defer();\n+    deferred.resolve();\n+    return deferred.promise;\n+  });\n+  it('passes if the deferred resolves after a short delay', function() {\n+    var deferred = Q.defer();\n+    setTimeout(function() {deferred.resolve();}, 100);\n+    return deferred.promise;\n+  });\n+  // These are expected to fail. Remove the x from xit to test that.",
        "path": "spec/lib/jasmine-promise.js",
        "position": null,
        "original_position": 51,
        "commit_id": "6d8a164eb4b6dd2130d6b4aefbb432c0989981eb",
        "original_commit_id": "aa5155c143e7ab2b261b6753ec61150563507e4d",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Heh, yeah, testing jasmine-promise using itself is not ideal :P\n",
        "created_at": "2012-11-29T22:21:34Z",
        "updated_at": "2012-11-29T23:08:42Z",
        "html_url": "https://github.com/kriskowal/q/pull/147#discussion_r2271921",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/147",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2271921"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/147#discussion_r2271921"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/147"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2272014",
        "pull_request_review_id": null,
        "id": 2272014,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNzIwMTQ=",
        "diff_hunk": "@@ -24,3 +38,29 @@ jasmine.Block.prototype.execute = function (onComplete) {\n     }\n };\n \n+/**\n+ * Tests and documents the behavior of the above extension to jasmine.\n+ */\n+describe('jasmine-promise', function() {\n+  it('passes if the deferred resolves immediately', function() {\n+    var deferred = Q.defer();\n+    deferred.resolve();\n+    return deferred.promise;\n+  });\n+  it('passes if the deferred resolves after a short delay', function() {\n+    var deferred = Q.defer();\n+    setTimeout(function() {deferred.resolve();}, 100);\n+    return deferred.promise;\n+  });\n+  // These are expected to fail. Remove the x from xit to test that.",
        "path": "spec/lib/jasmine-promise.js",
        "position": null,
        "original_position": 51,
        "commit_id": "6d8a164eb4b6dd2130d6b4aefbb432c0989981eb",
        "original_commit_id": "aa5155c143e7ab2b261b6753ec61150563507e4d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Good point!\n",
        "created_at": "2012-11-29T22:29:06Z",
        "updated_at": "2012-11-29T23:08:42Z",
        "html_url": "https://github.com/kriskowal/q/pull/147#discussion_r2272014",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/147",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2272014"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/147#discussion_r2272014"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/147"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2370817",
        "pull_request_review_id": null,
        "id": 2370817,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzA4MTc=",
        "diff_hunk": "@@ -109,10 +109,23 @@ if (typeof process !== \"undefined\") {\n         channel.port2.postMessage(0);\n     };\n } else {\n-    // old browsers\n-    nextTick = function (task) {\n-        setTimeout(task, 0);\n-    };\n+    var vertx = null;\n+\n+    try {\n+        vertx = require('vertx.js');",
        "path": "q.js",
        "position": 11,
        "original_position": 11,
        "commit_id": "c53f454847ef6774586f578a4beae69a276eb1ea",
        "original_commit_id": "c53f454847ef6774586f578a4beae69a276eb1ea",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is there any other way to detect VertX or alternately to patch process.nextTick or the proposed standard setImmediate instead? This line will interfere with static dependency analysis for asynchronous CommonJS module loaders.\n",
        "created_at": "2012-12-10T22:21:37Z",
        "updated_at": "2012-12-10T22:21:37Z",
        "html_url": "https://github.com/kriskowal/q/pull/150#discussion_r2370817",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/150",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2370817"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/150#discussion_r2370817"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/150"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2370931",
        "pull_request_review_id": null,
        "id": 2370931,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzA5MzE=",
        "diff_hunk": "@@ -109,10 +109,23 @@ if (typeof process !== \"undefined\") {\n         channel.port2.postMessage(0);\n     };\n } else {\n-    // old browsers\n-    nextTick = function (task) {\n-        setTimeout(task, 0);\n-    };\n+    var vertx = null;\n+\n+    try {\n+        vertx = require('vertx.js');",
        "path": "q.js",
        "position": 11,
        "original_position": 11,
        "commit_id": "c53f454847ef6774586f578a4beae69a276eb1ea",
        "original_commit_id": "c53f454847ef6774586f578a4beae69a276eb1ea",
        "user": {
            "login": "blalor",
            "id": 109915,
            "node_id": "MDQ6VXNlcjEwOTkxNQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/109915?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/blalor",
            "html_url": "https://github.com/blalor",
            "followers_url": "https://api.github.com/users/blalor/followers",
            "following_url": "https://api.github.com/users/blalor/following{/other_user}",
            "gists_url": "https://api.github.com/users/blalor/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/blalor/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/blalor/subscriptions",
            "organizations_url": "https://api.github.com/users/blalor/orgs",
            "repos_url": "https://api.github.com/users/blalor/repos",
            "events_url": "https://api.github.com/users/blalor/events{/privacy}",
            "received_events_url": "https://api.github.com/users/blalor/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm a relative JavaScript novice.  I first looked for a way to provide a global setTimeout() of my own for Q to use, but wasn't able to figure out how to do that, as Rhino's CommonJS loader seems to (rightly) completely sandbox `require()`'d modules.  I could look for the presence of a tell-tale class; something along the lines of \n\n```\nif (typeof org.vertx.java.core.Vertx !== 'undefined') { /* do Vert.x-specific stuff */ }\n```\n\nbut then I'd still need to `require()` the vertx module.  That seems less direct, but would it suit your needs?\n",
        "created_at": "2012-12-10T22:28:39Z",
        "updated_at": "2012-12-10T22:29:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/150#discussion_r2370931",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/150",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2370931"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/150#discussion_r2370931"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/150"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2371042",
        "pull_request_review_id": null,
        "id": 2371042,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzEwNDI=",
        "diff_hunk": "@@ -109,10 +109,23 @@ if (typeof process !== \"undefined\") {\n         channel.port2.postMessage(0);\n     };\n } else {\n-    // old browsers\n-    nextTick = function (task) {\n-        setTimeout(task, 0);\n-    };\n+    var vertx = null;\n+\n+    try {\n+        vertx = require('vertx.js');",
        "path": "q.js",
        "position": 11,
        "original_position": 11,
        "commit_id": "c53f454847ef6774586f578a4beae69a276eb1ea",
        "original_commit_id": "c53f454847ef6774586f578a4beae69a276eb1ea",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The most elegant solution would be for all platforms to implement the standard setImmediate so none of this song and dance would be necessary. Related issue here. https://github.com/vert-x/vert.x/issues/448\n\nDiving into the Java packages namespace is not acceptable because touching those names would initialize the JVM in some browsers. That is, unless we find a solution for that problem as well.\n",
        "created_at": "2012-12-10T22:34:35Z",
        "updated_at": "2012-12-10T22:34:35Z",
        "html_url": "https://github.com/kriskowal/q/pull/150#discussion_r2371042",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/150",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2371042"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/150#discussion_r2371042"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/150"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2839805",
        "pull_request_review_id": null,
        "id": 2839805,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Mzk4MDU=",
        "diff_hunk": "@@ -91,11 +91,11 @@ if (typeof process !== \"undefined\") {\n     // http://www.nonblocking.io/2011/06/windownexttick.html\n     var channel = new MessageChannel();\n     // linked list of tasks (single, with head node)\n-    var head = {}, tail = head;\n+    var head = {task: void 0, next: null}, tail = head;\n     channel.port1.onmessage = function () {\n         head = head.next;\n         var task = head.task;\n-        delete head.task;\n+        head.task = void 0;\n         task();\n     };\n     nextTick = function (task) {",
        "path": "q.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "0f819cb23284c42fa946dbfa91fbe30f84b45d0c",
        "original_commit_id": "63b287ede86fd1c188cb929099595aa476e715b9",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The bulk of node creation occurs down here in `nextTick`. We should add the `next` property there too.\n",
        "created_at": "2013-01-31T08:12:53Z",
        "updated_at": "2013-02-09T16:39:10Z",
        "html_url": "https://github.com/kriskowal/q/pull/191#discussion_r2839805",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/191",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2839805"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/191#discussion_r2839805"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/191"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2840027",
        "pull_request_review_id": null,
        "id": 2840027,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDAwMjc=",
        "diff_hunk": "@@ -91,11 +91,11 @@ if (typeof process !== \"undefined\") {\n     // http://www.nonblocking.io/2011/06/windownexttick.html\n     var channel = new MessageChannel();\n     // linked list of tasks (single, with head node)\n-    var head = {}, tail = head;\n+    var head = {task: void 0, next: null}, tail = head;\n     channel.port1.onmessage = function () {\n         head = head.next;\n         var task = head.task;\n-        delete head.task;\n+        head.task = void 0;\n         task();\n     };\n     nextTick = function (task) {",
        "path": "q.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "0f819cb23284c42fa946dbfa91fbe30f84b45d0c",
        "original_commit_id": "63b287ede86fd1c188cb929099595aa476e715b9",
        "user": {
            "login": "rkatic",
            "id": 38577,
            "node_id": "MDQ6VXNlcjM4NTc3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/38577?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rkatic",
            "html_url": "https://github.com/rkatic",
            "followers_url": "https://api.github.com/users/rkatic/followers",
            "following_url": "https://api.github.com/users/rkatic/following{/other_user}",
            "gists_url": "https://api.github.com/users/rkatic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rkatic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rkatic/subscriptions",
            "organizations_url": "https://api.github.com/users/rkatic/orgs",
            "repos_url": "https://api.github.com/users/rkatic/repos",
            "events_url": "https://api.github.com/users/rkatic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rkatic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yep, I definitely need to go sleep now, it's 9:34 AM here.\n",
        "created_at": "2013-01-31T08:34:44Z",
        "updated_at": "2013-02-09T16:39:10Z",
        "html_url": "https://github.com/kriskowal/q/pull/191#discussion_r2840027",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/191",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2840027"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/191#discussion_r2840027"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/191"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/2840070",
        "pull_request_review_id": null,
        "id": 2840070,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDAwNzA=",
        "diff_hunk": "@@ -91,11 +91,11 @@ if (typeof process !== \"undefined\") {\n     // http://www.nonblocking.io/2011/06/windownexttick.html\n     var channel = new MessageChannel();\n     // linked list of tasks (single, with head node)\n-    var head = {}, tail = head;\n+    var head = {task: void 0, next: null}, tail = head;\n     channel.port1.onmessage = function () {\n         head = head.next;\n         var task = head.task;\n-        delete head.task;\n+        head.task = void 0;\n         task();\n     };\n     nextTick = function (task) {",
        "path": "q.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "0f819cb23284c42fa946dbfa91fbe30f84b45d0c",
        "original_commit_id": "63b287ede86fd1c188cb929099595aa476e715b9",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nice, thanks. Get some rest :P It\u2019s merely 12:39 AM here and _I_ should do the same.\n",
        "created_at": "2013-01-31T08:39:45Z",
        "updated_at": "2013-02-09T16:39:10Z",
        "html_url": "https://github.com/kriskowal/q/pull/191#discussion_r2840070",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/191",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/2840070"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/191#discussion_r2840070"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/191"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197842",
        "pull_request_review_id": null,
        "id": 3197842,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTc4NDI=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "If `typeof define.amd === 'object'`, it is guaranteed that `define.amd` is truthy as well, so that is superfluous. Was there some other check supposed to follow that?\n",
        "created_at": "2013-02-28T22:59:14Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3197842",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197842"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3197842"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197866",
        "pull_request_review_id": null,
        "id": 3197866,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTc4NjY=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`define.amd === null` ;)\n",
        "created_at": "2013-02-28T23:01:42Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3197866",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197866"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3197866"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197876",
        "pull_request_review_id": null,
        "id": 3197876,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTc4NzY=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "weird that `define.amd === true` isn't allowed though.\n",
        "created_at": "2013-02-28T23:02:16Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3197876",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197876"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3197876"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197899",
        "pull_request_review_id": null,
        "id": 3197899,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTc4OTk=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "True enough that `null` is a the falsy \u201cobject\u201d. But is there really some real-world case where `define.amd === null` that necessitates this extra code?\n",
        "created_at": "2013-02-28T23:03:50Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3197899",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197899"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3197899"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197916",
        "pull_request_review_id": null,
        "id": 3197916,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTc5MTY=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Not sure what \"The r.js optimizer checks for a predefined if statement\" means exactly, gonna have to ask @terinjokes or @jrburke to explain.\n",
        "created_at": "2013-02-28T23:05:43Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3197916",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3197916"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3197916"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3198182",
        "pull_request_review_id": null,
        "id": 3198182,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTgxODI=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "terinjokes",
            "id": 273509,
            "node_id": "MDQ6VXNlcjI3MzUwOQ==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/273509?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/terinjokes",
            "html_url": "https://github.com/terinjokes",
            "followers_url": "https://api.github.com/users/terinjokes/followers",
            "following_url": "https://api.github.com/users/terinjokes/following{/other_user}",
            "gists_url": "https://api.github.com/users/terinjokes/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/terinjokes/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/terinjokes/subscriptions",
            "organizations_url": "https://api.github.com/users/terinjokes/orgs",
            "repos_url": "https://api.github.com/users/terinjokes/repos",
            "events_url": "https://api.github.com/users/terinjokes/events{/privacy}",
            "received_events_url": "https://api.github.com/users/terinjokes/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@domenic A bunch of regexes it considers valid formats and will namespace for (to avoid namespacing unrelated define and requires)\n\n@kriskowal I can switch the pull request to use `typeof define === \"function\" && define.amd` if that's what is preferred, it matches one.\n",
        "created_at": "2013-02-28T23:26:08Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3198182",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3198182"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3198182"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3201513",
        "pull_request_review_id": null,
        "id": 3201513,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDE1MTM=",
        "diff_hunk": "@@ -44,7 +44,7 @@\n         module.exports = definition();\n \n     // RequireJS\n-    } else if (typeof define === \"function\") {\n+    } else if (typeof define === \"function\" && typeof define.amd === 'object' && define.amd) {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "c931317779a05d14c9b895c743d63be83a7b83e0",
        "original_commit_id": "ba94a57297544ac8f4e048bdc29228c4db35aa7f",
        "user": {
            "login": "jrburke",
            "id": 73359,
            "node_id": "MDQ6VXNlcjczMzU5",
            "avatar_url": "https://avatars3.githubusercontent.com/u/73359?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jrburke",
            "html_url": "https://github.com/jrburke",
            "followers_url": "https://api.github.com/users/jrburke/followers",
            "following_url": "https://api.github.com/users/jrburke/following{/other_user}",
            "gists_url": "https://api.github.com/users/jrburke/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jrburke/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jrburke/subscriptions",
            "organizations_url": "https://api.github.com/users/jrburke/orgs",
            "repos_url": "https://api.github.com/users/jrburke/repos",
            "events_url": "https://api.github.com/users/jrburke/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jrburke/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The usual recommended pattern is: `typeof define === \"function\" && define.amd`. These module adapters are used for files that can be used in multiple environments, including a \"browser globals\" case that does not have a module API available, but still may have a global define function. The define.amd check ensures the define is only called in the AMD case.\n\nThat check also helps the optimizer to know what kind of define checks/calls to rewrite. There are libraries that internal define functions that are not AMD define calls, and so not just any define reference can be rewritten for the namespacing feature that @terinjokes is using.\n",
        "created_at": "2013-03-01T08:22:11Z",
        "updated_at": "2013-03-01T20:13:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/225#discussion_r3201513",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/225",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3201513"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/225#discussion_r3201513"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/225"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3290779",
        "pull_request_review_id": null,
        "id": 3290779,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyOTA3Nzk=",
        "diff_hunk": "@@ -1318,6 +1318,8 @@ function timeout(promise, ms) {\n     }, function (exception) {\n         clearTimeout(timeoutId);\n         deferred.reject(exception);\n+    }, function (progress) {",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "6f791c7a7161bc0cefe0d29c0bee51f6406f3506",
        "original_commit_id": "2f6f4de556024e36474e4e42dd1d8be0dfdc9051",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This could be merely:\n\n``` javascript\n}, deferred.notify);\n```\n",
        "created_at": "2013-03-07T23:28:44Z",
        "updated_at": "2013-03-07T23:32:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/229#discussion_r3290779",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/229",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3290779"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/229#discussion_r3290779"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/229"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687505",
        "pull_request_review_id": null,
        "id": 3687505,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1MDU=",
        "diff_hunk": "@@ -412,36 +412,56 @@ function defer() {\n         promise.stack = promise.stack.substring(promise.stack.indexOf(\"\\n\") + 1);\n     }\n \n-    function become(resolvedValue) {\n-        if (!pending) {\n-            return;\n-        }\n-        value = resolve(resolvedValue);\n+    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n+    // consolidating them into `become`, since otherwise we'd create new\n+    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n+\n+    function become(promise) {\n+        resolvedPromise = promise;\n+\n         array_reduce(pending, function (undefined, pending) {\n             nextTick(function () {\n-                value.promiseDispatch.apply(value, pending);\n+                promise.promiseDispatch.apply(promise, pending);\n             });\n         }, void 0);\n+\n         pending = void 0;\n         progressListeners = void 0;\n     }\n \n     deferred.promise = promise;\n-    deferred.resolve = become;\n+    deferred.resolve = function (value) {\n+        if (resolvedPromise) {\n+            return;\n+        }\n+\n+        become(resolve(value));\n+    };\n+\n     deferred.fulfill = function (value) {\n+        if (resolvedPromise) {",
        "path": "q.js",
        "position": null,
        "original_position": 68,
        "commit_id": "7c9be4166be1e1ab96327329ec6c6a282cf55edc",
        "original_commit_id": "0cba230eafa90dcc74f4af135387219e845c5f38",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Perhaps these lines should be in `become` so that it only appears once.\n",
        "created_at": "2013-04-07T22:21:47Z",
        "updated_at": "2013-04-07T22:40:58Z",
        "html_url": "https://github.com/kriskowal/q/pull/258#discussion_r3687505",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/258",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687505"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/258#discussion_r3687505"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/258"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687513",
        "pull_request_review_id": null,
        "id": 3687513,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1MTM=",
        "diff_hunk": "@@ -412,36 +412,56 @@ function defer() {\n         promise.stack = promise.stack.substring(promise.stack.indexOf(\"\\n\") + 1);\n     }\n \n-    function become(resolvedValue) {\n-        if (!pending) {\n-            return;\n-        }\n-        value = resolve(resolvedValue);\n+    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n+    // consolidating them into `become`, since otherwise we'd create new\n+    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n+\n+    function become(promise) {\n+        resolvedPromise = promise;\n+\n         array_reduce(pending, function (undefined, pending) {\n             nextTick(function () {\n-                value.promiseDispatch.apply(value, pending);\n+                promise.promiseDispatch.apply(promise, pending);\n             });\n         }, void 0);\n+\n         pending = void 0;\n         progressListeners = void 0;\n     }\n \n     deferred.promise = promise;\n-    deferred.resolve = become;\n+    deferred.resolve = function (value) {\n+        if (resolvedPromise) {\n+            return;\n+        }\n+\n+        become(resolve(value));\n+    };\n+\n     deferred.fulfill = function (value) {\n+        if (resolvedPromise) {",
        "path": "q.js",
        "position": null,
        "original_position": 68,
        "commit_id": "7c9be4166be1e1ab96327329ec6c6a282cf55edc",
        "original_commit_id": "0cba230eafa90dcc74f4af135387219e845c5f38",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "But see https://github.com/kriskowal/q/pull/258/files#L0R415 !!\n",
        "created_at": "2013-04-07T22:23:19Z",
        "updated_at": "2013-04-07T22:40:58Z",
        "html_url": "https://github.com/kriskowal/q/pull/258#discussion_r3687513",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/258",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687513"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/258#discussion_r3687513"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/258"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687514",
        "pull_request_review_id": null,
        "id": 3687514,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1MTQ=",
        "diff_hunk": "@@ -412,36 +412,56 @@ function defer() {\n         promise.stack = promise.stack.substring(promise.stack.indexOf(\"\\n\") + 1);\n     }\n \n-    function become(resolvedValue) {\n-        if (!pending) {\n-            return;\n-        }\n-        value = resolve(resolvedValue);\n+    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n+    // consolidating them into `become`, since otherwise we'd create new\n+    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n+\n+    function become(promise) {\n+        resolvedPromise = promise;\n+\n         array_reduce(pending, function (undefined, pending) {\n             nextTick(function () {\n-                value.promiseDispatch.apply(value, pending);\n+                promise.promiseDispatch.apply(promise, pending);\n             });\n         }, void 0);\n+\n         pending = void 0;\n         progressListeners = void 0;\n     }\n \n     deferred.promise = promise;\n-    deferred.resolve = become;\n+    deferred.resolve = function (value) {\n+        if (resolvedPromise) {\n+            return;\n+        }\n+\n+        become(resolve(value));\n+    };\n+\n     deferred.fulfill = function (value) {\n+        if (resolvedPromise) {",
        "path": "q.js",
        "position": null,
        "original_position": 68,
        "commit_id": "7c9be4166be1e1ab96327329ec6c6a282cf55edc",
        "original_commit_id": "0cba230eafa90dcc74f4af135387219e845c5f38",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "OH. I see.\n",
        "created_at": "2013-04-07T22:24:37Z",
        "updated_at": "2013-04-07T22:40:58Z",
        "html_url": "https://github.com/kriskowal/q/pull/258#discussion_r3687514",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/258",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687514"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/258#discussion_r3687514"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/258"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687904",
        "pull_request_review_id": null,
        "id": 3687904,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MDQ=",
        "diff_hunk": "@@ -506,16 +506,50 @@ defer.prototype.makeNodeResolver = function () {\n Q.promise = promise;\n function promise(makePromise) {\n     var deferred = defer();\n-    fcall(\n-        makePromise,\n-        deferred.resolve,\n-        deferred.reject,\n-        deferred.notify\n-    ).fail(deferred.reject);\n+    try {\n+        makePromise(deferred.resolve, deferred.reject, deferred.notify);\n+    } catch (reason) {\n+        deferred.reject(reason);\n+    }\n     return deferred.promise;\n }\n \n /**\n+ * Will be relevant for remote\n+ */\n+Q.passByCopy = passByCopy;\n+//var passByCopies = WeakMap();\n+function passByCopy(obj) {\n+    //freeze(obj);\n+    //passByCopies.set(obj, true);\n+    return obj;\n+}\n+\n+/**\n+ * Consider making this variadic\n+ */\n+Q.join = join;\n+function join(x, y) {\n+    return Q.all([x, y]).spread(function(x, y) {\n+        if (x === y) {\n+\t    // TODO: \"===\" should be Object.is or equiv\n+\t    return x;\n+\t}",
        "path": "q.js",
        "position": null,
        "original_position": 38,
        "commit_id": "921df684be268fbf258e9294bc2efa681935fa37",
        "original_commit_id": "fac6d749674b778741819c37c0e8c284d325b024",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Indentation issue here.\n",
        "created_at": "2013-04-08T01:15:42Z",
        "updated_at": "2013-04-09T02:37:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/266#discussion_r3687904",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/266",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687904"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/266#discussion_r3687904"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/266"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687906",
        "pull_request_review_id": null,
        "id": 3687906,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MDY=",
        "diff_hunk": "@@ -506,16 +506,50 @@ defer.prototype.makeNodeResolver = function () {\n Q.promise = promise;\n function promise(makePromise) {\n     var deferred = defer();\n-    fcall(\n-        makePromise,\n-        deferred.resolve,\n-        deferred.reject,\n-        deferred.notify\n-    ).fail(deferred.reject);\n+    try {\n+        makePromise(deferred.resolve, deferred.reject, deferred.notify);\n+    } catch (reason) {\n+        deferred.reject(reason);\n+    }\n     return deferred.promise;\n }\n \n /**\n+ * Will be relevant for remote",
        "path": "q.js",
        "position": 19,
        "original_position": 19,
        "commit_id": "921df684be268fbf258e9294bc2efa681935fa37",
        "original_commit_id": "fac6d749674b778741819c37c0e8c284d325b024",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Will need to make this something similar to Q.master, but with the opposite meaning.\n",
        "created_at": "2013-04-08T01:16:09Z",
        "updated_at": "2013-04-09T02:37:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/266#discussion_r3687906",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/266",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687906"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/266#discussion_r3687906"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/266"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687907",
        "pull_request_review_id": null,
        "id": 3687907,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MDc=",
        "diff_hunk": "@@ -506,16 +506,50 @@ defer.prototype.makeNodeResolver = function () {\n Q.promise = promise;\n function promise(makePromise) {\n     var deferred = defer();\n-    fcall(\n-        makePromise,\n-        deferred.resolve,\n-        deferred.reject,\n-        deferred.notify\n-    ).fail(deferred.reject);\n+    try {\n+        makePromise(deferred.resolve, deferred.reject, deferred.notify);\n+    } catch (reason) {\n+        deferred.reject(reason);\n+    }\n     return deferred.promise;\n }\n \n /**\n+ * Will be relevant for remote\n+ */\n+Q.passByCopy = passByCopy;\n+//var passByCopies = WeakMap();\n+function passByCopy(obj) {\n+    //freeze(obj);\n+    //passByCopies.set(obj, true);\n+    return obj;\n+}\n+\n+/**\n+ * Consider making this variadic\n+ */\n+Q.join = join;\n+function join(x, y) {\n+    return Q.all([x, y]).spread(function(x, y) {\n+        if (x === y) {\n+\t    // TODO: \"===\" should be Object.is or equiv\n+\t    return x;\n+\t}",
        "path": "q.js",
        "position": null,
        "original_position": 38,
        "commit_id": "921df684be268fbf258e9294bc2efa681935fa37",
        "original_commit_id": "fac6d749674b778741819c37c0e8c284d325b024",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Be sure to check for tabs; there were some of those in a81dbd46624cdfb00b41438774ff2bd6ddc2c7b8 :)\n",
        "created_at": "2013-04-08T01:16:45Z",
        "updated_at": "2013-04-09T02:37:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/266#discussion_r3687907",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/266",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/3687907"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/266#discussion_r3687907"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/266"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4155644",
        "pull_request_review_id": null,
        "id": 4155644,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDQ=",
        "diff_hunk": "@@ -785,6 +791,11 @@ function reject(reason) {\n             return rejected ? rejected(reason) : this;\n         }\n     }, function fallback() {",
        "path": "q.js",
        "position": 16,
        "original_position": 16,
        "commit_id": "fc65e938570e2751f3d292482f199d58e6ef978a",
        "original_commit_id": "4fe3a0253d3d605b9283b7c6b027dd490fc8148b",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah, so it was the fallback that was causing the duplication.\n\nThis might be just as well solved by merely returning `this` in the fallback. Will have to verify.\n",
        "created_at": "2013-05-09T16:30:20Z",
        "updated_at": "2013-05-09T16:36:06Z",
        "html_url": "https://github.com/kriskowal/q/pull/290#discussion_r4155644",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/290",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4155644"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/290#discussion_r4155644"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/290"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4155745",
        "pull_request_review_id": null,
        "id": 4155745,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3NDU=",
        "diff_hunk": "@@ -785,6 +791,11 @@ function reject(reason) {\n             return rejected ? rejected(reason) : this;\n         }\n     }, function fallback() {",
        "path": "q.js",
        "position": 16,
        "original_position": 16,
        "commit_id": "fc65e938570e2751f3d292482f199d58e6ef978a",
        "original_commit_id": "4fe3a0253d3d605b9283b7c6b027dd490fc8148b",
        "user": {
            "login": "SLaks",
            "id": 313894,
            "node_id": "MDQ6VXNlcjMxMzg5NA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/313894?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/SLaks",
            "html_url": "https://github.com/SLaks",
            "followers_url": "https://api.github.com/users/SLaks/followers",
            "following_url": "https://api.github.com/users/SLaks/following{/other_user}",
            "gists_url": "https://api.github.com/users/SLaks/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/SLaks/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/SLaks/subscriptions",
            "organizations_url": "https://api.github.com/users/SLaks/orgs",
            "repos_url": "https://api.github.com/users/SLaks/repos",
            "events_url": "https://api.github.com/users/SLaks/events{/privacy}",
            "received_events_url": "https://api.github.com/users/SLaks/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Changing to `return this` doesn't break any tests; I'll commit that.\n",
        "created_at": "2013-05-09T16:34:42Z",
        "updated_at": "2013-05-09T16:36:06Z",
        "html_url": "https://github.com/kriskowal/q/pull/290#discussion_r4155745",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/290",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4155745"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/290#discussion_r4155745"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/290"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4145050",
        "pull_request_review_id": null,
        "id": 4145050,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNTA=",
        "diff_hunk": "@@ -380,6 +380,17 @@ function captureLine() {\n     }\n }\n \n+function deprecate(callback, name, alternative) {\n+    return function () {\n+        if (typeof console !== \"undefined\" &&\n+            typeof console.warn === \"function\") {\n+            console.warn(name + \" is deprecated, use \" + alternative +\n+                         \" instead.\", new Error(\"\").stack);\n+        }\n+        return callback.apply(callback, arguments);\n+    };\n+}\n+",
        "path": "q.js",
        "position": 14,
        "original_position": 14,
        "commit_id": "1eefd58c44c82ed7893e9ff29bfa7f623b1fae71",
        "original_commit_id": "5dcd5a459564fbaddc1c12fb8a69cef3185442cd",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Welcome back, `deprecate` :-P\n",
        "created_at": "2013-05-08T22:21:41Z",
        "updated_at": "2013-05-18T17:47:26Z",
        "html_url": "https://github.com/kriskowal/q/pull/286#discussion_r4145050",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/286",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4145050"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/286#discussion_r4145050"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/286"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4490701",
        "pull_request_review_id": null,
        "id": 4490701,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MDE=",
        "diff_hunk": "@@ -0,0 +1,27 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {",
        "path": "examples/async-generators/3-spawn.js",
        "position": 3,
        "original_position": 3,
        "commit_id": "6a34b92771d9642203b6e0593802314b81dc0bf9",
        "original_commit_id": "6a34b92771d9642203b6e0593802314b81dc0bf9",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You can just use `Q.delay`, no?\n",
        "created_at": "2013-06-02T01:38:39Z",
        "updated_at": "2013-06-02T01:38:39Z",
        "html_url": "https://github.com/kriskowal/q/pull/306#discussion_r4490701",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/306",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4490701"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/306#discussion_r4490701"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/306"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4491002",
        "pull_request_review_id": null,
        "id": 4491002,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwMDI=",
        "diff_hunk": "@@ -1126,6 +1126,18 @@ function async(makeGenerator) {\n     };\n }\n \n+/**\n+ * The spawn function is a small wrapper around async that immediately\n+ * calls the generator and also ends the promise chain, so that any\n+ * unhandled errors are thrown instead of forwarded to the error\n+ * handler. This is useful because it's extremely common to run\n+ * generators at the top-level to work with libraries.\n+ */\n+Q.spawn = spawn;\n+function spawn(makeGenerator) {\n+    Q.done(Q.async(makeGenerator)());",
        "path": "q.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "6a34b92771d9642203b6e0593802314b81dc0bf9",
        "original_commit_id": "6a34b92771d9642203b6e0593802314b81dc0bf9",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Internally, you can just say `done` and `async` instead of `Q.done` and `Q.async`.\n",
        "created_at": "2013-06-02T06:57:58Z",
        "updated_at": "2013-06-02T06:57:58Z",
        "html_url": "https://github.com/kriskowal/q/pull/306#discussion_r4491002",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/306",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4491002"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/306#discussion_r4491002"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/306"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4515502",
        "pull_request_review_id": null,
        "id": 4515502,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1MDI=",
        "diff_hunk": "@@ -1125,6 +1126,17 @@ function fcall(value) {\n }\n \n /**\n+ * Calls the promised method in a future turn.\n+ * @param object    promise or immediate reference for target method\n+ * @param ...args   array of application arguments\n+ */\n+Q.mcall = mcall;",
        "path": "q.js",
        "position": 16,
        "original_position": 16,
        "commit_id": "91d258f1de71c4eecd55aa7d0dc1bf70e20ded9a",
        "original_commit_id": "91d258f1de71c4eecd55aa7d0dc1bf70e20ded9a",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`Q.mcall` would just be `Q.invoke`.\n",
        "created_at": "2013-06-04T04:15:33Z",
        "updated_at": "2013-06-04T04:15:33Z",
        "html_url": "https://github.com/kriskowal/q/pull/235#discussion_r4515502",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/235",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4515502"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/235#discussion_r4515502"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/235"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4638683",
        "pull_request_review_id": null,
        "id": 4638683,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2ODM=",
        "diff_hunk": "@@ -1713,6 +1713,27 @@ function nodeify(promise, nodeback) {\n     }\n }\n \n+/**\n+ * Wraps a DOMRequest-producing function and returns an equivalent version that\n+ * returns a promise.\n+ */\n+Q.dedomrequest = dedomrequest;\n+function dedomrequest(fn) {\n+    var baseArgs = array_slice(arguments, 1);\n+    return function() {\n+        var requestArgs = baseArgs.concat(array_slice(arguments));\n+        var deferred = defer();\n+        var request = fn.apply(null, requestArgs);\n+        request.onsuccess = function() {\n+            deferred.resolve(request.result);\n+        };\n+        request.onerror = function() {\n+            deferred.resolve(request.error);",
        "path": "q.js",
        "position": null,
        "original_position": 19,
        "commit_id": "4ce65ee9752b4bd69ab1c64d071496eae435c2b4",
        "original_commit_id": "1667626e348a33b62cdd2d89bd4fdf4e9f99deb9",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "deferred.reject\n",
        "created_at": "2013-06-11T17:18:11Z",
        "updated_at": "2013-06-11T17:32:55Z",
        "html_url": "https://github.com/kriskowal/q/pull/315#discussion_r4638683",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/315",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4638683"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/315#discussion_r4638683"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/315"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4950599",
        "pull_request_review_id": null,
        "id": 4950599,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA1OTk=",
        "diff_hunk": "@@ -1589,12 +1589,12 @@ function timeout(promise, ms, msg) {\n }\n \n /**\n- * Returns a promise for the given value (or promised value) after some\n- * milliseconds.\n+ * Returns a promise for the given value (or promised value), some\n+ * milliseconds after it resolved.",
        "path": "q.js",
        "position": 7,
        "original_position": 7,
        "commit_id": "46a4dad8f96a818ea0214b3545da34004dd1eaa8",
        "original_commit_id": "46a4dad8f96a818ea0214b3545da34004dd1eaa8",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "s/resolved/fulfilled, similarly in other comments, right?\n",
        "created_at": "2013-06-29T00:02:08Z",
        "updated_at": "2013-06-29T00:02:08Z",
        "html_url": "https://github.com/kriskowal/q/pull/330#discussion_r4950599",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/330",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4950599"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/330#discussion_r4950599"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/330"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4950786",
        "pull_request_review_id": null,
        "id": 4950786,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3ODY=",
        "diff_hunk": "@@ -1589,12 +1589,12 @@ function timeout(promise, ms, msg) {\n }\n \n /**\n- * Returns a promise for the given value (or promised value) after some\n- * milliseconds.\n+ * Returns a promise for the given value (or promised value), some\n+ * milliseconds after it resolved.",
        "path": "q.js",
        "position": 7,
        "original_position": 7,
        "commit_id": "46a4dad8f96a818ea0214b3545da34004dd1eaa8",
        "original_commit_id": "46a4dad8f96a818ea0214b3545da34004dd1eaa8",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah.\n",
        "created_at": "2013-06-29T00:28:18Z",
        "updated_at": "2013-06-29T00:28:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/330#discussion_r4950786",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/330",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4950786"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/330#discussion_r4950786"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/330"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4955789",
        "pull_request_review_id": null,
        "id": 4955789,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3ODk=",
        "diff_hunk": "@@ -847,6 +847,7 @@ function when(value, fulfilled, rejected, progressed) {\n     }\n \n     function _rejected(exception) {\n+        console.log('rejected ' + exception.message)",
        "path": "q.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "6e42ce9451b676ac21276ba3d429394c9b36cf9d",
        "original_commit_id": "6e42ce9451b676ac21276ba3d429394c9b36cf9d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I am removing this line.\n",
        "created_at": "2013-07-01T02:50:04Z",
        "updated_at": "2013-07-01T02:50:04Z",
        "html_url": "https://github.com/kriskowal/q/pull/234#discussion_r4955789",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/234",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4955789"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/234#discussion_r4955789"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/234"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4955792",
        "pull_request_review_id": null,
        "id": 4955792,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3OTI=",
        "diff_hunk": "@@ -923,6 +924,13 @@ function spread(promise, fulfilled, rejected) {\n     }, rejected);\n }\n \n+Q.map = map;\n+function map(promise, callback, fulfilled, rejected) {\n+    return when(promise, function (valuesOrPromises) {\n+    \treturn all(valuesOrPromises.map(callback));",
        "path": "q.js",
        "position": 15,
        "original_position": 15,
        "commit_id": "6e42ce9451b676ac21276ba3d429394c9b36cf9d",
        "original_commit_id": "6e42ce9451b676ac21276ba3d429394c9b36cf9d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I am expanding this to use our `array_reduce` shim so that it will work in older IE\u2019s.\n",
        "created_at": "2013-07-01T02:50:37Z",
        "updated_at": "2013-07-01T02:50:37Z",
        "html_url": "https://github.com/kriskowal/q/pull/234#discussion_r4955792",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/234",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4955792"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/234#discussion_r4955792"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/234"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4955877",
        "pull_request_review_id": null,
        "id": 4955877,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU4Nzc=",
        "diff_hunk": "@@ -1029,6 +1029,17 @@ describe(\"all\", function () {\n         return Q.all([]);\n     });\n \n+    it(\"fails if any of the promises fail\", function() {",
        "path": "spec/q-spec.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "6e42ce9451b676ac21276ba3d429394c9b36cf9d",
        "original_commit_id": "6e42ce9451b676ac21276ba3d429394c9b36cf9d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This spec is invalid and fails. Q.all is not obliged to call the contained functions. However, you could Q.map(functions, Q.fcall).\n",
        "created_at": "2013-07-01T03:08:26Z",
        "updated_at": "2013-07-01T03:08:26Z",
        "html_url": "https://github.com/kriskowal/q/pull/234#discussion_r4955877",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/234",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4955877"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/234#discussion_r4955877"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/234"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4957391",
        "pull_request_review_id": null,
        "id": 4957391,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczOTE=",
        "diff_hunk": "@@ -1162,41 +1162,61 @@ function spread(promise, fulfilled, rejected) {\n  */\n Q.async = async;\n function async(makeGenerator) {\n-    return function () {\n-        // when verb is \"send\", arg is a value\n-        // when verb is \"throw\", arg is an exception\n-        function continuer(verb, arg) {\n-            var result;\n-            if (hasES6Generators) {\n-                try {\n-                    result = generator[verb](arg);\n-                } catch (exception) {\n-                    return reject(exception);\n-                }\n-                if (result.done) {\n-                    return result.value;\n-                } else {\n-                    return when(result.value, callback, errback);\n-                }\n+    return function() {\n+        return makeContinuer(makeGenerator.apply(this, arguments));\n+    };\n+}\n+\n+function makeContinuer(generator) {\n+    // when verb is \"send\", arg is a value\n+    // when verb is \"throw\", arg is an exception\n+    function continuer(verb, arg) {\n+        var result;\n+        if (hasES6Generators) {\n+            try {\n+                result = generator[verb](arg);\n+            } catch (exception) {\n+                return reject(exception);\n+            }\n+            if (result.done) {\n+                return result.value;\n             } else {\n-                // FIXME: Remove this case when SM does ES6 generators.\n-                try {\n-                    result = generator[verb](arg);\n-                } catch (exception) {\n-                    if (isStopIteration(exception)) {\n-                        return exception.value;\n-                    } else {\n-                        return reject(exception);\n-                    }\n+                var val = asyncValue(result.value);                \n+                return when(val, callback, errback);\n+            }\n+        } else {\n+            // FIXME: Remove this case when SM does ES6 generators.\n+            try {\n+                result = generator[verb](arg);\n+            } catch (exception) {\n+                if (isStopIteration(exception)) {\n+                    return exception.value;\n+                } else {\n+                    return reject(exception);\n                 }\n-                return when(result, callback, errback);\n             }\n+            return when(result, callback, errback);\n         }\n-        var generator = makeGenerator.apply(this, arguments);\n-        var callback = continuer.bind(continuer, \"send\");\n-        var errback = continuer.bind(continuer, \"throw\");\n-        return callback();\n-    };\n+    }\n+\n+    var callback = continuer.bind(continuer, \"send\");\n+    var errback = continuer.bind(continuer, \"throw\");\n+    return callback();\n+};\n+\n+var dummyGenProto = (function*() {})().constructor;",
        "path": "q.js",
        "position": 77,
        "original_position": 77,
        "commit_id": "17538e7402d57450af54dac7319ae7795ba27b9a",
        "original_commit_id": "17538e7402d57450af54dac7319ae7795ba27b9a",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We can\u2019t take this line because it is a syntax error in previous versions.\n",
        "created_at": "2013-07-01T07:50:34Z",
        "updated_at": "2013-07-01T07:50:34Z",
        "html_url": "https://github.com/kriskowal/q/pull/327#discussion_r4957391",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/327",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4957391"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/327#discussion_r4957391"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/327"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4963375",
        "pull_request_review_id": null,
        "id": 4963375,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMzNzU=",
        "diff_hunk": "@@ -1162,41 +1162,61 @@ function spread(promise, fulfilled, rejected) {\n  */\n Q.async = async;\n function async(makeGenerator) {\n-    return function () {\n-        // when verb is \"send\", arg is a value\n-        // when verb is \"throw\", arg is an exception\n-        function continuer(verb, arg) {\n-            var result;\n-            if (hasES6Generators) {\n-                try {\n-                    result = generator[verb](arg);\n-                } catch (exception) {\n-                    return reject(exception);\n-                }\n-                if (result.done) {\n-                    return result.value;\n-                } else {\n-                    return when(result.value, callback, errback);\n-                }\n+    return function() {\n+        return makeContinuer(makeGenerator.apply(this, arguments));\n+    };\n+}\n+\n+function makeContinuer(generator) {\n+    // when verb is \"send\", arg is a value\n+    // when verb is \"throw\", arg is an exception\n+    function continuer(verb, arg) {\n+        var result;\n+        if (hasES6Generators) {\n+            try {\n+                result = generator[verb](arg);\n+            } catch (exception) {\n+                return reject(exception);\n+            }\n+            if (result.done) {\n+                return result.value;\n             } else {\n-                // FIXME: Remove this case when SM does ES6 generators.\n-                try {\n-                    result = generator[verb](arg);\n-                } catch (exception) {\n-                    if (isStopIteration(exception)) {\n-                        return exception.value;\n-                    } else {\n-                        return reject(exception);\n-                    }\n+                var val = asyncValue(result.value);                \n+                return when(val, callback, errback);\n+            }\n+        } else {\n+            // FIXME: Remove this case when SM does ES6 generators.\n+            try {\n+                result = generator[verb](arg);\n+            } catch (exception) {\n+                if (isStopIteration(exception)) {\n+                    return exception.value;\n+                } else {\n+                    return reject(exception);\n                 }\n-                return when(result, callback, errback);\n             }\n+            return when(result, callback, errback);\n         }\n-        var generator = makeGenerator.apply(this, arguments);\n-        var callback = continuer.bind(continuer, \"send\");\n-        var errback = continuer.bind(continuer, \"throw\");\n-        return callback();\n-    };\n+    }\n+\n+    var callback = continuer.bind(continuer, \"send\");\n+    var errback = continuer.bind(continuer, \"throw\");\n+    return callback();\n+};\n+\n+var dummyGenProto = (function*() {})().constructor;",
        "path": "q.js",
        "position": 77,
        "original_position": 77,
        "commit_id": "17538e7402d57450af54dac7319ae7795ba27b9a",
        "original_commit_id": "17538e7402d57450af54dac7319ae7795ba27b9a",
        "user": {
            "login": "jlongster",
            "id": 17031,
            "node_id": "MDQ6VXNlcjE3MDMx",
            "avatar_url": "https://avatars2.githubusercontent.com/u/17031?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jlongster",
            "html_url": "https://github.com/jlongster",
            "followers_url": "https://api.github.com/users/jlongster/followers",
            "following_url": "https://api.github.com/users/jlongster/following{/other_user}",
            "gists_url": "https://api.github.com/users/jlongster/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jlongster/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jlongster/subscriptions",
            "organizations_url": "https://api.github.com/users/jlongster/orgs",
            "repos_url": "https://api.github.com/users/jlongster/repos",
            "events_url": "https://api.github.com/users/jlongster/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jlongster/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Absolutely right. I wrote this too fast.\n",
        "created_at": "2013-07-01T14:51:55Z",
        "updated_at": "2013-07-01T14:51:55Z",
        "html_url": "https://github.com/kriskowal/q/pull/327#discussion_r4963375",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/327",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4963375"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/327#discussion_r4963375"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/327"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4970302",
        "pull_request_review_id": null,
        "id": 4970302,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMDI=",
        "diff_hunk": "@@ -245,6 +245,14 @@ var array_reduce = uncurryThis(\n     }\n );\n \n+var array_isArray = Array.isArray || function (object) {\n+    return object_toString(object) === \"[object Array]\";\n+};\n+\n+var array_isArguments = function (object) {\n+    return object_toString(object) === \"[object Arguments]\";",
        "path": "q.js",
        "position": null,
        "original_position": 9,
        "commit_id": "089e457c2e82c3f7d12871ae0840c742d87a9344",
        "original_commit_id": "41388348c90e495a77c7daed172383e7f96ab183",
        "user": {
            "login": "rkatic",
            "id": 38577,
            "node_id": "MDQ6VXNlcjM4NTc3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/38577?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rkatic",
            "html_url": "https://github.com/rkatic",
            "followers_url": "https://api.github.com/users/rkatic/followers",
            "following_url": "https://api.github.com/users/rkatic/following{/other_user}",
            "gists_url": "https://api.github.com/users/rkatic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rkatic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rkatic/subscriptions",
            "organizations_url": "https://api.github.com/users/rkatic/orgs",
            "repos_url": "https://api.github.com/users/rkatic/repos",
            "events_url": "https://api.github.com/users/rkatic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rkatic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I have done some effort to implement a cross-browser `isArguments` in past (for jQuery), but it seems it is not possible. This solution will fail on older IE at least.\n\nInstead of checking if an object is an array or arguments, it should be much more robust to check for `iterator` and `next` methods and to fallback to `array_iterate`.\n",
        "created_at": "2013-07-01T19:46:09Z",
        "updated_at": "2013-07-02T00:20:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/334#discussion_r4970302",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/334",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4970302"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/334#discussion_r4970302"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/334"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4970456",
        "pull_request_review_id": null,
        "id": 4970456,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0NTY=",
        "diff_hunk": "@@ -245,6 +245,14 @@ var array_reduce = uncurryThis(\n     }\n );\n \n+var array_isArray = Array.isArray || function (object) {\n+    return object_toString(object) === \"[object Array]\";\n+};\n+\n+var array_isArguments = function (object) {\n+    return object_toString(object) === \"[object Arguments]\";",
        "path": "q.js",
        "position": null,
        "original_position": 9,
        "commit_id": "089e457c2e82c3f7d12871ae0840c742d87a9344",
        "original_commit_id": "41388348c90e495a77c7daed172383e7f96ab183",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Good observation.\n",
        "created_at": "2013-07-01T19:53:41Z",
        "updated_at": "2013-07-02T00:20:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/334#discussion_r4970456",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/334",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4970456"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/334#discussion_r4970456"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/334"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034317",
        "pull_request_review_id": null,
        "id": 5034317,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzMTc=",
        "diff_hunk": "@@ -1456,22 +1456,23 @@ function allResolved(promises) {\n     });\n }\n \n+/**\n+ * Turns an array of promises into a promise for an array of their states (as\n+ * returned by `inspect`) when they have all settled.\n+ * @param {Array[Any*]} values an array (or promise for an array) of values (or\n+ * promises for values)\n+ * @returns {Array[State]} an array of states for the respective values.\n+ */\n Q.allSettled = allSettled;\n function allSettled(values) {\n     return when(values, function (values) {\n-        return all(array_map(values, function (value, i) {\n-            return when(\n-                value,\n-                function (fulfillmentValue) {\n-                    values[i] = { state: \"fulfilled\", value: fulfillmentValue };\n-                    return values[i];\n-                },\n-                function (reason) {\n-                    values[i] = { state: \"rejected\", reason: reason };\n-                    return values[i];\n-                }\n-            );\n-        })).thenResolve(values);\n+        return all(array_map(values, function (value) {\n+            var promise = resolve(value);\n+            function regardless() {",
        "path": "q.js",
        "position": 29,
        "original_position": 29,
        "commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "original_commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Heh, I like the name.\n",
        "created_at": "2013-07-04T17:16:32Z",
        "updated_at": "2013-07-04T17:16:32Z",
        "html_url": "https://github.com/kriskowal/q/pull/338#discussion_r5034317",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/338",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034317"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/338#discussion_r5034317"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/338"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034334",
        "pull_request_review_id": null,
        "id": 5034334,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzMzQ=",
        "diff_hunk": "@@ -1456,22 +1456,23 @@ function allResolved(promises) {\n     });\n }\n \n+/**\n+ * Turns an array of promises into a promise for an array of their states (as\n+ * returned by `inspect`) when they have all settled.\n+ * @param {Array[Any*]} values an array (or promise for an array) of values (or\n+ * promises for values)\n+ * @returns {Array[State]} an array of states for the respective values.\n+ */\n Q.allSettled = allSettled;\n function allSettled(values) {\n     return when(values, function (values) {\n-        return all(array_map(values, function (value, i) {\n-            return when(\n-                value,\n-                function (fulfillmentValue) {\n-                    values[i] = { state: \"fulfilled\", value: fulfillmentValue };\n-                    return values[i];\n-                },\n-                function (reason) {\n-                    values[i] = { state: \"rejected\", reason: reason };\n-                    return values[i];\n-                }\n-            );\n-        })).thenResolve(values);\n+        return all(array_map(values, function (value) {\n+            var promise = resolve(value);",
        "path": "q.js",
        "position": 28,
        "original_position": 28,
        "commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "original_commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think you switched to using `Q` these days?\n",
        "created_at": "2013-07-04T17:17:52Z",
        "updated_at": "2013-07-04T17:17:52Z",
        "html_url": "https://github.com/kriskowal/q/pull/338#discussion_r5034334",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/338",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034334"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/338#discussion_r5034334"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/338"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034337",
        "pull_request_review_id": null,
        "id": 5034337,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzMzc=",
        "diff_hunk": "@@ -1179,20 +1179,6 @@ describe(\"allSettled\", function () {\n         });\n     });\n \n-    it(\"modifies the input array\", function () {",
        "path": "spec/q-spec.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "original_commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Probably should add a test that it does _not_ modify the input array.\n",
        "created_at": "2013-07-04T17:18:05Z",
        "updated_at": "2013-07-04T17:18:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/338#discussion_r5034337",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/338",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034337"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/338#discussion_r5034337"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/338"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034364",
        "pull_request_review_id": null,
        "id": 5034364,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzNjQ=",
        "diff_hunk": "@@ -1456,22 +1456,23 @@ function allResolved(promises) {\n     });\n }\n \n+/**\n+ * Turns an array of promises into a promise for an array of their states (as\n+ * returned by `inspect`) when they have all settled.\n+ * @param {Array[Any*]} values an array (or promise for an array) of values (or\n+ * promises for values)\n+ * @returns {Array[State]} an array of states for the respective values.\n+ */\n Q.allSettled = allSettled;\n function allSettled(values) {\n     return when(values, function (values) {\n-        return all(array_map(values, function (value, i) {\n-            return when(\n-                value,\n-                function (fulfillmentValue) {\n-                    values[i] = { state: \"fulfilled\", value: fulfillmentValue };\n-                    return values[i];\n-                },\n-                function (reason) {\n-                    values[i] = { state: \"rejected\", reason: reason };\n-                    return values[i];\n-                }\n-            );\n-        })).thenResolve(values);\n+        return all(array_map(values, function (value) {\n+            var promise = resolve(value);",
        "path": "q.js",
        "position": 28,
        "original_position": 28,
        "commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "original_commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "There\u2019s some shearing between the branches. I have already rebased this on the other, pending.\n",
        "created_at": "2013-07-04T17:19:53Z",
        "updated_at": "2013-07-04T17:19:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/338#discussion_r5034364",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/338",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034364"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/338#discussion_r5034364"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/338"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034367",
        "pull_request_review_id": null,
        "id": 5034367,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzNjc=",
        "diff_hunk": "@@ -1179,20 +1179,6 @@ describe(\"allSettled\", function () {\n         });\n     });\n \n-    it(\"modifies the input array\", function () {",
        "path": "spec/q-spec.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "original_commit_id": "9e0f9631b709be11bbed6f66c2426d143fc0ee50",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes.\n",
        "created_at": "2013-07-04T17:20:06Z",
        "updated_at": "2013-07-04T17:20:06Z",
        "html_url": "https://github.com/kriskowal/q/pull/338#discussion_r5034367",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/338",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5034367"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/338#discussion_r5034367"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/338"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5010016",
        "pull_request_review_id": null,
        "id": 5010016,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMTY=",
        "diff_hunk": "@@ -621,18 +634,56 @@ function promise(resolver) {\n     if (typeof resolver !== \"function\") {\n         throw new TypeError(\"resolver must be a function.\");\n     }\n-\n     var deferred = defer();\n-    fcall(\n-        resolver,\n-        deferred.resolve,\n-        deferred.reject,\n-        deferred.notify\n-    ).fail(deferred.reject);\n+    try {\n+        resolver(deferred.resolve, deferred.reject, deferred.notify);\n+    } catch (reason) {\n+        deferred.reject(reason);\n+    }\n     return deferred.promise;\n }\n \n /**\n+ * Will be relevant for remote\n+ */\n+Q.passByCopy = passByCopy; // XXX experimental\n+//var passByCopies = WeakMap();\n+function passByCopy(obj) {\n+    //freeze(obj);\n+    //passByCopies.set(obj, true);\n+    return obj;\n+}\n+\n+/**\n+ * Consider making this variadic\n+ */\n+Q.join = join;\n+function join(x, y) {\n+    return Q.all([x, y]).spread(function(x, y) {",
        "path": "q.js",
        "position": null,
        "original_position": 76,
        "commit_id": "f5a310cfc3310242a30507e8944d3277f6dc2520",
        "original_commit_id": "9be40a9fb720fb72381e3b6dc63026a25188f1e5",
        "user": {
            "login": "rkatic",
            "id": 38577,
            "node_id": "MDQ6VXNlcjM4NTc3",
            "avatar_url": "https://avatars1.githubusercontent.com/u/38577?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rkatic",
            "html_url": "https://github.com/rkatic",
            "followers_url": "https://api.github.com/users/rkatic/followers",
            "following_url": "https://api.github.com/users/rkatic/following{/other_user}",
            "gists_url": "https://api.github.com/users/rkatic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rkatic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rkatic/subscriptions",
            "organizations_url": "https://api.github.com/users/rkatic/orgs",
            "repos_url": "https://api.github.com/users/rkatic/repos",
            "events_url": "https://api.github.com/users/rkatic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rkatic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Instead of  `Q.all([...]).spread(...)`, you can `Q([...]).spread(...)`. It's shorter and cheaper, while still clear on intention.\n",
        "created_at": "2013-07-03T14:19:50Z",
        "updated_at": "2013-07-07T04:21:33Z",
        "html_url": "https://github.com/kriskowal/q/pull/339#discussion_r5010016",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/339",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5010016"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/339#discussion_r5010016"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/339"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5012836",
        "pull_request_review_id": null,
        "id": 5012836,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4MzY=",
        "diff_hunk": "@@ -621,18 +634,56 @@ function promise(resolver) {\n     if (typeof resolver !== \"function\") {\n         throw new TypeError(\"resolver must be a function.\");\n     }\n-\n     var deferred = defer();\n-    fcall(\n-        resolver,\n-        deferred.resolve,\n-        deferred.reject,\n-        deferred.notify\n-    ).fail(deferred.reject);\n+    try {\n+        resolver(deferred.resolve, deferred.reject, deferred.notify);\n+    } catch (reason) {\n+        deferred.reject(reason);\n+    }\n     return deferred.promise;\n }\n \n /**\n+ * Will be relevant for remote\n+ */\n+Q.passByCopy = passByCopy; // XXX experimental\n+//var passByCopies = WeakMap();\n+function passByCopy(obj) {\n+    //freeze(obj);\n+    //passByCopies.set(obj, true);\n+    return obj;\n+}\n+\n+/**\n+ * Consider making this variadic\n+ */\n+Q.join = join;\n+function join(x, y) {\n+    return Q.all([x, y]).spread(function(x, y) {",
        "path": "q.js",
        "position": null,
        "original_position": 76,
        "commit_id": "f5a310cfc3310242a30507e8944d3277f6dc2520",
        "original_commit_id": "9be40a9fb720fb72381e3b6dc63026a25188f1e5",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Good catch.\n",
        "created_at": "2013-07-03T16:00:24Z",
        "updated_at": "2013-07-07T04:21:33Z",
        "html_url": "https://github.com/kriskowal/q/pull/339#discussion_r5012836",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/339",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5012836"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/339#discussion_r5012836"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/339"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4998709",
        "pull_request_review_id": null,
        "id": 4998709,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDk=",
        "diff_hunk": "@@ -1398,61 +1349,267 @@ function fbind(value) {\n Q.keys = dispatcher(\"keys\");\n \n /**\n- * Turns an array of promises into a promise for an array.  If any of\n- * the promises gets rejected, the whole array is rejected immediately.\n- * @param {Array*} an array (or promise for an array) of values (or\n- * promises for values)\n- * @returns a promise for an array of the corresponding values\n  */\n-// By Mark Miller\n-// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n-Q.all = all;\n-function all(promises) {\n-    return when(promises, function (promises) {\n-        var countDown = 0;\n-        var deferred = defer();\n-        array_reduce(promises, function (undefined, promise, index) {\n-            var snapshot;\n-            if (\n-                isPromise(promise) &&\n-                (snapshot = promise.inspect()).state === \"fulfilled\"\n-            ) {\n-                promises[index] = snapshot.value;\n+Q.iterate = dispatcher(\"iterate\");\n+\n+/**\n+ * Aggregates all of the input into a single value, asynchronously.  `reduce`\n+ * uses a pool of acreted values, optionall starting with some `basis`.  Each",
        "path": "q.js",
        "position": null,
        "original_position": 208,
        "commit_id": "0e5d134e07a787e486f4d1174c93e5bf23779de6",
        "original_commit_id": "b694a102fe3bbe13f69b97564684187b84a06f1c",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "optionally\n",
        "created_at": "2013-07-02T23:10:05Z",
        "updated_at": "2013-07-07T04:52:24Z",
        "html_url": "https://github.com/kriskowal/q/pull/337#discussion_r4998709",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/337",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4998709"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/337#discussion_r4998709"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/337"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4998715",
        "pull_request_review_id": null,
        "id": 4998715,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MTU=",
        "diff_hunk": "@@ -1398,61 +1349,267 @@ function fbind(value) {\n Q.keys = dispatcher(\"keys\");\n \n /**\n- * Turns an array of promises into a promise for an array.  If any of\n- * the promises gets rejected, the whole array is rejected immediately.\n- * @param {Array*} an array (or promise for an array) of values (or\n- * promises for values)\n- * @returns a promise for an array of the corresponding values\n  */\n-// By Mark Miller\n-// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n-Q.all = all;\n-function all(promises) {\n-    return when(promises, function (promises) {\n-        var countDown = 0;\n-        var deferred = defer();\n-        array_reduce(promises, function (undefined, promise, index) {\n-            var snapshot;\n-            if (\n-                isPromise(promise) &&\n-                (snapshot = promise.inspect()).state === \"fulfilled\"\n-            ) {\n-                promises[index] = snapshot.value;\n+Q.iterate = dispatcher(\"iterate\");\n+\n+/**\n+ * Aggregates all of the input into a single value, asynchronously.  `reduce`\n+ * uses a pool of acreted values, optionall starting with some `basis`.  Each\n+ * time a value becomes available both from the input and the pool of bases,\n+ * the values are taken out and asynchronously combined.  When the combination\n+ * has been fulfilled, the result is placed back in the pool.  When the input\n+ * is exhausted, the result is the last value remainin in in the pool of",
        "path": "q.js",
        "position": null,
        "original_position": 212,
        "commit_id": "0e5d134e07a787e486f4d1174c93e5bf23779de6",
        "original_commit_id": "b694a102fe3bbe13f69b97564684187b84a06f1c",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "remaining\n",
        "created_at": "2013-07-02T23:10:30Z",
        "updated_at": "2013-07-07T04:52:24Z",
        "html_url": "https://github.com/kriskowal/q/pull/337#discussion_r4998715",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/337",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4998715"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/337#discussion_r4998715"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/337"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/4998732",
        "pull_request_review_id": null,
        "id": 4998732,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MzI=",
        "diff_hunk": "@@ -1398,61 +1349,267 @@ function fbind(value) {\n Q.keys = dispatcher(\"keys\");\n \n /**\n- * Turns an array of promises into a promise for an array.  If any of\n- * the promises gets rejected, the whole array is rejected immediately.\n- * @param {Array*} an array (or promise for an array) of values (or\n- * promises for values)\n- * @returns a promise for an array of the corresponding values\n  */\n-// By Mark Miller\n-// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n-Q.all = all;\n-function all(promises) {\n-    return when(promises, function (promises) {\n-        var countDown = 0;\n-        var deferred = defer();\n-        array_reduce(promises, function (undefined, promise, index) {\n-            var snapshot;\n-            if (\n-                isPromise(promise) &&\n-                (snapshot = promise.inspect()).state === \"fulfilled\"\n-            ) {\n-                promises[index] = snapshot.value;\n+Q.iterate = dispatcher(\"iterate\");\n+\n+/**\n+ * Aggregates all of the input into a single value, asynchronously.  `reduce`\n+ * uses a pool of acreted values, optionall starting with some `basis`.  Each\n+ * time a value becomes available both from the input and the pool of bases,\n+ * the values are taken out and asynchronously combined.  When the combination\n+ * has been fulfilled, the result is placed back in the pool.  When the input\n+ * is exhausted, the result is the last value remainin in in the pool of\n+ * accumulated values.\n+ *\n+ * The result is rejected if and when any of the input values or combined\n+ * values are rejected.\n+ *\n+ * By default, the reducer will consume the entire input as it becomes\n+ * available.  With a `maxInFlight` argument, the reducer will only consume\n+ * enough to keep that number of concurrent reductions in progress.\n+ *\n+ * @param {Iterable*} input\n+ * @param {Function} callback a function that accepts a value from the base\n+ * pool and a value from the input, and produces a combined base to be returned\n+ * to the pool.\n+ * @param {Number?} maxInFlight the maximum number of concurrent reductions to\n+ * perform at any given time.  If `undefined`, there is no upper bound.  If",
        "path": "q.js",
        "position": null,
        "original_position": 227,
        "commit_id": "0e5d134e07a787e486f4d1174c93e5bf23779de6",
        "original_commit_id": "b694a102fe3bbe13f69b97564684187b84a06f1c",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "department of redundancy department\n",
        "created_at": "2013-07-02T23:11:30Z",
        "updated_at": "2013-07-07T04:52:24Z",
        "html_url": "https://github.com/kriskowal/q/pull/337#discussion_r4998732",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/337",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/4998732"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/337#discussion_r4998732"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/337"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5001806",
        "pull_request_review_id": null,
        "id": 5001806,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4MDY=",
        "diff_hunk": "@@ -1750,6 +1905,223 @@ function nodeify(promise, nodeback) {\n     }\n }\n \n+/**\n+ * An infinite promise queue is an asynchronous linked list that allows the\n+ * consumer to get a promise for a value before the producer has put one, or a\n+ * producer to put a value before the the consumer has asked for it.  Of\n+ * course, the more mundane case of a producer putting and then the consumer\n+ * getting works just as well.\n+ *\n+ * Additionally, a Queue supports the iterator API, specifically the iterator\n+ * API as returned by ES6 generators, with one crucial difference.  `next`\n+ * returns a promise for the next iteration.  This works by using an infinite\n+ * promise queue as an asynchronous transport for iterations.  Borrowing the\n+ * terms from the generator API, `send` and `throw`, and supplementing them",
        "path": "q.js",
        "position": 772,
        "original_position": 507,
        "commit_id": "0e5d134e07a787e486f4d1174c93e5bf23779de6",
        "original_commit_id": "f05e27069a62f81320e52ec9ef388969ba04f3eb",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Hmm, you are aware `send` got replaced by a `next` overload that takes a param?\n",
        "created_at": "2013-07-03T04:25:31Z",
        "updated_at": "2013-07-07T04:52:24Z",
        "html_url": "https://github.com/kriskowal/q/pull/337#discussion_r5001806",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/337",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5001806"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/337#discussion_r5001806"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/337"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5001925",
        "pull_request_review_id": null,
        "id": 5001925,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MjU=",
        "diff_hunk": "@@ -1750,6 +1905,223 @@ function nodeify(promise, nodeback) {\n     }\n }\n \n+/**\n+ * An infinite promise queue is an asynchronous linked list that allows the\n+ * consumer to get a promise for a value before the producer has put one, or a\n+ * producer to put a value before the the consumer has asked for it.  Of\n+ * course, the more mundane case of a producer putting and then the consumer\n+ * getting works just as well.\n+ *\n+ * Additionally, a Queue supports the iterator API, specifically the iterator\n+ * API as returned by ES6 generators, with one crucial difference.  `next`\n+ * returns a promise for the next iteration.  This works by using an infinite\n+ * promise queue as an asynchronous transport for iterations.  Borrowing the\n+ * terms from the generator API, `send` and `throw`, and supplementing them",
        "path": "q.js",
        "position": 772,
        "original_position": 507,
        "commit_id": "0e5d134e07a787e486f4d1174c93e5bf23779de6",
        "original_commit_id": "f05e27069a62f81320e52ec9ef388969ba04f3eb",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I had not heard, but I had hoped. I\u2019ll just have to re-arrange the prose here. We\u2019ll still need `send` for manipulating a queue.\n",
        "created_at": "2013-07-03T04:45:23Z",
        "updated_at": "2013-07-07T04:52:24Z",
        "html_url": "https://github.com/kriskowal/q/pull/337#discussion_r5001925",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/337",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5001925"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/337#discussion_r5001925"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/337"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5395858",
        "pull_request_review_id": null,
        "id": 5395858,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NTg=",
        "diff_hunk": "@@ -2115,59 +2126,32 @@ function Queue() {\n }\n \n /**\n- * When using a Queue as an asycnronous iteration transport, returns a promise\n- * for the next iteration.  Iterations are objects like `{value}` for an\n- * iteration, which can be supplemented with an index like `{value, index}` if\n- * the source is an array or array-like, and `{value, done: true}` for the\n- * completion of the iteration, optionally with a return value, or a rejected\n- * promise if the simulated generator threw an error.\n- * @returns {Iteration*}\n+ * Returns an asynchronous iterator that that wraps the consumer end of a\n+ * Queue.\n  */\n-Queue.prototype.next = function () {\n-    return this.get();\n-};\n-\n-/**\n- * When using a Queue as an asynchronous iteration transport, adds a value to\n- * the queue of iterations.  The value may be at an optional given index.  If\n- * no index is provided, the iteration will be given a sequence number.\n- * @param {Any} value\n- * @param {Number?} index\n- */\n-Queue.prototype.send = function (value, index) {\n-    if (index === undefined) {\n-        index = this.index++;\n-    }\n-    return this.put({value: value, index: index});\n+Queue.prototype.iterate = function () {\n+    return new this.QueueIterator(this.get);\n };\n \n /**\n- * When using a Queue as an asynchronous iteration transport, adds a completion\n- * value to the queue of iterations.  This signals the end of the sequence,\n- * like closing a stream.\n+ * Returns an asynchronous \"generator\" that wraps the producing side of a\n+ * Queue.  The \"generator\" is merely an object that has \"yield\", \"return\", and\n+ * \"throw\" methods that emulate the corresponding keywords within a generator\n+ * function.\n  */\n-Queue.prototype[\"return\"] = function (value) {\n-    this.put({value: value, done: true});\n+Queue.prototype.generate = function () {\n+    return new this.QueueGenerator(this.put);\n };\n \n /**\n- * When using a Queue as an asynchronous iteration transport, adds a thrown\n- * exception to the queue.  This signals the end of the sequence, like closing\n- * a stream with an error, or throwing an exception from a generator.\n+ * @see QueueIterator\n  */\n-Queue.prototype[\"throw\"] = function (error) {\n-    this.put(Q.reject(error));\n-};\n+Queue.prototype.QueueIterator = QueueIterator;",
        "path": "q.js",
        "position": 153,
        "original_position": 153,
        "commit_id": "e25c98cbab9f011f252915af15d52dcf46c95feb",
        "original_commit_id": "e25c98cbab9f011f252915af15d52dcf46c95feb",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Interesting, any particular reason to allow instances to use their own `QueueIterator`/`QueueGenerator` classes?\n",
        "created_at": "2013-07-25T11:40:15Z",
        "updated_at": "2013-07-25T11:40:15Z",
        "html_url": "https://github.com/kriskowal/q/pull/348#discussion_r5395858",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/348",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5395858"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/348#discussion_r5395858"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/348"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5395899",
        "pull_request_review_id": null,
        "id": 5395899,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4OTk=",
        "diff_hunk": "@@ -1496,11 +1497,12 @@ describe(\"queue\", function () {\n \n     it(\"should emulate a generator with forEach\", function () {",
        "path": "spec/q-spec.js",
        "position": 31,
        "original_position": 31,
        "commit_id": "e25c98cbab9f011f252915af15d52dcf46c95feb",
        "original_commit_id": "e25c98cbab9f011f252915af15d52dcf46c95feb",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Might be good to add a test using the iterator only, via either `Q.forEach(queue.iterate())` to simulate giving the iterator to some other caller, or via `Q.forEach(queue)` to test that the queue implementers the \"has-`iterate()`\" interface correctly. Or both.\n",
        "created_at": "2013-07-25T11:42:56Z",
        "updated_at": "2013-07-25T11:42:56Z",
        "html_url": "https://github.com/kriskowal/q/pull/348#discussion_r5395899",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/348",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5395899"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/348#discussion_r5395899"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/348"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5395908",
        "pull_request_review_id": null,
        "id": 5395908,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MDg=",
        "diff_hunk": "@@ -2115,59 +2126,32 @@ function Queue() {\n }\n \n /**\n- * When using a Queue as an asycnronous iteration transport, returns a promise\n- * for the next iteration.  Iterations are objects like `{value}` for an\n- * iteration, which can be supplemented with an index like `{value, index}` if\n- * the source is an array or array-like, and `{value, done: true}` for the\n- * completion of the iteration, optionally with a return value, or a rejected\n- * promise if the simulated generator threw an error.\n- * @returns {Iteration*}\n+ * Returns an asynchronous iterator that that wraps the consumer end of a\n+ * Queue.\n  */\n-Queue.prototype.next = function () {\n-    return this.get();\n-};\n-\n-/**\n- * When using a Queue as an asynchronous iteration transport, adds a value to\n- * the queue of iterations.  The value may be at an optional given index.  If\n- * no index is provided, the iteration will be given a sequence number.\n- * @param {Any} value\n- * @param {Number?} index\n- */\n-Queue.prototype.send = function (value, index) {\n-    if (index === undefined) {\n-        index = this.index++;\n-    }\n-    return this.put({value: value, index: index});\n+Queue.prototype.iterate = function () {",
        "path": "q.js",
        "position": 125,
        "original_position": 125,
        "commit_id": "e25c98cbab9f011f252915af15d52dcf46c95feb",
        "original_commit_id": "e25c98cbab9f011f252915af15d52dcf46c95feb",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Hmm, why not use the existing convention of `iterator()`? Then you wouldn't need to add a new case to the iterable-detection.\n",
        "created_at": "2013-07-25T11:43:31Z",
        "updated_at": "2013-07-25T11:43:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/348#discussion_r5395908",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/348",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5395908"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/348#discussion_r5395908"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/348"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398396",
        "pull_request_review_id": null,
        "id": 5398396,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzOTY=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 3,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Just use `Q.delay`?\n",
        "created_at": "2013-07-25T14:13:34Z",
        "updated_at": "2013-07-25T15:00:00Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398396",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398396"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398396"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398398",
        "pull_request_review_id": null,
        "id": 5398398,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzOTg=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 11,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Just use `Q`?\n",
        "created_at": "2013-07-25T14:13:41Z",
        "updated_at": "2013-07-25T15:00:00Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398398",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398398"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398398"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398420",
        "pull_request_review_id": null,
        "id": 5398420,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg0MjA=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {\n+    const deferredResult = Q.defer();\n+    deferredResult.resolve(answer)\n+    return deferredResult.promise;\n+}\n+\n+var waitForAll = Q.async(function*() {\n+    var ps = [",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 18,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Seems like this whole function could be reduced to `return [yield Q.delay(500, \"a\"), yield Q.delay(1000, \"b\"), yield Q(\"c\")]`?\n",
        "created_at": "2013-07-25T14:14:22Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398420",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398420"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398420"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398428",
        "pull_request_review_id": null,
        "id": 5398428,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg0Mjg=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {\n+    const deferredResult = Q.defer();\n+    deferredResult.resolve(answer)\n+    return deferredResult.promise;\n+}\n+\n+var waitForAll = Q.async(function*() {\n+    var ps = [\n+        delay(500,\"a\"),\n+        delay(1000,\"b\"),\n+        alreadyResolved(\"c\")\n+    ];\n+\n+    var results = [];\n+    for(var i = 0; i < ps.length; i++) {\n+        results.push( yield ps[i] );\n+    }\n+    return results;\n+});\n+\n+waitForAll().then(function(all) {",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 31,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Use `done` for the end of the chain instead of `then`.\n",
        "created_at": "2013-07-25T14:14:37Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398428",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398428"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398428"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398601",
        "pull_request_review_id": null,
        "id": 5398601,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg2MDE=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 3,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "timruffles",
            "id": 249800,
            "node_id": "MDQ6VXNlcjI0OTgwMA==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/249800?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/timruffles",
            "html_url": "https://github.com/timruffles",
            "followers_url": "https://api.github.com/users/timruffles/followers",
            "following_url": "https://api.github.com/users/timruffles/following{/other_user}",
            "gists_url": "https://api.github.com/users/timruffles/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/timruffles/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/timruffles/subscriptions",
            "organizations_url": "https://api.github.com/users/timruffles/orgs",
            "repos_url": "https://api.github.com/users/timruffles/repos",
            "events_url": "https://api.github.com/users/timruffles/events{/privacy}",
            "received_events_url": "https://api.github.com/users/timruffles/received_events",
            "type": "User",
            "site_admin": true
        },
        "body": "Copied from [other example code](https://github.com/kriskowal/q/blob/6a34b92771d9642203b6e0593802314b81dc0bf9/examples/async-generators/3-spawn.js) for consistency.\n",
        "created_at": "2013-07-25T14:21:16Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398601",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398601"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398601"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398603",
        "pull_request_review_id": null,
        "id": 5398603,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg2MDM=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 11,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "timruffles",
            "id": 249800,
            "node_id": "MDQ6VXNlcjI0OTgwMA==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/249800?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/timruffles",
            "html_url": "https://github.com/timruffles",
            "followers_url": "https://api.github.com/users/timruffles/followers",
            "following_url": "https://api.github.com/users/timruffles/following{/other_user}",
            "gists_url": "https://api.github.com/users/timruffles/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/timruffles/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/timruffles/subscriptions",
            "organizations_url": "https://api.github.com/users/timruffles/orgs",
            "repos_url": "https://api.github.com/users/timruffles/repos",
            "events_url": "https://api.github.com/users/timruffles/events{/privacy}",
            "received_events_url": "https://api.github.com/users/timruffles/received_events",
            "type": "User",
            "site_admin": true
        },
        "body": "ibid.\n",
        "created_at": "2013-07-25T14:21:18Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398603",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398603"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398603"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398604",
        "pull_request_review_id": null,
        "id": 5398604,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg2MDQ=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {\n+    const deferredResult = Q.defer();\n+    deferredResult.resolve(answer)\n+    return deferredResult.promise;\n+}\n+\n+var waitForAll = Q.async(function*() {\n+    var ps = [",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 18,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "timruffles",
            "id": 249800,
            "node_id": "MDQ6VXNlcjI0OTgwMA==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/249800?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/timruffles",
            "html_url": "https://github.com/timruffles",
            "followers_url": "https://api.github.com/users/timruffles/followers",
            "following_url": "https://api.github.com/users/timruffles/following{/other_user}",
            "gists_url": "https://api.github.com/users/timruffles/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/timruffles/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/timruffles/subscriptions",
            "organizations_url": "https://api.github.com/users/timruffles/orgs",
            "repos_url": "https://api.github.com/users/timruffles/repos",
            "events_url": "https://api.github.com/users/timruffles/events{/privacy}",
            "received_events_url": "https://api.github.com/users/timruffles/received_events",
            "type": "User",
            "site_admin": true
        },
        "body": "How would that be a demonstration of the code composing with flow control precisely?\n",
        "created_at": "2013-07-25T14:21:20Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398604",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398604"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398604"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398713",
        "pull_request_review_id": null,
        "id": 5398713,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3MTM=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {\n+    const deferredResult = Q.defer();\n+    deferredResult.resolve(answer)\n+    return deferredResult.promise;\n+}\n+\n+var waitForAll = Q.async(function*() {\n+    var ps = [",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 18,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm not sure how the current code demonstrates composing with flow control either :-/. It just demonstrates a very inefficient way of assembling an array.\n",
        "created_at": "2013-07-25T14:24:34Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398713",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398713"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398713"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398719",
        "pull_request_review_id": null,
        "id": 5398719,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3MTk=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 3,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I suppose we should fix those.\n",
        "created_at": "2013-07-25T14:24:48Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5398719",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5398719"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5398719"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5399017",
        "pull_request_review_id": null,
        "id": 5399017,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkwMTc=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {\n+    const deferredResult = Q.defer();\n+    deferredResult.resolve(answer)\n+    return deferredResult.promise;\n+}\n+\n+var waitForAll = Q.async(function*() {\n+    var ps = [",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 18,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "timruffles",
            "id": 249800,
            "node_id": "MDQ6VXNlcjI0OTgwMA==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/249800?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/timruffles",
            "html_url": "https://github.com/timruffles",
            "followers_url": "https://api.github.com/users/timruffles/followers",
            "following_url": "https://api.github.com/users/timruffles/following{/other_user}",
            "gists_url": "https://api.github.com/users/timruffles/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/timruffles/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/timruffles/subscriptions",
            "organizations_url": "https://api.github.com/users/timruffles/orgs",
            "repos_url": "https://api.github.com/users/timruffles/repos",
            "events_url": "https://api.github.com/users/timruffles/events{/privacy}",
            "received_events_url": "https://api.github.com/users/timruffles/received_events",
            "type": "User",
            "site_admin": true
        },
        "body": "Demonstration code isn't about efficiency IMO. It's a simple demo of how the yield pattern lets us use basic flow-control stuff again. Perhaps it could also have some if/elses in there too:\n\n```\nif(yield aPromise) alert(\"Oh look I can use promises as if they're blocking\");\n```\n",
        "created_at": "2013-07-25T14:33:39Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5399017",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5399017"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5399017"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5399115",
        "pull_request_review_id": null,
        "id": 5399115,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkxMTU=",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+var Q = require('../../q');\n+\n+function delay(millis, answer) {\n+    const deferredResult = Q.defer();\n+    setTimeout(function() {\n+        deferredResult.resolve(answer);\n+    }, millis);\n+    return deferredResult.promise;\n+}\n+\n+function alreadyResolved(answer) {\n+    const deferredResult = Q.defer();\n+    deferredResult.resolve(answer)\n+    return deferredResult.promise;\n+}\n+\n+var waitForAll = Q.async(function*() {\n+    var ps = [",
        "path": "examples/async-generators/4-flow-control.js",
        "position": null,
        "original_position": 18,
        "commit_id": "5b9a81a794257ca7f2b9ebe672ae3ce42f2d3483",
        "original_commit_id": "072c77775a98776ccd4ea35c84bef80c88430b97",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think `if`s would be a nicer demonstration, yeah. As-is this doesn't show the power of generators with regard to control flow primitives at all, i.e. it's too easy to go \"well why did you just put them in an array like a normal person?\"\n",
        "created_at": "2013-07-25T14:36:38Z",
        "updated_at": "2013-07-25T15:00:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/350#discussion_r5399115",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/350",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5399115"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/350#discussion_r5399115"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/350"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412034",
        "pull_request_review_id": null,
        "id": 5412034,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMzQ=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to",
        "path": "README.md",
        "position": null,
        "original_position": 118,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "gains gains spotted\n",
        "created_at": "2013-07-25T22:36:19Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412034",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412034"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412034"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412071",
        "pull_request_review_id": null,
        "id": 5412071,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwNzE=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the",
        "path": "README.md",
        "position": null,
        "original_position": 185,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "at the rate / at the same rate, spotted.\n",
        "created_at": "2013-07-25T22:38:37Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412071",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412071"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412071"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412252",
        "pull_request_review_id": null,
        "id": 5412252,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNTI=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`",
        "path": "README.md",
        "position": null,
        "original_position": 559,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "practicle -> practical\n",
        "created_at": "2013-07-25T22:48:06Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412252",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412252"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412252"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412324",
        "pull_request_review_id": null,
        "id": 5412324,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIzMjQ=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,",
        "path": "README.md",
        "position": null,
        "original_position": 589,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "iteratoble -> iterable?\n",
        "created_at": "2013-07-25T22:53:22Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412324",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412324"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412324"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412367",
        "pull_request_review_id": null,
        "id": 5412367,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIzNjc=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than",
        "path": "README.md",
        "position": null,
        "original_position": 652,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "counsume -> consume\n",
        "created_at": "2013-07-25T22:56:02Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412367",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412367"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412367"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412378",
        "pull_request_review_id": null,
        "id": 5412378,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIzNzg=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values",
        "path": "README.md",
        "position": null,
        "original_position": 653,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This line is a little confusing.\n",
        "created_at": "2013-07-25T22:56:58Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412378",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412378"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412378"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412408",
        "pull_request_review_id": null,
        "id": 5412408,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI0MDg=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values\n+have been placed in the `output` bin.\n+\n+This is an implementation for a scheduling buffer, eliding very few\n+details of the actual implementation.\n+\n+```javascript\n+var pipe = new Q.Pipe(source, maxInFlight);\n+var inbox = pipe.input.iterate();\n+\n+function job() {\n+    // waits for a value to become available\n+    inbox.next().then(function (iteration) {\n+        // as long as they're coming, keep asking\n+        job();\n+        // start this job\n+        return process(iteration.value);\n+    })\n+    .then(function (result) {\n+        outbox.yield(result);\n+    })\n+}\n+job();\n+\n+var outbox = pipe.output.generate();\n+return pipe.output.iterate();\n+```\n+\n+One elided detail is that the input may be a promise for a remote\n+iterable, in which case we do not need to have a local iterator but can\n+instead send the \"iterate\" message to the remote and get a promise for a\n+remote iterator on which we may invoke the remote \"next\" method to\n+transfer remote iterations on demand.\n+\n+\n+### Generators for Control-flow\n+\n+A generator can be used as a \"trampouline\" for promises to regain use of\n+all of the control flow abstractions afforded to us by JavaScript.  The\n+`async` method decorates a generator function and turns it into a\n+function that returns a promise for the eventual return value of the\n+generator, but internally uses the `yield` to explicitly pause the\n+current event and wait for that promise to resolve.  Whent that promise",
        "path": "README.md",
        "position": null,
        "original_position": 695,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Whent -> When\n",
        "created_at": "2013-07-25T22:59:34Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412408",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412408"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412408"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412421",
        "pull_request_review_id": null,
        "id": 5412421,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI0MjE=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values\n+have been placed in the `output` bin.\n+\n+This is an implementation for a scheduling buffer, eliding very few\n+details of the actual implementation.\n+\n+```javascript\n+var pipe = new Q.Pipe(source, maxInFlight);\n+var inbox = pipe.input.iterate();\n+\n+function job() {\n+    // waits for a value to become available\n+    inbox.next().then(function (iteration) {\n+        // as long as they're coming, keep asking\n+        job();\n+        // start this job\n+        return process(iteration.value);\n+    })\n+    .then(function (result) {\n+        outbox.yield(result);\n+    })\n+}\n+job();\n+\n+var outbox = pipe.output.generate();\n+return pipe.output.iterate();\n+```\n+\n+One elided detail is that the input may be a promise for a remote\n+iterable, in which case we do not need to have a local iterator but can\n+instead send the \"iterate\" message to the remote and get a promise for a\n+remote iterator on which we may invoke the remote \"next\" method to\n+transfer remote iterations on demand.\n+\n+\n+### Generators for Control-flow\n+\n+A generator can be used as a \"trampouline\" for promises to regain use of\n+all of the control flow abstractions afforded to us by JavaScript.  The\n+`async` method decorates a generator function and turns it into a\n+function that returns a promise for the eventual return value of the\n+generator, but internally uses the `yield` to explicitly pause the\n+current event and wait for that promise to resolve.  Whent that promise\n+resolves, the `yield` expression either takes on the fulfillment value\n+or throws an exception right into the the generator function's control\n+flow and stack.\n+\n+The `spawn` method is equivalent to decorating a function with `async`,\n+immediately invoking it, and using `done` to ensure that errors are\n+handled.\n+\n+In this example, we have a an asynchronous generator function that\n+consumes iterations from an iterator, waits for the iteration's value,\n+waits for the iterations index, then calls the map function waiting for",
        "path": "README.md",
        "position": null,
        "original_position": 706,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "iterations -> iteration's\n",
        "created_at": "2013-07-25T23:00:19Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412421",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412421"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412421"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412667",
        "pull_request_review_id": null,
        "id": 5412667,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2Njc=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.",
        "path": "README.md",
        "position": null,
        "original_position": 409,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "message -> messages\n",
        "created_at": "2013-07-25T23:16:28Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412667",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412667"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412667"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412670",
        "pull_request_review_id": null,
        "id": 5412670,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2NzA=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.",
        "path": "README.md",
        "position": null,
        "original_position": 411,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "mili -> milli\n",
        "created_at": "2013-07-25T23:16:44Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412670",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412670"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412670"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412702",
        "pull_request_review_id": null,
        "id": 5412702,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI3MDI=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.",
        "path": "README.md",
        "position": null,
        "original_position": 474,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\"do not\" -> \", and we do not\"\n",
        "created_at": "2013-07-25T23:19:01Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412702",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412702"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412702"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412813",
        "pull_request_review_id": null,
        "id": 5412813,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4MTM=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`",
        "path": "README.md",
        "position": null,
        "original_position": 559,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "thanks\n",
        "created_at": "2013-07-25T23:27:09Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412813",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412813"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412813"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412815",
        "pull_request_review_id": null,
        "id": 5412815,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4MTU=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,",
        "path": "README.md",
        "position": null,
        "original_position": 589,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "thanks\n",
        "created_at": "2013-07-25T23:27:15Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412815",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412815"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412815"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412817",
        "pull_request_review_id": null,
        "id": 5412817,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4MTc=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than",
        "path": "README.md",
        "position": null,
        "original_position": 652,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "thanks\n",
        "created_at": "2013-07-25T23:27:20Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412817",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412817"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412817"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412835",
        "pull_request_review_id": null,
        "id": 5412835,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4MzU=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values",
        "path": "README.md",
        "position": null,
        "original_position": 653,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "thanks, i'm trying \u201cOnce `maxInFlight` values have been drawn from the true\ninput, the pipe ensures that additional values will only be requested\nafter the same quantity of values are consumed from the true output.\u201d\n",
        "created_at": "2013-07-25T23:28:18Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412835",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412835"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412835"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412841",
        "pull_request_review_id": null,
        "id": 5412841,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4NDE=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values\n+have been placed in the `output` bin.\n+\n+This is an implementation for a scheduling buffer, eliding very few\n+details of the actual implementation.\n+\n+```javascript\n+var pipe = new Q.Pipe(source, maxInFlight);\n+var inbox = pipe.input.iterate();\n+\n+function job() {\n+    // waits for a value to become available\n+    inbox.next().then(function (iteration) {\n+        // as long as they're coming, keep asking\n+        job();\n+        // start this job\n+        return process(iteration.value);\n+    })\n+    .then(function (result) {\n+        outbox.yield(result);\n+    })\n+}\n+job();\n+\n+var outbox = pipe.output.generate();\n+return pipe.output.iterate();\n+```\n+\n+One elided detail is that the input may be a promise for a remote\n+iterable, in which case we do not need to have a local iterator but can\n+instead send the \"iterate\" message to the remote and get a promise for a\n+remote iterator on which we may invoke the remote \"next\" method to\n+transfer remote iterations on demand.\n+\n+\n+### Generators for Control-flow\n+\n+A generator can be used as a \"trampouline\" for promises to regain use of\n+all of the control flow abstractions afforded to us by JavaScript.  The\n+`async` method decorates a generator function and turns it into a\n+function that returns a promise for the eventual return value of the\n+generator, but internally uses the `yield` to explicitly pause the\n+current event and wait for that promise to resolve.  Whent that promise",
        "path": "README.md",
        "position": null,
        "original_position": 695,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "got it\n",
        "created_at": "2013-07-25T23:28:35Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412841",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412841"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412841"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412842",
        "pull_request_review_id": null,
        "id": 5412842,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4NDI=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values\n+have been placed in the `output` bin.\n+\n+This is an implementation for a scheduling buffer, eliding very few\n+details of the actual implementation.\n+\n+```javascript\n+var pipe = new Q.Pipe(source, maxInFlight);\n+var inbox = pipe.input.iterate();\n+\n+function job() {\n+    // waits for a value to become available\n+    inbox.next().then(function (iteration) {\n+        // as long as they're coming, keep asking\n+        job();\n+        // start this job\n+        return process(iteration.value);\n+    })\n+    .then(function (result) {\n+        outbox.yield(result);\n+    })\n+}\n+job();\n+\n+var outbox = pipe.output.generate();\n+return pipe.output.iterate();\n+```\n+\n+One elided detail is that the input may be a promise for a remote\n+iterable, in which case we do not need to have a local iterator but can\n+instead send the \"iterate\" message to the remote and get a promise for a\n+remote iterator on which we may invoke the remote \"next\" method to\n+transfer remote iterations on demand.\n+\n+\n+### Generators for Control-flow\n+\n+A generator can be used as a \"trampouline\" for promises to regain use of\n+all of the control flow abstractions afforded to us by JavaScript.  The\n+`async` method decorates a generator function and turns it into a\n+function that returns a promise for the eventual return value of the\n+generator, but internally uses the `yield` to explicitly pause the\n+current event and wait for that promise to resolve.  Whent that promise\n+resolves, the `yield` expression either takes on the fulfillment value\n+or throws an exception right into the the generator function's control\n+flow and stack.\n+\n+The `spawn` method is equivalent to decorating a function with `async`,\n+immediately invoking it, and using `done` to ensure that errors are\n+handled.\n+\n+In this example, we have a an asynchronous generator function that\n+consumes iterations from an iterator, waits for the iteration's value,\n+waits for the iterations index, then calls the map function waiting for",
        "path": "README.md",
        "position": null,
        "original_position": 706,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "got it\n",
        "created_at": "2013-07-25T23:28:39Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412842",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412842"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412842"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412846",
        "pull_request_review_id": null,
        "id": 5412846,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4NDY=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.",
        "path": "README.md",
        "position": null,
        "original_position": 409,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "got it\n",
        "created_at": "2013-07-25T23:28:44Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412846",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412846"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412846"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412854",
        "pull_request_review_id": null,
        "id": 5412854,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4NTQ=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.",
        "path": "README.md",
        "position": null,
        "original_position": 411,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "fixed all occurrences, thanks\n",
        "created_at": "2013-07-25T23:29:16Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412854",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412854"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412854"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412857",
        "pull_request_review_id": null,
        "id": 5412857,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI4NTc=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.",
        "path": "README.md",
        "position": null,
        "original_position": 474,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "got it\n",
        "created_at": "2013-07-25T23:29:23Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5412857",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5412857"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5412857"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/5414646",
        "pull_request_review_id": null,
        "id": 5414646,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ2NDY=",
        "diff_hunk": "@@ -777,12 +782,686 @@ This feature does come with somewhat-serious performance and memory overhead,\n however. If you're working with lots of promises, or trying to scale a server\n to many users, you should probably keep it off. But in development, go for it!\n \n+\n+### Primer on Iterators and Generators\n+\n+EcmaScript 6 introduces a brand of iterators to JavaScript.  Contact\n+your local JavaScript engine for information on how to try them out.\n+They have appeared in very recent versions of V8 (Chrome and Node) and\n+SpiderMonkey (Firefox) but are hidden behind flags at time of writing.\n+\n+An iterator is an object that has a `next` method.  The `next` method\n+returns an \"iterator\", which is an object that conveys either a value or\n+whether the iterator has reached its end using `value` and `done`\n+properties.\n+\n+```javascript\n+iteration.next() // {value: 1}\n+iteration.next() // {value: 2}\n+iteration.next() // {value: 3}\n+iteration.next() // {done: true}\n+```\n+\n+EcmaScript 6 also introduces generator functions.  A generator function\n+is a \"shallow coroutine\", a function that pauses and resumes at explicit\n+\"yield\" expressions.  When called, a generator function returns an\n+iterator.\n+\n+```javascript\n+function *range(start, stop, step) {\n+    while (start < step) {\n+        yield start;\n+        start += step;\n+    }\n+}\n+\n+var iterator = range(0, Infinity, 1);\n+iterator.next() // {value: 0};\n+iterator.next() // {value: 1};\n+iterator.next() // {value: 2};\n+```\n+\n+The `next` method gains the ability to convey the return value of the\n+generator function in addition to communicating that the iteration has\n+come to an end.\n+\n+```javascript\n+function *startRace() {\n+    yield 3;\n+    yield 2;\n+    yield 1;\n+    return \"Go!\";\n+}\n+\n+var starter = startRace();\n+starter.next() // {value: 3};\n+starter.next() // {value: 2};\n+starter.next() // {value: 1};\n+starter.next() // {value: 'Go!', done: true};\n+```\n+\n+With generators, the `next` method also gains gains the ability to\n+convey a value for the `yield` expression, making it both the sender and\n+receiver of information.  If the generator throws an exception while\n+trying to reach the next `yield`, the `next` method will throw that\n+exception.\n+\n+```javascript\n+function *contrivedExample(previous) {\n+    while (true) {\n+        previous = yield previous + 1;\n+    }\n+}\n+\n+var oneUp = contrivedExample(0);\n+oneUp.next(100) // {value: 1}\n+oneUp.next(-100) // {value: 101}\n+oneUp.next() // {value: -99}\n+```\n+\n+\n+### Asynchronous Iterators\n+\n+This library introduces the notion of an asynchronous iterator.  The\n+`next` function again gains a new ability.  Instead of returning an\n+iteration, it returns a promise for an iteration.  Additionally, the\n+iteration may have an `index` property, so if you are iterating an\n+array, you can use `iteratation.index` to infer the index that\n+`iteration.value` came from.  Implementing `next` is sufficent for Q to\n+recognize a value that is an iterator.\n+\n+Of course, just as with a normal iterator, the `iteration.value` may be\n+a promise as well, separating the issue of synchronizing the order of\n+delivery from the issue of synchronizing the order of the resolution of\n+the transported values.\n+\n+Implementing an `iterate` or `iterator` method is sufficient for Q to\n+recognize an iterable and iterate it accordingly.  `iterator` because\n+SpiderMonkey established that precedent, `iterate` because that's what\n+it should be and because ES6 did not continue that precedent, favoring\n+private names, and thus avoiding the duck-type issue entirely.\n+\n+Q can consume iterators and can produce asynchronous iterators using the\n+functions `forEach`, `map`, `reduce`, and `buffer`.\n+\n+\n+### Promises as Streams\n+\n+A promise for an iterable can be used as a stream, including the ability\n+to moderate the rate of consumption to approach the rate of production,\n+which is often called \"back pressure\" in the Unix pipe metaphore.\n+\n+Q provides the methods `forEach`, `map`, `reduce`, and `buffer` for\n+using a promise as a stream.  The `all` method can also accumulate\n+values from a stream.\n+\n+The stream functions all accept optional `maxInFlight` and `notify`\n+arguments.  `maxInFlight` determines the upper limit on how many\n+concurrent operations the function can schedule and the default varies.\n+`notify` is an optional callback that provides the current `inFlight`\n+and shared `maxInFlight` values for an operation.\n+\n+\n+#### map\n+\n+The `map` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise for a corresponding value and produces a stream of\n+those values.  Values are consumed at the rate at the same rate as the\n+callback.\n+\n+In this example, we transform a stream of user identifiers into a stream\n+of users, getting user information from the database, piplining up to\n+100 requests at any given time.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.all(function (users) {\n+    // all users available in memory.\n+    // this might not be a good idea.\n+})\n+.done();\n+```\n+\n+To enforce serial processing, `maxInFlight` may be set to 1.  By\n+default, it is infinite.\n+\n+The output stream closes when the input has been consumed in its\n+entirety *and* all results have been queued on the output stream.\n+\n+#### forEach\n+\n+The `forEach` method consumes up to `maxInFlight` values from the input\n+stream while processing those values.  It takes a callback that may\n+return a promise *for scheuduling and synchronization purposes only*.\n+The fulfillment of the callback is ignored, but rejections propagate and\n+halt the loop.\n+\n+This example starts as the previous.  We consume the stream of users one\n+at a time with an artificial delay of 100 miliseconds between printing\n+each user's name.  When the list is finished, we print an underline.\n+\n+```javascript\n+Q(userIds).map(function (id) {\n+    return getUserForId(id);\n+}, 100)\n+.forEach(function (user) {\n+    console.log(user.name);\n+    return Q.delay(100);\n+})\n+.then(function () {\n+    console.log(\"-----\");\n+})\n+.done();\n+```\n+\n+Note that the artificial delay on the `forEach` may dominate the\n+scheduling constraints.  As such, the `map` operation might slow down,\n+accumulating up to 100 users on its output stream but requesting a new\n+one once every 100ms on average.\n+\n+### reduce\n+\n+The `reduce` method, much like its forebear on `Array.prototype`,\n+accepts an aggregator function.  It also takes an optional `basis`, and\n+once you've opted in to having a basis instead of just using the first\n+value from the source, you can also provide `maxInFlight` and `notify`.\n+\n+In this example, we accumulate a sum using a combinator (Code-ish for\n+\"combiner\") that returns a promise.\n+\n+```javascript\n+Q(source).reduce(function (sum, number) {\n+    return slowCombinator(sum, number);\n+}, 1, 100);\n+```\n+\n+Not being able to specify `maxInFlight` or `notify` without opting into\n+a basis is a known and unsolved wart of the interface.  For your\n+consolation, most reductions have an appropriate \"identity\" for\n+reduction, like 0 for computing a sum of numbers, 1 for computing a\n+product of numbers, empty arrays and strings for concatenation, null for\n+just about anything else, but streams of heterogenous values can be\n+problematic.\n+\n+The default `maxInFlight` is infinite. Values are aggregated as they\n+come, and if the aggregator is slow, the reduction may overschedule the\n+process and saturate memory.  Remember, the major performance benefit of\n+using Node follows from all IO operations being asynchronous, but when\n+the process runs out of real memory, swapping virtual memory pages is\n+inherently *synchronous*.\n+\n+`reduce` eventually consumes all of the values from the input and\n+aggregates them opportunistically.  That is, as each value from the\n+input becomes available, it is placed in a pool of values that can be\n+aggregated.  Up to `maxInFlight` values will be plucked from that pool\n+and sent off for aggregation using the given callback, first-to-come:\n+first-served.  When the aggregator completes, the new compound value\n+returns to the pool.  In the end, there will only be one value in the\n+pool and that is the result.\n+\n+Note that if the source comes from a `map`, both `map` and `reduce` are\n+opportunistic.  A `map` will stream values as they become available,\n+regardless of the order or timing of the mapping relation (barring\n+exceptions).\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0)\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output like:\n+\n+```\n+combining 9 with 0 for 9 so far\n+combining 3 with 9 for 12 so far\n+combining 5 with 12 for 17 so far\n+combining 2 with 17 for 19 so far\n+combining 8 with 19 for 27 so far\n+combining 6 with 27 for 33 so far\n+combining 1 with 33 for 34 so far\n+combining 7 with 34 for 41 so far\n+combining 4 with 41 for 45 so far\n+combining 10 with 45 for 55 so far\n+grand total 55\n+```\n+\n+Note that throttling the mapper or reducer limits the range of values available\n+to the combiner.\n+\n+```javascript\n+var Q = require(\"./q\");\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+}) // <- could be constrained here\n+.reduce(function (total, n) {\n+    console.log('combining', n, 'with', total, 'for', total + n, 'so far');\n+    return total + n;\n+}, 0, 3) // <- extra argument here\n+.then(function (total) {\n+    console.log('grand total', total);\n+})\n+.done();\n+```\n+\n+For output that favors earlier values initially:\n+\n+```\n+combining 1 with 0 for 1 so far\n+combining 3 with 1 for 4 so far\n+combining 2 with 4 for 6 so far\n+combining 7 with 6 for 13 so far\n+combining 5 with 13 for 18 so far\n+combining 4 with 18 for 22 so far\n+combining 9 with 22 for 31 so far\n+combining 6 with 31 for 37 so far\n+combining 10 with 37 for 47 so far\n+combining 8 with 47 for 55 so far\n+grand total 55\n+```\n+\n+If `maxInFlight` is 1, `reduce` is serial, equivalent to the\n+left-to-right `reduce` on `Array.prototype`.  A right-to-left reduce\n+does not make sense for streams, but you can use `all` and `invoke`\n+`reduceRight` on the resulting array.\n+\n+```javascript\n+Q([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n+.map(function (n) {\n+    return Q(n).delay(Math.random() * 1000);\n+})\n+.all()\n+.invoke(\"reduceRight\", function (total, number) {\n+    console.log('adding', number, 'to', total, 'for', total + number, 'so far');\n+    return total + number;\n+})\n+.then(function (total) {\n+    console.log(\"Grand total\", total);\n+})\n+.done();\n+```\n+\n+Which accumulates all of the input in memory and walks from right to left.\n+\n+```javascript\n+adding 9 to 10 for 19 so far\n+adding 8 to 19 for 27 so far\n+adding 7 to 27 for 34 so far\n+adding 6 to 34 for 40 so far\n+adding 5 to 40 for 45 so far\n+adding 4 to 45 for 49 so far\n+adding 3 to 49 for 52 so far\n+adding 2 to 52 for 54 so far\n+adding 1 to 54 for 55 so far\n+Grand total 55\n+```\n+\n+Note that the output is in exactly the reverse order of the input, despite the\n+randomization produced by `map`.  This is because `map` has communicated the\n+iteration `index` from the input array to the output stream and `all` has\n+reassembled the array in its original order.  The strict order is not an\n+indication that `map` yielded the values in that order.\n+\n+\n+### Infinite Promise Queue\n+\n+An infinite promise queue is a first-on-first-off (FIFO) structure.  It\n+has two methods, `get` and `put`, which are implicitly bound to the\n+queue and can safely be passed as functions.\n+\n+The `get` method returns a promise and the `put` method resolves the\n+respective promise.  Unlike a synchronous queue, because `get` returns a\n+promise, you can call `get` before calling `put`.  The consumer and\n+producer side of a queue do not need to even be aware of each other's\n+existence.  Also, because `put` accepts values or promises, the promises\n+returned by `get` do not need to be resolved in order.\n+\n+In this example, note that we call `get` once immediately, and then we\n+call `get` again after the first promise is resolved.  This should\n+ensure that the first and second message are logged in order.\n+\n+Note that we wait 100 miliseconds before putting anything on the queue.\n+At that time, we put *a promise* for the first message on the queue, and\n+resolve the second message immediately.  Thus, the second message is\n+fulfilled first, before the consumer has even asked for it.\n+\n+```javascript\n+var Queue = require(\"q\").Queue;\n+var queue = Queue();\n+\n+return queue.get()\n+.then(function (first) {\n+    console.log(first);\n+    return queue.get()\n+})\n+.then(function (second) {\n+    console.log(second);\n+})\n+.done();\n+\n+Q.delay(100)\n+.then(function () {\n+    queue.put(Q(\"Hello\").delay(100));\n+    queue.put(\"World\");\n+})\n+.done();\n+```\n+\n+In summary, an infinite asynchronous promise queue is a fascinating\n+machine that preserves consistent FIFO rules, but relaxes all rules\n+about the order in which values are produced or consumed.  In addition,\n+the implementation is incredibly succinct.  It is a variation on a\n+singly linked list, a Lisp list.\n+\n+```javascript\n+var ends = Q.defer();\n+this.put = function (value) {\n+    var next = Q.defer();\n+    ends.resolve({\n+        head: value,\n+        tail: next.promise\n+    });\n+    ends.resolve = next.resolve;\n+};\n+this.get = function () {\n+    var result = ends.promise.get(\"head\");\n+    ends.promise = ends.promise.get(\"tail\");\n+    return result;\n+};\n+```\n+\n+Note that `get` and `put` are implicitly bound to the Queue.  This means\n+that these functions can be vended to producers and consumers\n+separately, allowing fine grain control over which actors have the\n+capability to consume and produce.\n+\n+\n+### buffer\n+\n+The `buffer` method sends its input directly to its output, accumulating some\n+number of values in memory.  This is useful for reducing latency delays when\n+consuming iterations from a remote iterator.\n+\n+In this example, there is a remote array.  We want to log every value from that\n+remote array do not want to wait for all of them to accumulate in local memory.\n+\n+```javascript\n+Q(remoteArray)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+We also do not want to reenact this scenario:\n+\n+```\n+next()\n+wait one round trip time (typically 60ms)\n+log one value\n+next()\n+wait one round trip time\n+log one value\n+...\n+```\n+\n+To achive this, we add a buffer.\n+\n+```javascript\n+Q(remoteArray)\n+.buffer(100)\n+.forEach(function (value) {\n+    console.log(value);\n+})\n+.done();\n+```\n+\n+Thus, the replay would look more like:\n+\n+```\n+next() 100 times\n+wait one round trip time\n+log one value\n+next()\n+log one value\n+next()\n+...\n+```\n+\n+\n+### Asynchronous Semaphores\n+\n+A queue can be used as an asynchronous semaphore.  A railroad semaphore\n+is a sign or light that says whether it is safe for a train to proceed\n+down a certain track.  The far more pervasive traffic light by rights\n+could be called a semaphore, but motorists are still asleep at the\n+wheel.\n+\n+Semaphores in programming usually guard the usage of a limited resource,\n+like a pool of file descriptors or database connections.  Semaphores are\n+a generalization on mutual exclusion (mutex) where there can be more\n+than one resource in the pool.\n+\n+With an infinite promise queue, you would put all your resources in the\n+queue initially.  Competitors would `get` a promise for that resource\n+when one becomes available, and return that resource to the queue with\n+`put` when they are finished.\n+\n+```javascript\n+var pool = Queue();\n+\n+pool.put(resource1);\n+pool.put(resource2);\n+pool.put(resource3);\n+\n+pool.get().then(function (resource) {\n+    return useResource(resource)\n+    .finally(function () {\n+        pool.put(resource);\n+    });\n+})\n+```\n+\n+Q provides a `Semaphore` constructor that it uses internally for\n+scheduling.  Such resource pools abstractly represent the number of\n+additional jobs that may be performed concurrently, as represented by\n+the `maxInFlight` argument of `forEach`, `map`, `reduce`, and `buffer`.\n+As such, the resource itself is undefined, but the pool size is variable\n+and `undefined` implies that the resource is infinite.  Since modeling\n+an infinite promise queue in memory is not practicle, the `Semaphore`\n+constructor returns a queue that resolves any `get` request immediately,\n+and ignores all `put` requests.\n+\n+```javascript\n+var limited = Semaphore(3);\n+var infinite = Semaphore();\n+```\n+\n+\n+### Queue Iterator\n+\n+A Queue implements `iterate`, which returns an asynchronous iterator.\n+This allows us to very simply use an infinite promise queue as a\n+transport for iterations.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+\n+iterator.next()\n+.then(function (iteration) {\n+    console.log(iteration.value);\n+})\n+.done();\n+```\n+\n+In keeping with the Principle of Least-authority, the iterator only has\n+the authority to consume values from the queue.\n+\n+Note that since queues are iteratoble, we can use `forEach`, `map`,\n+`reduce`, and `buffer` as described above on promises for iterables and,\n+in fact, the latter three *return* promises for queue iterators.\n+\n+\n+### Queue Generator\n+\n+A queue generator provides a convenient interface for transporting\n+iterations to a queue iterator through a queue.  Queue generators are\n+not generator functions, but are analogous.  The generator has methods\n+`yield`, `return`, and `throw` that model the behavior of the eponymous\n+keyword inside a generator function.  `yield` produces an iteration with\n+a given `value` and an optional `index`.  `return` produces a terminal\n+iteration with an optional \"return\" value.  `throw` produces a rejected\n+promise for an iteration.\n+\n+```javascript\n+var queue = Queue();\n+var iterator = queue.iterate();\n+var generator = queue.generate();\n+\n+generator.yield(3);\n+generator.yield(2);\n+generator.yield(1);\n+generator.return(\"Go!\");\n+```\n+\n+The `forEach` method of a promise for an iterable works with queue\n+iterators in the same way it would with a generator iterator, even to\n+the point of treating the return value as the resolution of the\n+completion promise.\n+\n+```javascript\n+Q(iterator).forEach(function (countDown) {\n+    console.log(countDown);\n+})\n+.then(function (go) {\n+    console.log(go);\n+})\n+```\n+\n+\n+### Pipes\n+\n+One of the fundamental scheduling mechanisms of Unix is a pipe.  A pipe\n+is a finite buffer of kernel memory shared by two processes.  If the\n+producer fills the buffer faster than the consumer drains it, this is a\n+signal to the operating system that the consumer must be put to sleep\n+until an attempt to write to that buffer is guaranteed to succeed.\n+\n+This library provides an analogous pipe for internal scheduling\n+purposes.  It is very unlikely that you will need to use it directly\n+since it is an implementation detail of `forEach`, `map`, `reduce`, and\n+`buffer`.\n+\n+A pipe contains a scheduling semaphore of a particular size (`undefined`\n+again means unlimited) that determines the number of concurrent jobs\n+that may be undertaken between taking a value from the input and placing\n+a result in the output.  The pipe *does* presume a one to one\n+correspondence between values taken from input and placed in output.\n+\n+The pipe consists of an `input` queue, an `output` queue, and an\n+internal scheduling queue.  The user provides an iterable for the true\n+input source, and the pipe promises not to counsume more than\n+`maxInFlight` values from that source more than the values than values",
        "path": "README.md",
        "position": null,
        "original_position": 653,
        "commit_id": "9fed6c9bfac3a2f82b98f6b6e210fb3cc3da428e",
        "original_commit_id": "90f7a68b8a5017c965512dbaa0bd79ce9119d790",
        "user": {
            "login": "aaylward",
            "id": 846647,
            "node_id": "MDQ6VXNlcjg0NjY0Nw==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/846647?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/aaylward",
            "html_url": "https://github.com/aaylward",
            "followers_url": "https://api.github.com/users/aaylward/followers",
            "following_url": "https://api.github.com/users/aaylward/following{/other_user}",
            "gists_url": "https://api.github.com/users/aaylward/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/aaylward/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/aaylward/subscriptions",
            "organizations_url": "https://api.github.com/users/aaylward/orgs",
            "repos_url": "https://api.github.com/users/aaylward/repos",
            "events_url": "https://api.github.com/users/aaylward/events{/privacy}",
            "received_events_url": "https://api.github.com/users/aaylward/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Much improved!\n",
        "created_at": "2013-07-26T01:59:34Z",
        "updated_at": "2013-07-26T21:25:53Z",
        "html_url": "https://github.com/kriskowal/q/pull/351#discussion_r5414646",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/351",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/5414646"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/351#discussion_r5414646"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/351"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342498",
        "pull_request_review_id": null,
        "id": 6342498,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDI0OTg=",
        "diff_hunk": "@@ -0,0 +1,25 @@\n+var Q = require('../q');\n+\n+function log() {\n+    console.log.apply(console, arguments);\n+}\n+\n+Q('----------- tic 1 -----------').then(log).done(); // next tic\n+Q().thenResolve('----------- tic 2 -----------').then(log).done(); // in 2 tics\n+Q().thenResolve().thenResolve('----------- tic 3 -----------').then(log).done(); // in 3 tics\n+\n+\n+Q(1).then(log).done(); //logs '1'\n+\n+Q().thenResolve(2).then(log).done(); //logs '2'\n+\n+Q(5).then(Q.fbind(log, 3, 4)).done(); //logs '3 4 5'\n+\n+Q().thenResolve(log).fapply([6, 7, 8]).done(); //logs '6 7 8'\n+\n+Q(9).then(Q.fcall(log, 10, 11)).done(); //logs '10 11' (no 9)",
        "path": "examples/simpleCalls.js",
        "position": 20,
        "original_position": 20,
        "commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "original_commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is a bad example, as you are passing a promise to `then`, which you should never do.\n",
        "created_at": "2013-09-13T07:04:08Z",
        "updated_at": "2013-09-13T07:04:08Z",
        "html_url": "https://github.com/kriskowal/q/pull/388#discussion_r6342498",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/388",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342498"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/388#discussion_r6342498"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/388"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342504",
        "pull_request_review_id": null,
        "id": 6342504,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDI1MDQ=",
        "diff_hunk": "@@ -0,0 +1,25 @@\n+var Q = require('../q');\n+\n+function log() {\n+    console.log.apply(console, arguments);\n+}\n+\n+Q('----------- tic 1 -----------').then(log).done(); // next tic\n+Q().thenResolve('----------- tic 2 -----------').then(log).done(); // in 2 tics\n+Q().thenResolve().thenResolve('----------- tic 3 -----------').then(log).done(); // in 3 tics\n+\n+\n+Q(1).then(log).done(); //logs '1'\n+\n+Q().thenResolve(2).then(log).done(); //logs '2'\n+\n+Q(5).then(Q.fbind(log, 3, 4)).done(); //logs '3 4 5'\n+\n+Q().thenResolve(log).fapply([6, 7, 8]).done(); //logs '6 7 8'",
        "path": "examples/simpleCalls.js",
        "position": 18,
        "original_position": 18,
        "commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "original_commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Any reason to do `Q().thenResolve(log)` instead of `Q(log)`?\n",
        "created_at": "2013-09-13T07:04:41Z",
        "updated_at": "2013-09-13T07:04:41Z",
        "html_url": "https://github.com/kriskowal/q/pull/388#discussion_r6342504",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/388",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342504"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/388#discussion_r6342504"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/388"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342581",
        "pull_request_review_id": null,
        "id": 6342581,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDI1ODE=",
        "diff_hunk": "@@ -0,0 +1,25 @@\n+var Q = require('../q');\n+\n+function log() {\n+    console.log.apply(console, arguments);\n+}\n+\n+Q('----------- tic 1 -----------').then(log).done(); // next tic\n+Q().thenResolve('----------- tic 2 -----------').then(log).done(); // in 2 tics\n+Q().thenResolve().thenResolve('----------- tic 3 -----------').then(log).done(); // in 3 tics\n+\n+\n+Q(1).then(log).done(); //logs '1'\n+\n+Q().thenResolve(2).then(log).done(); //logs '2'\n+\n+Q(5).then(Q.fbind(log, 3, 4)).done(); //logs '3 4 5'\n+\n+Q().thenResolve(log).fapply([6, 7, 8]).done(); //logs '6 7 8'",
        "path": "examples/simpleCalls.js",
        "position": 18,
        "original_position": 18,
        "commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "original_commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "user": {
            "login": "dtudury",
            "id": 878029,
            "node_id": "MDQ6VXNlcjg3ODAyOQ==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/878029?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dtudury",
            "html_url": "https://github.com/dtudury",
            "followers_url": "https://api.github.com/users/dtudury/followers",
            "following_url": "https://api.github.com/users/dtudury/following{/other_user}",
            "gists_url": "https://api.github.com/users/dtudury/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/dtudury/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/dtudury/subscriptions",
            "organizations_url": "https://api.github.com/users/dtudury/orgs",
            "repos_url": "https://api.github.com/users/dtudury/repos",
            "events_url": "https://api.github.com/users/dtudury/events{/privacy}",
            "received_events_url": "https://api.github.com/users/dtudury/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "while I was working out how Q functioned I somehow cultivated the belief that Q(log) was calling log rather than passing it.  (after reading your question and a quick test I've discovered that was a superstition)\n\nno good reason\n",
        "created_at": "2013-09-13T07:13:01Z",
        "updated_at": "2013-09-13T07:13:01Z",
        "html_url": "https://github.com/kriskowal/q/pull/388#discussion_r6342581",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/388",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342581"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/388#discussion_r6342581"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/388"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342601",
        "pull_request_review_id": null,
        "id": 6342601,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDI2MDE=",
        "diff_hunk": "@@ -0,0 +1,25 @@\n+var Q = require('../q');\n+\n+function log() {\n+    console.log.apply(console, arguments);\n+}\n+\n+Q('----------- tic 1 -----------').then(log).done(); // next tic\n+Q().thenResolve('----------- tic 2 -----------').then(log).done(); // in 2 tics\n+Q().thenResolve().thenResolve('----------- tic 3 -----------').then(log).done(); // in 3 tics\n+\n+\n+Q(1).then(log).done(); //logs '1'\n+\n+Q().thenResolve(2).then(log).done(); //logs '2'\n+\n+Q(5).then(Q.fbind(log, 3, 4)).done(); //logs '3 4 5'\n+\n+Q().thenResolve(log).fapply([6, 7, 8]).done(); //logs '6 7 8'\n+\n+Q(9).then(Q.fcall(log, 10, 11)).done(); //logs '10 11' (no 9)",
        "path": "examples/simpleCalls.js",
        "position": 20,
        "original_position": 20,
        "commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "original_commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "user": {
            "login": "dtudury",
            "id": 878029,
            "node_id": "MDQ6VXNlcjg3ODAyOQ==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/878029?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dtudury",
            "html_url": "https://github.com/dtudury",
            "followers_url": "https://api.github.com/users/dtudury/followers",
            "following_url": "https://api.github.com/users/dtudury/following{/other_user}",
            "gists_url": "https://api.github.com/users/dtudury/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/dtudury/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/dtudury/subscriptions",
            "organizations_url": "https://api.github.com/users/dtudury/orgs",
            "repos_url": "https://api.github.com/users/dtudury/repos",
            "events_url": "https://api.github.com/users/dtudury/events{/privacy}",
            "received_events_url": "https://api.github.com/users/dtudury/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "sorry, which line? or all lines? (your comment is showing up as covering most of the commit.\n",
        "created_at": "2013-09-13T07:15:30Z",
        "updated_at": "2013-09-13T07:15:30Z",
        "html_url": "https://github.com/kriskowal/q/pull/388#discussion_r6342601",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/388",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342601"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/388#discussion_r6342601"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/388"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342613",
        "pull_request_review_id": null,
        "id": 6342613,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDI2MTM=",
        "diff_hunk": "@@ -0,0 +1,25 @@\n+var Q = require('../q');\n+\n+function log() {\n+    console.log.apply(console, arguments);\n+}\n+\n+Q('----------- tic 1 -----------').then(log).done(); // next tic\n+Q().thenResolve('----------- tic 2 -----------').then(log).done(); // in 2 tics\n+Q().thenResolve().thenResolve('----------- tic 3 -----------').then(log).done(); // in 3 tics\n+\n+\n+Q(1).then(log).done(); //logs '1'\n+\n+Q().thenResolve(2).then(log).done(); //logs '2'\n+\n+Q(5).then(Q.fbind(log, 3, 4)).done(); //logs '3 4 5'\n+\n+Q().thenResolve(log).fapply([6, 7, 8]).done(); //logs '6 7 8'\n+\n+Q(9).then(Q.fcall(log, 10, 11)).done(); //logs '10 11' (no 9)",
        "path": "examples/simpleCalls.js",
        "position": 20,
        "original_position": 20,
        "commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "original_commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "user": {
            "login": "dtudury",
            "id": 878029,
            "node_id": "MDQ6VXNlcjg3ODAyOQ==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/878029?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dtudury",
            "html_url": "https://github.com/dtudury",
            "followers_url": "https://api.github.com/users/dtudury/followers",
            "following_url": "https://api.github.com/users/dtudury/following{/other_user}",
            "gists_url": "https://api.github.com/users/dtudury/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/dtudury/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/dtudury/subscriptions",
            "organizations_url": "https://api.github.com/users/dtudury/orgs",
            "repos_url": "https://api.github.com/users/dtudury/repos",
            "events_url": "https://api.github.com/users/dtudury/events{/privacy}",
            "received_events_url": "https://api.github.com/users/dtudury/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "sorry, was in a bad view (or needed to refresh, or something), can see now\n",
        "created_at": "2013-09-13T07:16:51Z",
        "updated_at": "2013-09-13T07:16:51Z",
        "html_url": "https://github.com/kriskowal/q/pull/388#discussion_r6342613",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/388",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342613"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/388#discussion_r6342613"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/388"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342773",
        "pull_request_review_id": null,
        "id": 6342773,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDI3NzM=",
        "diff_hunk": "@@ -0,0 +1,25 @@\n+var Q = require('../q');\n+\n+function log() {\n+    console.log.apply(console, arguments);\n+}\n+\n+Q('----------- tic 1 -----------').then(log).done(); // next tic\n+Q().thenResolve('----------- tic 2 -----------').then(log).done(); // in 2 tics\n+Q().thenResolve().thenResolve('----------- tic 3 -----------').then(log).done(); // in 3 tics\n+\n+\n+Q(1).then(log).done(); //logs '1'\n+\n+Q().thenResolve(2).then(log).done(); //logs '2'\n+\n+Q(5).then(Q.fbind(log, 3, 4)).done(); //logs '3 4 5'\n+\n+Q().thenResolve(log).fapply([6, 7, 8]).done(); //logs '6 7 8'\n+\n+Q(9).then(Q.fcall(log, 10, 11)).done(); //logs '10 11' (no 9)",
        "path": "examples/simpleCalls.js",
        "position": 20,
        "original_position": 20,
        "commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "original_commit_id": "6ed5d63ffbce3136fa55b48df5c73e9df21caf75",
        "user": {
            "login": "dtudury",
            "id": 878029,
            "node_id": "MDQ6VXNlcjg3ODAyOQ==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/878029?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dtudury",
            "html_url": "https://github.com/dtudury",
            "followers_url": "https://api.github.com/users/dtudury/followers",
            "following_url": "https://api.github.com/users/dtudury/following{/other_user}",
            "gists_url": "https://api.github.com/users/dtudury/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/dtudury/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/dtudury/subscriptions",
            "organizations_url": "https://api.github.com/users/dtudury/orgs",
            "repos_url": "https://api.github.com/users/dtudury/repos",
            "events_url": "https://api.github.com/users/dtudury/events{/privacy}",
            "received_events_url": "https://api.github.com/users/dtudury/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "so really the example for fcall is `Q.fcall(log, 10, 11).done();` or `Q(log).fcall(10, 11).done();`\n",
        "created_at": "2013-09-13T07:34:35Z",
        "updated_at": "2013-09-13T07:34:35Z",
        "html_url": "https://github.com/kriskowal/q/pull/388#discussion_r6342773",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/388",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6342773"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/388#discussion_r6342773"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/388"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6505720",
        "pull_request_review_id": null,
        "id": 6505720,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU3MjA=",
        "diff_hunk": "@@ -484,7 +483,7 @@ Q.resolve = Q;\n  * Performs a task in a future turn of the event loop.\n  * @param {Function} task\n  */\n-Q.nextTick = nextTick;\n+Q.nextTick = deprecate(nextTick, \"nextTick\", \"asap\");",
        "path": "q.js",
        "position": null,
        "original_position": 17,
        "commit_id": "f12ccd838809da57a6d3d9f631679cac9410d877",
        "original_commit_id": "cd62696afb36a390ba928976d86abc826feb4419",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Maybe the last parameter should be \"the 'asap' npm package\" instead.\n",
        "created_at": "2013-09-22T17:05:49Z",
        "updated_at": "2013-09-22T17:55:54Z",
        "html_url": "https://github.com/kriskowal/q/pull/397#discussion_r6505720",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/397",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6505720"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/397#discussion_r6505720"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/397"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6505836",
        "pull_request_review_id": null,
        "id": 6505836,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU4MzY=",
        "diff_hunk": "@@ -484,7 +483,7 @@ Q.resolve = Q;\n  * Performs a task in a future turn of the event loop.\n  * @param {Function} task\n  */\n-Q.nextTick = nextTick;\n+Q.nextTick = deprecate(nextTick, \"nextTick\", \"asap\");",
        "path": "q.js",
        "position": null,
        "original_position": 17,
        "commit_id": "f12ccd838809da57a6d3d9f631679cac9410d877",
        "original_commit_id": "cd62696afb36a390ba928976d86abc826feb4419",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Good call.\n",
        "created_at": "2013-09-22T17:53:40Z",
        "updated_at": "2013-09-22T17:55:54Z",
        "html_url": "https://github.com/kriskowal/q/pull/397#discussion_r6505836",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/397",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6505836"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/397#discussion_r6505836"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/397"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504461",
        "pull_request_review_id": null,
        "id": 6504461,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDQ0NjE=",
        "diff_hunk": "@@ -462,44 +469,34 @@ function Promise(descriptor, fallback, inspect) {\n \n     var promise = object_create(Promise.prototype);\n \n-    promise.promiseDispatch = function (resolve, op, args) {\n-        var result;\n-        try {\n-            if (descriptor[op]) {\n-                result = descriptor[op].apply(promise, args);\n-            } else {\n-                result = fallback.call(promise, op, args);\n+    var handler = {\n+        dispatch: function (resolve, op, operands) {\n+            var result;\n+            try {\n+                if (descriptor[op]) {\n+                    result = descriptor[op].apply(promise, operands);\n+                } else {\n+                    result = fallback.call(promise, op, operands);\n+                }\n+            } catch (exception) {\n+                result = reject(exception);\n             }\n-        } catch (exception) {\n-            result = reject(exception);\n-        }\n-        if (resolve) {\n-            resolve(result);\n-        }\n+            if (resolve) {\n+                resolve(result);\n+            }\n+        },\n+        inspect: inspect\n     };\n \n-    promise.inspect = inspect;\n-\n-    // XXX deprecated `valueOf` and `exception` support\n-    if (inspect) {\n-        var inspected = inspect();\n-        if (inspected.state === \"rejected\") {\n-            promise.exception = inspected.reason;\n-        }\n-\n-        promise.valueOf = deprecate(function () {\n-            var inspected = inspect();\n-            if (inspected.state === \"pending\" ||\n-                inspected.state === \"rejected\") {\n-                return promise;\n-            }\n-            return inspected.value;\n-        });\n-    }\n+    handlers.set(promise, handler);\n \n     return promise;\n }\n \n+Promise.prototype.inspect = function () {",
        "path": "q.js",
        "position": 277,
        "original_position": 240,
        "commit_id": "0a087e601000f96123d510167dd91151aa7e4109",
        "original_commit_id": "a24636975097cf4aab11f4eb46101dc12768dbf3",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nice, this will reduce memory usage a decent bit.\n",
        "created_at": "2013-09-22T05:24:32Z",
        "updated_at": "2013-09-22T17:56:25Z",
        "html_url": "https://github.com/kriskowal/q/pull/395#discussion_r6504461",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/395",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504461"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/395#discussion_r6504461"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/395"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504464",
        "pull_request_review_id": null,
        "id": 6504464,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDQ0NjQ=",
        "diff_hunk": "@@ -656,11 +651,11 @@ function isPromiseAlike(object) {\n  */\n Q.isPending = isPending;\n function isPending(object) {\n-    return isPromise(object) && object.inspect().state === \"pending\";\n+    return Q(object).isPending();",
        "path": "q.js",
        "position": 318,
        "original_position": 281,
        "commit_id": "0a087e601000f96123d510167dd91151aa7e4109",
        "original_commit_id": "a24636975097cf4aab11f4eb46101dc12768dbf3",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Hmm, this is an interesting semantic change.\n",
        "created_at": "2013-09-22T05:25:33Z",
        "updated_at": "2013-09-22T17:56:25Z",
        "html_url": "https://github.com/kriskowal/q/pull/395#discussion_r6504464",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/395",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504464"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/395#discussion_r6504464"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/395"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504473",
        "pull_request_review_id": null,
        "id": 6504473,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDQ0NzM=",
        "diff_hunk": "@@ -656,11 +651,11 @@ function isPromiseAlike(object) {\n  */\n Q.isPending = isPending;\n function isPending(object) {\n-    return isPromise(object) && object.inspect().state === \"pending\";\n+    return Q(object).isPending();",
        "path": "q.js",
        "position": 318,
        "original_position": 281,
        "commit_id": "0a087e601000f96123d510167dd91151aa7e4109",
        "original_commit_id": "a24636975097cf4aab11f4eb46101dc12768dbf3",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is the change observable? I figured it was an optimization to check `isPromise` first. I suppose that thenables would be a gray area, especially if we introduce the `accepted` state.\n",
        "created_at": "2013-09-22T05:31:09Z",
        "updated_at": "2013-09-22T17:56:25Z",
        "html_url": "https://github.com/kriskowal/q/pull/395#discussion_r6504473",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/395",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504473"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/395#discussion_r6504473"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/395"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504476",
        "pull_request_review_id": null,
        "id": 6504476,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDQ0NzY=",
        "diff_hunk": "@@ -656,11 +651,11 @@ function isPromiseAlike(object) {\n  */\n Q.isPending = isPending;\n function isPending(object) {\n-    return isPromise(object) && object.inspect().state === \"pending\";\n+    return Q(object).isPending();",
        "path": "q.js",
        "position": 318,
        "original_position": 281,
        "commit_id": "0a087e601000f96123d510167dd91151aa7e4109",
        "original_commit_id": "a24636975097cf4aab11f4eb46101dc12768dbf3",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Now that I think about the truth table, I suppose it is not observable. I was under the mistaken impression that this changed the result of `Q.isPending(5)`.\n",
        "created_at": "2013-09-22T05:35:36Z",
        "updated_at": "2013-09-22T17:56:25Z",
        "html_url": "https://github.com/kriskowal/q/pull/395#discussion_r6504476",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/395",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6504476"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/395#discussion_r6504476"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/395"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082567",
        "pull_request_review_id": null,
        "id": 7082567,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1Njc=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));",
        "path": "README.md",
        "position": null,
        "original_position": 39,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The above \"fs\" should be \"q-io/fs\", and the readSync here should be read.\n",
        "created_at": "2013-10-20T15:18:25Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082567",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082567"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082567"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082569",
        "pull_request_review_id": null,
        "id": 7082569,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1Njk=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to",
        "path": "README.md",
        "position": null,
        "original_position": 52,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\"without generators, <ins>by using just promises,</ins> we can at least...\"\n",
        "created_at": "2013-10-20T15:19:05Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082569",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082569"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082569"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082573",
        "pull_request_review_id": null,
        "id": 7082573,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1NzM=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            var result = JSON.parse(result);",
        "path": "README.md",
        "position": null,
        "original_position": 74,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Aren't try blocks block scoped? Or is it just catch blocks? Probably best to move the variable declaration outside, in any case.\n",
        "created_at": "2013-10-20T15:20:22Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082573",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082573"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082573"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082577",
        "pull_request_review_id": null,
        "id": 7082577,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1Nzc=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.",
        "path": "README.md",
        "position": null,
        "original_position": 64,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\"It also must take care not to accidentally call the subscriber inside the `try` block, since this would trap subscriber errors instead of those related to the JSON-reading process.\"\n",
        "created_at": "2013-10-20T15:21:34Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082577",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082577"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082577"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082578",
        "pull_request_review_id": null,
        "id": 7082578,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1Nzg=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            var result = JSON.parse(result);\n+        } catch (error) {\n+            return nodeback(error);\n+        }\n+        nodeback(null, result);\n     });\n+}\n+```\n+\n+The second reward for using promises is that they implicitly guarantee\n+that interfaces you create will be strictly asynchronous.  Oliver\n+Steele\u2019s [Minimizing Code Paths in Asynchronous Code][Steele] succinctly\n+captures the issue and Isaac Schlueter\u2019s more recent treatise,\n+[Designing APIs for Asynchrony][Isaac], reframed the edict as \u201cDo Not\n+Release Zalgo\u201d.\n+\n+[Steele]: http://osteele.com/posts/2008/04/minimizing-code-paths-in-asychronous-code\n+[Isaac]: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n+\n+If you are using `Q`, you can cast any promise, even a jQuery promise,",
        "path": "README.md",
        "position": null,
        "original_position": 93,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I wouldn't code-ize Q here.\n",
        "created_at": "2013-10-20T15:22:10Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082578",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082578"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082578"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082581",
        "pull_request_review_id": null,
        "id": 7082581,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1ODE=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            var result = JSON.parse(result);\n+        } catch (error) {\n+            return nodeback(error);\n+        }\n+        nodeback(null, result);\n     });\n+}\n+```\n+\n+The second reward for using promises is that they implicitly guarantee\n+that interfaces you create will be strictly asynchronous.  Oliver\n+Steele\u2019s [Minimizing Code Paths in Asynchronous Code][Steele] succinctly\n+captures the issue and Isaac Schlueter\u2019s more recent treatise,\n+[Designing APIs for Asynchrony][Isaac], reframed the edict as \u201cDo Not\n+Release Zalgo\u201d.\n+\n+[Steele]: http://osteele.com/posts/2008/04/minimizing-code-paths-in-asychronous-code\n+[Isaac]: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n+\n+If you are using `Q`, you can cast any promise, even a jQuery promise,",
        "path": "README.md",
        "position": null,
        "original_position": 93,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I personally would wrap jQuery \"promise\" in scare quotes, but failing that, a link to our wiki page might be a good thing to insert at this point.\n",
        "created_at": "2013-10-20T15:22:43Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082581",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082581"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082581"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082589",
        "pull_request_review_id": null,
        "id": 7082589,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1ODk=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            var result = JSON.parse(result);\n+        } catch (error) {\n+            return nodeback(error);\n+        }\n+        nodeback(null, result);\n     });\n+}\n+```\n+\n+The second reward for using promises is that they implicitly guarantee\n+that interfaces you create will be strictly asynchronous.  Oliver\n+Steele\u2019s [Minimizing Code Paths in Asynchronous Code][Steele] succinctly\n+captures the issue and Isaac Schlueter\u2019s more recent treatise,\n+[Designing APIs for Asynchrony][Isaac], reframed the edict as \u201cDo Not\n+Release Zalgo\u201d.\n+\n+[Steele]: http://osteele.com/posts/2008/04/minimizing-code-paths-in-asychronous-code\n+[Isaac]: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n+\n+If you are using `Q`, you can cast any promise, even a jQuery promise,\n+into a well-behaved promise that will not call event handlers until your\n+event is done.\n+\n+```javascript\n+var x = 10;\n+var part1 = Q($.ajax(...))\n+.then(function () {\n+});\n+var part2 = Q($.ajax(...))\n+.then(function () {\n });\n+expect(x).toBe(10); // still, no matter what, even with caching\n ```\n \n-With a promise library, you can flatten the pyramid.\n+Using promises also preserves the signatures of synchronous functions.\n+Continuation passing style is an \u201cinversion of control\u201d, where you pass\n+control forward instead of getting it back when a function returns.\n+Promises [un-invert][IOC] the inversion, cleanly separating the input\n+arguments from control flow arguments.  This simplifies the use and\n+creation of API\u2019s, particularly variadic, rest and spread arguments.\n+\n+[IOC]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\n+\n+Many designs with promises merely extend existing contracts, like",
        "path": "README.md",
        "position": null,
        "original_position": 118,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think this example is unfortunately too confusing to use in the intro. As a first-time user, I would come away assuming that Q provided some kind of Stream. I am not sure if there is a better example to make your point. Perhaps Qx, with a link? That could work:\n\n``` js\nreturn Qx.map(array, function (path) {\n  return $.ajax(path);\n})\n.then(function (responses) {\n  // all requests done, and all responses available\n});\n```\n",
        "created_at": "2013-10-20T15:26:25Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082589",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082589"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082589"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082594",
        "pull_request_review_id": null,
        "id": 7082594,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1OTQ=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            var result = JSON.parse(result);\n+        } catch (error) {\n+            return nodeback(error);\n+        }\n+        nodeback(null, result);\n     });\n+}\n+```\n+\n+The second reward for using promises is that they implicitly guarantee\n+that interfaces you create will be strictly asynchronous.  Oliver\n+Steele\u2019s [Minimizing Code Paths in Asynchronous Code][Steele] succinctly\n+captures the issue and Isaac Schlueter\u2019s more recent treatise,\n+[Designing APIs for Asynchrony][Isaac], reframed the edict as \u201cDo Not\n+Release Zalgo\u201d.\n+\n+[Steele]: http://osteele.com/posts/2008/04/minimizing-code-paths-in-asychronous-code\n+[Isaac]: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n+\n+If you are using `Q`, you can cast any promise, even a jQuery promise,\n+into a well-behaved promise that will not call event handlers until your\n+event is done.\n+\n+```javascript\n+var x = 10;\n+var part1 = Q($.ajax(...))\n+.then(function () {\n+});\n+var part2 = Q($.ajax(...))\n+.then(function () {\n });\n+expect(x).toBe(10); // still, no matter what, even with caching\n ```\n \n-With a promise library, you can flatten the pyramid.\n+Using promises also preserves the signatures of synchronous functions.\n+Continuation passing style is an \u201cinversion of control\u201d, where you pass\n+control forward instead of getting it back when a function returns.\n+Promises [un-invert][IOC] the inversion, cleanly separating the input\n+arguments from control flow arguments.  This simplifies the use and\n+creation of API\u2019s, particularly variadic, rest and spread arguments.\n+\n+[IOC]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\n+\n+Many designs with promises merely extend existing contracts, like\n+`forEach`, with only the distinction that functions return promises.\n \n ```javascript\n-Q.fcall(promisedStep1)\n-.then(promisedStep2)\n-.then(promisedStep3)\n-.then(promisedStep4)\n-.then(function (value4) {\n-    // Do something with value4\n+new Stream(iterable)\n+.forEach(function (path,) {\n+    return $.ajax(path);\n })\n-.catch(function (error) {\n-    // Handle any error from all above steps\n+.then(function () {\n+    // all requests done\n })\n-.done();\n ```\n \n-With this approach, you also get implicit error propagation, just like `try`,\n-`catch`, and `finally`.  An error in `promisedStep1` will flow all the way to\n-the `catch` function, where it\u2019s caught and handled.  (Here `promisedStepN` is\n-a version of `stepN` that returns a promise.)\n+Another point to using promises is that multiple subscribers can wait",
        "path": "README.md",
        "position": null,
        "original_position": 144,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Editorial: <del>Another point to</del> <ins>A final benefit of</ins>\n",
        "created_at": "2013-10-20T15:27:11Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082594",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082594"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082594"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082596",
        "pull_request_review_id": null,
        "id": 7082596,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODI1OTY=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises",
        "path": "README.md",
        "position": null,
        "original_position": 26,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I would link \"combining promises and generators\" to @ForbesLindesay's slides at http://pag.forbeslindesay.co.uk/.\n",
        "created_at": "2013-10-20T15:28:09Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7082596",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7082596"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7082596"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7083084",
        "pull_request_review_id": null,
        "id": 7083084,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODMwODQ=",
        "diff_hunk": "@@ -13,54 +13,130 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  This happy ideal is possible by combining promises\n+and generators.\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n+var FS = require(\"fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.readSync(path, \"utf-8\"));\n+});\n+```\n+\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at **any time at all** with\n+threads.\n+\n+But even without generators, we can at least get exceptions to\n+implicitly propagate asynchronously with very little noise.\n+\n+```javascript\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            var result = JSON.parse(result);",
        "path": "README.md",
        "position": null,
        "original_position": 74,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "e5f76bce91a364ad1a010d768ab1adbeb0398bef",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "They are hoisted, but I\u2019ll move for clarity. Only `catch` is scoped.\n",
        "created_at": "2013-10-20T18:05:03Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7083084",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7083084"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7083084"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7083215",
        "pull_request_review_id": null,
        "id": 7083215,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODMyMTU=",
        "diff_hunk": "@@ -13,55 +13,141 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  Forbes Lindesay illustrates the way to this happy\n+ideal in his presentation, [\u201cPromises and Generators\u201d][PAG].\n+\n+[PAG]: http://pag.forbeslindesay.co.uk/\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n-    });\n+var FS = require(\"q-io/fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.read(path));\n });\n ```\n \n-With a promise library, you can flatten the pyramid.\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at *any time at all* with threads.\n+\n+But even without generators, by using promises, we can at least get\n+exceptions to implicitly propagate asynchronously with very little\n+noise.\n \n ```javascript\n-Q.fcall(promisedStep1)\n-.then(promisedStep2)\n-.then(promisedStep3)\n-.then(promisedStep4)\n-.then(function (value4) {\n-    // Do something with value4\n-})\n-.catch(function (error) {\n-    // Handle any error from all above steps\n-})\n-.done();\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.  It\n+also must take care not to call the subscriber inside the try block,\n+since this would catch errors thrown by `nodeback` and throw them back\n+at `nodeback` in the catch block.",
        "path": "README.md",
        "position": null,
        "original_position": 82,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "a6fad45738bcb2ea981ab51ceb7dfe576b8e4fe1",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\"In general, writing callback-based functions that handle errors robustly is difficult and error-prone, and even if you do it right, rather verbose.\"\n",
        "created_at": "2013-10-20T18:58:11Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7083215",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7083215"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7083215"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7083223",
        "pull_request_review_id": null,
        "id": 7083223,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwODMyMjM=",
        "diff_hunk": "@@ -13,55 +13,141 @@ proxy for a [remote object][Q-Connection] to overcome latency.\n \n [Q-Connection]: https://github.com/kriskowal/q-connection\n \n-On the first pass, promises can mitigate the \u201c[Pyramid of\n-Doom][POD]\u201d: the situation where code marches to the right faster\n-than it marches forward.\n+There are many reasons to use promises.  The first reward is that\n+promises implicitly propagate errors and values downstream.  Consider\n+this synchronous solution to reading a file and parsing its content.\n \n-[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonSync = function (path) {\n+    return JSON.parse(FS.readSync(path, \"utf-8\"));\n+};\n+```\n+\n+The asynchronous analog would ideally look and behave exactly the same\n+*except* it would explicitly mark anywhere it might yield to other\n+tasks, which is to say, between calling and returning, and reading and\n+parsing.  Control flow constructs like `return`, `throw`, `if`, `for`,\n+`break` and `continue` would still work, except asynchronously.\n+Exceptions, such as the `SyntaxError` that `JSON.parse` might throw,\n+would propagate through the promise graph just as they do through the\n+synchronous stack.  Forbes Lindesay illustrates the way to this happy\n+ideal in his presentation, [\u201cPromises and Generators\u201d][PAG].\n+\n+[PAG]: http://pag.forbeslindesay.co.uk/\n \n ```javascript\n-step1(function (value1) {\n-    step2(value1, function(value2) {\n-        step3(value2, function(value3) {\n-            step4(value3, function(value4) {\n-                // Do something with value4\n-            });\n-        });\n-    });\n+var FS = require(\"q-io/fs\");\n+var readJsonPromise = Q.async(function *(path) {\n+    return JSON.parse(yield FS.read(path));\n });\n ```\n \n-With a promise library, you can flatten the pyramid.\n+Explicitly marking yield points makes it possible for users to take\n+advantage of the invariant that they can arrange for a consistent\n+internal state between events, and be guaranteed that only they can\n+alter their state during an event.  Fibers and threads do not provide\n+this guarantee, so programmers must work with a heightened sense of\n+caution\u2014their work may be interrupted and their state modified at any\n+function call boundary for fibers, or at *any time at all* with threads.\n+\n+But even without generators, by using promises, we can at least get\n+exceptions to implicitly propagate asynchronously with very little\n+noise.\n \n ```javascript\n-Q.fcall(promisedStep1)\n-.then(promisedStep2)\n-.then(promisedStep3)\n-.then(promisedStep4)\n-.then(function (value4) {\n-    // Do something with value4\n-})\n-.catch(function (error) {\n-    // Handle any error from all above steps\n-})\n-.done();\n+var FS = require(\"q-io/fs\");\n+function readJsonPromise(path) {\n+    return FS.read(path).then(JSON.parse);\n+}\n+```\n+\n+Compare these solutions to the equivalent using bare callbacks.  It must\n+use an explicit `try` block to `catch` the exception that `JSON.parse`\n+might throw and must manually forward all errors to the subscriber.  It\n+also must take care not to call the subscriber inside the try block,\n+since this would catch errors thrown by `nodeback` and throw them back\n+at `nodeback` in the catch block.\n+\n+```javascript\n+var FS = require(\"fs\");\n+var readJsonWithNodebacks = function (path, nodeback) {\n+    FS.readFile(path, \"utf-8\", function (error, content) {\n+        var result;\n+        if (error) {\n+            return nodeback(error);\n+        }\n+        try {\n+            result = JSON.parse(result);\n+        } catch (error) {\n+            return nodeback(error);\n+        }\n+        nodeback(null, result);\n+    });\n+}\n ```\n \n-With this approach, you also get implicit error propagation, just like `try`,\n-`catch`, and `finally`.  An error in `promisedStep1` will flow all the way to\n-the `catch` function, where it\u2019s caught and handled.  (Here `promisedStepN` is\n-a version of `stepN` that returns a promise.)\n+The second reward for using promises is that they implicitly guarantee\n+that interfaces you create will be strictly asynchronous.  Oliver\n+Steele\u2019s [Minimizing Code Paths in Asynchronous Code][Steele] succinctly\n+captures the issue and Isaac Schlueter\u2019s more recent treatise,\n+[Designing APIs for Asynchrony][Isaac], reframed the edict as \u201cDo Not\n+Release Zalgo\u201d.\n+\n+[Steele]: http://osteele.com/posts/2008/04/minimizing-code-paths-in-asychronous-code\n+[Isaac]: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n+\n+If you are using Q, you can cast any promise, even a [jQuery\n+\u201cpromise\u201d][jQuery], into a well-behaved promise that will not call event\n+handlers until your event is done.\n+\n+[jQuery]: https://github.com/kriskowal/q/wiki/Coming-from-jQuery\n+\n+```javascript\n+var x = 10;\n+var part1 = Q($.ajax(...))\n+.then(function () {\n+    x = 20;\n+});\n+var part2 = Q($.ajax(...))\n+.then(function () {\n+    x = 30;\n+});\n+expect(x).toBe(10); // still, no matter what\n+```\n \n-The callback approach is called an \u201cinversion of control\u201d.\n-A function that accepts a callback instead of a return value\n-is saying, \u201cDon\u2019t call me, I\u2019ll call you.\u201d.  Promises\n-[un-invert][IOC] the inversion, cleanly separating the input\n-arguments from control flow arguments.  This simplifies the\n-use and creation of API\u2019s, particularly variadic,\n-rest and spread arguments.\n+Using promises also preserves the signatures of synchronous functions.\n+Continuation passing style is an \u201cinversion of control\u201d, where you pass\n+control forward instead of getting it back when a function returns.\n+Promises [un-invert][IOC] the inversion, cleanly separating the input\n+arguments from control flow arguments.  This simplifies the use and\n+creation of API\u2019s, particularly variadic, rest and spread arguments.\n \n [IOC]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\n \n+Another point to using promises is that multiple subscribers can wait\n+for a result, and new subscribers can be added even after the result has\n+been published.  Consider how much simpler it would be to wait for\n+DOMContentLoaded with promises.  No need to worry about whether the\n+event has already passed.\n+\n+```javascript\n+return document.ready.then(setup);\n+```\n+\n+Promises go on to be a useful primitive for capturing the \u201ccausal graph\u201d\n+of an asynchronous program, providing \u201clong traces\u201d that capture the\n+stacks from all the events that led to an exception.  Promises are also\n+useful as proxies for objects in other processes, piplining messages\n+over any inter-process message channel.\n+\n+The point of promises is that they have scouted the way ahead and will\n+help you avoid set-backs and dead-ends, from simple problems like\n+synchronizing local work, to more [advanced problems like distributed",
        "path": "README.md",
        "position": null,
        "original_position": 169,
        "commit_id": "e6d2adaa51d23f2cfa7c1e65abca507209461f82",
        "original_commit_id": "a6fad45738bcb2ea981ab51ceb7dfe576b8e4fe1",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'd move the start of the link to \"like\" instead of \"advanced\"\n",
        "created_at": "2013-10-20T19:00:15Z",
        "updated_at": "2013-10-20T19:02:13Z",
        "html_url": "https://github.com/kriskowal/q/pull/414#discussion_r7083223",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/414",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7083223"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/414#discussion_r7083223"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591532",
        "pull_request_review_id": null,
        "id": 6591532,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE1MzI=",
        "diff_hunk": "@@ -11,6 +11,7 @@\n     <script src=\"lib/jasmine-promise.js\"></script>\n \n     <!-- include source files here... -->\n+    <script src=\"../node_modules/asap/asap.js\"></script>",
        "path": "spec/q-spec.html",
        "position": null,
        "original_position": 4,
        "commit_id": "d165f68ad8c4cfe3d611e8aabffab8e727b33b72",
        "original_commit_id": "a0f4b96d9f946b8d03a0452c2cea178cc83d56e9",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't think we want to do this.\n",
        "created_at": "2013-09-26T02:10:41Z",
        "updated_at": "2013-10-30T19:58:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/394#discussion_r6591532",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/394",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591532"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/394#discussion_r6591532"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/394"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591540",
        "pull_request_review_id": null,
        "id": 6591540,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE1NDA=",
        "diff_hunk": "@@ -1,5 +1,29 @@\n <!-- vim:ts=4:sts=4:sw=4:et:tw=60 -->\n \n+## 1.0.0 :warning: BACKWARD INCOMPATIBILITY\n+\n+ - 1.0! :cake:\n+ - :warning: As of `1.0`, Q will require ECMAScript 5. Using `es5-shim`,\n+   nor even `es5-sham`, is not sufficient to make legacy engines\n+   compatible because Q requires a WeakMap shim that depends on ES5\n+   properties.  The `0.9` version train will continue to support older\n+   browsers and will attempt to provide a forward-compatible feature set\n+   if you take care to eliminate all deprecation warnings before\n+   migrating.\n+ - :warning: Release management has changed.  The source for this\n+   library is `q.js` and is only suitable for consumption as a CommonJS,\n+   ergo Node.js, module.  Releases are created using `grunt`, including\n+   `release/q.js`, which is suitable for use as a `<script>`, and\n+   `release/amd/q.js`, which is suitable for use as an AMD module.  All\n+   new versions will be published to S3.\n+ - :warning: Q now depends on a WeakMap shim.  If you are using an AMD\n+   loader, you will need to bring in https://github.com/drses/weak-map.\n+   If you are using Q as a `<script>`, this has been embedded in the\n+   release.  If you are using Q in Node.js, the dependency is taken care\n+   of by NPM.",
        "path": "CHANGES.md",
        "position": null,
        "original_position": 23,
        "commit_id": "d165f68ad8c4cfe3d611e8aabffab8e727b33b72",
        "original_commit_id": "a0f4b96d9f946b8d03a0452c2cea178cc83d56e9",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nit: \"npm\" is never capitalized.\n",
        "created_at": "2013-09-26T02:11:25Z",
        "updated_at": "2013-10-30T19:58:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/394#discussion_r6591540",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/394",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591540"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/394#discussion_r6591540"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/394"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591573",
        "pull_request_review_id": null,
        "id": 6591573,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE1NzM=",
        "diff_hunk": "@@ -1,5 +1,29 @@\n <!-- vim:ts=4:sts=4:sw=4:et:tw=60 -->\n \n+## 1.0.0 :warning: BACKWARD INCOMPATIBILITY\n+\n+ - 1.0! :cake:\n+ - :warning: As of `1.0`, Q will require ECMAScript 5. Using `es5-shim`,\n+   nor even `es5-sham`, is not sufficient to make legacy engines\n+   compatible because Q requires a WeakMap shim that depends on ES5\n+   properties.  The `0.9` version train will continue to support older\n+   browsers and will attempt to provide a forward-compatible feature set\n+   if you take care to eliminate all deprecation warnings before\n+   migrating.\n+ - :warning: Release management has changed.  The source for this\n+   library is `q.js` and is only suitable for consumption as a CommonJS,\n+   ergo Node.js, module.  Releases are created using `grunt`, including\n+   `release/q.js`, which is suitable for use as a `<script>`, and\n+   `release/amd/q.js`, which is suitable for use as an AMD module.  All\n+   new versions will be published to S3.\n+ - :warning: Q now depends on a WeakMap shim.  If you are using an AMD\n+   loader, you will need to bring in https://github.com/drses/weak-map.\n+   If you are using Q as a `<script>`, this has been embedded in the\n+   release.  If you are using Q in Node.js, the dependency is taken care\n+   of by NPM.",
        "path": "CHANGES.md",
        "position": null,
        "original_position": 23,
        "commit_id": "d165f68ad8c4cfe3d611e8aabffab8e727b33b72",
        "original_commit_id": "a0f4b96d9f946b8d03a0452c2cea178cc83d56e9",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I can\u2019t abide this. If we did everything izs said, many commas would be in very different places.\n",
        "created_at": "2013-09-26T02:14:43Z",
        "updated_at": "2013-10-30T19:58:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/394#discussion_r6591573",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/394",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591573"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/394#discussion_r6591573"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/394"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591581",
        "pull_request_review_id": null,
        "id": 6591581,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE1ODE=",
        "diff_hunk": "@@ -11,6 +11,7 @@\n     <script src=\"lib/jasmine-promise.js\"></script>\n \n     <!-- include source files here... -->\n+    <script src=\"../node_modules/asap/asap.js\"></script>",
        "path": "spec/q-spec.html",
        "position": null,
        "original_position": 4,
        "commit_id": "d165f68ad8c4cfe3d611e8aabffab8e727b33b72",
        "original_commit_id": "a0f4b96d9f946b8d03a0452c2cea178cc83d56e9",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I\u2019m probably going to entrain `montagejs/mr` as a dependency so we can do our browser testing with Node.js-packaged-modules.\n",
        "created_at": "2013-09-26T02:15:34Z",
        "updated_at": "2013-10-30T19:58:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/394#discussion_r6591581",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/394",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591581"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/394#discussion_r6591581"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/394"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591603",
        "pull_request_review_id": null,
        "id": 6591603,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE2MDM=",
        "diff_hunk": "@@ -11,6 +11,7 @@\n     <script src=\"lib/jasmine-promise.js\"></script>\n \n     <!-- include source files here... -->\n+    <script src=\"../node_modules/asap/asap.js\"></script>",
        "path": "spec/q-spec.html",
        "position": null,
        "original_position": 4,
        "commit_id": "d165f68ad8c4cfe3d611e8aabffab8e727b33b72",
        "original_commit_id": "a0f4b96d9f946b8d03a0452c2cea178cc83d56e9",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "That sounds lovely. The only alternative I had in mind was switching to Mocha and [zuul](https://github.com/shtylman/zuul).\n",
        "created_at": "2013-09-26T02:17:03Z",
        "updated_at": "2013-10-30T19:58:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/394#discussion_r6591603",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/394",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/6591603"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/394#discussion_r6591603"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/394"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7325693",
        "pull_request_review_id": null,
        "id": 7325693,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDczMjU2OTM=",
        "diff_hunk": "@@ -1123,6 +1123,12 @@ function ThenableHandler(thenable) {\n     this.became = null;\n }\n \n+ThenableHandler.prototype.state = \"thenable\";",
        "path": "q.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "b31abd721f1c2c36c4851d3bfa4f8ca0569a4139",
        "original_commit_id": "b31abd721f1c2c36c4851d3bfa4f8ca0569a4139",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This could be \"pending\", in which case promise.isPending() would be true for thenables at least until they are thened.\n",
        "created_at": "2013-10-30T20:47:46Z",
        "updated_at": "2013-10-30T20:47:46Z",
        "html_url": "https://github.com/kriskowal/q/pull/426#discussion_r7325693",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/426",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7325693"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/426#discussion_r7325693"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/426"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879443",
        "pull_request_review_id": null,
        "id": 7879443,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk0NDM=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+",
        "path": "examples/chain.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "So `task` is a function that returns a promise for a function that should be called when resolved.\n",
        "created_at": "2013-11-24T18:05:21Z",
        "updated_at": "2013-11-24T18:05:21Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879443",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879443"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879443"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879444",
        "pull_request_review_id": null,
        "id": 7879444,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk0NDQ=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+\n+function task(i) {\n+    return function(deferred) {\n+        var delay = Math.floor(1000 * (Math.random() * 10) + 1);\n+        console.log(delay);\n+        setTimeout(function() {\n+            deferred.resolve(function() {\n+                console.log(i);\n+            });\n+        }, delay)",
        "path": "examples/chain.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Missing `return deferred.promise`.\n",
        "created_at": "2013-11-24T18:05:42Z",
        "updated_at": "2013-11-24T18:05:42Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879444",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879444"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879444"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879515",
        "pull_request_review_id": null,
        "id": 7879515,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk1MTU=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+\n+function task(i) {\n+    return function(deferred) {\n+        var delay = Math.floor(1000 * (Math.random() * 10) + 1);\n+        console.log(delay);\n+        setTimeout(function() {\n+            deferred.resolve(function() {\n+                console.log(i);\n+            });\n+        }, delay)",
        "path": "examples/chain.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "jouni-kantola",
            "id": 2670127,
            "node_id": "MDQ6VXNlcjI2NzAxMjc=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/2670127?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jouni-kantola",
            "html_url": "https://github.com/jouni-kantola",
            "followers_url": "https://api.github.com/users/jouni-kantola/followers",
            "following_url": "https://api.github.com/users/jouni-kantola/following{/other_user}",
            "gists_url": "https://api.github.com/users/jouni-kantola/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jouni-kantola/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jouni-kantola/subscriptions",
            "organizations_url": "https://api.github.com/users/jouni-kantola/orgs",
            "repos_url": "https://api.github.com/users/jouni-kantola/repos",
            "events_url": "https://api.github.com/users/jouni-kantola/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jouni-kantola/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The return deferred.promise statement is encapsulated in q.js;\nhttps://github.com/jouni-kantola/q/blob/chain/q.js#L1604-1606\n",
        "created_at": "2013-11-24T18:25:10Z",
        "updated_at": "2013-11-24T18:25:10Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879515",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879515"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879515"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879521",
        "pull_request_review_id": null,
        "id": 7879521,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk1MjE=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+",
        "path": "examples/chain.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "jouni-kantola",
            "id": 2670127,
            "node_id": "MDQ6VXNlcjI2NzAxMjc=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/2670127?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jouni-kantola",
            "html_url": "https://github.com/jouni-kantola",
            "followers_url": "https://api.github.com/users/jouni-kantola/followers",
            "following_url": "https://api.github.com/users/jouni-kantola/following{/other_user}",
            "gists_url": "https://api.github.com/users/jouni-kantola/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jouni-kantola/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jouni-kantola/subscriptions",
            "organizations_url": "https://api.github.com/users/jouni-kantola/orgs",
            "repos_url": "https://api.github.com/users/jouni-kantola/repos",
            "events_url": "https://api.github.com/users/jouni-kantola/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jouni-kantola/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Exactly, a task will either be resolved or rejected (and all tasks from the current). That is up to the user to decide. Like in my app, I'll use resolve even if an ajax call fails, since I want the rest of the promises to be handled.\n",
        "created_at": "2013-11-24T18:26:45Z",
        "updated_at": "2013-11-24T18:26:45Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879521",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879521"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879521"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879536",
        "pull_request_review_id": null,
        "id": 7879536,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk1MzY=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+\n+function task(i) {\n+    return function(deferred) {\n+        var delay = Math.floor(1000 * (Math.random() * 10) + 1);\n+        console.log(delay);\n+        setTimeout(function() {\n+            deferred.resolve(function() {\n+                console.log(i);\n+            });\n+        }, delay)",
        "path": "examples/chain.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I see. Would it not be simpler if a task just returned a promise?\n\n``` js\nfunction makeTask(i) {\n    return function task(previousResult) {\n        console.log(\"started\", i);\n        return Q.delay(Math.ceil(Math.random() * 1000 * 10))\n        .then(function () {\n            console.log(\"finished\", i);\n        })\n    };\n}\n```\n",
        "created_at": "2013-11-24T18:28:19Z",
        "updated_at": "2013-11-24T18:28:54Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879536",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879536"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879536"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879575",
        "pull_request_review_id": null,
        "id": 7879575,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk1NzU=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+",
        "path": "examples/chain.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Consider:\n\n``` js\nfunction makeAjaxTask(arg) {\n    function ajaxTask() {\n        return Q($.ajax(arg));\n    }\n}\n\nreturn [makeAjaxTask(arg1), makeAjaxTask(arg2), makeAjaxTask(arg3)]\n.reduce(function (results, task) {\n    return results.then(function (results) {\n        return task().then(function (result) {\n            results.push(result);\n            return results;\n        }, function (error) {\n            return results;\n        });\n    });\n}, Q([]))\n```\n\nWhich returns a promise for the results of each task.\n",
        "created_at": "2013-11-24T18:36:18Z",
        "updated_at": "2013-11-24T18:36:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879575",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879575"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879575"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879617",
        "pull_request_review_id": null,
        "id": 7879617,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc4Nzk2MTc=",
        "diff_hunk": "@@ -0,0 +1,17 @@\n+\"use strict\";\n+\n+var Q = require(\"../q\");\n+\n+function task(i) {\n+    return function(deferred) {\n+        var delay = Math.floor(1000 * (Math.random() * 10) + 1);\n+        console.log(delay);\n+        setTimeout(function() {\n+            deferred.resolve(function() {\n+                console.log(i);\n+            });\n+        }, delay)",
        "path": "examples/chain.js",
        "position": 13,
        "original_position": 13,
        "commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "original_commit_id": "edeb9c4ad2f672096d8ea164cd573cce1f4d92aa",
        "user": {
            "login": "jouni-kantola",
            "id": 2670127,
            "node_id": "MDQ6VXNlcjI2NzAxMjc=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/2670127?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jouni-kantola",
            "html_url": "https://github.com/jouni-kantola",
            "followers_url": "https://api.github.com/users/jouni-kantola/followers",
            "following_url": "https://api.github.com/users/jouni-kantola/following{/other_user}",
            "gists_url": "https://api.github.com/users/jouni-kantola/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jouni-kantola/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jouni-kantola/subscriptions",
            "organizations_url": "https://api.github.com/users/jouni-kantola/orgs",
            "repos_url": "https://api.github.com/users/jouni-kantola/repos",
            "events_url": "https://api.github.com/users/jouni-kantola/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jouni-kantola/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah, this is probably a more clear choice; then() is maybe more intuitive.\n",
        "created_at": "2013-11-24T18:46:33Z",
        "updated_at": "2013-11-24T18:46:33Z",
        "html_url": "https://github.com/kriskowal/q/pull/438#discussion_r7879617",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/438",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/7879617"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/438#discussion_r7879617"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/8007336",
        "pull_request_review_id": null,
        "id": 8007336,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgwMDczMzY=",
        "diff_hunk": "@@ -1161,9 +1167,8 @@ var trackUnhandledRejections = true;\n function displayUnhandledReasons() {\n     if (\n         !unhandledReasonsDisplayed &&",
        "path": "q.js",
        "position": null,
        "original_position": 27,
        "commit_id": "53be162283bdae7b7dee05b157021e9356d894d6",
        "original_commit_id": "a6dbb350e599a0ca5859e49be9631e90c4757a6d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "still need the `window` check so that this doesn\u2019t log in Node.js\n",
        "created_at": "2013-11-29T19:46:04Z",
        "updated_at": "2013-12-02T14:08:32Z",
        "html_url": "https://github.com/kriskowal/q/pull/441#discussion_r8007336",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/441",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/8007336"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/441#discussion_r8007336"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/441"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/8007353",
        "pull_request_review_id": null,
        "id": 8007353,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgwMDczNTM=",
        "diff_hunk": "@@ -1174,7 +1179,10 @@ function displayUnhandledReasons() {\n function logUnhandledReasons() {\n     for (var i = 0; i < unhandledReasons.length; i++) {\n         var reason = unhandledReasons[i];\n-        console.warn(\"Unhandled rejection reason:\", reason);",
        "path": "q.js",
        "position": 64,
        "original_position": 40,
        "commit_id": "53be162283bdae7b7dee05b157021e9356d894d6",
        "original_commit_id": "a6dbb350e599a0ca5859e49be9631e90c4757a6d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Please change to use the prevalent style throughout Q:\n\n``` js\nif (\n    line &&\n    line\n) {\n    line;\n}\n```\n",
        "created_at": "2013-11-29T19:47:17Z",
        "updated_at": "2013-12-02T14:08:32Z",
        "html_url": "https://github.com/kriskowal/q/pull/441#discussion_r8007353",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/441",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/8007353"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/441#discussion_r8007353"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/441"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/8505637",
        "pull_request_review_id": null,
        "id": 8505637,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg1MDU2Mzc=",
        "diff_hunk": "@@ -133,3 +133,18 @@ function nodeify(object, nodeback) {\n     return Q(object).nodeify(nodeback);\n }\n \n+/**\n+ * Takes a promise-returning function and returns a function that takes a\n+ * Node-style callback. This is useful if the user wants to nodeify a\n+ * promise-returning function but does not know the value of the nodeback.\n+ * @param thisArg The value of this provided for the call to fn\n+ * @param fn The promise-returning function to be converted\n+ */\n+NQ.nodeified = nodeified;\n+function nodeified(thisArg, fn) {\n+    return function () {\n+        var args = Array.prototype.slice.call(arguments, 0, -1);\n+        var nodeback = arguments[arguments.length - 1];\n+        fn.apply(thisArg, args).nodeify(nodeback);",
        "path": "node.js",
        "position": null,
        "original_position": 16,
        "commit_id": "e9efb3d1210f4b444c9573da46cff680a8a09688",
        "original_commit_id": "15188a4c1da81ed521e37ad2723bd3ed4d3b42bf",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Should return here.\n",
        "created_at": "2013-12-20T17:44:29Z",
        "updated_at": "2013-12-21T17:22:24Z",
        "html_url": "https://github.com/kriskowal/q/pull/451#discussion_r8505637",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/451",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/8505637"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/451#discussion_r8505637"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/451"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/9974139",
        "pull_request_review_id": null,
        "id": 9974139,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk5NzQxMzk=",
        "diff_hunk": "@@ -151,15 +151,22 @@ function captureLine() {\n }\n \n function deprecate(callback, name, alternative) {\n-    return function () {\n+    return function Q$deprecate() {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "e2ef3e815aa55813538c96aa8aa7b5561b1b06b4",
        "original_commit_id": "b04f8df1dbd339a570e7a3f75d4f5312d7660ee2",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I meant to reply. I feel like `Q_` would be nicer than `Q$`? No big deal though.\n",
        "created_at": "2014-02-23T02:57:50Z",
        "updated_at": "2014-02-23T07:10:39Z",
        "html_url": "https://github.com/kriskowal/q/pull/486#discussion_r9974139",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/486",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/9974139"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/486#discussion_r9974139"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/486"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/9974142",
        "pull_request_review_id": null,
        "id": 9974142,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk5NzQxNDI=",
        "diff_hunk": "@@ -151,15 +151,22 @@ function captureLine() {\n }\n \n function deprecate(callback, name, alternative) {\n-    return function () {\n+    return function Q$deprecate() {",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "e2ef3e815aa55813538c96aa8aa7b5561b1b06b4",
        "original_commit_id": "b04f8df1dbd339a570e7a3f75d4f5312d7660ee2",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It would. Can be done.\n",
        "created_at": "2014-02-23T03:00:04Z",
        "updated_at": "2014-02-23T07:10:39Z",
        "html_url": "https://github.com/kriskowal/q/pull/486#discussion_r9974142",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/486",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/9974142"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/486#discussion_r9974142"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/486"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24475946",
        "pull_request_review_id": null,
        "id": 24475946,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc1OTQ2",
        "diff_hunk": "@@ -91,6 +91,7 @@ var nextTick =(function () {\n     var flushing = false;\n     var requestTick = void 0;\n     var isNodeJS = false;\n+    var laterQueue = []; // queue for late tasks",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "In general, this approach to creating another priority tier is barely enough to work. I\u2019d much favor the approach of creating a task queue primitive that can be constructed in terms of the queue it uses to request flush. Such event queues could be stacked trivially. That would be a logical next step for asap, a make-asap(requestFlush).\n",
        "created_at": "2015-02-11T06:08:38Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24475946",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24475946"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24475946"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24475969",
        "pull_request_review_id": null,
        "id": 24475969,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc1OTY5",
        "diff_hunk": "@@ -1012,6 +1027,14 @@ function trackRejection(promise, reason) {\n     if (!trackUnhandledRejections) {\n         return;\n     }\n+    if(typeof process === \"object\" && typeof process.emit === \"function\"){\n+        Q.nextTick.runAfter(function(){\n+            if(array_indexOf(unhandledRejections, promise) !== -1){\n+                process.emit(\"unhandledRejection\", reason, promise);",
        "path": "q.js",
        "position": null,
        "original_position": 118,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I would prefer to just have optional Q method hooks for browser support, like Q.onerror, or support a delegate object with method hooks.\n",
        "created_at": "2015-02-11T06:10:03Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24475969",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24475969"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24475969"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24476063",
        "pull_request_review_id": null,
        "id": 24476063,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc2MDYz",
        "diff_hunk": "@@ -1012,6 +1027,14 @@ function trackRejection(promise, reason) {\n     if (!trackUnhandledRejections) {\n         return;\n     }\n+    if(typeof process === \"object\" && typeof process.emit === \"function\"){\n+        Q.nextTick.runAfter(function(){\n+            if(array_indexOf(unhandledRejections, promise) !== -1){\n+                process.emit(\"unhandledRejection\", reason, promise);",
        "path": "q.js",
        "position": null,
        "original_position": 118,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "benjamingr",
            "id": 1315533,
            "node_id": "MDQ6VXNlcjEzMTU1MzM=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/1315533?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/benjamingr",
            "html_url": "https://github.com/benjamingr",
            "followers_url": "https://api.github.com/users/benjamingr/followers",
            "following_url": "https://api.github.com/users/benjamingr/following{/other_user}",
            "gists_url": "https://api.github.com/users/benjamingr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/benjamingr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/benjamingr/subscriptions",
            "organizations_url": "https://api.github.com/users/benjamingr/orgs",
            "repos_url": "https://api.github.com/users/benjamingr/repos",
            "events_url": "https://api.github.com/users/benjamingr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/benjamingr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The `process` bits are part of the specification for node/io and work this way across promise libraries and soon native promises in io.js\n\nFiring events for browsers here is something we can definitely wait with - I asked @domenic if he wanted it and he said he did. I can leave it just like that if you'd like.\n",
        "created_at": "2015-02-11T06:14:36Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24476063",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24476063"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24476063"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24476138",
        "pull_request_review_id": null,
        "id": 24476138,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc2MTM4",
        "diff_hunk": "@@ -91,6 +91,7 @@ var nextTick =(function () {\n     var flushing = false;\n     var requestTick = void 0;\n     var isNodeJS = false;\n+    var laterQueue = []; // queue for late tasks",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "benjamingr",
            "id": 1315533,
            "node_id": "MDQ6VXNlcjEzMTU1MzM=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/1315533?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/benjamingr",
            "html_url": "https://github.com/benjamingr",
            "followers_url": "https://api.github.com/users/benjamingr/followers",
            "following_url": "https://api.github.com/users/benjamingr/following{/other_user}",
            "gists_url": "https://api.github.com/users/benjamingr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/benjamingr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/benjamingr/subscriptions",
            "organizations_url": "https://api.github.com/users/benjamingr/orgs",
            "repos_url": "https://api.github.com/users/benjamingr/repos",
            "events_url": "https://api.github.com/users/benjamingr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/benjamingr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "In general I agree that two tiers are something that isn't enough - however in this particular case only the library calls `runAfter`.\n\nWhile I agree a heap implementing a priority queue or some kind of chain of responsibility pattern is preferred I didn't want to bloat Q with too much code and wanted to add a single extra tier in the simplest way possible. I used an array instead of a linked list since it is much faster and less code to write.\n",
        "created_at": "2015-02-11T06:17:33Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24476138",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24476138"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24476138"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24476151",
        "pull_request_review_id": null,
        "id": 24476151,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc2MTUx",
        "diff_hunk": "@@ -1012,6 +1027,14 @@ function trackRejection(promise, reason) {\n     if (!trackUnhandledRejections) {\n         return;\n     }\n+    if(typeof process === \"object\" && typeof process.emit === \"function\"){\n+        Q.nextTick.runAfter(function(){\n+            if(array_indexOf(unhandledRejections, promise) !== -1){\n+                process.emit(\"unhandledRejection\", reason, promise);",
        "path": "q.js",
        "position": null,
        "original_position": 118,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I\u2019ll stand with @domenic. Progress on this would be good.\n",
        "created_at": "2015-02-11T06:17:58Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24476151",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24476151"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24476151"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24477631",
        "pull_request_review_id": null,
        "id": 24477631,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc3NjMx",
        "diff_hunk": "@@ -91,6 +91,7 @@ var nextTick =(function () {\n     var flushing = false;\n     var requestTick = void 0;\n     var isNodeJS = false;\n+    var laterQueue = []; // queue for late tasks",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You are right that minimum viable is appropriate for this. My intuition is that layering queues would compose better and be more maintainable in the long run. I am content to make v2 the long run branch though, if there\u2019s a pragmatic solution here.\n",
        "created_at": "2015-02-11T07:20:47Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24477631",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24477631"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24477631"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24477677",
        "pull_request_review_id": null,
        "id": 24477677,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc3Njc3",
        "diff_hunk": "@@ -91,6 +91,7 @@ var nextTick =(function () {\n     var flushing = false;\n     var requestTick = void 0;\n     var isNodeJS = false;\n+    var laterQueue = []; // queue for late tasks",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "benjamingr",
            "id": 1315533,
            "node_id": "MDQ6VXNlcjEzMTU1MzM=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/1315533?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/benjamingr",
            "html_url": "https://github.com/benjamingr",
            "followers_url": "https://api.github.com/users/benjamingr/followers",
            "following_url": "https://api.github.com/users/benjamingr/following{/other_user}",
            "gists_url": "https://api.github.com/users/benjamingr/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/benjamingr/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/benjamingr/subscriptions",
            "organizations_url": "https://api.github.com/users/benjamingr/orgs",
            "repos_url": "https://api.github.com/users/benjamingr/repos",
            "events_url": "https://api.github.com/users/benjamingr/events{/privacy}",
            "received_events_url": "https://api.github.com/users/benjamingr/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah, this should definitely look differently in v2 :)\n\nI'll try to amend this PR Friday to fire the browser hooks - let me know if\nthere is anything else you'd like me to change. If you feel like\nimplementing this yourself differently then you're of course also welcome.\n\nOn Wed, Feb 11, 2015 at 7:20 AM, Kris Kowal notifications@github.com\nwrote:\n\n> In q.js https://github.com/kriskowal/q/pull/643#discussion_r24477631:\n> \n> > @@ -91,6 +91,7 @@ var nextTick =(function () {\n> >      var flushing = false;\n> >      var requestTick = void 0;\n> >      var isNodeJS = false;\n> > -    var laterQueue = []; // queue for late tasks\n> \n> You are right that minimum viable is appropriate for this. My intuition is\n> that layering queues would compose better and be more maintainable in the\n> long run. I am content to make v2 the long run branch though, if there\u2019s a\n> pragmatic solution here.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kriskowal/q/pull/643/files#r24477631.\n",
        "created_at": "2015-02-11T07:22:51Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24477677",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24477677"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24477677"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24477749",
        "pull_request_review_id": null,
        "id": 24477749,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDc3NzQ5",
        "diff_hunk": "@@ -91,6 +91,7 @@ var nextTick =(function () {\n     var flushing = false;\n     var requestTick = void 0;\n     var isNodeJS = false;\n+    var laterQueue = []; // queue for late tasks",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "d61eb13a6c14ef00b44f5876264ee1c30ae166c4",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah, I don\u2019t have much discretionary time anymore, and some of the hubris is wearing off too. Glad to accept your help on this one. Maybe I\u2019ll get a chance to merge/test/release this on the weekend.\n",
        "created_at": "2015-02-11T07:25:45Z",
        "updated_at": "2015-02-13T14:08:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24477749",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24477749"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24477749"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24730413",
        "pull_request_review_id": null,
        "id": 24730413,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NzMwNDEz",
        "diff_hunk": "@@ -203,7 +212,16 @@ var nextTick =(function () {\n             setTimeout(flush, 0);\n         };\n     }\n-\n+    // runs a task after all other tasks have been run\n+    // this is useful for unhandled rejection tracking that needs to happen\n+    // after all `then`d tasks have been run.\n+    nextTick.runAfter = function(task){",
        "path": "q.js",
        "position": 98,
        "original_position": 98,
        "commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "original_commit_id": "86cb5c6327271edd670d999979ce5b8d6c7657d7",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is sometimes called an idle event, and it\u2019s fine as long as it does not effect a resume. I\u2019ll take it as-is.\n",
        "created_at": "2015-02-16T03:19:19Z",
        "updated_at": "2015-02-16T03:19:19Z",
        "html_url": "https://github.com/kriskowal/q/pull/643#discussion_r24730413",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/643",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24730413"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/643#discussion_r24730413"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/643"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24794700",
        "pull_request_review_id": null,
        "id": 24794700,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0Nzk0NzAw",
        "diff_hunk": "@@ -1540,6 +1540,82 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected with an array\n+ * containing the reasons of all rejected promises.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a promise rejected with an array with the reasons of all rejected\n+ * promises.\n+ */\n+Q.firstResolved = firstResolved;\n+\n+function firstResolved(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {",
        "path": "q.js",
        "position": 16,
        "original_position": 16,
        "commit_id": "e208ac062a94cbc533327ee86a74fa57790a146d",
        "original_commit_id": "e208ac062a94cbc533327ee86a74fa57790a146d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Check first and just return Q.resolve();\n",
        "created_at": "2015-02-17T05:48:50Z",
        "updated_at": "2015-02-17T05:48:50Z",
        "html_url": "https://github.com/kriskowal/q/pull/646#discussion_r24794700",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/646",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24794700"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/646#discussion_r24794700"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/646"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24794719",
        "pull_request_review_id": null,
        "id": 24794719,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0Nzk0NzE5",
        "diff_hunk": "@@ -1540,6 +1540,82 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected with an array\n+ * containing the reasons of all rejected promises.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a promise rejected with an array with the reasons of all rejected\n+ * promises.\n+ */\n+Q.firstResolved = firstResolved;\n+\n+function firstResolved(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {\n+        deferred.resolve();\n+    }\n+\n+    for (var i = 0; i < promises.length; i++) {\n+        var promise = promises[i];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise === undefined || promise === null) {\n+            continue;\n+        }\n+\n+        if (!isPromiseAlike(promise)) {\n+            // It's a value, not a promise\n+            var value = promise;\n+            deferred.resolve(value);\n+            return deferred.promise;\n+        }",
        "path": "q.js",
        "position": 34,
        "original_position": 34,
        "commit_id": "e208ac062a94cbc533327ee86a74fa57790a146d",
        "original_commit_id": "e208ac062a94cbc533327ee86a74fa57790a146d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Above block is superfluous. Q.resolve(promise) will coerce promises, promise-alikes, and non-promises into a promise. Apply liberally to all input promises and consistency is solved.\n",
        "created_at": "2015-02-17T05:49:46Z",
        "updated_at": "2015-02-17T05:49:54Z",
        "html_url": "https://github.com/kriskowal/q/pull/646#discussion_r24794719",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/646",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24794719"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/646#discussion_r24794719"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/646"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24794813",
        "pull_request_review_id": null,
        "id": 24794813,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0Nzk0ODEz",
        "diff_hunk": "@@ -1540,6 +1540,82 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected with an array\n+ * containing the reasons of all rejected promises.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a promise rejected with an array with the reasons of all rejected\n+ * promises.\n+ */\n+Q.firstResolved = firstResolved;\n+\n+function firstResolved(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {\n+        deferred.resolve();\n+    }\n+\n+    for (var i = 0; i < promises.length; i++) {\n+        var promise = promises[i];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise === undefined || promise === null) {\n+            continue;\n+        }\n+\n+        if (!isPromiseAlike(promise)) {\n+            // It's a value, not a promise\n+            var value = promise;\n+            deferred.resolve(value);\n+            return deferred.promise;\n+        }\n+\n+        (function(promise, i) {\n+            promise.then(function(result) {\n+                deferred.resolve(result);\n+            }, function() {\n+                // Ignore. Later, with allSettled, we take care of rejecting.\n+            }, function(progress) {\n+                deferred.notify({\n+                    index: i,\n+                    value: progress\n+                });\n+            });\n+        })(promise, i);\n+    }\n+\n+    var allRejected = [];\n+\n+    Q.allSettled(promises)\n+      .then(function(allSettled) {\n+        for (var i = 0; i < allSettled.length; i++) {\n+            var snapshot = allSettled[i];\n+            if (!snapshot || !snapshot.state) {\n+              continue;\n+            }\n+            if (snapshot.state === 'fulfilled') {\n+              return Q.reject();\n+            } else if (snapshot.state === 'rejected') {\n+              allRejected.push(Q.reject(snapshot.reason));\n+            }\n+        }\n+\n+        return Q.resolve(allRejected);\n+      })\n+      .then(function(result) {\n+          deferred.reject(allRejected);\n+      });",
        "path": "q.js",
        "position": 70,
        "original_position": 70,
        "commit_id": "e208ac062a94cbc533327ee86a74fa57790a146d",
        "original_commit_id": "e208ac062a94cbc533327ee86a74fa57790a146d",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It is sufficient to reject with a new error as in Tobie\u2019s example, rather than attempt to collect errors. Q.reject must be called with a new Error instance. I would favor mimicking the countDown code of Q.all over using Q.allSettled.\n",
        "created_at": "2015-02-17T05:52:50Z",
        "updated_at": "2015-02-17T05:52:50Z",
        "html_url": "https://github.com/kriskowal/q/pull/646#discussion_r24794813",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/646",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24794813"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/646#discussion_r24794813"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/646"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828279",
        "pull_request_review_id": null,
        "id": 24828279,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0ODI4Mjc5",
        "diff_hunk": "@@ -1540,6 +1540,56 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    var deferred = Q.defer();",
        "path": "q.js",
        "position": null,
        "original_position": 13,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "9df7841107f051da9dd42d275772f7f9125ba856",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This can be done after the if block to avoid allocating a deferred.\n",
        "created_at": "2015-02-17T16:25:51Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r24828279",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828279"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r24828279"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828387",
        "pull_request_review_id": null,
        "id": 24828387,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0ODI4Mzg3",
        "diff_hunk": "@@ -1540,6 +1540,56 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var promisesCount = promises.length;\n+    for (var i = 0; i < promises.length; i++) {\n+        var promise = promises[i];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise === undefined || promise === null) {\n+            promisesCount--;\n+            continue;\n+        }\n+\n+        (function(promise, i) {\n+            Q.resolve(promise).then(function(result) {\n+                deferred.resolve(result);\n+            }, function(reason) {\n+                promisesCount--;\n+                if(promisesCount === 0) {\n+                    deferred.reject(new Error(\"No promises resolved successfully.\"));\n+                }\n+            }, function(progress) {\n+                deferred.notify({\n+                    index: i,\n+                    value: progress\n+                });\n+            });\n+        })(promise, i);\n+    }",
        "path": "q.js",
        "position": null,
        "original_position": 44,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "9df7841107f051da9dd42d275772f7f9125ba856",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You can use array_reduce as above in Q.all, especially since you need a closure to capture the index regardless.\n",
        "created_at": "2015-02-17T16:26:57Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r24828387",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828387"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r24828387"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828413",
        "pull_request_review_id": null,
        "id": 24828413,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0ODI4NDEz",
        "diff_hunk": "@@ -1540,6 +1540,56 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var promisesCount = promises.length;\n+    for (var i = 0; i < promises.length; i++) {",
        "path": "q.js",
        "position": null,
        "original_position": 19,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "9df7841107f051da9dd42d275772f7f9125ba856",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Please spell out index.\n",
        "created_at": "2015-02-17T16:27:14Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r24828413",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828413"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r24828413"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828600",
        "pull_request_review_id": null,
        "id": 24828600,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0ODI4NjAw",
        "diff_hunk": "@@ -1540,6 +1540,56 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var promisesCount = promises.length;\n+    for (var i = 0; i < promises.length; i++) {\n+        var promise = promises[i];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise === undefined || promise === null) {\n+            promisesCount--;\n+            continue;\n+        }\n+\n+        (function(promise, i) {\n+            Q.resolve(promise).then(function(result) {\n+                deferred.resolve(result);\n+            }, function(reason) {\n+                promisesCount--;\n+                if(promisesCount === 0) {\n+                    deferred.reject(new Error(\"No promises resolved successfully.\"));",
        "path": "q.js",
        "position": null,
        "original_position": 35,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "9df7841107f051da9dd42d275772f7f9125ba856",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This might be more expressive as \"Can't get fulfillment value from any promise, all promises were rejected.\"\n",
        "created_at": "2015-02-17T16:29:15Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r24828600",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828600"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r24828600"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828714",
        "pull_request_review_id": null,
        "id": 24828714,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0ODI4NzE0",
        "diff_hunk": "@@ -1540,6 +1540,56 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    var deferred = Q.defer();\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var promisesCount = promises.length;\n+    for (var i = 0; i < promises.length; i++) {\n+        var promise = promises[i];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise === undefined || promise === null) {\n+            promisesCount--;\n+            continue;\n+        }\n+\n+        (function(promise, i) {\n+            Q.resolve(promise).then(function(result) {",
        "path": "q.js",
        "position": null,
        "original_position": 30,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "9df7841107f051da9dd42d275772f7f9125ba856",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Note that Q\u2019s internals do not generally bind to the Q object directly. Most of the internal functions are available as free variables in scope. See `when(promise, function (result) {` as in Q.all.\n",
        "created_at": "2015-02-17T16:30:29Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r24828714",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/24828714"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r24828714"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125256",
        "pull_request_review_id": null,
        "id": 25125256,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTI1MjU2",
        "diff_hunk": "@@ -1540,6 +1540,60 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var deferred = Q.defer();\n+    var promisesCount = 0;\n+    array_reduce(promises, function(prev, current, index) {\n+        var promise = promises[index];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */",
        "path": "q.js",
        "position": null,
        "original_position": 23,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "ab6d512bd0aa2c5f4cd0231d152b9a77ccf1cecf",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "// comment would suffice here.\nBut I think I disagree. Even `undefined` is a valid, and in fact common, promise resolution. Let\u2019s not filter any value.\n",
        "created_at": "2015-02-21T20:06:40Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r25125256",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125256"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r25125256"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125259",
        "pull_request_review_id": null,
        "id": 25125259,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTI1MjU5",
        "diff_hunk": "@@ -1540,6 +1540,60 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var deferred = Q.defer();\n+    var promisesCount = 0;\n+    array_reduce(promises, function(prev, current, index) {\n+        var promise = promises[index];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise !== undefined && promise !== null) {\n+            promisesCount++;\n+        } else {\n+          return;",
        "path": "q.js",
        "position": null,
        "original_position": 27,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "ab6d512bd0aa2c5f4cd0231d152b9a77ccf1cecf",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Four space indent please.\n",
        "created_at": "2015-02-21T20:06:45Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r25125259",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125259"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r25125259"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125260",
        "pull_request_review_id": null,
        "id": 25125260,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTI1MjYw",
        "diff_hunk": "@@ -1540,6 +1540,60 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var deferred = Q.defer();\n+    var promisesCount = 0;\n+    array_reduce(promises, function(prev, current, index) {\n+        var promise = promises[index];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise !== undefined && promise !== null) {\n+            promisesCount++;\n+        } else {\n+          return;\n+        }\n+\n+        (function(promise, index) {",
        "path": "q.js",
        "position": null,
        "original_position": 30,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "ab6d512bd0aa2c5f4cd0231d152b9a77ccf1cecf",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This IIFE is no longer necessary.\n",
        "created_at": "2015-02-21T20:06:49Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r25125260",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125260"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r25125260"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125264",
        "pull_request_review_id": null,
        "id": 25125264,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTI1MjY0",
        "diff_hunk": "@@ -1540,6 +1540,60 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var deferred = Q.defer();\n+    var promisesCount = 0;\n+    array_reduce(promises, function(prev, current, index) {\n+        var promise = promises[index];\n+        /* Let's define that false could be a value to resolve with, so let's not\n+         * if(!promise)\n+         */\n+        if (promise !== undefined && promise !== null) {\n+            promisesCount++;\n+        } else {\n+          return;\n+        }\n+\n+        (function(promise, index) {\n+            when(promise, fulfilled, rejected, progress);\n+            function fulfilled(result) {\n+                deferred.resolve(result);\n+            };\n+            function rejected(reason) {\n+                promisesCount--;\n+                if(promisesCount === 0) {",
        "path": "q.js",
        "position": null,
        "original_position": 37,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "ab6d512bd0aa2c5f4cd0231d152b9a77ccf1cecf",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Space between if and paren.\n",
        "created_at": "2015-02-21T20:07:16Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r25125264",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125264"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r25125264"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125274",
        "pull_request_review_id": null,
        "id": 25125274,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MTI1Mjc0",
        "diff_hunk": "@@ -1540,6 +1540,60 @@ Promise.prototype.all = function () {\n };\n \n /**\n+ * Returns the first resolved promise of an array. Prior rejected promises are\n+ * ignored.  Rejects only if all promises are rejected.\n+ * @param {Array*} an array containing values or promises for values\n+ * @returns a promise fulfilled with the value of the first resolved promise,\n+ * or a rejected promise if all promises are rejected.\n+ */\n+Q.any = any;\n+\n+function any(promises) {\n+    if (promises.length === 0) {\n+        return Q.resolve();\n+    }\n+\n+    var deferred = Q.defer();\n+    var promisesCount = 0;",
        "path": "q.js",
        "position": null,
        "original_position": 18,
        "commit_id": "475850dee58e0995c2e12766815ca02f1e218abb",
        "original_commit_id": "ab6d512bd0aa2c5f4cd0231d152b9a77ccf1cecf",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think I may follow up by naming promisesCount and countDown above to pendingCount in both cases.\n",
        "created_at": "2015-02-21T20:08:28Z",
        "updated_at": "2015-02-21T21:40:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/649#discussion_r25125274",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/649",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/25125274"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/649#discussion_r25125274"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/649"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26900089",
        "pull_request_review_id": null,
        "id": 26900089,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTAwMDg5",
        "diff_hunk": "@@ -1502,6 +1506,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (!isArray(arguments[0]) || arguments.length !== 1) {\n+            throw Error(\"All must be passed an array of promises.\");",
        "path": "q.js",
        "position": null,
        "original_position": 25,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "arikon",
            "id": 75247,
            "node_id": "MDQ6VXNlcjc1MjQ3",
            "avatar_url": "https://avatars0.githubusercontent.com/u/75247?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/arikon",
            "html_url": "https://github.com/arikon",
            "followers_url": "https://api.github.com/users/arikon/followers",
            "following_url": "https://api.github.com/users/arikon/following{/other_user}",
            "gists_url": "https://api.github.com/users/arikon/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/arikon/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/arikon/subscriptions",
            "organizations_url": "https://api.github.com/users/arikon/orgs",
            "repos_url": "https://api.github.com/users/arikon/repos",
            "events_url": "https://api.github.com/users/arikon/events{/privacy}",
            "received_events_url": "https://api.github.com/users/arikon/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Would you mind replacing `All` with `all()` to make the error message more clear?\n",
        "created_at": "2015-03-22T05:41:08Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26900089",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26900089"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26900089"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26900095",
        "pull_request_review_id": null,
        "id": 26900095,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTAwMDk1",
        "diff_hunk": "@@ -1096,6 +1096,15 @@ describe(\"propagation\", function () {\n });\n \n describe(\"all\", function () {\n+    it(\"rejects if not passed an array\", function() {\n+        var promise = Q.defer(),\n+            willBeRejected = Q.all(promise);",
        "path": "spec/q-spec.js",
        "position": 6,
        "original_position": 6,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "arikon",
            "id": 75247,
            "node_id": "MDQ6VXNlcjc1MjQ3",
            "avatar_url": "https://avatars0.githubusercontent.com/u/75247?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/arikon",
            "html_url": "https://github.com/arikon",
            "followers_url": "https://api.github.com/users/arikon/followers",
            "following_url": "https://api.github.com/users/arikon/following{/other_user}",
            "gists_url": "https://api.github.com/users/arikon/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/arikon/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/arikon/subscriptions",
            "organizations_url": "https://api.github.com/users/arikon/orgs",
            "repos_url": "https://api.github.com/users/arikon/repos",
            "events_url": "https://api.github.com/users/arikon/events{/privacy}",
            "received_events_url": "https://api.github.com/users/arikon/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We should also check the case with many arguments to `all()`\n",
        "created_at": "2015-03-22T05:42:03Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26900095",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26900095"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26900095"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903661",
        "pull_request_review_id": null,
        "id": 26903661,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTAzNjYx",
        "diff_hunk": "@@ -1096,6 +1096,15 @@ describe(\"propagation\", function () {\n });\n \n describe(\"all\", function () {\n+    it(\"rejects if not passed an array\", function() {\n+        var promise = Q.defer(),\n+            willBeRejected = Q.all(promise);\n+\n+        willBeRejected.then(function() {\n+            expect(willBeRejected.isRejected()).toBe(true);",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 9,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This will never execute, because it is a fulfillment callback.\n\nAlso, to get the test runner to recognize async tests, you need to return the promise.\n\nSo I think this would be better:\n\n``` js\nreturn willBeRejected.then(\n  function () {\n    expect(true).toBe(false);\n  },\n  function (err) {\n    expect(err.constructor).toBe(TypeError);\n  }\n);\n```\n",
        "created_at": "2015-03-22T14:41:49Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26903661",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903661"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26903661"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903664",
        "pull_request_review_id": null,
        "id": 26903664,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTAzNjY0",
        "diff_hunk": "@@ -1502,6 +1506,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (!isArray(arguments[0]) || arguments.length !== 1) {\n+            throw Error(\"All must be passed an array of promises.\");",
        "path": "q.js",
        "position": null,
        "original_position": 25,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "TypeError is appropriate here.\n",
        "created_at": "2015-03-22T14:42:03Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26903664",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903664"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26903664"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903677",
        "pull_request_review_id": null,
        "id": 26903677,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTAzNjc3",
        "diff_hunk": "@@ -1502,6 +1506,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (!isArray(arguments[0]) || arguments.length !== 1) {",
        "path": "q.js",
        "position": null,
        "original_position": 24,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't think it's good to prohibit extra arguments. Consider e.g. `arrayOfArrays.map(Q.all)`---that will now fail, since `map` passes `(array, index, arrayOfArrays)`.\n",
        "created_at": "2015-03-22T14:42:51Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26903677",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903677"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26903677"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903683",
        "pull_request_review_id": null,
        "id": 26903683,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTAzNjgz",
        "diff_hunk": "@@ -1502,6 +1506,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (!isArray(arguments[0]) || arguments.length !== 1) {",
        "path": "q.js",
        "position": null,
        "original_position": 24,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I also don't think it's good to prohibit array-likes (like `arguments`). Best bet is checking for a `length` property.\n",
        "created_at": "2015-03-22T14:43:36Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26903683",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26903683"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26903683"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26904991",
        "pull_request_review_id": null,
        "id": 26904991,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTA0OTkx",
        "diff_hunk": "@@ -1096,6 +1096,15 @@ describe(\"propagation\", function () {\n });\n \n describe(\"all\", function () {\n+    it(\"rejects if not passed an array\", function() {\n+        var promise = Q.defer(),\n+            willBeRejected = Q.all(promise);\n+\n+        willBeRejected.then(function() {\n+            expect(willBeRejected.isRejected()).toBe(true);",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 9,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "vingiarrusso",
            "id": 4361490,
            "node_id": "MDQ6VXNlcjQzNjE0OTA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4361490?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vingiarrusso",
            "html_url": "https://github.com/vingiarrusso",
            "followers_url": "https://api.github.com/users/vingiarrusso/followers",
            "following_url": "https://api.github.com/users/vingiarrusso/following{/other_user}",
            "gists_url": "https://api.github.com/users/vingiarrusso/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vingiarrusso/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vingiarrusso/subscriptions",
            "organizations_url": "https://api.github.com/users/vingiarrusso/orgs",
            "repos_url": "https://api.github.com/users/vingiarrusso/repos",
            "events_url": "https://api.github.com/users/vingiarrusso/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vingiarrusso/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Thanks Domenic.  Works perfectly.\n",
        "created_at": "2015-03-22T17:21:38Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26904991",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26904991"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26904991"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26906664",
        "pull_request_review_id": null,
        "id": 26906664,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTA2NjY0",
        "diff_hunk": "@@ -1096,6 +1096,15 @@ describe(\"propagation\", function () {\n });\n \n describe(\"all\", function () {\n+    it(\"rejects if not passed an array\", function() {\n+        var promise = Q.defer(),\n+            willBeRejected = Q.all(promise);\n+\n+        willBeRejected.then(function() {\n+            expect(willBeRejected.isRejected()).toBe(true);",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 9,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "vingiarrusso",
            "id": 4361490,
            "node_id": "MDQ6VXNlcjQzNjE0OTA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4361490?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vingiarrusso",
            "html_url": "https://github.com/vingiarrusso",
            "followers_url": "https://api.github.com/users/vingiarrusso/followers",
            "following_url": "https://api.github.com/users/vingiarrusso/following{/other_user}",
            "gists_url": "https://api.github.com/users/vingiarrusso/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vingiarrusso/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vingiarrusso/subscriptions",
            "organizations_url": "https://api.github.com/users/vingiarrusso/orgs",
            "repos_url": "https://api.github.com/users/vingiarrusso/repos",
            "events_url": "https://api.github.com/users/vingiarrusso/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vingiarrusso/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@domenic  is there a reason you can think of that we shouldn't use this? \n\n``` javascript\nreturn willBeRejected.fail(function(err) {\n       expect(err.constructor).toBe(TypeError);\n   });\n```\n",
        "created_at": "2015-03-22T20:12:41Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26906664",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26906664"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26906664"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26907655",
        "pull_request_review_id": null,
        "id": 26907655,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTA3NjU1",
        "diff_hunk": "@@ -1096,6 +1096,15 @@ describe(\"propagation\", function () {\n });\n \n describe(\"all\", function () {\n+    it(\"rejects if not passed an array\", function() {\n+        var promise = Q.defer(),\n+            willBeRejected = Q.all(promise);\n+\n+        willBeRejected.then(function() {\n+            expect(willBeRejected.isRejected()).toBe(true);",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 9,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "If the promise fulfills the test will still pass in your version,\n",
        "created_at": "2015-03-22T21:57:32Z",
        "updated_at": "2015-03-24T02:26:49Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26907655",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26907655"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26907655"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/26999413",
        "pull_request_review_id": null,
        "id": 26999413,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2OTk5NDEz",
        "diff_hunk": "@@ -1502,6 +1506,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (!isArray(arguments[0]) || arguments.length !== 1) {",
        "path": "q.js",
        "position": null,
        "original_position": 24,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "1429af880d77e33ea07c1a55c7efcc0cdaf3c177",
        "user": {
            "login": "vingiarrusso",
            "id": 4361490,
            "node_id": "MDQ6VXNlcjQzNjE0OTA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4361490?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vingiarrusso",
            "html_url": "https://github.com/vingiarrusso",
            "followers_url": "https://api.github.com/users/vingiarrusso/followers",
            "following_url": "https://api.github.com/users/vingiarrusso/following{/other_user}",
            "gists_url": "https://api.github.com/users/vingiarrusso/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vingiarrusso/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vingiarrusso/subscriptions",
            "organizations_url": "https://api.github.com/users/vingiarrusso/orgs",
            "repos_url": "https://api.github.com/users/vingiarrusso/repos",
            "events_url": "https://api.github.com/users/vingiarrusso/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vingiarrusso/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Thanks Domenic!\n",
        "created_at": "2015-03-24T02:30:59Z",
        "updated_at": "2015-03-24T02:30:59Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r26999413",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/26999413"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r26999413"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/28982973",
        "pull_request_review_id": null,
        "id": 28982973,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTgyOTcz",
        "diff_hunk": "@@ -155,9 +155,15 @@ var nextTick =(function () {\n         }\n     };\n \n-    if (typeof process !== \"undefined\" && process.nextTick) {\n+    if (typeof process === \"object\" && (process + '') === '[object process]' &&",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "8683b09f3d9a07a3be110dc6ae55fa31a1ba34b9",
        "original_commit_id": "b57834b75493ccba6824ff7358d4f21971aca0ac",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Let\u2019s toString explicitly.\n",
        "created_at": "2015-04-23T17:16:44Z",
        "updated_at": "2015-04-25T18:26:43Z",
        "html_url": "https://github.com/kriskowal/q/pull/682#discussion_r28982973",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/682",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/28982973"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/682#discussion_r28982973"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/682"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/29119131",
        "pull_request_review_id": null,
        "id": 29119131,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MTE5MTMx",
        "diff_hunk": "@@ -2022,6 +2032,10 @@ Promise.prototype.nodeify = function (nodeback) {\n     }\n };\n \n+Q.noConflict = function() {\n+    console.log('Q.noConflict only works when Q is used as a global');",
        "path": "q.js",
        "position": null,
        "original_position": 24,
        "commit_id": "12db37ec6ac0dec205256cf63b48df2c89c80f8a",
        "original_commit_id": "8cd300503b1211fea67f7c5518b21bb52cbe3314",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This should simply throw an error.\n",
        "created_at": "2015-04-27T03:28:44Z",
        "updated_at": "2015-04-27T16:01:12Z",
        "html_url": "https://github.com/kriskowal/q/pull/686#discussion_r29119131",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/686",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/29119131"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/686#discussion_r29119131"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/686"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/29119147",
        "pull_request_review_id": null,
        "id": 29119147,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5MTE5MTQ3",
        "diff_hunk": "@@ -2491,6 +2491,27 @@ describe(\"node support\", function () {\n \n });\n \n+describe(\"browser support\", function () {\n+    var _Q;\n+\n+    beforeEach(function() {\n+        _Q = Q;\n+    });\n+\n+    afterEach(function() {\n+        Q = _Q;\n+    });\n+\n+    it(\"sets the global Q object to its original value\", function() {\n+        Q.noConflict();\n+\n+        // In this context the original value of Q is undefined.\n+        if(typeof window !== 'undefined') {",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 19,
        "commit_id": "12db37ec6ac0dec205256cf63b48df2c89c80f8a",
        "original_commit_id": "8cd300503b1211fea67f7c5518b21bb52cbe3314",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Attend to the prevailing style with regard to spaces. I believe `npm run lint` will inform, but if it does not, take care to place spaces between keywords and parens to distinguish such cases from function calls.\n",
        "created_at": "2015-04-27T03:30:15Z",
        "updated_at": "2015-04-27T16:01:12Z",
        "html_url": "https://github.com/kriskowal/q/pull/686#discussion_r29119147",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/686",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/29119147"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/686#discussion_r29119147"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/686"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/29993854",
        "pull_request_review_id": null,
        "id": 29993854,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI5OTkzODU0",
        "diff_hunk": "@@ -1502,6 +1502,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (typeof arguments[0].length === \"undefined\") {",
        "path": "q.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why this as opposed to `Array.isArray(promises)`?\n",
        "created_at": "2015-05-09T16:14:18Z",
        "updated_at": "2015-05-09T16:14:18Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r29993854",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/29993854"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r29993854"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30061995",
        "pull_request_review_id": null,
        "id": 30061995,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwMDYxOTk1",
        "diff_hunk": "@@ -1502,6 +1502,10 @@ Promise.prototype.keys = function () {\n Q.all = all;\n function all(promises) {\n     return when(promises, function (promises) {\n+        if (typeof arguments[0].length === \"undefined\") {",
        "path": "q.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "original_commit_id": "3a3a36749866530c49f8667ce91267c2d9f63e88",
        "user": {
            "login": "vingiarrusso",
            "id": 4361490,
            "node_id": "MDQ6VXNlcjQzNjE0OTA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4361490?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vingiarrusso",
            "html_url": "https://github.com/vingiarrusso",
            "followers_url": "https://api.github.com/users/vingiarrusso/followers",
            "following_url": "https://api.github.com/users/vingiarrusso/following{/other_user}",
            "gists_url": "https://api.github.com/users/vingiarrusso/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/vingiarrusso/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/vingiarrusso/subscriptions",
            "organizations_url": "https://api.github.com/users/vingiarrusso/orgs",
            "repos_url": "https://api.github.com/users/vingiarrusso/repos",
            "events_url": "https://api.github.com/users/vingiarrusso/events{/privacy}",
            "received_events_url": "https://api.github.com/users/vingiarrusso/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "With Array.isArray, if all() gets passed the arguments object it would be rejected.\n",
        "created_at": "2015-05-11T17:36:00Z",
        "updated_at": "2015-05-11T17:36:00Z",
        "html_url": "https://github.com/kriskowal/q/pull/667#discussion_r30061995",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/667",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30061995"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/667#discussion_r30061995"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/667"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30609816",
        "pull_request_review_id": null,
        "id": 30609816,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjA5ODE2",
        "diff_hunk": "@@ -5,6 +5,7 @@\n  - Removed extraneous files from the npm package by using the \"files\"\n    whitelist in package.json instead of the .npmignore blacklist.\n    (@anton-rudeshko)\n+ - Throw if callback supplied to \"finally\" is invalid",
        "path": "CHANGES.md",
        "position": null,
        "original_position": 4,
        "commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "original_commit_id": "f67f039d5784f485aa27975d43058da767315e40",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Most people don\u2019t do this. Thanks for adding it. Be sure to credit yourself (`@you`) and put it above the most recent release so it gets rolled up in the next minor/patch.\n",
        "created_at": "2015-05-19T15:13:44Z",
        "updated_at": "2015-05-20T08:11:02Z",
        "html_url": "https://github.com/kriskowal/q/pull/634#discussion_r30609816",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/634",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30609816"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/634#discussion_r30609816"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/634"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30609969",
        "pull_request_review_id": null,
        "id": 30609969,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjA5OTY5",
        "diff_hunk": "@@ -1645,6 +1645,9 @@ Q[\"finally\"] = function (object, callback) {\n \n Promise.prototype.fin = // XXX legacy\n Promise.prototype[\"finally\"] = function (callback) {\n+    if (callback === undefined) {",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "original_commit_id": "f67f039d5784f485aa27975d43058da767315e40",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`if (!callback)` would suffice; `if (typeof callback.apply !== \"function\")` would be strong. If we do this here, we should do it for all methods.\n",
        "created_at": "2015-05-19T15:15:14Z",
        "updated_at": "2015-05-20T08:11:02Z",
        "html_url": "https://github.com/kriskowal/q/pull/634#discussion_r30609969",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/634",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30609969"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/634#discussion_r30609969"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/634"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30610030",
        "pull_request_review_id": null,
        "id": 30610030,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjEwMDMw",
        "diff_hunk": "@@ -1645,6 +1645,9 @@ Q[\"finally\"] = function (object, callback) {\n \n Promise.prototype.fin = // XXX legacy\n Promise.prototype[\"finally\"] = function (callback) {\n+    if (callback === undefined) {\n+        throw new Error('Invalid callback');",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "original_commit_id": "f67f039d5784f485aa27975d43058da767315e40",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`Can't apply finally callback`\n",
        "created_at": "2015-05-19T15:15:42Z",
        "updated_at": "2015-05-20T08:11:02Z",
        "html_url": "https://github.com/kriskowal/q/pull/634#discussion_r30610030",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/634",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30610030"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/634#discussion_r30610030"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/634"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30611111",
        "pull_request_review_id": null,
        "id": 30611111,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjExMTEx",
        "diff_hunk": "@@ -1645,6 +1645,9 @@ Q[\"finally\"] = function (object, callback) {\n \n Promise.prototype.fin = // XXX legacy\n Promise.prototype[\"finally\"] = function (callback) {\n+    if (callback === undefined) {",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "original_commit_id": "f67f039d5784f485aa27975d43058da767315e40",
        "user": {
            "login": "willtcarey",
            "id": 880387,
            "node_id": "MDQ6VXNlcjg4MDM4Nw==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/880387?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/willtcarey",
            "html_url": "https://github.com/willtcarey",
            "followers_url": "https://api.github.com/users/willtcarey/followers",
            "following_url": "https://api.github.com/users/willtcarey/following{/other_user}",
            "gists_url": "https://api.github.com/users/willtcarey/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/willtcarey/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/willtcarey/subscriptions",
            "organizations_url": "https://api.github.com/users/willtcarey/orgs",
            "repos_url": "https://api.github.com/users/willtcarey/repos",
            "events_url": "https://api.github.com/users/willtcarey/events{/privacy}",
            "received_events_url": "https://api.github.com/users/willtcarey/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`if (typeof callback.apply !== \"function\")` would throw an error for reading a property if callback were undefined, wouldn't it?\n",
        "created_at": "2015-05-19T15:24:33Z",
        "updated_at": "2015-05-20T08:11:02Z",
        "html_url": "https://github.com/kriskowal/q/pull/634#discussion_r30611111",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/634",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30611111"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/634#discussion_r30611111"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/634"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30611634",
        "pull_request_review_id": null,
        "id": 30611634,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjExNjM0",
        "diff_hunk": "@@ -1645,6 +1645,9 @@ Q[\"finally\"] = function (object, callback) {\n \n Promise.prototype.fin = // XXX legacy\n Promise.prototype[\"finally\"] = function (callback) {\n+    if (callback === undefined) {",
        "path": "q.js",
        "position": null,
        "original_position": 4,
        "commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "original_commit_id": "f67f039d5784f485aa27975d43058da767315e40",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@willtcarey Good catch. Of course, `if (callback && typeof callback.apply !== \"function\")`.\n",
        "created_at": "2015-05-19T15:29:32Z",
        "updated_at": "2015-05-20T08:11:02Z",
        "html_url": "https://github.com/kriskowal/q/pull/634#discussion_r30611634",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/634",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30611634"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/634#discussion_r30611634"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/634"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/30679147",
        "pull_request_review_id": null,
        "id": 30679147,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjc5MTQ3",
        "diff_hunk": "@@ -1752,6 +1752,9 @@ Q[\"finally\"] = function (object, callback) {\n \n Promise.prototype.fin = // XXX legacy\n Promise.prototype[\"finally\"] = function (callback) {\n+    if (!callback || typeof callback.apply !== \"function\") {",
        "path": "q.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "original_commit_id": "79e5b717d7d54f21fe27d1b53f1b8b70eaab0219",
        "user": {
            "login": "grahamrhay",
            "id": 180700,
            "node_id": "MDQ6VXNlcjE4MDcwMA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/180700?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/grahamrhay",
            "html_url": "https://github.com/grahamrhay",
            "followers_url": "https://api.github.com/users/grahamrhay/followers",
            "following_url": "https://api.github.com/users/grahamrhay/following{/other_user}",
            "gists_url": "https://api.github.com/users/grahamrhay/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/grahamrhay/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/grahamrhay/subscriptions",
            "organizations_url": "https://api.github.com/users/grahamrhay/orgs",
            "repos_url": "https://api.github.com/users/grahamrhay/repos",
            "events_url": "https://api.github.com/users/grahamrhay/events{/privacy}",
            "received_events_url": "https://api.github.com/users/grahamrhay/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I find this a little confusing, but I feel the alternative (inverting the conditional, and having the guard at the bottom) is worse\n",
        "created_at": "2015-05-20T08:12:31Z",
        "updated_at": "2015-05-20T08:12:31Z",
        "html_url": "https://github.com/kriskowal/q/pull/634#discussion_r30679147",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/634",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/30679147"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/634#discussion_r30679147"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/634"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/32884272",
        "pull_request_review_id": null,
        "id": 32884272,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyODg0Mjcy",
        "diff_hunk": "@@ -557,11 +557,21 @@ describe(\"promises for objects\", function () {\n             return Q(object)\n             .set(\"a\", 1)\n             .then(function (result) {\n-                expect(result).toBe(undefined);\n+                expect(result).not.toBe(undefined);\n+                expect(object).toBe(result);",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 6,
        "commit_id": "f86840da701abc06b0acbe42b3abf8b710b77faa",
        "original_commit_id": "d99a7877bdc6ab8eca4bdbe317ac91a55ac35cfb",
        "user": {
            "login": "bergus",
            "id": 1146478,
            "node_id": "MDQ6VXNlcjExNDY0Nzg=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/1146478?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bergus",
            "html_url": "https://github.com/bergus",
            "followers_url": "https://api.github.com/users/bergus/followers",
            "following_url": "https://api.github.com/users/bergus/following{/other_user}",
            "gists_url": "https://api.github.com/users/bergus/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bergus/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bergus/subscriptions",
            "organizations_url": "https://api.github.com/users/bergus/orgs",
            "repos_url": "https://api.github.com/users/bergus/repos",
            "events_url": "https://api.github.com/users/bergus/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bergus/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`expect(result).toBe(object)` sounds more natural\n",
        "created_at": "2015-06-20T12:32:31Z",
        "updated_at": "2015-06-20T16:31:05Z",
        "html_url": "https://github.com/kriskowal/q/pull/705#discussion_r32884272",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/705",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/32884272"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/705#discussion_r32884272"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/705"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/32885856",
        "pull_request_review_id": null,
        "id": 32885856,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyODg1ODU2",
        "diff_hunk": "@@ -557,11 +557,21 @@ describe(\"promises for objects\", function () {\n             return Q(object)\n             .set(\"a\", 1)\n             .then(function (result) {\n-                expect(result).toBe(undefined);\n+                expect(result).not.toBe(undefined);\n+                expect(object).toBe(result);",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 6,
        "commit_id": "f86840da701abc06b0acbe42b3abf8b710b77faa",
        "original_commit_id": "d99a7877bdc6ab8eca4bdbe317ac91a55ac35cfb",
        "user": {
            "login": "thefourtheye",
            "id": 696611,
            "node_id": "MDQ6VXNlcjY5NjYxMQ==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/696611?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/thefourtheye",
            "html_url": "https://github.com/thefourtheye",
            "followers_url": "https://api.github.com/users/thefourtheye/followers",
            "following_url": "https://api.github.com/users/thefourtheye/following{/other_user}",
            "gists_url": "https://api.github.com/users/thefourtheye/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/thefourtheye/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/thefourtheye/subscriptions",
            "organizations_url": "https://api.github.com/users/thefourtheye/orgs",
            "repos_url": "https://api.github.com/users/thefourtheye/repos",
            "events_url": "https://api.github.com/users/thefourtheye/events{/privacy}",
            "received_events_url": "https://api.github.com/users/thefourtheye/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@bergus Thanks for reviewing :-) I changed it like that.\n",
        "created_at": "2015-06-20T16:31:20Z",
        "updated_at": "2015-06-20T16:31:20Z",
        "html_url": "https://github.com/kriskowal/q/pull/705#discussion_r32885856",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/705",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/32885856"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/705#discussion_r32885856"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/705"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/43403631",
        "pull_request_review_id": null,
        "id": 43403631,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzNjMx",
        "diff_hunk": "@@ -1622,12 +1622,12 @@ function any(promises) {\n         function onFulfilled(result) {\n             deferred.resolve(result);\n         }\n-        function onRejected() {\n+        function onRejected(err) {\n             pendingCount--;\n             if (pendingCount === 0) {\n                 deferred.reject(new Error(\n                     \"Q can't get fulfillment value from any promise, all \" +\n-                    \"promises were rejected.\"\n+                    \"promises were rejected. Last error: \" + err",
        "path": "q.js",
        "position": null,
        "original_position": 11,
        "commit_id": "c340b2d05241330674697705a5e4b00c7ac1443b",
        "original_commit_id": "269560a09080c7a44fe879c470763202f4a002e5",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Let\u2019s rather augment and rethrow the last error. That would look like:\n\n``` js\nerror.message = \"Q can't get \u2026 \" + error.message;\ndeferred.reject(error);\n```\n",
        "created_at": "2015-10-29T15:52:27Z",
        "updated_at": "2015-10-30T02:41:17Z",
        "html_url": "https://github.com/kriskowal/q/pull/740#discussion_r43403631",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/740",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/43403631"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/740#discussion_r43403631"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/740"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/48688919",
        "pull_request_review_id": null,
        "id": 48688919,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg4OTE5",
        "diff_hunk": "@@ -345,6 +346,14 @@ function isObject(value) {\n     return value === Object(value);\n }\n \n+// Pad an array value with nulls to the specified length.  Longer arrays are left alone.\n+function padArrayTo(arry,len) {\n+    if ( arry.length < len ) {\n+        arry = array_concat(arry, new Array(len - arry.length));",
        "path": "q.js",
        "position": null,
        "original_position": 15,
        "commit_id": "36f8c42aba00fdca942b1df7aa3d1209ecafec30",
        "original_commit_id": "f493930e12328585e218e48823a909c788d72898",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This can be accomplished without allocations `array.length = Math.min(array.length, length)`\n",
        "created_at": "2016-01-03T00:20:27Z",
        "updated_at": "2016-01-03T01:12:15Z",
        "html_url": "https://github.com/kriskowal/q/pull/753#discussion_r48688919",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/753",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/48688919"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/753#discussion_r48688919"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/753"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/48698146",
        "pull_request_review_id": null,
        "id": 48698146,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MTQ2",
        "diff_hunk": "@@ -345,6 +346,14 @@ function isObject(value) {\n     return value === Object(value);\n }\n \n+// Pad an array value with nulls to the specified length.  Longer arrays are left alone.",
        "path": "q.js",
        "position": 12,
        "original_position": 12,
        "commit_id": "36f8c42aba00fdca942b1df7aa3d1209ecafec30",
        "original_commit_id": "36f8c42aba00fdca942b1df7aa3d1209ecafec30",
        "user": {
            "login": "domenic",
            "id": 617481,
            "node_id": "MDQ6VXNlcjYxNzQ4MQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/617481?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/domenic",
            "html_url": "https://github.com/domenic",
            "followers_url": "https://api.github.com/users/domenic/followers",
            "following_url": "https://api.github.com/users/domenic/following{/other_user}",
            "gists_url": "https://api.github.com/users/domenic/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/domenic/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/domenic/subscriptions",
            "organizations_url": "https://api.github.com/users/domenic/orgs",
            "repos_url": "https://api.github.com/users/domenic/repos",
            "events_url": "https://api.github.com/users/domenic/events{/privacy}",
            "received_events_url": "https://api.github.com/users/domenic/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This doesn't do what it says. It pads the array with holes, not nulls.\n",
        "created_at": "2016-01-03T22:33:17Z",
        "updated_at": "2016-01-03T22:33:17Z",
        "html_url": "https://github.com/kriskowal/q/pull/753#discussion_r48698146",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/753",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/48698146"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/753#discussion_r48698146"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/753"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/48699273",
        "pull_request_review_id": null,
        "id": 48699273,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5Mjcz",
        "diff_hunk": "@@ -345,6 +346,14 @@ function isObject(value) {\n     return value === Object(value);\n }\n \n+// Pad an array value with nulls to the specified length.  Longer arrays are left alone.",
        "path": "q.js",
        "position": 12,
        "original_position": 12,
        "commit_id": "36f8c42aba00fdca942b1df7aa3d1209ecafec30",
        "original_commit_id": "36f8c42aba00fdca942b1df7aa3d1209ecafec30",
        "user": {
            "login": "denised",
            "id": 1312334,
            "node_id": "MDQ6VXNlcjEzMTIzMzQ=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1312334?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/denised",
            "html_url": "https://github.com/denised",
            "followers_url": "https://api.github.com/users/denised/followers",
            "following_url": "https://api.github.com/users/denised/following{/other_user}",
            "gists_url": "https://api.github.com/users/denised/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/denised/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/denised/subscriptions",
            "organizations_url": "https://api.github.com/users/denised/orgs",
            "repos_url": "https://api.github.com/users/denised/repos",
            "events_url": "https://api.github.com/users/denised/events{/privacy}",
            "received_events_url": "https://api.github.com/users/denised/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oops, you are right; I will change the comment.\n",
        "created_at": "2016-01-04T00:06:30Z",
        "updated_at": "2016-01-04T00:06:30Z",
        "html_url": "https://github.com/kriskowal/q/pull/753#discussion_r48699273",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/753",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/48699273"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/753#discussion_r48699273"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/753"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/59580526",
        "pull_request_review_id": null,
        "id": 59580526,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgwNTI2",
        "diff_hunk": "@@ -1580,6 +1580,7 @@ function all(promises) {\n                     promise,\n                     function (value) {\n                         promises[index] = value;\n+                        deferred.notify( { index: index, pending: pendingCount - 1 } );",
        "path": "q.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "270906b44c15ed7eabb9817c21ba44123eb55f18",
        "original_commit_id": "270906b44c15ed7eabb9817c21ba44123eb55f18",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Note that there is existing code, below, that propagates a different kind of progress notification.\n",
        "created_at": "2016-04-13T16:31:59Z",
        "updated_at": "2016-04-13T16:31:59Z",
        "html_url": "https://github.com/kriskowal/q/pull/775#discussion_r59580526",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/775",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/59580526"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/775#discussion_r59580526"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/775"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/117390346",
        "pull_request_review_id": 39095287,
        "id": 117390346,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExNzM5MDM0Ng==",
        "diff_hunk": "@@ -1219,8 +1231,11 @@ describe(\"any\", function() {\n           .then(function() {\n               expect(promise.isRejected()).toBe(true);\n               expect(promise.inspect().reason).toBe(expectedError);\n-              expect(promise.inspect().reason.message)\n-              .toBe(\"Q can't get fulfillment value from any promise, all promises were rejected. Last error message: Rejected\");\n+\n+              if (!expectNull) {",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 31,
        "commit_id": "9175f60da197b2edf23dfc55fb7343502216ebd9",
        "original_commit_id": "a964880a4d0ba6d3a9e66fcbd07fdb9fa3e6db8f",
        "user": {
            "login": "jbunton-atlassian",
            "id": 13862371,
            "node_id": "MDQ6VXNlcjEzODYyMzcx",
            "avatar_url": "https://avatars0.githubusercontent.com/u/13862371?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jbunton-atlassian",
            "html_url": "https://github.com/jbunton-atlassian",
            "followers_url": "https://api.github.com/users/jbunton-atlassian/followers",
            "following_url": "https://api.github.com/users/jbunton-atlassian/following{/other_user}",
            "gists_url": "https://api.github.com/users/jbunton-atlassian/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jbunton-atlassian/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jbunton-atlassian/subscriptions",
            "organizations_url": "https://api.github.com/users/jbunton-atlassian/orgs",
            "repos_url": "https://api.github.com/users/jbunton-atlassian/repos",
            "events_url": "https://api.github.com/users/jbunton-atlassian/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jbunton-atlassian/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Right now Q is rejecting the promise with an undefined/null value. Just because the library user did that doesn't mean that we should as well :)\r\n\r\nHow about something like:\r\n\r\n```\r\nif (expectNull) {\r\n  expect(promise.inspect().reason.message)\r\n  .toBe(\"Q can't get fulfillment value from any promise, all promises were rejected. Last rejection was null/undefined.\");\r\n} else {\r\n  expect(promise.inspect().reason.message)\r\n  .toBe(\"Q can't get fulfillment value from any promise, all promises were rejected. Last error message: Rejected\");\r\n}",
        "created_at": "2017-05-19T01:58:15Z",
        "updated_at": "2017-05-31T21:55:46Z",
        "html_url": "https://github.com/kriskowal/q/pull/813#discussion_r117390346",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/813",
        "author_association": "COLLABORATOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/117390346"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/813#discussion_r117390346"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/813"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/119463100",
        "pull_request_review_id": 41345435,
        "id": 119463100,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExOTQ2MzEwMA==",
        "diff_hunk": "@@ -1645,9 +1645,12 @@ function any(promises) {\n         function onRejected(err) {\n             pendingCount--;\n             if (pendingCount === 0) {\n-                err.message = (\"Q can't get fulfillment value from any promise, all \" +\n+                var rejection = err || new Error(\"Rejection was null/undefined\");",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "9175f60da197b2edf23dfc55fb7343502216ebd9",
        "original_commit_id": "1bcb612fe565ad02e8eaa5e11712480dfd77a59b",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This could be new Error(\"error \" + err) and you\u2019d get \"error undefined\" or \"error null\" specifically.",
        "created_at": "2017-05-31T20:20:48Z",
        "updated_at": "2017-05-31T21:55:46Z",
        "html_url": "https://github.com/kriskowal/q/pull/813#discussion_r119463100",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/813",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/119463100"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/813#discussion_r119463100"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/813"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/119481049",
        "pull_request_review_id": 41365252,
        "id": 119481049,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExOTQ4MTA0OQ==",
        "diff_hunk": "@@ -1192,7 +1192,7 @@ describe(\"any\", function() {\n         var deferreds = [Q.defer(), Q.defer()];\n         var promises = [deferreds[0].promise, deferreds[1].promise];\n \n-        return testReject(promises, deferreds);\n+        return testReject(promises, deferreds, new Error('Rejected'));",
        "path": "spec/q-spec.js",
        "position": null,
        "original_position": 5,
        "commit_id": "9175f60da197b2edf23dfc55fb7343502216ebd9",
        "original_commit_id": "a78a46ef9883a25dd322b29bb1b424c97132d2c1",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This line should not pass lint, since the quotes are inconsistent with the rest of the module.",
        "created_at": "2017-05-31T21:39:57Z",
        "updated_at": "2017-05-31T21:55:46Z",
        "html_url": "https://github.com/kriskowal/q/pull/813#discussion_r119481049",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/813",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/119481049"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/813#discussion_r119481049"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/813"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/119481820",
        "pull_request_review_id": 41365252,
        "id": 119481820,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExOTQ4MTgyMA==",
        "diff_hunk": "@@ -1645,10 +1645,10 @@ function any(promises) {\n         function onRejected(err) {\n             pendingCount--;\n             if (pendingCount === 0) {\n-                var rejection = err || new Error(\"Rejection was null/undefined\");\n+                var rejection = err || new Error(\"Rejection value was: \" + err);",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "9175f60da197b2edf23dfc55fb7343502216ebd9",
        "original_commit_id": "a78a46ef9883a25dd322b29bb1b424c97132d2c1",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Thinking more, do you think it might not suffice to just toString the error instead of prefixing with any front-matter? `(\"\" + err)`. Consider ultimately `Q.any can't get fulfillment value from any promise. All promises were rejected. Last error: undefined`.",
        "created_at": "2017-05-31T21:43:29Z",
        "updated_at": "2017-05-31T21:55:46Z",
        "html_url": "https://github.com/kriskowal/q/pull/813#discussion_r119481820",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/813",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/119481820"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/813#discussion_r119481820"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/813"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/119483198",
        "pull_request_review_id": 41367597,
        "id": 119483198,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExOTQ4MzE5OA==",
        "diff_hunk": "@@ -1645,10 +1645,10 @@ function any(promises) {\n         function onRejected(err) {\n             pendingCount--;\n             if (pendingCount === 0) {\n-                var rejection = err || new Error(\"Rejection was null/undefined\");\n+                var rejection = err || new Error(\"Rejection value was: \" + err);",
        "path": "q.js",
        "position": null,
        "original_position": 5,
        "commit_id": "9175f60da197b2edf23dfc55fb7343502216ebd9",
        "original_commit_id": "a78a46ef9883a25dd322b29bb1b424c97132d2c1",
        "user": {
            "login": "ivanetchart",
            "id": 155458,
            "node_id": "MDQ6VXNlcjE1NTQ1OA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/155458?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ivanetchart",
            "html_url": "https://github.com/ivanetchart",
            "followers_url": "https://api.github.com/users/ivanetchart/followers",
            "following_url": "https://api.github.com/users/ivanetchart/following{/other_user}",
            "gists_url": "https://api.github.com/users/ivanetchart/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/ivanetchart/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ivanetchart/subscriptions",
            "organizations_url": "https://api.github.com/users/ivanetchart/orgs",
            "repos_url": "https://api.github.com/users/ivanetchart/repos",
            "events_url": "https://api.github.com/users/ivanetchart/events{/privacy}",
            "received_events_url": "https://api.github.com/users/ivanetchart/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I agree it can be too verbose. My attempt was to make sure the error message could lead you to the real cause, but `Last Error: undefined` is enough & clear.",
        "created_at": "2017-05-31T21:51:18Z",
        "updated_at": "2017-05-31T21:55:46Z",
        "html_url": "https://github.com/kriskowal/q/pull/813#discussion_r119483198",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/813",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/119483198"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/813#discussion_r119483198"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/813"
            }
        },
        "in_reply_to_id": 119481820
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/145856616",
        "pull_request_review_id": 70719828,
        "id": 145856616,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0NTg1NjYxNg==",
        "diff_hunk": "@@ -1083,10 +1083,25 @@ function trackRejection(promise, reason) {\n     }\n \n     unhandledRejections.push(promise);\n+    var rejectionString = reason + \"\";\n+\n+    // Public hook to allow for custom tweaking of unhandled rejection string (note, stack\n+    // will be appended afterwards by code below)\n+    if (Q.customizeRejectionString) {",
        "path": "q.js",
        "position": 8,
        "original_position": 8,
        "commit_id": "a9d8b281953989ece87a836ae808393f57a2060a",
        "original_commit_id": "a9d8b281953989ece87a836ae808393f57a2060a",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Perhaps we should name the hook `rewriteReason`",
        "created_at": "2017-10-20T00:35:10Z",
        "updated_at": "2017-10-20T00:35:47Z",
        "html_url": "https://github.com/kriskowal/q/pull/817#discussion_r145856616",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/817",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/145856616"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/817#discussion_r145856616"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/817"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/145856649",
        "pull_request_review_id": 70719828,
        "id": 145856649,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0NTg1NjY0OQ==",
        "diff_hunk": "@@ -2948,9 +2948,18 @@ describe(\"unhandled rejection reporting\", function () {\n \n     it(\"reports a stack trace\", function () {\n         var error = new Error(\"a reason\");\n+        var firstLineOfStack = error.stack ? error.stack.split('\\n')[0] : undefined;\n+        var expectedStack;\n+\n         Q.reject(error);\n \n-        expect(Q.getUnhandledReasons()).toEqual([error.stack]);\n+        if (firstLineOfStack && firstLineOfStack.indexOf('a reason') >= 0) {",
        "path": "spec/q-spec.js",
        "position": 10,
        "original_position": 10,
        "commit_id": "a9d8b281953989ece87a836ae808393f57a2060a",
        "original_commit_id": "a9d8b281953989ece87a836ae808393f57a2060a",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Check lint.",
        "created_at": "2017-10-20T00:35:25Z",
        "updated_at": "2017-10-20T00:35:47Z",
        "html_url": "https://github.com/kriskowal/q/pull/817#discussion_r145856649",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/817",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/145856649"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/817#discussion_r145856649"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/817"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/kriskowal/q/pulls/comments/230617026",
        "pull_request_review_id": 171393199,
        "id": 230617026,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYxNzAyNg==",
        "diff_hunk": "@@ -1665,7 +1665,9 @@ function any(promises) {\n }\n \n Promise.prototype.any = function () {\n-    return any(this);\n+    return this.then(function(values) {",
        "path": "q.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "fd74cf878521bae46a868f3d5d8f90ae21a62a12",
        "original_commit_id": "fd74cf878521bae46a868f3d5d8f90ae21a62a12",
        "user": {
            "login": "kriskowal",
            "id": 60294,
            "node_id": "MDQ6VXNlcjYwMjk0",
            "avatar_url": "https://avatars1.githubusercontent.com/u/60294?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kriskowal",
            "html_url": "https://github.com/kriskowal",
            "followers_url": "https://api.github.com/users/kriskowal/followers",
            "following_url": "https://api.github.com/users/kriskowal/following{/other_user}",
            "gists_url": "https://api.github.com/users/kriskowal/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kriskowal/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kriskowal/subscriptions",
            "organizations_url": "https://api.github.com/users/kriskowal/orgs",
            "repos_url": "https://api.github.com/users/kriskowal/repos",
            "events_url": "https://api.github.com/users/kriskowal/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kriskowal/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This can be merely `this.then(any)`.",
        "created_at": "2018-11-05T01:43:18Z",
        "updated_at": "2018-11-05T01:45:38Z",
        "html_url": "https://github.com/kriskowal/q/pull/838#discussion_r230617026",
        "pull_request_url": "https://api.github.com/repos/kriskowal/q/pulls/838",
        "author_association": "OWNER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/comments/230617026"
            },
            "html": {
                "href": "https://github.com/kriskowal/q/pull/838#discussion_r230617026"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/kriskowal/q/pulls/838"
            }
        }
    }
]