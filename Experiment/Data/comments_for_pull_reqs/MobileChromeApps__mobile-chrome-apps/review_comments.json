[
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7033113",
        "pull_request_review_id": null,
        "id": 7033113,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzMxMTM=",
        "diff_hunk": "@@ -593,8 +593,7 @@ function createCommand(appId, addAndroidPlatform, addIosPlatform) {\n       callback();\n     }\n \n-    fs.mkdirSync(appName);\n-    cordova.config(path.join(origDir, appName), {\n+    config_json = {",
        "path": "mca.js",
        "position": null,
        "original_position": 6,
        "commit_id": "01a2432c59499b21a96342098d1df1fa5c6c6bab",
        "original_commit_id": "b6e670d9d90daef87d39a38dd7c51a0639ec617b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Missing \"var\", should be: var configJson = {.  You should also put a semicolon at the end of the statement\n",
        "created_at": "2013-10-17T14:04:41Z",
        "updated_at": "2013-10-17T14:21:32Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/25#discussion_r7033113",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/25",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7033113"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/25#discussion_r7033113"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/25"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7033902",
        "pull_request_review_id": null,
        "id": 7033902,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzM5MDI=",
        "diff_hunk": "@@ -593,8 +593,7 @@ function createCommand(appId, addAndroidPlatform, addIosPlatform) {\n       callback();\n     }\n \n-    fs.mkdirSync(appName);\n-    cordova.config(path.join(origDir, appName), {\n+    config_json = {",
        "path": "mca.js",
        "position": null,
        "original_position": 6,
        "commit_id": "01a2432c59499b21a96342098d1df1fa5c6c6bab",
        "original_commit_id": "b6e670d9d90daef87d39a38dd7c51a0639ec617b",
        "user": {
            "login": "kamrik",
            "id": 3289730,
            "node_id": "MDQ6VXNlcjMyODk3MzA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/3289730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kamrik",
            "html_url": "https://github.com/kamrik",
            "followers_url": "https://api.github.com/users/kamrik/followers",
            "following_url": "https://api.github.com/users/kamrik/following{/other_user}",
            "gists_url": "https://api.github.com/users/kamrik/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kamrik/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kamrik/subscriptions",
            "organizations_url": "https://api.github.com/users/kamrik/orgs",
            "repos_url": "https://api.github.com/users/kamrik/repos",
            "events_url": "https://api.github.com/users/kamrik/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kamrik/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "fixed.\n",
        "created_at": "2013-10-17T14:30:07Z",
        "updated_at": "2013-10-17T14:30:07Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/25#discussion_r7033902",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/25",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7033902"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/25#discussion_r7033902"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/25"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7662727",
        "pull_request_review_id": null,
        "id": 7662727,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc2NjI3Mjc=",
        "diff_hunk": "@@ -826,5 +826,7 @@ function main() {\n \n if (require.main === module) {\n     main();\n+} else {\n+    module.exports = main;",
        "path": "src/mca.js",
        "position": null,
        "original_position": 198,
        "commit_id": "438ef90b679f9dfacac8cd2dc6d876865c3ea8dc",
        "original_commit_id": "2a941681b5165b7106c07dcf3464c7b49968eb8e",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I would export an object/map, not a single function.  Likely we will want to support more targets in the future, and require('mca')() looks worse than require('mca').run() anyway.\n\nAdditionally, I would export the main() function under a name that looks like \"parseCLI\" or something?\n",
        "created_at": "2013-11-14T15:50:17Z",
        "updated_at": "2013-11-14T16:40:22Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7662727",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7662727"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7662727"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7662739",
        "pull_request_review_id": null,
        "id": 7662739,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc2NjI3Mzk=",
        "diff_hunk": "@@ -66,7 +66,7 @@ var commandLineFlags = null;\n var origDir = process.cwd();\n var isWindows = process.platform.slice(0, 3) == 'win';\n var eventQueue = [];\n-var scriptDir = path.dirname(process.argv[1]);\n+var mcaRoot = path.join(__dirname, '..');",
        "path": "src/mca.js",
        "position": 5,
        "original_position": 5,
        "commit_id": "438ef90b679f9dfacac8cd2dc6d876865c3ea8dc",
        "original_commit_id": "2a941681b5165b7106c07dcf3464c7b49968eb8e",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I like this change.\n",
        "created_at": "2013-11-14T15:50:37Z",
        "updated_at": "2013-11-14T16:40:22Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7662739",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7662739"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7662739"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7662907",
        "pull_request_review_id": null,
        "id": 7662907,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc2NjI5MDc=",
        "diff_hunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env node\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//  KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+// Set this to 1 to enable timestamp collection via addTs().\n+if (0) {\n+    var ts = [];\n+    addTs = function(name) {\n+        ts.push([name, new Date]);\n+    }\n+    process.on('exit', function() {\n+        for (var i = 0; i < ts.length - 1; ++i) {\n+          var e1 = ts[i];\n+          var e2 = ts[i+1];\n+          console.log(e1[0] + ' -> ' + e2[0] + ' = ' + (e2[1] - e1[1]));\n+        }\n+        console.log('total: ' + (ts[ts.length-1][1] - ts[0][1]));\n+    });\n+} else {\n+    addTs = function() {};\n+}\n+\n+addTs('start');\n+var mca = require('./src/mca');\n+mca();\n+addTs('end');",
        "path": "mca",
        "position": null,
        "original_position": 42,
        "commit_id": "438ef90b679f9dfacac8cd2dc6d876865c3ea8dc",
        "original_commit_id": "2a941681b5165b7106c07dcf3464c7b49968eb8e",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't think this form on timestamping is necessary, personally.  Seems we wouldn't get an end event if you ctrl+c to exit early etc.  If we want to benchmark the pieces of MCA workflow, lets move this helper inside mca.js..\n\nAlso, this is exposing globals ts, addTs, mca on the global object, so I would suggest wrapping in an anonymous scope (function() { ... }()).\n\nAnyway, I think this is what the \"time\" command is for.\n",
        "created_at": "2013-11-14T15:56:17Z",
        "updated_at": "2013-11-14T16:40:22Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7662907",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7662907"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7662907"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7663409",
        "pull_request_review_id": null,
        "id": 7663409,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDc2NjM0MDk=",
        "diff_hunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env node\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//  KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+// Set this to 1 to enable timestamp collection via addTs().\n+if (0) {\n+    var ts = [];\n+    addTs = function(name) {\n+        ts.push([name, new Date]);\n+    }\n+    process.on('exit', function() {\n+        for (var i = 0; i < ts.length - 1; ++i) {\n+          var e1 = ts[i];\n+          var e2 = ts[i+1];\n+          console.log(e1[0] + ' -> ' + e2[0] + ' = ' + (e2[1] - e1[1]));\n+        }\n+        console.log('total: ' + (ts[ts.length-1][1] - ts[0][1]));\n+    });\n+} else {\n+    addTs = function() {};\n+}\n+\n+addTs('start');\n+var mca = require('./src/mca');\n+mca();\n+addTs('end');",
        "path": "mca",
        "position": null,
        "original_position": 42,
        "commit_id": "438ef90b679f9dfacac8cd2dc6d876865c3ea8dc",
        "original_commit_id": "2a941681b5165b7106c07dcf3464c7b49968eb8e",
        "user": {
            "login": "kamrik",
            "id": 3289730,
            "node_id": "MDQ6VXNlcjMyODk3MzA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/3289730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kamrik",
            "html_url": "https://github.com/kamrik",
            "followers_url": "https://api.github.com/users/kamrik/followers",
            "following_url": "https://api.github.com/users/kamrik/following{/other_user}",
            "gists_url": "https://api.github.com/users/kamrik/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kamrik/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kamrik/subscriptions",
            "organizations_url": "https://api.github.com/users/kamrik/orgs",
            "repos_url": "https://api.github.com/users/kamrik/repos",
            "events_url": "https://api.github.com/users/kamrik/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kamrik/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ok, I'll get rid of the timing bits (wasn't sure about them, just copied over from cordova-cli) and rename the main export to be something like parseCLI. This file will then be a one-liner with require('./src/mca').parseCLI()\n",
        "created_at": "2013-11-14T16:09:39Z",
        "updated_at": "2013-11-14T16:40:22Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7663409",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/7663409"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/29#discussion_r7663409"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/29"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/9345886",
        "pull_request_review_id": null,
        "id": 9345886,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDkzNDU4ODY=",
        "diff_hunk": "@@ -0,0 +1,146 @@\n+/*",
        "path": "docs/htmlConvert.js",
        "position": 20,
        "original_position": 1,
        "commit_id": "61bd969e06f70b79178ee90330bfbc0138ccc9bc",
        "original_commit_id": "d2675295a042e10389914ff84a84287e9cedce15",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Can you add the license header to this file as well as a shebang\n",
        "created_at": "2014-01-31T15:45:21Z",
        "updated_at": "2014-01-31T21:29:13Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/59#discussion_r9345886",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/59",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/9345886"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/59#discussion_r9345886"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/9346176",
        "pull_request_review_id": null,
        "id": 9346176,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDkzNDYxNzY=",
        "diff_hunk": "@@ -0,0 +1,146 @@\n+/*\n+\n+  A Node.js script to convert the mobile-chrome-apps Markdown docs\n+  into a HTML file to be included in the Chromium documents.\n+\n+  Usage:\n+  - Run from the mobile-chrome-apps repo's docs folder: \n+    node htmlConvert.js\n+  - Edit and save the document in the Chromium repo\n+    (src/chrome/common/extensions/docs/templates/articles/chrome_apps_on_mobile.html)\n+  - Submit a Change List (CL)\n+    git-cl upload\n+\n+  Required external modules:\n+    - markdown-js (https://github.com/evilstreak/markdown-js/): \n+      npm install -g markdown",
        "path": "docs/htmlConvert.js",
        "position": 35,
        "original_position": 16,
        "commit_id": "61bd969e06f70b79178ee90330bfbc0138ccc9bc",
        "original_commit_id": "d2675295a042e10389914ff84a84287e9cedce15",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "instead of installing dependencies globally, the \"node-preferred\" way is to add them locally in a package.json file.\n\nI think maybe it'd be better to put this script in its own repo. wdyt? That way it can have a README & its own package.json\n",
        "created_at": "2014-01-31T15:53:10Z",
        "updated_at": "2014-01-31T21:29:13Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/59#discussion_r9346176",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/59",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/9346176"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/59#discussion_r9346176"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/9358815",
        "pull_request_review_id": null,
        "id": 9358815,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDkzNTg4MTU=",
        "diff_hunk": "@@ -0,0 +1,146 @@\n+/*\n+\n+  A Node.js script to convert the mobile-chrome-apps Markdown docs\n+  into a HTML file to be included in the Chromium documents.\n+\n+  Usage:\n+  - Run from the mobile-chrome-apps repo's docs folder: \n+    node htmlConvert.js\n+  - Edit and save the document in the Chromium repo\n+    (src/chrome/common/extensions/docs/templates/articles/chrome_apps_on_mobile.html)\n+  - Submit a Change List (CL)\n+    git-cl upload\n+\n+  Required external modules:\n+    - markdown-js (https://github.com/evilstreak/markdown-js/): \n+      npm install -g markdown",
        "path": "docs/htmlConvert.js",
        "position": 35,
        "original_position": 16,
        "commit_id": "61bd969e06f70b79178ee90330bfbc0138ccc9bc",
        "original_commit_id": "d2675295a042e10389914ff84a84287e9cedce15",
        "user": {
            "login": "pearlchen-old",
            "id": 6394533,
            "node_id": "MDQ6VXNlcjYzOTQ1MzM=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/6394533?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/pearlchen-old",
            "html_url": "https://github.com/pearlchen-old",
            "followers_url": "https://api.github.com/users/pearlchen-old/followers",
            "following_url": "https://api.github.com/users/pearlchen-old/following{/other_user}",
            "gists_url": "https://api.github.com/users/pearlchen-old/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/pearlchen-old/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/pearlchen-old/subscriptions",
            "organizations_url": "https://api.github.com/users/pearlchen-old/orgs",
            "repos_url": "https://api.github.com/users/pearlchen-old/repos",
            "events_url": "https://api.github.com/users/pearlchen-old/events{/privacy}",
            "received_events_url": "https://api.github.com/users/pearlchen-old/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I kind of screwed up on my git pull so I'm closing this issue and opening a new branch so the script can be kept separate. Content changes have been pushed to master already.\n",
        "created_at": "2014-01-31T21:49:12Z",
        "updated_at": "2014-01-31T21:49:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/59#discussion_r9358815",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/59",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/9358815"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/59#discussion_r9358815"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/59"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15464330",
        "pull_request_review_id": null,
        "id": 15464330,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NDY0MzMw",
        "diff_hunk": "@@ -4,41 +4,69 @@\n \n package org.chromium;\n \n-import android.view.WindowManager;\n-\n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaInterface;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.CordovaWebView;\n import org.json.JSONException;\n \n+import android.content.Context;\n+import android.os.PowerManager;\n+import android.os.PowerManager.WakeLock;\n+import android.util.Log;\n+import android.view.WindowManager;\n+\n public class ChromePower extends CordovaPlugin {\n     private static final String LOG_TAG = \"ChromePower\";\n \n+    private WakeLock systemLock = null;\n+\n     @Override\n     public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n         if (\"requestKeepAwake\".equals(action)) {\n-            requestKeepAwake(args, callbackContext);\n+            requestKeepAwake(args);\n             return true;\n         } else if (\"releaseKeepAwake\".equals(action)) {\n-            releaseKeepAwake(args, callbackContext);\n+            releaseKeepAwake();\n             return true;\n         }\n \n         return false;\n     }\n \n-    private void requestKeepAwake(final CordovaArgs args, final CallbackContext callbackContext) {\n+    @Override\n+    public void onDestroy() {\n+        releaseKeepAwake();\n+    }\n+\n+    private void requestKeepAwake(final CordovaArgs args) {\n+        final String level = args.optString(0);\n         cordova.getActivity().runOnUiThread(new Runnable() {\n             public void run() {\n-                cordova.getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n+                if (\"display\".equals(level)) {\n+                    cordova.getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n+                } else if (\"system\".equals(level)) {\n+                    if (systemLock == null) {\n+                        PowerManager powerManager = (PowerManager) cordova.getActivity().getSystemService(Context.POWER_SERVICE);\n+                        systemLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"Chrome Power System lock\");\n+                        systemLock.acquire();\n+                    }\n+                } else {\n+                  Log.e(LOG_TAG, \"Invalid value. Level must be one of [system, display]\");",
        "path": "chrome-cordova/plugins/chrome.power/src/android/ChromePower.java",
        "position": 59,
        "original_position": 59,
        "commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "original_commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think general practice is to report these in JS land, since most cca devs don't do native dev or don't even have sdk installed to track logcat.  (Hence why Max originally had the check in js).\n\nI'm going to land this as is, since I'm sure we get this wrong in very many places in our plugins, but figured I'd mention this goal if you're going to keep making awesome patches for us!\n",
        "created_at": "2014-07-28T14:19:46Z",
        "updated_at": "2014-07-28T14:19:46Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15464330",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15464330"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15464330"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15464545",
        "pull_request_review_id": null,
        "id": 15464545,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NDY0NTQ1",
        "diff_hunk": "@@ -4,41 +4,69 @@\n \n package org.chromium;\n \n-import android.view.WindowManager;\n-\n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaInterface;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.CordovaWebView;\n import org.json.JSONException;\n \n+import android.content.Context;\n+import android.os.PowerManager;\n+import android.os.PowerManager.WakeLock;\n+import android.util.Log;\n+import android.view.WindowManager;\n+\n public class ChromePower extends CordovaPlugin {\n     private static final String LOG_TAG = \"ChromePower\";\n \n+    private WakeLock systemLock = null;\n+\n     @Override\n     public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n         if (\"requestKeepAwake\".equals(action)) {\n-            requestKeepAwake(args, callbackContext);\n+            requestKeepAwake(args);\n             return true;\n         } else if (\"releaseKeepAwake\".equals(action)) {\n-            releaseKeepAwake(args, callbackContext);\n+            releaseKeepAwake();\n             return true;\n         }\n \n         return false;\n     }\n \n-    private void requestKeepAwake(final CordovaArgs args, final CallbackContext callbackContext) {\n+    @Override\n+    public void onDestroy() {\n+        releaseKeepAwake();\n+    }\n+\n+    private void requestKeepAwake(final CordovaArgs args) {\n+        final String level = args.optString(0);\n         cordova.getActivity().runOnUiThread(new Runnable() {\n             public void run() {\n-                cordova.getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n+                if (\"display\".equals(level)) {\n+                    cordova.getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n+                } else if (\"system\".equals(level)) {\n+                    if (systemLock == null) {\n+                        PowerManager powerManager = (PowerManager) cordova.getActivity().getSystemService(Context.POWER_SERVICE);\n+                        systemLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"Chrome Power System lock\");\n+                        systemLock.acquire();\n+                    }\n+                } else {\n+                  Log.e(LOG_TAG, \"Invalid value. Level must be one of [system, display]\");",
        "path": "chrome-cordova/plugins/chrome.power/src/android/ChromePower.java",
        "position": 59,
        "original_position": 59,
        "commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "original_commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "user": {
            "login": "beaufortfrancois",
            "id": 634478,
            "node_id": "MDQ6VXNlcjYzNDQ3OA==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/634478?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/beaufortfrancois",
            "html_url": "https://github.com/beaufortfrancois",
            "followers_url": "https://api.github.com/users/beaufortfrancois/followers",
            "following_url": "https://api.github.com/users/beaufortfrancois/following{/other_user}",
            "gists_url": "https://api.github.com/users/beaufortfrancois/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/beaufortfrancois/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/beaufortfrancois/subscriptions",
            "organizations_url": "https://api.github.com/users/beaufortfrancois/orgs",
            "repos_url": "https://api.github.com/users/beaufortfrancois/repos",
            "events_url": "https://api.github.com/users/beaufortfrancois/events{/privacy}",
            "received_events_url": "https://api.github.com/users/beaufortfrancois/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Don't land this\n",
        "created_at": "2014-07-28T14:23:22Z",
        "updated_at": "2014-07-28T14:23:22Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15464545",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15464545"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15464545"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15851502",
        "pull_request_review_id": null,
        "id": 15851502,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODUxNTAy",
        "diff_hunk": "@@ -4,41 +4,69 @@\n \n package org.chromium;\n \n-import android.view.WindowManager;\n-\n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaInterface;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.CordovaWebView;\n import org.json.JSONException;\n \n+import android.content.Context;\n+import android.os.PowerManager;\n+import android.os.PowerManager.WakeLock;\n+import android.util.Log;\n+import android.view.WindowManager;\n+\n public class ChromePower extends CordovaPlugin {\n     private static final String LOG_TAG = \"ChromePower\";\n \n+    private WakeLock systemLock = null;\n+\n     @Override\n     public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n         if (\"requestKeepAwake\".equals(action)) {\n-            requestKeepAwake(args, callbackContext);\n+            requestKeepAwake(args);\n             return true;\n         } else if (\"releaseKeepAwake\".equals(action)) {\n-            releaseKeepAwake(args, callbackContext);\n+            releaseKeepAwake();\n             return true;\n         }\n \n         return false;\n     }\n \n-    private void requestKeepAwake(final CordovaArgs args, final CallbackContext callbackContext) {\n+    @Override\n+    public void onDestroy() {",
        "path": "chrome-cordova/plugins/chrome.power/src/android/ChromePower.java",
        "position": 41,
        "original_position": 41,
        "commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "original_commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Super awesome work!\n\nCan you add an override of onReset() as well that releases the wake lock?\n",
        "created_at": "2014-08-06T00:56:07Z",
        "updated_at": "2014-08-06T00:56:07Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15851502",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15851502"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15851502"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15851522",
        "pull_request_review_id": null,
        "id": 15851522,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODUxNTIy",
        "diff_hunk": "@@ -4,41 +4,69 @@\n \n package org.chromium;\n \n-import android.view.WindowManager;\n-\n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaInterface;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.CordovaWebView;\n import org.json.JSONException;\n \n+import android.content.Context;\n+import android.os.PowerManager;\n+import android.os.PowerManager.WakeLock;\n+import android.util.Log;\n+import android.view.WindowManager;\n+\n public class ChromePower extends CordovaPlugin {\n     private static final String LOG_TAG = \"ChromePower\";\n \n+    private WakeLock systemLock = null;\n+\n     @Override\n     public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n         if (\"requestKeepAwake\".equals(action)) {\n-            requestKeepAwake(args, callbackContext);\n+            requestKeepAwake(args);\n             return true;\n         } else if (\"releaseKeepAwake\".equals(action)) {\n-            releaseKeepAwake(args, callbackContext);\n+            releaseKeepAwake();\n             return true;\n         }\n \n         return false;\n     }\n \n-    private void requestKeepAwake(final CordovaArgs args, final CallbackContext callbackContext) {\n+    @Override\n+    public void onDestroy() {",
        "path": "chrome-cordova/plugins/chrome.power/src/android/ChromePower.java",
        "position": 41,
        "original_position": 41,
        "commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "original_commit_id": "16073278bd22154fa016eb07aeda23490d0e4b6d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "NVM - didn't notice this got merged. I'll add this in. Thanks again!\n",
        "created_at": "2014-08-06T00:56:55Z",
        "updated_at": "2014-08-06T00:56:55Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15851522",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15851522"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/235#discussion_r15851522"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/235"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15888964",
        "pull_request_review_id": null,
        "id": 15888964,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODg4OTY0",
        "diff_hunk": "@@ -217,10 +217,16 @@ function postPrepareInternal(platform) {\n     return require('./get-manifest')(root);\n   }).then(function(manifest) {\n     // Android\n-    if (platform === 'android' && manifest && manifest.versionCode) {\n+    if (platform === 'android' && manifest && (manifest.versionCode || manifest.short_name)) {\n       var androidManifestPath = path.join('platforms', 'android', 'AndroidManifest.xml');\n       var androidManifest = et.parse(fs.readFileSync(androidManifestPath, 'utf-8'));\n-      androidManifest.getroot().attrib[\"android:versionCode\"] = manifest.versionCode;\n+\n+      if (manifest.versionCode) {\n+        androidManifest.getroot().attrib[\"android:versionCode\"] = manifest.versionCode;\n+      }\n+      if (manifest.short_name) {\n+        androidManifest.find('./application/activity/intent-filter').attrib['android:label'] = manifest.short_name;",
        "path": "src/post-prepare.js",
        "position": null,
        "original_position": 14,
        "commit_id": "963e9d1725e6fa714e064b46e5d2257a73787c16",
        "original_commit_id": "42b03ae1830dbe0b0eae11430afeac5a81b1dbbf",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Would be better to change the value in res/values/strings.xml\n\nIt's a bit of a nitpick though, so feel free to just add a \"TODO: Change this in res/values/strings.xml instead\" comment here and I'll merge it in.\n",
        "created_at": "2014-08-06T17:26:01Z",
        "updated_at": "2014-08-06T18:11:20Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/258#discussion_r15888964",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/258",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15888964"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/258#discussion_r15888964"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/258"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15889542",
        "pull_request_review_id": null,
        "id": 15889542,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODg5NTQy",
        "diff_hunk": "@@ -217,10 +217,16 @@ function postPrepareInternal(platform) {\n     return require('./get-manifest')(root);\n   }).then(function(manifest) {\n     // Android\n-    if (platform === 'android' && manifest && manifest.versionCode) {\n+    if (platform === 'android' && manifest && (manifest.versionCode || manifest.short_name)) {\n       var androidManifestPath = path.join('platforms', 'android', 'AndroidManifest.xml');\n       var androidManifest = et.parse(fs.readFileSync(androidManifestPath, 'utf-8'));\n-      androidManifest.getroot().attrib[\"android:versionCode\"] = manifest.versionCode;\n+\n+      if (manifest.versionCode) {\n+        androidManifest.getroot().attrib[\"android:versionCode\"] = manifest.versionCode;\n+      }\n+      if (manifest.short_name) {\n+        androidManifest.find('./application/activity/intent-filter').attrib['android:label'] = manifest.short_name;",
        "path": "src/post-prepare.js",
        "position": null,
        "original_position": 14,
        "commit_id": "963e9d1725e6fa714e064b46e5d2257a73787c16",
        "original_commit_id": "42b03ae1830dbe0b0eae11430afeac5a81b1dbbf",
        "user": {
            "login": "beaufortfrancois",
            "id": 634478,
            "node_id": "MDQ6VXNlcjYzNDQ3OA==",
            "avatar_url": "https://avatars1.githubusercontent.com/u/634478?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/beaufortfrancois",
            "html_url": "https://github.com/beaufortfrancois",
            "followers_url": "https://api.github.com/users/beaufortfrancois/followers",
            "following_url": "https://api.github.com/users/beaufortfrancois/following{/other_user}",
            "gists_url": "https://api.github.com/users/beaufortfrancois/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/beaufortfrancois/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/beaufortfrancois/subscriptions",
            "organizations_url": "https://api.github.com/users/beaufortfrancois/orgs",
            "repos_url": "https://api.github.com/users/beaufortfrancois/repos",
            "events_url": "https://api.github.com/users/beaufortfrancois/events{/privacy}",
            "received_events_url": "https://api.github.com/users/beaufortfrancois/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I will update this to change the value in `res/values/strings.xml`.\nI wasn't sure it would conflict later.\n",
        "created_at": "2014-08-06T17:35:12Z",
        "updated_at": "2014-08-06T18:11:20Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/258#discussion_r15889542",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/258",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15889542"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/258#discussion_r15889542"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/258"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15938273",
        "pull_request_review_id": null,
        "id": 15938273,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1OTM4Mjcz",
        "diff_hunk": "@@ -4,18 +4,49 @@\n \n registerAutoTests('chrome.app.window', function() {\n   'use strict';\n+\n+  var customMatchers = {\n+    toBeArray : function(util, customEqualityTesters){\n+      return {\n+        compare : function(actual, expected){\n+          var result = {};\n+          result.pass = (actual instanceof Array);",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/auto/test.chrome.app.window.js",
        "position": 10,
        "original_position": 10,
        "commit_id": "f2863a806e563f394a35ca943082097a20f03261",
        "original_commit_id": "f2863a806e563f394a35ca943082097a20f03261",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: better to use Array.isArray(actual)\n",
        "created_at": "2014-08-07T14:26:45Z",
        "updated_at": "2014-08-07T14:26:45Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/261#discussion_r15938273",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/261",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/15938273"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/261#discussion_r15938273"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/261"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546705",
        "pull_request_review_id": null,
        "id": 16546705,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTQ2NzA1",
        "diff_hunk": "@@ -123,6 +123,10 @@ When using this plugin outside the context of a Chrome App, this information mus\n The [Google APIs Explorer](https://developers.google.com/apis-explorer/) is a useful tool for determining required scopes and testing various API use cases.\n \n # Release Notes\n+## 1.2.2 (Aug 2o, 2014)",
        "path": "chrome-cordova/plugins/chrome.identity/README.md",
        "position": null,
        "original_position": 13,
        "commit_id": "40982c54972b3ddc54fb5c3558e6a9db2dc402c3",
        "original_commit_id": "baa38fdc6918fea8599c7dccf18614b1197b6666",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Lets move the release notes to another commit.  Also the date is wrong.\n",
        "created_at": "2014-08-21T15:39:49Z",
        "updated_at": "2014-08-21T17:48:15Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546705",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546705"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546705"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546749",
        "pull_request_review_id": null,
        "id": 16546749,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTQ2NzQ5",
        "diff_hunk": "@@ -123,6 +123,10 @@ When using this plugin outside the context of a Chrome App, this information mus\n The [Google APIs Explorer](https://developers.google.com/apis-explorer/) is a useful tool for determining required scopes and testing various API use cases.\n \n # Release Notes\n+## 1.2.2 (Aug 2o, 2014)",
        "path": "chrome-cordova/plugins/chrome.identity/README.md",
        "position": null,
        "original_position": 13,
        "commit_id": "40982c54972b3ddc54fb5c3558e6a9db2dc402c3",
        "original_commit_id": "baa38fdc6918fea8599c7dccf18614b1197b6666",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "sorry, this was from a plugin publish yesterday i guess.  still split this out and land it first.\n",
        "created_at": "2014-08-21T15:40:34Z",
        "updated_at": "2014-08-21T17:48:15Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546749",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546749"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546749"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546805",
        "pull_request_review_id": null,
        "id": 16546805,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTQ2ODA1",
        "diff_hunk": "@@ -11,6 +11,9 @@ Stable on Android; not supported on iOS.\n The API reference is [here](http://developer.chrome.com/apps/notifications.html).\n \n # Release Notes\n+## 1.0.4 (April 1, 2014)",
        "path": "chrome-cordova/plugins/chrome.notifications/README.md",
        "position": null,
        "original_position": 4,
        "commit_id": "40982c54972b3ddc54fb5c3558e6a9db2dc402c3",
        "original_commit_id": "baa38fdc6918fea8599c7dccf18614b1197b6666",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "date?\n",
        "created_at": "2014-08-21T15:40:55Z",
        "updated_at": "2014-08-21T17:48:15Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546805",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546805"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546805"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546955",
        "pull_request_review_id": null,
        "id": 16546955,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTQ2OTU1",
        "diff_hunk": "@@ -29,6 +29,9 @@ In addition to the manfest changes for `chrome.identity`, you will need to add t\n * FileEntry.moveTo and FileEntry.copyTo do not trigger syncs.\n \n # Release Notes\n+## 0.1.3 (Aug 20, 2014)\n+- Change to new PluginManager",
        "path": "chrome-cordova/plugins/chrome.syncFileSystem/README.md",
        "position": null,
        "original_position": 5,
        "commit_id": "40982c54972b3ddc54fb5c3558e6a9db2dc402c3",
        "original_commit_id": "baa38fdc6918fea8599c7dccf18614b1197b6666",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "These release notes are for end users, not devs, I think.  So this change should be more like \"No external changes\" or \"Internal-only updates to support android platform changes\"\n",
        "created_at": "2014-08-21T15:43:04Z",
        "updated_at": "2014-08-21T17:48:15Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546955",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/16546955"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/288#discussion_r16546955"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/288"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17427261",
        "pull_request_review_id": null,
        "id": 17427261,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDI3MjYx",
        "diff_hunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.sockets.udp', function(rootEl, addButton) {\n+\n+  function sendTo(data, addr, port) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.send(createInfo.socketId, data, addr, port, function(result) {\n+          if (result < 0) {\n+            logger('send fail: ' + result);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          } else {\n+            logger('sendTo: success ' + port);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          }\n+        });\n+      });\n+    });\n+  }\n+\n+  function receiveErrorListener(info) {\n+    logger('RecvError on socket: ' + info.socketId);\n+    logger(info);\n+    chrome.sockets.udp.close(info.socketId);\n+  }\n+\n+  function receiveListener(info) {\n+    logger('Recv: success Data: ' +\n+           String.fromCharCode.apply(null, new Uint16Array(info.data)));",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.udp.js",
        "position": null,
        "original_position": 31,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't mind logging on failure, but we should remove the logs for success, since these are auto tests and when the log noise get high we tend to miss things.\n\nAlso, the `String.fromCharCode.apply` is subject to argument length limits.  If anyone changes to add a test for larger data, this will fail.\n",
        "created_at": "2014-09-11T15:21:05Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17427261",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17427261"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17427261"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17428204",
        "pull_request_review_id": null,
        "id": 17428204,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDI4MjA0",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<!--\n+  Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+  Use of this source code is governed by a BSD-style license that can be\n+  found in the LICENSE file.\n+-->\n+<plugin xmlns=\"http://cordova.apache.org/ns/plugins/1.0\"\n+    id=\"org.chromium.sockets.udp\"\n+    version=\"1.0.0\">\n+  <engines>\n+    <engine name=\"cordova\" version=\">=3.0.0\" />\n+  </engines>\n+\n+  <name>Chrome Apps Sockets UDP API</name>\n+\n+  <dependency id=\"org.chromium.common\" />\n+  <dependency id=\"org.chromium.iosSocketsHelper\" />",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/plugin.xml",
        "position": null,
        "original_position": 17,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Consider renaming the plugin \"iosSocketsCommon\"\n",
        "created_at": "2014-09-11T15:36:08Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17428204",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17428204"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17428204"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17428351",
        "pull_request_review_id": null,
        "id": 17428351,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDI4MzUx",
        "diff_hunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+var Event = require('org.chromium.common.events');\n+var exec = cordova.require('cordova/exec');\n+\n+var checkBufferSize = function(bufferSize) {\n+\n+    if (bufferSize === null)\n+        return;\n+\n+    if (bufferSize > 65535) {\n+        console.warn('The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.');",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/sockets.udp.js",
        "position": null,
        "original_position": 13,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This warning will not help users diagnose the problem.  Consider specifically saying that the buffer size exceeds the 65535 size limit.\n",
        "created_at": "2014-09-11T15:38:31Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17428351",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17428351"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17428351"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17428541",
        "pull_request_review_id": null,
        "id": 17428541,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDI4NTQx",
        "diff_hunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+var Event = require('org.chromium.common.events');\n+var exec = cordova.require('cordova/exec');\n+\n+var checkBufferSize = function(bufferSize) {\n+\n+    if (bufferSize === null)\n+        return;\n+\n+    if (bufferSize > 65535) {\n+        console.warn('The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.');",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/sockets.udp.js",
        "position": null,
        "original_position": 13,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Also, is this just a warning, or should it be an error?  What will happen on native side, will it just use the max?\n\nIf its an error, you could callback with an error code and set the message for `chrome.runtime.lastError`\n",
        "created_at": "2014-09-11T15:41:12Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17428541",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17428541"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17428541"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17432522",
        "pull_request_review_id": null,
        "id": 17432522,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDMyNTIy",
        "diff_hunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+var Event = require('org.chromium.common.events');\n+var exec = cordova.require('cordova/exec');\n+\n+var checkBufferSize = function(bufferSize) {\n+\n+    if (bufferSize === null)\n+        return;\n+\n+    if (bufferSize > 65535) {\n+        console.warn('The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.');",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/sockets.udp.js",
        "position": null,
        "original_position": 13,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is just a warning. The native side will just use the max for IPV4 and IPV6 if the buffer size exceed. I will update the warning message.\n\nlink to native side buffer checking:\nhttps://github.com/MobileChromeApps/mobile-chrome-apps/blob/32d143209771dc72b91dfed3fed84ef259acbcdf/chrome-cordova/plugins/chrome.sockets.udp/src/ios/ChromeSocketsUdp.m#L138\n",
        "created_at": "2014-09-11T16:52:28Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17432522",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17432522"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17432522"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436217",
        "pull_request_review_id": null,
        "id": 17436217,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDM2MjE3",
        "diff_hunk": "@@ -0,0 +1,249 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.sockets.udp', function(rootEl, addButton) {\n+\n+  function sendTo(data, addr, port) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.send(createInfo.socketId, data, addr, port, function(result) {\n+          if (result < 0) {\n+            logger('send fail: ' + result);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          } else {\n+            logger('sendTo: success ' + port);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          }\n+        });\n+      });\n+    });\n+  }\n+\n+  function receiveErrorListener(info) {\n+    logger('RecvError on socket: ' + info.socketId);\n+    logger(info);\n+    chrome.sockets.udp.close(info.socketId);\n+  }\n+\n+  function receiveListener(info) {\n+    logger('Recv: success Data: ' +\n+           String.fromCharCode.apply(null, new Uint16Array(info.data)));",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.udp.js",
        "position": null,
        "original_position": 31,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I have removed `String.fromCharCode.apply`, and do not log the received data.\n\nDo you mean we want remove all success loggings? This is manual tests, Let me know if you think it is necessary.\n",
        "created_at": "2014-09-11T17:50:09Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436217",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436217"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436217"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436227",
        "pull_request_review_id": null,
        "id": 17436227,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDM2MjI3",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<!--\n+  Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+  Use of this source code is governed by a BSD-style license that can be\n+  found in the LICENSE file.\n+-->\n+<plugin xmlns=\"http://cordova.apache.org/ns/plugins/1.0\"\n+    id=\"org.chromium.sockets.udp\"\n+    version=\"1.0.0\">\n+  <engines>\n+    <engine name=\"cordova\" version=\">=3.0.0\" />\n+  </engines>\n+\n+  <name>Chrome Apps Sockets UDP API</name>\n+\n+  <dependency id=\"org.chromium.common\" />\n+  <dependency id=\"org.chromium.iosSocketsHelper\" />",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/plugin.xml",
        "position": null,
        "original_position": 17,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "6b8ef0fe98b5e7f50ddf89bc6523a6a61d4e3069",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "done\n",
        "created_at": "2014-09-11T17:50:21Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436227",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436227"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436227"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436734",
        "pull_request_review_id": null,
        "id": 17436734,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDM2NzM0",
        "diff_hunk": "@@ -0,0 +1,41 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import <Foundation/Foundation.h>\n+#import <Cordova/CDVPlugin.h>\n+\n+@interface ChromeSocketsUdp : CDVPlugin\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView;\n+\n+- (void)create:(CDVInvokedUrlCommand*)command;\n+\n+- (void)update:(CDVInvokedUrlCommand*)command;\n+\n+- (void)setPaused:(CDVInvokedUrlCommand*)command;\n+\n+- (void)bind:(CDVInvokedUrlCommand*)command;\n+\n+- (void)send:(CDVInvokedUrlCommand*)command;\n+\n+- (void)close:(CDVInvokedUrlCommand*)command;\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command;\n+\n+- (void)getSockets:(CDVInvokedUrlCommand*)command;\n+\n+- (void)joinGroup:(CDVInvokedUrlCommand*)command;\n+\n+- (void)leaveGroup:(CDVInvokedUrlCommand*)command;\n+\n+- (void)setMulticastTimeToLive:(CDVInvokedUrlCommand*)command;\n+\n+- (void)setMulticastLoopbackMode:(CDVInvokedUrlCommand*)command;\n+\n+- (void)getJoinedGroups:(CDVInvokedUrlCommand*)command;\n+\n+- (void)registerReceiveEvents:(CDVInvokedUrlCommand*)command;\n+\n+- (void)fireReceiveEventsWithSocketId:(NSUInteger)theSocketId data:(NSData*)theData address:(NSString*)theAddress port:(NSUInteger)thePort;",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/src/ios/ChromeSocketsUdp.h",
        "position": 40,
        "original_position": 40,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "b3e61e10da61783e6794ea6b50cc7983c1c5dd9a",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is this a public method?\n",
        "created_at": "2014-09-11T17:57:48Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436734",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436734"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436734"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436983",
        "pull_request_review_id": null,
        "id": 17436983,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDM2OTgz",
        "diff_hunk": "@@ -0,0 +1,41 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import <Foundation/Foundation.h>\n+#import <Cordova/CDVPlugin.h>\n+\n+@interface ChromeSocketsUdp : CDVPlugin\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView;\n+\n+- (void)create:(CDVInvokedUrlCommand*)command;\n+\n+- (void)update:(CDVInvokedUrlCommand*)command;\n+\n+- (void)setPaused:(CDVInvokedUrlCommand*)command;\n+\n+- (void)bind:(CDVInvokedUrlCommand*)command;\n+\n+- (void)send:(CDVInvokedUrlCommand*)command;\n+\n+- (void)close:(CDVInvokedUrlCommand*)command;\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command;\n+\n+- (void)getSockets:(CDVInvokedUrlCommand*)command;\n+\n+- (void)joinGroup:(CDVInvokedUrlCommand*)command;\n+\n+- (void)leaveGroup:(CDVInvokedUrlCommand*)command;\n+\n+- (void)setMulticastTimeToLive:(CDVInvokedUrlCommand*)command;\n+\n+- (void)setMulticastLoopbackMode:(CDVInvokedUrlCommand*)command;\n+\n+- (void)getJoinedGroups:(CDVInvokedUrlCommand*)command;\n+\n+- (void)registerReceiveEvents:(CDVInvokedUrlCommand*)command;\n+\n+- (void)fireReceiveEventsWithSocketId:(NSUInteger)theSocketId data:(NSData*)theData address:(NSString*)theAddress port:(NSUInteger)thePort;",
        "path": "chrome-cordova/plugins/chrome.sockets.udp/src/ios/ChromeSocketsUdp.h",
        "position": 40,
        "original_position": 40,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "b3e61e10da61783e6794ea6b50cc7983c1c5dd9a",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, Used here: https://github.com/MobileChromeApps/mobile-chrome-apps/blob/32d143209771dc72b91dfed3fed84ef259acbcdf/chrome-cordova/plugins/chrome.sockets.udp/src/ios/ChromeSocketsUdp.m#L195\n\nWe can also use a block callback if don't want this be public.\n",
        "created_at": "2014-09-11T18:01:17Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436983",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17436983"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17436983"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17481277",
        "pull_request_review_id": null,
        "id": 17481277,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NDgxMjc3",
        "diff_hunk": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.sockets.udp', function(rootEl, addButton) {\n+\n+  function sendTo(data, addr, port) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.send(createInfo.socketId, data, addr, port, function(result) {\n+          if (result < 0) {\n+            logger('send fail: ' + result);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          } else {\n+            logger('sendTo: success ' + port);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          }\n+        });\n+      });\n+    });\n+  }\n+\n+  function receiveErrorListener(info) {\n+    logger('RecvError on socket: ' + info.socketId);\n+    chrome.sockets.udp.close(info.socketId);\n+  }\n+\n+  function receiveListener(info) {\n+    logger('Recv from socket: ');\n+    logger(info);\n+    chrome.sockets.udp.close(info.socketId);\n+  }\n+\n+  function addReceiveListeners() {\n+    chrome.sockets.udp.onReceiveError.addListener(receiveErrorListener);\n+    chrome.sockets.udp.onReceive.addListener(receiveListener);\n+  }\n+\n+  function removeReceiveListeners() {\n+    chrome.sockets.udp.onReceiveError.removeListener(receiveErrorListener);\n+    chrome.sockets.udp.onReceive.removeListener(receiveListener);\n+  }\n+\n+  function bindRecvFromSendTo(data) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+          sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+        });\n+      });\n+    });\n+  }\n+\n+  function bindRecvFromSendToWithBufferSize(data, bufferSize) {\n+    chrome.sockets.udp.create({bufferSize:bufferSize}, function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+          sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+        });\n+      });\n+    });\n+  }\n+\n+  function pauseBindRecvFromSendTo(data) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.setPaused(createInfo.socketId, true, function() {\n+        chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+          chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+            sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+          });\n+        });\n+      });\n+    });\n+  }\n+\n+  function bindPauseRecvFromSendTo(data) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.setPaused(createInfo.socketId, true, function() {\n+          chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+            sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+          });\n+        });\n+      });\n+    });\n+  }\n+\n+  function stringToArrayBuffer(string) {\n+    // UTF-16LE\n+    var buf = new ArrayBuffer(string.length * 2);\n+    var bufView = new Uint16Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function joinMulticastGroup(address, port, loopback) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.udp.js",
        "position": 98,
        "original_position": 98,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "bc080c15f41643d30110d7c0195e319f47a81e02",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This test seems to fail if I run it multiple times in a row.  I think its just the test, not the plugin, that needs fixing, because if I call closeSockets between runs it always works.\n",
        "created_at": "2014-09-12T14:27:46Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17481277",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17481277"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17481277"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17505651",
        "pull_request_review_id": null,
        "id": 17505651,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTA1NjUx",
        "diff_hunk": "@@ -0,0 +1,247 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.sockets.udp', function(rootEl, addButton) {\n+\n+  function sendTo(data, addr, port) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.send(createInfo.socketId, data, addr, port, function(result) {\n+          if (result < 0) {\n+            logger('send fail: ' + result);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          } else {\n+            logger('sendTo: success ' + port);\n+            chrome.sockets.udp.close(createInfo.socketId);\n+          }\n+        });\n+      });\n+    });\n+  }\n+\n+  function receiveErrorListener(info) {\n+    logger('RecvError on socket: ' + info.socketId);\n+    chrome.sockets.udp.close(info.socketId);\n+  }\n+\n+  function receiveListener(info) {\n+    logger('Recv from socket: ');\n+    logger(info);\n+    chrome.sockets.udp.close(info.socketId);\n+  }\n+\n+  function addReceiveListeners() {\n+    chrome.sockets.udp.onReceiveError.addListener(receiveErrorListener);\n+    chrome.sockets.udp.onReceive.addListener(receiveListener);\n+  }\n+\n+  function removeReceiveListeners() {\n+    chrome.sockets.udp.onReceiveError.removeListener(receiveErrorListener);\n+    chrome.sockets.udp.onReceive.removeListener(receiveListener);\n+  }\n+\n+  function bindRecvFromSendTo(data) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+          sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+        });\n+      });\n+    });\n+  }\n+\n+  function bindRecvFromSendToWithBufferSize(data, bufferSize) {\n+    chrome.sockets.udp.create({bufferSize:bufferSize}, function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+          sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+        });\n+      });\n+    });\n+  }\n+\n+  function pauseBindRecvFromSendTo(data) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.setPaused(createInfo.socketId, true, function() {\n+        chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+          chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+            sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+          });\n+        });\n+      });\n+    });\n+  }\n+\n+  function bindPauseRecvFromSendTo(data) {\n+    chrome.sockets.udp.create(function(createInfo) {\n+      chrome.sockets.udp.bind(createInfo.socketId, '0.0.0.0', 0, function(result) {\n+        chrome.sockets.udp.setPaused(createInfo.socketId, true, function() {\n+          chrome.sockets.udp.getInfo(createInfo.socketId, function(socketInfo) {\n+            sendTo(data, socketInfo.localAddress, socketInfo.localPort);\n+          });\n+        });\n+      });\n+    });\n+  }\n+\n+  function stringToArrayBuffer(string) {\n+    // UTF-16LE\n+    var buf = new ArrayBuffer(string.length * 2);\n+    var bufView = new Uint16Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function joinMulticastGroup(address, port, loopback) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.udp.js",
        "position": 98,
        "original_position": 98,
        "commit_id": "b1ee85a7525d2193d3a6ee1a46a01db37db945ac",
        "original_commit_id": "bc080c15f41643d30110d7c0195e319f47a81e02",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Found that `bindToPort...` will close the internal socket if failed; therefore, close delegate method won't be called, and the previous solution holds some bind error sockets forever. That explains why the `closeSockets` always works between runs. Fixed in f864223\n",
        "created_at": "2014-09-12T22:17:21Z",
        "updated_at": "2014-10-06T19:23:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17505651",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/17505651"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/313#discussion_r17505651"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/313"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18318681",
        "pull_request_review_id": null,
        "id": 18318681,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzE4Njgx",
        "diff_hunk": "@@ -241,21 +248,41 @@ private void send(CordovaArgs args, final CallbackContext callbackContext)\n     }\n \n     if (!socket.isConnected()) {\n-      Log.e(LOG_TAG, \"Socket is not connected with host \" + socketId);\n+      Log.e(LOG_TAG, \"Socket is not connected with hsot \" + socketId);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 45,
        "commit_id": "69212c1b8816fe1ef7a54d0aec9459de647c783b",
        "original_commit_id": "41058348f795345e636c393af73719b7cb722539",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "whoops\n",
        "created_at": "2014-10-02T01:23:14Z",
        "updated_at": "2014-10-10T15:05:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/348#discussion_r18318681",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/348",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18318681"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/348#discussion_r18318681"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/348"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18295311",
        "pull_request_review_id": null,
        "id": 18295311,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Mjk1MzEx",
        "diff_hunk": "@@ -0,0 +1,73 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@interface ChromeSystemCpu () {\n+    NSOperationQueue* _executor;\n+}\n+- (void)_getInfo:(CDVInvokedUrlCommand*)command;\n+@end\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _executor = [NSOperationQueue new];\n+        [_executor setMaxConcurrentOperationCount:1];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getOperatingSystemArch\n+{\n+    return @\"\";//System.getProperty(\"os.arch\");",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 33,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "13c149fc9ced0b9a0c33237e9d7a8d89252385e2",
        "user": {
            "login": "clelland",
            "id": 45853,
            "node_id": "MDQ6VXNlcjQ1ODUz",
            "avatar_url": "https://avatars2.githubusercontent.com/u/45853?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/clelland",
            "html_url": "https://github.com/clelland",
            "followers_url": "https://api.github.com/users/clelland/followers",
            "following_url": "https://api.github.com/users/clelland/following{/other_user}",
            "gists_url": "https://api.github.com/users/clelland/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/clelland/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clelland/subscriptions",
            "organizations_url": "https://api.github.com/users/clelland/orgs",
            "repos_url": "https://api.github.com/users/clelland/repos",
            "events_url": "https://api.github.com/users/clelland/events{/privacy}",
            "received_events_url": "https://api.github.com/users/clelland/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "What's up with this line? Does the getProperty call not work, or was it just temporarily disabled?\n",
        "created_at": "2014-10-01T17:51:37Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18295311",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18295311"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18295311"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18295393",
        "pull_request_review_id": null,
        "id": 18295393,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Mjk1Mzkz",
        "diff_hunk": "@@ -0,0 +1,73 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@interface ChromeSystemCpu () {\n+    NSOperationQueue* _executor;\n+}\n+- (void)_getInfo:(CDVInvokedUrlCommand*)command;\n+@end\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _executor = [NSOperationQueue new];\n+        [_executor setMaxConcurrentOperationCount:1];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getOperatingSystemArch\n+{\n+    return @\"\";//System.getProperty(\"os.arch\");\n+}\n+\n+- (NSNumber *)getProcessorCount\n+{\n+    return [NSNumber numberWithInt:[[NSProcessInfo processInfo] processorCount]];\n+}\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command\n+{\n+    NSInvocationOperation* operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(_getInfo:) object:command];\n+    [_executor addOperation:operation];\n+}\n+\n+- (void)_getInfo:(CDVInvokedUrlCommand*)command\n+{\n+    CDVPluginResult* pluginResult = nil;\n+\n+    @try {\n+\n+        NSMutableDictionary* info = [NSMutableDictionary dictionary];\n+\n+        //    JSONArray processors = getCpuTimePerProcessor();\n+    \n+        [info setValue:[self getOperatingSystemArch] forKey:@\"archName\"];\n+        //    ret.put(\"features\", getCpuFeatures());\n+        //    ret.put(\"modelName\", getCpuModelName());\n+        //    ret.put(\"processors\", processors);\n+        //    ret.put(\"numOfProcessors\", processors.length());",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 61,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "13c149fc9ced0b9a0c33237e9d7a8d89252385e2",
        "user": {
            "login": "clelland",
            "id": 45853,
            "node_id": "MDQ6VXNlcjQ1ODUz",
            "avatar_url": "https://avatars2.githubusercontent.com/u/45853?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/clelland",
            "html_url": "https://github.com/clelland",
            "followers_url": "https://api.github.com/users/clelland/followers",
            "following_url": "https://api.github.com/users/clelland/following{/other_user}",
            "gists_url": "https://api.github.com/users/clelland/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/clelland/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clelland/subscriptions",
            "organizations_url": "https://api.github.com/users/clelland/orgs",
            "repos_url": "https://api.github.com/users/clelland/repos",
            "events_url": "https://api.github.com/users/clelland/events{/privacy}",
            "received_events_url": "https://api.github.com/users/clelland/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is this Java code that was left in, but commented? (Also line 55 above)\n",
        "created_at": "2014-10-01T17:52:37Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18295393",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18295393"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18295393"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18296221",
        "pull_request_review_id": null,
        "id": 18296221,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Mjk2MjIx",
        "diff_hunk": "@@ -6,17 +6,21 @@\n -->\n <plugin xmlns=\"http://cordova.apache.org/ns/plugins/1.0\"\n     id=\"org.chromium.system.display\"\n-    version=\"1.0.1-dev\">\n+    version=\"1.0.2-dev\">",
        "path": "chrome-cordova/plugins/chrome.system.display/plugin.xml",
        "position": null,
        "original_position": 5,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "13c149fc9ced0b9a0c33237e9d7a8d89252385e2",
        "user": {
            "login": "clelland",
            "id": 45853,
            "node_id": "MDQ6VXNlcjQ1ODUz",
            "avatar_url": "https://avatars2.githubusercontent.com/u/45853?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/clelland",
            "html_url": "https://github.com/clelland",
            "followers_url": "https://api.github.com/users/clelland/followers",
            "following_url": "https://api.github.com/users/clelland/following{/other_user}",
            "gists_url": "https://api.github.com/users/clelland/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/clelland/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clelland/subscriptions",
            "organizations_url": "https://api.github.com/users/clelland/orgs",
            "repos_url": "https://api.github.com/users/clelland/repos",
            "events_url": "https://api.github.com/users/clelland/events{/privacy}",
            "received_events_url": "https://api.github.com/users/clelland/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'd vote for 1.1.0 here -- Adding iOS is pretty significant (more than a bug fix :), but still backwards-compatible with 1.0.1 (so doesn't need to be 2.0.0)\n",
        "created_at": "2014-10-01T18:03:06Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18296221",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18296221"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18296221"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18296557",
        "pull_request_review_id": null,
        "id": 18296557,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Mjk2NTU3",
        "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerAutoTests('chrome.system.cpu', function() {\n+  'use strict';\n+  \n+  var customMatchers = {\n+    toBeString : function(util, customEqualityTesters) {\n+      return {\n+        compare : function(actual, expected){\n+          var result = {};\n+          result.pass = (typeof actual === 'string');\n+          result.message = 'Expected ' + actual + ' to be a string.'; \n+          return result;\n+        }\n+      };\n+    },\n+\n+    toBeNumber : function(util, customEqualityTesters) {\n+      return {\n+        compare : function(actual, expected){\n+          var result = {};\n+          result.pass = (typeof actual === 'number');\n+          result.message = 'Expected ' + actual + ' to be a number.'; \n+          return result;\n+        }\n+      };\n+    },\n+    \n+    toBeArray : function(util, customEqualityTesters) {\n+      return {\n+        compare : function(actual, expected){\n+          var result = {};\n+          result.pass = (actual instanceof Array);\n+          result.message = 'Expected ' + actual + ' to be an array.'; \n+          return result;\n+        }\n+      };\n+    }\n+  };\n+  \n+  beforeEach(function(done) {\n+    addMatchers(customMatchers);\n+    done();\n+  });\n+  \n+  it('should have getInfo exist', function() {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/auto/test.chrome.system.cpu.js",
        "position": null,
        "original_position": 48,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "13c149fc9ced0b9a0c33237e9d7a8d89252385e2",
        "user": {
            "login": "clelland",
            "id": 45853,
            "node_id": "MDQ6VXNlcjQ1ODUz",
            "avatar_url": "https://avatars2.githubusercontent.com/u/45853?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/clelland",
            "html_url": "https://github.com/clelland",
            "followers_url": "https://api.github.com/users/clelland/followers",
            "following_url": "https://api.github.com/users/clelland/following{/other_user}",
            "gists_url": "https://api.github.com/users/clelland/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/clelland/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clelland/subscriptions",
            "organizations_url": "https://api.github.com/users/clelland/orgs",
            "repos_url": "https://api.github.com/users/clelland/repos",
            "events_url": "https://api.github.com/users/clelland/events{/privacy}",
            "received_events_url": "https://api.github.com/users/clelland/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "(Minor style preference)\nI'd probably put this inside of the `describe('getInfo')` block below, with a spec description of just \"should exist\". \"should have getInfo exist\" sounds odd to me :)\n",
        "created_at": "2014-10-01T18:07:20Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18296557",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18296557"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18296557"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18299053",
        "pull_request_review_id": null,
        "id": 18299053,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Mjk5MDUz",
        "diff_hunk": "@@ -0,0 +1,73 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@interface ChromeSystemCpu () {\n+    NSOperationQueue* _executor;\n+}\n+- (void)_getInfo:(CDVInvokedUrlCommand*)command;\n+@end\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _executor = [NSOperationQueue new];\n+        [_executor setMaxConcurrentOperationCount:1];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getOperatingSystemArch\n+{\n+    return @\"\";//System.getProperty(\"os.arch\");\n+}\n+\n+- (NSNumber *)getProcessorCount\n+{\n+    return [NSNumber numberWithInt:[[NSProcessInfo processInfo] processorCount]];\n+}\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command\n+{\n+    NSInvocationOperation* operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(_getInfo:) object:command];",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 43,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "13c149fc9ced0b9a0c33237e9d7a8d89252385e2",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Unlikely that you'd need to run this on a background thread, it'll probably run quite quickly.\nIf you _do_ want a background thread, use [self.commandDelegate runInBackground:^{ ... }];\n",
        "created_at": "2014-10-01T18:41:29Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18299053",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18299053"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18299053"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545797",
        "pull_request_review_id": null,
        "id": 18545797,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTQ1Nzk3",
        "diff_hunk": "@@ -0,0 +1,13 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.h",
        "position": null,
        "original_position": 1,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "For this and the others - Don't bother with a .h file since there are no useful symbols being exported. Just cut & paste the `@interface` into the .m file.\n",
        "created_at": "2014-10-07T20:17:34Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545797",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545797"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545797"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545846",
        "pull_request_review_id": null,
        "id": 18545846,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTQ1ODQ2",
        "diff_hunk": "@@ -4,7 +4,7 @@ This plugin provides the ability to query basic CPU information of the system.\n \n ## Status\n \n-Stable on Android; not yet supported on iOS.\n+Stable on Android, beta quality on iOS.",
        "path": "chrome-cordova/plugins/chrome.system.cpu/README.md",
        "position": null,
        "original_position": 5,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "What's missing for it to be stable on iOS?\n",
        "created_at": "2014-10-07T20:18:10Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545846",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545846"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545846"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545876",
        "pull_request_review_id": null,
        "id": 18545876,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTQ1ODc2",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 22,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This override doesn't change the behaviour at all. Delete it.\n",
        "created_at": "2014-10-07T20:18:38Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545876",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545876"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545876"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545934",
        "pull_request_review_id": null,
        "id": 18545934,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTQ1OTM0",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 32,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "From what I've been told, you should avoid exceptions in Obj-C (forget the rationale right now though).\n",
        "created_at": "2014-10-07T20:19:39Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545934",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545934"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545934"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545945",
        "pull_request_review_id": null,
        "id": 18545945,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTQ1OTQ1",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 32,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Actually, the usual pattern is to have an (NSError **)outError as a parameter that you set upon an error.\nhttp://stackoverflow.com/questions/11100951/nsexception-and-nserror-custom-exception-error\n",
        "created_at": "2014-10-07T20:19:52Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545945",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18545945"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18545945"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18591799",
        "pull_request_review_id": null,
        "id": 18591799,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTkxNzk5",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException\n+                                exceptionWithName:@\"InvalidOperationException\"\n+                                reason:[NSString stringWithFormat:@\"%@: %@\", reason, errMsg]\n+                                userInfo:nil];\n+    @throw myException;\n+}\n+\n+- (NSString*)getSysctlByName:(const char *)identifier\n+{\n+    size_t len;",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 41,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: Obj-C allows you to define variables not at the top of a block. Seeing uninitialized variables makes the code a bit harder to read (at least for me), so I'd just define them when assigned.\n\nSince len is an in-out, should initialize it to 0 I think.\n",
        "created_at": "2014-10-08T15:49:37Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18591799",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18591799"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18591799"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18592380",
        "pull_request_review_id": null,
        "id": 18592380,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTkyMzgw",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException\n+                                exceptionWithName:@\"InvalidOperationException\"\n+                                reason:[NSString stringWithFormat:@\"%@: %@\", reason, errMsg]\n+                                userInfo:nil];\n+    @throw myException;\n+}\n+\n+- (NSString*)getSysctlByName:(const char *)identifier\n+{\n+    size_t len;\n+    char *value;\n+    int ret;\n+    \n+    ret = sysctlbyname(identifier, NULL, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    value = malloc(len);\n+    ret = sysctlbyname(identifier, value, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    return @(value);",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 58,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is short for [NSString stringWithUTF8String:value]. Aka, a memory leak.\n\nYou could use [[NSString alloc] initWithBytesNoCopy:length:encoding:freeWhenDone:] instead, or free() the memory yourself.\n",
        "created_at": "2014-10-08T15:57:34Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18592380",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18592380"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18592380"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18592479",
        "pull_request_review_id": null,
        "id": 18592479,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTkyNDc5",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException\n+                                exceptionWithName:@\"InvalidOperationException\"\n+                                reason:[NSString stringWithFormat:@\"%@: %@\", reason, errMsg]\n+                                userInfo:nil];\n+    @throw myException;\n+}\n+\n+- (NSString*)getSysctlByName:(const char *)identifier\n+{\n+    size_t len;\n+    char *value;\n+    int ret;\n+    \n+    ret = sysctlbyname(identifier, NULL, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    value = malloc(len);\n+    ret = sysctlbyname(identifier, value, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    return @(value);\n+}\n+\n+- (void)getCpuNames:(NSMutableDictionary*)info typeKey:(NSString*)typeKey subTypeKey:(NSString*)subTypeKey\n+{\n+    host_basic_info_data_t hinfo;\n+    mach_msg_type_number_t count;\n+    char *cpu_type_name, *cpu_subtype_name;",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 65,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Initialize these pointers.\n",
        "created_at": "2014-10-08T15:58:46Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18592479",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18592479"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18592479"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18600929",
        "pull_request_review_id": null,
        "id": 18600929,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjAwOTI5",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException\n+                                exceptionWithName:@\"InvalidOperationException\"\n+                                reason:[NSString stringWithFormat:@\"%@: %@\", reason, errMsg]\n+                                userInfo:nil];\n+    @throw myException;\n+}\n+\n+- (NSString*)getSysctlByName:(const char *)identifier\n+{\n+    size_t len;\n+    char *value;\n+    int ret;\n+    \n+    ret = sysctlbyname(identifier, NULL, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    value = malloc(len);\n+    ret = sysctlbyname(identifier, value, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    return @(value);\n+}\n+\n+- (void)getCpuNames:(NSMutableDictionary*)info typeKey:(NSString*)typeKey subTypeKey:(NSString*)subTypeKey\n+{\n+    host_basic_info_data_t hinfo;\n+    mach_msg_type_number_t count;\n+    char *cpu_type_name, *cpu_subtype_name;\n+    \n+    count = HOST_BASIC_INFO_COUNT;\n+    kern_return_t kr = host_info(mach_host_self(),\n+                                 HOST_BASIC_INFO,\n+                                 (host_info_t)&hinfo,\n+                                 &count);\n+    \n+    if (kr != KERN_SUCCESS) {\n+        NSException* myException = [NSException\n+                                    exceptionWithName:@\"InvalidOperationException\"\n+                                    reason:@\"Failed to retrieve host info\"\n+                                    userInfo:nil];\n+        @throw myException;\n+    }\n+    \n+    \n+    // the slot_name() library function converts the specified\n+    // cpu_type/cpu_subtype pair to a human-readable form\n+    slot_name(hinfo.cpu_type, hinfo.cpu_subtype, &cpu_type_name,\n+              &cpu_subtype_name);\n+    \n+    [info setValue:@(cpu_type_name) forKey:typeKey];\n+    [info setValue:@(cpu_subtype_name) forKey:subTypeKey];\n+}\n+\n+- (NSArray*)getCpuFeatures\n+{\n+    NSMutableArray* ret = [NSMutableArray array];\n+    // This key is not supported on iOS apparently (although it is for Mac)\n+    // NSString* allFeatures = [self getSysctlByName:\"machdep.cpu.features\"];\n+    // Have yet to find other way to determine cpu features\n+    return ret;\n+}\n+\n+- (NSArray*)getCpuTimePerProcessor\n+{\n+    NSMutableArray* ret = [NSMutableArray array];\n+\n+    processor_info_array_t cpuInfo;\n+    mach_msg_type_number_t numCpuInfo;    \n+    natural_t numCPUs = 0U;\n+    \n+    kern_return_t err = host_processor_info(mach_host_self(),\n+                                            PROCESSOR_CPU_LOAD_INFO,\n+                                            &numCPUs,\n+                                            &cpuInfo,\n+                                            &numCpuInfo);\n+    if (err != KERN_SUCCESS) {\n+        NSException* myException = [NSException\n+                exceptionWithName:@\"InvalidOperationException\"\n+                reason:@\"Failed to retrieve host processor info\"\n+                userInfo:nil];\n+        @throw myException;\n+    }\n+\n+    for(unsigned i = 0U; i < numCPUs; ++i) {",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 121,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Should i be of type natural_t?\n",
        "created_at": "2014-10-08T18:10:06Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18600929",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18600929"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18600929"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18600992",
        "pull_request_review_id": null,
        "id": 18600992,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjAwOTky",
        "diff_hunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemCpu.h\"\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <mach/mach.h>\n+#include <mach/machine.h>\n+#include <mach/processor_info.h>\n+#include <mach/mach_host.h>\n+\n+#if CHROME_SYSTEM_CPU_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemCpu\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSError *)throwSystemCallFailed:(NSString *)reason\n+{\n+\tNSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];\n+\n+    NSException* myException = [NSException\n+                                exceptionWithName:@\"InvalidOperationException\"\n+                                reason:[NSString stringWithFormat:@\"%@: %@\", reason, errMsg]\n+                                userInfo:nil];\n+    @throw myException;\n+}\n+\n+- (NSString*)getSysctlByName:(const char *)identifier\n+{\n+    size_t len;\n+    char *value;\n+    int ret;\n+    \n+    ret = sysctlbyname(identifier, NULL, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    value = malloc(len);\n+    ret = sysctlbyname(identifier, value, &len, NULL, 0);\n+    if (ret != 0)\n+    {\n+        [self throwSystemCallFailed:[NSString stringWithFormat:@\"sysctlbyname('%s') failed\", identifier]];\n+    }\n+\n+    return @(value);\n+}\n+\n+- (void)getCpuNames:(NSMutableDictionary*)info typeKey:(NSString*)typeKey subTypeKey:(NSString*)subTypeKey\n+{\n+    host_basic_info_data_t hinfo;\n+    mach_msg_type_number_t count;\n+    char *cpu_type_name, *cpu_subtype_name;\n+    \n+    count = HOST_BASIC_INFO_COUNT;\n+    kern_return_t kr = host_info(mach_host_self(),\n+                                 HOST_BASIC_INFO,\n+                                 (host_info_t)&hinfo,\n+                                 &count);\n+    \n+    if (kr != KERN_SUCCESS) {\n+        NSException* myException = [NSException\n+                                    exceptionWithName:@\"InvalidOperationException\"\n+                                    reason:@\"Failed to retrieve host info\"\n+                                    userInfo:nil];\n+        @throw myException;\n+    }\n+    \n+    \n+    // the slot_name() library function converts the specified\n+    // cpu_type/cpu_subtype pair to a human-readable form\n+    slot_name(hinfo.cpu_type, hinfo.cpu_subtype, &cpu_type_name,\n+              &cpu_subtype_name);\n+    \n+    [info setValue:@(cpu_type_name) forKey:typeKey];\n+    [info setValue:@(cpu_subtype_name) forKey:subTypeKey];\n+}\n+\n+- (NSArray*)getCpuFeatures\n+{\n+    NSMutableArray* ret = [NSMutableArray array];\n+    // This key is not supported on iOS apparently (although it is for Mac)\n+    // NSString* allFeatures = [self getSysctlByName:\"machdep.cpu.features\"];\n+    // Have yet to find other way to determine cpu features\n+    return ret;\n+}\n+\n+- (NSArray*)getCpuTimePerProcessor\n+{\n+    NSMutableArray* ret = [NSMutableArray array];\n+\n+    processor_info_array_t cpuInfo;\n+    mach_msg_type_number_t numCpuInfo;    \n+    natural_t numCPUs = 0U;\n+    \n+    kern_return_t err = host_processor_info(mach_host_self(),\n+                                            PROCESSOR_CPU_LOAD_INFO,\n+                                            &numCPUs,\n+                                            &cpuInfo,\n+                                            &numCpuInfo);\n+    if (err != KERN_SUCCESS) {\n+        NSException* myException = [NSException\n+                exceptionWithName:@\"InvalidOperationException\"\n+                reason:@\"Failed to retrieve host processor info\"\n+                userInfo:nil];\n+        @throw myException;\n+    }\n+\n+    for(unsigned i = 0U; i < numCPUs; ++i) {\n+        float user, kernel, idle, total;\n+\n+        user = cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER];\n+        kernel = cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM];\n+        idle = cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];\n+        total = user + kernel + idle + cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE];\n+\n+        NSMutableDictionary* procStat = [NSMutableDictionary dictionary];",
        "path": "chrome-cordova/plugins/chrome.system.cpu/src/ios/ChromeSystemCpu.m",
        "position": null,
        "original_position": 129,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Use new-style obj-c dict would be nicer:\n\n```\nNSDictionary* procStat = @{\n    @\"user\": @(user),\n    ...\n};\n```\n",
        "created_at": "2014-10-08T18:11:02Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18600992",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18600992"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18600992"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18601153",
        "pull_request_review_id": null,
        "id": 18601153,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjAxMTUz",
        "diff_hunk": "@@ -0,0 +1,131 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemDisplay.h\"\n+#import <UIKit/UIScreen.h>\n+    \n+#if CHROME_SYSTEM_DISPLAY_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemDisplay\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+- (NSDictionary*) buildBoundsInfo:(CGRect)bounds scale:(CGFloat)scale\n+{\n+    NSMutableDictionary* boundsInfo = [NSMutableDictionary dictionary];\n+\n+    // Convert screen resolution from points to pixels\n+    CGSize screenSize = CGSizeMake(bounds.size.width * scale, bounds.size.height * scale);\n+\n+    [boundsInfo setValue:@(0) forKey:@\"left\"];\n+    [boundsInfo setValue:@(0) forKey:@\"top\"];\n+    [boundsInfo setValue:@(screenSize.width) forKey:@\"width\"];\n+    [boundsInfo setValue:@(screenSize.height) forKey:@\"height\"];\n+\n+    return boundsInfo;\n+}\n+\n+- (NSNumber*) getRotation:(UIScreen*)display",
        "path": "chrome-cordova/plugins/chrome.system.display/src/ios/ChromeSystemDisplay.m",
        "position": null,
        "original_position": 37,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Using \"get\" prefix in Obj-C doesn't follow their style-guides. Probably fine in our code (not worth changing), but FYI in Obj-C this should be called:\n\nrotationForDisplay:\n",
        "created_at": "2014-10-08T18:13:26Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18601153",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18601153"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18601153"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18601331",
        "pull_request_review_id": null,
        "id": 18601331,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjAxMzMx",
        "diff_hunk": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import \"ChromeSystemNetwork.h\"\n+#import <sys/types.h>\n+#import <ifaddrs.h> // For getifaddrs()\n+#import <net/if.h> // For IFF_LOOPBACK\n+#import <netinet/in.h> // For sockaddr_in\n+\n+#if CHROME_SYSTEM_NETWORK_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@implementation ChromeSystemNetwork\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView*)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    return self;\n+}\n+\n+-(NSString*)getIPAddress:(struct sockaddr *)ifa_addr family:(sa_family_t)family\n+{\n+    // IP address has different data structure, for IPv4 vs IPv6\n+    void* addressPointer;\n+    char addressBuffer[100];\n+    \n+    if (family == AF_INET6)\n+    {\n+        addressPointer = &((struct sockaddr_in6 *)ifa_addr)->sin6_addr;\n+    }\n+    else\n+    {\n+        addressPointer = &((struct sockaddr_in *)ifa_addr)->sin_addr;\n+    }\n+    inet_ntop(family, addressPointer, &addressBuffer, sizeof(addressBuffer));\n+    \n+    NSString* address = [NSString stringWithUTF8String:addressBuffer];\n+    \n+    // Strip address scope zones for IPv6 address.\n+    if (family == AF_INET6)\n+    {\n+        NSRange range = [address rangeOfString:@\"%\"];\n+        if (range.location != NSNotFound)\n+        {\n+            address = [address substringToIndex:range.location];\n+        }\n+    }\n+    \n+    return address;\n+}\n+\n+-(unsigned int)getPrefixLength:(struct sockaddr *)ifa_netmask family:(sa_family_t)family\n+{\n+    if (ifa_netmask == NULL)\n+    {\n+        return 0;\n+    }\n+    \n+    unsigned int prefixLength;",
        "path": "chrome-cordova/plugins/chrome.system.network/src/ios/ChromeSystemNetwork.m",
        "position": null,
        "original_position": 63,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: initialize to 0 here instead of within each condition block\n",
        "created_at": "2014-10-08T18:15:55Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18601331",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18601331"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18601331"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18654587",
        "pull_request_review_id": null,
        "id": 18654587,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjU0NTg3",
        "diff_hunk": "@@ -4,7 +4,7 @@ This plugin provides the ability to query basic CPU information of the system.\n \n ## Status\n \n-Stable on Android; not yet supported on iOS.\n+Stable on Android, beta quality on iOS.",
        "path": "chrome-cordova/plugins/chrome.system.cpu/README.md",
        "position": null,
        "original_position": 5,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "jpchase",
            "id": 544981,
            "node_id": "MDQ6VXNlcjU0NDk4MQ==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/544981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jpchase",
            "html_url": "https://github.com/jpchase",
            "followers_url": "https://api.github.com/users/jpchase/followers",
            "following_url": "https://api.github.com/users/jpchase/following{/other_user}",
            "gists_url": "https://api.github.com/users/jpchase/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jpchase/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jpchase/subscriptions",
            "organizations_url": "https://api.github.com/users/jpchase/orgs",
            "repos_url": "https://api.github.com/users/jpchase/repos",
            "events_url": "https://api.github.com/users/jpchase/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jpchase/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "There is no implementation to list the cpu features.  Of course, this is missing on Android as well.  After discussion, we decided that it's acceptable to leave the features un-implemented.  So, I'll mark it as stable on iOS.\n",
        "created_at": "2014-10-09T15:57:09Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18654587",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18654587"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18654587"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18655034",
        "pull_request_review_id": null,
        "id": 18655034,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjU1MDM0",
        "diff_hunk": "@@ -4,7 +4,7 @@ This plugin provides the ability to query basic CPU information of the system.\n \n ## Status\n \n-Stable on Android; not yet supported on iOS.\n+Stable on Android, beta quality on iOS.",
        "path": "chrome-cordova/plugins/chrome.system.cpu/README.md",
        "position": null,
        "original_position": 5,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "1cbea362e688758e8d4bf5ae9d7c3a804308c4d8",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Honestly, our use of the terms stable/beta/alpha suck anyway.  We should have a table that measures coverage, not quality.  Api is implemented \"fully\", \"mostly\", \"barely\", \"none\", or something like that.  Thats how other projects do it as well (i.e. http://clang.llvm.org/cxx_status.html)\n",
        "created_at": "2014-10-09T16:03:33Z",
        "updated_at": "2014-10-10T18:47:56Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18655034",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18655034"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18655034"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18729099",
        "pull_request_review_id": null,
        "id": 18729099,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NzI5MDk5",
        "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import <Cordova/CDVPlugin.h>\n+#import <Foundation/Foundation.h>\n+#import <UIKit/UIScreen.h>\n+    \n+#if CHROME_SYSTEM_DISPLAY_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@interface ChromeSystemDisplay : CDVPlugin\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command;\n+\n+@end\n+\n+@implementation ChromeSystemDisplay\n+\n+- (NSDictionary*) buildBoundsInfo:(CGRect)bounds scale:(CGFloat)scale\n+{\n+    // Convert screen resolution from points to pixels\n+    CGSize screenSize = CGSizeMake(bounds.size.width * scale, bounds.size.height * scale);\n+\n+    return @{\n+        @\"left\": @(0),\n+        @\"top\": @(0),\n+        @\"width\": @(screenSize.width),\n+        @\"height\": @(screenSize.height)\n+    };\n+}\n+\n+- (NSNumber*) rotationForDisplay:(UIScreen*)display\n+{\n+    //TODO: There should be a way to figure out the orientation, and thus the rotation\n+    return @(0);\n+}\n+\n+- (NSDictionary*) boundsForDisplay:(UIScreen*)display\n+{\n+    return [self buildBoundsInfo:[display bounds] scale:[display scale]];\n+}\n+\n+- (NSDictionary*) overscanForDisplay:(UIScreen*)display\n+{\n+    return @{\n+        @\"left\": @(0),\n+        @\"top\": @(0),\n+        @\"right\": @(0),\n+        @\"bottom\": @(0)\n+    };\n+}\n+\n+- (NSNumber*) dpiXForDisplay:(UIScreen*)display\n+{\n+    float scale = [display scale];\n+\n+    return [NSNumber numberWithFloat: scale * 160];",
        "path": "chrome-cordova/plugins/chrome.system.display/src/ios/ChromeSystemDisplay.m",
        "position": 61,
        "original_position": 61,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: add comment about why \\* 160.\n",
        "created_at": "2014-10-10T20:31:33Z",
        "updated_at": "2014-10-10T20:31:33Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18729099",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18729099"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18729099"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18729187",
        "pull_request_review_id": null,
        "id": 18729187,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NzI5MTg3",
        "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import <Cordova/CDVPlugin.h>\n+#import <Foundation/Foundation.h>\n+#import <UIKit/UIScreen.h>\n+    \n+#if CHROME_SYSTEM_DISPLAY_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@interface ChromeSystemDisplay : CDVPlugin\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command;\n+\n+@end\n+\n+@implementation ChromeSystemDisplay\n+\n+- (NSDictionary*) buildBoundsInfo:(CGRect)bounds scale:(CGFloat)scale\n+{\n+    // Convert screen resolution from points to pixels\n+    CGSize screenSize = CGSizeMake(bounds.size.width * scale, bounds.size.height * scale);\n+\n+    return @{\n+        @\"left\": @(0),\n+        @\"top\": @(0),\n+        @\"width\": @(screenSize.width),\n+        @\"height\": @(screenSize.height)\n+    };\n+}\n+\n+- (NSNumber*) rotationForDisplay:(UIScreen*)display\n+{\n+    //TODO: There should be a way to figure out the orientation, and thus the rotation\n+    return @(0);\n+}\n+\n+- (NSDictionary*) boundsForDisplay:(UIScreen*)display\n+{\n+    return [self buildBoundsInfo:[display bounds] scale:[display scale]];\n+}\n+\n+- (NSDictionary*) overscanForDisplay:(UIScreen*)display\n+{\n+    return @{\n+        @\"left\": @(0),\n+        @\"top\": @(0),\n+        @\"right\": @(0),\n+        @\"bottom\": @(0)\n+    };\n+}\n+\n+- (NSNumber*) dpiXForDisplay:(UIScreen*)display\n+{\n+    float scale = [display scale];\n+\n+    return [NSNumber numberWithFloat: scale * 160];\n+}\n+\n+- (NSNumber*) dpiYForDisplay:(UIScreen*)display\n+{\n+    float scale = [display scale];\n+    \n+    return [NSNumber numberWithFloat: scale * 160];\n+}\n+\n+- (NSDictionary*) workAreaForDisplay:(UIScreen*)display\n+{\n+    return [self buildBoundsInfo:[display applicationFrame] scale:[display scale]];\n+}\n+\n+- (NSDictionary*) getDisplayInfo:(UIScreen*)display displayIndex:(NSInteger)index mainDisplay:(UIScreen*)mainDisplay\n+{\n+    BOOL isPrimary = NO;\n+    NSString* name = @\"[unnamed]\";\n+    \n+    if (display == mainDisplay) {\n+        isPrimary = YES;\n+        name = @\"Built-in Screen\";\n+    }\n+\n+    return @{\n+        @\"id\": [@(index) stringValue],\n+        @\"name\": name,\n+        @\"isPrimary\": [NSNumber numberWithBool:isPrimary],\n+        @\"dpiX\": [self dpiXForDisplay:display],\n+        @\"dpiY\": [self dpiYForDisplay:display],\n+        @\"rotation\": [self rotationForDisplay:display],\n+        @\"bounds\": [self boundsForDisplay:display],\n+        @\"overscan\": [self overscanForDisplay:display],\n+        @\"workArea\": [self workAreaForDisplay:display]\n+    };\n+}\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command\n+{\n+    [self.commandDelegate runInBackground:^{\n+        CDVPluginResult* pluginResult = nil;\n+\n+        @try {",
        "path": "chrome-cordova/plugins/chrome.system.display/src/ios/ChromeSystemDisplay.m",
        "position": 104,
        "original_position": 104,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Probably don't need this try/catch now?\n",
        "created_at": "2014-10-10T20:33:29Z",
        "updated_at": "2014-10-10T20:33:29Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18729187",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18729187"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18729187"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18729286",
        "pull_request_review_id": null,
        "id": 18729286,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NzI5Mjg2",
        "diff_hunk": "@@ -4,7 +4,7 @@ This plugin provides the ability to retrieve information about local network ada\n \n ## Status\n \n-Stable on Android; not yet supported on iOS.\n+Stable on Android; beta quality on iOS.",
        "path": "chrome-cordova/plugins/chrome.system.network/README.md",
        "position": 5,
        "original_position": 5,
        "commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "original_commit_id": "85056f3b36bb4d35ec1726fe230fda5173d609ed",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Say in the comment why it's beta (what's missing).\n",
        "created_at": "2014-10-10T20:35:44Z",
        "updated_at": "2014-10-10T20:35:44Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18729286",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/18729286"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/346#discussion_r18729286"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/346"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19122878",
        "pull_request_review_id": null,
        "id": 19122878,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIyODc4",
        "diff_hunk": "@@ -70,6 +72,58 @@ registerManualTests('chrome.sockets.tcp', function(rootEl, addButton) {\n     });\n   }\n \n+  function stringToArrayBuffer(string) {\n+    var buf = new ArrayBuffer(string.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function connectSecureAndSend(data) {\n+    chrome.sockets.tcp.create(function(createInfo) {\n+      chrome.sockets.tcp.setPaused(createInfo.socketId, true, function() {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcp.js",
        "position": null,
        "original_position": 24,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: add a comment saying why we need to call setPaused here\n",
        "created_at": "2014-10-21T00:03:22Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19122878",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19122878"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19122878"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19122956",
        "pull_request_review_id": null,
        "id": 19122956,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIyOTU2",
        "diff_hunk": "@@ -70,6 +72,58 @@ registerManualTests('chrome.sockets.tcp', function(rootEl, addButton) {\n     });\n   }\n \n+  function stringToArrayBuffer(string) {\n+    var buf = new ArrayBuffer(string.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function connectSecureAndSend(data) {\n+    chrome.sockets.tcp.create(function(createInfo) {\n+      chrome.sockets.tcp.setPaused(createInfo.socketId, true, function() {\n+        var hostname = 'www.sslshopper.com';",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcp.js",
        "position": null,
        "original_position": 25,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: an even better test url would be: https://httpbin.org/get\n",
        "created_at": "2014-10-21T00:05:53Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19122956",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19122956"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19122956"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19122999",
        "pull_request_review_id": null,
        "id": 19122999,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIyOTk5",
        "diff_hunk": "@@ -70,6 +72,58 @@ registerManualTests('chrome.sockets.tcp', function(rootEl, addButton) {\n     });\n   }\n \n+  function stringToArrayBuffer(string) {\n+    var buf = new ArrayBuffer(string.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function connectSecureAndSend(data) {\n+    chrome.sockets.tcp.create(function(createInfo) {\n+      chrome.sockets.tcp.setPaused(createInfo.socketId, true, function() {\n+        var hostname = 'www.sslshopper.com';\n+        chrome.sockets.tcp.connect(createInfo.socketId, hostname, 443, function(result) {\n+          if (result === 0) {\n+              chrome.sockets.tcp.secure(\n+                createInfo.socketId,\n+                {tlsVersion: {min: 'ssl3', max: 'tls1.2'}},\n+                function(result) {\n+                  if (result !== 0) {\n+                    logger('secure connection failed: ' + result);\n+                  }\n+                  chrome.sockets.tcp.setPaused(createInfo.socketId, false, function() {\n+                    var requestString = 'GET / HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+                    var message = stringToArrayBuffer(requestString);\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcp.js",
        "position": null,
        "original_position": 39,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "why send it three times? add a comment and make each one log a different message.\n",
        "created_at": "2014-10-21T00:07:08Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19122999",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19122999"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19122999"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123022",
        "pull_request_review_id": null,
        "id": 19123022,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzMDIy",
        "diff_hunk": "@@ -70,6 +72,58 @@ registerManualTests('chrome.sockets.tcp', function(rootEl, addButton) {\n     });\n   }\n \n+  function stringToArrayBuffer(string) {\n+    var buf = new ArrayBuffer(string.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function connectSecureAndSend(data) {\n+    chrome.sockets.tcp.create(function(createInfo) {\n+      chrome.sockets.tcp.setPaused(createInfo.socketId, true, function() {\n+        var hostname = 'www.sslshopper.com';\n+        chrome.sockets.tcp.connect(createInfo.socketId, hostname, 443, function(result) {\n+          if (result === 0) {\n+              chrome.sockets.tcp.secure(\n+                createInfo.socketId,\n+                {tlsVersion: {min: 'ssl3', max: 'tls1.2'}},\n+                function(result) {\n+                  if (result !== 0) {\n+                    logger('secure connection failed: ' + result);\n+                  }\n+                  chrome.sockets.tcp.setPaused(createInfo.socketId, false, function() {\n+                    var requestString = 'GET / HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+                    var message = stringToArrayBuffer(requestString);\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                  });\n+                });\n+          }",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcp.js",
        "position": null,
        "original_position": 59,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Indenting is weird here. Should only ever need to out-dent by 2 spaces.\n",
        "created_at": "2014-10-21T00:07:38Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123022",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123022"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123022"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123063",
        "pull_request_review_id": null,
        "id": 19123063,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzMDYz",
        "diff_hunk": "@@ -25,8 +25,6 @@ registerManualTests('chrome.sockets.tcpServer', function(rootEl, addButton) {\n       chrome.sockets.tcp.send(info.clientSocketId, arr.buffer, function(result) {\n         if (result.resultCode === 0) {\n           logger('TCP send: success');\n-          chrome.sockets.tcp.disconnect(info.clientSocketId);",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcpServer.js",
        "position": 4,
        "original_position": 4,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "why not close sockets? \n",
        "created_at": "2014-10-21T00:08:38Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123063",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123063"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123063"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123074",
        "pull_request_review_id": null,
        "id": 19123074,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzMDc0",
        "diff_hunk": "@@ -70,6 +72,58 @@ registerManualTests('chrome.sockets.tcp', function(rootEl, addButton) {\n     });\n   }\n \n+  function stringToArrayBuffer(string) {\n+    var buf = new ArrayBuffer(string.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function connectSecureAndSend(data) {\n+    chrome.sockets.tcp.create(function(createInfo) {\n+      chrome.sockets.tcp.setPaused(createInfo.socketId, true, function() {\n+        var hostname = 'www.sslshopper.com';\n+        chrome.sockets.tcp.connect(createInfo.socketId, hostname, 443, function(result) {\n+          if (result === 0) {\n+              chrome.sockets.tcp.secure(\n+                createInfo.socketId,\n+                {tlsVersion: {min: 'ssl3', max: 'tls1.2'}},\n+                function(result) {\n+                  if (result !== 0) {\n+                    logger('secure connection failed: ' + result);\n+                  }\n+                  chrome.sockets.tcp.setPaused(createInfo.socketId, false, function() {\n+                    var requestString = 'GET / HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+                    var message = stringToArrayBuffer(requestString);\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcp.js",
        "position": null,
        "original_position": 51,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why not close sockets at the end?\n",
        "created_at": "2014-10-21T00:08:50Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123074",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123074"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123074"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123470",
        "pull_request_review_id": null,
        "id": 19123470,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzNDcw",
        "diff_hunk": "@@ -632,13 +697,159 @@ void disconnect() throws IOException {\n       channel.close();\n     }\n \n-    int send(byte[] data) throws IOException {\n-      return channel.write(ByteBuffer.wrap(data));\n+    /**\n+     * @return whether handshake has been finished.\n+     */\n+    boolean handshaking() throws IOException, JSONException {\n+      SSLEngineResult res;\n+      switch(sslEngine.getHandshakeStatus()) {\n+        case FINISHED:\n+          return false;\n+        case NEED_TASK:\n+          Runnable task;\n+          while((task = sslEngine.getDelegatedTask()) != null) {\n+            task.run();\n+          }\n+          return true;\n+        case NEED_UNWRAP:\n+          int bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead == -1) {\n+            handshakeFailed();\n+            return false;\n+          }\n+          sslPeerAppData.clear();\n+          sslPeerNetData.flip();\n+\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n+\n+          sslPeerAppData.flip();\n+          sslPeerNetData.compact();\n+          return true;\n+        case NEED_WRAP:\n+          ByteBuffer wrapData = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n+          res = sslEngine.wrap(ByteBuffer.allocate(0), wrapData);\n+          wrapData.flip();\n+          channel.write(wrapData);\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void handshakeFailed() {\n+      if (secureCallback != null) {\n+        secureCallback.error(-1000);\n+        secureCallback = null;\n+      }\n+      tearDownSSLEngine();\n+    }\n+\n+    void handshakeSuccess() {\n+      if (secureCallback != null) {\n+        secureCallback.success();\n+        secureCallback = null;\n+      }\n+    }\n+\n+    boolean shouldRedoUnwrap(SSLEngineResult res) {\n+      switch (res.getStatus()) {\n+        case BUFFER_OVERFLOW:\n+          increaseSSLAppBuffer();\n+          return true;\n+        case BUFFER_UNDERFLOW:\n+          if (sslPeerNetData.capacity() < sslEngine.getSession().getPacketBufferSize())\n+            increaseSSLNetBuffer();\n+          return false;\n+        case OK:\n+          return res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP &&\n+              res.bytesProduced() == 0;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    boolean shouldRedoWrap(SSLEngineResult res) {\n+      switch (res.getStatus()) {\n+        case BUFFER_OVERFLOW:\n+          increaseSSLNetBuffer();\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void increaseSSLAppBuffer() {\n+      ByteBuffer newBuffer = ByteBuffer.allocate(",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 299,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "add a comment stating & justifying the growth algorithm used here\n",
        "created_at": "2014-10-21T00:19:35Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123470",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123470"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123470"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123689",
        "pull_request_review_id": null,
        "id": 19123689,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzNjg5",
        "diff_hunk": "@@ -632,13 +697,159 @@ void disconnect() throws IOException {\n       channel.close();\n     }\n \n-    int send(byte[] data) throws IOException {\n-      return channel.write(ByteBuffer.wrap(data));\n+    /**\n+     * @return whether handshake has been finished.\n+     */\n+    boolean handshaking() throws IOException, JSONException {\n+      SSLEngineResult res;\n+      switch(sslEngine.getHandshakeStatus()) {\n+        case FINISHED:\n+          return false;\n+        case NEED_TASK:\n+          Runnable task;\n+          while((task = sslEngine.getDelegatedTask()) != null) {\n+            task.run();\n+          }\n+          return true;\n+        case NEED_UNWRAP:\n+          int bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead == -1) {\n+            handshakeFailed();\n+            return false;\n+          }\n+          sslPeerAppData.clear();\n+          sslPeerNetData.flip();\n+\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n+\n+          sslPeerAppData.flip();\n+          sslPeerNetData.compact();\n+          return true;\n+        case NEED_WRAP:\n+          ByteBuffer wrapData = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n+          res = sslEngine.wrap(ByteBuffer.allocate(0), wrapData);\n+          wrapData.flip();\n+          channel.write(wrapData);\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void handshakeFailed() {\n+      if (secureCallback != null) {\n+        secureCallback.error(-1000);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 258,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Unless this is really the code used by desktop, you should use a different code for each error case. You probably also should use: https://github.com/MobileChromeApps/mobile-chrome-apps/blob/5c52c0f47514af3c744f80115818414e9df5f52d/chrome-cordova/plugins/chrome-common/errors.js\nto set chrome.runtime.lastError to a string message saying what went wrong.\n",
        "created_at": "2014-10-21T00:25:50Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123689",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123689"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123689"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123735",
        "pull_request_review_id": null,
        "id": 19123735,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzNzM1",
        "diff_hunk": "@@ -632,13 +697,159 @@ void disconnect() throws IOException {\n       channel.close();\n     }\n \n-    int send(byte[] data) throws IOException {\n-      return channel.write(ByteBuffer.wrap(data));\n+    /**\n+     * @return whether handshake has been finished.\n+     */\n+    boolean handshaking() throws IOException, JSONException {\n+      SSLEngineResult res;\n+      switch(sslEngine.getHandshakeStatus()) {\n+        case FINISHED:\n+          return false;\n+        case NEED_TASK:\n+          Runnable task;\n+          while((task = sslEngine.getDelegatedTask()) != null) {\n+            task.run();\n+          }\n+          return true;\n+        case NEED_UNWRAP:\n+          int bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead == -1) {\n+            handshakeFailed();\n+            return false;\n+          }\n+          sslPeerAppData.clear();\n+          sslPeerNetData.flip();\n+\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n+\n+          sslPeerAppData.flip();\n+          sslPeerNetData.compact();",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 243,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nit: Is compact() necessary here? Probably just causes an unnecessary copy...\n",
        "created_at": "2014-10-21T00:27:16Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123735",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123735"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123735"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123841",
        "pull_request_review_id": null,
        "id": 19123841,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzODQx",
        "diff_hunk": "@@ -414,6 +459,17 @@ private void processPendingMessages() {\n               if (msg.callbackContext != null)\n                 msg.callbackContext.success();\n               break;\n+            case SSL_INIT_HANDSHAKE:\n+              msg.socket.setUpSSLEngine();\n+              while(msg.socket.handshaking());",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 116,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This looks like a busy loop since it's one line and the method name seems like a getter. Suggestion:\n    boolean hasWork = true;\n    while(hasWork) {\n      hasWork = msg.socket.performNextHandshakeStep();\n    }\n",
        "created_at": "2014-10-21T00:30:05Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123841",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123841"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123841"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123888",
        "pull_request_review_id": null,
        "id": 19123888,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzODg4",
        "diff_hunk": "@@ -227,6 +242,35 @@ private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n     }\n   }\n \n+  private void secure(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    int socketId = args.getInt(0);\n+    JSONObject options = args.getJSONObject(1);\n+\n+    TcpSocket socket = sockets.get(Integer.valueOf(socketId));\n+\n+    if (socket == null) {\n+      Log.e(LOG_TAG, \"No socket with socketId \" + socketId);\n+      callbackContext.error(-1000);\n+      return;\n+    }\n+\n+    if (!socket.isConnected()) {\n+      Log.e(LOG_TAG, \"Socket is not connected with host \" + socketId);\n+      callbackContext.error(-1000);\n+      return;\n+    }\n+\n+    socket.secure(options, callbackContext);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 65,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Don't pass a JSONObject to implementation methods. Much better to extract any needed args here and pass them in explicitly.\n",
        "created_at": "2014-10-21T00:31:13Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123888",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123888"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123888"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123931",
        "pull_request_review_id": null,
        "id": 19123931,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzOTMx",
        "diff_hunk": "@@ -136,6 +143,14 @@ private void setPaused(CordovaArgs args, final CallbackContext callbackContext)\n     }\n \n     socket.setPaused(paused);\n+    if (!paused) {\n+      try {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 32,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: This block of code is repeated a bunch - make a helper? `addSelectorMessage(socket, TYPE, null);`\n",
        "created_at": "2014-10-21T00:32:42Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123931",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123931"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123931"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123992",
        "pull_request_review_id": null,
        "id": 19123992,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTIzOTky",
        "diff_hunk": "@@ -632,13 +697,159 @@ void disconnect() throws IOException {\n       channel.close();\n     }\n \n-    int send(byte[] data) throws IOException {\n-      return channel.write(ByteBuffer.wrap(data));\n+    /**\n+     * @return whether handshake has been finished.\n+     */\n+    boolean handshaking() throws IOException, JSONException {\n+      SSLEngineResult res;\n+      switch(sslEngine.getHandshakeStatus()) {\n+        case FINISHED:\n+          return false;\n+        case NEED_TASK:\n+          Runnable task;\n+          while((task = sslEngine.getDelegatedTask()) != null) {\n+            task.run();\n+          }\n+          return true;\n+        case NEED_UNWRAP:\n+          int bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead == -1) {\n+            handshakeFailed();\n+            return false;\n+          }\n+          sslPeerAppData.clear();\n+          sslPeerNetData.flip();\n+\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n+\n+          sslPeerAppData.flip();\n+          sslPeerNetData.compact();\n+          return true;\n+        case NEED_WRAP:\n+          ByteBuffer wrapData = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n+          res = sslEngine.wrap(ByteBuffer.allocate(0), wrapData);\n+          wrapData.flip();\n+          channel.write(wrapData);\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void handshakeFailed() {\n+      if (secureCallback != null) {\n+        secureCallback.error(-1000);\n+        secureCallback = null;\n+      }\n+      tearDownSSLEngine();\n+    }\n+\n+    void handshakeSuccess() {\n+      if (secureCallback != null) {\n+        secureCallback.success();\n+        secureCallback = null;\n+      }\n+    }\n+\n+    boolean shouldRedoUnwrap(SSLEngineResult res) {\n+      switch (res.getStatus()) {\n+        case BUFFER_OVERFLOW:\n+          increaseSSLAppBuffer();\n+          return true;\n+        case BUFFER_UNDERFLOW:\n+          if (sslPeerNetData.capacity() < sslEngine.getSession().getPacketBufferSize())\n+            increaseSSLNetBuffer();\n+          return false;\n+        case OK:\n+          return res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP &&\n+              res.bytesProduced() == 0;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    boolean shouldRedoWrap(SSLEngineResult res) {\n+      switch (res.getStatus()) {\n+        case BUFFER_OVERFLOW:\n+          increaseSSLNetBuffer();\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void increaseSSLAppBuffer() {\n+      ByteBuffer newBuffer = ByteBuffer.allocate(\n+          sslEngine.getSession().getApplicationBufferSize() +\n+          sslPeerAppData.position());\n+      sslPeerAppData.flip();\n+      newBuffer.put(sslPeerAppData);\n+      sslPeerAppData = newBuffer;\n+    }\n+\n+    void increaseSSLNetBuffer() {\n+      ByteBuffer newBuffer = ByteBuffer.allocate(\n+          sslEngine.getSession().getPacketBufferSize() +\n+          sslPeerNetData.position());\n+      sslPeerNetData.flip();\n+      newBuffer.put(sslPeerNetData);\n+      sslPeerNetData = newBuffer;\n+    }\n+\n+    void setUpSSLEngine() throws JSONException {\n+      try {\n+        sslEngine = SSLContext.getDefault().createSSLEngine();\n+        sslEngine.setUseClientMode(true);\n+        sslPeerNetData = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n+        sslNetData = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n+        sslPeerAppData = ByteBuffer.allocate(sslEngine.getSession().getApplicationBufferSize());\n+\n+        String minVersion = \"\";\n+        String maxVersion = \"\";\n+        if (sslOptions != null && !sslOptions.isNull(\"tlsVersion\")) {\n+          JSONObject tlsVersion = sslOptions.getJSONObject(\"tlsVersion\");\n+\n+          if (!tlsVersion.isNull(\"min\")) {\n+            minVersion = tlsVersion.getString(\"min\");\n+          }\n+\n+          if (!tlsVersion.isNull(\"max\")) {\n+            maxVersion = tlsVersion.getString(\"max\");\n+          }\n+        }\n+\n+        if (minVersion.startsWith(\"tls\")) {\n+          sslEngine.setEnabledProtocols(new String[] {\"TLSv1\"});\n+        }\n+\n+        if (maxVersion.startsWith(\"ssl\")) {\n+          sslEngine.setEnabledProtocols(new String[] {\"SSLv3\"});\n+        }\n+\n+        sslEngine.beginHandshake();\n+      } catch (SSLException e) {\n+        handshakeFailed();\n+      } catch (NoSuchAlgorithmException e) {\n+        handshakeFailed();\n+      }\n+    }\n+\n+    void tearDownSSLEngine() {\n+      sslEngine = null;\n+    }\n+\n+    void secure(JSONObject options, CallbackContext callbackContext) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 358,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "intention of method is not obvious from its name. Suggestion: setSecureCallbackAndOptions()\n",
        "created_at": "2014-10-21T00:35:12Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123992",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19123992"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19123992"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124123",
        "pull_request_review_id": null,
        "id": 19124123,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0MTIz",
        "diff_hunk": "@@ -136,6 +143,14 @@ private void setPaused(CordovaArgs args, final CallbackContext callbackContext)\n     }\n \n     socket.setPaused(paused);\n+    if (!paused) {\n+      try {\n+        selectorMessages.put(new SelectorMessage(\n+            socket, SelectorMessageType.SO_ADD_READ_INTEREST, null));",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 34,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why not remove the interest here as well (in the opposite case)? Add a comment if there's a reason.\n",
        "created_at": "2014-10-21T00:40:25Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124123",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124123"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124123"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124245",
        "pull_request_review_id": null,
        "id": 19124245,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0MjQ1",
        "diff_hunk": "@@ -688,33 +915,40 @@ JSONObject getInfo() throws JSONException {\n     int read() throws JSONException {\n \n       int bytesRead = 0;\n-      if (paused) return bytesRead;\n-\n-      ByteBuffer recvBuffer = ByteBuffer.allocate(bufferSize);\n-      recvBuffer.clear();\n+      if (paused) {\n+        removeInterestSet(SelectionKey.OP_READ);\n+        return bytesRead;",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 429,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "add a comment saying what will happen by doing this.\n",
        "created_at": "2014-10-21T00:44:26Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124245",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124245"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124245"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124276",
        "pull_request_review_id": null,
        "id": 19124276,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0Mjc2",
        "diff_hunk": "@@ -688,33 +915,40 @@ JSONObject getInfo() throws JSONException {\n     int read() throws JSONException {\n \n       int bytesRead = 0;\n-      if (paused) return bytesRead;\n-\n-      ByteBuffer recvBuffer = ByteBuffer.allocate(bufferSize);\n-      recvBuffer.clear();\n+      if (paused) {\n+        removeInterestSet(SelectionKey.OP_READ);\n+        return bytesRead;\n+      }\n \n       try {\n-        bytesRead = channel.read(recvBuffer);\n-        if (bytesRead < 0) {\n-          sendReceiveError();\n-          return bytesRead;\n-        }\n-        recvBuffer.flip();\n-        byte[] recvBytes = new byte[recvBuffer.limit()];\n-        recvBuffer.get(recvBytes);\n+        if (sslEngine != null) {\n+          bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead < 0)\n+            return bytesRead;\n \n-        PluginResult dataResult = new PluginResult(Status.OK, recvBytes);\n-        dataResult.setKeepCallback(true);\n+          sslPeerNetData.flip();\n \n-        recvContext.sendPluginResult(dataResult);\n+          SSLEngineResult res;\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n \n-        JSONObject metadata = new JSONObject();\n+          if (res.getStatus() == SSLEngineResult.Status.OK) {\n+            sslPeerAppData.flip();\n+            sendReceive(sslPeerAppData);\n+          }\n \n-        metadata.put(\"socketId\", socketId);\n-        PluginResult metadataResult = new PluginResult(Status.OK, metadata);\n-        metadataResult.setKeepCallback(true);\n+          sslPeerNetData.compact();",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 465,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Necessary?\n",
        "created_at": "2014-10-21T00:45:12Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124276",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124276"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124276"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124337",
        "pull_request_review_id": null,
        "id": 19124337,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0MzM3",
        "diff_hunk": "@@ -688,33 +915,40 @@ JSONObject getInfo() throws JSONException {\n     int read() throws JSONException {\n \n       int bytesRead = 0;\n-      if (paused) return bytesRead;\n-\n-      ByteBuffer recvBuffer = ByteBuffer.allocate(bufferSize);\n-      recvBuffer.clear();\n+      if (paused) {\n+        removeInterestSet(SelectionKey.OP_READ);\n+        return bytesRead;\n+      }\n \n       try {\n-        bytesRead = channel.read(recvBuffer);\n-        if (bytesRead < 0) {\n-          sendReceiveError();\n-          return bytesRead;\n-        }\n-        recvBuffer.flip();\n-        byte[] recvBytes = new byte[recvBuffer.limit()];\n-        recvBuffer.get(recvBytes);\n+        if (sslEngine != null) {\n+          bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead < 0)\n+            return bytesRead;\n \n-        PluginResult dataResult = new PluginResult(Status.OK, recvBytes);\n-        dataResult.setKeepCallback(true);\n+          sslPeerNetData.flip();\n \n-        recvContext.sendPluginResult(dataResult);\n+          SSLEngineResult res;\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n \n-        JSONObject metadata = new JSONObject();\n+          if (res.getStatus() == SSLEngineResult.Status.OK) {\n+            sslPeerAppData.flip();\n+            sendReceive(sslPeerAppData);\n+          }\n \n-        metadata.put(\"socketId\", socketId);\n-        PluginResult metadataResult = new PluginResult(Status.OK, metadata);\n-        metadataResult.setKeepCallback(true);\n+          sslPeerNetData.compact();\n+          sslPeerAppData.clear();\n+        } else {\n+          ByteBuffer recvData = ByteBuffer.allocate(bufferSize);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 468,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Can we share the sslPeerNetData buffer for use here as well? e.g. receiveDataBuffer\n",
        "created_at": "2014-10-21T00:47:16Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124337",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124337"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124337"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124360",
        "pull_request_review_id": null,
        "id": 19124360,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0MzYw",
        "diff_hunk": "@@ -722,6 +956,22 @@ int read() throws JSONException {\n       return bytesRead;\n     }\n \n+    private void sendReceive(ByteBuffer data) throws JSONException {\n+\n+      byte[] recvBytes = new byte[data.limit()];",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 486,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Add a TODO here to avoid this copy by creating a new PluginResult overload\n",
        "created_at": "2014-10-21T00:48:20Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124360",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124360"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124360"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124446",
        "pull_request_review_id": null,
        "id": 19124446,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0NDQ2",
        "diff_hunk": "@@ -354,6 +368,56 @@ - (void)disconnect:(CDVInvokedUrlCommand*)command\n     [self disconnectSocketWithId:socketId callbackId:command.callbackId close:NO];\n }\n \n+- (NSNumber*)getSecureVersion:(NSString*)versionString\n+{\n+    if ([versionString isEqualToString:@\"ssl3\"]) {\n+        return [NSNumber numberWithInt:kSSLProtocol3];\n+    } else if ([versionString isEqualToString:@\"tls1\"]) {\n+        return [NSNumber numberWithInt:kTLSProtocol1];\n+    } else if ([versionString isEqualToString:@\"tls1.1\"]) {\n+        return [NSNumber numberWithInt:kTLSProtocol11];\n+    } else if ([versionString isEqualToString:@\"tls1.2\"]) {\n+        return [NSNumber numberWithInt:kTLSProtocol12];\n+    } else {\n+        return nil;\n+    }\n+}\n+\n+- (void)secure:(CDVInvokedUrlCommand *)command\n+{\n+    NSNumber* socketId = [command argumentAtIndex:0];\n+    NSDictionary* options = [command argumentAtIndex:1];\n+    \n+    ChromeSocketsTcpSocket* socket = [_sockets objectForKey:socketId];",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/ios/ChromeSocketsTcp.m",
        "position": null,
        "original_position": 68,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nit: Use newer&nicer syntax:   = _sockets[socketId];\n",
        "created_at": "2014-10-21T00:51:17Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124446",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124446"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124446"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124468",
        "pull_request_review_id": null,
        "id": 19124468,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTI0NDY4",
        "diff_hunk": "@@ -354,6 +368,56 @@ - (void)disconnect:(CDVInvokedUrlCommand*)command\n     [self disconnectSocketWithId:socketId callbackId:command.callbackId close:NO];\n }\n \n+- (NSNumber*)getSecureVersion:(NSString*)versionString\n+{\n+    if ([versionString isEqualToString:@\"ssl3\"]) {\n+        return [NSNumber numberWithInt:kSSLProtocol3];\n+    } else if ([versionString isEqualToString:@\"tls1\"]) {\n+        return [NSNumber numberWithInt:kTLSProtocol1];\n+    } else if ([versionString isEqualToString:@\"tls1.1\"]) {\n+        return [NSNumber numberWithInt:kTLSProtocol11];\n+    } else if ([versionString isEqualToString:@\"tls1.2\"]) {\n+        return [NSNumber numberWithInt:kTLSProtocol12];\n+    } else {\n+        return nil;\n+    }\n+}\n+\n+- (void)secure:(CDVInvokedUrlCommand *)command\n+{\n+    NSNumber* socketId = [command argumentAtIndex:0];\n+    NSDictionary* options = [command argumentAtIndex:1];\n+    \n+    ChromeSocketsTcpSocket* socket = [_sockets objectForKey:socketId];\n+    \n+    if (socket == nil) {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsInt:ENOTSOCK] callbackId:command.callbackId];\n+        return;\n+    }\n+ \n+    socket->_secureCallback = [^() {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK] callbackId:command.callbackId];\n+    } copy];\n+  \n+    NSMutableDictionary* settings = [NSMutableDictionary dictionaryWithCapacity:2];\n+    \n+    NSDictionary* tlsVersion = [options objectForKey:@\"tlsVersion\"];\n+    if (tlsVersion) {\n+        NSNumber* minVersion = [self getSecureVersion:[tlsVersion objectForKey:@\"min\"]];\n+        NSNumber* maxVersion = [self getSecureVersion:[tlsVersion objectForKey:@\"max\"]];\n+        \n+        if (minVersion) {\n+            [settings setObject:minVersion forKey:GCDAsyncSocketSSLProtocolVersionMin];\n+        }\n+        \n+        if (maxVersion) {\n+            [settings setObject:maxVersion forKey:GCDAsyncSocketSSLProtocolVersionMax];\n+        }\n+    }\n+    \n+    [socket->_socket startTLS:settings];",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/ios/ChromeSocketsTcp.m",
        "position": null,
        "original_position": 95,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "well this is a bit more concise than the java implementation... :+1: \n",
        "created_at": "2014-10-21T00:51:55Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124468",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19124468"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19124468"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19148808",
        "pull_request_review_id": null,
        "id": 19148808,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTQ4ODA4",
        "diff_hunk": "@@ -70,6 +72,58 @@ registerManualTests('chrome.sockets.tcp', function(rootEl, addButton) {\n     });\n   }\n \n+  function stringToArrayBuffer(string) {\n+    var buf = new ArrayBuffer(string.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = string.length; i < strLen; i++) {\n+      bufView[i] = string.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  function connectSecureAndSend(data) {\n+    chrome.sockets.tcp.create(function(createInfo) {\n+      chrome.sockets.tcp.setPaused(createInfo.socketId, true, function() {\n+        var hostname = 'www.sslshopper.com';\n+        chrome.sockets.tcp.connect(createInfo.socketId, hostname, 443, function(result) {\n+          if (result === 0) {\n+              chrome.sockets.tcp.secure(\n+                createInfo.socketId,\n+                {tlsVersion: {min: 'ssl3', max: 'tls1.2'}},\n+                function(result) {\n+                  if (result !== 0) {\n+                    logger('secure connection failed: ' + result);\n+                  }\n+                  chrome.sockets.tcp.setPaused(createInfo.socketId, false, function() {\n+                    var requestString = 'GET / HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+                    var message = stringToArrayBuffer(requestString);\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {\n+                      if (result.resultCode === 0) {\n+                        logger('connectSecureAndSend: success');\n+                      }\n+                    });\n+\n+                    chrome.sockets.tcp.send(createInfo.socketId, message, function(result) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.sockets.tcp.js",
        "position": null,
        "original_position": 51,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We need to wait for the receive events. We have a `closeAllSockets` method to close all pending sockets. We also close sockets when receive events raise.\n",
        "created_at": "2014-10-21T13:54:58Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19148808",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19148808"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19148808"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19149100",
        "pull_request_review_id": null,
        "id": 19149100,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTQ5MTAw",
        "diff_hunk": "@@ -136,6 +143,14 @@ private void setPaused(CordovaArgs args, final CallbackContext callbackContext)\n     }\n \n     socket.setPaused(paused);\n+    if (!paused) {\n+      try {\n+        selectorMessages.put(new SelectorMessage(\n+            socket, SelectorMessageType.SO_ADD_READ_INTEREST, null));",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 34,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "We need to add/remove interests on the selector thread instead of the main thread. I slightly documented here https://github.com/MobileChromeApps/mobile-chrome-apps/blob/4afb1b6ad0e5db7682dc68c078774b112525965b/chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java#L605\n\nI will add a comment here as well.\n",
        "created_at": "2014-10-21T13:59:41Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19149100",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19149100"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19149100"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19156394",
        "pull_request_review_id": null,
        "id": 19156394,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTU2Mzk0",
        "diff_hunk": "@@ -632,13 +697,159 @@ void disconnect() throws IOException {\n       channel.close();\n     }\n \n-    int send(byte[] data) throws IOException {\n-      return channel.write(ByteBuffer.wrap(data));\n+    /**\n+     * @return whether handshake has been finished.\n+     */\n+    boolean handshaking() throws IOException, JSONException {\n+      SSLEngineResult res;\n+      switch(sslEngine.getHandshakeStatus()) {\n+        case FINISHED:\n+          return false;\n+        case NEED_TASK:\n+          Runnable task;\n+          while((task = sslEngine.getDelegatedTask()) != null) {\n+            task.run();\n+          }\n+          return true;\n+        case NEED_UNWRAP:\n+          int bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead == -1) {\n+            handshakeFailed();\n+            return false;\n+          }\n+          sslPeerAppData.clear();\n+          sslPeerNetData.flip();\n+\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n+\n+          sslPeerAppData.flip();\n+          sslPeerNetData.compact();",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 243,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes. Just double checked. `sslEngine.unwrap()` will change buffer's position and we need to clear buffer that has been unwrapped. For example, Here is a buffer after unwrap `java.nio.ByteArrayBuffer[position=6453,limit=6453,capacity=18437]`.\n",
        "created_at": "2014-10-21T15:37:45Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19156394",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19156394"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19156394"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19156477",
        "pull_request_review_id": null,
        "id": 19156477,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTU2NDc3",
        "diff_hunk": "@@ -688,33 +915,40 @@ JSONObject getInfo() throws JSONException {\n     int read() throws JSONException {\n \n       int bytesRead = 0;\n-      if (paused) return bytesRead;\n-\n-      ByteBuffer recvBuffer = ByteBuffer.allocate(bufferSize);\n-      recvBuffer.clear();\n+      if (paused) {\n+        removeInterestSet(SelectionKey.OP_READ);\n+        return bytesRead;\n+      }\n \n       try {\n-        bytesRead = channel.read(recvBuffer);\n-        if (bytesRead < 0) {\n-          sendReceiveError();\n-          return bytesRead;\n-        }\n-        recvBuffer.flip();\n-        byte[] recvBytes = new byte[recvBuffer.limit()];\n-        recvBuffer.get(recvBytes);\n+        if (sslEngine != null) {\n+          bytesRead = channel.read(sslPeerNetData);\n+          if (bytesRead < 0)\n+            return bytesRead;\n \n-        PluginResult dataResult = new PluginResult(Status.OK, recvBytes);\n-        dataResult.setKeepCallback(true);\n+          sslPeerNetData.flip();\n \n-        recvContext.sendPluginResult(dataResult);\n+          SSLEngineResult res;\n+          do {\n+            res = sslEngine.unwrap(sslPeerNetData, sslPeerAppData);\n+          } while (shouldRedoUnwrap(res));\n \n-        JSONObject metadata = new JSONObject();\n+          if (res.getStatus() == SSLEngineResult.Status.OK) {\n+            sslPeerAppData.flip();\n+            sendReceive(sslPeerAppData);\n+          }\n \n-        metadata.put(\"socketId\", socketId);\n-        PluginResult metadataResult = new PluginResult(Status.OK, metadata);\n-        metadataResult.setKeepCallback(true);\n+          sslPeerNetData.compact();",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 465,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "4afb1b6ad0e5db7682dc68c078774b112525965b",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, same as above.\n",
        "created_at": "2014-10-21T15:38:54Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19156477",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19156477"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19156477"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19304316",
        "pull_request_review_id": null,
        "id": 19304316,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzA0MzE2",
        "diff_hunk": "@@ -80,13 +88,20 @@ public void onReset() {\n     stopSelectorThread();\n   }\n \n+  private JSONObject buildErrorInfo(int code, String message)\n+      throws JSONException {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 33,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "304c22127b636881087c503d0320419bc2e59c7d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: rather than declaring this as \"throws\", add a try / catch inside. There's no reason it actually should ever throw, and it uglifies all call-sites.\n",
        "created_at": "2014-10-23T20:15:36Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19304316",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19304316"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19304316"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19304526",
        "pull_request_review_id": null,
        "id": 19304526,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzA0NTI2",
        "diff_hunk": "@@ -136,7 +151,12 @@ private void setPaused(CordovaArgs args, final CallbackContext callbackContext)\n     }\n \n     socket.setPaused(paused);\n-    callbackContext.success();\n+    if (paused) {\n+      callbackContext.success();",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 58,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "304c22127b636881087c503d0320419bc2e59c7d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Add a comment here saying why it's not necessary to remove the read interest.\n",
        "created_at": "2014-10-23T20:18:45Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19304526",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19304526"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19304526"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19305299",
        "pull_request_review_id": null,
        "id": 19305299,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzA1Mjk5",
        "diff_hunk": "@@ -633,32 +696,200 @@ void disconnect() throws IOException {\n       channel.close();\n     }\n \n-    int send(byte[] data) throws IOException {\n-      return channel.write(ByteBuffer.wrap(data));\n+    /**\n+     * @return whether further handshake need to be performed.\n+     */\n+    boolean performNextHandshakeStep() throws IOException, JSONException {\n+      SSLEngineResult res;\n+      switch(sslEngine.getHandshakeStatus()) {\n+        case FINISHED:\n+          return false;\n+        case NEED_TASK:\n+          Runnable task;\n+          while((task = sslEngine.getDelegatedTask()) != null) {\n+            task.run();\n+          }\n+          return true;\n+        case NEED_UNWRAP:\n+          int bytesRead = channel.read(receiveDataBuffer);\n+          if (bytesRead == -1) {\n+            handshakeFailed();\n+            return false;\n+          }\n+          sslPeerAppBuffer.clear();\n+          receiveDataBuffer.flip();\n+\n+          do {\n+            res = sslEngine.unwrap(receiveDataBuffer, sslPeerAppBuffer);\n+          } while (shouldRedoUnwrap(res));\n+\n+          sslPeerAppBuffer.flip();\n+          receiveDataBuffer.compact();\n+          return true;\n+        case NEED_WRAP:\n+          ByteBuffer wrapData = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n+          res = sslEngine.wrap(ByteBuffer.allocate(0), wrapData);\n+          wrapData.flip();\n+          channel.write(wrapData);\n+          return true;\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void handshakeFailed() throws JSONException {\n+      if (secureCallback != null) {\n+        secureCallback.error(buildErrorInfo(-148, \"SSL handshake not completed\"));\n+        secureCallback = null;\n+      }\n+      tearDownSSLEngine();\n+    }\n+\n+    void handshakeSuccess() {\n+      if (secureCallback != null) {\n+        secureCallback.success();\n+        secureCallback = null;\n+      }\n+    }\n+\n+    boolean shouldRedoUnwrap(SSLEngineResult res) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 581,
        "commit_id": "d7215cb9a833d1bed95668f4dfaae3a04cca018f",
        "original_commit_id": "304c22127b636881087c503d0320419bc2e59c7d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: This function sounds like a getter(), but it's mutating state. Better name would be:\nboolean maybeGrowBuffersForUnwrap()\n",
        "created_at": "2014-10-23T20:29:55Z",
        "updated_at": "2014-10-24T02:34:12Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19305299",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19305299"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/361#discussion_r19305299"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/361"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107589",
        "pull_request_review_id": null,
        "id": 19107589,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA3NTg5",
        "diff_hunk": "@@ -14,9 +14,19 @@ registerAutoTests('chrome.app.window', function() {\n           result.message = 'Expected ' + actual + ' to be an Array.';\n           return result;\n         }\n-      }\n+      };\n     },\n-  }\n+    toHaveFunction : function(util, customEqualityTesters) {\n+      return {\n+        compare : function(actual, functionName){\n+          var result = {};\n+          result.pass = ((void 0 !== actual[functionName]) && (typeof actual[functionName] === 'function'));",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/auto/test.chrome.app.window.js",
        "position": null,
        "original_position": 12,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: this first part of the && is redundant. typeof undefined == 'undefined'\n",
        "created_at": "2014-10-20T19:30:52Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107589",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107589"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107589"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107738",
        "pull_request_review_id": null,
        "id": 19107738,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA3NzM4",
        "diff_hunk": "@@ -0,0 +1,40 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.app.window', function(rootEl, addButton) {\n+\n+  document.addEventListener(\"pause\", function onPause() {\n+    console.log('Received the pause event');\n+  });\n+\n+  document.addEventListener(\"resume\", function onResume() {\n+    console.log('Received the resume event');\n+  });\n+  \n+  addButton('AppWindow.hide()', function() {\n+    chrome.app.window.current().hide();\n+  });\n+\n+  addButton('AppWindow.show()', function() {\n+    chrome.app.window.current().show();\n+  });\n+\n+  addButton('AppWindow.show() after alarm', function() {\n+\n+    var expectedFireTime = Date.now() + 500;\n+    var myAlarmName = 'alarmtoshowafterhide';\n+\n+    chrome.alarms.onAlarm.addListener(function showAlarmHandler(alarm) {\n+      console.log(\"Received alarm: \" + alarm.name);\n+      chrome.alarms.onAlarm.removeListener(showAlarmHandler);",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.app.window.js",
        "position": null,
        "original_position": 30,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "this should go inside the alarm.name condition\n",
        "created_at": "2014-10-20T19:33:04Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107738",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107738"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107738"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107827",
        "pull_request_review_id": null,
        "id": 19107827,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA3ODI3",
        "diff_hunk": "@@ -47,6 +47,16 @@ AppWindow.prototype.getBounds = function() {\n     top: 0\n   };\n };\n+AppWindow.prototype.hide = function() {\n+  exec(function() {}, function(error) {}, 'ChromeAppWindow', 'hide', []);\n+};\n+AppWindow.prototype.show = function(focused) {\n+  exec(function() {}, function(error) {}, 'ChromeAppWindow', 'show', []);\n+};\n+AppWindow.prototype.restore = function() {\n+  // Same behaviour as show, given minimize/maximize are not supported\n+  show();",
        "path": "chrome-cordova/plugins/chrome-bootstrap/api/app/window.js",
        "position": null,
        "original_position": 37,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Should be this.show()\n",
        "created_at": "2014-10-20T19:34:28Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107827",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107827"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107827"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107866",
        "pull_request_review_id": null,
        "id": 19107866,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA3ODY2",
        "diff_hunk": "@@ -47,6 +47,16 @@ AppWindow.prototype.getBounds = function() {\n     top: 0\n   };\n };\n+AppWindow.prototype.hide = function() {\n+  exec(function() {}, function(error) {}, 'ChromeAppWindow', 'hide', []);",
        "path": "chrome-cordova/plugins/chrome-bootstrap/api/app/window.js",
        "position": null,
        "original_position": 30,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "pass nulls for the callbacks instead of empty functions\n",
        "created_at": "2014-10-20T19:34:59Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107866",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107866"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107866"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107909",
        "pull_request_review_id": null,
        "id": 19107909,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA3OTA5",
        "diff_hunk": "@@ -39,6 +40,10 @@\n     <js-module src=\"api/helpers/ChromeExtensionURLs.android.js\" name=\"helpers.ChromeExtensionURLs\" />\n \n     <config-file target=\"res/xml/config.xml\" parent=\"/widget\">\n+      <feature name=\"ChromeAppWindow\">\n+        <param name=\"android-package\" value=\"org.chromium.ChromeAppWindow\"/>\n+        <param name=\"onload\" value=\"true\"/>",
        "path": "chrome-cordova/plugins/chrome-bootstrap/plugin.xml",
        "position": null,
        "original_position": 14,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "There's no need for this to be onload I don't think\n",
        "created_at": "2014-10-20T19:35:36Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107909",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107909"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107909"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107981",
        "pull_request_review_id": null,
        "id": 19107981,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA3OTgx",
        "diff_hunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaInterface;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.CordovaWebView;\n+import org.apache.cordova.PluginResult;\n+\n+import android.app.Activity;\n+import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+import android.util.Log;\n+\n+import org.json.JSONException;\n+\n+public class ChromeAppWindow extends CordovaPlugin {\n+\n+    private static final String LOG_TAG = \"ChromeAppWindow\";\n+\n+    @Override\n+    public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+        if (\"show\".equals(action)) {\n+            show(args, callbackContext);\n+            return true;\n+        } else if (\"hide\".equals(action)) {\n+            hide(args, callbackContext);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private void hide(final CordovaArgs args, final CallbackContext callbackContext) {\n+        try {",
        "path": "chrome-cordova/plugins/chrome-bootstrap/src/android/ChromeAppWindow.java",
        "position": null,
        "original_position": 41,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "remove the try/catch. There's already a default one in cordova that routes to the error callback. you need to do this manually only when running on a background thread.\n",
        "created_at": "2014-10-20T19:36:42Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107981",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19107981"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19107981"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19109958",
        "pull_request_review_id": null,
        "id": 19109958,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA5OTU4",
        "diff_hunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaInterface;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.CordovaWebView;\n+import org.apache.cordova.PluginResult;\n+\n+import android.app.Activity;\n+import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+import android.util.Log;\n+\n+import org.json.JSONException;\n+\n+public class ChromeAppWindow extends CordovaPlugin {\n+\n+    private static final String LOG_TAG = \"ChromeAppWindow\";\n+\n+    @Override\n+    public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+        if (\"show\".equals(action)) {\n+            show(args, callbackContext);\n+            return true;\n+        } else if (\"hide\".equals(action)) {\n+            hide(args, callbackContext);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private void hide(final CordovaArgs args, final CallbackContext callbackContext) {\n+        try {\n+            cordova.getActivity().moveTaskToBack(true);\n+            callbackContext.success();\n+        } catch (Exception e) {\n+            Log.e(LOG_TAG, \"Could not hide window\", e);\n+            callbackContext.error(\"Could not hide window\");\n+        }\n+    }\n+    \n+    private void show(final CordovaArgs args, final CallbackContext callbackContext) {\n+        try {\n+            Activity activity = cordova.getActivity();\n+            \n+            if (activity.hasWindowFocus()) {\n+                // Window is already visible, nothing to do\n+                callbackContext.success();\n+                return;\n+            }\n+\n+            Context context = activity.getApplicationContext();\n+            \n+            String activityClass = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES).activities[0].name;\n+            Log.d(LOG_TAG, \"Starting activity '\" + activityClass + \"', from package: \" + context.getPackageName());\n+\n+            ComponentName component = new ComponentName(context, activityClass);\n+            Log.d(LOG_TAG, \"Component is: \" + component.flattenToString());\n+            \n+            Intent activityIntent = Intent.makeMainActivity(component);",
        "path": "chrome-cordova/plugins/chrome-bootstrap/src/android/ChromeAppWindow.java",
        "position": null,
        "original_position": 68,
        "commit_id": "2011c8d00b6f3eb934ec3dfa16bd52bd43c9a571",
        "original_commit_id": "58f6400733dcedbb54708ac1558cc7f5ba802be8",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Might be the same (and simpler) to do:\n\nnew Intent(activity, activity.getClass());\n",
        "created_at": "2014-10-20T20:10:39Z",
        "updated_at": "2014-10-24T21:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19109958",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19109958"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/372#discussion_r19109958"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/372"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19473028",
        "pull_request_review_id": null,
        "id": 19473028,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDczMDI4",
        "diff_hunk": "@@ -29,11 +29,35 @@ exports.setPaused = function(socketId, paused, callback) {\n };\n \n exports.setKeepAlive = function(socketId, enabled, delay, callback) {\n-    console.warn('chrome.sockets.tcp.setKeepAlive not implemented yet');\n+    if (typeof delay == 'function') {\n+        callback = delay;\n+        delay = 0;\n+    }\n+    if (platform.id == 'android') {\n+        var win = callback && function() {\n+            callback(0);\n+        };\n+        var fail = callback && function(error) {\n+            callbackWithError(error.message, callback, error.resultCode);\n+        };\n+        exec(win, fail, 'ChromeSocketsTcp', 'setKeepAlive', [socketId, enabled, delay]);\n+    } else {\n+        console.warn('chrome.sockets.tcp.setKeepAlive not implemented yet');",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/sockets.tcp.js",
        "position": null,
        "original_position": 18,
        "commit_id": "41865799c8cd18aaf1d1025272c7a5595a2aab6a",
        "original_commit_id": "2858db7ba604319d6e9cadb9f9b798c542997006",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Can you create a github issue for implementing this, and then reference this issue in this log message (so people can star it and let us know whether it's important)\n",
        "created_at": "2014-10-28T14:22:34Z",
        "updated_at": "2014-10-28T14:44:48Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/389#discussion_r19473028",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/389",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19473028"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/389#discussion_r19473028"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/389"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19503676",
        "pull_request_review_id": null,
        "id": 19503676,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTAzNjc2",
        "diff_hunk": "@@ -168,6 +172,13 @@ - (void)setProperties:(NSDictionary*)theProperties\n         _bufferSize = [NSNumber numberWithUnsignedInteger:4096];\n }\n \n+- (void)resumeReadIfNotReading\n+{\n+    if (_readTag == _receivedTag && [_plugin getPendingReceive] == 0) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/ios/ChromeSocketsTcp.m",
        "position": null,
        "original_position": 28,
        "commit_id": "5a9debe68d10401a9039d6bd1f8862ec0428462c",
        "original_commit_id": "ac8984d8ce96a5d6040414468f8f27a7af91c113",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: use of a getter here is overkill. just do _plugin->_pendingReceive\n",
        "created_at": "2014-10-28T21:05:00Z",
        "updated_at": "2014-10-29T00:09:39Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/392#discussion_r19503676",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/392",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19503676"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/392#discussion_r19503676"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/392"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19778568",
        "pull_request_review_id": null,
        "id": 19778568,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzc4NTY4",
        "diff_hunk": "@@ -81,16 +83,29 @@ public boolean execute(String action, CordovaArgs args, final CallbackContext ca\n     return true;\n   }\n \n-  public void onDestory() {\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n     closeAllSockets();\n     stopSelectorThread();\n   }\n \n+  @Override\n   public void onReset() {\n+    super.onReset();\n     closeAllSockets();\n     stopSelectorThread();\n   }\n \n+  @Override\n+  public void initialize(CordovaInterface cordova, CordovaWebView webView) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 30,
        "original_position": 30,
        "commit_id": "f30121801d6a4b2344a8f1eb20fd2491a51691c1",
        "original_commit_id": "f30121801d6a4b2344a8f1eb20fd2491a51691c1",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Just one comment - can you do a follow-up commit that changes these to override pluginInitialize() instead (that's the newer initialize method), but more importantly - add a comment saying why it's in initialize instead of a background thread (that initialized gets called on the first exec(), and that it must finish before any other calls to exec() can start)\n",
        "created_at": "2014-11-04T00:36:25Z",
        "updated_at": "2014-11-04T00:36:25Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/406#discussion_r19778568",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/406",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19778568"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/406#discussion_r19778568"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/406"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19779612",
        "pull_request_review_id": null,
        "id": 19779612,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzc5NjEy",
        "diff_hunk": "@@ -81,16 +83,29 @@ public boolean execute(String action, CordovaArgs args, final CallbackContext ca\n     return true;\n   }\n \n-  public void onDestory() {\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n     closeAllSockets();\n     stopSelectorThread();\n   }\n \n+  @Override\n   public void onReset() {\n+    super.onReset();\n     closeAllSockets();\n     stopSelectorThread();\n   }\n \n+  @Override\n+  public void initialize(CordovaInterface cordova, CordovaWebView webView) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 30,
        "original_position": 30,
        "commit_id": "f30121801d6a4b2344a8f1eb20fd2491a51691c1",
        "original_commit_id": "f30121801d6a4b2344a8f1eb20fd2491a51691c1",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh, I see that initialized will be called on the same thread of the first `exec()`, which is the main thread. I don't think solve our problem now. I will send a follow-up commit to do the `Selector.open()` in the `SelectorThread`.\n",
        "created_at": "2014-11-04T01:02:22Z",
        "updated_at": "2014-11-04T01:02:22Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/406#discussion_r19779612",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/406",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19779612"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/406#discussion_r19779612"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/406"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784745",
        "pull_request_review_id": null,
        "id": 19784745,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg0NzQ1",
        "diff_hunk": "@@ -2,24 +2,59 @@\n \n This plugin provides the ability to query storage device information and be notified when a removable storage device is attached and detached.\n \n-## Caveats\n+In general, storage on mobile devices is handled differently than on desktop.\n+The plugin is designed to provide consistent behaviour with desktop usage, but\n+there are notable differences.\n \n-### Android\n+A summary of the similarities and differences:\n+\n+- Each mobile device has built-in storage (on both Android and iOS).  This is",
        "path": "chrome-cordova/plugins/chrome.system.storage/README.md",
        "position": 12,
        "original_position": 12,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is is\n",
        "created_at": "2014-11-04T04:20:09Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784745",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784745"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784745"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784815",
        "pull_request_review_id": null,
        "id": 19784815,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg0ODE1",
        "diff_hunk": "@@ -2,24 +2,59 @@\n \n This plugin provides the ability to query storage device information and be notified when a removable storage device is attached and detached.\n \n-## Caveats\n+In general, storage on mobile devices is handled differently than on desktop.\n+The plugin is designed to provide consistent behaviour with desktop usage, but\n+there are notable differences.\n \n-### Android\n+A summary of the similarities and differences:\n+\n+- Each mobile device has built-in storage (on both Android and iOS).  This is\n+    is reported as storage unit, similar to the physical hard drive in a desktop\n+\n+- Neither Android nor iOS officially support external storage attached via cable,\n+    like USB devices for desktops.  Instead, both platforms expect only special-purpose\n+    accessories to be attached by cable (see\n+    [Android](http://developer.android.com/guide/topics/connectivity/usb/index.html)\n+    and [iOS](https://developer.apple.com/programs/mfi/))\n+\n+- Many Android devices will support an SD card for [external storage](http://source.android.com/devices/tech/storage/index.html).\n+    As of Android 4.4, the SDK has also added support for multiple SD cards.\n+    If found, the plugin will report any SD card(s) as storage units, similar\n+    to USB storage devices on desktop\n \n-`chrome.system.storage.getInfo` is the only method to be implemented for now.\n \n ## Status\n \n-Alpha quality on Android; not yet supported on iOS.\n+The implementation of various functionality, across platforms, is summarized in the table below.\n+\n+| Method / Event | Android | iOS  |\n+| -------------- |:-------:|:----:|\n+| getInfo          | Yes     | Yes<sup>1</sup>    |\n+| ejectDevice      | Yes<sup>2</sup>      | Yes  |\n+| getAvailableCapacity | Yes      | Yes   |\n+| onAttached      | Yes      | No-op<sup>3</sup>   |",
        "path": "chrome-cordova/plugins/chrome.system.storage/README.md",
        "position": null,
        "original_position": 38,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You should make explicit mention that on Android these events will cause your app to start even if it's not running.\n",
        "created_at": "2014-11-04T04:24:02Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784815",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784815"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784815"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784879",
        "pull_request_review_id": null,
        "id": 19784879,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg0ODc5",
        "diff_hunk": "@@ -5,37 +5,354 @@\n package org.chromium;\n \n import java.io.File;\n+import java.lang.String;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n import java.util.UUID;\n \n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import android.os.Environment;\n+import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+import android.support.v4.content.ContextCompat;\n import android.util.Log;\n \n public class ChromeSystemStorage extends CordovaPlugin {\n \n     private static final String LOG_TAG = \"ChromeSystemStorage\";\n-    private String externalStorageId = null;\n+    private static final String INTENT_PREFIX = \"ChromeSystemStorage.\";\n+    private static final String MAIN_ACTIVITY_LABEL = INTENT_PREFIX + \"MainActivity\";\n+    private static final String FILE_SCHEME = \"file://\";\n+\n+    private static ChromeSystemStorage pluginInstance;\n+    private static List<EventInfo> pendingEvents = new ArrayList<>();\n+    private CallbackContext messageChannel;\n+    private String builtinStorageId = null;\n+    private HashMap<String, String> externalStorageIds = null;\n+\n+    private static class EventInfo {\n+        public String action;\n+        public String storagePath;\n+\n+        public EventInfo(String action, String storagePath) {\n+            this.action = action;\n+            this.storagePath = storagePath;\n+        }\n+    }\n+\n+    private class StorageFile {\n+        public File path;\n+        public String type;\n+\n+        public StorageFile(File path, String type) {\n+            this.path = path;\n+            this.type = type;\n+        }\n+    }\n+\n+    public static void handleMediaChangeAction(Context context, Intent intent) {\n+\n+        if (pluginInstance != null && pluginInstance.messageChannel != null) {\n+            Log.w(LOG_TAG, \"Firing event to already running webview\");\n+            pluginInstance.sendStorageMessage(intent.getAction(), intent.getDataString());\n+        } else {\n+            pendingEvents.add(new EventInfo(intent.getAction(), intent.getDataString()));\n+            if (pluginInstance == null) {\n+                try {\n+                    String activityClass = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES).activities[0].name;\n+                    Intent activityIntent = Intent.makeMainActivity(new ComponentName(context, activityClass));\n+                    activityIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_FROM_BACKGROUND);\n+                    activityIntent.putExtra(MAIN_ACTIVITY_LABEL, MAIN_ACTIVITY_LABEL);\n+                    context.startActivity(activityIntent);\n+                } catch (Exception e) {\n+                    Log.e(LOG_TAG, \"Failed to make startActivity intent\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void pluginInitialize() {\n+        if (pluginInstance == null && cordova.getActivity().getIntent().hasExtra(MAIN_ACTIVITY_LABEL)) {\n+            cordova.getActivity().moveTaskToBack(true);\n+        }\n+        pluginInstance = this;\n+    }\n+\n+    @Override\n+    public void onReset() {\n+        messageChannel = null;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        messageChannel = null;\n+    }\n \n     @Override\n     public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n-        if (\"getInfo\".equals(action)) {\n-            getInfo(args, callbackContext);\n-            return true;\n+        switch (action) {\n+            case \"getInfo\":\n+                getInfo(args, callbackContext);\n+                return true;\n+            case \"ejectDevice\":\n+                ejectDevice(args, callbackContext);\n+                return true;\n+            case \"getAvailableCapacity\":\n+                getAvailableCapacity(args, callbackContext);\n+                return true;\n+            case \"messageChannel\":\n+                messageChannel = callbackContext;\n+                for (EventInfo event : pendingEvents) {\n+                    sendStorageMessage(event.action, event.storagePath);\n+                }\n+                pendingEvents.clear();\n+                return true;\n         }\n         return false;\n     }\n \n-    private String getExternalStorageId() {\n-        if (externalStorageId == null) {\n-            externalStorageId = UUID.randomUUID().toString();\n+    private void sendStorageMessage(String action, String storagePath) {\n+\n+        boolean attached = false;\n+\n+        switch (action)\n+        {\n+            case Intent.ACTION_MEDIA_MOUNTED:\n+                attached = true;\n+                break;\n+\n+            case Intent.ACTION_MEDIA_BAD_REMOVAL:\n+            case Intent.ACTION_MEDIA_REMOVED:\n+            case Intent.ACTION_MEDIA_SHARED:\n+            case Intent.ACTION_MEDIA_UNMOUNTED:\n+                break;\n+\n+            default:\n+                // Ignore any other actions\n+                return;\n+        }\n+\n+        // Sanitize the path provided with the event\n+        if (storagePath.startsWith(FILE_SCHEME)) {",
        "path": "chrome-cordova/plugins/chrome.system.storage/src/android/ChromeSystemStorage.java",
        "position": null,
        "original_position": 150,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This will strip the scheme, but it won't decode % escapes. Better to use Uri.parse(storagePath).getPath()\n",
        "created_at": "2014-11-04T04:27:09Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784879",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784879"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784879"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784949",
        "pull_request_review_id": null,
        "id": 19784949,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg0OTQ5",
        "diff_hunk": "@@ -5,37 +5,354 @@\n package org.chromium;\n \n import java.io.File;\n+import java.lang.String;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n import java.util.UUID;\n \n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import android.os.Environment;\n+import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+import android.support.v4.content.ContextCompat;\n import android.util.Log;\n \n public class ChromeSystemStorage extends CordovaPlugin {\n \n     private static final String LOG_TAG = \"ChromeSystemStorage\";\n-    private String externalStorageId = null;\n+    private static final String INTENT_PREFIX = \"ChromeSystemStorage.\";\n+    private static final String MAIN_ACTIVITY_LABEL = INTENT_PREFIX + \"MainActivity\";\n+    private static final String FILE_SCHEME = \"file://\";\n+\n+    private static ChromeSystemStorage pluginInstance;\n+    private static List<EventInfo> pendingEvents = new ArrayList<>();\n+    private CallbackContext messageChannel;\n+    private String builtinStorageId = null;\n+    private HashMap<String, String> externalStorageIds = null;\n+\n+    private static class EventInfo {\n+        public String action;\n+        public String storagePath;\n+\n+        public EventInfo(String action, String storagePath) {\n+            this.action = action;\n+            this.storagePath = storagePath;\n+        }\n+    }\n+\n+    private class StorageFile {\n+        public File path;\n+        public String type;\n+\n+        public StorageFile(File path, String type) {\n+            this.path = path;\n+            this.type = type;\n+        }\n+    }\n+\n+    public static void handleMediaChangeAction(Context context, Intent intent) {\n+\n+        if (pluginInstance != null && pluginInstance.messageChannel != null) {\n+            Log.w(LOG_TAG, \"Firing event to already running webview\");\n+            pluginInstance.sendStorageMessage(intent.getAction(), intent.getDataString());\n+        } else {\n+            pendingEvents.add(new EventInfo(intent.getAction(), intent.getDataString()));\n+            if (pluginInstance == null) {\n+                try {\n+                    String activityClass = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES).activities[0].name;\n+                    Intent activityIntent = Intent.makeMainActivity(new ComponentName(context, activityClass));\n+                    activityIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_FROM_BACKGROUND);\n+                    activityIntent.putExtra(MAIN_ACTIVITY_LABEL, MAIN_ACTIVITY_LABEL);\n+                    context.startActivity(activityIntent);\n+                } catch (Exception e) {\n+                    Log.e(LOG_TAG, \"Failed to make startActivity intent\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void pluginInitialize() {\n+        if (pluginInstance == null && cordova.getActivity().getIntent().hasExtra(MAIN_ACTIVITY_LABEL)) {\n+            cordova.getActivity().moveTaskToBack(true);\n+        }\n+        pluginInstance = this;\n+    }\n+\n+    @Override\n+    public void onReset() {\n+        messageChannel = null;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        messageChannel = null;\n+    }\n \n     @Override\n     public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n-        if (\"getInfo\".equals(action)) {\n-            getInfo(args, callbackContext);\n-            return true;\n+        switch (action) {\n+            case \"getInfo\":\n+                getInfo(args, callbackContext);\n+                return true;\n+            case \"ejectDevice\":\n+                ejectDevice(args, callbackContext);\n+                return true;\n+            case \"getAvailableCapacity\":\n+                getAvailableCapacity(args, callbackContext);\n+                return true;\n+            case \"messageChannel\":\n+                messageChannel = callbackContext;\n+                for (EventInfo event : pendingEvents) {\n+                    sendStorageMessage(event.action, event.storagePath);\n+                }\n+                pendingEvents.clear();\n+                return true;\n         }\n         return false;\n     }\n \n-    private String getExternalStorageId() {\n-        if (externalStorageId == null) {\n-            externalStorageId = UUID.randomUUID().toString();\n+    private void sendStorageMessage(String action, String storagePath) {\n+\n+        boolean attached = false;\n+\n+        switch (action)\n+        {\n+            case Intent.ACTION_MEDIA_MOUNTED:\n+                attached = true;\n+                break;\n+\n+            case Intent.ACTION_MEDIA_BAD_REMOVAL:\n+            case Intent.ACTION_MEDIA_REMOVED:\n+            case Intent.ACTION_MEDIA_SHARED:\n+            case Intent.ACTION_MEDIA_UNMOUNTED:\n+                break;\n+\n+            default:\n+                // Ignore any other actions\n+                return;\n+        }\n+\n+        // Sanitize the path provided with the event\n+        if (storagePath.startsWith(FILE_SCHEME)) {\n+            storagePath = storagePath.substring(FILE_SCHEME.length());\n+        }\n+        storagePath = getBaseStoragePath(storagePath);\n+\n+        // The attached/detached events may fire before the client has a chance to call getInfo().\n+        // Thus, must initialize the external storage here (if not already done), to ensure that\n+        // unit ids are consistent across calls to getInfo, and subsequent attach/detach events.\n+        StorageFile[] directories = initializeExternalStorageDirectories();\n+\n+        String unitId = externalStorageIds.get(storagePath);\n+        StorageFile attachedStorage = null;\n+        if (attached) {\n+            attachedStorage = getExternalStorageDirectoryByPath(storagePath, directories);\n+        } else {\n+            // If the detached event causes initialization, the unit id may not be found\n+            // as it won't be reported in the list of directories.  We can safely generate\n+            // a random id, as the client won't have called getInfo yet.\n+            if (unitId == null) {\n+                unitId = UUID.randomUUID().toString();\n+            }\n+        }\n+\n+        JSONObject message = new JSONObject();\n+        try {\n+            message.put(\"action\", attached ? \"attached\" : \"detached\");\n+            message.put(\"id\", unitId);\n+            if (attached) {\n+                JSONObject storageUnit = buildExternalStorageUnitInfo(attachedStorage);\n+\n+                message.put(\"info\", storageUnit);\n+            }\n+        } catch (JSONException e) {\n+            Log.e(LOG_TAG, \"Failed to create storage message\", e);\n+        }\n+\n+        PluginResult pluginResult = new PluginResult(PluginResult.Status.OK, message);\n+        pluginResult.setKeepCallback(true);\n+        messageChannel.sendPluginResult(pluginResult);\n+    }\n+\n+    private String getBuiltInStorageId() {\n+        if (builtinStorageId == null) {\n+            builtinStorageId = UUID.randomUUID().toString();\n+        }\n+        return builtinStorageId;\n+    }\n+\n+    private boolean isBuiltInStorageId(String unitId) {\n+        return getBuiltInStorageId().equalsIgnoreCase(unitId);\n+    }\n+\n+    private File getBuiltInStorageDirectory() {\n+        return cordova.getActivity().getFilesDir();\n+    }\n+\n+    private String getExternalStoragePath(String unitId) {\n+        // The unit ids are stored in the map where key = path, value = id,\n+        // so must iterate and check each value\n+        if (externalStorageIds == null) {\n+            return null;\n+        }\n+        for (HashMap.Entry<String, String> entry : externalStorageIds.entrySet()) {\n+            if (entry.getValue().equalsIgnoreCase(unitId)) {\n+                return entry.getKey();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean isExternalStorageId(String unitId) {\n+        String path = getExternalStoragePath(unitId);\n+\n+        return (path != null);\n+    }\n+\n+    private File getExternalStorageDirectoryById(String unitId) {\n+        String path = getExternalStoragePath(unitId);\n+\n+        if (path == null) {\n+            return null;\n+        }\n+\n+        File[] directories = getExternalStorageDirectories();\n+\n+        for (File storage : directories) {\n+            if (storage == null) {\n+                continue;\n+            }\n+\n+            if (getBaseStoragePath(storage).equalsIgnoreCase(path)) {",
        "path": "chrome-cordova/plugins/chrome.system.storage/src/android/ChromeSystemStorage.java",
        "position": null,
        "original_position": 240,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "might be worth a comment here saying that case-sensitivity depends on file system.\nhttp://stackoverflow.com/questions/6502712/isnt-android-file-exists-case-sensitive\n",
        "created_at": "2014-11-04T04:30:32Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784949",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784949"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19784949"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19785106",
        "pull_request_review_id": null,
        "id": 19785106,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg1MTA2",
        "diff_hunk": "@@ -5,37 +5,354 @@\n package org.chromium;\n \n import java.io.File;\n+import java.lang.String;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n import java.util.UUID;\n \n import org.apache.cordova.CallbackContext;\n import org.apache.cordova.CordovaArgs;\n import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import android.os.Environment;\n+import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+import android.support.v4.content.ContextCompat;",
        "path": "chrome-cordova/plugins/chrome.system.storage/src/android/ChromeSystemStorage.java",
        "position": null,
        "original_position": 23,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You need to add this <dependency> for this in the plugin.xml.\n",
        "created_at": "2014-11-04T04:38:57Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19785106",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19785106"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19785106"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19785319",
        "pull_request_review_id": null,
        "id": 19785319,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg1MzE5",
        "diff_hunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import <Cordova/CDVPlugin.h>\n+#import <Foundation/Foundation.h>\n+#import <UIKit/UIScreen.h>\n+\n+#if CHROME_SYSTEM_STORAGE_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+@interface ChromeSystemStorage : CDVPlugin\n+\n+- (void)getInfo:(CDVInvokedUrlCommand*)command;\n+- (void)ejectDevice:(CDVInvokedUrlCommand*)command;\n+- (void)getAvailableCapacity:(CDVInvokedUrlCommand*)command;\n+\n+@end\n+\n+@implementation ChromeSystemStorage\n+{\n+    NSString* _externalStorageId;\n+}\n+\n+NSString *const StorageErrorDomain = @\"ChromeSystemStorageErrorDomain\";\n+\n+typedef enum {Total, Available} CapacityType;\n+\n+- (NSString*)builtInStorageId\n+{\n+    if (_externalStorageId == nil) {\n+        _externalStorageId = [[NSUUID UUID] UUIDString];",
        "path": "chrome-cordova/plugins/chrome.system.storage/src/ios/ChromeSystemStorage.m",
        "position": null,
        "original_position": 35,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "given the multi-threading going on, it might be better to just create this in pluginInitialize instead.\n",
        "created_at": "2014-11-04T04:42:14Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19785319",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19785319"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19785319"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19785346",
        "pull_request_review_id": null,
        "id": 19785346,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg1MzQ2",
        "diff_hunk": "@@ -74,7 +74,6 @@ _Current as of July 2014_.\n ### APIs Coming in the Medium Term\n * bluetooth\n * fileSystem (fixes)\n-* system.*",
        "path": "docs/APIsAndLibraries.md",
        "position": 13,
        "original_position": 13,
        "commit_id": "a24ba8c2b81c6de5e9af27cc46ae9f51bf612c2d",
        "original_commit_id": "71775a5eb33a1c008db5fd14aa6792548412267d",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "woohoo!\n",
        "created_at": "2014-11-04T04:43:37Z",
        "updated_at": "2014-11-04T15:19:53Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19785346",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19785346"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/411#discussion_r19785346"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/411"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19811875",
        "pull_request_review_id": null,
        "id": 19811875,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODExODc1",
        "diff_hunk": "@@ -502,7 +489,18 @@ private void processPendingMessages() {\n     }\n \n     public void run() {\n+\n+      try {\n+        selector = Selector.open();\n+      } catch (IOException e) {\n+      }",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 60,
        "commit_id": "469d11f0264ba1510cfa61928852a78f4f299405",
        "original_commit_id": "ecfbe8a35e161f1de70e3ca989d31addaaeae1d1",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: Should probably rethrow this as a RuntimeException\n",
        "created_at": "2014-11-04T15:58:14Z",
        "updated_at": "2014-11-04T19:27:34Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/414#discussion_r19811875",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/414",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19811875"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/414#discussion_r19811875"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/414"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783147",
        "pull_request_review_id": null,
        "id": 19783147,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzMTQ3",
        "diff_hunk": "@@ -0,0 +1,297 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.bluetoothLowEnergy', function(rootEl, addButton) {\n+\n+  var devices = {}; /** key is deviceAddress, value is device object */\n+  var services = {}; /** key is serviceId, value is service object */\n+  var characteristics = {}; /** key is characteristicId, value is characteristic object */\n+  var descriptors = {}; /** key is descriptorId, value is descriptor object */\n+\n+  function abToStr(ab) {\n+    return String.fromCharCode.apply(null, new Uint8Array(ab));\n+  }\n+\n+  function strToAb(str) {\n+    var buf = new ArrayBuffer(str.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = str.length; i < strLen; i++) {\n+      bufView[i] = str.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  addButton('Test getAdapter State', function() {\n+    chrome.bluetooth.getAdapterState(function(adapter) {\n+      logger(JSON.stringify(adapter));\n+    });\n+  });\n+\n+  addButton('Add Events Listener', function() {\n+\n+    chrome.bluetooth.onAdapterStateChanged.addListener(function(adapter) {\n+      logger(JSON.stringify(adapter));\n+    });\n+\n+    chrome.bluetooth.onDeviceAdded.addListener(function(device) {\n+      logger('Device added: ' + device.address);\n+      devices[device.address] = device;\n+    });\n+\n+    chrome.bluetooth.onDeviceChanged.addListener(function(device) {\n+      logger('Device changed: ' + device.address);\n+      devices[device.address] = device;\n+    });\n+\n+    chrome.bluetooth.onDeviceRemoved.addListener(function(device) {\n+      logger('Device removed: ' + device.address);\n+      delete devices[device.address];\n+    });\n+\n+    chrome.bluetoothLowEnergy.onServiceAdded.addListener(function(service) {\n+      logger('Service added: ' + service.instanceId);\n+      services[service.instanceId] = service;\n+    });\n+\n+    chrome.bluetoothLowEnergy.onServiceRemoved.addListener(function(service) {\n+      logger('Service removed: ' + service.instanceId);\n+      delete services[service.instanceId];\n+    });\n+\n+    chrome.bluetoothLowEnergy.onServiceChanged.addListener(function(service) {\n+      logger('Service changed: ' + service.instanceId);\n+      services[service.instanceId] = service;\n+    });\n+\n+    chrome.bluetoothLowEnergy.onCharacteristicValueChanged.addListener(function(characteristic) {\n+      logger('Characteristic changed: ' + characteristic.instanceId);\n+      characteristics[characteristic.instanceId] = characteristic;\n+      logger(JSON.stringify(characteristic));\n+    });\n+\n+    chrome.bluetoothLowEnergy.onDescriptorValueChanged.addListener(function(descriptor) {\n+      logger('Descriptor changed: ' + descriptor.instanceId);\n+      descriptor[descriptor.instanceId] = descriptor;\n+    });\n+  });\n+\n+  addButton('Log known devices', function() {\n+    logger(JSON.stringify(devices));\n+  });\n+\n+  addButton('Log known services', function() {\n+    logger(JSON.stringify(services));\n+  });\n+\n+  addButton('Log known characteristic', function() {\n+    logger(JSON.stringify(characteristics));\n+  });\n+\n+  addButton('Log known descriptor', function() {\n+    logger(JSON.stringify(descriptors));\n+  });\n+\n+  addButton('Start discovering', function() {\n+    chrome.bluetooth.startDiscovery(function() {\n+      logger('start discovery...');\n+    });\n+  });\n+\n+  addButton('Stop discovering', function() {\n+    chrome.bluetooth.stopDiscovery(function() {\n+      logger('stop discovery...');\n+    });\n+  });\n+\n+  addButton('Get all devices', function() {\n+    chrome.bluetooth.getDevices(function(foundDevices) {\n+      logger(JSON.stringify(foundDevices));\n+      for (var i = 0; i < foundDevices.length; i++) {\n+        devices[foundDevices[i].address] = foundDevices[i];\n+      }\n+    });\n+  });\n+\n+  addButton('connect all known devices', function() {\n+    for (var address in devices) {\n+      (function(address) {\n+        chrome.bluetoothLowEnergy.connect(address, function() {\n+          logger(address + ' connected');\n+        });\n+      })(address);\n+    }\n+  });\n+\n+  // This can force two iOS devices paired with each other.\n+  addButton('connect all known devices & getServices & getCharacteristics & startNotification', function() {\n+    for (var address in devices) {\n+      (function(address) {\n+        chrome.bluetoothLowEnergy.connect(address, function() {\n+          logger(address + ' connected');\n+          chrome.bluetoothLowEnergy.getServices(address, function(services) {\n+            logger('Services for address: ' + address);\n+            logger(JSON.stringify(services));\n+            for (var i = 0; i < services.length; i++) {\n+              logger(services[i].instanceId);\n+              logger('start get characteristics for service Id: ' + services[i].instanceId);\n+              chrome.bluetoothLowEnergy.getCharacteristics(services[i].instanceId, function(characteristics) {\n+                logger(JSON.stringify(characteristics));\n+                for (var j = 0; j < characteristics.length; j++) {\n+                  chrome.bluetoothLowEnergy.startCharacteristicNotifications(characteristics[j].instanceId, function() {});\n+                }\n+              });\n+            }\n+          });\n+        });\n+      })(address);\n+    }\n+  });\n+\n+  addButton('Disconnect all connected device', function() {\n+    for (var address in devices) {\n+      if (devices[address].connected) {\n+        (function(address) {\n+          chrome.bluetoothLowEnergy.disconnect(address, function() {\n+            logger(address + ' disconnected');\n+          });\n+        })(address);\n+      }\n+    }\n+  });\n+\n+  addButton('get services for all devices', function() {\n+    for (var address in devices) {\n+      if (devices[address].connected) {\n+        (function(address) {\n+          logger('Start get services for: ' + address);\n+          chrome.bluetoothLowEnergy.getServices(address, function(services) {\n+            logger('Services for address: ' + address);\n+            logger(JSON.stringify(services));\n+          });\n+        })(address);\n+      }\n+    }\n+  });\n+\n+  addButton('get all known services by Id', function() {\n+    for (var serviceId in services) {\n+      logger(serviceId);\n+      chrome.bluetoothLowEnergy.getService(serviceId, function(service) {\n+        logger(JSON.stringify(service));\n+      });\n+    }\n+  });\n+\n+  addButton('get all included services by Id', function() {\n+    for (var serviceId in services) {\n+      chrome.bluetoothLowEnergy.getIncludedServices(serviceId, function(includedServices) {\n+        for (var i = 0; i < includedServices.length; i++) {\n+          logger(JSON.stringify(includedServices[i]));\n+          services[includedServices[i].instanceId] = includedServices[i];\n+        }\n+      });\n+    }\n+  });\n+\n+  addButton('get characteristics for known services', function() {\n+    for (var serviceId in services) {\n+      (function(serviceId) {\n+        chrome.bluetoothLowEnergy.getCharacteristics(serviceId, function(foundCharacteristics) {\n+          logger('Characteristics for service: ' + serviceId);\n+          logger(JSON.stringify(foundCharacteristics));\n+          for (var i = 0; i < foundCharacteristics.length; i++) {\n+            characteristics[foundCharacteristics[i].instanceId] = foundCharacteristics[i];\n+          }\n+        });\n+      })(serviceId);\n+    }\n+  });\n+\n+  addButton('get all known characteristics by id', function() {\n+    for (var characteristicId in characteristics) {\n+      chrome.bluetoothLowEnergy.getCharacteristic(characteristicId, function(characteristic) {\n+        logger(JSON.stringify(characteristic));\n+        characteristics[characteristic.instanceId] = characteristic;\n+      });\n+    }\n+  });\n+\n+  addButton('read all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      chrome.bluetoothLowEnergy.readCharacteristicValue(characteristicId, function(characteristic) {\n+        logger(JSON.stringify(characteristic));\n+        logger(abToStr(characteristic.value));\n+      });\n+    }\n+  });\n+\n+  addButton('write all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      (function(characteristicId) {\n+        chrome.bluetoothLowEnergy.writeCharacteristicValue(characteristicId, strToAb('test: '+ characteristicId), function() {\n+          logger('successfully write into: ' + characteristicId);\n+        });\n+      })(characteristicId);\n+    }\n+  });\n+\n+  addButton('start notification of all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      (function(characteristicId) {\n+        chrome.bluetoothLowEnergy.startCharacteristicNotifications(characteristicId, function() {\n+          logger('successfully set notification on: ' + characteristicId);\n+        });\n+      })(characteristicId);\n+    }\n+  });\n+\n+  addButton('stop notification of all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      (function(characteristicId) {\n+        chrome.bluetoothLowEnergy.stopCharacteristicNotifications(characteristicId, function() {\n+          logger('successfully set notification off: ' + characteristicId);\n+        });\n+      })(characteristicId);\n+    }\n+  });\n+\n+  addButton('get descriptors for known characteristics', function() {\n+    for (var characteristicId in characteristics) {\n+      chrome.bluetoothLowEnergy.getDescriptors(characteristicId, function(foundDescriptors) {\n+        JSON.stringify(foundDescriptors);",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.bluetoothLowEnergy.js",
        "position": null,
        "original_position": 262,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "did you mean to logger this?\n",
        "created_at": "2014-11-04T02:49:07Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783147",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783147"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783147"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783155",
        "pull_request_review_id": null,
        "id": 19783155,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzMTU1",
        "diff_hunk": "@@ -0,0 +1,297 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+registerManualTests('chrome.bluetoothLowEnergy', function(rootEl, addButton) {\n+\n+  var devices = {}; /** key is deviceAddress, value is device object */\n+  var services = {}; /** key is serviceId, value is service object */\n+  var characteristics = {}; /** key is characteristicId, value is characteristic object */\n+  var descriptors = {}; /** key is descriptorId, value is descriptor object */\n+\n+  function abToStr(ab) {\n+    return String.fromCharCode.apply(null, new Uint8Array(ab));\n+  }\n+\n+  function strToAb(str) {\n+    var buf = new ArrayBuffer(str.length);\n+    var bufView = new Uint8Array(buf);\n+    for (var i = 0, strLen = str.length; i < strLen; i++) {\n+      bufView[i] = str.charCodeAt(i);\n+    }\n+    return buf;\n+  }\n+\n+  addButton('Test getAdapter State', function() {\n+    chrome.bluetooth.getAdapterState(function(adapter) {\n+      logger(JSON.stringify(adapter));\n+    });\n+  });\n+\n+  addButton('Add Events Listener', function() {\n+\n+    chrome.bluetooth.onAdapterStateChanged.addListener(function(adapter) {\n+      logger(JSON.stringify(adapter));\n+    });\n+\n+    chrome.bluetooth.onDeviceAdded.addListener(function(device) {\n+      logger('Device added: ' + device.address);\n+      devices[device.address] = device;\n+    });\n+\n+    chrome.bluetooth.onDeviceChanged.addListener(function(device) {\n+      logger('Device changed: ' + device.address);\n+      devices[device.address] = device;\n+    });\n+\n+    chrome.bluetooth.onDeviceRemoved.addListener(function(device) {\n+      logger('Device removed: ' + device.address);\n+      delete devices[device.address];\n+    });\n+\n+    chrome.bluetoothLowEnergy.onServiceAdded.addListener(function(service) {\n+      logger('Service added: ' + service.instanceId);\n+      services[service.instanceId] = service;\n+    });\n+\n+    chrome.bluetoothLowEnergy.onServiceRemoved.addListener(function(service) {\n+      logger('Service removed: ' + service.instanceId);\n+      delete services[service.instanceId];\n+    });\n+\n+    chrome.bluetoothLowEnergy.onServiceChanged.addListener(function(service) {\n+      logger('Service changed: ' + service.instanceId);\n+      services[service.instanceId] = service;\n+    });\n+\n+    chrome.bluetoothLowEnergy.onCharacteristicValueChanged.addListener(function(characteristic) {\n+      logger('Characteristic changed: ' + characteristic.instanceId);\n+      characteristics[characteristic.instanceId] = characteristic;\n+      logger(JSON.stringify(characteristic));\n+    });\n+\n+    chrome.bluetoothLowEnergy.onDescriptorValueChanged.addListener(function(descriptor) {\n+      logger('Descriptor changed: ' + descriptor.instanceId);\n+      descriptor[descriptor.instanceId] = descriptor;\n+    });\n+  });\n+\n+  addButton('Log known devices', function() {\n+    logger(JSON.stringify(devices));\n+  });\n+\n+  addButton('Log known services', function() {\n+    logger(JSON.stringify(services));\n+  });\n+\n+  addButton('Log known characteristic', function() {\n+    logger(JSON.stringify(characteristics));\n+  });\n+\n+  addButton('Log known descriptor', function() {\n+    logger(JSON.stringify(descriptors));\n+  });\n+\n+  addButton('Start discovering', function() {\n+    chrome.bluetooth.startDiscovery(function() {\n+      logger('start discovery...');\n+    });\n+  });\n+\n+  addButton('Stop discovering', function() {\n+    chrome.bluetooth.stopDiscovery(function() {\n+      logger('stop discovery...');\n+    });\n+  });\n+\n+  addButton('Get all devices', function() {\n+    chrome.bluetooth.getDevices(function(foundDevices) {\n+      logger(JSON.stringify(foundDevices));\n+      for (var i = 0; i < foundDevices.length; i++) {\n+        devices[foundDevices[i].address] = foundDevices[i];\n+      }\n+    });\n+  });\n+\n+  addButton('connect all known devices', function() {\n+    for (var address in devices) {\n+      (function(address) {\n+        chrome.bluetoothLowEnergy.connect(address, function() {\n+          logger(address + ' connected');\n+        });\n+      })(address);\n+    }\n+  });\n+\n+  // This can force two iOS devices paired with each other.\n+  addButton('connect all known devices & getServices & getCharacteristics & startNotification', function() {\n+    for (var address in devices) {\n+      (function(address) {\n+        chrome.bluetoothLowEnergy.connect(address, function() {\n+          logger(address + ' connected');\n+          chrome.bluetoothLowEnergy.getServices(address, function(services) {\n+            logger('Services for address: ' + address);\n+            logger(JSON.stringify(services));\n+            for (var i = 0; i < services.length; i++) {\n+              logger(services[i].instanceId);\n+              logger('start get characteristics for service Id: ' + services[i].instanceId);\n+              chrome.bluetoothLowEnergy.getCharacteristics(services[i].instanceId, function(characteristics) {\n+                logger(JSON.stringify(characteristics));\n+                for (var j = 0; j < characteristics.length; j++) {\n+                  chrome.bluetoothLowEnergy.startCharacteristicNotifications(characteristics[j].instanceId, function() {});\n+                }\n+              });\n+            }\n+          });\n+        });\n+      })(address);\n+    }\n+  });\n+\n+  addButton('Disconnect all connected device', function() {\n+    for (var address in devices) {\n+      if (devices[address].connected) {\n+        (function(address) {\n+          chrome.bluetoothLowEnergy.disconnect(address, function() {\n+            logger(address + ' disconnected');\n+          });\n+        })(address);\n+      }\n+    }\n+  });\n+\n+  addButton('get services for all devices', function() {\n+    for (var address in devices) {\n+      if (devices[address].connected) {\n+        (function(address) {\n+          logger('Start get services for: ' + address);\n+          chrome.bluetoothLowEnergy.getServices(address, function(services) {\n+            logger('Services for address: ' + address);\n+            logger(JSON.stringify(services));\n+          });\n+        })(address);\n+      }\n+    }\n+  });\n+\n+  addButton('get all known services by Id', function() {\n+    for (var serviceId in services) {\n+      logger(serviceId);\n+      chrome.bluetoothLowEnergy.getService(serviceId, function(service) {\n+        logger(JSON.stringify(service));\n+      });\n+    }\n+  });\n+\n+  addButton('get all included services by Id', function() {\n+    for (var serviceId in services) {\n+      chrome.bluetoothLowEnergy.getIncludedServices(serviceId, function(includedServices) {\n+        for (var i = 0; i < includedServices.length; i++) {\n+          logger(JSON.stringify(includedServices[i]));\n+          services[includedServices[i].instanceId] = includedServices[i];\n+        }\n+      });\n+    }\n+  });\n+\n+  addButton('get characteristics for known services', function() {\n+    for (var serviceId in services) {\n+      (function(serviceId) {\n+        chrome.bluetoothLowEnergy.getCharacteristics(serviceId, function(foundCharacteristics) {\n+          logger('Characteristics for service: ' + serviceId);\n+          logger(JSON.stringify(foundCharacteristics));\n+          for (var i = 0; i < foundCharacteristics.length; i++) {\n+            characteristics[foundCharacteristics[i].instanceId] = foundCharacteristics[i];\n+          }\n+        });\n+      })(serviceId);\n+    }\n+  });\n+\n+  addButton('get all known characteristics by id', function() {\n+    for (var characteristicId in characteristics) {\n+      chrome.bluetoothLowEnergy.getCharacteristic(characteristicId, function(characteristic) {\n+        logger(JSON.stringify(characteristic));\n+        characteristics[characteristic.instanceId] = characteristic;\n+      });\n+    }\n+  });\n+\n+  addButton('read all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      chrome.bluetoothLowEnergy.readCharacteristicValue(characteristicId, function(characteristic) {\n+        logger(JSON.stringify(characteristic));\n+        logger(abToStr(characteristic.value));\n+      });\n+    }\n+  });\n+\n+  addButton('write all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      (function(characteristicId) {\n+        chrome.bluetoothLowEnergy.writeCharacteristicValue(characteristicId, strToAb('test: '+ characteristicId), function() {\n+          logger('successfully write into: ' + characteristicId);\n+        });\n+      })(characteristicId);\n+    }\n+  });\n+\n+  addButton('start notification of all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      (function(characteristicId) {\n+        chrome.bluetoothLowEnergy.startCharacteristicNotifications(characteristicId, function() {\n+          logger('successfully set notification on: ' + characteristicId);\n+        });\n+      })(characteristicId);\n+    }\n+  });\n+\n+  addButton('stop notification of all known characteristic', function() {\n+    for (var characteristicId in characteristics) {\n+      (function(characteristicId) {\n+        chrome.bluetoothLowEnergy.stopCharacteristicNotifications(characteristicId, function() {\n+          logger('successfully set notification off: ' + characteristicId);\n+        });\n+      })(characteristicId);\n+    }\n+  });\n+\n+  addButton('get descriptors for known characteristics', function() {\n+    for (var characteristicId in characteristics) {\n+      chrome.bluetoothLowEnergy.getDescriptors(characteristicId, function(foundDescriptors) {\n+        JSON.stringify(foundDescriptors);\n+        for (var i = 0; i < foundDescriptors.length; i++) {\n+          descriptors[foundDescriptors[i].instanceId] = foundDescriptors[i];\n+        }\n+      });\n+    }\n+  });\n+\n+  addButton('get known descriptor by Id', function() {\n+    for (var descriptorId in descriptors) {\n+      chrome.bluetoothLowEnergy.getDescriptor(descriptorId, function(descriptor) {\n+        logger(JSON.stringify(descriptor));\n+      });\n+    }\n+  });\n+\n+  addButton('read known descriptor by Id', function() {\n+    for (var descriptorId in descriptors) {\n+      chrome.bluetoothLowEnergy.readDescriptorValue(descriptorId, function(descriptor) {\n+        logger(JSON.stringify(descriptor));\n+        logger(abToStr(descriptor.value));\n+      });\n+    }\n+  });\n+\n+  addButton('write known descriptor by Id', function() {\n+    for (var descriptorId in descriptors) {\n+      (function(descriptorId) {\n+        chrome.bluetoothLowEnergy.writeDescriptorValue(descriptorId, strToAb('test: ' + descriptorId), function() {\n+          logger('successfully write into: ' + descriptorId);\n+        });\n+      })(descriptorId);\n+    }\n+  });\n+",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/manual/manual.chrome.bluetoothLowEnergy.js",
        "position": 296,
        "original_position": 296,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "These are awesome tests!\n",
        "created_at": "2014-11-04T02:49:31Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783155",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783155"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783155"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783441",
        "pull_request_review_id": null,
        "id": 19783441,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNDQx",
        "diff_hunk": "@@ -0,0 +1,71 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+var Event = require('org.chromium.common.events');\n+var platform = cordova.require('cordova/platform');\n+var exec = require('cordova/exec');\n+var callbackWithError = require('org.chromium.common.errors').callbackWithError;\n+\n+exports.getAdapterState = function(callback) {\n+    exec(callback, callbackWithError, 'ChromeBluetooth', 'getAdapterState', []);",
        "path": "chrome-cordova/plugins/chrome.bluetooth/bluetooth.js",
        "position": null,
        "original_position": 11,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Not quite the intended purpose for callbackWithError. You're using it here strictly for it's console logging? Might be better to use your own helper here that just does the log (rather than having the helper throw & catch an exception)\n",
        "created_at": "2014-11-04T03:02:17Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783441",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783441"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783441"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783536",
        "pull_request_review_id": null,
        "id": 19783536,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNTM2",
        "diff_hunk": "@@ -0,0 +1,74 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source file is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#import <Cordova/CDVPlugin.h>",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.h",
        "position": null,
        "original_position": 5,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "nit: Unless you want to export some functions to be called directly from the native side of other plugins, it's better to not include a .h file. Can you cut & paste this file to the top of the .m?\n",
        "created_at": "2014-11-04T03:06:29Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783536",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783536"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783536"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783542",
        "pull_request_review_id": null,
        "id": 19783542,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNTQy",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": 12,
        "original_position": 1,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "missing license header\n",
        "created_at": "2014-11-04T03:06:46Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783542",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783542"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783542"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783633",
        "pull_request_review_id": null,
        "id": 19783633,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNjMz",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 140,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't understand this TODO - could you elaborate in the comment?\n",
        "created_at": "2014-11-04T03:11:55Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783633",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783633"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783633"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783652",
        "pull_request_review_id": null,
        "id": 19783652,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNjUy",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 138,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Naming convention in Obj-C is:\n- setSomeFoo:\n- someFoo    <-- no get prefix\n",
        "created_at": "2014-11-04T03:12:45Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783652",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783652"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783652"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783678",
        "pull_request_review_id": null,
        "id": 19783678,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNjc4",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 228,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "no need to make a copy here\n",
        "created_at": "2014-11-04T03:14:40Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783678",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783678"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783678"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783688",
        "pull_request_review_id": null,
        "id": 19783688,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNjg4",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 289,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "is the copy necessary?\n",
        "created_at": "2014-11-04T03:15:23Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783688",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783688"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783688"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783719",
        "pull_request_review_id": null,
        "id": 19783719,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzNzE5",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],\n+        @\"instanceId\": characteristicId,\n+    };\n+}\n+\n+- (NSData*)getCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return characteristic.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getCharacteristicInfoByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return [self buildCharacteristicInfo:characteristic];\n+    }\n+    return nil;\n+}\n+\n+- (BOOL)discoveryCharacteristicsByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverCharacteristics:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral readValueForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeCharacteristicValueByCharacteristicId:(NSString*)characteristicId value:(NSData*)value\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)setCharacteristicNotificationValue:(BOOL)enabled CharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral setNotifyValue:enabled forCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildDescriptorInfo:(CBDescriptor*)descriptor\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    \n+    if (!_knownDescriptors[descriptorId]) {\n+        _knownDescriptors[descriptorId] = descriptor;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [descriptor.UUID UUIDString],\n+        @\"characteristic\": [self buildCharacteristicInfo:descriptor.characteristic],\n+        @\"instanceId\": descriptorId,\n+    };\n+}\n+\n+- (NSData*)getDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return descriptor.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getDescriptorInfoByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return [self buildDescriptorInfo:descriptor];\n+    }\n+    \n+    return nil;\n+}\n+\n+- (BOOL)discoveryDescriptorByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral discoverDescriptorsForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral readValueForDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeDescriptorValueByDescriptorId:(NSString*)descriptorId value:(NSData*)value\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral writeValue:value forDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (void)cleanup\n+{\n+    if (!_peripheral.isConnected) {\n+        return;\n+    }\n+    \n+    for (CBService* service in _peripheral.services) {\n+        for (CBCharacteristic* characteristic in service.characteristics) {\n+            if (characteristic.isNotifying) {\n+                [_peripheral setNotifyValue:NO forCharacteristic:characteristic];\n+            }\n+        }\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin disconnectPeripheral:_peripheral];\n+    return;\n+}\n+\n+# pragma mark CBPeripheralDelegate methods\n+\n+// Note: this delegate does not work correctly for cached device.\n+// See: http://stackoverflow.com/questions/13180134/corebluetooth-refreshing-local-name-of-an-already-discovered-peripheral\n+- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral\n+{\n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray *)invalidatedServices\n+{\n+    for (CBService* service in invalidatedServices) {\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+        [_knownServices removeObjectForKey:[self getServiceIdFromService:service]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n+{\n+    for (CBService* service in peripheral.services) {\n+        [_plugin sendServiceAddedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* includedServicesInfo = [NSMutableArray array];\n+    for (CBService* includedService in service.includedServices) {\n+        NSDictionary* serviceInfo = [self buildServiceInfo:includedService];\n+        [includedServicesInfo addObject:serviceInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getIncludedServicesCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([includedServicesInfo copy], error);",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 479,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "excess copy?\n",
        "created_at": "2014-11-04T03:17:37Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783719",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783719"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783719"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783864",
        "pull_request_review_id": null,
        "id": 19783864,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzODY0",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],\n+        @\"instanceId\": characteristicId,\n+    };\n+}\n+\n+- (NSData*)getCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return characteristic.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getCharacteristicInfoByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return [self buildCharacteristicInfo:characteristic];\n+    }\n+    return nil;\n+}\n+\n+- (BOOL)discoveryCharacteristicsByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverCharacteristics:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral readValueForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeCharacteristicValueByCharacteristicId:(NSString*)characteristicId value:(NSData*)value\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)setCharacteristicNotificationValue:(BOOL)enabled CharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral setNotifyValue:enabled forCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildDescriptorInfo:(CBDescriptor*)descriptor\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    \n+    if (!_knownDescriptors[descriptorId]) {\n+        _knownDescriptors[descriptorId] = descriptor;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [descriptor.UUID UUIDString],\n+        @\"characteristic\": [self buildCharacteristicInfo:descriptor.characteristic],\n+        @\"instanceId\": descriptorId,\n+    };\n+}\n+\n+- (NSData*)getDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return descriptor.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getDescriptorInfoByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return [self buildDescriptorInfo:descriptor];\n+    }\n+    \n+    return nil;\n+}\n+\n+- (BOOL)discoveryDescriptorByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral discoverDescriptorsForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral readValueForDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeDescriptorValueByDescriptorId:(NSString*)descriptorId value:(NSData*)value\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral writeValue:value forDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (void)cleanup\n+{\n+    if (!_peripheral.isConnected) {\n+        return;\n+    }\n+    \n+    for (CBService* service in _peripheral.services) {\n+        for (CBCharacteristic* characteristic in service.characteristics) {\n+            if (characteristic.isNotifying) {\n+                [_peripheral setNotifyValue:NO forCharacteristic:characteristic];\n+            }\n+        }\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin disconnectPeripheral:_peripheral];\n+    return;\n+}\n+\n+# pragma mark CBPeripheralDelegate methods\n+\n+// Note: this delegate does not work correctly for cached device.\n+// See: http://stackoverflow.com/questions/13180134/corebluetooth-refreshing-local-name-of-an-already-discovered-peripheral\n+- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral\n+{\n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray *)invalidatedServices\n+{\n+    for (CBService* service in invalidatedServices) {\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+        [_knownServices removeObjectForKey:[self getServiceIdFromService:service]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n+{\n+    for (CBService* service in peripheral.services) {\n+        [_plugin sendServiceAddedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* includedServicesInfo = [NSMutableArray array];\n+    for (CBService* includedService in service.includedServices) {\n+        NSDictionary* serviceInfo = [self buildServiceInfo:includedService];\n+        [includedServicesInfo addObject:serviceInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getIncludedServicesCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([includedServicesInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* characteristicsInfo = [NSMutableArray array];\n+    for (CBCharacteristic* characteristic in service.characteristics) {\n+        NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+        [characteristicsInfo addObject:characteristicInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getCharacteristicsCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([characteristicsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+    NSMutableArray* multipartMessage = [@[\n+        characteristicInfo[@\"uuid\"],\n+        characteristicInfo[@\"service\"],\n+        characteristicInfo[@\"properties\"],\n+        characteristicInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (characteristic.value) {\n+        [multipartMessage addObject:characteristic.value];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _readCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_readCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback([multipartMessage copy], error);\n+    }\n+    \n+    if (characteristic.isNotifying) {\n+        [_plugin sendCharacteristicValueChangedEvent:[multipartMessage copy]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSError*) = _writeCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_writeCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback(error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    if (characteristic.isNotifying) { // start notification\n+        void (^callback)(NSError*) = _startCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_startCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    } else { // stop notification\n+        void (^callback)(NSError*) = _stopCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_stopCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSMutableArray* descriptorsInfo = [NSMutableArray array];\n+    for (CBDescriptor* descriptor in characteristic.descriptors) {\n+        [descriptorsInfo addObject:[self buildDescriptorInfo:descriptor]];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _getDescriptorsCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_getDescriptorsCallbacks removeObjectForKey:characteristicId];\n+        callback([descriptorsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSDictionary* descriptorInfo = [self buildDescriptorInfo:descriptor];\n+    \n+    NSMutableArray* multipartMessage = [@[\n+        descriptorInfo[@\"uuid\"],\n+        descriptorInfo[@\"characteristic\"],\n+        descriptorInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (descriptor.value) {\n+        [multipartMessage addObject:descriptor.value];\n+    }\n+    \n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSArray*, NSError*) = _readDescriptorValueCallbacks[descriptorId];\n+    if (callback != nil) {\n+        [_readDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(multipartMessage, error);\n+    }\n+    \n+    [_plugin sendDescriptorValueChangedEvent:[multipartMessage copy]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSError*) = [_writeDescriptorValueCallbacks objectForKey:descriptorId];\n+    if (callback != nil) {\n+        [_writeDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(error);\n+    }\n+}\n+\n+@end\n+\n+@implementation ChromeBluetooth\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView *)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];\n+        _peripherals = [NSMutableDictionary dictionary];\n+        _addressUUIDMap = [NSMutableDictionary dictionary];\n+        _activePeripherals = [NSMutableSet set];\n+    }\n+    return self;\n+}\n+\n+#pragma mark chrome.bluetooth implementations\n+- (ChromeBluetoothPeripheral*)getPeripheralByAddress:(NSString*)address\n+{\n+    NSUUID* uuid = _addressUUIDMap[address];\n+    if (uuid) {\n+        return _peripherals[uuid];\n+    }\n+    return nil;\n+}\n+\n+- (NSDictionary*)getAdapterStateInfo\n+{\n+    BOOL isPoweredOn = NO;\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        isPoweredOn = YES;\n+    }\n+    \n+    return @{\n+        @\"name\": [[UIDevice currentDevice] name],\n+        // getifaddrs() returns 02:00:00:00:00:00 since iOS7\n+        @\"address\": @\"02:00:00:00:00:00\",\n+        @\"discovering\": [NSNumber numberWithBool:NO],\n+        @\"available\": [NSNumber numberWithBool:isPoweredOn],\n+        @\"powered\": [NSNumber numberWithBool:isPoweredOn],\n+    };\n+}\n+\n+- (void)getAdapterState:(CDVInvokedUrlCommand*)command\n+{\n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]] callbackId:command.callbackId];\n+    \n+}\n+\n+- (void)getDevice:(CDVInvokedUrlCommand*)command\n+{\n+    NSString* deviceAddress = [command argumentAtIndex:0];\n+ \n+    ChromeBluetoothPeripheral* chromePeripheral =[self getPeripheralByAddress:deviceAddress];\n+        \n+    if (chromePeripheral) {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[chromePeripheral getDeviceInfo]] callbackId:command.callbackId];\n+    } else {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@\"Invalid Argument\"] callbackId:command.callbackId];\n+    }\n+}\n+\n+- (void)getDevices:(CDVInvokedUrlCommand*)command\n+{\n+    NSArray *allPeripherals = [_peripherals allValues];\n+    NSMutableArray *allDeviceInfo = [NSMutableArray array];\n+    \n+    for (ChromeBluetoothPeripheral* peripheral in allPeripherals) {\n+        [allDeviceInfo addObject:[peripheral getDeviceInfo]];\n+    }\n+    \n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsArray:[allDeviceInfo copy]] callbackId:command.callbackId];\n+}\n+\n+- (void)registerAdapterStateChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _adapterStateChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceAddedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceAddedCallbackId = command.callbackId;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo\n+{\n+    CDVPluginResult* deviceChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:deviceInfo];\n+    [deviceChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:deviceChangedResult callbackId:_deviceChangedCallbackId];\n+}\n+\n+- (void)registerDeviceChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceRemovedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceRemovedCallbackId = command.callbackId;\n+}\n+\n+- (void)checkRemovedDevice:(id)sender",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 704,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Purpose of this method isn't obvious from its name. Can you add a comment saying what it does?\n",
        "created_at": "2014-11-04T03:23:43Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783864",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783864"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783864"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783904",
        "pull_request_review_id": null,
        "id": 19783904,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzOTA0",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],\n+        @\"instanceId\": characteristicId,\n+    };\n+}\n+\n+- (NSData*)getCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return characteristic.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getCharacteristicInfoByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return [self buildCharacteristicInfo:characteristic];\n+    }\n+    return nil;\n+}\n+\n+- (BOOL)discoveryCharacteristicsByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverCharacteristics:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral readValueForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeCharacteristicValueByCharacteristicId:(NSString*)characteristicId value:(NSData*)value\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)setCharacteristicNotificationValue:(BOOL)enabled CharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral setNotifyValue:enabled forCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildDescriptorInfo:(CBDescriptor*)descriptor\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    \n+    if (!_knownDescriptors[descriptorId]) {\n+        _knownDescriptors[descriptorId] = descriptor;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [descriptor.UUID UUIDString],\n+        @\"characteristic\": [self buildCharacteristicInfo:descriptor.characteristic],\n+        @\"instanceId\": descriptorId,\n+    };\n+}\n+\n+- (NSData*)getDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return descriptor.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getDescriptorInfoByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return [self buildDescriptorInfo:descriptor];\n+    }\n+    \n+    return nil;\n+}\n+\n+- (BOOL)discoveryDescriptorByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral discoverDescriptorsForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral readValueForDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeDescriptorValueByDescriptorId:(NSString*)descriptorId value:(NSData*)value\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral writeValue:value forDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (void)cleanup\n+{\n+    if (!_peripheral.isConnected) {\n+        return;\n+    }\n+    \n+    for (CBService* service in _peripheral.services) {\n+        for (CBCharacteristic* characteristic in service.characteristics) {\n+            if (characteristic.isNotifying) {\n+                [_peripheral setNotifyValue:NO forCharacteristic:characteristic];\n+            }\n+        }\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin disconnectPeripheral:_peripheral];\n+    return;\n+}\n+\n+# pragma mark CBPeripheralDelegate methods\n+\n+// Note: this delegate does not work correctly for cached device.\n+// See: http://stackoverflow.com/questions/13180134/corebluetooth-refreshing-local-name-of-an-already-discovered-peripheral\n+- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral\n+{\n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray *)invalidatedServices\n+{\n+    for (CBService* service in invalidatedServices) {\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+        [_knownServices removeObjectForKey:[self getServiceIdFromService:service]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n+{\n+    for (CBService* service in peripheral.services) {\n+        [_plugin sendServiceAddedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* includedServicesInfo = [NSMutableArray array];\n+    for (CBService* includedService in service.includedServices) {\n+        NSDictionary* serviceInfo = [self buildServiceInfo:includedService];\n+        [includedServicesInfo addObject:serviceInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getIncludedServicesCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([includedServicesInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* characteristicsInfo = [NSMutableArray array];\n+    for (CBCharacteristic* characteristic in service.characteristics) {\n+        NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+        [characteristicsInfo addObject:characteristicInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getCharacteristicsCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([characteristicsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+    NSMutableArray* multipartMessage = [@[\n+        characteristicInfo[@\"uuid\"],\n+        characteristicInfo[@\"service\"],\n+        characteristicInfo[@\"properties\"],\n+        characteristicInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (characteristic.value) {\n+        [multipartMessage addObject:characteristic.value];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _readCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_readCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback([multipartMessage copy], error);\n+    }\n+    \n+    if (characteristic.isNotifying) {\n+        [_plugin sendCharacteristicValueChangedEvent:[multipartMessage copy]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSError*) = _writeCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_writeCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback(error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    if (characteristic.isNotifying) { // start notification\n+        void (^callback)(NSError*) = _startCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_startCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    } else { // stop notification\n+        void (^callback)(NSError*) = _stopCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_stopCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSMutableArray* descriptorsInfo = [NSMutableArray array];\n+    for (CBDescriptor* descriptor in characteristic.descriptors) {\n+        [descriptorsInfo addObject:[self buildDescriptorInfo:descriptor]];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _getDescriptorsCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_getDescriptorsCallbacks removeObjectForKey:characteristicId];\n+        callback([descriptorsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSDictionary* descriptorInfo = [self buildDescriptorInfo:descriptor];\n+    \n+    NSMutableArray* multipartMessage = [@[\n+        descriptorInfo[@\"uuid\"],\n+        descriptorInfo[@\"characteristic\"],\n+        descriptorInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (descriptor.value) {\n+        [multipartMessage addObject:descriptor.value];\n+    }\n+    \n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSArray*, NSError*) = _readDescriptorValueCallbacks[descriptorId];\n+    if (callback != nil) {\n+        [_readDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(multipartMessage, error);\n+    }\n+    \n+    [_plugin sendDescriptorValueChangedEvent:[multipartMessage copy]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSError*) = [_writeDescriptorValueCallbacks objectForKey:descriptorId];\n+    if (callback != nil) {\n+        [_writeDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(error);\n+    }\n+}\n+\n+@end\n+\n+@implementation ChromeBluetooth\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView *)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];\n+        _peripherals = [NSMutableDictionary dictionary];\n+        _addressUUIDMap = [NSMutableDictionary dictionary];\n+        _activePeripherals = [NSMutableSet set];\n+    }\n+    return self;\n+}\n+\n+#pragma mark chrome.bluetooth implementations\n+- (ChromeBluetoothPeripheral*)getPeripheralByAddress:(NSString*)address\n+{\n+    NSUUID* uuid = _addressUUIDMap[address];\n+    if (uuid) {\n+        return _peripherals[uuid];\n+    }\n+    return nil;\n+}\n+\n+- (NSDictionary*)getAdapterStateInfo\n+{\n+    BOOL isPoweredOn = NO;\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        isPoweredOn = YES;\n+    }\n+    \n+    return @{\n+        @\"name\": [[UIDevice currentDevice] name],\n+        // getifaddrs() returns 02:00:00:00:00:00 since iOS7\n+        @\"address\": @\"02:00:00:00:00:00\",\n+        @\"discovering\": [NSNumber numberWithBool:NO],\n+        @\"available\": [NSNumber numberWithBool:isPoweredOn],\n+        @\"powered\": [NSNumber numberWithBool:isPoweredOn],\n+    };\n+}\n+\n+- (void)getAdapterState:(CDVInvokedUrlCommand*)command\n+{\n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]] callbackId:command.callbackId];\n+    \n+}\n+\n+- (void)getDevice:(CDVInvokedUrlCommand*)command\n+{\n+    NSString* deviceAddress = [command argumentAtIndex:0];\n+ \n+    ChromeBluetoothPeripheral* chromePeripheral =[self getPeripheralByAddress:deviceAddress];\n+        \n+    if (chromePeripheral) {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[chromePeripheral getDeviceInfo]] callbackId:command.callbackId];\n+    } else {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@\"Invalid Argument\"] callbackId:command.callbackId];\n+    }\n+}\n+\n+- (void)getDevices:(CDVInvokedUrlCommand*)command\n+{\n+    NSArray *allPeripherals = [_peripherals allValues];\n+    NSMutableArray *allDeviceInfo = [NSMutableArray array];\n+    \n+    for (ChromeBluetoothPeripheral* peripheral in allPeripherals) {\n+        [allDeviceInfo addObject:[peripheral getDeviceInfo]];\n+    }\n+    \n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsArray:[allDeviceInfo copy]] callbackId:command.callbackId];\n+}\n+\n+- (void)registerAdapterStateChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _adapterStateChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceAddedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceAddedCallbackId = command.callbackId;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo\n+{\n+    CDVPluginResult* deviceChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:deviceInfo];\n+    [deviceChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:deviceChangedResult callbackId:_deviceChangedCallbackId];\n+}\n+\n+- (void)registerDeviceChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceRemovedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceRemovedCallbackId = command.callbackId;\n+}\n+\n+- (void)checkRemovedDevice:(id)sender\n+{\n+    NSArray* activeDeviceAddrs = [_activePeripherals allObjects];\n+    NSMutableArray* removedDeviceAddrs = [[_peripherals allKeys] mutableCopy];\n+    [removedDeviceAddrs removeObjectsInArray:activeDeviceAddrs];\n+    [_activePeripherals removeAllObjects];\n+    \n+    for (NSString* deviceAddr in removedDeviceAddrs) {\n+        ChromeBluetoothPeripheral* peripheral = _peripherals[deviceAddr];\n+        CDVPluginResult* deviceRemovedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[peripheral getDeviceInfo]];\n+        [deviceRemovedResult setKeepCallbackAsBool:YES];\n+        [self.commandDelegate sendPluginResult:deviceRemovedResult callbackId:_deviceRemovedCallbackId];\n+        [peripheral cleanup];\n+        [_addressUUIDMap removeObjectForKey:[peripheral->_peripheral identifier]];\n+        [_peripherals removeObjectForKey:deviceAddr];\n+    }\n+}\n+#pragma mark CBCentralManagerDelegate methods\n+\n+- (void)centralManagerDidUpdateState:(CBCentralManager *)central\n+{\n+    CDVPluginResult* adapterStateChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]];\n+    [adapterStateChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:adapterStateChangedResult callbackId:_adapterStateChangedCallbackId];\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        [_centralManager scanForPeripheralsWithServices:nil options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES}];\n+        _removedDeviceTimer = [NSTimer scheduledTimerWithTimeInterval:REMOVED_DEVICE_CHECKING_INTERVAL target:self selector:@selector(checkRemovedDevice:) userInfo:nil repeats:YES];",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 731,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "should you invalidate this before re-assigning it?\n",
        "created_at": "2014-11-04T03:26:38Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783904",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783904"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783904"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783959",
        "pull_request_review_id": null,
        "id": 19783959,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzOTU5",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],\n+        @\"instanceId\": characteristicId,\n+    };\n+}\n+\n+- (NSData*)getCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return characteristic.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getCharacteristicInfoByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return [self buildCharacteristicInfo:characteristic];\n+    }\n+    return nil;\n+}\n+\n+- (BOOL)discoveryCharacteristicsByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverCharacteristics:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral readValueForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeCharacteristicValueByCharacteristicId:(NSString*)characteristicId value:(NSData*)value\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)setCharacteristicNotificationValue:(BOOL)enabled CharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral setNotifyValue:enabled forCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildDescriptorInfo:(CBDescriptor*)descriptor\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    \n+    if (!_knownDescriptors[descriptorId]) {\n+        _knownDescriptors[descriptorId] = descriptor;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [descriptor.UUID UUIDString],\n+        @\"characteristic\": [self buildCharacteristicInfo:descriptor.characteristic],\n+        @\"instanceId\": descriptorId,\n+    };\n+}\n+\n+- (NSData*)getDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return descriptor.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getDescriptorInfoByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return [self buildDescriptorInfo:descriptor];\n+    }\n+    \n+    return nil;\n+}\n+\n+- (BOOL)discoveryDescriptorByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral discoverDescriptorsForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral readValueForDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeDescriptorValueByDescriptorId:(NSString*)descriptorId value:(NSData*)value\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral writeValue:value forDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (void)cleanup\n+{\n+    if (!_peripheral.isConnected) {\n+        return;\n+    }\n+    \n+    for (CBService* service in _peripheral.services) {\n+        for (CBCharacteristic* characteristic in service.characteristics) {\n+            if (characteristic.isNotifying) {\n+                [_peripheral setNotifyValue:NO forCharacteristic:characteristic];\n+            }\n+        }\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin disconnectPeripheral:_peripheral];\n+    return;\n+}\n+\n+# pragma mark CBPeripheralDelegate methods\n+\n+// Note: this delegate does not work correctly for cached device.\n+// See: http://stackoverflow.com/questions/13180134/corebluetooth-refreshing-local-name-of-an-already-discovered-peripheral\n+- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral\n+{\n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray *)invalidatedServices\n+{\n+    for (CBService* service in invalidatedServices) {\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+        [_knownServices removeObjectForKey:[self getServiceIdFromService:service]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n+{\n+    for (CBService* service in peripheral.services) {\n+        [_plugin sendServiceAddedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* includedServicesInfo = [NSMutableArray array];\n+    for (CBService* includedService in service.includedServices) {\n+        NSDictionary* serviceInfo = [self buildServiceInfo:includedService];\n+        [includedServicesInfo addObject:serviceInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getIncludedServicesCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([includedServicesInfo copy], error);",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 479,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I use `copy` to convert a `mutable` container to `immutable`. I can remove them if it's unnecessary.\n",
        "created_at": "2014-11-04T03:29:34Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783959",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783959"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783959"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783986",
        "pull_request_review_id": null,
        "id": 19783986,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzgzOTg2",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],\n+        @\"instanceId\": characteristicId,\n+    };\n+}\n+\n+- (NSData*)getCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return characteristic.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getCharacteristicInfoByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return [self buildCharacteristicInfo:characteristic];\n+    }\n+    return nil;\n+}\n+\n+- (BOOL)discoveryCharacteristicsByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverCharacteristics:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral readValueForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeCharacteristicValueByCharacteristicId:(NSString*)characteristicId value:(NSData*)value\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)setCharacteristicNotificationValue:(BOOL)enabled CharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral setNotifyValue:enabled forCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildDescriptorInfo:(CBDescriptor*)descriptor\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    \n+    if (!_knownDescriptors[descriptorId]) {\n+        _knownDescriptors[descriptorId] = descriptor;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [descriptor.UUID UUIDString],\n+        @\"characteristic\": [self buildCharacteristicInfo:descriptor.characteristic],\n+        @\"instanceId\": descriptorId,\n+    };\n+}\n+\n+- (NSData*)getDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return descriptor.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getDescriptorInfoByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return [self buildDescriptorInfo:descriptor];\n+    }\n+    \n+    return nil;\n+}\n+\n+- (BOOL)discoveryDescriptorByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral discoverDescriptorsForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral readValueForDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeDescriptorValueByDescriptorId:(NSString*)descriptorId value:(NSData*)value\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral writeValue:value forDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (void)cleanup\n+{\n+    if (!_peripheral.isConnected) {\n+        return;\n+    }\n+    \n+    for (CBService* service in _peripheral.services) {\n+        for (CBCharacteristic* characteristic in service.characteristics) {\n+            if (characteristic.isNotifying) {\n+                [_peripheral setNotifyValue:NO forCharacteristic:characteristic];\n+            }\n+        }\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin disconnectPeripheral:_peripheral];\n+    return;\n+}\n+\n+# pragma mark CBPeripheralDelegate methods\n+\n+// Note: this delegate does not work correctly for cached device.\n+// See: http://stackoverflow.com/questions/13180134/corebluetooth-refreshing-local-name-of-an-already-discovered-peripheral\n+- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral\n+{\n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray *)invalidatedServices\n+{\n+    for (CBService* service in invalidatedServices) {\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+        [_knownServices removeObjectForKey:[self getServiceIdFromService:service]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n+{\n+    for (CBService* service in peripheral.services) {\n+        [_plugin sendServiceAddedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* includedServicesInfo = [NSMutableArray array];\n+    for (CBService* includedService in service.includedServices) {\n+        NSDictionary* serviceInfo = [self buildServiceInfo:includedService];\n+        [includedServicesInfo addObject:serviceInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getIncludedServicesCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([includedServicesInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* characteristicsInfo = [NSMutableArray array];\n+    for (CBCharacteristic* characteristic in service.characteristics) {\n+        NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+        [characteristicsInfo addObject:characteristicInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getCharacteristicsCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([characteristicsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+    NSMutableArray* multipartMessage = [@[\n+        characteristicInfo[@\"uuid\"],\n+        characteristicInfo[@\"service\"],\n+        characteristicInfo[@\"properties\"],\n+        characteristicInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (characteristic.value) {\n+        [multipartMessage addObject:characteristic.value];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _readCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_readCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback([multipartMessage copy], error);\n+    }\n+    \n+    if (characteristic.isNotifying) {\n+        [_plugin sendCharacteristicValueChangedEvent:[multipartMessage copy]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSError*) = _writeCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_writeCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback(error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    if (characteristic.isNotifying) { // start notification\n+        void (^callback)(NSError*) = _startCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_startCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    } else { // stop notification\n+        void (^callback)(NSError*) = _stopCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_stopCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSMutableArray* descriptorsInfo = [NSMutableArray array];\n+    for (CBDescriptor* descriptor in characteristic.descriptors) {\n+        [descriptorsInfo addObject:[self buildDescriptorInfo:descriptor]];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _getDescriptorsCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_getDescriptorsCallbacks removeObjectForKey:characteristicId];\n+        callback([descriptorsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSDictionary* descriptorInfo = [self buildDescriptorInfo:descriptor];\n+    \n+    NSMutableArray* multipartMessage = [@[\n+        descriptorInfo[@\"uuid\"],\n+        descriptorInfo[@\"characteristic\"],\n+        descriptorInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (descriptor.value) {\n+        [multipartMessage addObject:descriptor.value];\n+    }\n+    \n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSArray*, NSError*) = _readDescriptorValueCallbacks[descriptorId];\n+    if (callback != nil) {\n+        [_readDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(multipartMessage, error);\n+    }\n+    \n+    [_plugin sendDescriptorValueChangedEvent:[multipartMessage copy]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSError*) = [_writeDescriptorValueCallbacks objectForKey:descriptorId];\n+    if (callback != nil) {\n+        [_writeDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(error);\n+    }\n+}\n+\n+@end\n+\n+@implementation ChromeBluetooth\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView *)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];\n+        _peripherals = [NSMutableDictionary dictionary];\n+        _addressUUIDMap = [NSMutableDictionary dictionary];\n+        _activePeripherals = [NSMutableSet set];\n+    }\n+    return self;\n+}\n+\n+#pragma mark chrome.bluetooth implementations\n+- (ChromeBluetoothPeripheral*)getPeripheralByAddress:(NSString*)address\n+{\n+    NSUUID* uuid = _addressUUIDMap[address];\n+    if (uuid) {\n+        return _peripherals[uuid];\n+    }\n+    return nil;\n+}\n+\n+- (NSDictionary*)getAdapterStateInfo\n+{\n+    BOOL isPoweredOn = NO;\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        isPoweredOn = YES;\n+    }\n+    \n+    return @{\n+        @\"name\": [[UIDevice currentDevice] name],\n+        // getifaddrs() returns 02:00:00:00:00:00 since iOS7\n+        @\"address\": @\"02:00:00:00:00:00\",\n+        @\"discovering\": [NSNumber numberWithBool:NO],\n+        @\"available\": [NSNumber numberWithBool:isPoweredOn],\n+        @\"powered\": [NSNumber numberWithBool:isPoweredOn],\n+    };\n+}\n+\n+- (void)getAdapterState:(CDVInvokedUrlCommand*)command\n+{\n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]] callbackId:command.callbackId];\n+    \n+}\n+\n+- (void)getDevice:(CDVInvokedUrlCommand*)command\n+{\n+    NSString* deviceAddress = [command argumentAtIndex:0];\n+ \n+    ChromeBluetoothPeripheral* chromePeripheral =[self getPeripheralByAddress:deviceAddress];\n+        \n+    if (chromePeripheral) {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[chromePeripheral getDeviceInfo]] callbackId:command.callbackId];\n+    } else {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@\"Invalid Argument\"] callbackId:command.callbackId];\n+    }\n+}\n+\n+- (void)getDevices:(CDVInvokedUrlCommand*)command\n+{\n+    NSArray *allPeripherals = [_peripherals allValues];\n+    NSMutableArray *allDeviceInfo = [NSMutableArray array];\n+    \n+    for (ChromeBluetoothPeripheral* peripheral in allPeripherals) {\n+        [allDeviceInfo addObject:[peripheral getDeviceInfo]];\n+    }\n+    \n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsArray:[allDeviceInfo copy]] callbackId:command.callbackId];\n+}\n+\n+- (void)registerAdapterStateChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _adapterStateChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceAddedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceAddedCallbackId = command.callbackId;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo\n+{\n+    CDVPluginResult* deviceChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:deviceInfo];\n+    [deviceChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:deviceChangedResult callbackId:_deviceChangedCallbackId];\n+}\n+\n+- (void)registerDeviceChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceRemovedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceRemovedCallbackId = command.callbackId;\n+}\n+\n+- (void)checkRemovedDevice:(id)sender\n+{\n+    NSArray* activeDeviceAddrs = [_activePeripherals allObjects];\n+    NSMutableArray* removedDeviceAddrs = [[_peripherals allKeys] mutableCopy];\n+    [removedDeviceAddrs removeObjectsInArray:activeDeviceAddrs];\n+    [_activePeripherals removeAllObjects];\n+    \n+    for (NSString* deviceAddr in removedDeviceAddrs) {\n+        ChromeBluetoothPeripheral* peripheral = _peripherals[deviceAddr];\n+        CDVPluginResult* deviceRemovedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[peripheral getDeviceInfo]];\n+        [deviceRemovedResult setKeepCallbackAsBool:YES];\n+        [self.commandDelegate sendPluginResult:deviceRemovedResult callbackId:_deviceRemovedCallbackId];\n+        [peripheral cleanup];\n+        [_addressUUIDMap removeObjectForKey:[peripheral->_peripheral identifier]];\n+        [_peripherals removeObjectForKey:deviceAddr];\n+    }\n+}\n+#pragma mark CBCentralManagerDelegate methods\n+\n+- (void)centralManagerDidUpdateState:(CBCentralManager *)central\n+{\n+    CDVPluginResult* adapterStateChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]];\n+    [adapterStateChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:adapterStateChangedResult callbackId:_adapterStateChangedCallbackId];\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        [_centralManager scanForPeripheralsWithServices:nil options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES}];\n+        _removedDeviceTimer = [NSTimer scheduledTimerWithTimeInterval:REMOVED_DEVICE_CHECKING_INTERVAL target:self selector:@selector(checkRemovedDevice:) userInfo:nil repeats:YES];\n+    } else {\n+        [_removedDeviceTimer invalidate];\n+        \n+        [_centralManager stopScan];\n+        [_activePeripherals removeAllObjects];\n+        for (NSUUID* uuid in _peripherals) {\n+            [_peripherals[uuid] cleanup];\n+        }\n+        [_peripherals removeAllObjects];\n+    }\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI\n+{\n+    NSUUID* uuid = peripheral.identifier;\n+    [_activePeripherals addObject:uuid];\n+    \n+    ChromeBluetoothPeripheral* foundPeripheral = _peripherals[uuid];\n+    if (foundPeripheral) {\n+        foundPeripheral->_adData = advertisementData;\n+        return;\n+    }\n+   \n+    ChromeBluetoothPeripheral* chromePeripheral = [[ChromeBluetoothPeripheral alloc] initWithPeripheral:peripheral adData:advertisementData plugin:self];\n+    \n+    _addressUUIDMap[[chromePeripheral getPeripheralAddress]] = peripheral.identifier;\n+    _peripherals[uuid] = chromePeripheral;\n+    CDVPluginResult* deviceAddedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[chromePeripheral getDeviceInfo]];\n+    [deviceAddedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:deviceAddedResult callbackId:_deviceAddedCallbackId];\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral\n+{\n+    ChromeBluetoothPeripheral* chromePeripheral = _peripherals[peripheral.identifier];\n+    if (!chromePeripheral)\n+        return;\n+    \n+    VERBOSE_LOG(@\"Device %@ connected\", [chromePeripheral getPeripheralAddress]);\n+    \n+    [self sendDeviceChangedEvent:[chromePeripheral getDeviceInfo]];\n+    \n+    [peripheral discoverServices:nil];\n+    \n+    void (^callback)(NSError*) = chromePeripheral->_connectCallback;\n+    if (callback != nil) {\n+        chromePeripheral->_connectCallback = nil;\n+        callback(nil);\n+    }\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error\n+{\n+    ChromeBluetoothPeripheral* chromePeripheral = _peripherals[peripheral.identifier];\n+    if (!chromePeripheral)\n+        return;\n+    \n+    void (^callback)(NSError*) = chromePeripheral->_connectCallback;",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 789,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "These 5 lines are repeated a lot. Probably makes sense to create a helper. E.g.:\n\n```\n- callAndClear:(void (^)(NSError*)*)callback\n```\n\n(or however the heck you declare a pointer to a block callback!)\n",
        "created_at": "2014-11-04T03:31:09Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783986",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19783986"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19783986"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784037",
        "pull_request_review_id": null,
        "id": 19784037,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Nzg0MDM3",
        "diff_hunk": "@@ -0,0 +1,1263 @@\n+#import <CoreBluetooth/CoreBluetooth.h>\n+#import \"ChromeBluetooth.h\"\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetoothPeripheral interface\n+\n+@interface ChromeBluetoothPeripheral : NSObject<CBPeripheralDelegate> {\n+    @public\n+    __weak ChromeBluetooth* _plugin;\n+    CBPeripheral* _peripheral;\n+    NSDictionary* _adData;\n+    \n+    // <InstanceId, CBService>\n+    NSMutableDictionary* _knownServices;\n+    // <InstanceId, CBCharacteristic>\n+    NSMutableDictionary* _knownCharacteristics;\n+    // <InstanceId, CBDescriptor>\n+    NSMutableDictionary* _knownDescriptors;\n+    \n+    id _connectCallback;\n+    id _disconnectCallback;\n+    \n+    NSMutableDictionary* _getIncludedServicesCallbacks;\n+    NSMutableDictionary* _getCharacteristicsCallbacks;\n+    NSMutableDictionary* _getDescriptorsCallbacks;\n+    NSMutableDictionary* _readCharacteristicValueCallbacks;\n+    NSMutableDictionary* _writeCharacteristicValueCallbacks;\n+    NSMutableDictionary* _startCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _stopCharacteristicNotificationCallbacks;\n+    NSMutableDictionary* _readDescriptorValueCallbacks;\n+    NSMutableDictionary* _writeDescriptorValueCallbacks;\n+}\n+\n+@end\n+\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth() <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo;\n+- (void)sendServiceAddedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceChangedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendServiceRemovedEvent:(NSDictionary*)serviceInfo;\n+- (void)sendCharacteristicValueChangedEvent:(NSArray*)characteristicInfo;\n+- (void)sendDescriptorValueChangedEvent:(NSArray*)descriptroInfo;\n+- (void)disconnectPeripheral:(CBPeripheral*)peripheral;\n+\n+@end\n+\n+@implementation ChromeBluetoothPeripheral\n+\n+- (ChromeBluetoothPeripheral*)initWithPeripheral:(CBPeripheral*)thePeripheral adData:(NSDictionary*)theAdData plugin:(ChromeBluetooth*)thePlugin\n+{\n+    self = [super init];\n+    if (self) {\n+        _peripheral = thePeripheral;\n+        [_peripheral setDelegate:self];\n+        _plugin = thePlugin;\n+        _adData = theAdData;\n+        \n+        _knownServices = [NSMutableDictionary dictionary];\n+        _knownCharacteristics = [NSMutableDictionary dictionary];\n+        _knownDescriptors = [NSMutableDictionary dictionary];\n+        \n+        _getIncludedServicesCallbacks = [NSMutableDictionary dictionary];\n+        _getCharacteristicsCallbacks = [NSMutableDictionary dictionary];\n+        _getDescriptorsCallbacks = [NSMutableDictionary dictionary];\n+        _readCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeCharacteristicValueCallbacks = [NSMutableDictionary dictionary];\n+        _startCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _stopCharacteristicNotificationCallbacks = [NSMutableDictionary dictionary];\n+        _readDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+        _writeDescriptorValueCallbacks = [NSMutableDictionary dictionary];\n+    }\n+    return self;\n+}\n+\n+- (NSString*)getPeripheralAddress\n+{\n+    // TODO: find a way function to hash an UUIDString to a bluetooth address.\n+    return _peripheral.identifier.UUIDString;\n+}\n+\n+- (NSString*)getServiceIdFromService:(CBService*)service\n+{\n+    return [NSString stringWithFormat:@\"%@/%@\", [self getPeripheralAddress], [service.UUID UUIDString]];\n+}\n+\n+- (NSString*)getCharacteristicIdFromCharacteristic:(CBCharacteristic*)characteristic\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@\", [self getPeripheralAddress], [characteristic.service.UUID UUIDString], [characteristic.UUID UUIDString]];\n+}\n+\n+- (NSString*)getDescriptorIdFromDescriptor:(CBDescriptor*)descriptor\n+{\n+    return [NSString stringWithFormat:@\"%@/%@%@%@\", [self getPeripheralAddress], [descriptor.characteristic.service.UUID UUIDString], [descriptor.characteristic.UUID UUIDString], [descriptor.UUID UUIDString]];\n+}\n+\n+- (BOOL)isConnected\n+{\n+    return _peripheral.state == CBPeripheralStateConnected;\n+}\n+\n+- (NSDictionary*)getDeviceInfo\n+{\n+    NSMutableDictionary* deviceInfo = [@{\n+        @\"address\": [self getPeripheralAddress],\n+        @\"connected\": [NSNumber numberWithBool:[_peripheral state] == CBPeripheralStateConnected],\n+    } mutableCopy];\n+   \n+    NSString* name = [_peripheral name];\n+    if (name) {\n+        deviceInfo[@\"name\"] = name;\n+    }\n+    \n+    NSMutableSet* serviceUuids = [NSMutableSet set];\n+    \n+    NSArray* adServices = _adData[CBAdvertisementDataServiceUUIDsKey];\n+    if (adServices && [adServices count] > 0) {\n+        for (CBUUID* serviceUuid in adServices) {\n+            [serviceUuids addObject:[serviceUuid UUIDString]];\n+        }\n+    }\n+    \n+    NSArray* services = [_peripheral services];\n+    if (services && [services count] > 0) {\n+        for (CBService* service in services) {\n+            [serviceUuids addObject:[service.UUID UUIDString]];\n+        }\n+    }\n+    \n+    deviceInfo[@\"uuids\"] = [serviceUuids allObjects];\n+    return [deviceInfo copy];\n+}\n+\n+- (NSDictionary*)buildServiceInfo:(CBService*)service\n+{\n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    \n+    if (!_knownServices[serviceId]) {\n+        _knownServices[serviceId] = service;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [service.UUID UUIDString],\n+        @\"deviceAddress\": [self getPeripheralAddress],\n+        @\"instanceId\": serviceId,\n+        @\"isPrimary\": [NSNumber numberWithBool:service.isPrimary],\n+    };\n+}\n+\n+- (NSDictionary*)getServiceInfoByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        return [self buildServiceInfo:service];\n+    }\n+    return nil;\n+}\n+\n+- (NSArray*)getServicesInfo\n+{\n+    NSMutableArray* servicesInfo = [NSMutableArray array];\n+    \n+    for (CBService* service in _peripheral.services) {\n+        [servicesInfo addObject:[self buildServiceInfo:service]];\n+    }\n+    return [servicesInfo copy];\n+}\n+\n+- (BOOL)discoveryIncludedServicesByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverIncludedServices:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildCharacteristicInfo:(CBCharacteristic*)characteristic\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    \n+    if (!_knownCharacteristics[characteristicId]) {\n+        _knownCharacteristics[characteristicId] = characteristic;\n+        if (characteristic.service) {\n+            [_plugin sendServiceChangedEvent:[self buildServiceInfo:characteristic.service]];\n+        }\n+    }\n+    \n+    NSMutableArray* properties = [NSMutableArray array];\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyBroadcast) {\n+        [properties addObject:@\"broadcast\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyRead) {\n+        [properties addObject:@\"read\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWriteWithoutResponse) {\n+        [properties addObject:@\"writeWithoutResponse\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyWrite) {\n+        [properties addObject:@\"write\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyNotify) {\n+        [properties addObject:@\"notify\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyIndicate) {\n+        [properties addObject:@\"indicate\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyAuthenticatedSignedWrites) {\n+        [properties addObject:@\"authenticatedSignedWrites\"];\n+    }\n+    \n+    if (characteristic.properties & CBCharacteristicPropertyExtendedProperties) {\n+        [properties addObject:@\"extendedProperties\"];\n+    }\n+    \n+    return @{\n+        @\"uuid\": [characteristic.UUID UUIDString],\n+        @\"service\": [self buildServiceInfo:characteristic.service],\n+        @\"properties\": [properties copy],\n+        @\"instanceId\": characteristicId,\n+    };\n+}\n+\n+- (NSData*)getCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return characteristic.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getCharacteristicInfoByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    \n+    if (characteristic) {\n+        return [self buildCharacteristicInfo:characteristic];\n+    }\n+    return nil;\n+}\n+\n+- (BOOL)discoveryCharacteristicsByServiceId:(NSString*)serviceId\n+{\n+    CBService* service = _knownServices[serviceId];\n+    if (service) {\n+        [_peripheral discoverCharacteristics:nil forService:service];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readCharacteristicValueByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral readValueForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeCharacteristicValueByCharacteristicId:(NSString*)characteristicId value:(NSData*)value\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)setCharacteristicNotificationValue:(BOOL)enabled CharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral setNotifyValue:enabled forCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (NSDictionary*)buildDescriptorInfo:(CBDescriptor*)descriptor\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    \n+    if (!_knownDescriptors[descriptorId]) {\n+        _knownDescriptors[descriptorId] = descriptor;\n+    }\n+    \n+    return @{\n+        @\"uuid\": [descriptor.UUID UUIDString],\n+        @\"characteristic\": [self buildCharacteristicInfo:descriptor.characteristic],\n+        @\"instanceId\": descriptorId,\n+    };\n+}\n+\n+- (NSData*)getDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return descriptor.value;\n+    }\n+    \n+    return nil;\n+}\n+\n+- (NSDictionary*)getDescriptorInfoByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    \n+    if (descriptor) {\n+        return [self buildDescriptorInfo:descriptor];\n+    }\n+    \n+    return nil;\n+}\n+\n+- (BOOL)discoveryDescriptorByCharacteristicId:(NSString*)characteristicId\n+{\n+    CBCharacteristic* characteristic = _knownCharacteristics[characteristicId];\n+    if (characteristic) {\n+        [_peripheral discoverDescriptorsForCharacteristic:characteristic];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)readDescriptorValueByDescriptorId:(NSString*)descriptorId\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral readValueForDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (BOOL)writeDescriptorValueByDescriptorId:(NSString*)descriptorId value:(NSData*)value\n+{\n+    CBDescriptor* descriptor = _knownDescriptors[descriptorId];\n+    if (descriptor) {\n+        [_peripheral writeValue:value forDescriptor:descriptor];\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n+- (void)cleanup\n+{\n+    if (!_peripheral.isConnected) {\n+        return;\n+    }\n+    \n+    for (CBService* service in _peripheral.services) {\n+        for (CBCharacteristic* characteristic in service.characteristics) {\n+            if (characteristic.isNotifying) {\n+                [_peripheral setNotifyValue:NO forCharacteristic:characteristic];\n+            }\n+        }\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin disconnectPeripheral:_peripheral];\n+    return;\n+}\n+\n+# pragma mark CBPeripheralDelegate methods\n+\n+// Note: this delegate does not work correctly for cached device.\n+// See: http://stackoverflow.com/questions/13180134/corebluetooth-refreshing-local-name-of-an-already-discovered-peripheral\n+- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral\n+{\n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray *)invalidatedServices\n+{\n+    for (CBService* service in invalidatedServices) {\n+        [_plugin sendServiceRemovedEvent:[self buildServiceInfo:service]];\n+        [_knownServices removeObjectForKey:[self getServiceIdFromService:service]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error\n+{\n+    for (CBService* service in peripheral.services) {\n+        [_plugin sendServiceAddedEvent:[self buildServiceInfo:service]];\n+    }\n+    \n+    [_plugin sendDeviceChangedEvent:[self getDeviceInfo]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* includedServicesInfo = [NSMutableArray array];\n+    for (CBService* includedService in service.includedServices) {\n+        NSDictionary* serviceInfo = [self buildServiceInfo:includedService];\n+        [includedServicesInfo addObject:serviceInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getIncludedServicesCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([includedServicesInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error\n+{\n+    NSMutableArray* characteristicsInfo = [NSMutableArray array];\n+    for (CBCharacteristic* characteristic in service.characteristics) {\n+        NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+        [characteristicsInfo addObject:characteristicInfo];\n+    }\n+    \n+    NSString* serviceId = [self getServiceIdFromService:service];\n+    void (^callback)(NSArray*, NSError*) = _getCharacteristicsCallbacks[serviceId];\n+    if (callback != nil) {\n+        [_getIncludedServicesCallbacks removeObjectForKey:serviceId];\n+        callback([characteristicsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSDictionary* characteristicInfo = [self buildCharacteristicInfo:characteristic];\n+    NSMutableArray* multipartMessage = [@[\n+        characteristicInfo[@\"uuid\"],\n+        characteristicInfo[@\"service\"],\n+        characteristicInfo[@\"properties\"],\n+        characteristicInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (characteristic.value) {\n+        [multipartMessage addObject:characteristic.value];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _readCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_readCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback([multipartMessage copy], error);\n+    }\n+    \n+    if (characteristic.isNotifying) {\n+        [_plugin sendCharacteristicValueChangedEvent:[multipartMessage copy]];\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSError*) = _writeCharacteristicValueCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_writeCharacteristicValueCallbacks removeObjectForKey:characteristicId];\n+        callback(error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    if (characteristic.isNotifying) { // start notification\n+        void (^callback)(NSError*) = _startCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_startCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    } else { // stop notification\n+        void (^callback)(NSError*) = _stopCharacteristicNotificationCallbacks[characteristicId];\n+        if (callback != nil) {\n+            [_stopCharacteristicNotificationCallbacks removeObjectForKey:characteristicId];\n+            callback(error);\n+        }\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error\n+{\n+    NSMutableArray* descriptorsInfo = [NSMutableArray array];\n+    for (CBDescriptor* descriptor in characteristic.descriptors) {\n+        [descriptorsInfo addObject:[self buildDescriptorInfo:descriptor]];\n+    }\n+    \n+    NSString* characteristicId = [self getCharacteristicIdFromCharacteristic:characteristic];\n+    void (^callback)(NSArray*, NSError*) = _getDescriptorsCallbacks[characteristicId];\n+    if (callback != nil) {\n+        [_getDescriptorsCallbacks removeObjectForKey:characteristicId];\n+        callback([descriptorsInfo copy], error);\n+    }\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSDictionary* descriptorInfo = [self buildDescriptorInfo:descriptor];\n+    \n+    NSMutableArray* multipartMessage = [@[\n+        descriptorInfo[@\"uuid\"],\n+        descriptorInfo[@\"characteristic\"],\n+        descriptorInfo[@\"instanceId\"],\n+    ] mutableCopy];\n+    \n+    if (descriptor.value) {\n+        [multipartMessage addObject:descriptor.value];\n+    }\n+    \n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSArray*, NSError*) = _readDescriptorValueCallbacks[descriptorId];\n+    if (callback != nil) {\n+        [_readDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(multipartMessage, error);\n+    }\n+    \n+    [_plugin sendDescriptorValueChangedEvent:[multipartMessage copy]];\n+}\n+\n+- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error\n+{\n+    NSString* descriptorId = [self getDescriptorIdFromDescriptor:descriptor];\n+    void (^callback)(NSError*) = [_writeDescriptorValueCallbacks objectForKey:descriptorId];\n+    if (callback != nil) {\n+        [_writeDescriptorValueCallbacks removeObjectForKey:descriptorId];\n+        callback(error);\n+    }\n+}\n+\n+@end\n+\n+@implementation ChromeBluetooth\n+\n+- (CDVPlugin*)initWithWebView:(UIWebView *)theWebView\n+{\n+    self = [super initWithWebView:theWebView];\n+    if (self) {\n+        _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];\n+        _peripherals = [NSMutableDictionary dictionary];\n+        _addressUUIDMap = [NSMutableDictionary dictionary];\n+        _activePeripherals = [NSMutableSet set];\n+    }\n+    return self;\n+}\n+\n+#pragma mark chrome.bluetooth implementations\n+- (ChromeBluetoothPeripheral*)getPeripheralByAddress:(NSString*)address\n+{\n+    NSUUID* uuid = _addressUUIDMap[address];\n+    if (uuid) {\n+        return _peripherals[uuid];\n+    }\n+    return nil;\n+}\n+\n+- (NSDictionary*)getAdapterStateInfo\n+{\n+    BOOL isPoweredOn = NO;\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        isPoweredOn = YES;\n+    }\n+    \n+    return @{\n+        @\"name\": [[UIDevice currentDevice] name],\n+        // getifaddrs() returns 02:00:00:00:00:00 since iOS7\n+        @\"address\": @\"02:00:00:00:00:00\",\n+        @\"discovering\": [NSNumber numberWithBool:NO],\n+        @\"available\": [NSNumber numberWithBool:isPoweredOn],\n+        @\"powered\": [NSNumber numberWithBool:isPoweredOn],\n+    };\n+}\n+\n+- (void)getAdapterState:(CDVInvokedUrlCommand*)command\n+{\n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]] callbackId:command.callbackId];\n+    \n+}\n+\n+- (void)getDevice:(CDVInvokedUrlCommand*)command\n+{\n+    NSString* deviceAddress = [command argumentAtIndex:0];\n+ \n+    ChromeBluetoothPeripheral* chromePeripheral =[self getPeripheralByAddress:deviceAddress];\n+        \n+    if (chromePeripheral) {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[chromePeripheral getDeviceInfo]] callbackId:command.callbackId];\n+    } else {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@\"Invalid Argument\"] callbackId:command.callbackId];\n+    }\n+}\n+\n+- (void)getDevices:(CDVInvokedUrlCommand*)command\n+{\n+    NSArray *allPeripherals = [_peripherals allValues];\n+    NSMutableArray *allDeviceInfo = [NSMutableArray array];\n+    \n+    for (ChromeBluetoothPeripheral* peripheral in allPeripherals) {\n+        [allDeviceInfo addObject:[peripheral getDeviceInfo]];\n+    }\n+    \n+    [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsArray:[allDeviceInfo copy]] callbackId:command.callbackId];\n+}\n+\n+- (void)registerAdapterStateChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _adapterStateChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceAddedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceAddedCallbackId = command.callbackId;\n+}\n+\n+- (void)sendDeviceChangedEvent:(NSDictionary*)deviceInfo\n+{\n+    CDVPluginResult* deviceChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:deviceInfo];\n+    [deviceChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:deviceChangedResult callbackId:_deviceChangedCallbackId];\n+}\n+\n+- (void)registerDeviceChangedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceChangedCallbackId = command.callbackId;\n+}\n+\n+- (void)registerDeviceRemovedEvent:(CDVInvokedUrlCommand*)command\n+{\n+    _deviceRemovedCallbackId = command.callbackId;\n+}\n+\n+- (void)checkRemovedDevice:(id)sender\n+{\n+    NSArray* activeDeviceAddrs = [_activePeripherals allObjects];\n+    NSMutableArray* removedDeviceAddrs = [[_peripherals allKeys] mutableCopy];\n+    [removedDeviceAddrs removeObjectsInArray:activeDeviceAddrs];\n+    [_activePeripherals removeAllObjects];\n+    \n+    for (NSString* deviceAddr in removedDeviceAddrs) {\n+        ChromeBluetoothPeripheral* peripheral = _peripherals[deviceAddr];\n+        CDVPluginResult* deviceRemovedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[peripheral getDeviceInfo]];\n+        [deviceRemovedResult setKeepCallbackAsBool:YES];\n+        [self.commandDelegate sendPluginResult:deviceRemovedResult callbackId:_deviceRemovedCallbackId];\n+        [peripheral cleanup];\n+        [_addressUUIDMap removeObjectForKey:[peripheral->_peripheral identifier]];\n+        [_peripherals removeObjectForKey:deviceAddr];\n+    }\n+}\n+#pragma mark CBCentralManagerDelegate methods\n+\n+- (void)centralManagerDidUpdateState:(CBCentralManager *)central\n+{\n+    CDVPluginResult* adapterStateChangedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[self getAdapterStateInfo]];\n+    [adapterStateChangedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:adapterStateChangedResult callbackId:_adapterStateChangedCallbackId];\n+    \n+    if (_centralManager.state == CBCentralManagerStatePoweredOn) {\n+        [_centralManager scanForPeripheralsWithServices:nil options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES}];\n+        _removedDeviceTimer = [NSTimer scheduledTimerWithTimeInterval:REMOVED_DEVICE_CHECKING_INTERVAL target:self selector:@selector(checkRemovedDevice:) userInfo:nil repeats:YES];\n+    } else {\n+        [_removedDeviceTimer invalidate];\n+        \n+        [_centralManager stopScan];\n+        [_activePeripherals removeAllObjects];\n+        for (NSUUID* uuid in _peripherals) {\n+            [_peripherals[uuid] cleanup];\n+        }\n+        [_peripherals removeAllObjects];\n+    }\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI\n+{\n+    NSUUID* uuid = peripheral.identifier;\n+    [_activePeripherals addObject:uuid];\n+    \n+    ChromeBluetoothPeripheral* foundPeripheral = _peripherals[uuid];\n+    if (foundPeripheral) {\n+        foundPeripheral->_adData = advertisementData;\n+        return;\n+    }\n+   \n+    ChromeBluetoothPeripheral* chromePeripheral = [[ChromeBluetoothPeripheral alloc] initWithPeripheral:peripheral adData:advertisementData plugin:self];\n+    \n+    _addressUUIDMap[[chromePeripheral getPeripheralAddress]] = peripheral.identifier;\n+    _peripherals[uuid] = chromePeripheral;\n+    CDVPluginResult* deviceAddedResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:[chromePeripheral getDeviceInfo]];\n+    [deviceAddedResult setKeepCallbackAsBool:YES];\n+    [self.commandDelegate sendPluginResult:deviceAddedResult callbackId:_deviceAddedCallbackId];\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral\n+{\n+    ChromeBluetoothPeripheral* chromePeripheral = _peripherals[peripheral.identifier];\n+    if (!chromePeripheral)\n+        return;\n+    \n+    VERBOSE_LOG(@\"Device %@ connected\", [chromePeripheral getPeripheralAddress]);\n+    \n+    [self sendDeviceChangedEvent:[chromePeripheral getDeviceInfo]];\n+    \n+    [peripheral discoverServices:nil];\n+    \n+    void (^callback)(NSError*) = chromePeripheral->_connectCallback;\n+    if (callback != nil) {\n+        chromePeripheral->_connectCallback = nil;\n+        callback(nil);\n+    }\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error\n+{\n+    ChromeBluetoothPeripheral* chromePeripheral = _peripherals[peripheral.identifier];\n+    if (!chromePeripheral)\n+        return;\n+    \n+    void (^callback)(NSError*) = chromePeripheral->_connectCallback;\n+    if (callback != nil) {\n+        chromePeripheral->_connectCallback = nil;\n+        callback(error);\n+    }\n+}\n+\n+- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error\n+{\n+    ChromeBluetoothPeripheral* chromePeripheral = _peripherals[peripheral.identifier];\n+    if (!chromePeripheral)\n+        return;\n+\n+    VERBOSE_LOG(@\"Device %@ disconnected\", [chromePeripheral getPeripheralAddress]);\n+   \n+    [self sendDeviceChangedEvent:[chromePeripheral getDeviceInfo]];\n+    \n+    void (^callback)(NSError*) = chromePeripheral->_disconnectCallback;\n+    if (callback != nil) {\n+        chromePeripheral->_disconnectCallback = nil;\n+        callback(error);\n+    }\n+    \n+    [_peripherals removeObjectForKey:peripheral.identifier];\n+}\n+\n+#pragma mark chrome.bluetoothLowEnergy implementations\n+\n+- (void)connect:(CDVInvokedUrlCommand*)command\n+{\n+    NSString* deviceAddress = [command argumentAtIndex:0];\n+    \n+    ChromeBluetoothPeripheral* chromePeripheral = [self getPeripheralByAddress:deviceAddress];\n+    if (!chromePeripheral) {\n+        [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@\"Invalid Argument\"] callbackId:command.callbackId];\n+        return;\n+    }\n+    \n+    chromePeripheral->_connectCallback = [^(NSError* error) {\n+        if (error) {\n+            [self.commandDelegate sendPluginResult:[CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:[error localizedDescription]] callbackId:command.callbackId];",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 829,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "2291663693ed3e3d4f223aaa54bb4655b00d08cb",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Try not to reference `self` from within a block, as that often leads to memory leaks. Instead, create a variable outside to hold commandDelegate and use that instead.\n",
        "created_at": "2014-11-04T03:33:26Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19784037",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19784037"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19784037"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19828683",
        "pull_request_review_id": null,
        "id": 19828683,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODI4Njgz",
        "diff_hunk": "@@ -0,0 +1,1303 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source file is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+\n+#import <Cordova/CDVPlugin.h>\n+#import <CoreBluetooth/CoreBluetooth.h>\n+\n+#ifndef CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define CHROME_BLUETOOTH_VERBOSE_LOGGING 0\n+#endif\n+\n+#if CHROME_BLUETOOTH_VERBOSE_LOGGING\n+#define VERBOSE_LOG NSLog\n+#else\n+#define VERBOSE_LOG(args...) do {} while (false)\n+#endif\n+\n+#define REMOVED_DEVICE_CHECKING_INTERVAL 5 //second\n+\n+@interface CBUUID (UUIDString)\n+\n+- (NSString *)UUIDString;\n+\n+@end\n+\n+@implementation CBUUID (UUIDString)\n+\n+// build-in UUIDString only exist for CBUUID after iOS 7.1\n+- (NSString *)UUIDString;\n+{\n+    NSData *data = [self data];\n+    \n+    NSUInteger bytesToConvert = [data length];\n+    const unsigned char *uuidBytes = [data bytes];\n+    NSMutableString *outputString = [NSMutableString stringWithCapacity:16];\n+    \n+    for (NSUInteger currentByteIndex = 0; currentByteIndex < bytesToConvert; currentByteIndex++) {\n+        switch (currentByteIndex) {\n+            case 3:\n+            case 5:\n+            case 7:\n+            case 9:[outputString appendFormat:@\"%02x-\", uuidBytes[currentByteIndex]]; break;\n+            default:[outputString appendFormat:@\"%02x\", uuidBytes[currentByteIndex]];\n+        }\n+    }\n+    \n+    return outputString;\n+}\n+\n+@end\n+#pragma mark ChromeBluetooth interface\n+\n+@interface ChromeBluetooth : CDVPlugin <CBCentralManagerDelegate> {\n+    CBCentralManager* _centralManager;\n+    NSMutableDictionary* _peripherals;\n+    NSMutableDictionary* _addressUUIDMap;\n+    NSMutableSet* _activePeripherals;\n+    \n+    NSString* _adapterStateChangedCallbackId;\n+    NSString* _deviceAddedCallbackId;\n+    NSString* _deviceChangedCallbackId;\n+    NSString* _deviceRemovedCallbackId;\n+    NSString* _serviceAddedCallbackId;\n+    NSString* _serviceChangedCallbackId;\n+    NSString* _serviceRemovedCallbackId;\n+    NSString* _characteristicValueChangedCallbackId;\n+    NSString* _descriptorValueChangedCallbackId;\n+    \n+    NSTimer* _removedDeviceTimer;\n+}\n+#pragma mark chrome.bluetooth interface\n+\n+- (void)getAdapterState:(CDVInvokedUrlCommand*)command;\n+- (void)getDevice:(CDVInvokedUrlCommand*)command;\n+- (void)getDevices:(CDVInvokedUrlCommand*)command;\n+// - (void)startDiscovery:(CDVInvokedUrlCommand*)command;",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": null,
        "original_position": 77,
        "commit_id": "4311a058a4fb0745dd9a8f17ab5530558882b676",
        "original_commit_id": "098d7ead97c6034ba60251ce0101c61712b52a79",
        "user": {
            "login": "agrieve",
            "id": 1369484,
            "node_id": "MDQ6VXNlcjEzNjk0ODQ=",
            "avatar_url": "https://avatars3.githubusercontent.com/u/1369484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/agrieve",
            "html_url": "https://github.com/agrieve",
            "followers_url": "https://api.github.com/users/agrieve/followers",
            "following_url": "https://api.github.com/users/agrieve/following{/other_user}",
            "gists_url": "https://api.github.com/users/agrieve/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/agrieve/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/agrieve/subscriptions",
            "organizations_url": "https://api.github.com/users/agrieve/orgs",
            "repos_url": "https://api.github.com/users/agrieve/repos",
            "events_url": "https://api.github.com/users/agrieve/events{/privacy}",
            "received_events_url": "https://api.github.com/users/agrieve/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "add a comment here saying why we don't implement these.\n",
        "created_at": "2014-11-04T19:32:26Z",
        "updated_at": "2014-11-04T20:01:31Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19828683",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/19828683"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/405#discussion_r19828683"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/405"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20108625",
        "pull_request_review_id": null,
        "id": 20108625,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA4NjI1",
        "diff_hunk": "@@ -256,6 +256,48 @@ registerAutoTests('chrome.sockets.tcp and chrome.sockets.tcpServer', function()\n       });\n     });\n \n+    it('TCP file redirect', function(done) {\n+      var hostname = 'httpbin.org';\n+      var port = 80;\n+      var requestString = 'GET /get HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+      var request = new ArrayBuffer(requestString.length);\n+      var reqView = new Uint8Array(request);\n+      for (var i = 0, strLen = requestString.length; i < strLen; i++) {\n+        reqView[i] = requestString.charCodeAt(i);\n+      }\n+      var properties = {\n+        destUri: cordova.file.applicationStorageDirectory + 'Documents/redirectToFile.txt',\n+        append: false\n+      };\n+\n+      var recvListener = function(info) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/auto/test.chrome.sockets.tcp.js",
        "position": 18,
        "original_position": 18,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is this assuming that receive event is only called once?  Will this necessarily be true, or does it just happen to be for small requests?\n",
        "created_at": "2014-11-10T20:05:07Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20108625",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20108625"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20108625"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109129",
        "pull_request_review_id": null,
        "id": 20109129,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA5MTI5",
        "diff_hunk": "@@ -256,6 +256,48 @@ registerAutoTests('chrome.sockets.tcp and chrome.sockets.tcpServer', function()\n       });\n     });\n \n+    it('TCP file redirect', function(done) {\n+      var hostname = 'httpbin.org';\n+      var port = 80;\n+      var requestString = 'GET /get HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+      var request = new ArrayBuffer(requestString.length);\n+      var reqView = new Uint8Array(request);\n+      for (var i = 0, strLen = requestString.length; i < strLen; i++) {\n+        reqView[i] = requestString.charCodeAt(i);\n+      }\n+      var properties = {\n+        destUri: cordova.file.applicationStorageDirectory + 'Documents/redirectToFile.txt',\n+        append: false\n+      };\n+\n+      var recvListener = function(info) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/auto/test.chrome.sockets.tcp.js",
        "position": 18,
        "original_position": 18,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It only happens for small requests. For large request with multiple responses, the receive events will be called every time when sockets `read` a packet.\n",
        "created_at": "2014-11-10T20:12:24Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109129",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109129"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109129"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109291",
        "pull_request_review_id": null,
        "id": 20109291,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA5Mjkx",
        "diff_hunk": "@@ -138,34 +138,37 @@ exports.onReceive = new Event('onReceive');\n exports.onReceiveError = new Event('onReceiveError');\n \n function registerReceiveEvents() {\n-    var win = function() {\n-        var info = {\n-            socketId: arguments[0],\n-            data: arguments[1]\n-        };\n+\n+    var win = function(info, data) {\n+        if (data) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/sockets.tcp.js",
        "position": null,
        "original_position": 11,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Thats funny.  Assuming this is to get around the fact that binary data has to be a top level argument?  Worth adding a comment here about that.\n",
        "created_at": "2014-11-10T20:14:32Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109291",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109291"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109291"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109402",
        "pull_request_review_id": null,
        "id": 20109402,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA5NDAy",
        "diff_hunk": "@@ -138,34 +138,37 @@ exports.onReceive = new Event('onReceive');\n exports.onReceiveError = new Event('onReceiveError');\n \n function registerReceiveEvents() {\n-    var win = function() {\n-        var info = {\n-            socketId: arguments[0],\n-            data: arguments[1]\n-        };\n+\n+    var win = function(info, data) {\n+        if (data) {\n+            info.data = data;\n+        }\n         exports.onReceive.fire(info);\n-        exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);\n+\n+        if (data) { // Only exec readyToRead when not redirect ot file",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/sockets.tcp.js",
        "position": null,
        "original_position": 17,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "ot -> to\n",
        "created_at": "2014-11-10T20:16:18Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109402",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109402"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109402"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109606",
        "pull_request_review_id": null,
        "id": 20109606,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA5NjA2",
        "diff_hunk": "@@ -138,34 +138,37 @@ exports.onReceive = new Event('onReceive');\n exports.onReceiveError = new Event('onReceiveError');\n \n function registerReceiveEvents() {\n-    var win = function() {\n-        var info = {\n-            socketId: arguments[0],\n-            data: arguments[1]\n-        };\n+\n+    var win = function(info, data) {\n+        if (data) {\n+            info.data = data;\n+        }\n         exports.onReceive.fire(info);\n-        exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);\n+\n+        if (data) { // Only exec readyToRead when not redirect ot file\n+            exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/sockets.tcp.js",
        "position": null,
        "original_position": 18,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "May you comment as to why we have to call this?\n",
        "created_at": "2014-11-10T20:19:36Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109606",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109606"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109606"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109784",
        "pull_request_review_id": null,
        "id": 20109784,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA5Nzg0",
        "diff_hunk": "@@ -138,34 +138,37 @@ exports.onReceive = new Event('onReceive');\n exports.onReceiveError = new Event('onReceiveError');\n \n function registerReceiveEvents() {\n-    var win = function() {\n-        var info = {\n-            socketId: arguments[0],\n-            data: arguments[1]\n-        };\n+\n+    var win = function(info, data) {\n+        if (data) {\n+            info.data = data;\n+        }\n         exports.onReceive.fire(info);\n-        exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);\n+\n+        if (data) { // Only exec readyToRead when not redirect ot file\n+            exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/sockets.tcp.js",
        "position": null,
        "original_position": 18,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "..and why its called after fire().\n",
        "created_at": "2014-11-10T20:22:38Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109784",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109784"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109784"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109862",
        "pull_request_review_id": null,
        "id": 20109862,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTA5ODYy",
        "diff_hunk": "@@ -138,34 +138,37 @@ exports.onReceive = new Event('onReceive');\n exports.onReceiveError = new Event('onReceiveError');\n \n function registerReceiveEvents() {\n-    var win = function() {\n-        var info = {\n-            socketId: arguments[0],\n-            data: arguments[1]\n-        };\n+\n+    var win = function(info, data) {\n+        if (data) {\n+            info.data = data;\n+        }\n         exports.onReceive.fire(info);\n-        exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);\n+\n+        if (data) { // Only exec readyToRead when not redirect ot file\n+            exec(null, null, 'ChromeSocketsTcp', 'readyToRead', []);\n+        }\n     };\n \n     // TODO: speical callback for android, DELETE when multipart result for\n     // android is avaliable\n     if (platform.id == 'android') {\n         win = (function() {\n-            var data;\n+            var recvInfo;\n             var call = 0;\n-            return function(arg) {\n+            return function(info) {\n                 if (call === 0) {\n-                    data = arg;\n-                    call++;\n-                } else  {\n-                    var info = {\n-                        socketId: arg.socketId,\n-                        data: data\n-                    };\n-\n+                    recvInfo = info;\n+                    if (!recvInfo.destUri) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/sockets.tcp.js",
        "position": 45,
        "original_position": 41,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Please add a short comment that destUri implies only one callback\n",
        "created_at": "2014-11-10T20:23:52Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109862",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20109862"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20109862"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110098",
        "pull_request_review_id": null,
        "id": 20110098,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEwMDk4",
        "diff_hunk": "@@ -118,34 +127,45 @@ public int registerAcceptedSocketChannel(SocketChannel socketChannel)\n \n   private void create(CordovaArgs args, final CallbackContext callbackContext)\n       throws JSONException {\n-    JSONObject properties = args.getJSONObject(0);\n-\n-    try {\n-      TcpSocket socket = new TcpSocket(nextSocket++, recvContext, properties);\n-      sockets.put(Integer.valueOf(socket.getSocketId()), socket);\n-      callbackContext.success(socket.getSocketId());\n-    } catch (SocketException e) {\n-    } catch (IOException e) {\n-    }\n+    final JSONObject properties = args.getJSONObject(0);\n+\n+    // Use a background thread beacause TcpSocket constructor may perform IO operations\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          try {\n+            TcpSocket socket = new TcpSocket(nextSocket++, properties);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 53,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm no Java threading expert, but is `nextSocket++` call here a data race if you create a lot of sockets quickly?  Should it be marked volatile at least?\n",
        "created_at": "2014-11-10T20:28:09Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110098",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110098"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110098"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110189",
        "pull_request_review_id": null,
        "id": 20110189,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEwMTg5",
        "diff_hunk": "@@ -118,34 +127,45 @@ public int registerAcceptedSocketChannel(SocketChannel socketChannel)\n \n   private void create(CordovaArgs args, final CallbackContext callbackContext)\n       throws JSONException {\n-    JSONObject properties = args.getJSONObject(0);\n-\n-    try {\n-      TcpSocket socket = new TcpSocket(nextSocket++, recvContext, properties);\n-      sockets.put(Integer.valueOf(socket.getSocketId()), socket);\n-      callbackContext.success(socket.getSocketId());\n-    } catch (SocketException e) {\n-    } catch (IOException e) {\n-    }\n+    final JSONObject properties = args.getJSONObject(0);\n+\n+    // Use a background thread beacause TcpSocket constructor may perform IO operations\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          try {\n+            TcpSocket socket = new TcpSocket(nextSocket++, properties);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 53,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Actually volatile will not suffice since this is a read-modify-write operation.  Perhaps increment the socketId outside of the Runnable and capture that value.\n",
        "created_at": "2014-11-10T20:29:32Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110189",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110189"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110189"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110733",
        "pull_request_review_id": null,
        "id": 20110733,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEwNzMz",
        "diff_hunk": "@@ -652,6 +683,30 @@ void setProperties(JSONObject properties) throws JSONException, SocketException\n         bufferSize = properties.getInt(\"bufferSize\");\n         setBufferSize();\n       }\n+\n+      if (!properties.isNull(\"append\"))\n+        append = properties.getBoolean(\"append\");\n+\n+      if (!properties.isNull(\"destUri\")) {\n+        try {\n+          resetDestOutputStream();\n+\n+          String uriString = properties.getString(\"destUri\");\n+\n+          if (uriString.length() > 0) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 176,
        "original_position": 174,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why check length?  Seems we would silently fail to do anything with a destUri of \"\".\n",
        "created_at": "2014-11-10T20:37:52Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110733",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110733"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110733"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110913",
        "pull_request_review_id": null,
        "id": 20110913,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEwOTEz",
        "diff_hunk": "@@ -652,6 +683,30 @@ void setProperties(JSONObject properties) throws JSONException, SocketException\n         bufferSize = properties.getInt(\"bufferSize\");\n         setBufferSize();\n       }\n+\n+      if (!properties.isNull(\"append\"))\n+        append = properties.getBoolean(\"append\");\n+\n+      if (!properties.isNull(\"destUri\")) {\n+        try {\n+          resetDestOutputStream();\n+\n+          String uriString = properties.getString(\"destUri\");\n+\n+          if (uriString.length() > 0) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 176,
        "original_position": 174,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "set `destUri` to `\"\"` will cancel redirect to file feature, and start send receive event with received data.\n\nAlternatively, we can use a `boolean` in properties field to indicate weather we are redirecting data to file.\n",
        "created_at": "2014-11-10T20:40:52Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110913",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110913"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110913"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110938",
        "pull_request_review_id": null,
        "id": 20110938,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEwOTM4",
        "diff_hunk": "@@ -924,6 +980,11 @@ JSONObject getInfo() throws JSONException {\n       info.put(\"connected\", channel.isConnected());\n       info.put(\"name\", name);\n       info.put(\"paused\", paused);\n+      info.put(\"append\", append);",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": null,
        "original_position": 203,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Should we include append if destUri is not set?  Seems this is an api extension that should not have visible side effects unless the developer has chosen to use it.\n\nI don't think this is harmful in most cases, but its simple enough to move inside the below `if`.\n",
        "created_at": "2014-11-10T20:41:10Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110938",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20110938"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20110938"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20111294",
        "pull_request_review_id": null,
        "id": 20111294,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTExMjk0",
        "diff_hunk": "@@ -652,6 +683,30 @@ void setProperties(JSONObject properties) throws JSONException, SocketException\n         bufferSize = properties.getInt(\"bufferSize\");\n         setBufferSize();\n       }\n+\n+      if (!properties.isNull(\"append\"))\n+        append = properties.getBoolean(\"append\");\n+\n+      if (!properties.isNull(\"destUri\")) {\n+        try {\n+          resetDestOutputStream();\n+\n+          String uriString = properties.getString(\"destUri\");\n+\n+          if (uriString.length() > 0) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 176,
        "original_position": 174,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I see. I assumed a call to update without desturi would cancel it.\n\nOn Mon, 10 Nov 2014 15:41 Rui Zhao notifications@github.com wrote:\n\n> In\n> chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java:\n> \n> > @@ -652,6 +683,30 @@ void setProperties(JSONObject properties) throws JSONException, SocketException\n> >          bufferSize = properties.getInt(\"bufferSize\");\n> >          setBufferSize();\n> >        }\n> > +\n> > -      if (!properties.isNull(\"append\"))\n> > -        append = properties.getBoolean(\"append\");\n> >   +\n> > -      if (!properties.isNull(\"destUri\")) {\n> > -        try {\n> > -          resetDestOutputStream();\n> >   +\n> > -          String uriString = properties.getString(\"destUri\");\n> >   +\n> > -          if (uriString.length() > 0) {\n> \n> set destUri to \"\" will cancel redirect to file feature, and start send\n> receive event with received data.\n> \n> Alternatively, we can use a boolean in properties field to indicate\n> weather we are redirecting data to file.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416/files#r20110913\n> .\n",
        "created_at": "2014-11-10T20:46:07Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20111294",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20111294"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20111294"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20112015",
        "pull_request_review_id": null,
        "id": 20112015,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMDE1",
        "diff_hunk": "@@ -652,6 +683,30 @@ void setProperties(JSONObject properties) throws JSONException, SocketException\n         bufferSize = properties.getInt(\"bufferSize\");\n         setBufferSize();\n       }\n+\n+      if (!properties.isNull(\"append\"))\n+        append = properties.getBoolean(\"append\");\n+\n+      if (!properties.isNull(\"destUri\")) {\n+        try {\n+          resetDestOutputStream();\n+\n+          String uriString = properties.getString(\"destUri\");\n+\n+          if (uriString.length() > 0) {",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 176,
        "original_position": 174,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think the desktop `chrome.sockets.*.update` only update the fields existed in the properties parameters and keeps other properties unchanged. \n",
        "created_at": "2014-11-10T20:57:07Z",
        "updated_at": "2014-11-10T22:40:24Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20112015",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20112015"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20112015"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20119908",
        "pull_request_review_id": null,
        "id": 20119908,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTE5OTA4",
        "diff_hunk": "@@ -256,6 +256,48 @@ registerAutoTests('chrome.sockets.tcp and chrome.sockets.tcpServer', function()\n       });\n     });\n \n+    it('TCP file redirect', function(done) {\n+      var hostname = 'httpbin.org';\n+      var port = 80;\n+      var requestString = 'GET /get HTTP/1.1\\r\\nHOST: ' + hostname + '\\r\\n\\r\\n';\n+      var request = new ArrayBuffer(requestString.length);\n+      var reqView = new Uint8Array(request);\n+      for (var i = 0, strLen = requestString.length; i < strLen; i++) {\n+        reqView[i] = requestString.charCodeAt(i);\n+      }\n+      var properties = {\n+        destUri: cordova.file.applicationStorageDirectory + 'Documents/redirectToFile.txt',\n+        append: false\n+      };\n+\n+      var recvListener = function(info) {",
        "path": "chrome-cordova/chrome-apps-api-tests/tests/auto/test.chrome.sockets.tcp.js",
        "position": 18,
        "original_position": 18,
        "commit_id": "442f5f499c6e1e715ddda2e6a8e65a8cf7b3fcd6",
        "original_commit_id": "de5e87dec413ffb5acbd4118f402b119e74bd341",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Taking a second look, even if onReceive is called before the full response is processed the test should still pass. (its comparing length of file to length of current read reported, not the length of total read expected).\n\nI think thats fine for an auto test.\n",
        "created_at": "2014-11-10T22:49:52Z",
        "updated_at": "2014-11-10T22:49:52Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20119908",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20119908"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/416#discussion_r20119908"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/416"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251748",
        "pull_request_review_id": null,
        "id": 20251748,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjUxNzQ4",
        "diff_hunk": "@@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n        * This also sets the version of your desktop packaged app.\n     * `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n        * If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n+       * Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:\n+         * 0 - multi platform",
        "path": "docs/Publish.md",
        "position": null,
        "original_position": 5,
        "commit_id": "feede24f207939cf271da8f302436d418e9de1d7",
        "original_commit_id": "e1a7fe7391a0a776246c19c7b16bff7323c67f36",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "multi architecture?\n",
        "created_at": "2014-11-12T21:12:17Z",
        "updated_at": "2014-11-13T15:41:58Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251748",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251748"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251748"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251765",
        "pull_request_review_id": null,
        "id": 20251765,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjUxNzY1",
        "diff_hunk": "@@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n        * This also sets the version of your desktop packaged app.\n     * `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n        * If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n+       * Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:",
        "path": "docs/Publish.md",
        "position": null,
        "original_position": 4,
        "commit_id": "feede24f207939cf271da8f302436d418e9de1d7",
        "original_commit_id": "e1a7fe7391a0a776246c19c7b16bff7323c67f36",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "added -> appended\n",
        "created_at": "2014-11-12T21:12:32Z",
        "updated_at": "2014-11-13T15:41:58Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251765",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251765"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251765"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251871",
        "pull_request_review_id": null,
        "id": 20251871,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjUxODcx",
        "diff_hunk": "@@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n        * This also sets the version of your desktop packaged app.\n     * `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n        * If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n+       * Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:",
        "path": "docs/Publish.md",
        "position": null,
        "original_position": 4,
        "commit_id": "feede24f207939cf271da8f302436d418e9de1d7",
        "original_commit_id": "e1a7fe7391a0a776246c19c7b16bff7323c67f36",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "also, remove the reference to \"by Cordova Android gradle scripts\".  Perhaps just:\n\n\"Finally, a digit is appended to the versionCode to distinguish the apk type:\"\n",
        "created_at": "2014-11-12T21:14:23Z",
        "updated_at": "2014-11-13T15:41:58Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251871",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251871"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251871"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251935",
        "pull_request_review_id": null,
        "id": 20251935,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjUxOTM1",
        "diff_hunk": "@@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n        * This also sets the version of your desktop packaged app.\n     * `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n        * If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n+       * Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:\n+         * 0 - multi platform\n+         * 2 - arm\n+         * 4 - x86\n+         * 9 - APK using system webview and `targetSdkVersion >= 20`",
        "path": "docs/Publish.md",
        "position": null,
        "original_position": 8,
        "commit_id": "feede24f207939cf271da8f302436d418e9de1d7",
        "original_commit_id": "e1a7fe7391a0a776246c19c7b16bff7323c67f36",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why the targetSdkVersion requirement?  I thought the play store will handle this automatically, no?\n",
        "created_at": "2014-11-12T21:15:16Z",
        "updated_at": "2014-11-13T15:41:58Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251935",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20251935"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20251935"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20298456",
        "pull_request_review_id": null,
        "id": 20298456,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjk4NDU2",
        "diff_hunk": "@@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n        * This also sets the version of your desktop packaged app.\n     * `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n        * If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n+       * Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:\n+         * 0 - multi platform\n+         * 2 - arm\n+         * 4 - x86\n+         * 9 - APK using system webview and `targetSdkVersion >= 20`",
        "path": "docs/Publish.md",
        "position": null,
        "original_position": 8,
        "commit_id": "feede24f207939cf271da8f302436d418e9de1d7",
        "original_commit_id": "e1a7fe7391a0a776246c19c7b16bff7323c67f36",
        "user": {
            "login": "kamrik",
            "id": 3289730,
            "node_id": "MDQ6VXNlcjMyODk3MzA=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/3289730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kamrik",
            "html_url": "https://github.com/kamrik",
            "followers_url": "https://api.github.com/users/kamrik/followers",
            "following_url": "https://api.github.com/users/kamrik/following{/other_user}",
            "gists_url": "https://api.github.com/users/kamrik/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/kamrik/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/kamrik/subscriptions",
            "organizations_url": "https://api.github.com/users/kamrik/orgs",
            "repos_url": "https://api.github.com/users/kamrik/repos",
            "events_url": "https://api.github.com/users/kamrik/events{/privacy}",
            "received_events_url": "https://api.github.com/users/kamrik/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oops, it's minSdkVersion, changing. It's for publishing crosswalk based large APK for pre-L and a system webview based small APK for L+. The small APK must have versionCode higher than any of the crosswalk based APKs.\n",
        "created_at": "2014-11-13T15:35:41Z",
        "updated_at": "2014-11-13T15:41:58Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20298456",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20298456"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20298456"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20300470",
        "pull_request_review_id": null,
        "id": 20300470,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzAwNDcw",
        "diff_hunk": "@@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n        * This also sets the version of your desktop packaged app.\n     * `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n        * If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n+       * Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:\n+         * 0 - multi platform\n+         * 2 - arm\n+         * 4 - x86\n+         * 9 - APK using system webview and `targetSdkVersion >= 20`",
        "path": "docs/Publish.md",
        "position": null,
        "original_position": 8,
        "commit_id": "feede24f207939cf271da8f302436d418e9de1d7",
        "original_commit_id": "e1a7fe7391a0a776246c19c7b16bff7323c67f36",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I see.  I guess usually you devs would including minSDK as part of their\nversion number scheme, and we are doing this as a shortcut?  Why use 9?\nSeem to be limiting future options.  Also, what if we just made\nmulti-platform number larger than arm/x86, wouldn't the webview:system just\nuse that and take precedent over crosswalk builds?\n\nOn Thu Nov 13 2014 at 10:35:46 AM Mark Koudritsky notifications@github.com\nwrote:\n\n> In docs/Publish.md:\n> \n> > @@ -11,6 +11,11 @@ To publish your Android application to the Play Store:\n> >         \\* This also sets the version of your desktop packaged app.\n> >      \\* `android:versionCode` can be set using the `versionCode` key in `www/manifest.mobile.js`.\n> >         \\* If omitted, `versionCode` will default to `major * 10000 + minor * 100 + rev` (assuming `version` looks like `\"major.minor.rev\"`)\n> > -       \\* Another digit will be added to versionCode by Cordova Android gradle scripts to distinguish between the produced apk files. The digits currently in use:\n> > -         \\* 0 - multi platform\n> > -         \\* 2 - arm\n> > -         \\* 4 - x86\n> > -         \\* 9 - APK using system webview and `targetSdkVersion >= 20`\n> \n> Oops, it's minSdkVersion, changing. It's for publishing crosswalk based\n> large APK for pre-L and a system webview based small APK for L+. The small\n> APK must have versionCode higher than any of the crosswalk based APKs.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427/files#r20298456\n> .\n",
        "created_at": "2014-11-13T15:57:42Z",
        "updated_at": "2014-11-13T15:57:42Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20300470",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20300470"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/427#discussion_r20300470"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/427"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20913025",
        "pull_request_review_id": null,
        "id": 20913025,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTEzMDI1",
        "diff_hunk": "@@ -50,7 +43,24 @@ - (NSString *)UUIDString;\n         }\n     }\n     \n-    return outputString;\n+    return outputString;   \n+}\n+\n+// Generate the 128 bit UUIDString. If the UUID is 16 bit, it will be prefilled to 128 bit.\n+- (NSString *)fullUUIDString;\n+{\n+    NSString* outputString;\n+    if ([self respondsToSelector:@selector(UUIDString)]) {\n+        outputString = [self UUIDString];\n+    } else {\n+        outputString = [self UUIDStringFromData];\n+    }\n+    \n+    if ([outputString length] == 4) { // 16bit UUIDString\n+        outputString = [NSString stringWithFormat:@\"0000%@-0000-1000-8000-00805F9B34FB\", outputString];",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/ios/ChromeBluetooth.m",
        "position": 37,
        "original_position": 37,
        "commit_id": "b5b8d827e358c687510ec9358669b251324bebdc",
        "original_commit_id": "b5b8d827e358c687510ec9358669b251324bebdc",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Perhaps a comment here, for those who don't know why this is.  I just learned today from: http://en.wikipedia.org/wiki/Bluetooth_low_energy#Identifiers\n",
        "created_at": "2014-11-26T02:22:46Z",
        "updated_at": "2014-11-26T02:22:46Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/423#discussion_r20913025",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/423",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/20913025"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/423#discussion_r20913025"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/423"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21189908",
        "pull_request_review_id": null,
        "id": 21189908,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMTg5OTA4",
        "diff_hunk": "@@ -871,10 +880,8 @@ boolean maybeGrowBuffersForUnwrap(SSLEngineResult res) {\n           return true;\n         case BUFFER_UNDERFLOW:\n           increaseReceiveDataBuffer();\n-          return false;\n+          // Need another read to get enough data to unwrap.\n         case OK:\n-          return res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP &&\n-              res.bytesProduced() == 0;",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 45,
        "original_position": 45,
        "commit_id": "41f83483b40b38f2de3563517d774dc07870afd0",
        "original_commit_id": "41f83483b40b38f2de3563517d774dc07870afd0",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This always caused an infinite loop on `21` after a success connection. Probably because `21` and `19` uses different version of TLS by default, and we never hit this case on `19`?\n",
        "created_at": "2014-12-02T20:47:34Z",
        "updated_at": "2014-12-02T20:47:34Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/456#discussion_r21189908",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/456",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21189908"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/456#discussion_r21189908"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/456"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21191897",
        "pull_request_review_id": null,
        "id": 21191897,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMTkxODk3",
        "diff_hunk": "@@ -871,10 +880,8 @@ boolean maybeGrowBuffersForUnwrap(SSLEngineResult res) {\n           return true;\n         case BUFFER_UNDERFLOW:\n           increaseReceiveDataBuffer();\n-          return false;\n+          // Need another read to get enough data to unwrap.\n         case OK:\n-          return res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP &&\n-              res.bytesProduced() == 0;",
        "path": "chrome-cordova/plugins/chrome.sockets.tcp/src/android/ChromeSocketsTcp.java",
        "position": 45,
        "original_position": 45,
        "commit_id": "41f83483b40b38f2de3563517d774dc07870afd0",
        "original_commit_id": "41f83483b40b38f2de3563517d774dc07870afd0",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This also explains why I feel `21` is really slow, because this always lead auto tests into an infinite loop. I can reset app and put app into background without problem now.\n",
        "created_at": "2014-12-02T21:14:26Z",
        "updated_at": "2014-12-02T21:14:26Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/456#discussion_r21191897",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/456",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21191897"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/456#discussion_r21191897"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/456"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004315",
        "pull_request_review_id": null,
        "id": 21004315,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA0MzE1",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 136,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Are these the only profiles we want to support?  If this is just all we support at the moment, perhaps create a static constant list of \"currently supported profiles\" and iterate through the list here?\n",
        "created_at": "2014-11-27T16:33:41Z",
        "updated_at": "2014-12-05T19:08:15Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004315",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004315"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004315"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004529",
        "pull_request_review_id": null,
        "id": 21004529,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA0NTI5",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 142,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Can UUIDs repeat in these lists?\n",
        "created_at": "2014-11-27T16:38:46Z",
        "updated_at": "2014-12-05T19:08:15Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004529",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004529"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004529"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004655",
        "pull_request_review_id": null,
        "id": 21004655,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA0NjU1",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 197,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Assuming this is high battery usage mode?  Should this be configurable in an ideal world?\n",
        "created_at": "2014-11-27T16:42:42Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004655",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004655"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004655"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004687",
        "pull_request_review_id": null,
        "id": 21004687,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA0Njg3",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 197,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nit: Just hard code this below, like you do for callback types.\n",
        "created_at": "2014-11-27T16:43:23Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004687",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21004687"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21004687"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005010",
        "pull_request_review_id": null,
        "id": 21005010,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA1MDEw",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 262,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Needless line?\n",
        "created_at": "2014-11-27T16:53:07Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005010",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005010"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005010"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005114",
        "pull_request_review_id": null,
        "id": 21005114,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA1MTE0",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 286,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Error log?\n",
        "created_at": "2014-11-27T16:56:12Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005114",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005114"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005114"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005157",
        "pull_request_review_id": null,
        "id": 21005157,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA1MTU3",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");\n+        switch (callbackType) {\n+          case ScanSettings.CALLBACK_TYPE_FIRST_MATCH:\n+            if (!knownLeScanResults.containsKey(result.getDevice().getAddress())) {",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 289,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Do we get FIRST_MATCH multiple times without a MATCH_LOST?\n",
        "created_at": "2014-11-27T16:57:40Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005157",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005157"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005157"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005179",
        "pull_request_review_id": null,
        "id": 21005179,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA1MTc5",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");\n+        switch (callbackType) {\n+          case ScanSettings.CALLBACK_TYPE_FIRST_MATCH:\n+            if (!knownLeScanResults.containsKey(result.getDevice().getAddress())) {\n+              knownLeScanResults.put(result.getDevice().getAddress(), result);\n+              sendDeviceAddedEvent(result);\n+            }\n+            break;\n+          case ScanSettings.CALLBACK_TYPE_MATCH_LOST:",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 294,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Given the above question, can we ever get a MATCH_LOST without a MATCH_FIRST (perhaps dependant on the state of bluetooth scanning of another app on the system?)?\n",
        "created_at": "2014-11-27T16:58:29Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005179",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005179"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005179"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005215",
        "pull_request_review_id": null,
        "id": 21005215,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA1MjE1",
        "diff_hunk": "@@ -17,19 +18,35 @@ exports.connect = function(deviceAddress, properties, callback) {\n         callback = properties;\n         properties = {};\n     }\n-    exec(callback, fail(callback), 'ChromeBluetooth', 'connect', [deviceAddress, properties]);\n+    if (platform.id === 'android') {\n+        exec(callback, fail(callback), 'ChromeBluetoothLowEnergy', 'connect', [deviceAddress, properties]);\n+    } else {\n+        exec(callback, fail(callback), 'ChromeBluetooth', 'connect', [deviceAddress, properties]);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/bluetoothLowEnergy.js",
        "position": null,
        "original_position": 16,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "What if we created a ChromeBluetoothLowEnergy plugin for iOS, and forward to ChromeBluetooth on the native side.  This way, js doesn't know the specifics..?\n",
        "created_at": "2014-11-27T16:59:44Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005215",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005215"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005215"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005333",
        "pull_request_review_id": null,
        "id": 21005333,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA1MzMz",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 142,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I am not sure if the system will remove repeated uuids from advertisement packets. I can try to advertise duplicate uuids and see what happens.\n",
        "created_at": "2014-11-27T17:03:49Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005333",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21005333"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21005333"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21006993",
        "pull_request_review_id": null,
        "id": 21006993,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA2OTkz",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 142,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Better safe than sorry, I was just curious if we are using a Set for a specific reason\n",
        "created_at": "2014-11-27T17:55:33Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21006993",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21006993"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21006993"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007356",
        "pull_request_review_id": null,
        "id": 21007356,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3MzU2",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 43,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm no expert here, but if Semaphore is max count of 1, could you just use synchronized(this) to surround the calls?\n(Or if you want more fine grained locking, use java.util.concurrent.locks.Lock)?\n",
        "created_at": "2014-11-27T18:11:08Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007356",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007356"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007356"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007360",
        "pull_request_review_id": null,
        "id": 21007360,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3MzYw",
        "diff_hunk": "@@ -17,19 +18,35 @@ exports.connect = function(deviceAddress, properties, callback) {\n         callback = properties;\n         properties = {};\n     }\n-    exec(callback, fail(callback), 'ChromeBluetooth', 'connect', [deviceAddress, properties]);\n+    if (platform.id === 'android') {\n+        exec(callback, fail(callback), 'ChromeBluetoothLowEnergy', 'connect', [deviceAddress, properties]);\n+    } else {\n+        exec(callback, fail(callback), 'ChromeBluetooth', 'connect', [deviceAddress, properties]);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/bluetoothLowEnergy.js",
        "position": null,
        "original_position": 16,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This sounds good. I will create a wrapper class and remove these branching in js.\n",
        "created_at": "2014-11-27T18:11:24Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007360",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007360"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007360"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007412",
        "pull_request_review_id": null,
        "id": 21007412,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NDEy",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");\n+        switch (callbackType) {\n+          case ScanSettings.CALLBACK_TYPE_FIRST_MATCH:\n+            if (!knownLeScanResults.containsKey(result.getDevice().getAddress())) {",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 289,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "No, first match only get calls once without a MATCH_LOST. There is another flag to receive a callback for every single packets, but we didn't use it.\n",
        "created_at": "2014-11-27T18:13:51Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007412",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007412"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007412"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007480",
        "pull_request_review_id": null,
        "id": 21007480,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NDgw",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");\n+        switch (callbackType) {\n+          case ScanSettings.CALLBACK_TYPE_FIRST_MATCH:\n+            if (!knownLeScanResults.containsKey(result.getDevice().getAddress())) {",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 289,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Okay, then the guard here is useless?  Can switch with an assert?\n",
        "created_at": "2014-11-27T18:17:12Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007480",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007480"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007480"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007534",
        "pull_request_review_id": null,
        "id": 21007534,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NTM0",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 136,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "They are the only valid profiles Android support. `GATT` and `GATT_SERVER` does not make much difference for now (Implementation of android-21 pasted below). I think it might matter in future SDKs.\n\nI would like to create a `isConnected(ScanResult result)` static method, and share it with `ChromeBluetoothLowEnergy`.\n\n```\n    public List<BluetoothDevice> getConnectedDevices(int profile) {\n        if (DBG) Log.d(TAG,\"getConnectedDevices\");\n        if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {\n            throw new IllegalArgumentException(\"Profile not supported: \" + profile);\n        }\n\n        List<BluetoothDevice> connectedDevices = new ArrayList<BluetoothDevice>();\n\n        try {\n            IBluetoothManager managerService = mAdapter.getBluetoothManager();\n            IBluetoothGatt iGatt = managerService.getBluetoothGatt();\n            if (iGatt == null) return connectedDevices;\n\n            connectedDevices = iGatt.getDevicesMatchingConnectionStates(\n                new int[] { BluetoothProfile.STATE_CONNECTED });\n        } catch (RemoteException e) {\n            Log.e(TAG,\"\",e);\n        }\n\n        return connectedDevices;\n    }\n```\n",
        "created_at": "2014-11-27T18:19:52Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007534",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007534"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007534"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007606",
        "pull_request_review_id": null,
        "id": 21007606,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NjA2",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 43,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is `synchronized(this)` only locks on the `Runnable` that I created for the `Threadpool` \n",
        "created_at": "2014-11-27T18:22:32Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007606",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007606"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007606"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007633",
        "pull_request_review_id": null,
        "id": 21007633,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NjMz",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");\n+        switch (callbackType) {\n+          case ScanSettings.CALLBACK_TYPE_FIRST_MATCH:\n+            if (!knownLeScanResults.containsKey(result.getDevice().getAddress())) {",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 289,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, I will do that\n",
        "created_at": "2014-11-27T18:23:53Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007633",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007633"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007633"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007704",
        "pull_request_review_id": null,
        "id": 21007704,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NzA0",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;\n+\n+    ScanSettings settings = new ScanSettings.Builder()\n+        .setCallbackType(\n+            ScanSettings.CALLBACK_TYPE_FIRST_MATCH | ScanSettings.CALLBACK_TYPE_MATCH_LOST)\n+        .setScanMode(scanMode)\n+        .build();\n+\n+    if(leScanner.startScan(null, settings, leScanCallback)) {\n+      setIsLeScanning(true);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Starting discovery failed\");\n+    }\n+  }\n+\n+  private void stopDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning) {\n+      leScanner.stopScan(leScanCallback);\n+      setIsLeScanning(false);\n+      callbackContext.success();\n+    } else {\n+      callbackContext.error(\"Failed to stop discovery\");\n+    }\n+  }\n+\n+  private void registerBluetoothEvents(CallbackContext callbackContext) {\n+    bluetoothEventsCallback = callbackContext;\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(String eventType, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendAdapterStateChangedEvent() {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAdapterStateChanged\", getAdapterStateInfo()));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceAddedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceAdded\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  void sendDeviceChangedEvent(ScanResult scanResult) {\n+    try {\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceChanged\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendDeviceRemovedEvent(ScanResult scanResult) {\n+    try {\n+      List<PluginResult> multipartMessage = new ArrayList<>();\n+      bluetoothEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onDeviceRemoved\", getDeviceInfo(scanResult)));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void registerAdapterStateReceiver() {\n+    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n+    webView.getContext().registerReceiver(adapterStateReceiver, filter);\n+  }\n+\n+  private final BroadcastReceiver adapterStateReceiver = new BroadcastReceiver() {\n+      @Override\n+      public void onReceive(Context context, Intent intent) {\n+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction())) {\n+          sendAdapterStateChangedEvent();\n+        }\n+      }\n+    };\n+\n+  private final ScanCallback leScanCallback = new ScanCallback() {\n+      @Override\n+      public void onScanResult(int callbackType, ScanResult result) {\n+        Log.e(LOG_TAG, \"onScanResult():\");\n+        switch (callbackType) {\n+          case ScanSettings.CALLBACK_TYPE_FIRST_MATCH:\n+            if (!knownLeScanResults.containsKey(result.getDevice().getAddress())) {\n+              knownLeScanResults.put(result.getDevice().getAddress(), result);\n+              sendDeviceAddedEvent(result);\n+            }\n+            break;\n+          case ScanSettings.CALLBACK_TYPE_MATCH_LOST:",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 294,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "No (according to the comment: https://github.com/google/uribeacon/blob/master/android-uribeacon/uribeacon-library/src/main/java/org/uribeacon/scan/compat/ScanSettings.java#L61)\n",
        "created_at": "2014-11-27T18:27:36Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007704",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007704"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007704"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007753",
        "pull_request_review_id": null,
        "id": 21007753,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3NzUz",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 100,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Can you add comments about where these string fomats are defined? (for the lower methods too). I cannot find a source for it..\n",
        "created_at": "2014-11-27T18:30:29Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007753",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007753"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007753"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007877",
        "pull_request_review_id": null,
        "id": 21007877,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3ODc3",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 136,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "So those are the only profiles supported by the uribeacon scanning library?.. but others are supported by Android (RFCOMM specifically is interesting for bluetoothSocket).\n",
        "created_at": "2014-11-27T18:36:53Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007877",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007877"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007877"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007907",
        "pull_request_review_id": null,
        "id": 21007907,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA3OTA3",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 43,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`synchronized(ChromeBluetoothLowEnergy.this)` (maybe?) so all the Runnables use the same object could work.\n\nAnyway, Lock may be better anyway, since it supports timeouts, which I think you wanted?\n",
        "created_at": "2014-11-27T18:38:16Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007907",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21007907"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21007907"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008056",
        "pull_request_review_id": null,
        "id": 21008056,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA4MDU2",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static Collection<String> getPropertyStrings(int properties) {\n+",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 145,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "You mentioned that there are a bunch of properties which you couldn't send just because of the bridge lacking support for binary data.. Could you document where things are missing so we know what to add if we ever update the bridge?\n",
        "created_at": "2014-11-27T18:45:24Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008056",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008056"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008056"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008116",
        "pull_request_review_id": null,
        "id": 21008116,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA4MTE2",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 43,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`synchronized(ChromeBluetoothLowEnergy.this)` this works.\n\nDo you mean using `tryLock(timeout)`? It won't let me wait `connectGatt`, and reject a connect request too early. I uses `sleep(timeout)` to wait every `connectGatt`, which is very inefficient. \n",
        "created_at": "2014-11-27T18:47:51Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008116",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008116"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008116"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008242",
        "pull_request_review_id": null,
        "id": 21008242,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA4MjQy",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static Collection<String> getPropertyStrings(int properties) {\n+",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 145,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, I will do that. The \"properties\" are not this property strings. They are `value` field of `GattCharacteristic` and `GattDescriptor`. For example, `buildCharacteristicInfo` does not send `value` because we need to send an array of `characteristicInfo`, but  `buildCharacteristicMultipartInfo` does send `value` field. I will add some comments on these `build*` methods.\n",
        "created_at": "2014-11-27T18:53:45Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008242",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008242"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008242"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008288",
        "pull_request_review_id": null,
        "id": 21008288,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA4Mjg4",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 43,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Sorry, my mistake, you want to release the lock after a timeout, not fail to acquire it.\n",
        "created_at": "2014-11-27T18:55:43Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008288",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008288"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008288"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008314",
        "pull_request_review_id": null,
        "id": 21008314,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA4MzE0",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static Collection<String> getPropertyStrings(int properties) {\n+",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 145,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Thanks!\n",
        "created_at": "2014-11-27T18:56:39Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008314",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21008314"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21008314"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21015485",
        "pull_request_review_id": null,
        "id": 21015485,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDE1NDg1",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 136,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't think this API (`bluetoothManager.getConnectedDevice(int profile)`) works with BluetoothSocket's profile from its [documentation](https://developer.android.com/reference/android/bluetooth/BluetoothManager.html#getConnectedDevices%28int%29). `GATT_SERVER` and `GATT` are the only two acceptable profiles for `getConnectedDevices`.\n\nFor `BluetoothSocket`, we can implement a `BluetoothProfile.ServiceListener` or Add `BluetoothDevice.ACTION_ACL_CONNECTED` to the broadcast receiver of `BluetoothAdapter` to monitor the connection state of a bluetooth socket. I didn't implement that because we currently don't support `BluetoothSocket`, and it will require another type of bluetooth scan when we want to support that.\n",
        "created_at": "2014-11-28T02:44:11Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21015485",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21015485"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21015485"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21015528",
        "pull_request_review_id": null,
        "id": 21015528,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDE1NTI4",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));\n+    return deviceInfo;\n+  }\n+\n+  private Collection<String> getUuidStringsFromDevice(BluetoothDevice device) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    ParcelUuid[] uuids = device.getUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString()) ;\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private Collection<String> getUuidStringsFromLeScanRecord(ScanRecord scanRecord) {\n+    Set<String> uuidStrings = new HashSet<>();\n+    List<ParcelUuid> uuids = scanRecord.getServiceUuids();\n+    if (uuids != null) {\n+      for(ParcelUuid uuid : uuids) {\n+        uuidStrings.add(uuid.toString());\n+      }\n+    }\n+    return uuidStrings;\n+  }\n+\n+  private JSONObject getDeviceInfo(ScanResult leScanResult) throws JSONException {\n+    JSONObject deviceInfo = getBasicDeviceInfo(leScanResult.getDevice());\n+    Collection<String> uuidStrings = getUuidStringsFromDevice(leScanResult.getDevice());\n+    Collection<String> adUuidStrings = getUuidStringsFromLeScanRecord(leScanResult.getScanRecord());\n+    uuidStrings.addAll(adUuidStrings);\n+\n+    if (!uuidStrings.isEmpty()) {\n+      deviceInfo.put(\"uuids\", uuidStrings);\n+    }\n+\n+    return deviceInfo;\n+  }\n+\n+  private void getDevice(CordovaArgs args, CallbackContext callbackContext) throws JSONException {\n+    String deviceAddress = args.getString(0);\n+    ScanResult result = knownLeScanResults.get(deviceAddress);\n+    if (result == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+    } else {\n+      callbackContext.success(getDeviceInfo(result));\n+    }\n+  }\n+\n+  private void getDevices(CallbackContext callbackContext) throws JSONException {\n+    JSONArray results = new JSONArray();\n+    for (ScanResult result: knownLeScanResults.values()) {\n+      results.put(getDeviceInfo(result));\n+    }\n+    callbackContext.success(results);\n+  }\n+\n+  private void startDiscovery(CallbackContext callbackContext) {\n+    if (isLeScanning)\n+      return;\n+\n+    int scanMode = ScanSettings.SCAN_MODE_LOW_LATENCY;",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 197,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "For `chrome.bluetooth` and `web-bluetooth` APIs, I think this is fine because user supposes to find a device as soon as possible and close the discovery mode.\n\nFor something like `phyiscal web`, this is better to be configurable for saving battery life.\n",
        "created_at": "2014-11-28T02:48:43Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21015528",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21015528"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21015528"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21034031",
        "pull_request_review_id": null,
        "id": 21034031,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM0MDMx",
        "diff_hunk": "@@ -0,0 +1,307 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompat;\n+import org.uribeacon.scan.compat.BluetoothLeScannerCompatProvider;\n+import org.uribeacon.scan.compat.ScanCallback;\n+import org.uribeacon.scan.compat.ScanRecord;\n+import org.uribeacon.scan.compat.ScanResult;\n+import org.uribeacon.scan.compat.ScanSettings;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.os.Build;\n+import android.os.ParcelUuid;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetooth extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetooth\";\n+\n+  private Map<String, ScanResult> knownLeScanResults = new HashMap<>();\n+\n+  private BluetoothManager bluetoothManager;\n+  private BluetoothAdapter bluetoothAdapter;\n+  private BluetoothLeScannerCompat leScanner;\n+  private boolean isLeScanning;\n+\n+  private CallbackContext bluetoothEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"getAdapterState\".equals(action)) {\n+      getAdapterState(callbackContext);\n+    } else if (\"getDevice\".equals(action)) {\n+      getDevice(args, callbackContext);\n+    } else if (\"getDevices\".equals(action)) {\n+      getDevices(callbackContext);\n+    } else if (\"startDiscovery\".equals(action)) {\n+      startDiscovery(callbackContext);\n+    } else if (\"stopDiscovery\".equals(action)) {\n+      stopDiscovery(callbackContext);\n+    } else if (\"registerBluetoothEvents\".equals(action)) {\n+      registerBluetoothEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void onReset() {\n+    super.onReset();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  public void onDestroy() {\n+    super.onDestroy();\n+    webView.getContext().unregisterReceiver(adapterStateReceiver);\n+  }\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    registerAdapterStateReceiver();\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+    bluetoothAdapter = bluetoothManager.getAdapter();\n+    leScanner = BluetoothLeScannerCompatProvider.getBluetoothLeScannerCompat(webView.getContext());\n+    isLeScanning = false;\n+  }\n+\n+  @Nullable\n+  ScanResult getKnownLeScanResults(String deviceAddress) {\n+    return knownLeScanResults.get(deviceAddress);\n+  }\n+\n+  private void setIsLeScanning(boolean isLeScanning) {\n+    if (this.isLeScanning != isLeScanning) {\n+      this.isLeScanning = isLeScanning;\n+      sendAdapterStateChangedEvent();\n+    }\n+  }\n+\n+  private JSONObject getAdapterStateInfo() throws JSONException {\n+    JSONObject stateInfo = new JSONObject();\n+    stateInfo.put(\"address\", bluetoothAdapter.getAddress());\n+    stateInfo.put(\"name\", bluetoothAdapter.getName());\n+    stateInfo.put(\"powered\", bluetoothAdapter.getState() != BluetoothAdapter.STATE_OFF);\n+    stateInfo.put(\"available\", bluetoothAdapter.isEnabled());\n+    stateInfo.put(\"discovering\", isLeScanning);\n+    return stateInfo;\n+  }\n+\n+  private void getAdapterState(CallbackContext callbackContext) throws JSONException {\n+    callbackContext.success(getAdapterStateInfo());\n+  }\n+\n+  private JSONObject getBasicDeviceInfo(BluetoothDevice device) throws JSONException {\n+    JSONObject deviceInfo = new JSONObject();\n+    deviceInfo.put(\"address\", device.getAddress());\n+    deviceInfo.put(\"name\", device.getName());\n+    deviceInfo.put(\"deviceClass\", device.getBluetoothClass().getDeviceClass());\n+    deviceInfo.put(\"paired\", device.getBondState() == BluetoothDevice.BOND_BONDED);\n+    deviceInfo.put(\n+        \"connected\",\n+        bluetoothManager.getConnectedDevices(BluetoothProfile.GATT).contains(device)\n+        || bluetoothManager.getConnectedDevices(BluetoothProfile.GATT_SERVER).contains(device));",
        "path": "chrome-cordova/plugins/chrome.bluetooth/src/android/ChromeBluetooth.java",
        "position": null,
        "original_position": 136,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Gotcha, thanks.\n",
        "created_at": "2014-11-28T14:43:38Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21034031",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21034031"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21034031"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21036925",
        "pull_request_review_id": null,
        "id": 21036925,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM2OTI1",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static Collection<String> getPropertyStrings(int properties) {\n+\n+    List<String> propertyStrings = new ArrayList<>();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.add(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.add(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.add(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.add(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.add(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.add(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.add(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.add(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, new JSONArray(getPropertyStrings(characteristic.getProperties()))));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          try {\n+            connectGattSemaphore.acquire();\n+            peripheral.connect(callbackContext);\n+            connectGattSemaphore.release();\n+          } catch (InterruptedException e) {\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 662,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "fd5030efae80b90d0da998f37d3ac9ed6e5d8cc0",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "What is this?  Found this doc: https://developer.android.com/samples/BluetoothLeGatt/src/com.example.android.bluetoothlegatt/SampleGattAttributes.html#l27\nand some Stack Overflow questions about it.. worth a comment here.\n",
        "created_at": "2014-11-28T15:44:25Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21036925",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21036925"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21036925"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21038271",
        "pull_request_review_id": null,
        "id": 21038271,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM4Mjcx",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static Collection<String> getPropertyStrings(int properties) {\n+\n+    List<String> propertyStrings = new ArrayList<>();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.add(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.add(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.add(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.add(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.add(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.add(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.add(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.add(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, new JSONArray(getPropertyStrings(characteristic.getProperties()))));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          try {\n+            connectGattSemaphore.acquire();\n+            peripheral.connect(callbackContext);\n+            connectGattSemaphore.release();\n+          } catch (InterruptedException e) {\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 662,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "fd5030efae80b90d0da998f37d3ac9ed6e5d8cc0",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is a descriptor that used for characteristic's value notification. I will make a comment here.\n",
        "created_at": "2014-11-28T16:22:06Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21038271",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21038271"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21038271"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21042400",
        "pull_request_review_id": null,
        "id": 21042400,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDQyNDAw",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 100,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think the `instanceId` just a unique identifier for `Service`, `Characteristic`, and `Descriptor` among all founded devices because we cannot specify which device is the `Service/Characteristic/Descriptor` belongs to when using the `chrome.bluetoothLowEnergy.*`\n\n`/org/bluez/hci0/dev_64_A3_CB_3A_87_60/service004b/char004c`, this is a sample `instanceId` of a characteristic in ChromeOS\n",
        "created_at": "2014-11-28T19:18:56Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21042400",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21042400"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21042400"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21042503",
        "pull_request_review_id": null,
        "id": 21042503,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDQyNTAz",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 100,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, but is the format reverse engineered from what chrome does (if so document, or ideally find the relevant chromium code), or based on some bluetooth protocol?\n\nIt appears to me to be a chromium concept?\n",
        "created_at": "2014-11-28T19:24:15Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21042503",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21042503"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21042503"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21043014",
        "pull_request_review_id": null,
        "id": 21043014,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDQzMDE0",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothManager;\n+import android.bluetooth.BluetoothProfile;\n+import android.content.Context;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral = new HashMap<>();\n+\n+  // Ensure connectGatt() is called in serial\n+  private Semaphore connectGattSemaphore = new Semaphore(1, true);\n+\n+  private BluetoothManager bluetoothManager;\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  protected void pluginInitialize() {\n+    bluetoothManager = (BluetoothManager) webView.getContext().getSystemService(Context.BLUETOOTH_SERVICE);\n+  }\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 100,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "50464d4074cca95f83f5062c837c295a198de852",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I found this is the `object_path` of the bluetooth objects in the `chromeos` implementations, which is used by `dbus` to get access of the bluetooth object. `/org/bluez` is the base path to all bluetooth objects.\n",
        "created_at": "2014-11-28T19:47:32Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21043014",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21043014"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21043014"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21335804",
        "pull_request_review_id": null,
        "id": 21335804,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM1ODA0",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 281,
        "original_position": 281,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "What happens if someone attempts to use a peripheral that has not finished being connected to, by not waiting for the connect callback?  In other words, do we need to synchronize only connections, or all uses of the peripheral (such as read/write characteristics?)\n",
        "created_at": "2014-12-04T21:07:09Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21335804",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21335804"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21335804"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336096",
        "pull_request_review_id": null,
        "id": 21336096,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2MDk2",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 639,
        "original_position": 693,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Can we synchronize on ChromeBluetoothLowEnergyPeripheral object?\n",
        "created_at": "2014-12-04T21:11:04Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336096",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336096"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336096"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336195",
        "pull_request_review_id": null,
        "id": 21336195,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2MTk1",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 662,
        "original_position": 717,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "gatt = null ?\n",
        "created_at": "2014-12-04T21:12:09Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336195",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336195"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336195"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336294",
        "pull_request_review_id": null,
        "id": 21336294,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2Mjk0",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 739,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah, makes sense.\n",
        "created_at": "2014-12-04T21:13:17Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336294",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336294"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336294"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336415",
        "pull_request_review_id": null,
        "id": 21336415,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2NDE1",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 639,
        "original_position": 693,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Nevermind, I think your operations are async, which explains manual control.  Also your comment below I think explains that you want to reset when re-connecting, even if previous operations have not yet timed out..\n",
        "created_at": "2014-12-04T21:15:08Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336415",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336415"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336415"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336738",
        "pull_request_review_id": null,
        "id": 21336738,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2NzM4",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 281,
        "original_position": 281,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't think they can do that. If the peripheral is not connected, they won't get serviceId, characteristicId, descriptorId, and they will get invalid argument when they trying to do so.\n\nA disconnect will clear all cached service, characteristic, descriptor, etc.\n",
        "created_at": "2014-12-04T21:17:56Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336738",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336738"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336738"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336843",
        "pull_request_review_id": null,
        "id": 21336843,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2ODQz",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 662,
        "original_position": 717,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "gatt = null when user doesn't call `connect`\n",
        "created_at": "2014-12-04T21:19:30Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336843",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336843"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336843"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336955",
        "pull_request_review_id": null,
        "id": 21336955,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM2OTU1",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 281,
        "original_position": 281,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Actually, peripheral.connect is an async operation.  I think synchronizing here is insufficient, isn't it?  We need to block access to next connect until this connect finishes?\n",
        "created_at": "2014-12-04T21:20:41Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336955",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21336955"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21336955"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337132",
        "pull_request_review_id": null,
        "id": 21337132,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3MTMy",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    Collection<BluetoothGattService> getServices() {\n+      if (gatt != null) {\n+        return gatt.getServices();\n+      } else {\n+        return Collections.emptyList();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 972,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Probably should rename this to gattEventsCallback or something like that?\n",
        "created_at": "2014-12-04T21:22:54Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337132",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337132"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337132"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337153",
        "pull_request_review_id": null,
        "id": 21337153,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3MTUz",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 639,
        "original_position": 693,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, and the operations are async and not cancelable.\n\nWe also can't use a Lock, since the callback is not called on the Thread that dispatch the gatt operations.\n",
        "created_at": "2014-12-04T21:23:12Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337153",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337153"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337153"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337210",
        "pull_request_review_id": null,
        "id": 21337210,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3MjEw",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 742,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Is connection sometimes sync, sometimes async?\n",
        "created_at": "2014-12-04T21:24:05Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337210",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337210"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337210"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337291",
        "pull_request_review_id": null,
        "id": 21337291,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3Mjkx",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 746,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Should we timeout unconditionally, or should we check that connection hasn't been established by this point?\n",
        "created_at": "2014-12-04T21:25:15Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337291",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337291"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337291"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337542",
        "pull_request_review_id": null,
        "id": 21337542,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3NTQy",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 281,
        "original_position": 281,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes. The bluetooth adapter does not works well when I tried to connect to multiple devices at same time (beacons and peripheral). I need to restart my bluetooth adapter to make them works again.\n\n[This question](http://stackoverflow.com/questions/21237093/android-4-3-how-to-connect-to-multiple-bluetooth-low-energy-devices) also mentions sequentially connect & register notification.\n",
        "created_at": "2014-12-04T21:29:00Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337542",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337542"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337542"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337680",
        "pull_request_review_id": null,
        "id": 21337680,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3Njgw",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 746,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh, this is a bad name. It actually only timeout when connection is not established at that time.\n",
        "created_at": "2014-12-04T21:31:13Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337680",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337680"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337680"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337993",
        "pull_request_review_id": null,
        "id": 21337993,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM3OTkz",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    Collection<BluetoothGattService> getServices() {\n+      if (gatt != null) {\n+        return gatt.getServices();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 767,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why do the others add to known\\* but this one doesn't?  Is it because we expect to get events for found services already?  Worth a comment probably.\n",
        "created_at": "2014-12-04T21:35:46Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337993",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21337993"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21337993"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21338037",
        "pull_request_review_id": null,
        "id": 21338037,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM4MDM3",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 742,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Connection is always async, I think we can remove this or periodically check connection. Maybe Something like:\n\n``` java\nwhile(!isConnected() && sleep < timeout) {\n    Thread.sleep(10);\n    sleep += 10;\n}\n```\n",
        "created_at": "2014-12-04T21:36:39Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21338037",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21338037"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21338037"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21338719",
        "pull_request_review_id": null,
        "id": 21338719,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM4NzE5",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 662,
        "original_position": 717,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I meant to suggest we should set gatt to null after a close.  We won't be using it again and we reset it on subsequent connects.\n",
        "created_at": "2014-12-04T21:46:28Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21338719",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21338719"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21338719"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21338974",
        "pull_request_review_id": null,
        "id": 21338974,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM4OTc0",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 742,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I thought you get the connect event, which will call connectSuccess?  I think you don't need to do this check here at all, then?\n",
        "created_at": "2014-12-04T21:49:59Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21338974",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21338974"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21338974"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21339154",
        "pull_request_review_id": null,
        "id": 21339154,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM5MTU0",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 746,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "If my above comment is right, that the connect success is handled by the onConnectionStateChange event to connected, then we can just sleep the maximum amount of time and then check if we are connected callback with timeout failure, which is what you are doing already (although its confusing, since its based on whether connectCallback is null).\n",
        "created_at": "2014-12-04T21:52:41Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21339154",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21339154"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21339154"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21339216",
        "pull_request_review_id": null,
        "id": 21339216,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzM5MjE2",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 742,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yes, we don't need it here at all.\n\nThe only reason I want to check it here because I want to unblock the next connect call earlier.\n",
        "created_at": "2014-12-04T21:53:36Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21339216",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21339216"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21339216"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21345365",
        "pull_request_review_id": null,
        "id": 21345365,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzQ1MzY1",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    Collection<BluetoothGattService> getServices() {\n+      if (gatt != null) {\n+        return gatt.getServices();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 767,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I just updated this to use discoverService c109409.\n\nI think this is better because it will always update our active services and not just return the services stored. Moreover, if the connection drops, this will return an error now. Our iOS implementation uses this way to getServices.\n",
        "created_at": "2014-12-04T23:33:37Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21345365",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21345365"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21345365"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21374673",
        "pull_request_review_id": null,
        "id": 21374673,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc0Njcz",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 761,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "What happens if you call getServices on an unconnected peripheral?  Looks like we store the callback and don't fire it.  Should we fail if !isConnected here?\n",
        "created_at": "2014-12-05T14:38:48Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21374673",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21374673"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21374673"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21374981",
        "pull_request_review_id": null,
        "id": 21374981,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc0OTgx",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 315,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "connect, disconnect, getServices, etc all pass callbackContext into peripheral.\n\ngetService, getCharacteristics, etc, all get results and call the callback here.\n\nI think it would look nicer to just change all the calls to pass in callbackContext.  This will make the peripheral code a little longer, but I still think it will be more readable.\n",
        "created_at": "2014-12-05T14:44:08Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21374981",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21374981"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21374981"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21375273",
        "pull_request_review_id": null,
        "id": 21375273,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc1Mjcz",
        "diff_hunk": "@@ -0,0 +1,1172 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> services = peripheral.getServices();\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : services) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+        gatt.discoverServices();\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 662,
        "original_position": 717,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "b25a9f632fde1f93852abf733674102fb75407fe",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I was intentionally not set it to `null` (I will comment here).\n\nThe reason was `close()` will be called when a connection timeout or in a disconnect callback, both of them happens in a background thread. If a connection drops and a gatt read/write happens at same time, it may cause a NullPointerException since read/write depends on gatt.\n",
        "created_at": "2014-12-05T14:48:04Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21375273",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21375273"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21375273"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21376653",
        "pull_request_review_id": null,
        "id": 21376653,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc2NjUz",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 842,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "If gatt is null, its not an invalid argument, its just not connected yet, right?\n\nPerhaps create a single helper that all of these methods share that makes sure everything is connected properly?\n",
        "created_at": "2014-12-05T15:11:38Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21376653",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21376653"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21376653"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21376791",
        "pull_request_review_id": null,
        "id": 21376791,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc2Nzkx",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 315,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "..especially since it is unclear why some methods run on a worker thread and others do not need to with the current split of responsibility.\n",
        "created_at": "2014-12-05T15:13:32Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21376791",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21376791"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21376791"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21376896",
        "pull_request_review_id": null,
        "id": 21376896,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc2ODk2",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 890,
        "original_position": 848,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "If there is a queue of characteristic reads waiting on the acquire, and then the peripheral disconnects, should we re-check that we are still connected here?\n",
        "created_at": "2014-12-05T15:15:09Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21376896",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21376896"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21376896"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379496",
        "pull_request_review_id": null,
        "id": 21379496,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc5NDk2",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 1086,
        "original_position": 1023,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "If this fails, we should send an error result to js, right?\n",
        "created_at": "2014-12-05T15:55:02Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379496",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379496"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379496"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379545",
        "pull_request_review_id": null,
        "id": 21379545,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc5NTQ1",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 1086,
        "original_position": 1023,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "..same with the other events, in the exception catch handlers probably want callbackContext.error(...)\n",
        "created_at": "2014-12-05T15:55:51Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379545",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379545"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379545"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379640",
        "pull_request_review_id": null,
        "id": 21379640,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc5NjQw",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_WRITE_NOT_PERMITTED:\n+              writeCallbackContext.error(\"Write characteristic not permitted\");\n+              break;\n+            default:\n+              writeCallbackContext.error(\"Write characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n+\n+          Log.d(LOG_TAG, \"connection state changes - state: \" + newState);\n+\n+          switch (newState) {\n+            case BluetoothProfile.STATE_CONNECTED:\n+              connectSuccess();\n+              break;\n+            case BluetoothProfile.STATE_DISCONNECTED:\n+              if (disconnectCallback != null) {\n+                disconnectCallback.success();\n+                disconnectCallback = null;\n+              }\n+\n+              for (BluetoothGattService service : knownServices.values()) {\n+                sendServiceRemovedEvent(bleScanResult.getDevice().getAddress(), service);\n+              }\n+\n+              close();\n+              break;\n+          }\n+\n+          ChromeBluetooth bluetoothPlugin =\n+              (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+          bluetoothPlugin.sendDeviceChangedEvent(bleScanResult);\n+        }\n+\n+        @Override\n+        public void onDescriptorRead(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String descriptorId = buildDescriptorId(\n+              bleScanResult.getDevice().getAddress(), descriptor);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildDescriptorMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        descriptor)));\n+              } catch (JSONException e) {\n+              }\n+              sendDescriptorValueChangedEvent(bleScanResult.getDevice().getAddress(), descriptor);\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read descriptor not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read descriptor failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onDescriptorWrite(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+          CallbackContext callbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          PluginResult result = null;\n+\n+          if (descriptor.getUuid().toString().equals(CLIENT_CHARACTERISTIC_CONFIG)) {\n+            // Set remote notification by writing into config descriptor\n+            String characteristicId = buildCharacteristicId(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 1110,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why are we creating the characteristicId here?  I don't understand the comment above.\n",
        "created_at": "2014-12-05T15:57:23Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379640",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379640"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379640"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379780",
        "pull_request_review_id": null,
        "id": 21379780,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzc5Nzgw",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 1086,
        "original_position": 1023,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I don't think we will get a JSONException here actually, but I can add `callbackContext.error()` in catch. Or maybe `printStackTrace()`?\n",
        "created_at": "2014-12-05T15:59:29Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379780",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21379780"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21379780"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380016",
        "pull_request_review_id": null,
        "id": 21380016,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzgwMDE2",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_WRITE_NOT_PERMITTED:\n+              writeCallbackContext.error(\"Write characteristic not permitted\");\n+              break;\n+            default:\n+              writeCallbackContext.error(\"Write characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n+\n+          Log.d(LOG_TAG, \"connection state changes - state: \" + newState);\n+\n+          switch (newState) {\n+            case BluetoothProfile.STATE_CONNECTED:\n+              connectSuccess();\n+              break;\n+            case BluetoothProfile.STATE_DISCONNECTED:\n+              if (disconnectCallback != null) {\n+                disconnectCallback.success();\n+                disconnectCallback = null;\n+              }\n+\n+              for (BluetoothGattService service : knownServices.values()) {\n+                sendServiceRemovedEvent(bleScanResult.getDevice().getAddress(), service);\n+              }\n+\n+              close();\n+              break;\n+          }\n+\n+          ChromeBluetooth bluetoothPlugin =\n+              (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+          bluetoothPlugin.sendDeviceChangedEvent(bleScanResult);\n+        }\n+\n+        @Override\n+        public void onDescriptorRead(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String descriptorId = buildDescriptorId(\n+              bleScanResult.getDevice().getAddress(), descriptor);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildDescriptorMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        descriptor)));\n+              } catch (JSONException e) {\n+              }\n+              sendDescriptorValueChangedEvent(bleScanResult.getDevice().getAddress(), descriptor);\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read descriptor not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read descriptor failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onDescriptorWrite(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+          CallbackContext callbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          PluginResult result = null;\n+\n+          if (descriptor.getUuid().toString().equals(CLIENT_CHARACTERISTIC_CONFIG)) {\n+            // Set remote notification by writing into config descriptor\n+            String characteristicId = buildCharacteristicId(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 1110,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Actually, if I understand correct, this onDescriptorWrite call is in response to setCharacteristicNotification.  In that case, do we want to be using the gattCommandCallbackContext at all?  If there was a write call in queue this would mess with it, I think..\n",
        "created_at": "2014-12-05T16:02:34Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380016",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380016"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380016"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380233",
        "pull_request_review_id": null,
        "id": 21380233,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzgwMjMz",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_WRITE_NOT_PERMITTED:\n+              writeCallbackContext.error(\"Write characteristic not permitted\");\n+              break;\n+            default:\n+              writeCallbackContext.error(\"Write characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n+\n+          Log.d(LOG_TAG, \"connection state changes - state: \" + newState);\n+\n+          switch (newState) {\n+            case BluetoothProfile.STATE_CONNECTED:\n+              connectSuccess();\n+              break;\n+            case BluetoothProfile.STATE_DISCONNECTED:\n+              if (disconnectCallback != null) {\n+                disconnectCallback.success();\n+                disconnectCallback = null;\n+              }\n+\n+              for (BluetoothGattService service : knownServices.values()) {\n+                sendServiceRemovedEvent(bleScanResult.getDevice().getAddress(), service);\n+              }\n+\n+              close();\n+              break;\n+          }\n+\n+          ChromeBluetooth bluetoothPlugin =\n+              (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+          bluetoothPlugin.sendDeviceChangedEvent(bleScanResult);\n+        }\n+\n+        @Override\n+        public void onDescriptorRead(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String descriptorId = buildDescriptorId(\n+              bleScanResult.getDevice().getAddress(), descriptor);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildDescriptorMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        descriptor)));\n+              } catch (JSONException e) {\n+              }\n+              sendDescriptorValueChangedEvent(bleScanResult.getDevice().getAddress(), descriptor);\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read descriptor not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read descriptor failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onDescriptorWrite(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+          CallbackContext callbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          PluginResult result = null;\n+\n+          if (descriptor.getUuid().toString().equals(CLIENT_CHARACTERISTIC_CONFIG)) {\n+            // Set remote notification by writing into config descriptor\n+            String characteristicId = buildCharacteristicId(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 1110,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I think the id was just for debugging.... I will remove them.\n\nWe need to use gattCommandCallbackContext, since start/stopNotification need to be synced (because writing a descriptor is required)\n",
        "created_at": "2014-12-05T16:05:28Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380233",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380233"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380233"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380302",
        "pull_request_review_id": null,
        "id": 21380302,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzgwMzAy",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 1086,
        "original_position": 1023,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Both maybe, or remove the try if we are confident it won't throw.\n",
        "created_at": "2014-12-05T16:06:28Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380302",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380302"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380302"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380459",
        "pull_request_review_id": null,
        "id": 21380459,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzgwNDU5",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_WRITE_NOT_PERMITTED:\n+              writeCallbackContext.error(\"Write characteristic not permitted\");\n+              break;\n+            default:\n+              writeCallbackContext.error(\"Write characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n+\n+          Log.d(LOG_TAG, \"connection state changes - state: \" + newState);\n+\n+          switch (newState) {\n+            case BluetoothProfile.STATE_CONNECTED:\n+              connectSuccess();\n+              break;\n+            case BluetoothProfile.STATE_DISCONNECTED:\n+              if (disconnectCallback != null) {\n+                disconnectCallback.success();\n+                disconnectCallback = null;\n+              }\n+\n+              for (BluetoothGattService service : knownServices.values()) {\n+                sendServiceRemovedEvent(bleScanResult.getDevice().getAddress(), service);\n+              }\n+\n+              close();\n+              break;\n+          }\n+\n+          ChromeBluetooth bluetoothPlugin =\n+              (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+          bluetoothPlugin.sendDeviceChangedEvent(bleScanResult);\n+        }\n+\n+        @Override\n+        public void onDescriptorRead(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String descriptorId = buildDescriptorId(\n+              bleScanResult.getDevice().getAddress(), descriptor);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildDescriptorMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        descriptor)));\n+              } catch (JSONException e) {\n+              }\n+              sendDescriptorValueChangedEvent(bleScanResult.getDevice().getAddress(), descriptor);\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read descriptor not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read descriptor failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onDescriptorWrite(\n+            BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {\n+          CallbackContext callbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          PluginResult result = null;\n+\n+          if (descriptor.getUuid().toString().equals(CLIENT_CHARACTERISTIC_CONFIG)) {\n+            // Set remote notification by writing into config descriptor\n+            String characteristicId = buildCharacteristicId(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": null,
        "original_position": 1110,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah, I didn't notice that.  In this case, it will be a callbackContext for the start/stop notification call.\n",
        "created_at": "2014-12-05T16:08:35Z",
        "updated_at": "2014-12-05T19:08:16Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380459",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21380459"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21380459"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21393289",
        "pull_request_review_id": null,
        "id": 21393289,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzkzMjg5",
        "diff_hunk": "@@ -0,0 +1,1183 @@\n+package org.chromium;\n+\n+import android.annotation.TargetApi;\n+import android.bluetooth.BluetoothGatt;\n+import android.bluetooth.BluetoothGattCallback;\n+import android.bluetooth.BluetoothGattCharacteristic;\n+import android.bluetooth.BluetoothGattDescriptor;\n+import android.bluetooth.BluetoothGattService;\n+import android.bluetooth.BluetoothProfile;\n+import android.support.annotation.Nullable;\n+import android.util.Log;\n+import android.os.Build;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.uribeacon.scan.compat.ScanResult;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+\n+import static org.apache.cordova.PluginResult.Status;\n+\n+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n+public class ChromeBluetoothLowEnergy extends CordovaPlugin {\n+\n+  private static final String LOG_TAG = \"ChromeBluetoothLowEnergy\";\n+  private Map<String, ChromeBluetoothLowEnergyPeripheral> knownPeripheral =\n+      new HashMap<String, ChromeBluetoothLowEnergyPeripheral>();\n+  private CallbackContext bluetoothLowEnergyEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"getService\".equals(action)) {\n+      getService(args, callbackContext);\n+    } else if (\"getServices\".equals(action)) {\n+      getServices(args, callbackContext);\n+    } else if (\"getCharacteristic\".equals(action)) {\n+      getCharacteristic(args, callbackContext);\n+    } else if (\"getCharacteristics\".equals(action)) {\n+      getCharacteristics(args, callbackContext);\n+    } else if (\"getIncludedServices\".equals(action)) {\n+      getIncludedServices(args, callbackContext);\n+    } else if (\"getDescriptor\".equals(action)) {\n+      getDescriptor(args, callbackContext);\n+    } else if (\"getDescriptors\".equals(action)) {\n+      getDescriptors(args, callbackContext);\n+    } else if (\"readCharacteristicValue\".equals(action)) {\n+      readCharacteristicValue(args, callbackContext);\n+    } else if (\"writeCharacteristicValue\".equals(action)) {\n+      writeCharacteristicValue(args, callbackContext);\n+    } else if (\"startCharacteristicNotifications\".equals(action)) {\n+      startCharacteristicNotifications(args, callbackContext);\n+    } else if (\"stopCharacteristicNotifications\".equals(action)) {\n+      stopCharacteristicNotifications(args, callbackContext);\n+    } else if (\"readDescriptorValue\".equals(action)) {\n+      readDescriptorValue(args, callbackContext);\n+    } else if (\"writeDescriptorValue\".equals(action)) {\n+      writeDescriptorValue(args, callbackContext);\n+    } else if (\"registerBluetoothLowEnergyEvents\".equals(action)) {\n+      registerBluetoothLowEnergyEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static String getDeviceAddressFromInstanceId(String instanceId) {\n+    return instanceId.split(\"/\")[0];\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattService object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildServiceId(String deviceAddress, BluetoothGattService service) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(service.getUuid().toString())\n+        .append(\"_\")\n+        .append(service.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattCharacteristic object,\n+  // the format of the string is based on the dbus's object path in Linux\n+  // system.\n+  private static String buildCharacteristicId(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(characteristic.getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(characteristic.getUuid().toString())\n+        .append(\"_\")\n+        .append(characteristic.getInstanceId())\n+        .toString();\n+  }\n+\n+  // Generate a unique identifier for the BluetoothGattDescriptor object, the\n+  // format of the string is based on the dbus's object path in Linux system.\n+  private static String buildDescriptorId(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+    return new StringBuilder()\n+        .append(deviceAddress)\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getService().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getCharacteristic().getUuid().toString())\n+        .append(\"/\")\n+        .append(descriptor.getUuid().toString())\n+        .toString();\n+  }\n+\n+  private static JSONObject buildServiceInfo(String deviceAddress, BluetoothGattService service)\n+      throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", service.getUuid().toString());\n+    info.put(\"deviceAddress\", deviceAddress);\n+    info.put(\"instanceId\", buildServiceId(deviceAddress, service));\n+    info.put(\"isPrimary\", service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY);\n+    return info;\n+  }\n+\n+  private static JSONArray getPropertyStrings(int properties) throws JSONException {\n+\n+    JSONArray propertyStrings = new JSONArray();\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_BROADCAST & properties) != 0) {\n+      propertyStrings.put(\"broadcast\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS & properties) != 0) {\n+      propertyStrings.put(\"extendedProperties\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_INDICATE & properties) != 0) {\n+      propertyStrings.put(\"indicate\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_NOTIFY & properties) != 0) {\n+      propertyStrings.put(\"notify\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_READ & properties) != 0) {\n+      propertyStrings.put(\"read\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE & properties) != 0) {\n+      propertyStrings.put(\"authenticatedSignedWrites\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE & properties) != 0) {\n+      propertyStrings.put(\"write\");\n+    }\n+\n+    if ((BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE & properties) != 0) {\n+      propertyStrings.put(\"writeWithoutResponse\");\n+    }\n+\n+    return propertyStrings;\n+  }\n+\n+  // Note: The returned object need to be sent in an array or an object as the\n+  // response of getCharacteristics()/getDescriptor()/getDescriptors(). The\n+  // \"value\" field is excluded due to the bridge lacking support for binary\n+  // data.\n+  private static JSONObject buildCharacteristicInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", characteristic.getUuid().toString());\n+    info.put(\"service\", buildServiceInfo(deviceAddress, characteristic.getService()));\n+    info.put(\"properties\", getPropertyStrings(characteristic.getProperties()));\n+    info.put(\"instanceId\", buildCharacteristicId(deviceAddress, characteristic));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildCharacteristicMultipartInfo(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+    multipartInfo.add(new PluginResult(Status.OK, characteristic.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, characteristic.getService())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, getPropertyStrings(characteristic.getProperties())));\n+    multipartInfo.add(new PluginResult(\n+        Status.OK, buildCharacteristicId(deviceAddress, characteristic)));\n+\n+    if (characteristic.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, characteristic.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  // Note: The result object need to be sent in an array as the response of\n+  // getDescriptors(). The \"value\" field is excluded due to the bridge lacking\n+  // support for binary data.\n+  private static JSONObject buildDescriptorInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+    JSONObject info = new JSONObject();\n+    info.put(\"uuid\", descriptor.getUuid().toString());\n+    info.put(\n+        \"characteristic\",\n+        buildCharacteristicInfo(deviceAddress, descriptor.getCharacteristic()));\n+    info.put(\"instanceId\", buildDescriptorId(deviceAddress, descriptor));\n+    return info;\n+  }\n+\n+  private static List<PluginResult> buildDescriptorMultipartInfo(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) throws JSONException {\n+\n+    List<PluginResult> multipartInfo = new ArrayList<PluginResult>();\n+\n+    multipartInfo.add(new PluginResult(Status.OK, descriptor.getUuid().toString()));\n+    multipartInfo.add(new PluginResult(Status.OK, buildCharacteristicInfo(\n+        deviceAddress, descriptor.getCharacteristic())));\n+    multipartInfo.add(new PluginResult(Status.OK, buildDescriptorId(deviceAddress, descriptor)));\n+\n+    if (descriptor.getValue() != null) {\n+      multipartInfo.add(new PluginResult(Status.OK, descriptor.getValue()));\n+    }\n+\n+    return multipartInfo;\n+  }\n+\n+  @Nullable\n+  private ChromeBluetoothLowEnergyPeripheral getPeripheralByDeviceAddress(String deviceAddress) {\n+    ChromeBluetoothLowEnergyPeripheral peripheral = knownPeripheral.get(deviceAddress);\n+\n+    if (peripheral != null)\n+      return peripheral;\n+\n+    ChromeBluetooth bluetoothPlugin =\n+        (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+\n+    ScanResult bleScanResult = bluetoothPlugin.getKnownLeScanResults(deviceAddress);\n+\n+    if (bleScanResult == null)\n+      return null;\n+\n+    peripheral = new ChromeBluetoothLowEnergyPeripheral(bleScanResult);\n+    knownPeripheral.put(deviceAddress, peripheral);\n+\n+    return peripheral;\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext) throws JSONException {\n+\n+    String deviceAddress = args.getString(0);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          // Ensure connectGatt() is called in serial\n+          synchronized (ChromeBluetoothLowEnergy.this) {\n+            try {\n+              peripheral.connect(callbackContext);\n+            } catch (InterruptedException e) {\n+            }\n+          }\n+        }\n+      });\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.disconnect(callbackContext);\n+  }\n+\n+  private void getService(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattService service = peripheral.getService(serviceId);\n+\n+    if (service == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildServiceInfo(deviceAddress, service)));\n+  }\n+\n+  private void getServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String deviceAddress = args.getString(0);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    peripheral.getServices(callbackContext);\n+  }\n+\n+  private void getCharacteristic(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattCharacteristic characteristic = peripheral.getCharacteristic(characteristicId);\n+\n+    if (characteristic == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    List<PluginResult> multipartMessage =\n+        buildCharacteristicMultipartInfo(deviceAddress, characteristic);\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, multipartMessage));\n+  }\n+\n+  private void getCharacteristics(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> characteristics =\n+        peripheral.getCharacteristics(serviceId);\n+\n+    JSONArray characteristicsInfo = new JSONArray();\n+    for (BluetoothGattCharacteristic characteristic : characteristics) {\n+      characteristicsInfo.put(buildCharacteristicInfo(deviceAddress, characteristic));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, characteristicsInfo));\n+  }\n+\n+  private void getIncludedServices(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    String serviceId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(serviceId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattService> includedServices = peripheral.getIncludedServices(serviceId);\n+\n+    JSONArray servicesInfo = new JSONArray();\n+    for (BluetoothGattService service : includedServices) {\n+      servicesInfo.put(buildServiceInfo(deviceAddress, service));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, servicesInfo));\n+  }\n+\n+  private void getDescriptor(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    BluetoothGattDescriptor descriptor = peripheral.getDescriptor(descriptorId);\n+\n+    if (descriptor == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(\n+        Status.OK, buildDescriptorMultipartInfo(deviceAddress, descriptor)));\n+  }\n+\n+  private void getDescriptors(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    Collection<BluetoothGattDescriptor> descriptors = peripheral.getDescriptors(characteristicId);\n+\n+    JSONArray descriptorsInfo = new JSONArray();\n+\n+    for (BluetoothGattDescriptor descriptor : descriptors) {\n+      descriptorsInfo.put(buildDescriptorInfo(deviceAddress, descriptor));\n+    }\n+\n+    callbackContext.sendPluginResult(new PluginResult(Status.OK, descriptorsInfo));\n+  }\n+\n+  private void readCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readCharacteristicValue(characteristicId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeCharacteristicValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeCharacteristicValue(characteristicId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void startCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, true, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void stopCharacteristicNotifications(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String characteristicId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(characteristicId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.setCharacteristicNotification(characteristicId, false, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void readDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.readDescriptorValue(descriptorId, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void writeDescriptorValue(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    final String descriptorId = args.getString(0);\n+    String deviceAddress = getDeviceAddressFromInstanceId(descriptorId);\n+    final byte[] value = args.getArrayBuffer(1);\n+\n+    final ChromeBluetoothLowEnergyPeripheral peripheral = getPeripheralByDeviceAddress(deviceAddress);\n+\n+    if (peripheral == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    cordova.getThreadPool().execute(new Runnable() {\n+        public void run() {\n+          peripheral.writeDescriptorValue(descriptorId, value, callbackContext);\n+        }\n+      });\n+  }\n+\n+  private void registerBluetoothLowEnergyEvents(final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    bluetoothLowEnergyEventsCallback = callbackContext;\n+\n+  }\n+\n+  private static PluginResult getMultipartServiceEventsResult(\n+      String eventType, String deviceAddress, BluetoothGattService service) throws JSONException {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, buildServiceInfo(deviceAddress, service)));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendServiceAddedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceAdded\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceChangedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceChanged\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendServiceRemovedEvent(String deviceAddress, BluetoothGattService service) {\n+    try {\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(\n+          getMultipartServiceEventsResult(\n+              \"onServiceRemoved\", deviceAddress, service));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendCharacteristicValueChangedEvent(\n+      String deviceAddress, BluetoothGattCharacteristic characteristic) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onCharacteristicValueChanged\"));\n+\n+    try {\n+      multipartMessage.addAll(buildCharacteristicMultipartInfo(deviceAddress, characteristic));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  // From chrome API documentation: \"This event exists mostly for convenience\n+  // and will always be sent after a successful call to readDescriptorValue.\"\n+  private void sendDescriptorValueChangedEvent(\n+      String deviceAddress, BluetoothGattDescriptor descriptor) {\n+\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onDescriptorValueChanged\"));\n+    try {\n+      multipartMessage.addAll(buildDescriptorMultipartInfo(deviceAddress, descriptor));\n+      PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+      result.setKeepCallback(true);\n+      bluetoothLowEnergyEventsCallback.sendPluginResult(result);\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private class ChromeBluetoothLowEnergyPeripheral {\n+\n+    // The UUID of remote notification config descriptor. We need to set the\n+    // value of this descriptor when startNotification() or stopNotification()\n+    // on characteristics.\n+    private final static String CLIENT_CHARACTERISTIC_CONFIG =\n+        \"00002902-0000-1000-8000-00805f9b34fb\";\n+    private final static int CONNECTION_TIMEOUT = 2000;\n+\n+    private final ScanResult bleScanResult;\n+\n+    private BluetoothGatt gatt;\n+\n+    private Map<String, BluetoothGattService> knownServices =\n+        new HashMap<String, BluetoothGattService>();\n+    private Map<String, BluetoothGattCharacteristic> knownCharacteristics =\n+        new HashMap<String, BluetoothGattCharacteristic>();\n+    private Map<String, BluetoothGattDescriptor> knownDescriptors =\n+        new HashMap<String, BluetoothGattDescriptor>();\n+\n+    private CallbackContext connectCallback;\n+    private CallbackContext disconnectCallback;\n+\n+    private CallbackContext getServicesCallbackContext;\n+\n+    private CallbackContext gattCommandCallbackContext;\n+\n+    // BluetoothGatt only allows one async command at a time; otherwise, it will\n+    // cancel the previous command. Using this semaphore to ensure calling\n+    // BluetoothGatt async method in serial. This Semaphore is not initialized\n+    // until a connect() is called.\n+    private Semaphore gattAsyncCommandSemaphore;\n+\n+    ChromeBluetoothLowEnergyPeripheral(ScanResult bleScanResult) {\n+      this.bleScanResult = bleScanResult;\n+    }\n+\n+    private synchronized void connectSuccess() {\n+      if (connectCallback != null) {\n+        connectCallback.success();\n+        connectCallback = null;\n+      }\n+    }\n+\n+    private synchronized void connectTimeout() {\n+      if (connectCallback != null) {\n+        connectCallback.error(\"Connection timeout\");\n+        connectCallback = null;\n+        close();\n+      }\n+    }\n+\n+    private void close() {\n+      if (gatt != null) {\n+        gatt.close();\n+      }\n+\n+      knownServices.clear();\n+      knownDescriptors.clear();\n+      knownCharacteristics.clear();\n+    }\n+\n+    private boolean isConnected() {\n+      ChromeBluetooth bluetoothPlugin =\n+          (ChromeBluetooth) webView.getPluginManager().getPlugin(\"ChromeBluetooth\");\n+      return bluetoothPlugin.isConnected(bleScanResult.getDevice());\n+    }\n+\n+    void connect(CallbackContext callbackContext) throws InterruptedException {\n+\n+      connectCallback = callbackContext;\n+\n+      gatt = bleScanResult.getDevice().connectGatt(\n+          webView.getContext(), false, connectionCallback);\n+\n+      // Reset semaphore here because some read, write's callbacks may not be\n+      // called when a connection lost. This abort all pending gatt commands.\n+      gattAsyncCommandSemaphore = new Semaphore(1, true);\n+\n+      if (isConnected()) {\n+        connectSuccess();\n+      } else {\n+        Thread.sleep(CONNECTION_TIMEOUT);\n+        connectTimeout();\n+      }\n+    }\n+\n+    void disconnect(CallbackContext callbackContext) {\n+      if (!isConnected()) {\n+        callbackContext.success();\n+        close();\n+      } else {\n+        disconnectCallback = callbackContext;\n+        gatt.disconnect();\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattService getService(String serviceId) {\n+      return knownServices.get(serviceId);\n+    }\n+\n+    void getServices(CallbackContext callbackContext) {\n+      getServicesCallbackContext = callbackContext;\n+      if (gatt != null && !gatt.discoverServices()) {\n+        getServicesCallbackContext.error(\"Failed to discover services\");\n+        getServicesCallbackContext = null;\n+      }\n+    }\n+\n+    @Nullable\n+    BluetoothGattCharacteristic getCharacteristic(String characteristicId) {\n+      return knownCharacteristics.get(characteristicId);\n+    }\n+\n+    Collection<BluetoothGattCharacteristic> getCharacteristics(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();\n+\n+      for (BluetoothGattCharacteristic characteristic : characteristics) {\n+        knownCharacteristics.put(\n+            buildCharacteristicId(bleScanResult.getDevice().getAddress(), characteristic),\n+            characteristic);\n+      }\n+\n+      return characteristics;\n+    }\n+\n+    Collection<BluetoothGattService> getIncludedServices(String serviceId) {\n+\n+      BluetoothGattService service = knownServices.get(serviceId);\n+\n+      if (service == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattService> includedServices = service.getIncludedServices();\n+\n+      for (BluetoothGattService includedService : includedServices) {\n+        String includedServiceId = buildServiceId(\n+            bleScanResult.getDevice().getAddress(),\n+            includedService);\n+        if (!knownServices.containsKey(serviceId)) {\n+          sendServiceAddedEvent(bleScanResult.getDevice().getAddress(), includedService);\n+        }\n+        knownServices.put(includedServiceId, includedService);\n+      }\n+\n+      return includedServices;\n+    }\n+\n+    @Nullable\n+    BluetoothGattDescriptor getDescriptor(String descriptorId) {\n+      return knownDescriptors.get(descriptorId);\n+    }\n+\n+    Collection<BluetoothGattDescriptor> getDescriptors(String characteristicId) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null) {\n+        return Collections.emptyList();\n+      }\n+\n+      Collection<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();\n+\n+      for (BluetoothGattDescriptor descriptor : descriptors) {\n+        knownDescriptors.put(\n+            buildDescriptorId(bleScanResult.getDevice().getAddress(), descriptor),\n+            descriptor);\n+      }\n+\n+      return descriptors;\n+    }\n+\n+    void readCharacteristicValue(String characteristicId, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readCharacteristic(characteristic)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read characteristic value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeCharacteristicValue(\n+        String characteristicId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(characteristic.setValue(value) && gatt.writeCharacteristic(characteristic))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into characteristic\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void setCharacteristicNotification(\n+        String characteristicId, boolean enable, CallbackContext callbackContext) {\n+\n+      BluetoothGattCharacteristic characteristic = knownCharacteristics.get(characteristicId);\n+\n+      if (characteristic == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      // set characteristic local notification\n+      if (!gatt.setCharacteristicNotification(characteristic, enable)) {\n+        callbackContext.error(\"Failed to set characteristic local notification\");\n+        return;\n+      }\n+\n+      // set characteristic remote notification\n+      BluetoothGattDescriptor configDescriptor = characteristic.getDescriptor(\n+          UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));\n+\n+      if (configDescriptor == null) {\n+        callbackContext.error(\"Invalid Operation\");\n+        return;\n+      }\n+\n+      if (enable) {\n+        configDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n+      } else {\n+        configDescriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.writeDescriptor(configDescriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to set characteristic remote notification\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void readDescriptorValue(String descriptorId, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!gatt.readDescriptor(descriptor)) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to read descriptor value\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    void writeDescriptorValue(String descriptorId, byte[] value, CallbackContext callbackContext) {\n+\n+      BluetoothGattDescriptor descriptor = knownDescriptors.get(descriptorId);\n+\n+      if (descriptor == null || gatt == null) {\n+        callbackContext.error(\"Invalid Argument\");\n+        return;\n+      }\n+\n+      try {\n+        gattAsyncCommandSemaphore.acquire();\n+        gattCommandCallbackContext = callbackContext;\n+        if (!(descriptor.setValue(value) && gatt.writeDescriptor(descriptor))) {\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+          callbackContext.error(\"Failed to write value into descriptor\");\n+        }\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+\n+    private BluetoothGattCallback connectionCallback = new BluetoothGattCallback() {\n+        @Override\n+        public void onCharacteristicChanged(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n+          sendCharacteristicValueChangedEvent(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+        }\n+\n+        @Override\n+        public void onCharacteristicRead(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext readCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (readCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                readCallbackContext.sendPluginResult(\n+                    new PluginResult(Status.OK, buildCharacteristicMultipartInfo(\n+                        bleScanResult.getDevice().getAddress(),\n+                        characteristic)));\n+              } catch (JSONException e) {\n+              }\n+              break;\n+            case BluetoothGatt.GATT_READ_NOT_PERMITTED:\n+              readCallbackContext.error(\"Read characteristic not permitted\");\n+              break;\n+            default:\n+              readCallbackContext.error(\"Read characteristic failed\");\n+          }\n+        }\n+\n+        @Override\n+        public void onCharacteristicWrite(\n+            BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {\n+\n+          CallbackContext writeCallbackContext = gattCommandCallbackContext;\n+          gattCommandCallbackContext = null;\n+          gattAsyncCommandSemaphore.release();\n+\n+          String characteristicId = buildCharacteristicId(\n+              bleScanResult.getDevice().getAddress(), characteristic);\n+\n+          if (writeCallbackContext == null)\n+            return;\n+\n+          switch (status) {\n+            case BluetoothGatt.GATT_SUCCESS:\n+              try {\n+                writeCallbackContext.sendPluginResult(",
        "path": "chrome-cordova/plugins/chrome.bluetoothLowEnergy/src/android/ChromeBluetoothLowEnergy.java",
        "position": 1086,
        "original_position": 1023,
        "commit_id": "79aad4f69e07152c09df7c9ca43be108441fca52",
        "original_commit_id": "c1094091133d847b8c4a81888de963ca99e4f659",
        "user": {
            "login": "oahziur",
            "id": 4604464,
            "node_id": "MDQ6VXNlcjQ2MDQ0NjQ=",
            "avatar_url": "https://avatars2.githubusercontent.com/u/4604464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/oahziur",
            "html_url": "https://github.com/oahziur",
            "followers_url": "https://api.github.com/users/oahziur/followers",
            "following_url": "https://api.github.com/users/oahziur/following{/other_user}",
            "gists_url": "https://api.github.com/users/oahziur/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/oahziur/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/oahziur/subscriptions",
            "organizations_url": "https://api.github.com/users/oahziur/orgs",
            "repos_url": "https://api.github.com/users/oahziur/repos",
            "events_url": "https://api.github.com/users/oahziur/events{/privacy}",
            "received_events_url": "https://api.github.com/users/oahziur/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I just send `callbackContext.error()` for now. I don't think we can remove the `try` since this is not a runtime exception and we have to use try in this case.\n",
        "created_at": "2014-12-05T19:19:30Z",
        "updated_at": "2014-12-05T19:19:30Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21393289",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21393289"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/444#discussion_r21393289"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/444"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21579695",
        "pull_request_review_id": null,
        "id": 21579695,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTc5Njk1",
        "diff_hunk": "@@ -42,8 +43,13 @@\n     }\n   },\n   \"bluetooth\": {\n+    \"socket\": true,\n     \"low_energy\": true,\n-    \"uuids\": [\"C9D3\", \"180D\"]\n+    \"uuids\": [\n+      \"C9D3\",",
        "path": "chrome-cordova/chrome-apps-api-tests/manifest.json",
        "position": null,
        "original_position": 16,
        "commit_id": "e029c9a6c65f2b52a77a3b59eec6a5387407fa05",
        "original_commit_id": "637e0f0efba29460fbe0561d47ea1deb07289934",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "May you comment what each of these is for (which tests, which paired devices/services).\n",
        "created_at": "2014-12-10T01:59:41Z",
        "updated_at": "2014-12-12T19:10:19Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/467#discussion_r21579695",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/467",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21579695"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/467#discussion_r21579695"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/467"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21639607",
        "pull_request_review_id": null,
        "id": 21639607,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNjM5NjA3",
        "diff_hunk": "@@ -0,0 +1,647 @@\n+// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium;\n+\n+import android.bluetooth.BluetoothAdapter;\n+import android.bluetooth.BluetoothDevice;\n+import android.bluetooth.BluetoothServerSocket;\n+import android.bluetooth.BluetoothSocket;\n+\n+import org.apache.cordova.CallbackContext;\n+import org.apache.cordova.CordovaArgs;\n+import org.apache.cordova.CordovaPlugin;\n+import org.apache.cordova.PluginResult;\n+import org.apache.cordova.PluginResult.Status;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+public class ChromeBluetoothSocket extends CordovaPlugin {\n+\n+  private Map<Integer, ChromeBluetoothSocketSocket> sockets =\n+      new ConcurrentHashMap<Integer, ChromeBluetoothSocketSocket>();\n+\n+  private int nextSocket = 1;\n+  private static final String LOG_TAG = \"ChromeBluetoothSocket\";\n+\n+  private CallbackContext bluetoothSocketEventsCallback;\n+\n+  @Override\n+  public boolean execute(String action, CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+    if (\"create\".equals(action)) {\n+      create(args, callbackContext);\n+    } else if (\"update\".equals(action)) {\n+      update(args, callbackContext);\n+    } else if (\"setPaused\".equals(action)) {\n+      setPaused(args, callbackContext);\n+    } else if (\"listenUsingRfcomm\".equals(action)) {\n+      listenUsingRfcomm(args, callbackContext);\n+    } else if (\"connect\".equals(action)) {\n+      connect(args, callbackContext);\n+    } else if (\"disconnect\".equals(action)) {\n+      disconnect(args, callbackContext);\n+    } else if (\"close\".equals(action)) {\n+      close(args, callbackContext);\n+    } else if (\"send\".equals(action)) {\n+      send(args, callbackContext);\n+    } else if (\"getInfo\".equals(action)) {\n+      getInfo(args, callbackContext);\n+    } else if (\"getSockets\".equals(action)) {\n+      getSockets(callbackContext);\n+    } else if (\"registerBluetoothSocketEvents\".equals(action)) {\n+      registerBluetoothSocketEvents(callbackContext);\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private void create(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    JSONObject properties = args.getJSONObject(0);\n+\n+    ChromeBluetoothSocketSocket socket = new ChromeBluetoothSocketSocket(nextSocket++, properties);\n+    sockets.put(socket.getSocketId(), socket);\n+\n+    JSONObject createInfo = new JSONObject();\n+    createInfo.put(\"socketId\", socket.getSocketId());\n+    callbackContext.success(createInfo);\n+  }\n+\n+  private void update(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+    JSONObject properties = args.getJSONObject(1);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    socket.update(properties);\n+    callbackContext.success();\n+  }\n+\n+  private void setPaused(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+    boolean paused = args.getBoolean(1);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    socket.setPaused(paused);\n+    callbackContext.success();\n+  }\n+\n+  private void listenUsingRfcomm(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+    String uuid = args.getString(1);\n+    JSONObject options = args.getJSONObject(2);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    socket.listenUsingRfcomm(uuid, options, callbackContext);\n+  }\n+\n+  private void connect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+    String address = args.getString(1);\n+    String uuid = args.getString(2);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    socket.connect(address, uuid, callbackContext);\n+  }\n+\n+  private void disconnect(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    try {\n+      socket.disconnect();\n+      callbackContext.success();\n+    } catch (IOException e) {\n+      callbackContext.error(e.getMessage());\n+    }\n+  }\n+\n+  private void close(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    try {\n+      socket.disconnect();\n+      sockets.remove(socket.getSocketId());\n+      callbackContext.success();\n+    } catch (IOException e) {\n+      callbackContext.error(e.getMessage());\n+    }\n+  }\n+\n+  private void send(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+    byte[] data = args.getArrayBuffer(1);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+    socket.send(data, callbackContext);\n+  }\n+\n+  private void getInfo(CordovaArgs args, final CallbackContext callbackContext)\n+      throws JSONException {\n+\n+    int socketId = args.getInt(0);\n+\n+    ChromeBluetoothSocketSocket socket = sockets.get(socketId);\n+\n+    if (socket == null) {\n+      callbackContext.error(\"Invalid Argument\");\n+      return;\n+    }\n+\n+    callbackContext.success(socket.getInfo());\n+  }\n+\n+  private void getSockets(final CallbackContext callbackContext) throws JSONException {\n+\n+    JSONArray results = new JSONArray();\n+\n+    for (ChromeBluetoothSocketSocket socket: sockets.values()) {\n+      results.put(socket.getInfo());\n+    }\n+\n+    callbackContext.success(results);\n+  }\n+\n+  private void registerBluetoothSocketEvents(final CallbackContext callbackContext) {\n+    bluetoothSocketEventsCallback = callbackContext;\n+  }\n+\n+  private void sendReceiveEvent(int socketId, byte[] data) {\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, \"onReceive\"));\n+    multipartMessage.add(new PluginResult(Status.OK, socketId));\n+    multipartMessage.add(new PluginResult(Status.OK, data));\n+    PluginResult result = new PluginResult(Status.OK, multipartMessage);\n+    result.setKeepCallback(true);\n+    bluetoothSocketEventsCallback.sendPluginResult(result);\n+  }\n+\n+  private static PluginResult getMultipartEventsResult(\n+      String eventType, Status status, JSONObject info) {\n+    List<PluginResult> multipartMessage = new ArrayList<PluginResult>();\n+    multipartMessage.add(new PluginResult(Status.OK, eventType));\n+    multipartMessage.add(new PluginResult(Status.OK, info));\n+    PluginResult result = new PluginResult(status, multipartMessage);\n+    result.setKeepCallback(true);\n+    return result;\n+  }\n+\n+  private void sendReceiveErrorEvent(int socketId, String errorMessage) {\n+    try {\n+      JSONObject errorInfo = new JSONObject();\n+      errorInfo.put(\"socketId\", socketId);\n+      errorInfo.put(\"errorMessage\", errorMessage);\n+      bluetoothSocketEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onReceive\", Status.ERROR, errorInfo));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendAcceptEvent(int socketId, int clientSocketId) {\n+    try {\n+      JSONObject info = new JSONObject();\n+      info.put(\"socketId\", socketId);\n+      info.put(\"clientSocketId\", clientSocketId);\n+      bluetoothSocketEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAccept\", Status.OK, info));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private void sendAcceptErrorEvent(int socketId, String errorMessage) {\n+    try {\n+      JSONObject errorInfo = new JSONObject();\n+      errorInfo.put(\"socketId\", socketId);\n+      errorInfo.put(\"errorMessage\", errorMessage);\n+      bluetoothSocketEventsCallback.sendPluginResult(\n+          getMultipartEventsResult(\"onAccept\", Status.ERROR, errorInfo));\n+    } catch (JSONException e) {\n+    }\n+  }\n+\n+  private enum SocketType {\n+    SO_TYPE_UNKNOWN,\n+    SO_TYPE_CLIENT,\n+    SO_TYPE_SERVER;\n+  }\n+  private class ChromeBluetoothSocketSocket {\n+\n+    private final int socketId;\n+\n+    private boolean persistent;\n+    private String name;\n+    private int bufferSize;\n+    private boolean paused;\n+\n+    private SocketType type;\n+    private UUID uuid;\n+    private BluetoothSocket clientSocket;\n+    private BluetoothServerSocket serverSocket;\n+\n+    // Fields for client socket only\n+    private ClientThread clientThread;\n+    private byte[] pausedBuffer;\n+\n+    // Fields for server socket only\n+    private ServerThread serverThread;\n+    private BlockingQueue<Integer> acceptedSocketsQueue = new LinkedBlockingQueue<Integer>();\n+    // The default backlog value depends on OS, we just set 1 for now.\n+    int backlog = 1;\n+\n+    ChromeBluetoothSocketSocket(int socketId, JSONObject properties) throws JSONException {\n+      this.socketId = socketId;\n+      type = SocketType.SO_TYPE_UNKNOWN;\n+      setDefaultProperties();\n+      setProperties(properties);\n+    }\n+\n+    // This constructor can only be used to create socket with an accepted socket\n+    private ChromeBluetoothSocketSocket(int socketId, BluetoothSocket clientSocket) {\n+      this.socketId = socketId;\n+      type = SocketType.SO_TYPE_CLIENT;\n+      this.clientSocket = clientSocket;\n+      paused = true;\n+      setDefaultProperties();\n+    }\n+\n+    private void setDefaultProperties() {\n+      persistent = false;\n+      name = \"\";\n+      bufferSize = 4096;\n+      paused = false;\n+    }\n+\n+    private void setProperties(JSONObject properties) throws JSONException {\n+\n+      if (!properties.isNull(\"persistent\"))\n+        persistent = properties.getBoolean(\"persistent\");\n+\n+      if (!properties.isNull(\"name\"))\n+        name = properties.getString(\"name\");\n+\n+      if (!properties.isNull(\"bufferSize\"))\n+        bufferSize = properties.getInt(\"bufferSize\");\n+    }\n+\n+    private boolean isConnected() {\n+      if (type == SocketType.SO_TYPE_CLIENT && clientSocket != null)  {\n+        return clientSocket.isConnected();\n+      }\n+      return false;\n+    }\n+\n+    int getSocketId() {\n+      return socketId;\n+    }\n+\n+    void update(JSONObject properties) throws JSONException {\n+      setProperties(properties);\n+    }\n+\n+    void setPaused(boolean paused) {\n+      this.paused = paused;\n+      if (this.paused == false) {\n+        if (type == SocketType.SO_TYPE_CLIENT) {",
        "path": "chrome-cordova/plugins/chrome.bluetoothSocket/src/android/ChromeBluetoothSocket.java",
        "position": null,
        "original_position": 373,
        "commit_id": "e029c9a6c65f2b52a77a3b59eec6a5387407fa05",
        "original_commit_id": "637e0f0efba29460fbe0561d47ea1deb07289934",
        "user": {
            "login": "mmocny",
            "id": 474282,
            "node_id": "MDQ6VXNlcjQ3NDI4Mg==",
            "avatar_url": "https://avatars2.githubusercontent.com/u/474282?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mmocny",
            "html_url": "https://github.com/mmocny",
            "followers_url": "https://api.github.com/users/mmocny/followers",
            "following_url": "https://api.github.com/users/mmocny/following{/other_user}",
            "gists_url": "https://api.github.com/users/mmocny/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mmocny/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mmocny/subscriptions",
            "organizations_url": "https://api.github.com/users/mmocny/orgs",
            "repos_url": "https://api.github.com/users/mmocny/repos",
            "events_url": "https://api.github.com/users/mmocny/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mmocny/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Could we move this to some helper like resume() or something?\n",
        "created_at": "2014-12-10T21:37:13Z",
        "updated_at": "2014-12-12T19:10:19Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/467#discussion_r21639607",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/467",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/21639607"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/467#discussion_r21639607"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/467"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/30379093",
        "pull_request_review_id": null,
        "id": 30379093,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwMzc5MDkz",
        "diff_hunk": "@@ -23,7 +23,7 @@ To publish your Android application to the Play Store:\n    ```\n   * Create a password when prompted\n   * Note: the \"cca exec\" prefix is required only if keytool is not already available on your PATH\n-  * To see retrieve your certificate's fingerprint (needed when using `chrome.identity`):\n+  * To retrieve your certificate's fingerprint (needed when using `chrome.identity`):\n     * `cca exec keytool -list -v -keystore keys.p12 -storetype PKCS12`",
        "path": "docs/Publish.md",
        "position": 6,
        "original_position": 6,
        "commit_id": "feed2e014a9544ed6840c7e33d5e2b92b9b54a32",
        "original_commit_id": "feed2e014a9544ed6840c7e33d5e2b92b9b54a32",
        "user": {
            "login": "Ames0831",
            "id": 12452356,
            "node_id": "MDQ6VXNlcjEyNDUyMzU2",
            "avatar_url": "https://avatars0.githubusercontent.com/u/12452356?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Ames0831",
            "html_url": "https://github.com/Ames0831",
            "followers_url": "https://api.github.com/users/Ames0831/followers",
            "following_url": "https://api.github.com/users/Ames0831/following{/other_user}",
            "gists_url": "https://api.github.com/users/Ames0831/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/Ames0831/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/Ames0831/subscriptions",
            "organizations_url": "https://api.github.com/users/Ames0831/orgs",
            "repos_url": "https://api.github.com/users/Ames0831/repos",
            "events_url": "https://api.github.com/users/Ames0831/events{/privacy}",
            "received_events_url": "https://api.github.com/users/Ames0831/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Keys \n",
        "created_at": "2015-05-15T01:20:55Z",
        "updated_at": "2015-05-15T01:20:55Z",
        "html_url": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/565#discussion_r30379093",
        "pull_request_url": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/565",
        "author_association": "NONE",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/comments/30379093"
            },
            "html": {
                "href": "https://github.com/MobileChromeApps/mobile-chrome-apps/pull/565#discussion_r30379093"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/MobileChromeApps/mobile-chrome-apps/pulls/565"
            }
        }
    }
]