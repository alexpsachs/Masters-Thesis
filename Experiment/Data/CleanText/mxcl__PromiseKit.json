{
    "mxcl": "Yes, I'll add the choose-a-queue variant, and probably add an NSOperationQueue category too.\nFor other kinds of \"executor\" I'll wait for people to propose additions or use cases.\n. I started to consider the NSOperation variant and wasn't sure if it should be a category on NSOperationQueue or a subclass of NSOperation and what should then happen with then (ie. should the then's be operations also? If so, the complexity increases).\nBut as you can see above, I committed dispatch_promise_on.\n. As an additional note, I will make it possible for then to specify a queue (like your example code shows) as part of this ticket.\n. As soon as I can figure out how to do it elegantly. I can't really estimate that well, but I really would like to get this in ASAP.\n. dispatch_promise is documented to run on a background queue. It thens onto the main queue.\nThere is also dispatch_promise_on if you need a specific queue. Also documented.\nThere is currently no guarantees about the queue a then runs on, it depends on the implementation of the Promise, it's just currently they all then onto main.\nThus to achieve your current goals you can do this for now:\nobjc\nsomepromise.then(^{\n    return dispatch_promise(^{\n        //\u2026\n    });\n}).then(^{\n    return dispatch_promise(^{\n        //\u2026\n    });\n});\nNot pretty, but works for now. Naturally this will mean the main queue is always used as an intermediate, but that should be fine under most circumstances. Just not ideal.\n. @Zyphrax yes, I like that.\n. Then has to be mainQueue. Promises are cross-library solutions, and could come from any source. Their behavior has to be consistent, or their utility is reduced.\n. I'm not sure of an elegant solution. But for me, usually I only need one then block in any particular chain to be in a background queue, so continue isn't necessary. Maybe it's just the way I code. Perhaps you can provide an example where something like continue would make your code more elegant?\nI try to resist new methods without compelling justification. Especially now, when the library is new, and how it will come to be used is not entirely defined.\n. @andrebraga the problem here is that if the promise crosses a library boundary you (the user) have no way of knowing what queue the then will execute on. then must be consistent.\n. I can see your intent, but stringByAppendingString doesn't take a format. Probably however it should use stringWithFormat as that is way more common. If you adapt the PR I'll merge. Thanks.\n. Oh my bad, I misread the diff. You are absolutely right.\n. Probably, at the time I couldn't think of anything better. It is a private function though. So it's not as important.\n. Oh I agree completely. I plan to add a few comments and I'll rename voodoo today.\n. Let me know if you want more documentation. I am typically a little sparse with code comments.\n. I actually can handle this, so I will. Let\u2019s be delightful!\n. Thanks. I have submitted 0.9.1 to @CocoaPods/Specs with this fix.\n. This is a new clang feature. What version of Xcode are you running?\n. @cdzombak thanks, just what I was after.\n@lloydsheng I'll update the podspec, but for now you can enable modules in your project settings to get round this.\n. Merged into CocoaPods spec: https://github.com/CocoaPods/Specs/pull/10938\n. Thanks for the link, the specifications I have worked off of are less good. I'll make an assessment of our compliance.\nCan you provide an example of the constructor style? I used Deferred as my research had not led to another way of doing it that I felt was adequate. I'm not sure I saw this new style.\n. So, mostly yes.\nThe only significant difference is PromiseKit\u2019s then does not take an error handler, instead we have a dedicated catch handler. This was an active decision, I believe it makes code using Promises clearer.\nIt does make the implementation trickier, but I believe we otherwise (except where the spec is clearly Javascript specific) comply.\nThere are a couple of points that we don't yet implement that we should, but there are (AFAICT) for sanity checking reasons:\n\nI'll update the README with details.\n. I don't think it can be done with a define because there is no way I can see that allows the define to be enforced for all pods in a workspace.\n. In fact, this is something I plan, yes. Can't give an ETA though. It's not too tricky, since we get a block's method signature. But it would require additional tests. For now, pass the parameters as an array (indeed, ugly) and extract them out in your then.\n. Reopening as a reminder.\n. To use this facilitator use PMKManifold, e.g.:\nobjc\n[Promise new:^(PromiseResolver fulfiller, PromiseResolver rejecter){\n    [self.someAsyncTaskWithCompletionBlock:^(id foo, id bar){\n        fulfiller(PMKManifold(foo, bar));\n    }];\n}];\n. Sure, I dislike the hacks also. Thanks.\n. Really great. Didn\u2019t think of this method myself. Great work.\n. Yes. Agreed.\n. \ud83d\udc4c\n. I agree and am aware of the convention that exceptions are \u201cprogrammer errors\u201d in Cocoa, but the convenience of being able to throw inside then handlers is large, and I have taught PromiseKit four times now, the first two the catch handler was named fail and by far the idea of Promises was much easier to grasp when I turned it around and made it seems like a try\u2026catch block.\nAlso, I like the fault tolerant code I create now. Even out of bounds errors don't crash my program, and inside asynchronous blocks this is often desirable, instead of 1) tap button 2) crash the user gets 1) tap button 2) UIAlertView.\nFinally, the error method is in fact supported in PromiseKit, if you return an NSError from any handler it is treated the same as an exception being thrown. The parameter to a catch block is always an NSError.\nEdit: I guess throwing is not more convenient, but it is very explicit. I aim for code and libraries that you can show people and they \u201cget it\u201d.\n. There is: just define RETHROW_LIKE_A_MOFO.\nhttps://github.com/mxcl/PromiseKit/blob/master/objc/PMKPromise.m#L173\nHowever I can only say good things about catching all exceptions. You can still crash if you must, but it gives you the opportunity to do something first if you like. Just implement the PMKUnhandledErrorHandler block.\nPersonally I show a fatal error message and then crash, It's more user friendly.\n. That's the only place it happens, it's not the policy of PromiseKit to catch any exceptions, it's just the policy of promise kit that any errors or exceptions that happen during asynchronous handling are caught so you have the opportunity to handle them. Otherwise you wouldn't even be able to catch the exception or handle the error even if you wanted to. Most other toolkits just swallow the error and return nil.\nReview the code, it seems like you are worried about it and you shouldn't just take my word, or the word of anyone else who has put code on Github.\n. The way I use promises:\n1. chain everything that is a task so that I end up with a single promise for each logical separation of \u201ctask\u201d\n2. if an error happens consider that task failed and restore UI to before the promise\n3. if it succeeds go to the next step\nThis way if an exception is thrown it is isolated to that promise chain and I can safely just show an error. My state machine is safe. Everything is cool.\nI don't catch exceptions in the rest of the app, but inside the promise chain, it's fine.\nI've enjoyed the additional stability promises provide. So have my clients.\n. My promises are not coupled to the state of my application.\nCocoa exceptions are things like out of bounds accesses to arrays, or passing nil to an NSJSONSerialization.\nI'm not sure I want my real life apps with 500,000 users to crash because some JSON provider returned invalid UTF8 data.\n. I can certainly see your perspective, and I've gone back on forth on it.\nMaybe it is the wrong decision, but I think it benefits 95% of developers.\nPerhaps it is no good for Venmo though, you guys are more mission critical than most.\nStill, for users like yourselves I have provided mechanisms to have the promises work how you would like them to. Let me know if there is more than can be done.\n. I've been thinking about this all evening and maybe this should be reconsidered. If you consider exceptions programmer errors, and programmer errors that may lead to serious corruption, then they shouldn't be allowed to maintain the objects that they have any coupling.\nI dunno. There are not many common exceptions that are thrown. Out of bounds array exceptions indicate a bad index, and this is potentially bad. Throwing because data is nil for NSJSONSerialization however is an example of something that should just be a runtime error. In that case we can catch that and make it into an error.\nWe could use some common exceptions in this thread to aid our decision.\n. PromiseKit 2 will not catch exceptions. After much deliberation I decided my choice for 1.x was wrong.\n. Sure, you just have to write the category like described at http://promisekit.org.\nPromiseKit is new, so as yet, nobody has written interfaces for popular libraries like AFNetworking.\n``` objc\n@interface AFHTTPRequestOperation (PromiseKit)\n\n(Promise )promise {\n    return [Promise new:^(PromiseResolver fulfiller, PromiseResolver rejecter){\n        [self setCompletionBlockWithSuccess:^(AFHTTPRequestOperation op, id responseObject){\n            fulfiller(responseObject);\n        }) failure:^(AFHTTPRequestOperation op , NSError error){\n            rejecter(error);\n        }];\n    }];\n}\n\n@end\n```\nIf you write the library, submit it to AFNetworking or create a new pod. Thanks.\n. Fabulous.\nOne comment is that PMKManifold won't work with the rejecter:\nhttps://github.com/csotiriou/PromiseKit-AFNetworking/blob/master/PromiseKit%2BAFNetworking/AFNetworking%2BPromises.m#L35\nInstead you should reject with the error and add the operation as a new key in the error's userInfo.\nFor now then:\n``` objc\n@implementation AFHTTPRequestOperation (Promises)\n\n(Promise )promise\n{\n    return [Promise new:^(PromiseResolver fulfiller, PromiseResolver rejecter){\n        [self setCompletionBlockWithSuccess:^(AFHTTPRequestOperation operation, id responseObject) {\n            fulfiller(PMKManifold(responseObject, operation));\n        } failure:^(AFHTTPRequestOperation operation, NSError error) {\n            id info = error.userInfo.mutableCopy;\n            info[AFHTTPRequestOperationErrorKey] = operation;\n            id newerror = [NSError errorWithDomain:error.domain code:error.code userInfo:info]; \n            rejecter(newerror);\n        }];\n    }];\n}\n\n@end\n```\nWriting that out makes me realize I can improve the documentation and the syntax for this.\n. Once you're ready, let me know and I'll add you to the documentation as an implementer.\n. Well, it will work I guess! But you won't get catch(id o, id q){} like you would with then.\n. Glad to hear it :)\n. https://github.com/skeeet/AFNetworking-PromiseKit beat you to the pod.\n. My bad, I read the README for each project and the other seemed to imply it had grabbed the pod-name.\n. I believe I fixed this. Try pod update. If not I'll look straight into it, as indeed, this is a bug.\n. I believe this commit fixed it: ae18079fe08d4a85936fd695d39e30552cff7795\n. Thanks. You were absolutely right.\n. I like not having to open Xcode (like obviously I am developing in Xcode, but usually it would mean having to open another Xcode window for the PromiseKit tests), so I made it so I can just run it in the Terminal. There are no disadvantages, but I also can run a sinatra web server that returns fixtures so I don't need to mock NSURLConnection and that\u2019s very handy.\nIn many ways it was just experimentation, seeing what was possible. I've done it with several other projects too and each time it felt like I was gaining in ways I appreciate while not losing anything that mattered to me. I find the testing environment in Xcode unsatisfactory since it requires the iPhone simulator and also runs an entire application inside the simulator, with event loop and UIApplication. This way I have more control while also knowing for sure what is running, which when it comes to testing, seems important.\nThe only disadvantage is not getting the Xcode debugger when tests fail in ways you need to debug. I added a -d flag but the CLI LLDB is not as nice as Xcode.\n. I have been thinking about it. I was wondering if the cancelation could be communicated via an attached NSProgress. This seems very objc.\nNSURLConnection+PromiseKit would need to be rewritten to use the cancelable variety of NSURLConnection though (ie. delegation mechanism rather than completionBlock mechanism).\n. Indeed, the reason I was thinking of NSProgress in the first place was because Promises also should have progress. So it seems appropriate. I haven't done much research yet though so am not 100% sure it will work right.\nThanks for the link, interesting and useful material.\n. In my mind it's possible. If we think of canceling as just making that promise rejected with an NSError with code PMKCanceled, then everything else works out automatically. Providing an override for new that is a pointer to a block that is called when the promise is canceled would allow the promise to react to cancelation if it can. If it can't then it will finish, but its value will be ignored.\nThening off a rejected promise does nothing, and this is how it already is. So the multiplicity factor is already handled.\nI still would like to explore an NSProgress solution though.\n. Translating @kriskowal\u2019s comment: a key-tenant of Promises is that other systems cannot mess with them, they reject or fulfill themselves, but only they have that power. Based on this knowledge you can right robust software. Adding a cancel method to a Promise would make it possible for any part of the chain to cancel other promises it has access to leading to unexpected behavior.\nPOLA is Principle of Least Astonishment. I find the acronym ironic.\nI'm not totally sold on this argument. It's nice to imagine a world without astonishment but the real world involves cancelation.\nHowever, ATEOD I don't think cancelation is a 80% use case. IMO it's not even a 95% use case. @kriskowal\u2019s argument is quite compelling IMO for not adding features that aren't necessary that may lead to hard to debug systems.\n. @kriskowal thanks for your input, I appreciate it.\n. @albsala when automatically fails its promise when any of its array of input promises fail.\nIf you need to also cancel the remaining downloads then you will need to make your own promises for downloading that have a cancel mechanism. Wrapping a download is not particularly hard, just check NSURLConnection+PromiseKit.m.\nI'll document how to implement a cancel mechanism at some point, but as said in depth above, we cannot easily add canceling to Promises without producing an API with unexpected behavior, so if canceling is absolutely essential for you then don't use promises or make your own promise that has a cancel capability.\n. The question for the framework is: is ensure clearer and more useful than an if statement in the then?\n. 2.0 supports the idea of cancellation. Promises themselves cannot be cancelled, but the task they represent can (eg. [NSURLConnection cancel]). The promise then must ensure PromiseKit knows the specific NSError object that is generated is a cancellation error.\nCancellation errors skip to the next catch, but the catch handler is not executed unless it is called with catch(policy: .AllErrors).\nThis seemed the correct way to handle a cancellation. Not all promises are cancelable, promises that cancel do not resolve their chain. The catch handler usually is not interested in cancellation since either the user or the developer decided to end the chain explicitly, it is not strictly an error. Eg. with a typical flow with something that is cancellable:\n```\nUIApplication.sharedApplication().networkActivityIndicatorVisible = true\nlet cancellableThing = CancellableThing()\ncancellableThing.go().then {\n    //\u2026\n}.then {\n    //\u2026\n}.finally {\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = false\n}.catch { err in\n    UIAlertView.show(err)\n}\ncancellableThing.cancel()\n```\nHere the finally will undo the UI changes but an error alert view will not be shown to the user. Here the developer decided to cancel the chain, presumably because they no longer care about the result. In such a situation neither an error should occur nor should the chain itself have to identify and handle that situation. Let's compare with what is necessary for an alert view in PromiseKit 1.x:\nUIAlertView(\u2026).promise().then { dismissedButtonIndex in\n    if dismissedButtonIndex != alert.cancelButtonIndex {\n        foo().then {\n            // rightward drift\n        }\n    }\n}\nRightward drift. Yuck.\nLet me know if I should leave this open.\n. Terrific! Thank you.\n. Regarding error handling, as long as all the info there, I think that's what is most important at this point. I am researching how we can configure NSError to be most useful, and hopefully eventually will have something good to contribute there.\n. Thanks for the review.\nYou are right, the then is executed synchronously if the promise has been resolved.\nExecution contexts seem rather JavaScript specific. Is there any portable reason that synchronously invoking the then is unsafe? \n. Yes, I see. I'll amend that. Thanks.\n. Yes for sure. As much as it makes sense to from the Objective-C point of view. I know the spec was the result of much work, research and real-world experience so believe it to be a solid goal.\n. Thanks for pointing this stuff out. As I have come to fix I have realized its importance.\n. The solution is: call -value first, and branch.\nThe situation where the callback is executed out-of-order becomes ever more possible the more promises involved in your system, and then, eventually, one day, you are bitten by this issue, and like a race-condition, it doesn't happen always, just sometimes, and you can\u2019t figure out the cause or the source.\nProbably we can provide an immediate then option. As I hate the check and branch too.\n. Is this a bug? Result must be an object, so the only falsey value it can be is nil, and nil indicates that no result has been set.\n. You can fulfill with nil. Internally I fulfill with the static constant PMKNull, and convert that back to nil when thening.\n. That works also because you can only fulfill currently with objective-C objects, so you'd have to fulfill with @0 which is not falsey.\nI will eventually make it so you can fulfill with primitives, it's just with Objective-C this is not trivial to make possible. Already the block voodoo is quite scary.\n. You can fulfill with NO, but it has to be @NO.\n. Is there a use case for this? Or is it just rigid adherence to the spec?\n. Strictly I cannot see details of how the initial resolution should be handled in the spec. It only details thening. Leaving how the root promise is resolved/fulfilled up to the implementer. No?\n. I think this will remain a \u201cdivergence\u201d from the spec.\nSince JS promises allow rejection with a \u201creason\u201d which has no specific base class, but here I have decided that rejections will always be of the type NSError I don't want to allow the situation where you can fulfill with an error as this will lead to ambiguity. The certainty that errors are always rejected is good for the framework.\nI'll document that this is a point of divergence, though I think it remains in the spirit of the spec.\n. I wasn\u2019t sure which was best here, and since I have come to dislike it throwing, so good to hear another opinion SLASH better understanding of the spec.\n. Is \"sealing\" a promise acceptable nomenclature, because I love it.\n. I was referring to it as \"resolved\". I prefer \"sealed\" and will probably change the docs.\n. Is there something wrong with the diff that fixed the bug that closed the issue?\n. I was indeed thinking of NSProgress for this. And yes, it would mean not having progress support for < iOS 7, though someone could provide an NSProgress implementation in those cases.\nFor your use case you may have to be creative, since promises can only resolve once. One option is to fulfill your promise with the data and a new promise:\nobjc\nself.fetch.then(^(NSData *cachedData, Promise *freshDataPromise) {\n    [self updateWithData:cachedData];\n    return freshDataPromise;\n}).then(^(NSData *freshData){\n    [self updateWithData:freshData];\n});\nIf there is no cachedData, fulfill with (nil, freshDataPromise).\nYou can fulfill multiple parameters with PMKManifold().\n. I've experimented with this and NSProgress is a good Cocoa solution for PromiseKit IMO.\n. What's a void block? A block that does nothing? Returns nothing? Take's nothing? Thanks.\n. I believe this is what happens. I just wrote a new test to confirm it, which passes:\nobjc\n- (void)test_45_when_which_returns_void {\n    promise = promise.then(^{});\n    [Promise when:@[promise, [Promise promiseWithValue:@1]]].then(^(NSArray *stuff){\n        XCTAssertEqual(stuff.count, 2ul);\n        XCTAssertEqualObjects(stuff[0], [NSNull null]);\n        resolved = YES;\n    });\n    fulfiller(@1);\n    XCTAssertTrue(resolved); \n}\n. I like when. For me, it reads well. However I'm happy to add all as an alias as I realize it is common in other implementations, such as rsvp,js.\n. Anything thrown inside a then or catch rejects, so you can throw a Promise and it will reject. The initial reject is not detailed in the spec as far as I can tell.\n. Presumably a warning?\n. I think a solution would be to provide the index from the original array as a key in the error userInfo, or possibly as a second parameter in the catch off of a when. Though the latter would require some magic. Thoughts?\n. objc\n[Promise when:@[p1, p2, p3]].catch(^(NSError *err){\n    int indexOfPromiseThatRejected = [err.userInfo[PMKFailingPromiseIndexKey] intValue];\n});\nAlso I added a NSDictionary method:\nobjc\nid promises = @{\n    @1: somePromise,\n    @2: @\"abc\",\n    @\"a\": [NSURLConnection GET:URL]\n};\n[Promise all:promises].then(^(NSDictionary *dict){\n    //\u2026\n});\nIn which case PMKFailingPromiseIndexKey will be the corresponding input dictionary key.\nPMKFailingPromiseIndexKey is a little unwieldy because it is typical for these strings to end with Key.\n. I believe I understand the issues. You should review the eventual patch.\n. Sounds like a pretty good solution and set of diffs. I'll check it out when I get a chance. Thanks!\n. Reviewed. I like it.\nForgive me if I should know this (or could easily find appropriate resources), but is use of GCD of NSLock or @synchronized better? I like the code, but would rather use the most performant option since most of the time the synchronization will be overhead.\nI would like the pull request ASAP if possible, as I fear many people are experiencing these issues.\n. If you haven\u2019t much time I will just merge it locally with some adjustments and push that. Though I'd still like to discuss using locks so in the future we may make a decision about what is best. But the need for thread safety is urgent and I have verified the tests pass.\n. Look forward to it :+1: \n. 3e48ec95c9e6449014340660690baccd409fd2bb\n. @csotiriou thanks for the feedback, it's always useful. Especially when it is intelligent and detailed.\n. Thanks for the excellent explanation.\nRegarding not using the queue when the promise is resolved, it seems not worth the effort. I was before I read this considering making promiseWithValue return a subclass that has no queue logic, but having read this, and considering the potential for new bugs with new code, I don't think it is worth it.\nThanks again.\n. Yeah I\u2019d like to do this, several times I've tried. I have yet to add a solution that doesn't involve too much of an attack on the codebase. But I will, as soon as I can figure out how. PRs welcome.\n. Hmm I'm upset I didn't detect this myself. Thanks. Something is up with my testing.\n. Cherry picked: 89fe9d7541b93adca4a5d8d301a086a5282dc442\n. I force pushed 0.9.7.2 so this commit is included.\n. I pod trunk pushd 0.9.7.3 as I tested and CocoaPods doesn't update with a force push, which is fair. So you can pod update any projects you have now and it'll work.\n. \ud83d\udc4d\n. Agreed.\n. Merged: cbcbd9bbfefee2275f6204c7d82fe1fb99435870\n. Thanks \ud83d\udc4d\n. Yeah it's a bug in Xcode 6, I talked to the tools lab. I'll push a fix anyway.\n. Fixed: 8dff8c6dbc7c1977ba1e76ea8054c7c24fc66c5c (pod updated to 0.9.7.5)\n. @stormluke I am rewriting it in Swift currently. Not sure what the result will be yet.\n. The CoreLocation category has a delegate type implementation. The overview is to create a new object that implements the delegate protocol and fulfills or rejects the promise as a result.\nMost likely you will also need to use pmk_reference as well because the delegate implementing object will otherwise be released because typically the delegate property of the asynchronous thing has assign semantics.\n. Closing due to lack of response.\n. IMO, -promise: is the right choice for such customization. Building the NSMutableURLRequest by hand leads to more readable code.\nHowever, in such cases encoding the parameters is tricky, so probably we should offer a variety of -promise:parameters:encoding type helpers.\n. I pushed the fixes to +Social separately. Thanks for identifying this, but I couldn't cherry-pick your commit due to the copious whitespace changes. I dislike the 2-space spacing also, but it is how they were submitted.\n. I have split out the HTTP processing parts into a new library: OMGHTTPURLRQ: PromiseKit uses it internally.\nThus, though it is not as convenient, it is now easy to construct queries that can have modified timeouts and cache policies.\neg:\nobjc\nNSMutableURLRequest *rq = [OMGHTTPURLRQ POST:url:parameters];\nrq.cachePolicy = \u2026;\n[NSURLConnection promise:rq].then(^{\u2026});\n. True, it's not the current master, but it is the current 1.0 tag (so it should be fine I believe). I'll update when I release a new OMGHTTPURLRQ later this week.\nI decided that the multipart method should support multiple files since that's the point. So adjusted it with the very block-y method.\n. I guess I should include instructions for installation without CocoaPods really.\n. This was a very bad bug, sorry for it, and thanks for the report. Will push a pod update shortly.\n. @mccannmax can you show the then from your example that didn\u2019t work? I will attempt to reproduce your complaint. As afaict what you showed should work.\n. OK, yeah this makes sense. -init is not valid. I will make it throw.\nEdit: or perhaps just initialize it as a rejected promise.\n. In fact, this is expected behavior here. You return a promise that cannot be resolved. No then/finally/catch handlers will ever be called. The promise is never resolved.\nI will still make it throw, as your confusion is understandable.\n. This is great news! I'm super glad you're working on it.\nYour implementation is thorough and I appreciate the decisions you have made and that you were consistent with them.\nI agree with you that then-ing the Bool is unnecessary. My experience with promises is that you may as well then something (provided that something could be useful, the bool is wholly redundant) so indeed, I would then the object/s. This is not always needed, but in the occasions where you don't have access to the original objects for some reason (e.g. the promise has been passed up an abstraction layer) being able to get the objects out again is very useful.\nI look forward to you considering it complete. As soon as there is a pod, I'll link to it in the docs.\n. Really great :+1: I'll add notes to the promisekit.org docs. Thanks for the work.\n. I notice you GPL'd the code. isn't this problematic? Since you can't effectively release apps into the app store under the GPL, as I understand it.\n. Great. Thanks.\n. Yes, and I'm sure contribution is welcome. See #45.\n. Thanks for this.\n1. Can RevMob be a separate pod? I don't want another Homebrew: I would like PromiseKit to have clear divisions. The pod itself is PMKPromise + optional categories for the asynchronous parts of the SDK that Apple provides.\n2. We should really clean up this PR. I can provide the git commands.\n. So, this will cherry-pick the bits we want onto a new branch:\nsh\ngit tag tmp\ngit checkout -b promiseSegue\ngit cherry-pick 355d135d665d1fbaf082c31c142470fa4bc0c15d\ngit cherry-pick ced86e8f4a508fd1ce4bc9e684139e265029efd5\ngit cherry-pick 349e35df6817793355af50abd40d0c427a605057\ngit cherry-pick c2bc83693de8204921c7ecfcb97189febe2915b5\ngit cherry-pick 3e7a31efd715b5a621a4dd2a50bf8cadd9e022b3\ngit cherry-pick 8bbc56febb8f6251d6c388a03be5ffd14ca05ad5\nThen I suggest turning these into a one or two new commits\nsh\ngit reset tmp\ngitx\nGet gitx, I suggest, it makes committing line-by-line or file-by-file easier.\nThen force push back to your master and this PR will be updated.\n. Regarding RevMob, make a new repo on GitHub called: RevMobPromiseKit. Add the .m and the .h to it. Add a RevMob+PromiseKit.podspec file. Fill it in as per the CocoaPods docs (it's not too hard, the examples will help). Ensure your pod spec depends on PromiseKit/base. pod trunk push RevMob+PromiseKit.podspec and you\u2019re done.\n. Thanks! As a heads up, I intend to rename it +AVFoundation, unless you are strongly opposed.\n. Oh, hi Matt!\n. I've experienced this sort of thing, and (so far) it has been because the Promise has gotten deallocated. You have to trick ARC into keeping the promise chain in some manner. Usually I call description or some other innocuous method on whatever owns the root or some other part of the chain that if you look carefully may be being deallocated.\nFailing that you can send me the code in private and I'll try and figure it out for you.\n. I would love to have it hold onto itself. Sadly there is no guarantee that a Promise will ever finish (unlike, eg. NSURLConnection which contracts that the connection\u2019s delegate will receive either succeed or fail).\nI do want a solution here though. As this IMO is rubbish.\nProbably, I can just provide some logging \"Promise about to be deallocated before it has resolved!\" or something.\n. The other idea I am playing around with, is having Promises hold themselves for a reasonable amount of time. I\u2019m not sold on it though as that could lead to excessive retention of memory (I guess), and what is \"reasonable\"?\n. Try holding on to the chain inside some class that has a lifetime greater than the chain (just for debug).\nOtherwise can you say more about the code? How come it only happens after applicationWillEnterForeground?\n. Any luck here?\n. I see, it doesn't happen always? Annoying.\nIf you can email me the whole promise sample, I hopefully will be able to help. mxcl@me.com\n. Sounds legit. In which case @dlg don't start the promise chain with dispatch_promise this will probably fix your crashes.\nI'll urgently fix this, the main ticket being: #33\n. As I recall from your code, you can just start with one of your other promises. Just make sure they aren't necessarily starting with an empty dispatch_promise. In this case it is because you start with an empty dispatch_promise that this race condition happens so often (presumably).\n. > Also, I wrote RKRestKit+PMKPromiseKit (which I plan to open source)\nGreat :+1: Though probably you can drop the prefixes in the pod name.\n\nRestKit I think calls back to its completion block on another thread. Does I need to ensure it calls fulfiller() from the same thread the promise was started from?\n\nNo this is fine. The promises ensure the correct queues get used in then handlers.\n. Closing in leu of #33.\n. Sorry about this, I wasn\u2019t aware that this limitation existed. Serves me right for using features that are brand new.\n. then by default runs on the main thread. Would that work?\nGenerally I didn't expect dispatch_promise to be that often used.\n. Like, really dispatch_promise is not the usual way to start a promise. The documentation just happens to do it that way as the first example.\n. dispatch_promise is just a convenience function that runs the provided block on a specific dispatch_queue and returns a promise. The block executed by +new: executes immediately in the queue new is called in.\n. Usually you would wrap the +new: in another method so the resulting usage reads better. Like this:\n``` objc\nif (![self isOpponentDead])\n    return;\n[self opponentFaint].then(^{\n    NSString text = [NSString stringWithFormat:@\"%@ fainted!\", self.currentOpponent.name];\n    return [self showText:text];\n}).then(^{\n    NSInteger expGain = [self.currentOpponent experienceGainedWhenDefeated];\n    NSDictionary levelInfo = [self.currentPlayer gainExperience:expGain];\n/// if you grew a level OR if you need to delete a move, do all that.\n\nNSString *exp = [NSString stringWithFormat:@\"%@ got %d exp points!\", self.currentPlayerGuy.name, expGain];\nreturn [self showText:exp];\n\n}).then(^{\n    if (levelInfo == nil) {\n        [self opponentSendOutNext].then(^(NSNumber didSendOut){\n            if (!didSendOut.boolValue) {\n                [self opponentLosingSequence];\n            } else {\n                [self emptyMoveQueue];\n                [self showMainMenu];\n            }\n        });\n    } else {\n        NSString lvlUp = [NSString stringWithFormat:@\"%@ grew to level %d!\", self.currentPlayerGuy.name, self.currentPlayerGuy.level.integerValue];\n        [self updateLabels:NO];\n        [self showText:lvlUp].then(^{\n            //etc.\n        });\n    }\n});\n``\n. Agreed, PR welcome. Otherwise I'm sure I will eventually get to it.\n. Though personally I have never needed them, I'm sure they are valid.\n. Added by 3e48ec95c9e6449014340660690baccd409fd2bb\n. True, thanks.\n. Sorry, please explain this pull request.\n. I think I understand. You want to unleash Zalgo. So we can't do this inthenbut I am happy to accept a patch that adds a new function calledthenUnleashZalgothat isthenbut executed immediately if it can be executed immediately.\n. Zalgo is an edge case, but it turns up. However as long as you are sure it can't bite you, it's fine. In your case, you know it's fine, so a method that unleashes zalgo is fine IMO. It just has to be labeled as such so other people reading the code see it.\n. This is a swift compiler issue. You will have to specify the return type in the then for the compiler to find the catch (for some reason). Hopefully it will be fixed. In this case{ (number: Int)->Void inshould do the trick.\n. The README example is what _should_ work. I had what worked originally but don't want to have to edit it every time a new beta comes out. I'll fix it again if necessary at 1.0. I should have marked the code with that caveat, sorry.\n. I see the problem, will fix.\n. I\u2019m having trouble fixing it. It may have to wait for the language to stabilize. For now a workaround is to notcatchoff athenthat returnsVoid.\n. If you \u2318 clickVoidyou will see thatVoidis in fact a typealias for()`, ie. an empty tuple.\n. Beta 5 can finds catch, but it finds multiple variants, so you have to tell it exactly which one you want. Which sucks. So I\u2019ll leave this bug open. As yet I cannot figure out a solution.\nobjc\nlet catch = p3.catch as (dispatch_queue_t, (err:NSError)->())->()\ncatch(dispatch_get_global_queue(0, 0)) { err in\n    // k\n}\n. I have filed https://devforums.apple.com/thread/240380\nedit: https://devforums.apple.com/thread/240877\n. Nice workaround. And yes it isn't a compiler issue. That was just my initial suspicion.\nI hope that Swift provides a generic specialization that allows us to specify any T just not Void. That will fix the ambiguity.\nUntil then I will probably have to provide a different name for this ambiguous terminating catch.\nI'll fix this in the near future, since Swift is going 1.0 on the 17th.\n. Until Swift supports the ability to specify that a generic specialization can't be Void. We can\u2019t fix this. This best I can do (AFAICT) is to provide a terminating catch with a different name, but that won't fix this bug, it'll just make it possible to work around it.\n. Thanks @coppercash, I will check this out.\nCurrently I am experimenting with returning a different class for Void cases (Pr0mise).\n. I think my solution will be that catch always terminates a chain and I will introduce recover as a catch that can recover rejected chains.\nHaving experimented, I believe this will make the framework easier to use, which is my primary goal with open source in general.\n. 0 is 1.\nHonestly I can't remember exactly why catch(body:(NSError) -> Void) -> Void exists. I don't think I made it without consideration, though that consideration may have been due to compiler bugs that are fixed now.\nI've been waiting on a version of Swift that has better handling for generics. Sadly 1.2 is not it. So Swift PromiseKit is still not great and will not be great for a while to come.\nPossibly the solution is to make a -then:(^(Id))block method on objc promiseKit and to push that for now. Currently using objc PromiseKit in swift is painful because all the then methods take id as the parameter (to allow variable parameter blocks to passed).\nAs a summary, the main pain points using Swift PromiseKit right now are that the compiler cannot figure out which variant of catch and then to use in many common scenarios.\nI have a solution to this problem where catch is always terminating and a recover function is used for cases where you would like to try and recover from errors, and I quite like it actually. But it doesn't solve all problems so I've been hoping Swift will improve so I can then work against a better compiler.\n. I tend to agree, though 1.2 still doesn't fix this, so I am developing a work around for 2.0.\n. swift\nlet _: () = p.then { _ -> Void in\n      println(\" I made it! \")\n}.catch(body: onError)\nis enough.\n. I've pushed the 2.0 branch which solves this problem by introducing a new function recover and making catch always terminating.\n. Seems like bridge_unretained is the one-liner fix.\n. Great, thank you.\nAlso good job, you did all the extra bits that most PRs forget (podspec, umbrella header, etc.)\nI also approve of the mainThread assert. That's a good library addition. Though I wonder if instead we should reject the promise? (To be clear I am on the fence about this change, so have opened it for discussion).\n. Sounds good to me. If you want to push, I'll wait. Otherwise I'll merge and do it myself. No problem either way.\n. Yes you can't return a PMKManifold, you can only fulfill with it (the docs imply this).\nProbably it should though, since you expected it.\nProbably don\u2019t use dispatch_promise over +new:, there are known race conditions bugs. It was not meant to be the normal way to create a new promise, though I agree, it is nicer. So maybe I should just rethink it.\nThe bugs should be fixed by the weekend anyway.\n. Oh! Whoops. Well I opened a new ticket to make this possible anyway.\nI'm currently doing a big docs update, so will ensure I correct this.\n. Added PUT/DELETE to OMGHTTPURLRQ: https://github.com/mxcl/OMGHTTPURLRQ/commit/ab81123726bc2ad174dac28964fcde64ceaa8059\n. Thanks so much, you've made a very important contribution to the project.\n. Getting a confusing crash in one of my apps now:\n\nIt's a promise via a UIViewController -promiseViewController:animated:completion: and the promise is particular is not resolved. When the ViewController is dismissed, this crash occurs. I am tracing it but am stumped currently.\nIt appears that  _handlers is nil (even though the promise is not resolved, so it shouldn't be nil) and then the destructor is releasing it anyway. Which makes no sense, possibly this would behave differently if not compiled debug.\n. I think the patch has exposed an existing bug in the +UIKit category where the Promise is not retained. So I'll give that a look.\n. According to the Promise/A+ spec, this is the correct behavior.\nHowever, I am inclined to agree with you here. Though we should give it some thought.\n. I'm not too fussed about not doing what Promises/A+ says (when it makes sense). A+ is mostly so Javascript implementations can interoperate, and in our world, that's not important.\nOf course there is something to be said for doing what people will expect when they have come from other implementations.\n. I'm going back and forth on this.\nWhile this feels like propagation makes sense:\nobj\nmyPromise.catch(^(id err){\n    NSLog(@\"%@\", err);\n}).then(^(id o){\n    // should we run this or what?\n})\nDoes this?\nobj\nmyPromise.catch(^(id err){\n    [UIAlertView error:err];\n}).then(^(id o){\n    // should we run this or what?\n})\nI'm leaning towards not changing anything based on the above. Really the log is more like a tap, you just wanted to log the error for debugging (and probably we should add a method for that). But maybe you can provide some other examples.\n. Closing at this time. Can be reopened if there is more discussion.\nIf we imagine this:\nobjc\n@try {\n    @try {\n        @throw @1;\n    } @catch (id e) {\n         // must throw again to reach next catch\n    }\n    // executes\n} @catch (id e) {\n}\nNot that this is an exact analogy. You can\u2019t chain @try.\n. > Is this achievable with PromiseKit today?\nYes, and your code will work how you expect. The promise from the catch will be fulfilled with nil in the cancelation case.\n. Thanks, I just pushed the target fix (7ad527f5d71f52c05a8231741abc2b684b279cc1) and the deprecations are deliberate I'm afraid so I can't remove them.\n. Sorry your contributions weren't merged, I literally pushed the same fix just before I saw the ticket.\n. It is not possible to fulfill a promise with nothing per the definition of the possible states a promise can exist in. Typically, we pass nil when there is no value of note to fulfill. Typically users of your promises will understand nil to mean nothing.\n. Don't forget all parameters in then are optional. So:\nobjc\n[PMKPromise new:^(id fulfill, id reject){\n    fulfill(nil);\n}].then(^{\n    // then block has no params\n});\nIs fine.\n. Presuming satiated.\n. np, I understand, I'm just book keeping. I'll update the promisekit.org docs to refer to this too.\n. I'd say, yes, it should handle this and this is a bug. Let me look into it.\n. Well, this isn't strictly a header only response. It claims the response length is 1 and the content is JSON. PromiseKit reads that and tries to decode JSON from the 1 byte response and fails, so fails the response.\nNot sure what to do here.\n. For now you can do:\nobjc\n- (PMKPromise *)myPromise:(id)args {\n    id rq = [OMGHTTPURLRQ POST:url:args];\n    id q = ;\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject){\n        [NSURLConnection sendAsynchronousRequest:rq queue:q completionHandler:^(id rsp, id data, NSError *urlError) {\n            if (urlError) {\n                reject(urlError)\n            } else {\n                fulfill(nil);\n            }\n        }];\n    }];\n}\n. You'll need to #import <OMGHTTPURLRQ.h> too. That will work as PromiseKit depends on it.\n. Closing as I believe the issue is the web-server\u2019s response is invalid.\n. Turns out this is a common Rails work around. So I have hard-coded detection in v0.9.14.3 that will allow it.\nLet me know if it works.\n. Does it not say what requirement it cannot satisfy?\n. What CocoaPods command are you running to generate this error? More information please.\n. Without a repo update you cannot get the new PromiseKit, hence the error.\n. Thanks, I removed this check because the tests passed. I have now added a test for this so I don't do it again.\n. How are you importing PromiseKit in your Podfile? How are you importing PromiseKit in your source files? Can you provide the specific line that errors?\nI have code that uses +when: so I believe this error is a side effect of something else.\n. I\u2019d rather wait until the Swift compiler can handle this without hacks. Unless there is urgency?\n. Unless it's not a hack? I'm not familiar with autoclosure but remember reading about this as a way around the fact that enums with generics seem to crash the compiler.\n. Thanks! I'm happy to merge this. Every single beta I've tried to make State into State<T> and made a small cry every time it continued to not compile. x\n. Why are you getting this error? It shouldn't be compiled separately. It is imported into the file that uses it directly.\n. To ask more specifically, are you not using CocoaPods?\n. In which case, don\u2019t compile NSMethodSignatureForBlock.m.\n. Don\u2019t feel bad, it's not simple, but I didn't design PromiseKit for non-pod situations.\nI have updated the docs to recommend the CocoaPods-Packager for generating a static lib, should you want that though.\n. Presumably you can just lib up PK and import OMG.h without lib'ing it. It should work since the symbols are there.\n. > Promise.resolve(x:T) -> Promise which creates a resolved promise with the value x. Today this is done with Promise(x) which I believe is more ambiguous.\nCurrently example usage would be e.g. Promise(value: 1), this is no good?\n\nPromise.reject(e:NSError) -> Promise which creates a rejected promise with the reason e\n\nSimilarly example usage would be: Promise<Int>(error: e)\n\nPromise.all(a:Promise,b:Promise,c:Promise) -> Promise<(A,B,C)> and similarly overloads for 1 to 8 arguments, creates a promise that fulfills when they all fulfill or rejects when one rejects similarly to JavaScript's Promise.all, since Swift has no macros and arrays are homogenically typed this is a lot of repetition but very useful.\n\nPlanned. The reason variants of all are not there yet are due to compiler bugs. The compiler crashed every which way I wrote them so far. So I'm waiting on the next beta.\nRegarding the map, can you provide a usage example? I think I need to see it to understand it.\n. I plan to generate something like that from the headers and put it here http://promisekit.org/api/ which already has some stuff.\n. POST is easy once the Swift library uses OMGHTTPURLRQ, but that depends on CocoaPods supporting Swift.\nI'm not sure I see the point in map. It seems convoluted, where this:\nswift\nPromise.when([1,2,3,17].map { \n     NSURLConnection.GET(\"http://api?page=\\($0)\") \n }).then { (pages:[String]) in \n      // process all the pages downloaded as strings\n }\nInvolves more nesting, but seems clearer to read to me. A map for promises seems to be pushing what map means a little far, conceptually, to me.\n. I could import OMGHTTPURLRQ manually, but was not keen to do that, I'm waiting on the CocoaPods team to finish Swift integration.\nYou can do that, just import OMGHTTPURLRQ (4 files) and write a small Promise for POST:\nswift\nfunc POST(url: String, params: NSDictionary) {\n    let rq = OMGHTTPURLRQ.POST(url, params)\n    return NSURLCONNECTION.promise(rq)\n}\n. I believe a when for two promises was committed a few weeks ago. At least, my local check out has it.\n. I'm still unable to complete the Swift portion due to SourceKit crashes and compiler issues.\n. I closed it with a commit that fixed the leak. You can see the commit above the close marker. Thanks for the report and sorry for the bug.\n. Actually, this is not fixed. dispatch_release is forbidden in an ARC environment. My bad, I didn't test the fix, I just assumed it would work.\nSo I'm confused. ARC should deallocate the dispatch_queue_t.\n. It appears this behavior is because CocoaPods is adding -DOS_OBJECT_USE_OBJC=0 to the build flags, I'll figure it out.\n. Solved 3e22555010a64e9d4d400e7d7b2789d1b69b4240\n. I always push fixes to CocoaPods ASAP. So this particular fix is indeed live.\n. Seems suspicious that Xcode can't find UIKit headers. Right?\nWorks for me anyway, so I'm at a loss.\n. If I have any hope of fixing this, please provide as much information as possible. For example, what is your pod line? What is your iOS deployment target? What Xcode are your building with? What is your OS X version? etc.\n. Yes sounds likely. Let me check that out.\n. pod update should give you 0.9.15.3, and it should work now.\n. Sorry for the issue. It was a stupid mistake on my behalf. Thanks for the report.\n. I agree with the bug, though not the PR. IMO if people provide NSNull as a fulfillment, then it should remain NSNull. I think I know how to solve it elegantly though. One moment.\n. FFR this will happen whenever clang cannot infer the return type for a block due to there being multiple return types and is not unique to PMKManifold. In such cases you can specify the return type of a block as id and fix the error.\nobjc\npromise.then(^id(id obj){\n    if (obj)\n        return PMKManifold(@1, @2);\n    else\n        return someError;\n})\n. 0.9.16.2 will have this fix.\n. Can you show the code?\nNesting news is fine, PromiseKit itself does this all over the place.\nUsually something is being deallocated because you need to keep a strong pointer to that thing around, and if I could see the code I would be able to advise.\n. Thanks, I'll check it out.\n. As an FYI, this:\nobjc\n- (PMKPromise *) find:(Class)modelClass withQuery:(NSDictionary *)query;\n{\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter) {\n        [self.adapter findQuery:modelClass withQuery:query withStore:self]\n        .then(^(NSDictionary *adapterPayload) {\n            dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void){\n                //Background Thread\n                // FIXME: Should used a shared Serializer, etc.\n                SLSerializer *serializer = [[SLSerializer alloc] init];\n                // Extract from Payload\n                NSArray *extractedPayload = [serializer extractArray:modelClass withPayload:adapterPayload withStore:self];\n                dispatch_async(dispatch_get_main_queue(), ^(void){\n                    //Run UI Updates\n                    [self pushMany:modelClass withData:extractedPayload]\n                    .then(^(NSArray *records) {\n                        fulfiller(records);\n                    })\n                    .catch(rejecter);\n                });\n            });\n        })\n        .catch(rejecter);\n    }];\n}\nCould be simpler:\n``` objc\n- (PMKPromise ) find:(Class)modelClass withQuery:(NSDictionary )query;\n{\n    id q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\nreturn [self.adapter findQuery:modelClass withQuery:query withStore:self].thenOn(q, ^(NSDictionary *adapterPayload) {\n    SLSerializer *serializer = [[SLSerializer alloc] init];\n    NSArray *extractedPayload = [serializer extractArray:modelClass withPayload:adapterPayload withStore:self];\n    return [self pushMany:modelClass withData:extractedPayload];\n});\n\n}\n```\nYou don't have to do any GCD with promises, just specify what queue you want in the continuation handlers.\n. Also there's an AFNetworking+PromiseKit pod now: https://github.com/csotiriou/AFNetworking-PromiseKit in case that is useful.\n. This:\n``` objc\n- (PMKPromise ) push:(Class)modelClass withData:(NSDictionary )datum\n{\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter) {\n    NSLog(@\"push: %@\",datum);\n    SLNid nid = (NSString *) datum[@\"nid\"];\n\n    [PMKPromise when:@[\n                       [self record:modelClass forId:nid],\n                       [self normalizeRelationships:modelClass withData:datum withStore:self]\n                       ]\n     ]\n    .then(^(NSArray *results) {\n        SLModel *record = results[0];\n        NSDictionary *newDatum = results[1];\n        NSLog(@\"record: %@\", record);\n        NSLog(@\"post normalizeRelationships datum: %@\", newDatum);\n\n        //\n        [record setupData:newDatum];\n        NSLog(@\"Pushed record: %@\", record);\n\n        fulfiller(record);\n\n    })\n    .catch(rejecter);\n}];\n\n}\n```\nCould be:\n``` objc\n- (PMKPromise ) push:(Class)modelClass withData:(NSDictionary )datum\n{\n    NSLog(@\"push: %@\",datum);\n    SLNid nid = (NSString *) datum[@\"nid\"];\nreturn [PMKPromise when:@[\n                   [self record:modelClass forId:nid],\n                   [self normalizeRelationships:modelClass withData:datum withStore:self]\n                   ]\n ]\n.then(^(NSArray *results) {\n    SLModel *record = results[0];\n    NSDictionary *newDatum = results[1];\n    NSLog(@\"record: %@\", record);\n    NSLog(@\"post normalizeRelationships datum: %@\", newDatum);\n\n    //\n    [record setupData:newDatum];\n    NSLog(@\"Pushed record: %@\", record);\n\n    return record; \n});\n\n}\n```\nThere's no reason to nest things that return promises in a +new:.\nObviously it shouldn\u2019t crash either way.\n. A pleasure to help as it enables me to reconsider the documentation so people are guided towards the more condensed versions in future.\n. I have trouble running the tests so I can reproduce, is there some step I missed?\n\n. k np,, I'll look into it later today.\n. Thanks for the assistance! I will really look at this soon. I've had a bunch of urgent client work that cannot wait sadly.\n. I still cannot reproduce with your project:\nTest Case '-[Streamlyne_iOS_SDKTests testPushAssetWithRelationships]' started.\n2014-08-29 10:18:51.758 xctest[15678:3231337] setUp\n2014-08-29 10:18:51.760 xctest[15678:3231362] *** Assertion failure in +[NSManagedObjectContext MR_defaultContext], /Users/mxcl/scratch/Cocoa-SDK/Pods/MagicalRecord/MagicalRecord/Categories/NSManagedObjectContext/NSManagedObjectContext+MagicalRecord.m:60\n2014-08-29 10:18:51.761 xctest[15678:3231362] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Default Context is nil! Did you forget to initialize the Core Data Stack?'\nIs there some setup step I have missed?\n. How am I meant to reproduce this issue? I thought running the test cases would do it, but you just showed that they all pass.\n. K, if I force an anti-ARC retain on the block the crash doesn't happen. So I'm actually thinking we are exposing some bug in ARC here.\n. Seems relevant: http://stackoverflow.com/questions/12061756/blocks-and-arc-copy-or-crash-with-release-build-caused-by-optimization-level\n. 0.9.16.3 pushed to CocoaPods.\n. np. I should report this bug to Apple really. I'm pretty sure ARC is prematurely releasing the block based on my reading the spec.\n. Indeed, that exception should be caught, provided it is thrown within +new:.\nHere's the code:https://github.com/mxcl/PromiseKit/blob/master/objc/PMKPromise.m#L423-L427\nI really can't see how it is not being caught. Does the backtrace prove it is thrown within +new:? Can you provide the backtrace?\n. Please see this new test I just added that confirms that throwing an NSInvalidArgumentException inside +new: is caught.\n. To be clear, exceptions thrown outside of PromiseKit\u2019s handlers cannot be caught. I'm sorry if the documentation implied this to you, but I thought people would understand that it is impossible for any component to catch exceptions thrown where it is impossible for that component to stick a @try, @catch handler.\n. Possibly a bug in the runtime: http://openradar.appspot.com/8081169\n. Closing since I can\u2019t fix bugs in the runtime.\n. Please state PromiseKit version.\nUpdate: indeed unhandled errors should be logged. But only since recent versions of PromiseKit, so I need to know what version you are using in order to know if it is a bug or not.\n. Really? If so keep an eye on it, I wouldn't have thought that would fix it, so possibly it's some other side effect.\n. I've found an example where using +when which would cause errors to get silently absorbed. So I'll fix that.\n. How recent is PromiseKit in this app? As we fixed a crash issue in #77 recently and the pod is updated for that.\nHowever it looks to me like the copy is failing. Which implies the block has already been deallocated.\nI need to report this to Apple, as it seems to me to be an ARC bug. It's the third such issue we've had and my hacks are not fixing it.\n. I pushed a new pod today with some more attempts to do additional copies of the blocks. Can you try that one?\n. I hope so. I fear this is (genuinely) an ARC bug so the work arounds I applied may not suffice. Unfortunately I cannot produce a good enough test case to report the bug to Apple. Will close in a few weeks.\n. I\u2019m happy to accept this PR.\n. To contradict myself, I\u2019ve been thinking about this for a few hours now and I cannot think of a good usecase for this that isn\u2019t equally solved by just doing the the initial thing before the promise is used.\nUsually I would just add such a thing anyway as it complements finally but I think in fact it could be harmful to the API by implying that you should put such things in the initially block, and that is not the case.\nSo unless you can provide a usecase, I won\u2019t accept this. Thanks though, it was good to think about.\n. Thanks, and good thinking.\n. The objective C part of PromiseKit does not work in Swift due to all the methods taking id.\nIf you want to use PromiseKit with Swift (currently) you must use the separate PromiseKit.framework generated from the separate swift directory's xcodeproj.\nThe swift version does not have Cloudkit support yet.\nI have plans to combine the two projects, but currently I don't know how to go about it due to various issues.\n. Like I am confused a little here. Can you describe how you are using PromiseKit in your Swift project?\n. Yes, Swift is not 100% with the objc version currently, mainly because of all the tricks the objc version does which makes using it directly in Swift tricky.\nHence the Swift version, it just doesn't have 100% feature parity (e.g. CloudKit promises).\nI'll close this, but rest-assured, proper Swift support is urgent for me as I need it in just about every app I am currently working on.\nI'm not even sure it is possible to use the objc version in Swift due to the NSMethodSignatureForBlock stuff we use and the fact that Swift and objc blocks are (as I understand it) not 100% compatible.\n. swift\nalert.promise().then { index->() in\n}\nYour block must have some parameters in Swift at least currently.\n. Sorry for the delay, I've been on vacation.\n. @turbokuzmich can you post code? I can probably suggest the fix to persuade the Swift compiler to like it.\n. Thanks, sorry for the delay, I am on vacation.\n. Thanks, sorry for the delay, I'm on vacation.\n. This happens in the objc variant and will happen in the Swift variant once I have unified them. Thanks.\n.  Nice idea, new ticket please.\n. This feature now added to the Swift variant.\n. Can you PR it? Since you get the crash I'd feel better if you supplied a working (for you) fix. Happy with your suggested fix.\n. Yeah I see. I think we can work around this by using a when behind the scenes and unwrapping it after.\nFor now you may as well use a when. Will leave open.\n. Sorry for the delay in responding. I am on vacation until Saturday.\n. .all is the same as .when, PromiseKit has both.\n. I am not going to do this, because our documentation explicitly shows use of PMKManifold to pass a promise to another handler.\nI feel when is indicated to be the way to do this. PMKManifold is a convenience tool, and thus should remain flexible, passing promises is a possibility with PMKManifold. If one wants to split out the then you can do it, it's just not as pretty, but being less pretty is fine for library code, which is probably where this is wanted.\n. Just pushing it now.\n. Pushed, sorry for the delay, I had trouble with the CocoaPods linter.\n. Thanks, and sorry for the 10.7 problems. I'm surprised Travis didn't catch it, so clearly there's aspects of deployment targets vs. actually deploying these things I don't understand.\n. Pushing 0.9.17.1 to CocoaPods now. Glad you like :)\n. Pushed, sorry for the delay. I had trouble with the CocoaPods linter.\n. Wow, hairy.\n. Specifically, what is wrong (I believe 4 dots versioning is semantic versioning) and why do you have to remove it and re-add it?\n. I use PromiseKit all over the place and have not yet seen your issue.\nIn future however I will stick to 3 versions then, since indeed, the document above seems to suggest only three is valid.\n. Though seems like a bug in CocoaPods to me that it would have two versions installed and should probably be reported.\n. The log message is redundant, but this is correct behavior. If any of the promises passed to when are rejected then the promise returned from when is rejected. The other promises cannot be canceled (due to API limitations) so will continue to resolve, when they resolve they will cause the above log message because they will attempt to resolve the promise returned from when. This cannot be easily prevented.\nI'll leave this open though as I would like to prevent it.\n. Yes that would suffice. Though the then route also needs to be catered to.\nWe could just drop the warning altogether. Though I feel in general it has value.\n. That would be great, thanks.\n. Is this sufficient?\nPromise1: rejects the when promise\nPromsie2: succeeds, attempts to fulfill the already rejected promise\nResult: message that the promise is already rejected is logged.\n. Hah, yes of course. Thanks.\n. You\u2019ll have to do this:\nobjc\np.then{ _ -> Promise<Bool> in\n    if foo {\n        return Promise(value: true)\n    } else {\n        return Promise(error: NSError(domain: \"error\", code: 100, userInfo: nil))\n    }\n}\nNot ideal, but cannot be helped. If Swift ever supports exceptions, then this kind of thing will be more pleasant.\n. No, nowadays you throw. See our \u201cGetting Started\u201d documentation for more details.. You have no return in your then. . Your then returns void. There is not a version of then that allows this. You must return a promise from then. . Thanks! I appreciate that. Also your guard body doesn't ensure an \u201cexit\u201d.\n}.then { confirmed -> Void in\n    guard confirmed else { try throwError() }\n    API.sendInvite(to: user)\n}. Sounds sensible. Though I think the implementation could probably be tweaked.\n. Seems like [CLLocationManager promiseWithAccuracy:20].then(^(CLLocation *, NSArray *){}) would be a good convenience version. If you still want the block version then I suggest the name filteredPromiseUsingBlock: since that is named similarly to various Apple selectors on NSArray etc.\n. Added +until.\n. Seems legit.\nAlso, you may as well just return the error rather than wrapping it in a promise.\n. The Travis failure can be ignored.\n. Thanks, but I would like to make the changes, and add safety. I have a reverted patch for 6.1 already. I'm waiting for the final release to test it.\n. The already resolved message is because you don't have an else and as @dbachrach says, you end up fulfilling the promise twice the second time you call your loadAvatar method, hence it is already resolved.\nobjc\n- (PMKPromise *)loadAvatar;\n{\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject){\n        if (self.avatar) {\n            fulfill(self.avatar);\n        } else {\n            NSData *imageData = [[NSData alloc]\n                              initWithContentsOfURL: self.avatarUrl];\n            self.avatar = [UIImage imageWithData: imageData];\n            fulfill(self.avatar);\n        }\n    }];\n}\n. Don't feel bad! The style of promises is foreign to typical Objective-C techniques.\n. I\u2019m sorry but I haven\u2019t time. If you have some specific code then we can talk through a fix.\n. Thanks, and it appears the tests are broken since some update to Xcode. Probably 6.1 as I have run them against 6.0. I will fix that.\nThere are no specific contributing notes because all contribution is welcome. Thank you!\n. Hmm, I can't get the tests to not run again. The first time they did what you got, now I get all the tests to run whenever I run ./tests.\n. I release a new pod every time there's an important fix, or after I have written new significant functionality that is important. So, I'll pushing a new pod shortly.\n. Indeed, it should be like this:\nsh\n./tests \nTests\n  PASS test_01_resolve (0.053s)\n  [snip]\n  PASS test_67_until_failure (0.206s)\nTest Suite 'Tests' passed at 2014-11-18 16:38:23 +0000.\nExecuted 67 tests, with 0 failures (0 unexpected) in 7.373 (7.385) seconds\nTest Suite 'tmp' passed at 2014-11-18 16:38:23 +0000.\nExecuted 67 tests, with 0 failures (0 unexpected) in 7.373 (7.386) seconds\nI'm concerned that it didn't work for me at least once and am going to examine the code for it.\nThe Swift version is good! Though its usage is a little tedious due to limitations in the compiler, but I'm working on a fix to work around that. It's certainly usable for projects and has feature parity with the objc version.\n. There are some limitations where it cannot figure out which then and catch you want, so you have to more specific, and this can result in ugly code. There's a ticket open for it.\n. Pushed 1.0.2 to CocoaPods.\n. As per the documentation, errors are thrown to the next catch handler provided you return promises in your chain:\nswift\np.then{\n  return aPromise\n}.then{ \n  return anotherPromise\n).then {\n  return somePromise.then{\n    return someValue\n  }\n}.catch {\n  // error from any promise\n}\nMore information here: http://promisekit.org if the documentation is not clear, please feel free to open a ticket or submit a pull request.\n. Pushed 1.0.3, thanks!\n. I don\u2019t think that AFNetworking+PromiseKit works with swift PromiseKit.\n. Here\u2019s your example with adjusted comments:\nswift\np.then {\n  // this closure is fired by p, receiving p\u2019s value as $0\n  return aPromise\n}.then{\n  // this closure is fired by aPromise receiving aPromise\u2019s value as $0\n  return anotherPromise\n}.then {\n  // this closure is fired by p(?), receiving anotherPromise\u2019s value as $0\n  return somePromise.then {\n     // this closure is fired by somePromise, receiving somePromise\u2019s value as $0\n     return someValue\n  }\n}.catch {\n  // This closure will be called if *any* promise above becomes rejected\n  // FORSERIOUS\n}\n. Which CocoaPods version? I don\u2019t get this warning.\n. Any chance of more information here? I cannot reproduce.\n. Thanks, I'll ensure I'm on 0.35.0 and investigate.\n. It's a bug in CocoaPods, multiple subspecs request the same headers and it adds them multiple times. Can't fix! Thanks.\n. There is no catch that returns Void and a Promise. This is because such a catch must return something in order for the chain to make sense (think about it as, a catch in the middle is a catch that recovers from errors, so it must return a recovery). Put the catch at the end instead, errors propagate, so the error will skip the then that is in-between and go straight to the end.\nYou may need to do the following however as the compiler can't decide which catch to use (there's a ticket for this):\nswift\nlet _:() = api.getEvents(\u2026).then { events->Void in\n    //\n}.catch { error->Void in\n    //\n}\nThe workaround is the let _:() = at the beginning, which is indeed very ugly, but currently required and hard to know exactly how to fix since Swift is still so in flux, source-wise.\n. Indeed, you need to add AssetsLibrary to the project\u2019s frameworks at this point.\nI\u2019m trying to figure out a better fix, since this sucks.\nIdeally you wouldn't need to link to AssetsLibrary unless you used that feature of PromiseKit.\n. I guess this is just how frameworks work, and I either need to split the PromiseKit swift framework in two or check for the symbols at runtime and load the assets library on demand.\nSince Swift has proper modules, it seems a shame that this cannot happen automatically.\n. You don't need to link in PromiseKit.xcodeproj, you need to add the framework to your app. PromiseKit already links to the asset library, the problem is your app doesn't and that is where the linking fails.\n. The new PromiseKit/Swift pod imports AssetsLibrary. However I'd rather load it at runtime on demand. Since it is used only to provide the raw NSData for the image, if the user asks for that version of the Promise, so mostly it is a waste to load. So I'll leave this ticket open with that goal in mind.\n. Well, this isn't to do with PromiseKit then. We don\u2019t do anything with CoreAudio. You should be able to fix it however by making your app target link to CoreAudio.\n. There is nothing yet, but it would be useful, yes. PR welcome, or I'll get to it eventually.\n. I'm not sure how to implement this without causing deadlock if any part of the promise in question needs to use the same thread that wait is called in.\n. I guess RXPromise doesn't try to prevent this either. It\u2019s just that with larger chains (which happens easily with Promises), you can't know if any of them will require the thread you are blocking.\nThe runLoopWait is safer though.\nAnyway, as discussed they are just for debugging. So I guess I can add them with the caveat that you may get a deadlock. And the deadlock may not be reproducible.\n. Added +hang:, works via a runloop. I decided not to add the other, as this should be enough for your usage and the few times I've needed it too.\n. Great, thanks! And the subspec additions are done precisely right. Will merge once manifold order has been reversed. You can just push a new commit to this branch and the PR will update.\n. Happy to receive recommendations for alternative ways of phrasing this.\n. then is highlighted to indicate that it is a method, so I don\u2019t really understand why you didn't realize that the then part was a method and thus not some odd english phrase.\n. I guess we can just say \"call then on your Promise objects\" thus fulfilling the adage that any sufficiently popular open source project loses all personality.\n. I can't even run the tests in Xcode 6.1.1 (does nothing, no error, no fail, no pass, no log output), so you are my hero.\n. I did fix a memory leak a few weeks ago, you on the latest version?\n. I've confirmed this with a test case, but I can't find any leaks. Instruments isn't much use and some cursory logging suggests everything suspect is being deallocated. I'll keep looking.\n. Actually, when I use Instruments I see that the memory usage stays constant. Xcode's memory meter shows it grow continually.\nGoogling this I see that the Xcode meter is not reliable here since it is showing the malloc engine behavior for the Mac, Instruments is actually showing what memory is persisting, and it shows no leaks.\nHow did you confirm the unbound memory usage you describe? \n. Reference: http://osdir.com/ml/general/2013-12/msg13145.html\n. Docs are in the repo: https://github.com/mxcl/PromiseKit/tree/gh-pages\nI suggest you publish your cookbook (sounds fab) as a separate gh-pages repo, I'll link to it. Then we can collaborate on merging them.\nPsyched to read your stuff!\n. Yes, I like the approach. Can we put it on the main site in a new tab?\n. I was aiming to make something more gentle. Sorry if I didn't succeed.\nI however don't feel your cookbook is more gentle, though I'm happy to have it put somewhere in the documentation.\n. Like by all means, lets work together, submit some PRs to adapt what we have.\n. Dupe of #56. Basically you have to a nasty hack as detailed in that thread for the catch. I have a local \u201cfix\u201d, that I'm still debating where I make two different kinds of catch.\n. swift\nlet _:() = createA(a).then { resultingA -> Void in\n    fulfill(resultingA)\n}.catch {\n    reject(true)\n}\n. Could be expressed thus:\nswift\nfunc createA(a: A) -> Promise<A> {\n    return Promise { fulfill, reject in\n        doCall { error in\n            if !error {\n                fulfill(A())\n            } else {\n                let _:Void = createA(a).then { resultingA -> Void in\n                    fulfill(resultingA)\n                }.catch(reject)\n            }\n        }\n    }\n}\nWhere you just pass the reject directly into the catch.\n. I have a cleaner solution locally, I'm just waiting on a new Xcode release in case it is fixed better.\nGetting impatient for the Xcode release though\u2026 :/\n. Sorry, I've been offline. Reviewing now.\n. I'm tempted to remove the promiseSegue stuff altogether. It's way too hacky and potentially dangerous and I'm not convinced anyone uses it.\nIt was a PR a while ago.\n. Needed? Or closed because not needed?\n. Agreed.\n. I had a look at doing this, but it will require a lot of thorough thought on testing it and I don't feel up to it without a personal immediate need. So we'll leave this here in hope of a PR.\nI've used NSProgress with Promises in #Homescreen app, and it worked well. So this will work well, when done.\n. I'm implementing this and can only hope the NSProgress crashes are fixed. I found similar reports: http://jaanus.com/an-example-on-how-to-use-nsprogress/\nTwo things:\n- I'm not implementing a cancel handler, but perhaps we should one day, the idea of being able to cancel a promise from the outside is considered \u201cwrong\u201d, but practically it probably isn't sensible to worry that some weird library may cancel your when.\n- I'm making it so if one of the input promises is rejected the progress is set to 100%.\nThoughts?\n. ``` swift\nlet progress = NSProgress(totalUnitCount: 1)\nprogress.becomeCurrentWithPendingUnitCount(1)\nwhen(p1, p2, p3, p4).then {\n    //\u2026\n}\n// now use KVO to monitor progress\nprogress.resignCurrent()\n```\n. @russbishop it can be turned off with a compile time conditional. See the commit message.\n. Merged.\n. The underlying OMGHTTPURLRQ supports this. PromiseKit should have a method added, so maybe submit a PR?\nobjc\nNSURLRequest *`rq = [OMGHTTPURLRQ POST:url JSON:jsonDictionary];\nPMKPromise *promise = [NSURLConnection promise:rq];\n. The existing POST requests don't send JSON anyway, they send form url encoded data, with nesting support.\n. I don\u2019t think you can have sub-subspecs, but I'd like to offer the same modularity options for both.\n. @ldiqual good find. I'll merge this but aim to add that with an update.\n. I started adding nesting subspecs, but only as I've needed them. PR welcome! Or I will get round to eventually.\n. You can use them, but the syntax will suck because the objc then returns a block that takes a block. I haven't got any examples to hand, nor time right now to prepare one.\nIdeally we'd create some kind of bridge, but as yet I haven't come up with the code for a good one.\n. This was because it is marked as an embedded framework and they only support iOS 8. So I hope there won't be further issues since I have merged this.\nXcode now warns about the fact.\n. Yes. So either everyone gets a warning, or people must change the targeted SDK. Hmm.\n. You can fix it by setting the deployment target to 8.0. But I don't feel this is ideal. I need to ponder it.\n. @pgherveou not that I know of, but we'd use it if it exists.\n. Agreed. I've almost written something like this many times, I just couldn't decide on a good name.\nthenOnBackground, thenOnBG, etc. something.\n. Even though it is dirty I often do:\nobjc\n[object fetch].thenOn(dispatch_get_global_queue(0, 0), ^(id response) {\n}\nor:\nobjc\nid bgq = dispatch_get_global_queue(0, 0);\n[object fetch].thenOn(bgq, ^(id response) {\n}\n. If we follow Apple\u2019s lead we have: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/instm/NSObject/performSelectorInBackground:withObject:\nThat is: thenInBackground.\nI guess that is best. But yes, I find it longer in letters than I'd like. Which is why it doesn't exist yet. I guess I was waiting for some further inspiration for a short word like then that implied background.\n. PMKError is not for \u201csimplification\u201d it allows reference counting the error consumption so that unhandled errors can be reported.\nHowever indeed, we shouldn't lose the type of the error the user provides. I can look into fixing that.\n. Will push a new PromiseKit to cocoa pods this week.\n. The idea sounds useful.\nI fear we couldn't do it without bumping to v2 though. As there may be code out there that expects NSError and will break if we change it.\n. Actually I guess it could be fine, since it will always be an NSError unless you decide to make it something else for your own purposes.\n. I'm a little nervous about it though. NSError sucks, I've found this whole-heartedly since using Promises for 80% of my code paths, since Promises make it possible to do good error handling, and then you find you are limited by a code, a domain and a dictionary in what you can do next.\nWe could do something really special, with some more thought. This seems like the right direction.\n. I\u2019m interested in supporting some generic error, but I don\u2019t want to make the API more complicated than necessary. I believe APIs should be as flexible as possible, but I also believe they should appear simple. I worry about turning people off PromiseKit because they have to declare every promise as:\nPromise<SomeType, SomeErrorType>(body: \u2026)\nIf we can work around this then I'm cool with it.\nNotably this also makes me not particularly want to support some generic Error protocol since it will make the catch APIs seem strange. If NSError is good enough for the whole of Cocoa, then it will perhaps just have to be good enough for us.\nThinking about it, isn't subclassing NSError enough for the desired usage here?\n. So further to this. Why not just inherit from NSError for your error type?\n. I guess for PMK2 we can have a baser-Promise so you can do this sort of stuff.\nYou are the 1% though.\n. I'll believe when I see it.\n. I didn't expect this, but I was more saying I doubt most developers would demand a custom error type in their apps.\nFor PromiseKit I don't know what to do now, but I'll figure it out as I battle the compiler to make it even compile against Swift 2.\n. Like ErrorType is just an empty protocol as far as I can tell. Empty objects don't carry much error information. I design APIs for less experienced users than you guys that also scale up and are useful to experienced developers so I'm reluctant to make Promise rejectable with nothing.\n. Also notably, the SDK still is entirely NSErrors. Nothing, currently is something else.\nNot that users shouldn't be allowed to use their own errorTypes. But currently I'm not even sure how users are going to use the new error handling in Swift. I'll have to watch all the sessions and then interpolate.\nMaintaining Swift libraries is a constant iteration :/\n. You can do this, it's still hacky, but it is an alternative.\n``` swift\nimport Foundation\nimport PromiseKit\nclass SalesforceObjectFetcher: NSObject {\n// the type of the promise might be different, see fulfill usage to decide\nlet deferred = Promise<SalesforceObject>.defer()\n\ninit() {\n    deferred.promise.finally {\n        println(self)  // here we force a retain on self inside the promise object\n                            // it will be released once processed\n    }\n}\n\nfunc fetch (request: SFRestRequest) -> Promise<SalesforceObject> {\n    SFRestAPI.sharedInstance().send(request, delegate: self)\n    return deferred.promise\n}\n\n}\n//MARK: SFRestDelegate compliance\nextension SalesforceObjectFetcher: SFRestDelegate {\nfunc request(request: SFRestRequest!, didFailLoadWithError error: NSError!) {\n    deferred.reject(error)\n}\n\nfunc request(request: SFRestRequest!, didLoadResponse dataResponse: AnyObject!) {\n    deferred.fulfill(dataResponse as SalesforceObject)\n}\n\nfunc requestDidCancelLoad(request: SFRestRequest!) {\n    let error = NSError(\u2026)  // make a code and domain to represent this error state\n    deferred.reject(error)\n}\n\nfunc requestDidTimeout(request: SFRestRequest!) {\n    let error = NSError(\u2026)\n    deferred.reject(error)\n}\n\n}\n``\n.PMKRetainis better, I didn't suggest it because the suggestion is easier to understand, but if you understand the macros, use them!\n. They were never public API. So they gone. But there's other ways to achieve the same.. I'm cool with this, but I'd prefer a different name. I'll think on it. I'm not sure there is any precedent. Eg. Promises with ES6 have arace, function which is all we don't have, but it is not the same as your contribution.\n. Maybewait?\n. How aboutjoin`?\n. Many thanks, an excellent contribution.\n. np, I rewrote the tests to use XCTestExpectation, so the rebase would have been a PITA. But also I didn't realize you weren't finished, so my bad! All worked out though. The merge is fine IMO.\n. Can I ask for an example use-case for join?\nI've seen people using it instead of when and thus breaking their error handling, which disturbs me, if I understood more about what the requirements were that made this method get added, I could document it better.\n. Well, the other uploads won't abort. PromiseKit cannot cancel anything. That's up to the developer should they want that.\nHowever when does not let you know which succeed. So indeed.\n. I added some more documentation.\nWith hindsight probably join should have rejected the promise still if an error occurs, but still it should wait until all promises are resolved first.\n. Thanks.\n. If the promise is eventually resolved, strong references are fine.\nThe Promise object itself is careful to release everything after it is resolved, so all your callbacks will be released.\nEven if you hold a strong reference to the Promise itself, you can pass strong references into the callbacks. This is because the callback blocks/closures are released once the Promise is resolved.\nSo, as long as the Promise resolves, you're good. All Promises from PMK itself will resolve, so it's just up to you with your own implementations of promises.\n. This \u201cunleashes zalgo\u201d and we should avoid that. I understand the desire for it, but think it should either reside in its own pod, or we can devise some strategy to make this pattern more elegant.\n. I guess calling it dispatch_promise_unleashing_zalgo would suffice for me.\n. Or dispatch_zalgo perhaps.\n. For zalgo reference: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n. Yes I am planning to release some zalgo APIs for Promise libraries to use.\nIMO provided there are tests that prove that zalgo does not go public, this is the sort of efficiency gains libraries should aim for.\nIf the API is named with zalgo in it, then we are at least marking our code as dangerous for future maintainers to note.\nThere are numerous places in PromiseKit itself that could be more efficient.\n. Yes, but AnyObject isn't valid JSON. You can have strings, numbers, bools, arrays or dictionaries of the same. I was kind of waiting on some Pod that does JSON better and would then use that.\nStill, practically, this is what you need in the interim so I guess it should be committed.\n. Sounds good. I'll look into it.\nAnd don't worry about the donation :) I put that there mostly out of interest, in case anyone would ever do it. I do this work for free without qualm: it's fun.\n. Seems like you can add it via the CocoaPods option. Is that enough?\n. Can you provide an example of something you want to emulate?\n. I guess something like Backbone.js is a good example.\n. Closing. I have no time for this really, sorry. A PR would be accepted however.\n. Yes, I've been pondering Carthage support for a couple weeks. I think I can get it working, this ticket will motivate me.\n. Carthage can now import the Swift version of PromiseKit.\n. 1) yes I think this needs deletion\n2) yes, this is a bug in the compiler. UIImagePickerController inherits nav controller and this seems to confuse it. I did find a work around for this personally, but can't recall what I did. I'll try to remember.\n. Yeah, pretty sure my workaround was your workaround. Hopefully this will be fixed with Swift 1.2.\n. I started a branch called swift-1.2 and reached impassable compile issues. I got the attention of the Swift people on Twitter and they agreed that something in Swift itself needs to be fixed, so we'll just have to wait on the next beta I'm afraid.\n. If you want, you can check out the branch and try to find workarounds. I tried to find some, and eventually decided it wasn't going to happen.\n. Compiles with Xcode 6.3 beta2\n. Just pushing to CocoaPods trunk\u2026\n. Sorry I think the push failed, looking into it.\n. Seems pushed now.\n. Yeah I don't know what to do about this. As you can see, it\u2019s compiler errors. Building inside the project itself works, building it manually with xcodebuild works, just not with the Carthage tool itself.\n. I'll pull it together and report it to Carthage.\n. So for the Swift one you should be able to just open PromiseKit.xcodeproj and build the binary by hand. Or! Just drag and drop the xcodeproj into your project and then make sure you link against the to-be-built framework.\n. Try git pull as I just fixed the hardcoded path for my machine. Sorry about that, we assume that Apple would know to make paths relative when we add these things :/\n. This now works for me with 1.3.1. If it doesn't for you, reopen. Thanks.\n. Not sure, I expect it is not universal.\nPMK should work with Carthage now, which will indeed build a universal framework, though they say this is a problem when submitting to the store.\nOtherwise indeed, dragging in the xcodeproj, and doing the same for OMGHTTPURLRQ (unless you remove NSURLConnection+Promise.swift) will be easiest.\n. I believe everything is properly set up for Carthage now. A common reason for this is that your provisioning and certification is not correctly set up and Carthage seems to require this.\nThe other solution is to specify --no-build and Carthage then will just be a source based dependency manager: configure your project to build the dependencies.\n. @pgherveou this is unrelated to this ticket, but a fix has been pushed.\nYou may need to invalidate the Carthage cache as I forcibly moved the 1.5.0 tag. But hopefully it will notice that.\n. Sorry for this, my tests don't test the OS X specific portions, but Travis does. I should fix that.\n. The default promise function already does this:\nhttps://github.com/mxcl/PromiseKit/blob/master/Swift%20Sources/CLLocationManager%2BPromise.swift#L22\n. So I saw where you were coming from and implemented your request and added more spice! Check it out.\n. Sure, that makes sense.\n. I think we just need to make the path not hardcoded to my machine.\nGenerally, the project needs OMGHTTPURLRQ and when I work on it locally I don't want to have to always remember to tweak the framework paths.\n. Fixed, I'll update CocoaPods later today.\n. Seems crazy you would get data, but no NSURLResponse, but the code should handle this now.\n. Thanks.\n. I need more details. How did you install PromiseKit? What Xcode? Can you provide the build errors from the build log in Xcode? Thanks.\nSwift or Objective C? Version of PromiseKit?\n. I'm guessing this is Swift. I've had similar issues, in order to diagnose this specific one I'll need the full log from the \u201creport navigator\u201d.\n. Xcode cannot use it for some reason.\nVerify that you have correctly linked the framework as as embedded library and not just as a linked library.\nIf you provide the full build output I can help more effectively.\n. Try putting OMG ahead of PromiseKit in the target dependencies. Since PMK depends on OMG, that may be the problem. If not, we'll figure it out!\n. Without the build output (click the lines next to the error message) I cannot help.\n. I think I understand what is going on here. As a workaround: remove PromiseKit from the \"target dependencies\" list of for your app target. Build. Add PromiseKit. Build.\nI am trying to determine a proper solution in the mean time.\n. If you update I think I fixed it. Sorry for the trouble.\n. Anything here help? https://www.google.com/search?client=safari&rls=en&q=invalid+bundle+contains+disallowed+file+frameworks&ie=UTF-8&oe=UTF-8\n. Can you show the original code? There may be a bug in PromiseKit here still. It depends if an error escaped a chain somehow.\n. Change the deployment target to iOS 7.0.\nIt'll build, but it won't be a real 8.0 framework so you will have to manually force linkage.\nWe only provide support for PromiseKit with Carthage and CocoaPods. You can use PromiseKit without those tools, but you will have problems like this. This is unfortunate and simply because the iOS 7 to iOS 8 transition has been difficult.\n. This is an error in the documentation. You can\u2019t do this. Just like the error says, fulfill is not declared.\n. Fixed: http://promisekit.org/common-misusage/\n. So it should have been:\nobjc\n- (PMKPromise *)fetchParseAndStore {\n    return [Thing fetch].then(^(id result){\n        return [Thing parse:result];\n    }).then(^(id result){\n        return [Thang store:result];\n    });\n}\n. Yes, this is the kind of situation when you use new: because you must turn something that is not a promise into a promise. However I would do it thusly:\nobjc\n- (PMKPromise *)promiseToDoSomething {\n    return [Thing fetch].then( ^(id result){\n        return [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject){\n            [thirdParty doSomethingInBlock:^(BOOL success, NSError *error){\n                if (error) {\n                    reject(error);\n                } else {\n                    fulfill(nil);\n                }\n            }];\n        });\n    }];\n}\nBecause otherwise any errors from [Thing fetch] may escape the chain.\n. Right now, I don't feel Carthage is ready for this endorsement.\n. To be clear: I love Carthage and want it to succeed, it's just not ready for me to push people at it who don't already know about it.\n. Apologies, I'll look into it.\n. Sorry for the delay. But it's fixed now. 1.4.3 being pushed.\n. Is this for PMKPromise.m? Or for your code in general? Just interested.\n. Where do you use this construct in your own code? I'd only ever thought people would just return a promise, so you wouldn't need it.\n. Closing because I don\u2019t want to encourage people to add these methods (and adding public helper macros would do that) and can\u2019t immediately see why anyone would want to do it outside of PromiseKit when using PromiseKit.\n. If you can fulfill or reject any promise, then any part of your application could fulfill ore reject any promise, which would break encapsulation.\nThe usual pattern instead is a deferred which would look something like this:\nobjc\nPMKDeferred *deferred = [PMKPromise deferred];\n//\u2026\ndeferred.fulfill(obj);\nreturn [deferred promise];\nI provided a Deferred with Swift PromiseKit but not with the objective C version. Mainly because it doesn't make much difference (I guess you disagree), and the Swift one uses a tuple to make it sweeeet.\n``` objc\n@implementation MyWrappedDelegate {\n    PMKFulfiller fulfill;\n    PMKResolver reject;\n}\n\n(PMKPromise *)start {\n    return [PMKPromise new:^(id f, id r){\n        fulfill = f;\n        reject = r;\n    }];\n}\n@end\n```\n\nVersus:\n``` objc\n@implementation MyWrappedDelegate {\n    PMKDeferred deferred;\n}\n\n(PMKPromise *)start {\n    deferred = [PMKPromise deferred];\n    return deferred.promise;\n}\n@end\n```\n\nI consider the extra shock of \u201cyet another class to learn with PromiseKit\u201d not worth it to save two lines of code.\n. Discussion about this welcome though!\n. Sorry, I don\u2019t understand the request. The closest I can get is you want to serially iterate over a series of promise chains one at a time and reject a root promise if any of those reject.\n. Nothing is provided in PromiseKit explicitly to do this, but this will work:\nobjc\n@interface PMKPromise (Chain)\n+ (PMKPromise *)chain:(NSArray *)promises {\n    if (promises.count > 0) {\n        PMKPromise *prev = promises[0];\n        [promises removeObjectAtIndex:0];\n        for promise in promises {\n            prev = prev.then(^{ return promise; })\n        }\n        return prev;\n    }\n}\n@end\n. Well it's not the original promise. We keep the new promise from each then each time.\nLet me know if you need any further help \ud83d\udc4d\n. Yes, or you wouldn't be able to call then again.\n. There is for CocoaPod, but not in the xcodeproj right now, however coincidentally I have this in my local branch after some recent OS X work so I'll clean it up and push.\nApologies for this the xcodeproj only recently became more important due to Carthage.\n. The xcodeproj only builds the swift version currently as well. Something to keep in mind.\nI am fixing that for a version 2 bump, but that isn't ready yet.\n. Pushed https://github.com/mxcl/PromiseKit/commit/161bd47d56ba03d88925376f24be29521add04c3\n. You can't use PMKPromise (well) in Swift as described in the documentation.\nI am attempting to fix this for version 2. But the objective C version uses a number of tricks that are not interoperable with Swift.\nHad I know Swift was coming, I would have made a few changes here and there.\n. Nice solution though! I'll supplement our docs with it.\n. https://github.com/mxcl/PromiseKit/commit/61f16ffaf808f00df8949d433fecd382f5fdf394\n. 2.0 solves this and will be merged in the near future.\n. For Swift it's the same as 1.x, it'll work on 7, it's just CocoaPods and Carthage will both not install Swift libraries to 7.x deployment targets. So you have to do it by hand.\n. However I intend to attempt to build a static library version of 1 and 2 that can be dropped in (with headers for objc) to an iOS 7 project.\n. Good news! Sorry to ask rather than Google, is this in the latest gem or a pre-release?\n. Got a link to something @zdenektopic?\n. I reported this as a bug to the Swift team (some weeks ago), it should get fixed without code changes on our end. So I guess we'll wait for the next beta.\n. Strangely this seemed to be the only case where @objc needed to be specified. And we have a lot of equivalent delegates.\n. If you make it into a framework though, you have to import it with a framework import statement:\n```\nimport \n```\nDoes that help?\n. Closing because if you use frameworks, you have to use them properly.\n. 1.4.3 will remove the deprecations. It's been almost a year, hopefully people who used those headers back when they were the proper headers will cope.\n. The recent CocoaDocs update changed the links format apparently.\n. Glad it worked out. Let me know if you have any other problems.\n. Thanks, I wonder why I didn't do this already.\nFFR, the diff on line 44 shouldn\u2019t have made it into the PR.\n. The diff on line 44 just changes formatting and thus isn't related to the content of your PR.\nIf you wanted to change the formatting it should be a separate PR.\nConsequently the diff for this commit contains unrelated modifications and impedes the legibility of the actual fix.\n. Good. Push the fixes and I'll merge.\n. Shall I make the changes?\n. There\u2019s no rush, I just offer personal services to friends.\n. Fixed with: https://github.com/mxcl/PromiseKit/commit/7fdef1e6e41c6c7c94bb3c45e2ec17a4222b2af7\nI'm really sorry I didn't push a new pod for that. I thought I had.\nRelated: we need tests for this kind of thing, but I couldn't figure out how to make tests for eg. CLLocationManager that are reliable. Unreliable tests are useless. Any ideas?\n. Pushing 1.5.1\u2026\n. Pushed.\n. Yes, because the simulator is buggy when it comes to simulating location.\n. Yeah true, that would be fine for this case.\n. In fact, would stubbing have detected this? What we needed to do is trigger the CLLocationManager to call its delegates. Stubbing probably would have worked here while in actual usage it would not have because our delegate was invisible to the location manager (which seems like a Swift bug).\n. If this indeed doesn\u2019t work, can you provide the exact error message when it doesn\u2019t work?\nswift\nfunc fetchFeed() {\n    let _:() = feedPromise().then{ [weak self] (data:[FeedItem]) -> () in\n        self?.data = data\n        return\n    }.catch { error -> Void in\n        println(\"error caught\")\n    }\n}\n. The title of this bug report is a favorite.\n. PromiseKit 2 fixes this. I hope to release it within the month.\nWith study I believe the ambiguity cannot be determined by the compiler without a layer of analysis Apple will never write.\nI can't fix it for PMK1 without breaking source compatibility.\n. Yes, this is a Swift bug. It fails to infer the return type. Hopefully it'll be fixed in 1.3.\n. I see, well I expect this means objective c promise kit won't work with objective c++ then.\nTo me this sounds like a compiler bug though as the syntax is fine.\nI'll test it, but I wouldn't get your hopes up.\n. Yes, of course. Catch is a c++ keyword.\nI guess we can put #if __cplusplus around the catch and change its name slightly.\n. For objc++ one will just have to use promise.catchOn(dispatch_get_main_queue(), ^{ /*\u2026*/ });, which is less pleasant but I think is the choice of \u201cleast surprise\u201d.\n. Pushing 1.5.2\n. Zalgo is an optional subspec. You need to specify:\nruby\npod \"PromiseKit\"\npod \"PromiseKit/zalgo\"\n. There is no dispatch_promise in Swift. I didn\u2019t add it because people were usually using it incorrectly to start a promise chain and that is not the way that promise chains should be (typically) started. Here\u2019s the equivalent:\nswift\nreturn Promise { fulfill, _ in\n    dispatch_async(dispatch_get_global_queue(0,0)) {\n        // do work\n        fulfill(foo)\n    }\n}\nLeaving open for discussion.\n. Yes this was an omission. Thanks for pointing it out.\nIs there a good way to test this sort of thing? We'd need to get into the mechanism and cause the kinds of race conditions that would cause corruption.\nPushing 1.5.3\n. Thanks, but I can't pull unless it is 100% reliable or Travis will be emailing me with false failure reports.\n. aah yes, I should have realized that. My bad.\n. Well in theory we could mock and stub so we can force the various race conditions, and then prove they don't happen, but I've never tried to do such a thing before. Maybe it's not practical.\n. I'll merge, but why'd you need this out of interest?\n. Oh cool. Thanks for looking into it.\n. Well there's a few problems here.\n1. If you add the sources manually, then remove the OS X specific files, e.g.. NSTask.swift\n2. Dynamic frameworks are not supported on iOS 7, so Carthage cannot support iOS 7.\n3. Today extensions are iOS 8 only and thus only support iOS 8 deployed frameworks.\nIf you want to use Swift PromiseKit with iOS 7 then your only option right now is to compile by hand because both CocoaPods and Carthage require iOS 8 for Swift dependencies. If you add all the sources that you need (don't add all the categories) and exclude any OS X specific files (NSTask is the only one I believe), you should be OK.\nI'm sorry there isn't a better way currently, but Swift is new and there aren't many options yet.\n. I should add some documentation for supporting iOS 7 with the Swift version.\n. You can just pod install OMG since it is not Swift and thus you won't have the above problems.\nYou only need OMG with the NSURLConnection category, so don't include either if you don't need that.\n. I don\u2019t know if it has a meaning. I asked an artist to draw me something with elephants and this is what I got.\nI chose elephants as they never forget which is the kind of quality you want in a promise.\n. Simply, CocoaPods does not support iOS 7 and Swift.\nIf you need the Swift version with iOS 7 you will have to manually add the Swift sources to your project. Fortunately, this isn\u2019t too tricky.\n. This is the only resource that I could find that includes a (truly terrifying) work around: https://medium.com/ios-os-x-development/how-to-use-swift-cocoapods-and-still-support-ios-7-0-f9dc29b3628b\n. Reopening as I will experiment with this: https://github.com/SnapKit/SnapKit/issues/12\nNote I won't be able to make it work with CocoaPods, but it will be a solution that is simpler than manually compelling the sources.\n. Here is a solution: https://github.com/PromiseKit/EZiOS7\n. As said, I can't support CocoaPods, although in theory a static library could be provided via a different podspec.\n. Yes, PMKManifold does not wait for promises. This bug was reported and we decided to leave it like this as the manifold is like a \"box\", but tickets like this make me reconsider.\nOne option is:\nobjc\n[self generateRequests].thenInBackground(^(NSArray *requests) {\n    return [myApi postRequests:requests].thenInBackground(^(NSArray *responses) {\n        // do other stuff here, need access to \"requests\"\n    }):\n});\nor:\nobjc\n[self generateRequests].thenInBackground(^(NSArray *requests) {\n    return [myApi postRequests:requests].then(^(id responses){\n        return PMKManifold(requests, responses);\n    });\n}).thenInBackground(^(NSArray *requests, NSArray *responses) {\n       // do other stuff here, need access to \"requests\"\n});\n. Never seen this before. The error doesn\u2019t look like our fault though.\nA cursory google suggests some work-arounds based on how you write your code:\nhttps://www.google.com/search?client=safari&rls=en&q=Global+is+external,+but+doesn't+have+external+or+weak+linkage!&ie=UTF-8&oe=UTF-8\n. OK, I'll construct an test project and try to reproduce, however you owe me a beer. This is my free time and the bug is Apple\u2019s fault.\n. In order to reproduce I have to close everything I am doing so Xcode doesn't get confused. Delete all derived data so there isn't potential weirdness. Make a new project, checkout the pods you are using, and then massage your code so it doesn't refer to classes I don\u2019t have.\nNow, I would be happy to do this if the bug looked like it was my fault. I care about PromiseKit. But this doesn't look like my fault, and all the results I pointed you at on Google suggest it is a swift bug and you just have to move your code around a bit until Swift stops complaining.\nI understand that you have invested time into learning PromiseKit and time is effort and that when things don't work right it is frustrating and it is easy to feel that I have wasted your time. But open source is a two way street. I am not paid for this project, but I enjoy most aspects of making it open source and supporting it. I just expect not to have things demanded of me.\n[I edited this a few times in case anyone wonders]\n. Compiles:\n``` swift\n    func getBlogs() -> Promise<[AnyObject]> {\n        let (promise, fulfill, reject) = Promise<[AnyObject]>.defer()\n    Alamofire.request(NSURLRequest()).response { (_, _, data, error) in\n        if error == nil {\n            if let xwsse = data as? [String:AnyObject] {\n\n                if let result = data as? [AnyObject] {\n                    fulfill(result)\n                }\n            }\n\n        } else {\n            reject(error!)\n        }\n    }\n\n    return promise\n}\n\n```\nThe bug is in swiftc, I suggest you report the bug to Apple.\n. The Promise constructor in general compiles, but seemingly for this arrangement of code, swiftc crashes.\nI can confirm that it works in general because the test suite passes and that constructor is heavily used.\nPresumably this bug will be fixed in an update to Xcode.\n. No doubt Swift 2 has this fixed.\n. Well, the error domain should be a good clue. There is no sure-fire way to know though.\nIf it happens a lot it suggests you need to combine more chains so they end in a sensible terminating catch handler. Sensible in that: it's a good spot to show the user the error.\nin my code most of my promises will be returned where I make them. Then the caller is responsible for adding a catch. If I find the chain does not end where I want a catch I reconsider the chain. \n. If you don't need a catch handler, don't add one. I wouldn't write code simply to suppress the unhandled error handler. It's just an informational message.\n. Well, if they are clouding the output then add an empty handler. Or perhaps use this category:\nobjc\n@interface PMKPromise (NomNom)\n- (PMKPromise *)failSilently {\n    self.catch(^{});\n    return self;\n}\n@end\nWhich in use is:\nobjc\n- (PMKPromise *)foo {\n    return [self promise].then(^{\n        //\u2026\n    }).then(^{\n        //\u2026\n    }).failSilently;\n}\nThough I advise caution, it seems a code-smell to me: that so many errors go unhandled, though obviously every situation is different.\n. Here\u2019s what will be the accompanying blog post: http://promisekit.org/PromiseKit-2.0-Released/\n. Great this is an Xcode bug. I now have a choice between forwards or backwards compatibility.\nFor now you can get around it by not generating a Swift compat header, you can manually provide the @interface just like PromiseKit does in AnyPromise.h.\nHardly ideal. Sorry for this.\n. Oddly I cannot reproduce. I have a Swift file:\n``` swift\nimport PromiseKit\npublic class ViewController: UIViewController {\n    override public func viewDidLoad() {\n        Foo().foo()\n    }\n@objc public func foo() -> AnyPromise {\n    return AnyPromise(bound: Promise(1))\n}\n\n}\n```\nThen I call this:\n```\nimport \nimport \"TestCase-Swift.h\"\n@interface Foo : NSObject\n@end\n@implementation Foo\n\n(void)foo {\n    [[ViewController new] foo].then(^{\n        NSLog(@\"Hi\");\n    });\n}\n\n@end\n```\nMy generated TestCase-Swift.h:\n``` objc\n// snip\u2026\n@class AnyPromise;\nSWIFT_CLASS(\"_TtC6hgsdaf14ViewController\")\n@interface ViewController : UIViewController\n- (AnyPromise * __nonnull)foo;\n@end\n```\nI used CocoaPods to integrate PromiseKit.\n. Uploaded for comparison: https://github.com/PromiseKit/testcase\n. K reproduced.\nIt depends on #import order. :(\nMake sure you import PromiseKit first and the generated Swift header second.\nI'll ensure our documentation refers to this.\n. Please re-open if it isn't fixed for you.\nI think the only long term solution here will be to remove the @compatability_alias, so I'll aim to do this at 2.2. It's there for full source compatibility with PromiseKit 1.x\u2019s PMKPromise.\n. > What I see is that B and C get called at the same after A completes.\nThis shouldn't happen, and well, we have tests that prove it doesn't (for test conditions at least). Can you provide a code sample that shows the behavior you are seeing?\nUpdate: To clarify, what you are expecting is how it should behave, so either there is a severe bug in promise kit, or something else is happening.\n. I couldn't find anything that explicitly tests chains longer than two, though I'm sure there is something explicit. But there are definitely times it happens during the category tests, because often they chain 34 or 5 promises. Anyway I wrote a new test that tests 1000 sequential thens:\nswift\n    func testThensAreSequentialForLongTime() {\n        let ex = expectationWithDescription(\"\")\n        var promise = dispatch_promise { 0 }\n        let N = 1000\n        for x in 1..<N {\n            promise = promise.then { y -> Promise<Int> in\n                XCTAssertEqual(x - 1, y)\n                return dispatch_promise { x }\n            }\n        }\n        promise.then { x -> Void in\n            XCTAssertEqual(x, N-1)\n            ex.fulfill()\n        }\n        waitForExpectationsWithTimeout(10, handler: nil)\n    }\nIt passes. I'll push it. I believe this is testing your situation?\n. I guess it doesn't prove they are sequential, but I can adjust it. One second.\n. See the commit I just pushed for the revised test, but I believe this shows the behavior you are expecting.\nIf possible a code sample would help me assist here.\n. Actually looking closer something is wrong here:\nswift\npromise.then { _ -> Void in\n   return B()\n}.then { _ -> Void in \n   return C()\n}.then { _ -> Void in \n  return D()\n}\nYou're stating that all the closures return Void. Shouldn't they be returning a Promise<T>? If you return void, nothing is chained.\nIf B, C, etc return promises then it seems like a Swift bug that this compiled.\n. Well yes, returning Void will still chain.\nAnd in the last then, value has type Void (alt click it to see). This is because the previous then returned Void. println returns Void. One-line closures in swift get an implicit return.\nMaybe I'm misunderstanding. I thought B() and C() returned promises, no?\n. Like the point here is: you have to return the promise in your then if you want the next then to wait on that promise. Your example has your thens returning Void.\n``` swift\npromise.then { _ -> Void in\n    return ()\n}.then {\n    // happens immediately\n}\npromise.then { _ -> Promise in\n    return Promise { /\u2026/ }\n}.then {\n    // happens when the returned promise resolves\n}\n```\n. For reference the chaining documentation is here: http://promisekit.org/chaining/\nIf it can be improved please let me know which bits don't make stuff clear etc. as I really want it to be clear. Thanks!\nEdit: the docs haven't been updated for PMK2 yet, so they will have Swift versions soon.\n. K, cool. What page did you learn from and I'll update it.\nI'm compiling a list of Swift gotchas so I'll add it there too.\n. Yeah I totally agree, it's long overdue.\n. I have decided against this as it is misleading.\nswift\nfoo().then(after(0.5)).then {\n    //\u2026\n}\nActs like this:\nswift\nwhen(foo(), after(0.5)).then {\n    //\u2026\n}\nRather than what would be expected:\nswift\nfoo().then {\n    return after(0.5)\n}.then {\n    //\u2026\n}\nBecause the after starts executing immediately.\nProbably the objective-C version should be flexible and behave this way though. I'll give it some more thought.\n. Thank you. I'll see if I can create a test case for this.\n. I'm pushing PromiseKit 2.0.1 as we speak.\n. PMK 1 or 2? I am assuming 2 with my reproduction test.\n. It\u2019s a one-line patch, so if you can, apply it to your checkout and see if it fixes it. Or I can upload my testcase.\n. 2.0.2 is pushed with the fix.\n. This should not compile:\nswift\nfirstly { () -> Promise<AnyObject?> in\n    HTTPClient.sharedClient.getJSONP(\"test1\", parameters: nil);\n}.then { object -> Promise<AnyObject?> in\n    HTTPClient.sharedClient.getJSONP(\"test2\", parameters: nil);\n}.catch(policy: CatchPolicy.AllErrors) { (error) in\n    HTTPClient.sharedClient.getJSONP(\"test3\", parameters: nil);\n}.finally{}\nBecause catch in swift returns Void (for a history of this there is a ticket that describes why we do this).\nIt compiled?!\n. I can\u2019t make such code compile:\n\nWith PromiseKit 2 at least.\n. K I re-read. Yes you can't add a finally after a catch in Swift anymore.\nThe ticket justifying this is #175\nI understand this is weird, the only option I can see is having catch return a special object that is not a promise but allows a finally. But this may only make the situation even more confusing.\nRe-open if you believe this is a bug.\n. Yes it's the proper way. Swift's catch is terminating in PMK2. Nothing can happen in that branch of the chain after the catch.\n. Swift compiler bug. Hopefully the next Xcode will work better.\n. Can I confirm you tested this?\n. Yeah, I'm downloading too. This would suck if true, but such is life.\n. Oh FFS.\n. Options to replace catch:\n- p.then{ /*\u2026*/ }.error { error in }\n- p.then{ /*\u2026*/ }.onfail { error in }\n- p.then{ /*\u2026*/ }.fail { error in }\n- p.then{ /*\u2026*/ }.failed { error in }\n- p.then{ /*\u2026*/ }.clasp { error in }\n- p.then{ /*\u2026*/ }.onerror { error in }\nOptions for defer:\n- let (promise, fulfill, reject) = Promise<Int>.deferred()\n- let (promise, fulfill, reject) = Promise<Int>.tuple()\n- let (promise, fulfill, reject) = Promise<Int>.breakOut()\n- let (promise, fulfill, reject) = Promise<Int>.split()\n. fail is not my favorite, it doesn\u2019t read as well as catch. I'm still thinking of more ideas, the above list is not the final list.\n. Preliminary swift 2.0 branch here: https://github.com/mxcl/PromiseKit/tree/swift-2.0\nIt compiles, some UI tests are disabled. The name snatch is not final.\n. The current branch is now rescue. Though I'm not 100% sure yet since PromiseKit doesn't rescue errors, since the app survives if you don't.\n. I pushed some additional revisions so you can throw in most swift methods.\n. Also, Swift \u201cexceptions\u201d don\u2019t crash the app either; instead you must handle them, you cannot write code that does not.\nIdeally we\u2019d keep the same pattern for Promise, but I fail to see how that can be done since we are not writing the compiler.\n. No decision. I'm having sleepless nights about it.\n. For defer I made it pendingPromise which is more Cocoa like anyway.\n. I think I\u2019m happy with report:\n``` swift\nspinner.start()\nwhen(fetchImage(), getLocation()).then { image, location in\n    self.imageView.image = image;\n    self.label.text = \"Buy your cat a house in (location)\"\n}.ensure {\n    spinner.stop()\n}.report { error in\n    UIAlertView(\u2026).show()\n}\n```\nI changed finally to ensure since we had to change away from catch and finally is from the try, catch, finally pattern. And finally was a lie with the Swift version since 2.0 anyway since you couldn't do it after a catch.\nI will probably add ensure and report as aliases for AnyPromise, but I don't wish to force the change when not necessary for all users.\nOpinions welcome.\n. Another option I was playing with was done where done provides two optionals thus replacing both the error handler and the \u201calways\u201d case, eg:\n``` swift\nspinner.start()\nfoo.then {\n    //\u2026\n}.done { value, error in\n    spinner.stop()\nif let error = error {\n    //\u2026\n}\n\n}\n```\nBut it seemed unnecessarily tedious for most usages I tried it with. Especially for the \u201calways\u201d case since I made it terminating (or it was hardly \u201cdone\u201d) and thus if you needed to return the chain you\u2019d have to split it at a let:\n``` swift\nfunc foo() -> Promise {\n    spinner.start()\nlet p = promise()\np.done { value, error in\n    spinner.stop()\n}\nreturn p\n\n}\n```\nAnd this feels weird, since you just said the chain was \u201cdone\u201d.\n. My experience with users of this tool, hardly any of them are familiar with other promise implementations, or even the concept of promises.\nreport reads well, you are being required to report (to the user) on errors. fail does not read well, it is imperative, it reads as though you are instructing the promise chain to fail. onFail reads OK, but on as a prefix is not familiar to Cocoa and familiarity to our platform is an important goal in this project.\nerror is used in Cocoa everywhere and means that an error is being passed in-out, it is not an error handler, you are later expected to handle the error manually. error by itself does not read well, unlike then and I want the chains to read well as instruction to newcomers, that is part of the reason this library is popular, because it reads well and people reading the usage and documentation understood it due to familiarity with Cocoa not familiarity with other promise implementations. I don't want to make it read less well because this change is required.\nSo I minced many other alternatives, none are as good as catch and finally as they refer to an existing mechanism in Objective-C. Since I cannot use those, I ended up with report.\nWe have not merged 3.0.0 yet, but it is urgent that we do so. So if anyone has further input, it should happen quickly.\n. I also wanted to communicate that the chain is terminated (it returns Void not Promise).\nOther promise implementations do not terminate the chain at the error handler, but because (otherwise) Swift finds ambiguity with catch we had to change it to be terminating and add recover for the other usage.\nreport sounds final.\n. With further thought, I find my argument against error uncompelling.\nswift\nfoo.then { foo in\n    //\u2026\n}.always {\n    //\u2026\n}.error { error in\n    //\u2026\n}\nLooking at that, the only complaint I really have is that the token error repeats\n. Recover requires that you recover. You must return something that continues the chain. Catch terminates the chain. You can't continue with a then.\nWhich docs weren't clear may I ask? They should be improved.\n. The page you got from Google is part of the manual, you are expected to read what came before it, it is not designed for cherry-picking.\nI understand that the layout of the page does not suggest where you are in the documentation, and that you are part of a series of pages that should be read in order.\nBut I only have so many hours I can spend on this project, the fact that there is documentation at all represents 100s of unpaid hours.\nPull requests welcome.\n. Hey, I'm surprised it doesn\u2019t compile. It should. Either it's a bug in the compiler or I'm doing something wrong, so I'll take a look at it today. Thanks.\n. OK I think I have it. Sorry for this omission. I'll need one for dictionary too.\n. Pushing 2.0.3 now.\n. My bad I didn't think through the addition of nullable to OMG.\n\nIt's unsafe to assume Swift libraries will maintain backwards compatibility at this point.\n\nOMG is objc, I guess the semantic versioning here would mandate a bump to the major version for nullability.\nThe world of pods is kinda messy right now.\nWill fix with a quick bump to PMK that forces OMG 2.1.3\n. K pushing, but it takes 30 minutes for cocoa pods to lint us.\n. I guess since the objc interface is the same, the minor minor update is acceptable, we just must accept that if you a library incorporating swift and that swift code depends on something you should not allow cocoapods/carthage to update that dependency without vetting.\nFor now. At some point we'll get more source-compat guarantees for Swift.\n. Live. Let me know if there are any other problems.\n. Carthage users can specify 2.1.3 in their own Cartfiles for now. I will amend this for the next release, but I'm not pushing that for a bit.\n. Probably a dupe of: #202\nSwift is probably giving you the wrong error message.\nWill update the swift 2 branch today, though be warned this branch is transitory anyway so you may have further issues in the future. Though if so, I'm always happy to help.\n. K I've had OMGHTTPURLRQ 2.1.4 and 2.1.5 removed from CocoaPods.\nIn theory you should be able to pod update and get OMG 2.1.3. If that doesn't work you will probably need to delete your Pods directory then remove the CocoaPods cache, then pod update again. I don't know how to remove the CocoaPods cache, but I'm sure googling will help.\n. Apparently a solution is:\nreturn AuthHelper.getToken().then { (result: AuthenticationResult) in\n    return Promise<[String]> { fufill, reject in\n        let request = Alamofire.request(.GET, url)\n        request.responseJSON { (req, res, json, err) in\n            if (err != nil) {\n                println(\"Error: \\(err)\")\n                reject(err!)\n            } else {\n                println(\"Success: \\(url)\")\n                let value = JSON(json!).arrayValue.map { $0.string! }\n                fufill(value)\n            }\n        }\n    }\n}\nDupes #198 & #188.\nI imagine this is fixed in Swift 2.\n. np \ud83d\udc4a\ud83c\udffb\n. wow. Thanks.\n. Pushed 2.0.5\n. I don't understand what you mean by: trigger. \n. then has no side-effects to the promise. then is the answer you are asking for (I believe), it is executed once the promise has a value and can transform that value for the next then.\nIf trigger means \u201cstart\u201d then then does not start a promise. The promise is started by whoever created it. Typically promises are started as soon as they are created. Though that is up to the creator.\n. The only way to defer a promises\u2019 execution is to not create it until you need it.\nTechnically if you wrote the promise you could defer its execution eg:\n``` swift\nfunc foo() -> (Promise, NSURLSessionTask) {\n    var task: NSURLSessionTask!\n    let promise = Promise { fulfill, reject\n        task = NSURLSession.dataTaskWithRequest(rq) { data, _, error in\n            fulfill(data)\n        }\n    }\n    return (promise, task)\n}\nlet (promise, task) = foo()\ntask.resume()\n```\n. Fixed in Swift 2. Presumably.\n. Dupes #188\n. There's some good examples in our Categories:\nhttps://github.com/mxcl/PromiseKit/blob/master/Categories/UIKit/UIAlertView%2BPromise.swift\n``` swift\nextension UIAlertView {\n    public func promise() -> Promise {\n        let proxy = PMKAlertViewDelegate()\n        delegate = proxy\n        proxy.retainCycle = proxy\n        show()\n        return proxy.promise\n    }\n}\nprivate class PMKAlertViewDelegate: NSObject, UIAlertViewDelegate {\n    let (promise, fulfill, reject) = Promise.defer()\n    var retainCycle: NSObject?\n@objc func alertView(alertView: UIAlertView, didDismissWithButtonIndex buttonIndex: Int) {\n    fulfill(buttonIndex)\n    retainCycle = nil\n}\n\n}\n```\nAnd yes, the documentation is not yet up-to-date for Swift. Apologies, it's on my todo.\n. Don\u2019t forget to nil out the retainCycle!\n. Swift bug. This probably is the solution:\nswift\n        basicDelegate!.signUp(_PSRegisterData).then { result -> Void in\n            if result {\n                self.afterSignUpSucceed()\n            } else {\n                self.afterSignUpFailed()\n            }\n        }\n. FFR, this is because Swift was confused about which then to pick (it shouldn't have been). They will fix this or improve the error message, but this category of compile errors will always be around.\n. Thanks. I am upset this snuck through. The object version has this test.\n. Pushed 2.0.6\n. I'll push something that fixes this for beta2 shortly.\nIndeed the unhandled error system has to be revised.\nI've reported a nserror -> ErrorType conversion bug at radar. So we can assume this stuff is not really ready yet anyway.\n. Hey, seems bad.\nI think the problem is certainly related to OS_OBJECT_USE_OBJ being 0, this is pretty unconventional and so probably is not well tested.\nCan you detail:\n- Your deployment target\n- How you are installing PromiseKit\n- Xcode version\nCan you log out _promiseQueue at that line? Can you try commenting out that line, does that fix it? Thanks.\n. K I think I understand why OS_OBJECT_USE_OBJ is 0: http://guides.cocoapods.org/syntax/podspec.html#deployment_target\nOur deployment target on OS X is 10.7.\nHowever I don\u2019t understand why the pointer is nil. There is no way I can see for a PMKPromise to be instantiated without the accompanying _promiseQueue.\nYou\u2019re using ARC right?\n. It\u2019s possible a fix is to do an if check first. The only idea I have currently for the cause here is that ARC is handling the _promiseQueue even though it is documented to not when OS_OBJECT_USE_OBJ is 0.\nHowever I am not familiar with if ARC also sets pointers to nil when it deallocates. I wouldn't be surprised if:\n1) It only does this in debug mode\n2) It's nothing to do with ARC\nIf 2) I'm still stuck.\n. Regarding your question about being able to stop CocoaPods setting OS_OBJECT_USE_OBJ. I think the answer is that you could have a local PromiseKit.podspec and use that.\nIf you don't mind first adding the if guard and compiling a release build and seeing if it crashes I'd appreciate it.\nOr if you could provide me with a test case I could try and reproduce.\n. I'd have tried to reproduce this myself, but I don't have a machine with a working Xcode 6 install currently. Hopefully I will next month.\n. Here\u2019s your problem:\nobjc\n- (instancetype)initWithRepository:(YMGitRepository *)repository\n{\n    NSParameterAssert(repository);\n    self = [[super class] new:^(PMKFulfiller fulfill, PMKRejecter reject) {\n        NSError *error;\n        if ([repository fetchWithError:&error]) {\n            fulfill(repository);\n        } else {\n            reject(error);\n        }\n    }];\n    return self;\n}\nI believe this confuses ARC and it over releases the object. You can\u2019t use non-init methods in an initWith initializer.\npromises are not a good pattern for subclassing really, though I can provide an initWithResolver method if you like so that the above will work.\nIn your situation your code could just be:\nobjc\n- (PMKPromise *)fetch\n{\n    return [PMKPromise new:^(PMKFulfiller fulfill, PMKRejecter reject) {\n        NSError *error;\n        if ([self fetchWithError:&error]) {\n            fulfill(repository);\n        } else {\n            reject(error);\n        }\n    }];\n}\nThough I may add that if the fetch call is synchronous, +new: does not operate in the background: it runs synchronously on the current thread. You probably want dispatch_promise().\nIn situations where you need to keep state around for some duration then we recommend composition over inheritance, eg:\n``` objc\n@interface FooTask\n@property id something;\n@property PMKResolver resolve;\n@end\n@implementation Some_OTHER_Class\n\n(PMKPromise )somePromise {\n    FooTask task = [FooTask new];\n    task.something = something;\n    return [PMKPromise promiseWithResolver:^(PMKResolve resolve){\n        task.resolve = resolve;\n    }];\n}\n\n@end\n```\n. Thanks. I am going to hold off on pushing this to pods though as it dictates as minor version bump.\nTo use this version with CocoaPods you can specify that it sources from master.\n. I decided to merge and do it myself. It\u2019s not very nice to expect people to do this sort of stuff IMO after they already have done some work in their own time.\n. np, glad that you were happy to but it was fine for me to do it.\nIf the change was more severe I would have discussed it first obv.\n. I pushed 3.0.0 to CocoaPods.\n. Sorry, I meant to do this but got distracted and forgot.\n. 1.6.0 pushed.\n- OMG dep corrected\n- Swift support removed (use 2.0 branch)\n. Yes, you can't use them directly like this. You have to return the AnyPromise from a swift then handler. \nswiftPromise().then {\n    return anyPromise()\n}.then { (obj: AnyObject?) in\n    // AnyPromise always resolves with `AnyObject?`\n}\n. I'll write more here later. There should be something else added to the API.\n. See referenced commit, I added a then for your use-case.\n. 2.1.0 is pushed which allows your example:\nswift\nFooTest.promise().then { (obj: AnyObject?) in\n    self.obj = obj\n}\nThough you may need to provide the return type for it to compile with Swift 1.2 (compiler bug):\nswift\nFooTest.promise().then { (obj: AnyObject?) -> Void in\n    self.obj = obj\n}\nThis is probably enough:\nswift\nFooTest.promise().then { obj -> Void in\n    self.obj = obj\n}\n. tl;dr: use anything EXCEPT cancelledError and the catch handler will be called.\nYou chose to use cancelledError so probably you should read the docs about what it means: http://promisekit.org/PromiseKit-2.0-Released/\nQuestion: why did you use cancelledError?\n. np, I appreciate these tickets as I worry about the whole cancellation thing catching people out and need to be aware of how to document these things so people can use the library effectively.\n. The common practice here would be to make promise2 a function and then call it and return it in the then.\n. So:\n``` swift\nfunc foo() {\n    let promise1 = Promise { resolve, reject in\n        performAsyncCall1(resolve, reject)\n    }\nfunc promise2() -> Promise<Void> {\n    return Promise { resolve, reject in\n        performAsyncCall2(resolve, reject)\n    }\n}\n\npromise1.then {\n    return promise2()\n}.then {\n    // Profit\n}\n\n}\n```\nHowever I think it\u2019s notable that if your promise2 is that simple then you can just do this:\n``` swift\nlet promise1 = Promise { resolve, reject in\n    performAsyncCall1(resolve, reject)\n}\npromise1.then {\n    return Promise { performAsyncCall2($0.resolve) }\n}.then {\n    // Profit\n}\n``\n. I have updates for this locally. I'd pull your PR anyway as it is ready now (many thanks!), however I notice you removeimport PromiseKit` from all the categories and like: I can't merge that.\n. K I understand, and makes sense, I'm surprised it has worked this long. I (hopefully) can fix with:\n``` swift\nif !COCOAPODS\nimport PromiseKit\nendif\n```\nThe imports are required for Carthage or with the pre-built frameworks.\n. First example is fine. What didn't work?\n. I have tests that prove what you have written works. Can you provide a test case that demonstrates it not working?\n. I made this test case:\nhttps://github.com/mxcl/TestCase-223\nHere's the example output:\n\nThe test case was made with Xcode 7, but could be adapted to Xcode 6.\n. It may have been you forgot to return in a then, for a Void promise returning nothing would fulfill one variant of then, and in that case the Promise would not chain.\n. Can you provide the error messages?\n. Your project has modules disabled. These are headers so they are included into your app's target and this is not CocoaPods related. Turn modules on in your app target.\n. Edit the line and change it to:\n``` objc\nimport \n```\nShould fix it, if so, modules are disabled, somewhere anyway.\n. I'm pushing 2.1.1 without the @import in a header so, hopefully that is all you need.\n. I don't know what specific build configuration is causing this problem, but it\u2019s either modules related or a bug in the build systems.\n. Well, is it not all it took to fix it? I did a global search and the only place I found an @import in a header is there. You\u2019re the tester here :)\n. Yes. You can't use @import PromiseKit with PromiseKit. This is documented in various places.\n. np, it's fine \ud83d\udc4d\ud83c\udffb. I agree it's unexpected. It is done so Swift doesn't see the entire objective C interface as there would be conflicts.\n. AnyPromise is a type alias of PMKPromise. So you shouldn't need to cast. Do you have to?\n. I think this is just a Swift compiler error (in that its error message is not that useful). You must specialize obj. Look at the signature for then, it's generic. Compare with the 2.0 release notes. \n. swift\nlet p = MHObject.fetch()\np.then { (obj: AnyObject) -> Void in\n    // do something\n}\nI agree this sucks. Maybe then should just push AnyObject? from an AnyPromise.\n. Can you provide a full header of one these? There's a bug with import order I can't easily fix. \n. I appreciate the full test case, I'll make sure to figure out a fix for you!\n. OK, I understand what's the problem more or less.\nIt\u2019s a module problem. Your library CoreHound imports PromiseKit, but the module system gets confused between the objc and Swift components and ends up only importing the ObjC side of PromiseKit. You can verify this by trying to complete off of p2: it provides completions for ObjC-ish functions (note that they have Void parameters).\nThis is quite a substantial problem and will require a good deal of work for me to fix it.\nI tried initially to replace all instances of #import <PromiseKit/PromiseKit.h> in public headers in CoreHound and other pods with @class PMKPromise and then moving the #import to the .m files.\nThis worked, but then for some reason ViewController.swift still wouldn't compile as no function that returned PMKPromise had public access.\nI'll have to give this some thought.\nTL;DR: Any module that exposes an Objective-C interface that returns promises and which is then imported by Swift code will fail.\n. In fact, it imports almost all the Swift stuff, just not the AnyPromise part of the Swift stuff. Weird.\n. I'm still trying to solve this. Apologies for the delay.\n. Have a solution. It\u2019s deep module-foo. Dunno what specifically the problem was, but it is fixed. Just running tests now.\n. Apologies. I never made any promises to keep those branches but I would have kept them if I'd known you were using them.\nI'm a neat freak about branches.\nI'll keep all current branches until 2.0 is released properly.\nI'll try to push that commit again. Specifically which beta was it for?\n. Restored as https://github.com/mxcl/PromiseKit/tree/swift-2.0-beta2\n. There is no standard way to do this, (though it would be a welcome addition). I suggest:\n``` swift\nlet p = Promise { fulfill, reject in\nafter(10).then {\n    reject(NSError(\u2026))\n}\n\nsomeAsyncFunctionWithCompletionHandler {\n\n    // do stuff\n\n    if condition {\n        fulfill()\n    }\n}\n\n}\n```\nIt is safe to call reject or fulfill after the promise is already resolved, it is a noop.\nHowever if you want to avoid some work, then you can ask the promise if it is resolved:\n``` swift\nvar promise: Promise!\npromise = Promise { fulfill, reject in\nafter(10).then {\n    reject(NSError(\u2026))\n}\n\nsomeAsyncFunctionWithCompletionHandler {\n\n    while promise.pending {\n        // do stuff\n    }\n\n    if condition {\n        fulfill()\n    }\n}\n\n}\n```\nYou don\u2019t need to switch back to the main queue with Promises. See http://promisekit.org/dispatch-queues/\n. PromiseKit 6:\n```swift\nlet p = Promise { seal in\nafter(.seconds(10)).done {\n    seal.reject(MyError)\n}\n\nsomeAsyncFunctionWithCompletionHandler {\n\n    // do stuff\n\n    if condition {\n        seal.fulfill()\n    }\n}\n\n}\n```. Glad to hear \ud83d\udc4d\ud83c\udffb\nIf you found my work helpful, please consider supporting its development.. There's a conversion initializer for Guarantee to Promise:\nrace(promise, Promise(timeout))\n\nI assume it's safe (no-op) to resolve a seal more than once.\n\nYes, sources are easy to read if you want confirmation.\n\nAny opinion on this as a solution:\n\nCan be simpler, also weird to provide an error yourself imo:\n```swift\nenum E: Error {\n    case timeout\n}\nextension Promise {\n    func timeout(after seconds: TimeInterval) -> Promise {\n        return race(asVoid(), after(seconds: seconds).done {\n            throw E.timeout\n        }).map {\n            self.value!\n        }\n    }\n}\n```. If you have an issue please open a new ticket.. Indeed. There is no AnyPromise class due to backwards compatibility with PromiseKit 1.x.\nPromiseKit 3 fully deprecates this (so @class AnyPromise; will work).\nFor now (with PMK2), you can do:\nobjc\n@class PMKPromise;\n@compatibility_alias AnyPromise PMKPromise;\nSorry about this, I know it sucks, but I had a choice: break everything that uses PromiseKit 1.x when they transition to Promise 2 or have this particular thing work.\n. From docs:\n\nif any promise fails, the next catch is called.\n. No. It is not possible. jQuery promises are generally considered broken. Having exact conditions that represent errors or not errors is beneficial to writing correct code.\n\nIf you want something to run every time, use finally.\nIf you want a promise to not fail a when then you must explicit mark it as unable to fail:\n``` swift\nlet p1 = api.getUser(self.ticket.requesterId)\nlet p3 = api.listComments(self.ticket.id)\n// if the promise fails \u201crecover\u201d it.\n// Note you will need to massage the closure\u2019s return type\nlet p2 = api.getUser(self.ticket.assigneeId).recover { nil }\nwhen(p1, p2, p3).then { requester, assignee, comments -> () in\n    // success code\n}.finally {\n    // finally code\n}\n```\nI understand that maybe this doesn\u2019t suit you and you want a more task-orientated API, in which case I suggest bolts or Swift Async Task.\n. Nuts, I'm on it.\n. I\u2019m on El Capitan beta 6, thus I cannot load this project in Xcode 6.4. A fix will have to wait on a fix from Apple :(\nCertainly, this should work, we have tests for it.\nWhat specifically happens?\n. I see, it seems that Xcode is not seeing the then that takes a closure that returns an AnyPromise (because this is the behavior I\u2019d expect if it was just passing through the return as though it was a normal object).\nThis is most likely again due to the Objective-C framework imports Objective-C PromiseKit (which is built on Swift) which is then imported into Swift issue.\n. A workaround for now would be to then off the AnyPromise and return that. \n. This wasn't module weirdness, it was missing functions.\nI remember now why I didn't add a Swift then to AnyPromise, as it required a few others in order to ensure that it handled various cases. Instead I expected users to adapt them into Promise<T>s.\nSo my bad.\n. I'm pretty sure this is fixed, but I can't run your test project on El Capitan beta 9 and right now I have no other macs to try it on.\nLet me know if it isn't.\nAnd very sorry about this.\n. i appreciate you using the library to its full extent \ud83d\udc4d\ud83c\udffb\nI wrote new tests to verify the behavior, so I presume it is fixed. Hopefully my tests are extensive enough.\n. Great, glad to hear it. \ud83c\udf7a\n. Looks good! Some notes:\n- finally cannot come after catch (yes it's unfortunate, but Swift was difficult about it any other way)\n- The when is unnecessary, but it will work. You can just then off of thing(). In JS maybe you always use when because JS is dynamic and thus when will accept anything, not just promises, but Swift is strict, so we decided to be strict and don't provide a when that can take anything but promises (ObjC PromiseKit is different, PMKWhen can take anything).\n- If you are using when so you can stylistically then on the next line then we provide firstly.\n- You will need to specify the Promise\u2019s type:\nfunc thing() -> Promise<String> {\n  return Promise { resolve, reject in   \n      //\u2026\n  }\n}\n- Because Swift is a bit flakey, you may need to specify the return type of the final then closure.\n- If you want promises more like JS (ie. less fussy about types) then I suggest ObjC (AnyPromise) since it is dynamic where Swift is strict which is more like JS, though obviously ObjC has a lot of quirks.\n- Your syntax for Swift closures was a little off.\nSo I\u2019d write it more like this:\n``` swift\nfirstly {\n    thing()\n}.then { val -> Double in\n    Double(val) * 2.0\n}.then { val -> Void in\n    println(10 == val)\n}.finally {\n    println(\"always called\")\n}.catch { err in\n    // err is NSError\n}\nfunc thing() -> Promise {\n    return Promise { resolve, reject in \n        ajax(\"/foo\") { err, rsp, body in\n            if err == nil && rsp?.statusCode == 200 {\n                resolve(body)\n            } else {\n                reject(err)\n            }\n        }\n    }\n}\n``\n. If you do use Swift PromiseKit beware the incoming Xcode 7, we\u2019re having to renamecatch.\n.rejectandfulfill` have different signatures, so you need:\nvar resolved = Dictionary<String, Any>()\n. You may prefer to use defer, Swift doesn't much like dictionaries and Any in these contexts:\nswift\nlet (promise, fulfill, reject) = Promise<Any>.defer()\nsocket.emit(message, dic)\nrequest.updateValue((fulfill, reject), forKey: uuid)\nreturn promise\nWhere updateValue then has the signature:\nswift\nfunc updateValue(tuple: (fulfill: Any -> Void, reject: NSError -> Void), forKey: String)\nThough to be simpler you could do:\nswift\nfunc updateValue(fulfill: Any -> Void, reject: NSError -> Void, forKey: String)\nAlso, please beware, Swift 2 is coming, and the name of defer has to change.\n. Thanks for the suggestion, indeed, was missing.\n. Always \ud83d\udc4d\ud83c\udffb\n. Seems to me Duck Duck Go should be passing application/json when they are not return JSON-P.\n. The fix will be in 2.2.2 which should be released later today.\n. Thank you, however I don\u2019t think this should be configurable. When will JSON mime types change in the future? It's very unlikely they will change.\nFor the case where for some reason the API you are using has a bad mime type, you should write your own promise. The justification for PromiseKit\u2019s categories is they wrap existing Cocoa asynchronous patterns with promises, and I also try to add a little sugar, so for example the NSURLConnection promises also will decode JSON if they detect it.\nBeing able to configure what JSON is is beyond the scope of the library, IMO.\n. Any comments on my comment?\n. #worksforme\nsh\n~$ sudo xcode-select --switch /Applications/Xcode-beta.app/\n~$ mkdir tmp && cd tmp\n~/tmp$ carthage update\n*** Fetching PromiseKit\n*** Fetching OMGHTTPURLRQ\n*** Checking out OMGHTTPURLRQ at \"3.0.0\"\n*** Checking out PromiseKit at \"39495e0212792d3cc158b3bca92ddcc417679f55\"\n*** xcodebuild output can be found in /var/folders/9p/55y6r8hs3yz2qkhvf74gc0gh0000gn/T/carthage-xcodebuild.hikZiR.log\n*** Building scheme \"OMGiOS\" in OMGHTTPURLRQ.xcodeproj\n*** Building scheme \"OMGOSX\" in OMGHTTPURLRQ.xcodeproj\n*** Building scheme \"PMKiOS\" in PromiseKit.xcodeproj\n*** Building scheme \"PMKOSX\" in PromiseKit.xcodeproj\nwarning: All interface orientations must be supported unless the app requires full screen.\nwarning: A launch storyboard or xib must be provided unless the app requires full screen.\n~/tmp$ ls Carthage/*/*/*.framework\nCarthage/Build/iOS/PromiseKit.framework\nCarthage/Build/Mac/PromiseKit.framework\n~/tmp$ cat Cartfile\ngithub \"mxcl/PromiseKit\" \"swift-2.0-beta5\"\n. Can you build anything else with Carthage?\nHave you set your xcode-select to use Xcode-beta.app rather than Xcode.app?\n. In fact, I've had similar temperamental problems building with xcodebuild.\n. Probably. I have no experience with Core Bluetooth, but I could probably whip something up.\nCan you provide a list of the classes and methods you need?\n. Merged\n. Not sure I can fix the Swift compiler crashing.\n. Compiling it with --verbose gives more information, but nothing that is useful without re-writing URLDataPromise which shouldn\u2019t be necessary since it compiles in Xcode OK.\n. Hopefully the next beta will help.\n. Seems to build with beta6.\n. The Carthage install does indeed not include categories.\nThe reason for this is Carthage has no \u201csubspec\u201d capability, so I can install all the categories or none of them. All is not reasonable because then any app would link to 20+ frameworks. Thus we link to none.\nYou must import the categories manually. Drag and drop from the carthage checkout folder.\n. Thanks, and PR welcome, I cannot fix this. Not due to lack of desire, I assure you. Situation makes it impossible.\n. 2.0 only is fine by me. Thanks and thanks :)\n. Indeed, it's a swift bug. Specify the return type. More details in the PromiseKit documentation.\n. Works-for-me:\n``` bash\n$ pod update\nUpdate all pods\nAnalyzing dependencies\nCocoaPods 0.38.2 is available.\nTo update use: sudo gem install cocoapods\nFor more information see http://blog.cocoapods.org\nand the CHANGELOG for this version http://git.io/BaH8pQ.\nDownloading dependencies\nInstalling PromiseKit (2.2.1)\nGenerating Pods project\nIntegrating client project\n```\nI\u2019m not sure what to suggest.\n. The AdvancedSearchPlugin is something you installed yourself. Maybe you should uninstall it?\n. Your plugin target is not correctly copying PromiseKit.framework into its built bundle. This doesn't seem likely a CocoaPods problem.\nIt's hard to help you further unless you provide more information.\n. If you need further help here I can try and assist, but it seems to be a CocoaPods bug.\nThe standalone instructions are simply: drag and drop three files. Sorry you found that \u201csilly\u201d, I can try and help further if you have more questions.\n. The instructions are:\n1. Drag and drop either the iOS or OS X PromiseKit.framework into your\n   xcodeproj, ensure it is added to your application target.\n2. In your project\u2019s settings, ensure the framework is set to be embedded and\n   not just linked.\n3. Add the sources for any categories/extensions you require to your project\n   from the Categories directory in this distribution.\n4. If you add the category for NSURLConnection, you also need to drag and drop\n   OMGHTTPURLRQ.framework.\n5. Ensure \u201cembedded content contains Swift\u201d is checked in your build settings.\nI haven't found any clearer instructions for other projects. Maybe you can provide a clearer example?\n. 2) In the project settings there are two sections labeled Linked Frameworks and Embedded Frameworks. You need to ensure the framework is embedded, this is the case for all Frameworks for iOS targets, if you need more information refer to the Xcode documentation.\n3) There are sources in a directory called Categories in the distribution. Add the sources you want. If you don\u2019t understand why you need the categories then please read the PromiseKit documentation which goes into great detail.\n5) For both.\nImporting frameworks into targets with Xcode is complicated: it is hard to explain the steps and I have tried to do my best. This is why I recommend CocoaPods or Carthage: they do the job with minimal hassle and don\u2019t require any skill with Xcode.\nIf CocoaPods doesn't work with Plug-In targets then I suggest you report the bug there.\nGood luck.\n. Can't merge, this will make when ambiguous with:\npublic func when<T>(promises: [Promise<T>]) -> Promise<[T]> {\n    return when(promises).then(on: zalgo) { promises.map{ $0.value! } }\n}\nYou should be able to pass in [Promise<Void>] it will produce a Promise<[Void]> (not Promise<Void> which is more useful).\nA PR for:\npublic func when(promises: [Promise<Void>]) -> Promise<Void> {\n    return when(promises)\n}\nwould probably be ok. I'm worried it may be ambiguous however. Please run the OS X tests before submitting the PR.\nI'd do the work myself but am currently legally incapable.\n. The documentation is correct for PromiseKit 2, which is the current release. You are documenting PromiseKit 1, which is no longer recommended.\n. np \ud83d\udc4d\ud83c\udffb\n. Yes, for some reason Carthage won\u2019t build the binaries, and usually this is what I use to build the distribution.\n2.2.1 exists however: https://github.com/mxcl/PromiseKit/releases\n. Uploaded.\n. Thanks!\n. Swift 2 branch fixes this. For now I suggest just copy and pasting the NSJSONFromDataT code and adding your own extension.\n. There is no support, but it's easy enough to add. PR would be very welcome. \n. The task would involve adding functions to NSURLConnection+Promise.\nAnd adding PATCH to OMGHTTPURLRQ.\n. The alternative would be AFNetworking and one of the AFNetworking+PromiseKit libraries in CocoaPods.\n. I think our error is assuming the combination: false. nil is possible.\nApple are pretty strict in this pattern for completion blocks. Thus we can assume false, nil is impossible.\nThe other error is having a custom error type. Your code is in fact incorrect above, assuming that the error will always be of type PromiseKit.AddressBookError, you need a more complete logic handler that checks for NSError too, since in your example that is what is happening.\nThus, it seems having PromiseKit.AddressBookError exist at all is confusing. We should either handle all errors with our own type or none. Not half and half. My bad.\nI thus conclude we should handle none since we cannot know all errors Apple provide since their documentation is lacking.\n. I think this is all we should have, in fact:\n``` swift\nimport AddressBook\nimport CoreFoundation\nimport Foundation.NSError\nif !COCOAPODS\nimport PromiseKit\nendif\n/**\n Requests access to the address book.\nTo import ABAddressBookRequestAccess:\nuse_frameworks!\npod \"PromiseKit/AddressBook\"\n\nAnd then in your sources:\nimport PromiseKit\n\n*/\nextension NSError {\n    private convenience init(CFError error: CoreFoundation.CFError) {\n        let domain = CFErrorGetDomain(error) as String\n        let code = CFErrorGetCode(error)\n        let info = CFErrorCopyUserInfo(error) as [NSObject: AnyObject]\n        self.init(domain: domain, code: code, userInfo: info)\n    }\n}\npublic func ABAddressBookRequestAccess() -> Promise<(ABAddressBook)> {\n    var error: Unmanaged? = nil\n    guard let ubook = ABAddressBookCreateWithOptions(nil, &error) else {\n        return Promise(error: NSError(CFError: error!.takeRetainedValue()))\n    }\nlet book: ABAddressBook = ubook.takeRetainedValue()\nreturn Promise { fulfill, reject in\n    ABAddressBookRequestAccessWithCompletion(book) { _, error in\n        if error == nil {\n            fulfill(book)\n        } else {\n            reject(NSError(CFError: error))\n        }\n    }\n}\n\n}\n```\nThoughts?\n. Reopening so I don\u2019t forget work needs to be done.\nI won\u2019t break the API for version 2, but we have a version 3.0.0 on the horizon.\n. The Swift compiler is giving an incorrect error message due to nested closures.\nOne of fulfill or reject is not correct in some syntatic manner or possibly the use of self.findByTags is incorrect syntactically.\nTry the self.findByTags statement by itself without the Promise wrapping it.\nYou may also try: fulfill((count, channels)) though not usually necessary, I've seen that satisfy the compiler once.\nPossibly specifying Promise { (fulfill, reject) -> Void in will help, thought I doubt it.\nLet me know if any of these work.\n. Seems like a carthage bug. It shouldn't be trying to build that target/scheme.\n. Please provide example code. \n. swift\nfunc httpswiftCall() -> Promise<(Int, String)> {\n    return Promise { fulfill, reject in\n        myHTTPFunc(url) { statusCode, responseString in\n            fulfill(statusCode, responseString)\n        }\n    }\n}\nSorry if there isn't a more simple example in the documentation.\n. > Concurrent queues (also known as a type of global dispatch queue) execute one or more tasks concurrently, but tasks are still started in the order in which they were added to the queue. The currently executing tasks run on distinct threads that are managed by the dispatch queue. The exact number of tasks executing at any given point is variable and depends on system conditions.\nSo\u2014based on Apple\u2019s documentation\u2014you cannot control the number of threads that spawn, though you can specify the priority of _backgroundPriorityQueue which may help with your performance problem.\nOtherwise you will need to manage the threading yourself. You can still use promises (if you like) for this, but you will have to create your own (which is simple relative to the thread-management stuff).\n. There is no planned work for NSOperationQueues at this time.\nI don\u2019t know much about dispatch groups, but wrapping things with promises is the same any which way. You make a promise and call fulfill when that \u201ctask\u201d is done. More docs here.\n. Are you sure the crash is due to too many threads? If not, then it would be worth being sure about that before spending time on a more elaborate solution; if so then apologies for the comment.\n. This suggests you are blocking the main thread somewhere and that it is not because you have too many threads.\n80 threads sounds pretty normal to me.\nI guess it is possible if your many threads are very intensive that it is causing the main thread to hang. Sounds unlikely though, the kernel should be able to manage that. I'd in fact consider this a kernel bug if your threads are causing the kernel to not schedule time for the main thread for the amount of time it takes the main-thread-reaper to reap your application.\n\nIs this not an issue though? I feel like I cannot use PMKWhen for it's intended purpose since I cannot select how little or how much concurrency happens in the system and there is no way to work within the framework to do so. If I do make a workaround using dispatch groups, does that not make PMKWhen pointless?\n\nI think maybe you are not understanding what PromiseKit provides: PromiseKit provides promises, It is entirely agnostic to the underlying mechanism by which the asynchronicty is achieved. Every method which allow monitoring tasks has a mechanism that allows you to note that the task is complete; this is all promises are.\ndispatch_promise is provided for convenience since use of dispatch_async is very common, it is not provided as a statement about how you should use PromiseKit.\nIf you need more power over the concurrency in a system then you need to write your own promises that use some concurrency mechanism that allows you to achieve what you need.\nHowever, If you write something that can be applied generally, we'll happily take the PR.\n. Yeah I'd go with what Nathan was saying. More elegant in Swift:\n``` swift\nfunc follow() -> (Person, Promise) {\n    return (person, Promise { \u2026 })\n}\n///////////////////////////////////////////////////////\nlet (person, promise) = follow()\nfunc setUI(person: Person) {\n    //\u2026\n}\nsetUI(person)\npromise.then(setUI)\npromise.catch { error in\n    // error\n}\n```\nIt is not as elegant as a callback solution. Promises _only resolve _once** so there is no opportunity to have a promise handler be called twice.\nI like the optimistic model, I've used it in various apps. When you need it, you need it. But promises don\u2019t map directly to it.\n. You can\u2019t fulfill a promise twice, this is a feature generally. Just not for this pattern. Sadly, no design pattern works for everything. One must adapt.\n. The swift and objc implementations of the categories sources are separate. Perhaps this will work, but currently at least, it's not supported. \nYou'll notice there is code for promiseViewController in the objc portion of the categories.\n. I see. I'm not sure if this is a bug in the toolchain or a problem with the PromiseKit bridging header.\nI believe you can annotate @notobjc (or something like that) to prevent it being put in that header though.\n. I guess this is our fault. Our Swift-objc bridge doesn't include the Promisable protocol.\n. Yes, this is documented. It cannot contain the categories or linking to PromiseKit would link almost all possible system frameworks. You have to manually copy the categories in from the Carthage checkout.\n. In fact, it is not documented. I cannot modify this project legally currently, maybe someone could do a PR?\n. \ud83d\udc4d\ud83c\udffb\n. Sounds sensible, but specifically why for your needs? May I ask?\n. Oh that severe? Odd that the tests didn't uncover this, maybe the bug is device only?\nMust be a regression versus 2.x but the xcodeproj has changed a lot.\nPlease merge @nathanhosselton. Ta!\n. AnyPromise is PMKAnyPromise, per this stuff in Umbrella.h:\nobjc\n    SWIFT_CLASS(\"PMKAnyPromise\")\n    @interface AnyPromise : NSObject\nCan you post the error message?\nI worry about compatibility_alias fixes as we had previous bugs due to them, they shouldn't really be used in this context (I believe).\n. Yes, this is due to a change in beta 6 in how the runtime attribute for objc classes works. Your fix is good, but I think we should just give-in here and have AnyPromise be AnyPromise in the runtime as well.\n. Yes, Bolts apparently doesn\u2019t build with Carthage currently. It affects me also. Hopefully Facebook will fix it.\nNot building Bolts allows the rest of the Carthage deps to build, but then the iOS tests will fail.\n. You can do this with Swift when now:\nswift\nwhen(getGames(), getUser()).then {\n  games, user in\n  self.games = games\n  self.user = user\n}\nThis works up to four parameters. If you need more (or you only have them in an array) then they must all be the same type, and yeah, I recommend the asVoid() method. asAny was removed because Void is the most swift-syntax tolerant, and Any is dangerous and I feel responsible to promote safe Promise use, you can still do it though if you like:\npromise.then { $0 as Any }\n. It returns nil if the promise was rejected. So if it returns nil in the then it is a bug. It seems unlikely it is doing so though. We have SOOOO many tests.\n. Anyway how about the solution I gave? It is type safe and the suggested route for Swift.\n. Does it not work? Most of the spec only specifies sources for all platforms.\n. I guess it's because we do:\nruby\n  s.ios.deployment_target = '8.0'\n  s.osx.deployment_target = '10.9'\nIt needs a watchos one too.\n. Please.\nYou may not need OMGHTTPURLRQ for watchOS though. Using any networking there?\n. You may want the Foundation categories:\npod 'PromiseKit/Foundation'\nWe should make a Foundation-HTTP subspec so stuff can avoid requiring OMG.\n. So, is this fixed?\n. Does it not work? If not, what prevents it working?\n. You have to import PromiseKit with the old syntax:\n``` objc\nimport \n```\nOtherwise none of the categories get imported.\nIt's a limitation of modules.\n. np imo it's not intuitive. I document it in various places, but there's a lot of docs so I'd miss it too. \n. Swift is not ABI compatible. The binaries were built against swift 1.2. Xcode comes with Swift 2. You need to build from source. \n. Don't auto convert master. Use one of the swift 2 branches.\nThere will be a rebuilt standalone distribution for Xcode 7 or it will be removed altogether soonish. \n. I have to release 3.0 and it has issues. Before that there cannot be a new Carthage release.\nI'm not sure I entirely understand your issue @toddrick, do you have source compile issues with one of the swift 2 branches with Carthage.\n. I am sorry about this. I wish I could be more responsive. The issues are beyond our control to promptly deal with. In the meantime you can try to build them yourself. It should be a simple enough matter. We can help with any issues. \n. I've removed the references to the standalone distributions since it is a foolish errand to provide them in this time of no Swift ABI compatibility.\n. FFR you can amend the commit and force push the branch rather than make a cosmetic additional commit.\nI don't mind, but it's good practice.\nThanks for the fix!\n. Here\u2019s the minimal version:\nswift\nstatic func fetchList() -> Promise<[MatchModel]> {\n    return when(databaseResults.map{ dbresult in \n        return DataProvider.fetch(dbresult!).then { model in\n            return MatchModel(dbresult, partnerProfile: model))\n        }\n    })\n}\nThough you could go more extreme if the type inference works well enough:\nswift\nstatic func fetchList() -> Promise<[MatchModel]> {\n    return when(databaseResults.map{ DataProvider.fetch($0).then { MatchModel($0, partnerProfile: model) } })\n}\n. Your weight function returns nothing.\nYou are returning a string in the then, this is a closure, returning from that will not return out of higher functions.\nProbably you want to return a Promise<String>:\n``` swift\nprivate func weight() -> Promise {\n    let sampleType = HKSampleType.quantityTypeForIdentifier(HKQuantityTypeIdentifierBodyMass)\n    return readMostRecentSample(sampleType!).then { sample -> String in\n    if (sample != nil) {\n        var weightLocalizedString = self.kUnknownString\n\n        let weight = sample as? HKQuantitySample\n        if let pounds = weight?.quantity.doubleValueForUnit(HKUnit.poundUnit()) {\n            let weightFormatter = NSMassFormatter()\n            weightFormatter.forPersonMassUse = true\n            weightLocalizedString = weightFormatter.stringFromValue(pounds, unit: NSMassFormatterUnit.Pound)\n        }\n\n        return weightLocalizedString\n\n    } else {\n        print(\"no sample\")\n        return self.kUnknownString\n    }\n}\n\n}\n```\nPlease also note that you failed to return in all branches of your then, which is actually what the compiler was complaining about.\nDepending on Swift version, you may also need to specify -> String for your closure.\n. Would be better with Swift 2:\n``` swift\nprivate func weight() -> Promise {\n    let sampleType = HKSampleType.quantityTypeForIdentifier(HKQuantityTypeIdentifierBodyMass)\nreturn readMostRecentSample(sampleType!).then { sample in\n    guard let weight = sample as? HKQuantitySample else { return self.kUnknownString }\n    guard let pounds = weight.quantity.doubleValueForUnit(HKUnit.poundUnit()) else { return self.kUnknownString }\n\n    let weightFormatter = NSMassFormatter()\n    weightFormatter.forPersonMassUse = true\n    return weightFormatter.stringFromValue(pounds, unit: NSMassFormatterUnit.Pound)\n}\n\n}\n```\n. Can you screenshot the code with inline error?\n. Try:\n``` swift\nprivate func weight() -> Promise {\n    let sampleType = HKSampleType.quantityTypeForIdentifier(HKQuantityTypeIdentifierBodyMass)\nreturn readMostRecentSample(sampleType!).then { sample -> NSString in\n    let weight = sample as! HKQuantitySample\n    let pounds = weight.quantity.doubleValueForUnit(HKUnit.poundUnit())\n    let weightFormatter = NSMassFormatter()\n    weightFormatter.forPersonMassUse = true\n    return weightFormatter.stringFromValue(pounds, unit: NSMassFormatterUnit.Pound)\n}\n\n}\n``\n. It doesn\u2019t return aString, it returns anNSString`, normally these implicitly cast, but they don\u2019t implicitly cast for closure or function signatures.\n. PromiseKit 2 does not work as a modular import. This is documented.\nSorry. I know it sucks. \n. So what this means is: you must import it with a #\n. ErrorType and NSError implicitly cast in Swift. userInfo used to be lost every conversion in earlier Swift betas, so this is either a regression or PromiseKit is somehow losing it.\nI doubt it is PromiseKit though, if you look at the code we pass the rejected error straight into our result storage and then report just passes that back to your clojure.\n. This bug should be reported against Swift. Though will merge fix as well.\n. We should switch report to error like in the other discussion.\nreport should be kept around though for a few versions since many people are now using the switch-beta branches. Then we'll deprecate it.\n. Also, please specify your Xcode version.\n. Xcode 7 is Swift 2, PromiseKit 2 is Swift 1. You need to use PromiseKit 1 or PromiseKit 3. PromiseKit 3 has not been released yet.\nThis information is in the README.\n. PromiseKit's tests use report and expectations all over the place.\nCan you provide a test project that verifies your bug? Thank you.\n. We don\u2019t manipulate the run loop. We just dispatch_async onto it. This seems weird to me, Xcode UI tests can't work this way, so much stuff would break.\nEdit: I ran the tests and can see what you're saying, it's just weird. Not to mention the fact PromiseKit itself has UI tests that pass.\n. OK so for PromiseKit\u2019s UI tests the Promise logic is in the app. Why is your Promise code in the test bundle?\nXcode 7\u2019s UITest stuff is not designed to have logic in the testing portion. I know this sucks, but it is the case.\nI am reluctant to add a queue parameter to catch, so this is why this discussion hasn't moved on to a PR yet.\n. I'm not saying it is unreasonable to do it, I'm saying it is technically impossible. The UI tests run in a separate process to your app. You can't interact with your code from the tests.\nThis is a known limitation to Xcode 7 UI tests.\n\n\nI am reluctant to add a queue parameter to catch\n\nwhat drawback do you think there is?\n\nDevelopers make mistakes because they are trying to be performant. Error handling really must succeed or an end-user\u2019s data may be at risk. By forcing all error handling to occur serially on the main thread PromiseKit is helping create a world of robust applications.\n. K. I'm cool with this. PR welcome. \n. In case it isn't clear, we merged a PR adding this and pushed a new release.\n. This is by design, pendingPromise splits the ownership of the promise across the three objects. It seems in this case the solution is for the dataTask to be released, then it will release its owned objects, which includes its closures, and thus fulfill and reject will be released.\nThis would be the correct design considering the intended usage of Swift memory management.\nAnother solution would be to make fulfill and reject weak, though feels like \u201cfighting\u201d the system.\nThere is no retain cycle here.\n. Looks good.\n. We only provide for up to 3. After three you have to use an array. See when.swift for the documentation.\n. So:\nswift\nwhen(p1(), p2(), p3(), p4()).then { results -> Void in\n  //\n}\nwould work.\n. > I thought \"finally\" would do the stuff but it's seems it's still wrapped in the promise so my async code in saveAddress method will not work.\nThere is no \u201cpromise stuff\u201d that it can be \u201cwrapped in\u201d, If the then is called, then the finally will be called. Are you sure that your promise getCleanAddressFrom: resolves?\n\nI'm calling stuff like this:\n\n[[DataController sharedController]\n     saveAddressWithParameters:parameters\n     andOnCompletion:^(BOOL success, NSString *message, GDataXMLDocument *xmlDoc) {\n         // Stuff\n     }];\nI don\u2019t know what you mean here. Is this the contents of saveAddress?\n. Please provide the code to the getCleanAddress promise\n. This chain looks fine.\nI think it goes deeper: PromiseKit: Pending Promise deallocated! This is usually a bug. a promise is being deallocated before it resolves. If it is any of the promises before the finally the finally will never trigger, because it never receives a resolution.\nThis warning is rare and was added to aid debugging of these sorts of situations.\nWhat PromiseKit version and Xcode are you using?\n. > Or I missed that promiseWithResolverBlock can only wrap non chained block ?\nPromises from promiseWithResolverBlock can be chained.\n. If you can provide a test-case then we can reopen the bug. Without a test case it's just speculation. Thanks.\n. For now you can trivially set your Podspec to use the branch, please don't badger Nathan, the poor guy has been thrown in the deep end on this stuff. He is working hard and we will push as soon as he can persuade CocoaPods to lint.\n. Sorry, and yes, thanks\u2014I meant Podfile.\n. It's depressing how common such issues our with our tools. Glad you sorted it out.\n. Great work, but indeed, we shouldn\u2019t modify the NSURLConnection like that. So lets remove that, and if COcoaPods won't lint that we can --ignore-warnings as I'm not sure what other solution there is.\n. I don't have a problem with this. I think the reason it is not there is swift compiler bugs. \nThough the specific example could be written without dispatch_promise IMO\n. The bugs I refer to are probably fixed. \n. I'd have written:\nswift\nfunc doSomething(param0: String) -> Promise<String> {\n    guard someCheck(param0) else {\n         return Promise(error: MyError)\n    }\n    return dispatch_promise(on: queue) {\n        return self.obj.doActualWork(param0)\n    }\n}\nWhich is still using dispatch_promise, but it doesn't unnecessarily dispatch for the error condition.\n. @excaliburnan this is off topic. If you want help open a new ticket please with the line of code that you are having trouble with included. Thanks.\n. Honestly, this seems a little pointless, unless you can give me a good example? Because all I can think of is:\nswift\ndispatch_promise { \n    return login()\n}\nWhich is pretty much pointless unless the instantiation of the login promise is truly intimidating in work load.\nWill reopen if there's an example! \ud83d\udc4d\ud83c\udffb\n. Since PromiseKit 2 we support the idea of cancellation, it is a special ErrorType, CancellableErrorType. We on\u2019t provide an explicit mechanism to cancel a promise, instead this left as an implementation detail for the author of the Promise. More details here.\n. You don't have to subclass Promise, though it is certainly one option. Here's a functional example:\n``` swift\nenum Error: ErrorType, CancellableErrorType {\n    case MyCancellableError\n}\nfunc someCancellablePromise() -> (Promise, () -> Void) {\nlet (promise, fulfill, reject) = Promise.pendingPromise()\nfunc cancel() {\n    reject(Error.MyCancellableError)\n}\n\n// stuff\u2026\n\nreturn (promise, cancel)\n\n}\nlet (promise, cancel) = someCancellablePromise()\ncancel()\n```\nThus you can see how the consumer is cancelling the promise.\n. PR for the docs is welcome. I would do it myself but am legally unable currently.\n. The library is complete. It's in maintenance mode. Nathan is more than capable of maintaining it and I am allowed to advise him. The situation is temporary. Though I have no timescale for when it will change.\nIt's because I joined Apple and they are very strict about outside work.\n. I will continue to be available here in the tickets whatever happens.\n. > What would be the benefit of removing the master repo?\nIf you delete the local cache it will probably fix your issue.\nBy pointing it directly at the repo it bypassed the CocoaPods local cache.\n. Don't use () it is confusing the swift compiler apparently. \n. So just .error {\n. In fact it is necessary to provide a parameter to the closure or the Swift compiler is confused with our error property:\n.error { error in\nThis way it works with parenthesis too:\n.error() { error in\nSwift compiler bug.\n. I am unable to imagine your situation, can you provide pseudocode? Also it is important to know which PromiseKit version you are using, and which Xcode. Thank you.\n. From what I could discern from your description I made this and you can see the order is as expected:\n\nDid I understand wrongly?\n. I just wrote this test that shows the finally finishes before any subsequent executions can run:\n\nCan you provide a test project that demonstrates your bug?\nWhat makes you say that the finally is not executed before getMessagesForUsers is executed?\n. Is your problem that you are not returning [self destroyToken:serverToken];?\nBecause then that asynchronous operation will not have completed before getMessagesForUsers runs.\nPerhaps you want:\n``` objc\n- (AnyPromise )getUsers\n{\n    __block NSString serverToken = nil;\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver  _Nonnull resolve) {\n    [self createTokenOnServer:^(NSString *token) {\n        serverToken = token;\n        resolve(token);\n    }];\n}].then(^(NSString *token) {\n    return [self fetchServerUsersUsingToken:token];\n}).finally(^id{\n    if (serverToken) {\n        return [self destroyToken:serverToken];\n    } else {\n        return nil;\n    }\n});\n\n}\n```\n. Indeed, you cannot. I\u2019m not sure why I thought this feature existed. The reason it does not is this:\nobjc\nsomePromise1.then(^{\n   return @1;\n}).finally(^{\n    // can't interfere with chain\n}).then(^(id obj){\n   // obj is @1\n});\nfinally is for book-keeping, it just passes through the @1 and thus can't interfere with the chain. If we made it possible to wait on a promise it would introduce ambiguity. Does the promise influence subsequent then values? If not does that mean that users must always manually pipe the value in future?\nHowever, I think there is absolutely a need for what you need. We should add it. We just have to be aware of what I just said and make sure it is clear.\n. Still I don't think it is necessarily what you want, you want to ensure create always follows a destroy, so really you need to do something like this:\n``` objc\n- (AnyPromise )getUsers\n{\n    __block NSString serverToken = nil;\n    __block static AnyPromise *destroy = [AnyPromise promiseWithValue:@1];\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver  _Nonnull resolve) {\n    destroy.finally(^{\n        [self createTokenOnServer:^(NSString *token) {\n            serverToken = token;\n            resolve(token);\n        }];\n    });\n}].then(^(NSString *token) {\n    return [self fetchServerUsersUsingToken:token];\n}).finally(^{\n    if (serverToken) {\n        destroy = [self destroyToken:serverToken];\n    }\n});\n\n}\n```\n. This is not elegant, but without a better idea of how to approach API for the pattern, this is what we have:\nobjc\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n    [self createToken].then(^(id token){\n        AnyPromise *requestPromise =  [self makeRequest:token]\n        requestPromise.finally(^{\n             [self destroyToken:token].finally(^{ resolve(requestPromise.value) });\n        });\n    });\n}];\n. Indeed, this is important.\nWe need:\n[promise then:^(id obj){\n   return something;\n}];\nWhich is less nice for objc, but will work better (still not great, but at least there is something) for Swift.\nBut you'd never use these for objc, so it's ok.\n. If you must use these objc versions from Swift you have to cast first. The format of them is not strict enough for Swift.\n. Yes, the README :p\nWhich also links to: http://promisekit.org/PromiseKit-2.0-Released\n. Pushing 1.7.2\nThe code I added was minimal and inefficient, please advise if you need other functions. Please feel free to improve the code!\n. No sorry. These are swift compiler bugs. I hate it too and hope further iterations of swift will be smarter about inferring closure return types. \nOne trick is to write it in one line. Another is wrapping it in a func.\n. What is the signature for Auth.setContact?\nAs it's common for Swift to give wrong errors based on errors inside the closure.\n. Probably here the problem was the return type of the enclosing function had a different promise type to that inferred by the return from the then.\nClosing, we can't fix this, it's up to Swift. The best we could do is have three thens, one for returning a value, one for returning a promise and one for returning an AnyPromise. Then Swift would not be confused.\nThough it is notable it would not fix any of the above errors, but hopefully the messages would be a little more helpful.\n. Should have been merged October 2nd.\n. This is what dispatch_promise is for.\n. Thanks, but there is no need to duplicate UIImagePickerControllerProxy to UIImagePickerControllerInfoProxy, we can just use UIImagePickerControllerProxy. Do you mind amending the patch?\n. Please merge @nathanhosselton \n. It is impossible to suppress deprecation warnings. I agree it sucks. I have not come up with a solution.\n. We can't remove this category from the umbrella pod because CocoaPods offers no way to selectively remove files based on deployment target. And people may still need this category. Splitting it out would be a breaking change. \n. I've removed deprecated stuff from PMK4 since it has been two years since the deprecation now. They are going to be still available in a subspec. Nothing else we've been able to do, removing them outright earlier would have been outrageous to people who needed them. CocoaPods doesn't let us turn on no warnings, and you can't turn off warnings in the source code in Swift (just objc).\n. Fixed again.\n. I'm not convinced our implementation in PMKHang is safe, it may lead to deadlocks. Use with caution.\n. Possibly the runtime is using the wrong overload of promiseViewController.\n. PR welcome, testing this is the tricky part, can advise how.\n. There is no branch, check out the tag.\ngit checkout -b 1.6.0\n. when waits for all the promises to succeed. Sounds like you want race which succeeds as soon as one of the promises succeeds.\n. http://cocoadocs.org/docsets/PromiseKit/3.0.0\n. The compile error is truth: there is no version of join that takes an array, there is only a Promise... version, so you need to:\nswift\njoin(a, b, c)\nThis could be considered a Swift issue, but because we can't say if there will ever be a fix we need another version of join that takes an array. PR welcome.\n. This is a project setup error, not a code issue.\nIt's hard to help without a lot more information, what targets to you have, what is in your Podfile? iPhone app? Mac app? tvOS app?\n. Works for me:\n\n. Merged: a334234d4248637dbe419b1d6dd7820abc45b75c\n. always cannot change the promise chain\u2019s value this is deliberate. What if the chain errors?\nswift\nfoo.then {\n    throw Error.foo`\nalways {\n    return 1  // cancels error\n}\n. Looks correct to me.\n. I have removed the pre-built binaries as it is foolish to build them since Swift ABI is not stable so every Xcode release they will be invalid.\n. I have changed it to a url to the README.\n. I wish I'd just gone with a license without restrictions.\n. @ehiynh it is documented at PromiseKit.org\n. I have added a new feature to 4.0 allowing you to define PMKDisableWarnings to remove this warning.\n. It shouldn't come up for race. If it does it is literally a bug (IME). The promises should be retained by the tasks that they represent until the tasks are complete, if it is only race that is holding them then it is a bug.\n. Feels outside the scope of PromiseKit to me.\n. This has changed with 3.0, it's easy enough to tell, refer to the source documentation for details, alt-clicking in Xcode is sufficient:\nswift\nNSURLConnection.GET(\"http://placekitten.com/\\(width)/\\(height)\").asImage().then { (image: UIImage) in\n    self.imageView.image = image\n}.catch { error in\n    // If PromiseKit could not decode an image (for example, if you made\n    // a mistake and the endpoint actually provides JSON), then Promise<T>\n    // errors. AnyPromise would instead `then` a JSON NSDictionary, and if\n    // you then tried to set the imageView\u2019s image to that dictionary,\n    // your code would crash.\n}\nThe docs you reference are technically correct since they refer to the 2.x release, and at that time the code you used was correct.\n. Yes it's possible. Can't detail code yet. Swift or ObjC?\n. Can we get a code example? For a branching example would be:\n``` swift\nfoo.then {\n  //\u2026\n}.then.then\u2026\nfoo.then {\n  //\u2026\n}.then.then\u2026\n```\nHere cancellation would work provided you cancel foo. How do you cancel foo? Like so:\n``` swift\nfoo = bar.then {\n   throw Error.Cancel\n}\nenum Error: ErrorType, CancellableErrorType {\n    case Cancel\n}\n```\nSo is this not sufficient? I'm guessing, no.\n. Closing pending feedback, please re-open if you want to continue the discussion.\n. @ded for your usage you need to implement your own cancel method on a subclass of promise. e.g.:\n``` swift\nclass MyPromise: Promise {\n    var mytask\n    let reject: (ErrorType) -> Void\nfunc cancel() {\n    mytask.cancel()\n    reject(NSError.cancelledError)\n}\n\ninit() {\n    self.init { fulfill, reject in\n        self.reject = reject\n        mytask = MyTask()\n        mytask.startWithCompletionHandler {\n            fulfill()\n        }\n    }\n}\n\n}\n. swift\npublic class MyPromise: Promise {\n    private var mytask\n    private let reject: (ErrorType) -> Void\npublic func cancel() {\n    mytask.cancel()\n    reject(NSError.cancelledError)\n}\n\npublic func static go() -> MyPromise {\n    var reject: ((ErrorType) -> Void)!\n    let promise = MyPromise { fulfill, r in\n        reject = r\n        mytask = MyTask()\n        mytask.startWithCompletionHandler {\n            fulfill()\n        }\n    }\n    promise.reject = reject\n    return promise\n}\n\n}\n.objc\nfoo.then(^{\n    @throw NSError.cancelledError;\n})\n``.URLSessionalways calls its completion block and then afterwards releases its completion block, so: no. This is the kind of retain cycle you *want*, it retains the closure and surrounding code until you don't want it anymore. If you want to make your life more difficult you could do[weak self]but it isn't necessary for 99% of usages.. Amendment: however if you didn't start thetaskwithresume()` it would be a retain cycle. But this is done above immediately so we're good.. You don\u2019t need to subclass to use this pattern.. FYI for everyone we are considering a patch to do the original question in #899 . Makes sense to me. I think the Boolean parameter is the best option. \n. I will implement:\nswift\nwhen(foo, bar, errorPolicy: .Raw).catch { error in\n    // errorPolicy has a default of .Wrapped\n}\nUnless anyone has concerns or improvements.\nI reserve the option to do it like:\nswift\nwhen(foo, bar).unwrapError().catch { error in\n    //\u2026\n}\nBecause we have a lot of when functions and possibly we cannot do it with the parameter.\n. Thinking more about it, most of the time you don't care about the index, you care about the error. For PMK4 it would be nice to have a solution where the error is unchanged by default and the index can be obtained some other how.\n. Thinking about it more, maybe this is in fact a bug? It could prevent you correctly interpreting errors.\n. K I'm going with the idea that only the immediate caller cares about the potential index of the error, thus we will return a subclassed promise that offers a wrapError function that will add the index to the error.\nThis makes sense IMO because imagine receiving a promise from a function and catch on it, you don't care a when happened, you don't care about the index, but you may care about certain other classes of errors the when error may wrap and want to react to that. You don't want to have to add a pattern for when errors just in case!\nLet me know your thoughts.\n. K, this morning I came up with (for PMK4):\n``` swift\nfunc when(fulfilled: a, b) -> Promise<[T]>\nfunc when(resolved: a, b) -> Promise<[Result]>  // cannot fail\n// deprecate join()\n```\nThinking on these issues, join seemed wrong to me because it forces you to write the same code in both a then and a catch, since if you are using join you clearly want to act on errors if they occur on the non-error path or you would use when.\nI considered changing join's behavior, since we are doing a major release, but instead felt things are clearer if we instead add mandatory parameters to when and differentiate it. This is more like Swift 3\u2019s naming.\nThoughts?\n. So with this, if you need the index, either use when(resolved:) or you can adapt your when(fulfilled:) to:\nswift\nvar index: Int!\npromises = (0..<promises.count).map{ x in promises[x].recover{ err in index = x; throw err } }\nwhen(fulfilled: promises).catch { error in\n    // use error & index\n}\nRequiring the index is rare. This way consumers of promises will not need to defend against Error.when or Error.join.\n. Closing with solution committed to PMK4 (swift-3.0 branch).\nLet me know if it isn't any good, or any concerns and we'll re-open.\n. The crash is because you are calling the then block:\nobjc\npromise.then(^{\n    //\u2026\n});\n\nIf you just did [promise then]; or promise.then; it would not crash.\n\nCalling a nil block crashes:\nobjc\nvoid (^block)() = nil;\nblock();  //CRASH!\nThis cannot be fixed. It is because of the dot-notated syntax, and is unfortunate. This is documented at http://promisekit.org.\n. We should start a Swift 3 branch, which necessitates a bump to PromiseKit 4.0, and in there remove the  error property.\n. Maybe we should just bump it now, the lack of a stable ABI as things stands makes maintaining semantic versioning a futile effort.\n. > The easiest fix from a library standpoint would probably be to just duplicate the error method and properties with different names,\nGreat point, not sure why I didn't think of this. PR welcome. My initial ideas would be onError and errorValue\n. Can you list concrete situations and use-cases where you have needed this? Not saying no, just want to understand the problem properly.\n. It would have to be something like:\nswift\nretry(times: 2, delay: 2) {\n    NSURLSesssion.GET(url)\n}.then { data in\n    //\u2026\n}\nBecause the thing to be retried has to be captured in a closure or we could not retry it.\n. I'm still reluctant to add this as I feel it is an anti-pattern to retry, can someone provide a concrete example of a time it was important to have this feature?\n. The endpoint cannot be fixed? Adding retry to the library feels like fixing things with duct tape when really we should be fixing the underlying cause properly.\n. Here\u2019s code you can use:\nswift\nfunc retry<T>(var times: Int, body: () -> Promise<T>) -> Promise<T>\n    func attempt() -> Promise<T> {\n        return body().recover { error -> Promise in\n            guard times-- > 0 else { throw error }\n            return after(2).then(attempt)\n        }\n    }\n    return attempt()\n}\nUsage:\nswift\nretry(2: times) { flakeyTask() }.then {\n    //\u2026\n}\n. catch behaves the same as recover in ObjC. Open new ticket. \n. We had one, it didn't get maintained, so I removed it.\nThe commit history has all the information, I don't really understand why it is hard to read.\nEdit: like there is extra crap to skim for sure, but I just opened the history and there is maybe a dozen commits between 6.1.2 and 6.2.0, so it's not that bad.. I added the crux in the release notes: https://github.com/mxcl/PromiseKit/releases/tag/6.2.0. Well, sorry, but I haven't time to maintain the entire library and also update secondary metadata. Personally I don't think it's that hard to see which of those commits matter, and since nobody else is willing to step in and do this work, that's something you will just have to do. Like frankly, since you have to do the work, why don\u2019t you contribute the Changelog?. Mostly I\u2019m the one doing the \u201cPRs\u201d so\u2026\nReally GitHub should auto generate the changelog, all it has to do is allow us to specify which files to exclude and then put all the commit messages together. It could even link to the code.\nHaving this file exist separately seems like working harder not smarter.. The core is Swift. You can use PromiseKit 1, it sounds old but really it's just as good. PMK1 is all ObjC.\n. String is bridged to NSString in such situations and NSString is an object.\n. > Should I change it to Any?\nAnyPromise is for ObjectiveC (mostly), really it should be called AnyObjectPromise but that was unwieldy.\n. PR looks good.\n. 2) is impossible, Objective-C cannot bridge things that aren't AnyObject.\n. Merged: d1f77c76c2852dc24a79b92c1596ec8c9dc5a1ac\n. This is almost certainly a bug in Swift itself.\n. Swift bug, please report to http://bugs.swift.org\n. You could add a copy files phase to your app's project?\n. Thinking about it, that's even more than necessary, just drop the files into your app's project from the Carthage checkout. On fresh clones the files will show up red until Carthage is run.\n. We could add another xcodeproj with schemes for each category. Put it in: Categories. Then we won't pollute the main xcodeproj with all the other schemes which is really our concern since managing the project is already tedious.\n. > The issue is tricky in this project. We have cocoapods + carthage . Carthage is used to import 1 library. this one lib imports Promisekit.\nUgh. Yeah. I hate that #if anyway. Maybe I can figure out a solution by building two Frameworks in CocoaPods\u2026\n. I honestly don't think we can manage this, it is quite a lofty maintenance burden on top of that which we already have regarding all the categories (podspec + tests).\nI maintain the solution is to drop the files from the Carthage checkout into your xcodeproj. Carthage checkouts the files into your source tree, so it seems an acceptable compromise.\nWhen and if Xcode allows one scheme for multiple platforms we will add schemes for the categories, modify our tests to use the schemes and then also be able to easily test tvOS and watchOS which currently we do not for the same reasons outlined above.\nSorry.\n. Since my discovery of Single-scheme, multiplatform targets I have implemented this as requested.\nEach category is now a separate repository at https://github.com/PromiseKit\nSo you can request them separately in your Cartfile.\nFor CocoaPods we import the sources for the categories using git submodules, so nothing has changed for CocoaPods users.\nNote, this is only supported for PromiseKit 4 which is Swift 3 only.\n. I've removed deprecated stuff from PMK4 since it has been two years since the deprecation now. They are going to be still available in a subspec. Nothing else we've been able to do, removing them outright earlier would have been outrageous to people who needed them. CocoaPods doesn't let us turn on no warnings, and you can't turn off warnings in the source code in Swift (just objc).\n. https://github.com/PromiseKit/Foundation\nFFR you can read the .podspec file for any CocoaPod to have a direct pointer to where things live.\nEdit: OK, there is no subspec for NSURLConnection actually. I never wrote that, I think. Sorry.\nIf it's any consolation I didn't want to remove it, but CocoaPods and Apple's tooling provide no way around this, keeping them there results in warnings for all users. So they had to be removed rather than force all users to ignore warnings or disable them.. It's a single file though, so you can just drop it into you project and it'll just work.. One trick is to make them void:\nswift\nwhen(a.asVoid(), b.asVoid(), c.asVoid(), d.asVoid()).then { _ in\n    print(a.value, b.value, c.value, d.value)\n}\nThere's no other elegant answer since Swift has no mechanism to help us here.\n. Sure.\n. The reason this wasn't there is: it crashed certain versions of the Swift compiler.\nProbably we're safe now, but well\u2026 just a warning.\n. Platform & Xcode version?\n. This is pretty much the same platform/Xcode as everyone else, so I wonder why nobody else is getting this error?\n. Yes, PR welcome, I'm sure this is the correct thing to do. My reason for being more specific was to reduce the symbol weight of importing PromiseKit as much as possible (we only need the typedef for queues), but I don't want to break things.\n. Surely your synchronization tools can handle this?\nI understand your pain, but we hardly consider Windows support important. Now, if there is absolutely nothing you can do about this we'll change it, but I think you need to demonstrate that you have tried first before we make PromiseKit slightly less good to support a platform that we don't in fact support.\n. > but we hardly consider Windows support important\nThis was badly phrased. If and when using PromiseKit on Windows is viable and useful, then we'll consider it important.\nAnyway, so git itself cannot checkout the folder? Jeez. Well if this is the case then we'll rename it. /cc @nathanhosselton \n. This was fixed.\n. Last time I tried I could not make the Optional variant for AnyPromise work, so you have to unwrap it manually.\nI'm assuming someOtherAnyPromise() returns an Optional<Promise>\n. Be explicit with your return types, Swift is inferring the wrong type apparently. See the API options.\n. This merges master. So that's not what we want.\nI guess it didn't occur to me that you can't PR onto a tag. We'll need to create a branch. We never intended not to, just when we split 1.x off we didn't need one at the time.\n. Appears good! \ud83d\udc4d\ud83c\udffb\n. Ideally, you would squash these commits. You can force push back to your branch to fix the PR.\n. Many thanks! \ud83c\udf86@nathanhosselton please merge!\n. Though check for API breakage, we may need to bump the major version again\u2026\n. We have after(), which appears to be the same as Bluebird\u2019s delay.\nWe don\u2019t have anything that satisfies your needs directly.\n. Here is the linked gist as Swift:\n``` swift\nimport PromiseKit\nenum Error: ErrorType {\n    case Timeout\n}\nfunc poll(signal: () -> Bool, interval: NSTimeInterval, timeout: NSTimeInterval) {\n    func pollRecursive() -> Promise {\n        return signal() ? Promise() : after(interval).then(pollRecursive)\n    }\nreturn race(after(timeout).then { throw Error.Timeout }, pollRecursive())\n\n}\n/*\n * Every 2 seconds, call a signal function that returns true 25% of the time. Timeout after 10 seconds.\n /\npoll(randomSignal, interval: 2, timeout: 10).then(print);\nfunc randomSignal() -> Bool {\n    let r = arc4random_uniform(4) == 0\n    print(r ? \"Complete\" : \"Not complete\");\n    return r\n}\n```\n. Indeed, there's two separate chains, that later combined, the timeout only stops the left chain, so the right chain will continue until it errors.\nHere's the fix:\n```swift\nenum PromiseError: Error {\n    case Timeout\n}\nfunc poll(signal: @escaping () -> Bool, interval: TimeInterval, timeout: TimeInterval) -> Promise {\n    let timeout = after(interval: timeout).then { throw PromiseError.Timeout }\nfunc pollRecursive() -> Promise<Void> {\n    guard timeout.isPending else { return timeout }\n    return signal() ? Promise(value: ()) : after(interval: interval).then(execute: pollRecursive)\n}\n\nreturn race(after(timeout, pollRecursive())\n\n}\npoll(signal: randomSignal, interval: 1, timeout: 2).then {\n    print(\"done\")\n}.catch { error in\n    print(\"error\")\n}\nfunc randomSignal() -> Bool {\n    let r = arc4random_uniform(4) == 0\n    print(r ? \"Complete\" : \"Not complete\");\n    return r\n}\n```. Merged\n. Cool. I think the only reason this was not there previously was that it crashed Swift.\nHowever we must have tests verifying this stuff.\n. Merged #393\n. private func connect() -> Promise<Void> {\n    return tryToConnect()\n        .then { payload -> Void in\n            // do something here\n            // don't return anything\n        }\n        .onError { _ -> Void in\n    }\n}\nThis is because onError returns Void, not Promise<Void>.\n. The categories are convenience functions, nothing is stopping you from writing your own promise wrappers for NSURLSession. Please do so!\n. I like it.\n1. I think there should be just one function, do it in objc so it is accessible from both\n2. I think it should be named PMKDefaultDispatchQueue() since that is more consistent with other such things in PromiseKit.\n. LGTM! Many thanks.\n. Well, this isn't very \u201cpromisey\u201d. Seems like there should be a Bool that defines if the promise fulfills after completion or before completion. Maybe I'm forgetting why we haven't already done this though.\n. swift\npromiseViewController(vc, fulfill: .OnceDismissed).then {\n     // other value would be .BeforeDismissal\n     // default would be .OnceDismissed\n}\nWill implement unless you have any thoughts or concerns.\n. Merged.\n. I cannot reproduce with Xcode 7.3.1 and swift-2.2-minimal-changes:\n\n. I cannot fix this without a TestCase, if someone could help me out\u2026\nAlso, does it happen only on deployed apps on devices? Or in debug simulator builds too?\nIt's likely a Swift bug, but if I can reproduce I can determine a workaround.\n. Closing due to lack of responses.\n. IME this happens when there are multiple functions with the same name and different signatures.\n. > I wonder do we really need\n\nextension NSNotificationCenter {\n    public class func once(name: String) -> NotificationPromise\n}\n\nI wish I hadn't added it considering this bug. But sadly we can\u2019t remove it without breaking API compat. OTOH Swift makes keeping long-term major semantic versions near-impossible  (considering bugs and regular syntax changes) so maybe we should just drop it and bump to 4.\nNOTE THIS MEANS A PREMATURE BUMP TO PMK4\n. You want: pod update PromiseKit\n. Basically a Swift compiler issue then I guess, since the AnyPromise variant of then exists and it should have picked it.\nWith PMK4 we are ensuring the ObjectiveC versions of the categories do not show up in Swift at all, which will help here.\nUnfortunately I cannot specify to Swift to disallow creation of Promise<AnyPromise> like we do for Promise<ErrorProtocol> since it requires protocols.\nThanks for the report, it is interesting and will inform future development.\n. Yes we didn't write the NSURLSession categories for ObjC. If you need them then maybe you could write them?\n. Blocking the main thread just means Apple will reject your app (they have been known to reject for UI freezes) and it will crash (you get 20 ish seconds of block time before the kernel ejects you).\nSo\u2026\n. We do provide PMKHang() in ObjC, but it is strictly meant for testing purposes we don't provide it in Swift. We could provide it in Swift, but you probably don't want to hang the main thread so maybe you should think of some other solution?\n. This is probably a solution for you:\n``` swift\nvar addObjectPromise = Promise()\nfunc addObject() -> Promise {\n    addObjectPromise = addObjectPromise.then {\n        return fetchObject()\n    }.then { existingObject -> Promise in      \n        self.array.append(existingObject)\n        return self.deleteObject(existingObject)\n    }\n    return addObjectPromise\n}\nfunc deleteObject(myObject: MyType) -> Promise {\n    return addObjectPromise.then {\n        if let i = self.array.indexOf(myObject) {\n            self.array.removeAtIndex(i)\n        }\n    }\n}\nfunc fetchObject(id: String) -> Promise {\n    return addObjectPromise.then {\n    // throw instead of returning an Optional\n    // -- promise chains should continue with successes only\n\n    guard let obj self.array.filter {$0.id == id }.first else { throw Error.NoObject }\n    return obj\n}\n\n}\n```\nIt's all main thread (then runs on the main thread by default), this is the way you would use promises to do what you want. Please note, nothing is blocking here, if you need the code to block, then you cannot use promises.\nFeel free to ask any questions or re-open the ticket if you need more help.\n. Look at the code in PMKHang.m, you can do something similar.\n. I just discovered this which will allow you to wait on promises: https://github.com/yannickl/AwaitKit\n. Good catch, a correct fix would be to specify both @\"message\" and @\"messsage\" so we are backwards combat just in case anyone depends on this key.\n. It appears this effort was duplicated. Sorry.\n. You didn't say why you need this.\n. K, this seems like a good enough use-case to me. There have been good enough uses in the past, the problem is Swift+Xcode has hated error having another parameter and has been busted because of it.\nI suggest we roll this into PMK4 / Swift3, if you can wait that long? I guess not.\nIn the meantime I'm cool with an additional method like:\nerrorOnQueue(\u2026)\nUgly, but I really don't want to break compilation for Swift 2.x users (it breaks the parser, foo foo foo).\n. LGTM thanks!\n. Sounds like a \u2014the-horror!\u2014 CocoaPods bug.\n. You have not provided enough information for us to help you, Xcode version? PromiseKit version? How did you install PromiseKit? Etc.\n. You're building at the command line with xcodebuild? Does the same happen in Xcode with the Archive option?\n. I believe this may be a change in how CocoaPods specifies its import path since 1.0.\n. From the source code:\nobjc\n/**\n The provided block is executed when the receiver is rejected with the specified policy.\n @param policy The policy with which to catch. Either for all errors, or all errors *except* cancellation errors.\n @see catch\n*/\n- (AnyPromise * __nonnull(^ __nonnull)(PMKCatchPolicy, id __nonnull))catchWithPolicy;\nWhere PMKCatchPolicy is:\nobjc\ntypedef NS_ENUM(NSInteger, PMKCatchPolicy) {\n    PMKCatchPolicyAllErrors,\n    PMKCatchPolicyAllErrorsExceptCancellation\n};\nSo, per the declaration, the usage is:\n``` objc\npromise.catchWithPolicy(PMKCatchPolicyAllErrors, ^(NSError *error){\n    //\u2026\n});\n```\n. I agree in principle, I worry people won't realize they need it, but ultimately agree Carthage users are the kinds of users to read the docs. LGTM.\n. WatchOS 1.x didn't support such things, WatchOS 2.x does.\n. The history of this stuff is fuzzy for me. Anyway if it works, it's great! and much thanks.\n. Merged: aa831d1e85a087cbdd6c7c1728c38b9262284380\n. Dupes #415. Please confirm.\n. Code example please. \n. Here's the code: https://github.com/mxcl/PromiseKit/blob/master/Categories/Foundation/NSURLConnection%2BAnyPromise.m#L82-L177\nAs @nathanhosselton says, it will only be nil if it is not set.\nI will try a non-promised NSURLConnection and see if I get a URLResponse.\n. I made a test project: https://www.dropbox.com/sh/6w1bvpomjpo6sf6/AAA81bFuPMTG255ujK-UmPWha?dl=0\nThe NSURLResponse is indeed nil, so there's nothing we can do.\n\n. LGTM\n. Just out of interest, Swift version? Xcode version?\nSwift should handle this, I think, but since it doesn't, LGTM.\n. Ahh ok, yes I was expecting swift to handle the [Void] case, but indeed I acknowledge that what you really want is a Void one, so indeed, provided this doesn't make join more ambiguous to use, LGTM.\nI worry about the ambiguity when trying to write simple chains.\n. Merged: 60ac25210fcacce01aabaa862f5876417cf07b9c\n. Hard to debug without some idea of the input that causes it. Unless you're saying it happens for all NSURLSession promise usage?\n. I think this was: #323\n. Yes, sounds like you should return the same Promise in both cases. This is fine, you can then off a promise as many times as you like.\n. > The issue is that when I throw something from recover. It does not throw it back to the actual calling function get(), as it does for line //1. Throw DPError.Error Because of this I am not able to catch any error.\nWell, yes. This is expected. When you do this:\nfunc get(req: NetRequest, fn: NSData? -> ResponseModel?) throws -> Promise<(NetResponse, ResponseModel)> {\n    throw DPError.Error\n}\nYou are throwing synchronously.\nWhen you do this:\nfunc get(req: NetRequest, fn: NSData? -> ResponseModel?) throws -> Promise<(NetResponse, ResponseModel)> {\n    return Promise {\n        throw DPError.Error\n    }\n}\nYou are throwing asynchronously. The error is thrown inside the promise chain, which happens later.\nYou need to add an error handler for the promise chain in order to catch the error.\n. Please provide the crash backtrace.\n. Interesting. My first suspicion is: Swift bug, but we'll figure it out.\n. > Promise.(catch_(policy : ErrorPolicy, body : () -> ()) -> Promise<A>).(default argument 0) (Promise.swift:0)\nThis is suspicious. We don't have a catch function in PromiseKit 3. We do have a catch unavailable function, that aborts(). And the next line in the backtrace is the abort.\n\nDowngrading to PromiseKit version 3.0.3 while commenting out the NSNotificationCenter+Promise.swift file allows the previous code paths that were crashing to work.\n\nThis is unexpected. Your code doesn't use NSNotificationCenter.\nFinally:\nswift\nfunc toggleNetworkSpinnerWithPromise<T>(funcToCall: () -> Promise<T>) -> Promise<T> {\n        return Promise { fulfill, reject in\n            firstly {\n                setNetworkActivityIndicatorVisible(true)\n                return funcToCall()\n            }.then { result in\n                fulfill(result)\n            }.always {\n                setNetworkActivityIndicatorVisible(false)\n            }.error { err in\n                reject(err)\n            }\n        }\n    }\nCould be simply:\nswift\nfunc toggleNetworkSpinnerWithPromise<T>(funcToCall: () -> Promise<T>) -> Promise<T> {\n    return firstly {\n        setNetworkActivityIndicatorVisible(true)\n        return funcToCall()\n    }.always {\n        setNetworkActivityIndicatorVisible(false)\n    }\n}\n. Both backtraces confirm that the unavailable function _catch is being called, which explicitly aborts. This is unexpected. PromiseKit itself doesn't call this function. Certainly not within the always function.\n_catch: https://github.com/mxcl/PromiseKit/blob/fbccb01181bd93693de5292b987ab59190e71c9d/Sources/Promise.swift#L483\nI suspect that there is a Swift optimizer issue at play. Especially sine removing the NSNotificationCenter code supposedly fixes the issue.\nCan someone construct me a test case project? And then specify explicitly which Xcode I need to use to reproduce it?\nAlso does upgrading PromiseKit to the latest version: 3.2.1 help?\n. > Dropping the catch on the error in my function.. I am guessing it will still reject the promise automagically then?\nThis is how promises work, the values or errors always cascade.\n. I cannot reproduce, here is my testcase:\n- https://dl.dropboxusercontent.com/u/97921/testcase-443.tar.bz2\n- Xcode 7.3.1\n- PromiseKit 3.2.1\nCan you verify if this crashes for you when you Run the test case?\n. I used Xcode 7.3.1 to deploy the above testcase onto my iPad running 9.3.3 compiled as both debug and release. I did not get a crash.\n- Xcode 7.3.1\n- PromiseKit 3.2.1\n- Swift 2.2\n- iOS 9.3.3\n- Deployment target: 9.3\n- SDK iOS 9.3\nIf those affected could give me the above bullet points, and if they can, try the test case, it would really help get this fixed. Thanks.\n. Closing due to lack of responses.\n. Synopsis of what you want? Link doesn't really explain itself.\n. Makes sense. We should have this.\n. Seems like some parameters to when may be logical? Or would this just be non-intuitive to people experienced with Promises?\nswift\nwhen(promises, concurrently: 5).then {\n    //\u2026\n}\nThe maxQueue parameter seems a little esoteric.\n. > I believe, we actually cannot use/extend when because it accepts promises, so if we already have the promises, it immediately means that they already started resolving process (but we want to postpone it).\nYes I see, one of the features is that the promises are only generated on demand, which I like.\nAlso, I understand the maxQueue feature better now as well, and indeed: seems good.\nPerhaps there is a better name than \u201cqueue\u201d since it is concurrent and also debounces.\n. Please \ud83d\udc4d\ud83c\udffb\n. Merged: e50dc323c154f110a8defc819b916c09377e102e\n. I wonder about the maxQueue parameter (again), the example given was for concurrently: 1, maxQueue: 1, are there other situations where maxQueue would be something other than 1? If not then I don't think we should have the parameter in general, and instead have a separate function of the 1 case. The reason I think this way is the error that may be thrown. I strongly dislike functionality that may error at runtime and which you cannot reason about whether or not it will error at runtime. The maxQueue parameter may error at runtime and you cannot be sure if it will or not.\nThinking about, eg. a save queue, you want at most TWO promises in the queue, the one executing and the one pending. Thus if a third is added you would want the second to be discarded and the third to be run instead once the first is finished.\nSo well, indeed, we don't have a good answer here yet.\nI apologise. I know how much it sucks to write code you want in a library and have it endlessly debated, the thing is: I feel PromiseKit is in a pretty good state right now, and I only want to add features to it that are pretty good. So we are being cautious.\nLibraries should guarantee quality, in my opinion. And it's so important that they don't add features once their users trust them, and that those features are not carefully considered.\n. Closing in lieu of #449.\n. Dupes #415?\n. Hmm, seems like a bug. If you have time can you construct a test project? Otherwise we will get round to it.\n. We consider it an anti pattern to have pending promises that are deallocated. If you open a new ticket we can discuss it further.. One of your promises is neither fulfilled or rejected. This will lead to bugs. Figure out which promise it is: trace all asynchronous routes and look for an if or something like that where the else is not calling either fulfill or reject.. @seriyvolk83 the fulfill and reject functions retain the promise, so unless you are using promises incorrectly it is not how you are thinking it is.. Looks great. Nice use of AnyGenerator. I approve of using the stdlib.\n. Great, appreciated :)\nThe documentation for this function is a copy and paste from the other when. Can we make it describe what is different?\nRunning all PMKTests crashes for me:\n\nAlso, this is not thread safe.\n. I fixed the issues in subsequent commits. Though please review!\n. No reason, PR welcome!. Merged: https://github.com/mxcl/PromiseKit/commit/633fa83ca0c309dc54837db889fab820db5f27a3\n. Ideally PMK4 would support both with #if. Pragmatically, I think it would make the code unmaintainable.\n. Many Swift types cannot be represented by id so it would be impossible to use those types in Swift if the core was ObjC. If you need a pure ObjC version of PromiseKit we still maintain version 1.\n. @nathanhosselton please merge\n. Seems that all branches have default_subspecs removed to me.\n. Would merge, but the diff is much more than one line due to all the whitespace changes.\n. Please merge @nathanhosselton \n. What confused you as to thinking PMK3 is just Swift?\n2nd paragraph in README is: \n\nPromiseKit is a thoughtful and complete implementation of promises for iOS and OS X with first-class support for both Objective-C and Swift.\n\nSo presumably some other part made you think this didn't apply to version 3?\n. Website branch: https://github.com/mxcl/PromiseKit/tree/gh-pages\n. Well. I deliberately didn't want a separate license file. It's untidy.\n. Put a link to the README in the license section of the podspec.\n. If the parameter is an NSError, then it is has a code property. If it is not an NSError, then it depends on its type.\n. swift\nfoo.catch { err in\n    let code = (err as NSError).code\n}\n. ErrorType is the Swift error type, so that's what you get.\nThe only way we could do otherwise is to have the type of a Promise\u2019s error be generic too, but this would make it impossible to have different promises with different error types be chained without forcing the user to provide some kind of glue code every time a promise is chained.\n. Could you provide a usage example showing what you want?\n. swift\nsomePromiseStuff.then { _ -> Promise<Void> in\n    return Promise { fulfill, _ in\n        func go() {\n            if thereIsNotEnoughItemsLoaded {\n                load().then(go)\n            } else {\n                fulfill()\n            }\n        }\n        go()\n    }\n}\nThere could be API added for this.\n. It seems to me this an adaption of our current Queue open issue where instead of specifying a maximum concurrency, you provide a function that decides when to stop.\n. Merged: e50dc323c154f110a8defc819b916c09377e102e\n. We have recover for this.\nhttps://github.com/mxcl/PromiseKit/blob/master/Sources/Promise.swift#L443\n. Try setting PMKSetDefaultDispatchQueue(zalgo), this will remove the use of dispatch_async when calling then without any other parameters. Do not do this in production code (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\nProbably it is possible for us to remove dispatch_async use when the then will complete on the current queue and a \u201cqueue-leap\u201d has already occurred, so will leave this ticket open to track the research there.\n. I have updated the documentation for PMK4 to suggest the above trick.\n. Dupes #415 \n. Patch doesn't update the Xcodeproject.\n. @nathanhosselton please merge\n. @nathanhosselton please merge\n. swift\ntwo().always {\n    return one()\n}\nPresuming one() and two() return Promise.\n. then in swift returns Promise. So error and recover should be available. If they are not then something has gone with your build. Please provide complete build details.\n. Oh right, yeah AnyPromise has no catch in Swift.\n. ``` swift\nsomePromise.then { object1 -> Promise in\n    return FooPromise.then{ ($0, object1) }\n}.then { (foo, object1) -> Promise in\n    return BlaPromise.then{ ($0, foo, object1) }\n}.then { (bla, foo, object1) -> Void in\n    // TADA!\n}.error {\n}\n```\nOr:\n``` swift\nsomePromise.then { object1 -> Promise in\n    return FooPromise.then { foo -> Promise in\n        return BlaPromise.then { bla -> Void in\n            // access foo or object1\n        }\n    }\n}.error {\n}\n```\nReal world usage may help; generally if you need to access previous values from previous promises\u2013in my experience at least\u2013there's a better pattern.\n. Probably we could expand this section to include this trick: http://promisekit.org/tuples/\n. Could you provide a real-world usage to help us continue to understand the problem?\n. Please provide code example\n. Well, this is naively suspicious:\n__unsafe_unretained AnyPromise *promise;\nThe handlers do not hold onto their promise (only the new promise they return), so if nothing else is holding onto the promise it will deallocate.\nHowever since you say appears in call stack in a then off of that promise, it must be resolved, so\u2026 I'm confused.\nThere are 4 promises here:\n1. The promise from the NSInvocation\n2. The promise returned by catch\n3. The promise returned by the then off the catch\n4. The promise returned in the then\n2 is retained by the block you pass to catch (strictly a block in PMK retains your handler and the promise), 3 is returned by the block you pass to then, so unless I'm confused about how the retains are going on I can't immediately see where the deallocation is happening before a promise can be resolved.\nWhen a value is returned by a handler the promise is resolved synchronously so it should not be able to deallocate in between the value being returned and the promise being resolved by that value.\n. Cannot reproduce this other error with my initial experimentation.\n. This doesn't make sense, we don't provide a function with that signature anywhere.\n. I understand the issue, the objective-c variant is being imported by the new Swift importer from promiseViewController to promise(_ viewController: though that is surprising since it shouldn't drop the parameter name. Whatever I have a fix coming.\n. Sounds like you need a clean build.\n. K, looking properly I see that the missing symbol is from your code:\nUndefined symbols for architecture arm64:\nFeed.getData ([String: AnyObject]) -> Promise<AnyObject>\nThe missing symbol is Feed.getData(_: [String: AnyObject]).\nDid you also upgrade the compiler when you upgraded PromiseKit? Possibly the compiler is mis-compiling this function. Try renaming it.\n. Is it possible you haven't added ExpSwift to the link phase of ExpSwift_Example?\n. There's definitely a bug in either Xcode, CocoaPods or the Swift compiler here.\n. Yes, you can, we provide convenience functions for when that allow a tuple with varying T for less than three, with more than three they must be the same type. I refer you to the source code for documentation.\n. If you got questions, please ask, closed as I'm doing major cleanup but still happy to help.\n. Please specify the exact error message.\n. Did you add PromiseKit to your app's dependencies? Seems it is not being built.\n. Oh OK, Carthage. So, with Carthage you don't drag in the project. You need to add PromiseKit.framework that is built in the Carthage/Build/ directory to your app\u2019s \u201cBuild Phases\u201d link libraries section. Then it will import. Further docs at Carthage's website.\n. I just created a new Xcode 8 beta xcodeproj and added a Cartfile:\ngithub \"mxcl/PromiseKit\" \"swift-3.0\"\nAfter carthage bootstrap I dragged the iOS PromiseKit.framework into \u201cembedded frameworks\u201d in the Project settings. I added import PromiseKit to one of my swift files and added some PromiseKit code. Built, ran. It works.\nSo\u2026 it should work.\n. You didn't sudo xcode-select --switch /Applications/Xcode-beta.app first. It's compiling with swift 2.2.\n. Is your problem solved?\n. Re-open if not solved. Thanks.\n. - Don\u2019t drag the xcodeproj into your project with Carthage. I suggest deleting it from your project\n- Ensure you drag the correct .framework into your embedded binaries section, You need to drag the iOS one.\n. It's odd that it is even building PMKiOSUITestsHost since that is a test.\n. Fixed: https://github.com/mxcl/PromiseKit/commit/78af1260bbf023c13e41b1047a2e34b8fe528c24\n3.4.1 tagged.\n. Just pushed. Should be fixed, let me know if not.\n. Cocoapods will automatically install OMGHTTPURLRQ since it is a dependency of PromiseKit, so you're doing something wrong with CocoaPods. What commands did you run?\n. You're not using Xcode 8 beta?\n. Done:\n$ carthage bootstrap\n*** No Cartfile.resolved found, updating dependencies\n*** Fetching PromiseKit\n*** Checking out PromiseKit at \"1.7.3\"\n*** xcodebuild output can be found in /var/folders/9p/55y6r8hs3yz2qkhvf74gc0gh0000gn/T/carthage-xcodebuild.nOhY3G.log\n*** Building scheme \"PMKmacOS\" in PromiseKit.xcodeproj\n*** Building scheme \"PMKiOS\" in PromiseKit.xcodeproj\n$ cat Cartfile\ngithub \"mxcl/PromiseKit\" ~> 1.7\n. In RxSwift terms, Promises are a reactive pattern for asynchronicity.\nPromiseKit take the good parts of reactive programming and apply them to the hardest part of pure Swift development.\nRxSwift requires you to commit fully to a paradigm shift in how you program. If you do it right your code will be more robust, but you may have trouble finding other developers experienced with reactive paradigms to work on the project.\nPromises make code that is pretty clear to most developers.\n. Closing due to stagnation.\n. Thanks, these should have been redirecting so I have also fixed the redirects:\nhttp://promisekit.org/introduction/\n. Pushed a fix.\n. My bad. It's not possible for me to test the pod on my machine (for some reason, pod lib lint breaks) or on Travis since it is still on Xcode 8 beta 2.\n. Pushed a fix. Verified that the podspec parses at least.\n. Oh one sec\n. Fixed.\n. I'll push 3.4.2 presently.\n. Use recover. On phone, apologies for brevity.\nhttp://promisekit.org/docs/handbook/Classes/Promise.html#/s:FC10PromiseKit7Promise7recoverFT2onCSo13DispatchQueue6policyOSC11CatchPolicy7executeFzPs13ErrorProtocol_GS0_x__GS0_x_\n. Closing as I believe recover does what you want. I have added an FAQ entry for this question.\n\nfiltering errors by a given ErrorType as an argument\n\nThis feature we do not have, but that would be a welcome addition.\n. My bad, this is somewhat the problem with our tests versus how PMK is built for CocoaPods. With CocoaPods all members are put in PromiseKit.framework, but we don't do that in the Xcode project as that would mean all categories would be imported for all uses of the framework which is not efficient for most people.\n. Sorry about this. I'll work on a fix immediately.\n. Your solution is the only one I could get to work. A pure Swift OptionsSetType does not get generated into a -Swift.h header by the toolchain, probably there is a solution for that, but I don't know it. Having it be an Objective-C option works and is an acceptable solution. Will push 3.4.3.\n. __dispatch_current_queue_label or something like that. Not great, but I don't see a better way yet.\n. I spent some time trying to solve this well in the experimental PMK5 branch, the only real option is to create an object and wait for it to be deallocated. This is not good IMO as the docs for GCD say that autoreleasepools in threads without NSRunLoops only run every 50ms or so. Thus we are slowing down promises quite substantially (for queues without runloops, which is almost all queues that aren't the main queue).\nSo in the end I have decided that we do not guarantee Promises/A+ off the main queue, I don't see how else to avoid this.\nIn practice however it mostly behaves as desired. Especially if the chain starts on the main thread. Which is almost always. This really is edge-case, potentially \u201czalgo\u201d behavior.\nHowever in PMK5 I did implement the optimization where subsequent thens execute in the same \u201ccontext\u201d for the main queue. This avoids a dispatch to the next main run loop cycle in many cases so is a win, though in practice nobody is going to notice IMO.. It wasn't the promise itself that this logic was inside, it was in a helper object that the Promise itself manages (or didn't manage specifically).. This creates a new DispatchQueue, surely that means the thread it executes onto is undefined? And we have to wait for the thread a then handler is added to have a new \u201cexecution context\u201d, so forgive me, but I'm not quite seeing how your example works.\nI did something like:\n```swift\nclass Helper {\n    var done = {}\n    deinit {\n        done() // deallocate occurs in the thread that you instantiate your object, provided no other thread gets a handle anyway\n    }\n}\nextension Promise {\n   func then(body: () -> Void) -> Promise {\n       let helper = Helper()\n       helper.done = body\n       //\u00a0^^ simplified obv.\n   }\n}\n```\nWhere I did it in such a way that Swift wouldn't smartly optimize away the autorelease.. Well, my idea didn't work well enough, so I didn't consider it good enough. With up to 50ms latency, it didn't seem acceptable.\nAlso I didn't use it for threads with runloops as your suggestion worked better.\nIf we could figure out a general solution for threads without runloops then I'd be all for it.. Really the only solution is something like this (pseudocode):\nswift\nlet p = somePromise()\ndefer { p.continue() }\np.then {\n    //\u2026\n}\ndefer does what is needed, but we can't automate its usage.. I don't believe we can really fix this.. This includes converting all extensions to the asImage() type system we have for eg. NSURLSession.\n. I believe this is done.\n. Why is it building a test? Please provide your Cartfile.\n. Yeah I can reproduce. Weird.\n. Fixed, Carthage should grab the new sha.\n. The documentation is for version 4 and Swift 3. Reserved keywords can be used as functions in Swift 3.\n. Sorry for the confusion.\n. Thanks for noticing and the fix. This was a mistake and not a deliberate decision.\n. With Carthage none of the categories are installed because there is no way to choose subspecs like there is with CocoaPods.\nThis used to be documented but apparently has disappeared in the recent docs rewrite.\nYou have to manually add the category sources to your project with Carthage.\n. Actually it is documented here: http://promisekit.org/docs/cocoa-promise/\n. Go into the Pods project and check that UIViewController+Promise.swift is there.\n. The Swift header won't mention it since Promise<T> cannot be represented in ObjC.\nAnyway, the file is there, so something is wrong with your build. Since you added the xcodeproj manually and then added it with CocoaPods it is possible the old PromiseKit is still around somehow and that is being imported, and the old one had no categories.\n. We would still have an OMG extension, just separately. And nothing would change for CocoaPods bar the option to not depend on OMG being more readily available.\n. Done.\nI also added an Alamofire extension. Now you can chose between OMG and AF as you like.\nhttps://github.com/PromiseKit/OMGHTTPURLRQ\n. Yes, you must always specify the return type or Swift gets upset.\n. Yes, as the README says, the master branch supports 2.3. If it doesn't then that's a bug.\n. I'm sorry, minimal changes versus what? PMK3 supports Swift 2.2 & Swift 2.3, so it requires no minimal changes.\nDo you want a minimal changes branch for PMK2? Or for PMK4? Sorry for the confusion.\n. No no, this isn't small fry. I want PromiseKit to satisfy all its users. Just need to understand what you are after.\nSo PMK2 for Swift 2.3? Should be doable.\n. Done, let me know if you have any trouble.\nNext time feel free to open this ticket sooner! Only took me 20 minutes to make it work.\n. What line is the error on?\n. You need to specify the return type for the closure (-> Promise<(A,B)>), this is a Swift issue. Further information in the FAQ.\n. Let me know if you have other problems as I want to help, but also want to update the docs to be more useful.\n. You need to specify the return type like so:\n``` swift\nRequestLocation().requestUserLocation().then { locationCoordinate in\n    return NetworkRequest().makeRequest(locationCoordinate)\n}.then { weatherJSON -> Promise() in\n    let decodeWind = DecodeWind().decodeWind(weatherJSON)\n    let decodeCurrently = DecodeCurrently().decodeCurrentWeather(weatherJSON)\nreturn when(decodeWind, decodeCurrently)\n\n}.then { wind, currently in\n    print(wind, currently)\n}\n```\nThis is because Swift infers return types for single line closures but otherwise will not.\n. Cool. It is IMO a pity this is required, but Lattner has been pretty clear that he considers this a feature.\nObjC is more flexible\u2026 :/\n. Worksforme. See attached.\nasad.zip\nMy guess is your CocoaPods project is broken.\n. OK we have another report and I can reproduce.\nDupes #504\n. Should be fixed.\nWas due to how the generated umbrella header ordered the includes and because PromiseKit does the unusual: Adding objc to a Swift class.\n. Let me know if it works.\n. Tests will fail since Travis doesn't support beta6. However I have been working on this patch.\n. My attempt has test failures, so I tried this locally and it has ~20 failures too.\nMostly in AnyPromise stuff.\n. In fact my bad: Travis has been updated to beta 6.\n. Pushed to swift-3.0 and the 4.0.0 tag was updated.\n. Set legacy swift to no. For more information google: Xcode 8 swift legacy version.\n. Presumably when Xcode 8 is released CocoaPods will be updated. Until then this is what you have to do, your issue is with CocoaPods, so maybe report the bug there.\n. Unknown attribute escaping suggests to me that this isn't Xcode 8 beta 6. Since that was introduced in beta 6. What does About Xcode say?\nIf it is beta 6, check the SWIFT_VERSION setting in your build settings in both xcodeprojs.\n. Yes, CocoaPods doesn't have a way to set the Swift version yet, so you have to do that manually.\nfinally has been renamed always to be consistent with Promise<T>.\n. AnyPromise +promiseWithValue exists, and we use it copiously in our tests, so I'm confused about that. Looks like:\n[AnyPromise promiseWithValue:@1]\n?\n. Does it work if you @import PromiseKit; instead?\n. Actually I think I know why, will push a fix.\n. Try now, presumably pod update will fetch the new HEAD.\n. Please open a new ticket.\n. The then should definitely fulfill.\nWe have dozens of tests that prove that this works. Can you provide a test case so I can investigate?\n. When I run the project the then is called and the background turns yellow.\n. Promises are always asynchronous, you need to use XCTestExpectations or zalgo, see the FAQ.\n. I cannot, I know nothing about Quick I suggest you google for \u201casynchronous testing with Quick\u201d.\nWhen done you can contribute back to this project and improve the FAQ.\n. Google suggests something like:\nswift\nexpect(promise.value).toEventually(equal(something))\n. Closing due to no response.\n. I'm sorry I don\u2019t understand your questions. Perhaps you can try to explain them more concisely with more example code?\n. - The compiler warning is because an unterminated Promise chain is a chain that doesn't end in catch, and thus has no error handling.\n- The log warning is what it says, you have an unresolved promise somewhere and you don't want that. It may well be your code sample since the error path is not handled (there is no reject).\nYour code could be made more robust anyway:\n``` swift\nfunc getNewToken() -> Promise {\n  // by always returning promises you ensure that error paths\n  // and fulfillment paths are ALWAYS handled\nreturn firstly { _ -> Promise<_> in\n    guard let token = refreshToken else { throw TokenError.tokenExpired }\n    return Network.shared.apiRequest(\"auth/refreshtoken\", method: .post, data: [ \"refreshToken\": token.value ])\n  }.then { payload -> Void in\n    try self.setToken(fromPayload: payload)\n  }\n}\n```\nBy using promises you are ensuring you always handle errors and always handle positive paths too.\n. Use when:\n``` swift\nfunc getItems(restaurantGuid: String, authToken: String, itemGuids: [String]) -> Promise<[MenuItem]> {\nlet promises = itemGuids.map { itemGuid -> Promise<MenuItem> in\n    return Promise { fulfill, reject in\n        Alamofire.request(/*\u2026*/)\n    }\n}\n\nreturn when(promises)\n\n}\n``\n. Closing due to lack of response.\n. np, I don't expect responses, but I do keep my issues tracker clean as much as possible.\n. Thanks. \ud83d\udc4d\ud83c\udffb\n. Thanks and apologies.\n. Open for two years and no takers. Open source doesn't work really, init?. Bug is with SwiftPM.SWIFT_PACKAGEis not defined for generated Xcode projects.\n. You could manually define the constant in the project. \n. It should be a trivial fix, so we should fix it and submit the PR.\n. I submitted a fix to swiftpm and it was merged. Let me know if it doesn't fix it.\n. Couldn't tell you.\n. Your application is not successfully linking at runtime toPromiseKit.framework`.\nI suggest inspecting the application bundle, check PromiseKit.framework is there and checking the rpaths and link lines (otool -L) of the binaries and frameworks to try and figure out what is wrong.\nIf you can mail me the project I can do this for you.\n. This documentation is for the yet unreleased PromiseKit 4. This is mentioned at the top of the documentation.\nSorry for this, PMK4 is out very soon, and the documentation needed an update, so I combined the two.\nThe PMK3 equivalent is Promise { completionHandler in }.\n. If alamofireRequest1 returns Promise then you are using wrap wrongly. You should instead use firstly:\n``` swift\nfirstly {\n    alamofireRequest1()\n}.then { result in\n    //\u2026\n}\n// or you can just then of any promise:\nalamofireRequest1().then { result in\n    //\u2026\n}\n```\nIf they take a completion-handler then you should use wrap:\nswift\nPromiseKit.wrap(alamofireRequest1).then { result in\n    //\u2026\n}\nIf you are using PromiseKit 3 however there is no wrap. You didn't say which PromiseKit you are using.\n. If they return Request, then no, you need a completion handler variant to use with this initializer:\nhttps://github.com/mxcl/PromiseKit/blob/master/Sources/Promise.swift#L92-L104\n. Closing due to lack of response. Let me know if you need further assistance.\n. What you are doing doesn't really make sense, as far as I can tell you want this:\n``` swift\nfunc alamofireRequest(url: String) -> Promise {\n    return pp().then { _ -> Promise in\n        let user = User()\n        let URL = APIURLFactory().makeURLFor(url!)\n        let mutableURLRequest = NSMutableURLRequest(URL: URL)\n        mutableURLRequest.HTTPMethod = \"GET\"\n        mutableURLRequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        mutableURLRequest.setValue(\"JWT (user.jwt_token)\", forHTTPHeaderField: \"Authorization\")\n    return PromiseKit.wrap(Alamofire.request(mutableURLRequest).validate().responseJSON)\n}\n\n}\n```\n. Ahh. This is why we need tests for this part.\n. Pushed 3.5.1\n. I\u2019m afraid the ObjC implementation is not ObjC it is Swift, so it is impossible not to require the swift runtime.\nIf you want a pure ObjC PromiseKit, we still maintain PromiseKit 1.x.\n. This was fixed recently: https://github.com/mxcl/PromiseKit/commit/314a9897cebc50ace172104adbec9cfb0f185094\n. Make sure you pod update\n. It's a bug in CocoaPods: CocoaPods/CocoaPods#5778\nDowngrade or wait for beta2.\n. You will also need to specify submodules: true. A separate CocoaPods bug tracks this.\n. Fixed.\n. Thanks\n. There is no PMKFoundation with CocoaPods. This is documented in the headers.\n. Specifically it will be #import <PromiseKit/NSURLSession+AnyPromise.h> with CocoaPods, but as you specified for Carthage. This is unfortunate but not avoidable afaict.\n. With CocoaPods:\n#import <PromiseKit/NSURLSession+AnyPromise.h>\nWith Carthage:\n```\nimport \n``\n. Can you open a new ticket with error messages etc. ?\n. This is already done in PromiseKit 4, to be released with Xcode 8.\n. Though we have no plans to do it for 1.x or 2.3-minimal-changes, but we could if desired.\n. I can\u2019t experiment right now but this suggests that the module is badly formed, I suggest deleting the pods directory and doingpod update` again.\n. I pushed something that may help here just now.\nAlso 4.0.0 is now live on CocoaPods so you can remove any hacks in your Podfile that you were using.\n. New ticket please.\n. Closing due to lack of response.\n. Works for me:\nsh\n$ carthage update --platform iOS\n*** Fetching PromiseKit\n*** Checking out PromiseKit at \"4.0.0\"\n*** xcodebuild output can be found in /var/folders/9p/55y6r8hs3yz2qkhvf74gc0gh0000gn/T/carthage-xcodebuild.jTNxJt.log\n*** Building scheme \"PromiseKit\" in PromiseKit.xcodeproj\n$ carthage version\n0.17.2\n$ cat Cartfile\ngithub \"mxcl/PromiseKit\" ~> 4.0\nPromiseKit 4 doesn't have a PMKiOSUITestsHost scheme, so something is suspicious IMO. Only PromiseKit 3 has that scheme.\n. Promise(value: ())\n. Also, it's not a stupid question, I was initially confused about how to do this too, and I wrote the code. Promise() used to work, but we elected to be more \u201cSwifty\u201d with v4 and thus the value parameter  is now mandatory, which means the Void initializer ends up being odd.\n. Hmm I tried something like this:\nswift\nextension Promise {\n    static var void: Promise<Void> {\n        return Promise<Void>(value: ())\n    }\n}\nAnd Swift wouldn't compile it due to it requiring T to be inferred. I must have been doing it wrong.\nCould you PR it?. Maybe this will work since Swift 3.1, since that syntax was only just added. PR welcome, if it works and all tests pass.. @RobinDaugherty you can do Promise().\nThis information is in our documentation.\nThis is since Swift 3.2, which allowed generic specializations, thus we specialized Promise<Void>.. We have this now, and there are no further positive badges to earn! Great work everyone.. Did you rebuild PromiseKit? You have to rebuild every time Xcode changes.\n. PMKiOS does not exist in PromiseKit 4, only in PromiseKit 3, Carthage has a stale cache or something like that.\n. There is no catch in 3. It is called error\n. Leaving open because we should add this caveat to the revised PromiseKit 4 documentation.\n. K, figured it out, seems to be a bug in CocoaPods where specifying any deployment target in the subspec causes the deployment targets for any other platforms to be erased. Work around is to re-specify.\n. I will push 4.0.1 to CocoaPods as soon as I have determined the issue with #538.\n. In the meantime you should be able to use what we have with:\nruby\npod \"PromiseKit\", git: \"https://github.com/mxcl/PromiseKit\", commit: \"d8d9d95\"\n. You should probably upgrade CocoaPods to 1.0.1, though I don't expect that to be the issue, it might help.\n. I cannot reproduce this, I am actively working on a CocoaPods PromiseKit 4 iOS project and it builds fine.\n. What are your project\u2019s target\u2019s settings for allowing non modular includes?\n. Can\u2019t reproduce. I've also talked to several other users who do not have this issue with CocoaPods. Did you try upgrading CocoaPods to the latest version?\n. Nice!\n. Can you post the code that fails to compile?\n. Well indeed. That method is -, not +\nhttps://github.com/PromiseKit/Foundation/blob/master/Sources/NSURLSession%2BAnyPromise.h\n. np we've all done such things. \n. Try this syntax:\nswift\nApiManager.sharedInstance.createRide(params: params).then { ride -> Void in\n    //\u2026\n}\n. I think it's a swift compiler bug. \n. Try again. \n. The error is a timeout, so I can't suggest anything but keep trying.\n. Again, it timed out.\nfatal: unable to access 'https://github.com/PromiseKit/MessagesUI.git/': Failed to connect to github.com port 443: Operation timed out\n. \ud83d\udc4f\ud83c\udffb\n. Dupes #538. You need to upgrade CocoaPods.\n. In fact, 4.0.2 is not pushed to CocoaPods yet.\n. I cannot reproduce this, so we need as much information as you can provide about your situation.\nI am actively working on several projects that build PromiseKit via CocoaPods and do not experience this issue.\n. I can't think of anything specific, anything you can provide would be helpful. Sorry :(\n. Try this maybe:\n``` ruby\nplatform :ios, '10.0'\nuse_frameworks!\ntarget 'Bais' do\n  swift_version = \"3.0\"\npod 'pop'\n  pod 'DGActivityIndicatorView'\n  pod 'AsyncDisplayKit', '>= 1.9.90'\n  pod 'FBSDKCoreKit', '>= 4.15.1'\n  pod 'FBSDKLoginKit', '>= 4.15.1'\n  pod 'FBSDKShareKit', '>= 4.15.1'\n  pod 'GoogleMaps', '>= 2.0.1'\n  pod 'Alamofire', '>= 4.0.0'\n  pod 'AwaitKit', '>= 2.0.0'\n  pod 'ESTabBarController-swift',\n    :git => 'https://github.com/jonybur/ESTabBarController.git'\n  pod 'SwiftyJSON',\n    :git => 'https://github.com/appsailor/SwiftyJSON.git',\n    :branch => 'swift3'a\nend\nproject '/Users/Jonathan/Desktop/Claxon/BAIS.xcodeproj'\n``\n. Yeah the repo would definitely help\n. 4.0.2\u2019s release is pending this bug: https://github.com/CocoaPods/CocoaPods/issues/5880\n. Please provide yourCartfile.\n. Well something is amiss then because theswift-2.3-minimal-changesbranch has noExtensions` directory:\nhttps://github.com/mxcl/PromiseKit/tree/swift-2.3-minimal-changes\nAlso FYI, as our README says, you should use 3.x for Swift 2.3:\ngithub \"mxcl/PromiseKit\" ~> 3.5\nThe minimal changes branch is for migrating PromiseKit 2 which is over two years old now.\n. True, sorry. We changed this just before release and didn't realize that the docs had featured these functions.\n. What docs? I can't find any references to this.\n. Thanks, this change is pending:\n- https://github.com/realm/jazzy/issues/659\n- https://github.com/CocoaPods/cocoadocs.org/pull/468\n. Jazzy was finally updated so this is now fixed.. This is deliberate, you should always return a promise or terminate it with a catch. In the rare case you are attaching a handler that is already error handled elsewhere use _ = foo.then\nIf you believe we are wrong in this decision please provide examples.\n. Dupes #548. This is intentional.\n. I'm willing to be wrong on this, discussion welcome. IME there aren't many times where the chain shouldn't be returned or terminated so the trade off feels right.\n. It seems reasonable to require the user to explicitly mark that the situation does not require a catch though.\n. I appreciate the example very much, thanks. \n. Yes, _ = is recommended. Or figure out why you are not catching, or provide an example here.\n. Delete Pods, remove CocoaPods cache, pod install again.\n. Works for me. I'm using PromiseKit in four different projects. All fine. \n. I suggest blowing away cocoapods. Updating. Clearing its cache. Etc. \n. Go through our closed issues too. There were similar reports fixed by doing similar things to what I said.\n. Or if you provide a sample project I can try and fix. \n. Sample project needed. Thanks.\n. Closing, assuming CocoaPods issue.\n. In our experience, do it again and again until it works.. Hmm, this is due to our hack. I have figured out how to remove this hack in the PMK5 experimental branch, so I need to back port this.. I have removed AAA-CocoaPods-Hack.h in 4.2.0 (currently being pushed). Closing, reopen if not fixed.. Yes, never import frameworks with quotes, always use one of the two valid framework import syntaxes. . There are copious references to this in the documentation.. Swift bug. But we should work around it ourselves.\n. I wonder if this is fixed in Xcode 8.1 since really we shouldn't change this unless absolutely necessary.\n. Should be fixed with the 3.5.2 release.\n. Open a new ticket.. Yes, good point. This was not deliberately vicious on our part since it has only occurred because Swift\u2019s error type was renamed from ErrorType to Error during 2 -> 3 causing this conflict.\nI will rename our Error types throughout.\n. Should be fixed in 4.0.3. Please advise.\n. Hmm, my bad.\n. Fixed, I believe, though CocoaPods may have cached the previous checkout so you may have some trouble.\n. pending is now isPending per Swift 3 API guidelines.\n. The pattern you're using is what I'd do. I'd probably make it lazy and not optional though.\n. Thanks for the report. I'll grab the beta and see what I can find out.\n. Can you provide the full error from the build log?\n. Your cache or checkouts are still broken somehow since 4.x does not have a Categories directory, only 3.x does.\n. swift\nasyncThing().then {\n    let foo = promise1()\n    let bar = promise2()\n    return (foo, bar)\n}.then { promise1Result, promise2Result in\n    //\u2026\n}\n. Great, I think it'll make a good addition, provided it doesn't cause the Swift compiler to get confused by other usages. Which is my main concern. Swift already gets confused by PromiseKit enough.\nMany thanks.\n. > I made a support only for 2 & 3-values tuples. I feel at least 5 values should be allowed, however as for now I wanted to be consistent with when.\nBy all means add support for more, and feel free to increase the size of when also.\n\nI can't think about any way of allowing infinite number of promises in a tuple (except hacking with dangerous unsafeBitCast).\n\nI would be interested in seeing the code, but yeah, sounds binary unsafe.\n\nI haven't added tuples functionality to firstly, since firstly already doesn't match then functionality. I guess you kept it intentionally thin?\n\nfirstly is an odd one, we for example don't have an on parameter because firstly always executes immediately, and thus we don't unleash zalgo. I think we should support the tuple return for firstly, I think the only reason we didn't initially is Swift compiler issues.\n\nI haven't touched objc at all. Not even sure if there's anything to do on that side.\n\nYeah, feel free to leave it alone, the equivalent is PMKManifold and we chose not to make that behave like when some time ago.\n\nI've provided a very minimalistic set of tests. E.g. do you find a rejection test useful? (I can add it)\n\nProbably rejection is covered, but more tests is good.\n. Sorry for the delay. I wanted to try it out more.. Closing, dupes #551, #549, #548.\nAs said, discussion welcome.\n. It executes if the promise rejects and it executes when it fulfills.\nI considered something like drop, but it seemed to me:\nswift\n_ = firstly {\n    return URLSession.shared.dataTask(with: request).asString()\n}.then { string in\n    print(string)\n}\nWas more \u201cswifty\u201d.\nfinally was renamed because you could use it in the middle of a chain, and often would, and in such cases it seemed weird to name it finally. The original choice of finally was to mimic the @try, @catch, @finally system of objc.\n. Did you meant to close this?\n. Definitely. Thanks. \n. This should work. when does not require the same types. Do you have an error?\n. You claim to be returning a tuple, but you are returning a Promise. Fix your return type or return the tuple you say you are. \n. It was not desired to conflict with Foundation, this only started happening since Swift 3 and the removal of the NS prefixes. So as a solution to this issue: I have renamed the type.\n. Strictly this should be a major version bump, but I think everyone in the Swift community has just given up on semantic versioning until Swift 4.\n. Yeah sorry, I couldn't deprecate it without maintaining this same issue, so it had to just magically move.\nWe should maintain a changelog. It's a lot of work though.. Specify -> Void. See FAQ for more specific details.\n. Fixed it?\n. Great. Let us know if you have any other issues. \n. I agree this is confusing, I introduced this behavior with good intentions but it was wrong.\nWith PMK 2/3 catch returned Void, with PMK 4 returns self to enable chaining.\n. In the experimental PMK5 branch I have altered catch to return a half-promise that only has a finally method. Hopefully that will make situations like this identifiable.. Fixed in PromiseKit 5.. We use it in a number of places, but I'm not sure if it really justifies it being open. Could do the same tricks with a protocol, and this would probably be better anyway.\n. We can rename the method or document it more.\nProbably static func DispatchQueue.pmkAsync would be enough, to indicate it is special to us.\n. Many thanks.\nThe join stuff is new, here's an example:\n``` swift\nclass Engine {\n    static func make() -> Promise {\n        let (enginePromise, joint) = Promise.joint()\n        let cylinder: Cylinder\n    firstly { () -> Void in\n        // Engines are expensive to make, so we want\n        // to initialize its components first.\n\n        cylinder = Cylinder(explodeAction: {\n\n            // the problem is we need access to the engine\n            // every explosion\n\n            // we *could* an IUO, but Swift is safe and there\n            // are no guarantees about when this callback will\n            // be called. Having an actual promise is safe.\n\n            enginePromise.then { engine in\n                engine.checkOilPressure()\n            }\n        })\n    }.then {\n        Ignition.default.start\n    }.then { plugs in\n        Engine(cylinders: [cylinder], sparkPlugs: plugs)\n    }.join(joint)\n\n    return enginePromise\n}\n\n}\n```\nI hate this example, but actually I couldn't come up with a better one.\nPerhaps that means the pattern is bad.\nAnyway, this feature is \u201cbeta\u201d, hence I added it without docs or announcement. I need to experiment with it, and I hope others might too, so we can figure out if it makes sense or not.\nCertainly I have needed something like join many times.\n. > Just to be clear, this is basically just a convenience for specific use of pending promises?\nYes, true.\n. Terrific work, many thanks.\n. Like it says, you\u2019re missing a return:\nswift\npublic func request(method: String, path: String, jwt: String? = nil) -> URLDataPromise {\n    if jwt == nil && self.authorizer != nil {\n        self.authorizer!.authorize().then { generatedJwt in\n            return self.client.request(method: method, path: path, jwt: jwt)\n        }\n    } else {\n        return self.client.request(method: method, path: namespacedPath, jwt: jwt)\n    }\n}\nLine 3 should return.\n. Add -> URLDataPromise.\n. The problem here is:\n``` swift\npublic func request(method: String, path: String, jwt: String? = nil) -> URLDataPromise {\n    if jwt == nil && self.authorizer != nil {\n    // this following then returns `Promise` NOT `URLDataPromise`\n\n    self.authorizer!.authorize().then { generatedJwt in\n        return self.client.request(method: method, path: path, jwt: jwt)\n    }\n} else {\n    return self.client.request(method: method, path: namespacedPath, jwt: jwt)\n}\n\n}\n```\nThis is pretty hard to solve as far as I can tell. Easiest option would be to return Promise\n. Dupes #561, #551, #549, #548.\nWe consider this a feature, see other tickets for rationale. Thanks.\n. Upgrade to PromiseKit 4.0.4, we released this in advance of Xcode 8.1.\n. Nuts, thanks.\n. At this point we don't actively support 3.x. Yes, you\u2019re right, this is the correct approach. The pattern is the same. Good spot.\nLet's stew on the name a little.\n. Yeah great idea. Personally I almost always unwrap the pending when assigning to it, so if everyone does that, we can use your trick. I've been burned by such tricks in the PromiseKit past\u2020, but the difference is I think most people unwrap for pending. But I may be wrong.\n\n\u2020 CLLocationManager used to have two promise functions with different T which made using it a PITA.\n\n\nI still prefer the previous route of having the pipe go into the chain rather than take a promise:\n```\nlet promise = firstly {\n    //\u2026\n}.then {\n    //\u2026\n}\npipe(promise)\n//versus:\nfirstly {\n    //\u2026\n}.then {\n    //\u2026\n}.pipe(promise)\n```\nFor convenience (it's often painful to grab the promise chain instance), and because it reads better, \u201cfirstly, then, pipe\u201d.\nBut open to discussion, ofc.\n. Another option:\n``` swift\nlet (promise, fulfill, reject) = Promise.pending()\nfirstly {\n    //\u2026\n}.then {\n    //\u2026\n}.join(fulfill, reject)\n```\nThis is less efficient, but certainly a lot easier to understand.\nI guess the reason I always felt I needed the current implementation is I knew the underlying inefficiencies, and doing a then/catch pair was ugly. The inefficiencies are not severe though: a few unnecessary allocations and function calls, a sufficiently advanced compiler could optimize them away (that old chestnut).\n. I haven't had any good ideas about this.. I explored having a single pending in the experimental branch. We should all check it out in use etc.\nNot yet pushed this specific change, will soon.\nNothing is final, I'm working on the branch and then will try it out in an app.. The experimental branch drops joint and instead has a consistent Sealant for all methods of resolution.. Let's not be over reaching.. We have tests.. We can still publish old versions to CocoaPods if that is what you mean.\n. I'll add a branch for you.\nedit: branch swift-2.x is 3.x\n. You don\u2019t have to recover the error, you could still throw.\nI guess we could have multiple versions recover, if you use the one that doesn't throw then the result could be discarded.\n. I use it that way quite regularly, only recovering from some errors.\n. I'm going to assume it is ok.\n. On it.\n. Pushed.\n. Swift bug, it is interpreting Promise<Any> as Any  rather than Promise<Any> and thus choosing the wrong version of then causing it not to wait on the promise.\nAs a workaround, don't use Any, this should be reported against Swift. I'm not sure there is anything we can do to fix it.\nSee attached playground screenshot for  @proof:\n\n. Changing them to Int fixes it:\n\n. Perhaps we should add a fatalError:\nswift\nguard !(promise.value is Promise) else { fatalError() }\nSo in future we can catch this better? I'm usually not a fan of this sort of thing, but since the behavior is otherwise broken, it seems fair.\n. Sorry I see @zlangley already identified this, I only scanned over the responses\u2026 my bad.\n. The suggested fix for anyone coming here is to not use Promise<Any>.. Fixed by PromiseKit 5 being more strict with then.. With Carthage you have to manually embed the frameworks you use, the error suggests you are not doing this properly.\n. You OK?\n. Use race and create another promise you can resolve separately. \n. We should change the import line to Foundation.Progress\n. You can change it to just import Foundation.\nThough if Progress doesn't exist at all on Linux (possible) then we'll need to change the define to remove the progress for Linux.. I can investigate a PR for this, but it is pending me having a few hours solid time available to set up a VM, would be much quicker if someone with Linux available can trial the suggestions in this thread.. Merged a PR that fixed this? Reopen if not.. I believe this is a dupe and the solution was wiping out the cocoapods cache or similar. If this doesn't work keep browsing the closed tickets. \n. Changed which folder?. dafuq?. I'd do:\n```swift\nfunc poll(_ test: () -> Promise) -> Promise {\n    var x = 0\nfunc iteration() -> Promise<T> {\n    return test().recover { error -> Promise<T> in\n        guard error.canRetry && x < 3 else { throw error }\n        x += 1\n        return after(interval: 0.1).then(execute: iteration)\n    }\n}\n\nreturn iteration()\n\n}\nextension Error {\n    var canRetry: Bool { /TODO/ }\n}\n``. I think we need to some work here at least, eg. I useafter(interval: _)` a lot, there's no reason to warn for that. It cannot fail.\nSo maybe we should add an UnfailablePromise class.\nAlso, as an aside, I added a fatalCatch() chain terminator to my local branch, and use that quite a lot.. Also, during my use of PromiseKit, almost always I find that if I am getting this warning it means I am not handling errors. Only occasionally am I making a sub-chain where I know I am handling the error elsewhere and thus adding a _ = prefix is necessary and thus also a good indicator that I know the error is handled elsewhere.\nOther than the above mentioned cases where the promise cannot fail.\nAnother thing on this, this warning almost makes the UnhandledErrorHandler unnecessary, since the Swift compiler is ensuring we handle errors. We may want to consider deprecating it, unless I'm missing something.. The other option of course is to add the @discardableResult annotation.\nI feel this would lead to less good code for our users.\nBut it would lead to less tedious usage for our users.\nHonestly, I feel how we have it now is more Swifty. However, we are not Apple, and our popularity to an extent depends on us not being tedious.. Can we do all these smarts so it is compile time? I didn't think so, but would love to be wrong.. Great stuff.\nI haven't looked yet, but I spent my time in transit today trying out a PromiseKit where Promise is based on a protocol Thennable, this would presumably make it easy for UnfailablePromise to a separate protocol and not need to inherit.\nJust saying. I'm tired now and can't recall all the reasons I have done this. Will likely push the work to a branch soon so you guys can take a look. Certainly, the code is simpler in many places.\nAnyway, will check out your work @FilipZawada thanks, I'm super hyped this is possible.. The experimental-5.x is now beta worthy IMO, I'll be using it in an app from today.. There will be frequent updates, also please, your feedback would be wonderful.. In PMK5 (experimental) I added a cauterize() function, that prints any error and terminates the chain. So yeah, would be ok with this being in PMK4.. Closed by https://github.com/mxcl/PromiseKit/commit/a5d5221684061b482111aaed5d7ca8a94bcd4f7b\nPlease read the commit for details.\nTL;DR: I added @discardableResult for PMK 4. PMK 5 has been released and solves this more elegantly.. What compiler throws this error? Since we didn't get this error when PMK3 was HEAD for 1.5 years.. I'll fix Travis first. Sorry not yet. I can restart the build once I have.. We deliberately do not provide a cancel method because you should have explicit control over which parts of your app and which libraries you use can cancel your operations. If we provided cancel then any old library you import off cocoapods that uses PromiseKit could cancel anything. Hardly robust.\nThus if you need cancelation you can (with some effort) add it where you need it.. Our cancellation documentation could use some work actually, my fault, I revised it about 4 months ago.\nYou can add a cancel function like so:\n```swift\nenum MyError: CancellableError {\n    case foo\n    var isCancelled: Bool { return true }\n}\nvar cancel: (()-> Void)!\nlet promise = Promise { fulfill, reject in\n    cancel = { r(MyError.cancel) }\n}\n```. https://github.com/mxcl/PromiseKit/blob/master/Documentation/CommonPatterns.md#cancellation. Can you submit the PR? Much easier to tell what is is different in a PR.. Thanks and good point. . I'm not happy that it requires you to clarify the type to prevent an error, since the whole point is it has a specific type, it will just be confusing to users.\nI'd be interested to see usage examples as to why people need this so much, in my projects I need pre-resolved promises only rarely.. @ragboyjr yeah this is my typical usage too.\nFor PMK 5 I have restored the short circuit, which has led to me having to make all other initializers more explicit or it can short circuit their closure inputs as the Promise\u2019s type (!). However, it feels right.. Added in PromiseKit 4.3.0 thanks to changes in Swift 3.1. This info would cloud the main docs section, the reason it is in the README and the FAQ is because these are the entry points for most people to PromiseKit, GitHub is the first link on Google and the first link most people provide, the README is an overview of PMK + detailed instructions on how to install it. The FAQ duplicates this information because it is a frequently asked question.\nSo in conclusion, the information at /docs/ was very carefully considered to provide a concise overview of the capabilities of the framework, and adding installation instructions to it would lessen that impact.. Yeah that would be cool IMO. Thanks.\n\nI'm not sure how common of an issue this is but once I was on the PromiseKit site I felt like I had to stay there and hunt around for the documentation\n\nI relate. I'd only have one place, but people expect a README too.\nThe docs you were looking for are on at http://promisekit.org though: in the FAQ\u2026 unless I'm mistaken.. All you need is #import <PromiseKit/PromiseKit.h>\nPR welcome to improve such things.. I reckon http://promisekit.org (specifically that page) should link to this, like a contents.. We use the GitHub standard gh-pages branch.. I have updated the docs.\nHowever we still start with an introduction to PromiseKit. This is the landing page for the project, it should introduce itself.\nThe getting started instructions are exactly next after the introduction.. Dupes #549, #551, #561, #574, #584 and #595.\nSee other tickets for rationale about why we don't think we should add this attribute. Feel free to contribute to the discussion justifying why we should.. Will take a look\u2026. It's my pleasure.. Compiles for me\u2026 what's your error?. Seems like it is being compiled with Swift 3 to me.\nIs it possible your CocoaPods is building with Swift 3 for some reason?. It should default to Swift 2.3, but you could try adding swift_version = \"2.3\" at the top. np, glad it is solved!. File exists: https://github.com/PromiseKit/Foundation/blob/be45e79c0627511d02af221e6ca04ec8de119e2e/Sources/NSTask%2BAnyPromise.h\nYou did not specify how you install PromiseKit, are you doing it manually?. Like Nathan says, If you don't want the code in somePromise() to execute, then don\u2019t call it\u2026 this isn't PromiseKit choosing to run your code, you are literally telling the Swift compiler to call your code.. You want something like this, presumably:\n```swift\nfunc somePromise() -> Promise<()> {\n    print(\"running it\")\n    return Promise(value: ())\n}\nfunc runIt() {\n    func runPromiseIfNeeded(promise: () -> Promise<()>) -> Promise<()> {\n        //no, i dont want to run that promise\n        return Promise(value: ())\n    }\nrunPromiseIfNeeded(promise: somePromise).catch{ print($0) }\n\n}\nrunIt()\n``. Don\u2019t feel ashamed, we've all done it.. You need topod 'PromiseKit/OMGHTTPURLRQ'this is documented in our PromiseKit 4.0.0 release notes.. It'sget` with Swift 3.. Oh right yeah, we moved the methods to instance methods.\nNext time, I suggest reading the source documentation. Seriously, I don't mean to be condescending, but battling with Swift's crap error messages and Xcode sucking is ridiculous, just read the sources, it tells you what to do.. Good catch & thanks!. You aren't doing anything wrong (though using Promise<Any?> is weird).\nI don't know how to read this output nor am I sure what it means by \u201cdata race\u201d. Presumably two threads are accessing the same data at once? Well we have locks to guard against this, possibly we are doing it wrong, but we haven't seen any such issues in four years, so dunno.. Could be the deinit which we don\u2019t guard access to because it doesn't matter.. I say it doesn't matter because it is harmless:\ndeinit {\n    if case .pending = seal {\n        NSLog(\"PromiseKit: Pending Promise deallocated! This is usually a bug\")\n    }\n}\nWe could remove this, it just means losing this informative message.\nWe could add the dispatch_barrier guard here, but it seems excessive for this read on a deallocating instance.. Thanks, this was very informative.. If a let will fix it then we could:\nswift\npublic func then<U>(on q: DispatchQueue = .default, execute body: @escaping (T) throws -> Promise<U>) -> Promise<U> {\n    let (rv, resolve) = Promise<U>.pending()\n    state.then(on: q, else: resolve) { value in\n        let promise = try body(value)\n        guard promise !== rv else { throw PMKError.returnedSelf }\n        promise.state.pipe(resolve)\n    }\n    return rv\n}\nEdit: this only applies to my experimental branch in fact, but something like this would work.. > Of course, all accesses to a promise's members must be synchronised as well - which I assume is the case. Importing a const reference into the closure does not solve this kind of problem.\nThere is a single unguarded let member, but it guards access to its data with dispatch barriers, which is the promise\u2019s Result.\n\nIMHO, it would be a good idea to enable ThreadSanitizer in Unit Tests. This may increase the detection of potential data races.\n\nSeems like a good idea, I'll do that.\n\nNote: We still require memory barriers that synchronises with the two operations: writing to the imported copy of rv executed in thread A and reading from it in thread B when the closure executes, where A != B. When dispatching to a dispatch queue, dispatch lib will take care of this.\n\nIs this necessary considering the promise itself is immutable: it\u2019s the underlying State object that mutates?. Enabling Thread Sanitizer quickly verified the bug in tests.\nApplying the fix that @couchdeveloper suggested stopped it alerting me to the issue.\nConsidering it fixed, many thanks for the report OP, & many thanks for identifying the cause @couchdeveloper!. This stuff is beyond my domain knowledge, but I thought I was more savvy than this, so I'll read up.. True, thanks.. This is expected behavior, please read the documentation on cancellation: http://promisekit.org/docs/. Most of the time it is a very useful feature, hence its existence despite it being confusing for people who jumped straight into PromiseKit without reading our very minimal documentation first.. Just for clarification, you cancelled the url request, what were you expecting to happen?. > I read your documentation when I started using your library, but this was many many months ago now, you can't actually expect me to remember little nuances like this.\nYeah, I get you. Sorry for my snide response.\n\nI am coming from JavaScript where this would be a violation of the A+ promises spec I am used to in which a promise's state is either pending, fulfilled or rejected, whereas this is some weird 4th state between pending and fulfilled.\n\nThe promise is rejected. But we have a sub-state for rejection where catch handlers may not trigger unless you ask for them to be with the policy.\n\nBut anyway this is not JavaScript and its your library so do as you please.\n\nConforming to A+ is important to this library.\n\nI am implementing certificate pinning on my app. If you fail the auth challenge, iOS by default cancels the task. There is no special error code for it, just gets marked as cancelled. Pretty silly of Apple to not use an appropriate error code for this case but it is what it is and I couldn't find a way of ending the task with a custom error.\n\nYeah, this makes sense. So indeed, it was not you asking for cancellation it was some decision on Apple's behalf that made behavior from PMK unexpected.\nI'm going to reopen this, as a) cancellation should be explicit, so we should figure out how to at least post a debug warning for this case and b) many of the reasons I had for initially adding this behavior are less compelling to me a few years of PMK use down the line.\nReally appreciate your report.. In PMK5 a message is logged whenever a cancellation message is ignored by a catch handler. I played with removing cancellation altogether, but in all my apps it is too useful to be able to reject a chain without it leading to a catch handling the error. Thoughts welcome!\nPMK5 is experimental and probably will be for some time.. Your abort idea would still conflict with your primary concern though wouldn't it? That any user may cause a chain to not have a catch handled. Or did I miss the point?. I still don\u2019t follow, your report was due to confusion that a catch wasn't getting called, if instead we used an abort system then you still would have been confused that a catch wasn't called. The underlying code that you were using was unknown to you and it behaved in a way you didn't expect and still would have with this abort system.\nI'm not trying to be obtuse, just trying to understand the advantages of your proposal before we decide what should be done.. Canceled errors log since PMK 5.. \u8c22\u8c22!. Specify Alamofire.Result, or probably better unwrap the result, since if the network result is .failed then you should be rejecting the promise, not passing the unwrapped result to the promise.\nIf you provide your code I'll amend it.. K since you are using the resolved variant of when you have to specify `PromiseKit.Result\u2019. This is your fix. . Specifically: \n```swift\nimport PromiseKit\nimport Alamofire\nfunc requestGetAllImages(imageUrls: [String]) -> Promise<[PromiseKit.Result]>  {\n    let promises = imageUrls.map { (imageUrl) -> Promise in\n        return Promise { fulfill, reject in\n            FTAPIManager.sharedInstance.requestIgnoringCacheImage(imageUrl, { (image, error) in\n                if image != nil {\n                    fulfill(image!)\n                }else {\n                    reject(error!)\n                }\n            })\n        }\n    }\n    return when(resolved: promises)\n}\n``. And here's the same usingwrap`, which is what we recommend:\n```swift\nimport PromiseKit\nimport Alamofire\nfunc requestGetAllImages(imageUrls: [String]) -> Promise<[Result]>  {\n     return when(resolved: imageUrls.map { imageUrl in\n        PromiseKit.wrap{ FTAPIManager.sharedInstance.requestIgnoringCacheImage(imageUrl, $0) }\n    })\n}\n```. np, and sorry, I hate this sort of thing, but this is how we are meant to do this I believe, so this ambiguity is inevitable.\nLet us know if you have any other problems.. Please open a new ticket at https://github.com/mxcl/PromiseKit.\nSorry for your wasted time, but it is very hard to do this stuff, this was literally months of work and you did not have to upgrade to the new major version that was just released, that was your choice.\nPlease see the migration guide for further information which also specifies what to do about wrap:\nhttp://promisekit.org/news/2018/02/PromiseKit-6.0-Released/\nIn future do not upgrade major versions without careful thought. There is a reason all Podfile instructions specify that you should specify the major version range you want. Major version increments often break code.. I've added wrap as a deprecated function coming in 6.0.1 to be released today. Sorry I overlooked this.. > Flat map is deprecated..\nNo, it's not. One use of flatMap for arrays was renamed compactMap there are 4 other uses of flatMap in the Swift standard library.. > It would be nice to include this link in source code / readme with BOLD Breaking changes as there are so many >2500 repos and developers that any help to upgrade the old code to new would go a long way. I\u2019m on train now, will attempt downgrade tomorrow or raise ticket to refactor.\nThe README includes a link to the migration guide. When migrating it is generally recommended to read the provided migration guide. Thanks.. > FYI - projects I\u2019m using are based on Carthage and think the file didn\u2019t lock a specific version. Will look into downgrading.\nLocking with Carthage is possible and recommended by everyone, I suggest you do it in future to avoid the consequences of not doing it: Specifically your entire problem.. promises is seemingly a var since you modify it throughout this function. The debugger is showing you the state of promises at the moment the program is paused, but this is not the same value as that passed to when. Thus, this \u201ctest case\u201d is inconclusive, if you can submit a test case that proves when is not working, then we will reopen.. Bug in the Swift compiler. You can tell because if instead of:\nif true {\n    fullfil()\n} else {\n    // If code below is commented out, there will be no crash.\n    DispatchQueue.global().async {\n        fullfil()\n    }\n}\nYou do:\nfulfill()\nor:\nDispatchQueue.global().async {\n    fullfil()\n}\nor\nvar fulfill = {}\nfunc makeNoCrashpromise() -> Promise<Void> {\n    let (promise, fullfil, _) = Promise<Void>.pending()\n    self.fulfill = fulfill\n    if true {\n        fullfil()\n    } else {\n        // If code below is commented out, there will be no crash.\n        DispatchQueue.global().async {\n            fullfil()\n        }\n    }\n    return promise\n}\nSeems like incorrect auto-reference counting by the compiler. Bug should be reported to Swift.. I created a testcase: https://www.dropbox.com/sh/byxvrvx1qmcmjmg/AABbPwxsbpduk1O7RgReTBJaa?dl=0. I know as much as you.. I don\u2019t know where these things are set in Xcode, do you?\n. K, will do that presently.. Pushed that fix and tagged 4.1.5. LMK if there's any further trouble.. PR please. I cannot fix this this weekend. . Tagged 4.1.6. The individual promise in your array resolve when they resolve. We have no control over them.\nWe believe you are misunderstanding:\n\nPromises (as far as I know) should work in order\n\nThis is not true.\nLet us know how we can be of further assistance.. Yes they are the same, but your test doesn't prove this, your test proves that when you create a series of promises they fulfill at they own pace. They are already created and resolving before when can even get at them.. You need create the promises one by one:\nswift\nwhen(fulfilled: { return CREATEPROMISE() }, concurrent: 1).then{\n    //done\n}. No I don't mean like that.\nHonestly I don't even know how to use this function. I didn't add it. You may have better luck after reading the documentation seeing as it provides an example exactly like what you are trying to do.. If you know how many promises there are, then you should just chain them without a when.. Simplified:\n```swift\nfunc testIfResolvedOneByOne()\n{\n    let expectation = expectation(description: \"\")\n    var intGenerator = [5,4,3,2,1].makeIterator()\n    var current = 0\nlet generator = AnyIterator<Promise<Void>> {\n    guard let i = intGenerator.next() else {\n        return nil\n    }\n    return after(interval: 0.01 * i).always {\n        assert(i < current)\n        current = i\n    }\n}\n\nwhen(fulfilled: generator, concurrently: 1).then {\n    expectation.fulfill()\n}\n\nwaitForExpectations(timeout: 1)\n\n}\n. -1, IMO extensions from Frameworks should make sense in the context of the thing they extend. Here you are saying that all arrays are implicitly asynchronous, which is patently false..swift\nfunc bar() -> Promise {\n    //\u2026\n}\nfunc baz() -> Promise {\n    return bar().then {\n        if let done = value {\n            return Promise(value: done)\n        } else {\n            return baz()\n        }\n    }\n}\nbaz().then { value in\n    // all done\n}\n```. I wrote this a while back, but since have developed new techniques.\nhttps://github.com/mxcl/Kissogram\nI would love to offer something more complete, but all my work is for private corps, and they won't open source. In-between that time I maintain the library, I can't really dedicate the time to making a complete sample app.. Closing because issues are not a good place for wishlists. PR welcome though. Discussion will cause me to reopen the ticket.. Sounds like a Swift version mismatch, ensure Carthage is building with the same version of Swift that Xcode builds your project with.. Try making Carthage compile it in debug mode?. So, to provide more, this is definitely a bug in the Swift compiler, the function lookup table (or whatever) is wrong in the Carthage build or perhaps the Xcode build is using the wrong function.\nIf we can't figure out a work around then I can only direct you to https://bugs.swift.org . > After clearing the slate (deleted derived data directories, restart Xcode, etc.), Carthage no longer builds in a test project due to a missing PromiseKit.modulemap. So perhaps I was using cached, but out-of-date files yesterday, when Carthage successfully built, but the test app crashed?\nCertainly this sounds suspicious.. Glad it worked out. It's sad though that these packaging tools failed to work in this case :/. Hmm, looks like quite a bug. Sorry.. Xcode doesn't run on Linux\u2026 can you be more specific about your problem?. OK, the problem is yours I am afraid, promises are asynchronous, so they need a runloop to work.. Something like:\n```swift\npromise.then {\n    NSRunloop.main.stop()\n}\nNSRunloop.main.run()\nprint(\"Done!\")\n```\nShould make the project work, but really you want some kind of event-system on your server side code. To my knowledge, all of them provide one.. Strictly we don't need a run loop. But the app has to enter some kind of wait state so it doesn't exit while the async stuff happens.\nAlso the GCD internals must be running. I don't really know what that requires.. > Kitura blocks DispatchQueue.main\nWow. That seems crazy.. You can set the default queue that PromiseKit uses: https://github.com/mxcl/PromiseKit/blob/master/Sources/DispatchQueue%2BPromise.swift#L37-L52. I don't do any server side Swift. You, the people who do, are going to have tell me how to clarify the documentation.. Oh indeed, those are not implemented for SwiftPM. My bad. PR shouldn't be too hard though.. Fixed in 5/6.. :D. We don't support returning Promise? from then, mainly because, what should happen? Clearly you expected something to happen, but what exactly if I may ask?\nYou should throw or nest the second then in the first.. swift\npromise1().then { result in\n    guard result else { throw NSError.canceledError }\n    return promise2()\n}.then {\n    //\u2026\n}.catch { error in\n    // cancelled errors do not reach `catch` handlers\n}. Closed due to stagnation.. ```swift\nfunc fetchFromDisk() {\n    // if not on disk throw\n}\nfunc checkIfExpired() {\n    // if expired throw else return the thing\n}\nfunc fetchCache() -> Promise {\n    return firstly {\n        fetchFromDisk()\n    }.then {\n        checkIfExpired()\n    }\n}\nfunc fetchFromNetwork() -> Promise {\n    return firstly {\n        URSession.etc\n    }.then { foo in\n        save.map{ foo }\n    }\n}\nfirstly {\n    fetchCache()\n}.recover {\n    fetchFromNetwork()\n}\n```\nPlease open new tickets for new questions in future.. Yes, it works as a standalone, but that doesn't seem intuitive to me and thus I debate its utility.. Works as intended: promises are immutable once resolved and thus cannot be fulfilled more than once and thus a single then handler is guaranteed to only be called once or not at all.. Great, many thanks, and sorry about this :(. Will merge once Travis says it is ok.. Pushed 4.1.8. Merged your fix, thanks.. Promises don\u2019t \u201cexist\u201d on any specific thread, but handlers can be directed to any queue/thread. then, etc. default to the main thread however.\nThe queue on which a handler executes is entirely up to that handler.\nTherefore if you need a then to execute on a specific queue, tell it to do so, unless it is main in which case you can just specify then {. Yes. Is this convenient enough?. > Also I've been surprised that, even when called in the main thread, the block doesn't run synchronously as is the case in javascript. \nIf so, this is in violation of Promise/A+ which was formulated by the JS community. https://promisesaplus.com\nAll the major promises implementation in JSland conform to this, and it is explicit that what you described does not happen.. Swift toolchain version on Linux?\nBecause this did work: https://github.com/mxcl/PromiseKit/issues/591. In Swift it's DispatchQueue.default = zalgo.. Reopening as we should amend the docs.. > testing documentation\nSorry, I don\u2019t understand what you mean.\n\nspecially when there are more than one Async process (in my case, RxSwift hot stream and PromiseKit) chained together.\n\nSorry, I don\u2019t know what this would look like, could you provide an example?. We don\u2019t have a \u201ctesting section\u201d of our documentation, but if we did I don\u2019t understand why we would put this there.. PMK 5 adds #file and #line to every then instantiation. Though this only helps so much. There's not a great deal we can do without more explicit support in Xcode itself. So I think we can't do that much until Swift has await and well, when that happens we won't need Promises.. This is how I do it:\nreturn self.contentView.runFinishedAnimation()\n    .then { after(interval: 0.5) }\n    .then { () -> Void in\n        let dataAnalysis = DataAnalysisViewController()\n        self.navigationController?.pushViewController(dataAnalysis, animated: true)\n    }\nThough I'd probably write the whole thing like this:\nreturn firstly {\n    contentView.runFinishedAnimation()\n}.then {\n    after(interval: 0.5)\n}.then {\n    self.show(DataAnalysisViewController(), sender: self)\n}. This would be my preference:\nswift\nreturn firstly {\n    someMethod()\n}.then { object in\n    after(seconds: 1.5).then{ object }\n}.then { object in\n    //\u2026\n}. I use the recover solution when I need this pattern. There's room for something more specific though I think.. Closing since issues is not an effective place for a wishlist. PR welcome though. Discussion here will cause me to reopen the ticket.. There is no good place for wishes on GitHub, but clogging the issues tickets inhibits my ability to effectively manage the project, so I can't have them here, sorry. With Homebrew it got to the point where bugs were lost in the noise.\nAnyway, the wish is still valid and fine, a PR is the way to enact your wish, even a partial implementation would be fine for having the PR there. And it would attract interest from others since in Open Source land code is what talks.\nI have appealed to people at GitHub many times to have a separate tab for wishes. Something with voting makes sense to me.. I'm actually ok with wishes being opened here, but I can't leave them open forever in the hope that someone will PR it.\nSo yeah, maybe first here and then we migrate to canny.io after discussion?. On the contrary, it does: https://github.com/mxcl/PromiseKit/blob/master/PromiseKit.podspec#L21. What makes you say it doesn't?. Swift gives spurious error messages when errors happen in closures. Chances are the error is actually in the code inside the closure.\nSplit the code out into its own function:\n```swift\nfunc containingFunc() {\nfunc foo(_ channelId: _, _ messages: _) {\n    let controller = ...\n    controller.messages = messages\n    controller.user = selectedUser!\n    controller.chat = JXChatModel()\n    controller.chat.id = channelId // <- Needed here.\n    self.navigationController?.pushViewController(controller, animated: true)\n}\n\ncreateChannel([selectedUser!.userID!]).then { channelId in\n     // I need to be able to pass 'channelId' to the next .then {} block below.\n     return retrieveMessagesForChat(channelId).then { (channelId, $0) }\n}.then {\n    foo($0, $1)\n}\n\n}\n```\nSwift should provide the real error. Once fixed you can put the code back.. Much appreciated!. Indeed, PMKWhen wraps the error. But we stopped doing that in the Swift version because it is surprising. So probably we should do the same for objc. The wrapper has useful info, but typically that isn't as important.. PR is welcome but I could not merge until PMK 5, since it changes behavior and could thus break apps at runtime.. Ensure you have built PromiseKit for iOS first.. You have to open the project and build the framework for an iOS simulator target first.. Latest commit (also) changes the playground execution platform to macOS also, since apparently a clean clone will default to building to macOS (provided no iOS devices are plugged in).. You have to build the framework.. It isn't choosing that, it's just a bug in the compile errors you are getting.\nI have in fact tried to remove AnyPromise to see if it helps, and it just gives an equally useless compile error.\nI hope Swift 4 improves its error messages.\nUsually the actual error is some issue in the contents of the closure, or Swift requires you to specify the return type of the closure. If the former you can take the code and put it in a local func outside the chain then return that in the then handler. Then the error message should be correct.. In our experimental 5.0 branch I am aggressively trying to improve this sort of situation. So far I've met limited success. . Though: with 5.x the diagnostic never mentions AnyPromise anymore. So it is improved in that respect.. Sorry, is this an error? Can you mark up your question so the error message is explicitly marked?. No, clue. I'll have to try archiving one of my own.. I am in the process for starting my own company, so this will have to wait until I have some time for PromiseKit. Or you can pay me.. Cannot reproduce. One of my apps with PMK 4 archives fine with Xcode 3.1.. I have since archived 4 apps all with PMK, so I don\u2019t think this is a general issue.. Closing due to lack of responses.. We followed the same naming scheme as DispatchQueue: https://developer.apple.com/reference/dispatch/dispatchqueue/2016098-async\nI have renamed this label for catch and always in PMK 5.x.\nI\u2019m considering removing the label for then altogether. Will have to be v5 though. The problem with doing so though is that the previous parameter is on, so you can end up with this:\nswift\nfoo.then(on: q, bar)\nWhich isn't that clear to me, versus:\nswift\nfoo.then(on: q, execute: bar)\nYou may want to consider:\nswift\nfirstly {\n    store.save(user: user)\n}.then {\n    saveDidSucceed()\n}.catch {\n    saveDidFail()\n}.always {\n    saveDidFinish()\n}\nSwift should optimize away the closure (should, meaning, who knows). However in addition this is more readable IMO.. I'm going to leave this open for other people to find.. Despite what the person in that SO thread said, casting a Swift.Error to NSError should not crash, even if you don\u2019t implement the protocol. This is a feature of Swift\u2019s toll-free bridging to Foundation that has existed since Error handling appeared.\nI sincerely hope this is not a common issue :/\nThis bug should be reported at https://bugs.swift.com. A sample crash-case would be useful, or some example code, I assume you are using AnyPromise?. Sigh, really need to run tests in debug AND release mode, sucks.. @pgrosslicht super thanks, your deduction has helped and I will push this hopeful fix:\nif let ne = self as? CustomNSError {\n                return cancelledErrorIdentifiers.contains(ErrorPair(type(of: ne).errorDomain, ne.errorCode))\n            } else {\n                return false\n            }\nThough trying to prove it works or not first.. Tests fail, not a fix. Since apparently NSError does not confirm to CustomNSError. FFS.\nAlso I cannot actually reproduce this crash. If I run our tests built release with the framework built release, no crashes occur. The tests run over these code paths.\nSo really I need a test case.\nIs it possible this was fixed in the most recent Xcode 8.3.2 update?. > THE SAME\nThe same it\u2019s fixed in Xcode 8.3.2 or the same it crashes?. Can you provide a testcase? Otherwise I can't verify any fix I attempt works.. I have verified that the provided TestCase does not crash with 8.3.2.\nI guess I will try to get hold of 8.3.1 again and see with that.. > Yes, agree. I clean cache and try. It does not crash with 8.3.2\nK, great news. I am downloading 8.3.1, just for thoroughness. Will leave open for 2 weeks so anyone else experiencing the crash can easily find this report.. If you are experiencing this bug with other versions of Xcode please open a new ticket so we can investigate.. >  // I must return Promise here, right?\nNo, you can return Void. I presume you are getting an error, although you didn't say. If so specify the return type:\nswift\n  EventsWorker.getAllEvents().then { events -> Void in. np, this is an unfortunately common problem, and there's nothing we can do, it's up to the Swift team to fix it.. We already changed this because of Carthage: https://github.com/mxcl/PromiseKit/issues/620\nSo, I worry about it.. I will aim to tag a release and pod today, but it may end up being tomorrow, pretty busy today.. Live.. Promises don't decide, that is entirely up to the tasks they wrap.\nSo the answer is: probably concurrently, but it depends!. Well I guess the only way they would be serially is if the tasks that the promises represent knew about each other. Anyway, the point is that promises have nothing whatsoever to do with concurrency. I'm pretty sure that statement is in the docs somewhere.. There is ways to avoid that variant of when. Ping me tomorrow and I'll post them. They aren't great either though.. Not when, but you can do something like this:\n```swift\nfunc bar() -> Promise {\n    return foo().then {\n        if shouldContinue() {\n            return bar()\n        } else {\n            return Promise(value: Void())\n        }\n    }\n}\nbar().then {\n}\n```\nThis is a self-terminating, recursive promise, foo is the function that actually does something.. I clarified the documentation on this topic: https://github.com/mxcl/PromiseKit/blob/master/Documentation/Troubleshooting.md. Done.. Specifically, where?. Sorry, I meant, just http://promisekit.org, or including README, sources, headers, etc. But if it was just the website then we are done. Thanks @zlangley . Thing is though. It still is NSURLEtc for ObjC. And for Google juice. Dunno yet what should be chosen for non code samples. . when(resolved:) takes an array, with Swift Array has to have a known type, thus the type has to be the same. when(fulfilled:) has a few convenience varieties that take a tuple instead, tuples can be specified with varying types.\nSo yes, as it stands, when(resolved:) requires the promises to be the same type as can be seen from the declaration.\nAs per the FAQ on this topic, the easiest way to get around this is to make all the promises Void by using asVoid() and then to unwrap the original promise\u2019s value in your then:\nswift\nwhen(resolved: [a.asVoid(), b.asVoid()]).then { _ in\n    if let resultA = a.value {\n        //\u2026\n    }\n    if let resultB = b.value {\n        //\u2026\n    }\n}\nOr don\u2019t use when(resolved:); honestly, most of the time when people want to use it it is because they are using promises wrong. I have used when(resolved:) twice in 5 years of constantly using PromiseKit.\nIf you would like improvements to this domain, then you can contribute to when(resolved:) by copying the tuple methods provided for when(fulfilled:) or you can appeal to Swift Evolution and ask that some variety of generic-generic tuplizing functionality be added to Swift proper.. > Or don\u2019t use when(resolved:); honestly, most of the time when people want to use it it is because they are using promises wrong. I have used when(resolved:) twice in 5 years of constantly using PromiseKit.\nLike for example, you said you must recover from one of the two promises, but not the other, so maybe you should use recover:\n```swift\nlet b = a.recover { err -> TypeOfA in \n   // error handling\n   return someDefaultValueForTypeOfA\n}\nwhen(fulfilled: b, c).then { resultOfA, resultOfB in\n    //\u2026\n}.catch {\n   // this won't happen if a fails\n}\n```\nThis way if b fails you are still properly handling its error rather than potentially missing it.. Swift bug. Fixed in Swift 3. Not much more we can do.. Indeed, there's two separate chains, which are raced, thus both chains will complete. To prevent the right chain completing if the left chain times out you must incorporate the timeout into the right chain also:\n```swift\nenum PromiseError: Error {\n    case Timeout\n}\nfunc poll(signal: @escaping () -> Bool, interval: TimeInterval, timeout: TimeInterval) -> Promise {\n    let timeout = after(interval: timeout).then { throw PromiseError.Timeout }\nfunc pollRecursive() -> Promise<Void> {\n    guard timeout.isPending else { return timeout }\n    return signal() ? Promise(value: ()) : after(interval: interval).then(execute: pollRecursive)\n}\n\nreturn race(after(timeout, pollRecursive())\n\n}\npoll(signal: randomSignal, interval: 1, timeout: 2).then {\n    print(\"done\")\n}.catch { error in\n    print(\"error\")\n}\nfunc randomSignal() -> Bool {\n    let r = arc4random_uniform(4) == 0\n    print(r ? \"Complete\" : \"Not complete\");\n    return r\n}\n```\nrace is still necessary.. > It errors on the \"return when\" line because it says that it expects a void promise and mine is not.\nThat's because your when returns Promise<(BusPollResults, PlanePollResults)> but you annotated the closure to return Promise<PlanePollResults>\n\nI don't know if its possible to do a when with different type of promises. One is for PlaneResults and the other is for BusResults.\n\nYes, you're already doing it.\n\nAs far as my understanding goes, JOIN or WHEN, wait for all of them to complete. I don't really care, they don't need to complete \"at the same time\" and one does not depend on the other. I just want them to run at the same time.\n\nPromises start immediately, so, just create them and they already run at the same time.\n\nSo I could \"separate\" them out into different promise \"chains\", BUT they both depend on the first search promise. So in summary, they both depend on the first search promise to be able to start, but once that happens, they can go on their own separate ways and don't depend on each other in any way.\n\nSure, just create new chains:\n```swift\nfirstly {\n    searchService.search(searchQuery)\n}.then { searchResults -> Void in\nbusPoll().then {\n    //\u2026    \n}\n\nplanePoll.then {\n    //\u2026\n}\n\n}\n```. > So promises start as soon as they're initialized, or until .then is called?\nPromises make no decision whatsoever about when the underlying tasks they represent start. See the FAQ.\n\nThis is the final code. Does it seem reasonable?\n\nNot really. You are doing three catch handlers, one for each promise. You may as well just use completion blocks if you are going to use promises like that. One of the primary reasons to use promises is so you can consolidate error handling at a lower layer and thus handle error conditions for a wider amount of state conditions.\n\nI was thinking, knowing that both poll promise chains have finished might be useful for UI purposes, like stopping an activity indicator for example.\nI could use join or when, so the promise completes when all of them complete, that way I know when they are all finished.\nBUT then I'm back to square one, because I also want to know when each one is finished, I don't need to wait for all of them to complete to update UI. That's why I followed your example of creating separate promise chains each one with their own .then handler.\n\nDon\u2019t forget, promises are composable:\n```swift\nfirstly {\n    searchService.search(searchQuery)\n}.then { searchResults -> Void in\nlet p1 = busPoll().then {\n    //\u2026    \n}\n\nlet p2 = planePoll.then {\n    //\u2026\n}\n\nreturn when(fulfilled: p1, p2)\n\n}\n```\n\nI think I need to somehow merge the POLL implementation, with the RETRY implementation in the docs, and implement some form of RECOVER. But the recover function returns a \"default\" value of some sort. I just really want to tell the promise chain to continue, and ignore the error.\n\nThe only logical way recover could work is if it returns a default value, for example:\nswift\nfoo().then {\n    return 1\n}.recover {\n    // ignore error\n}.then { x in\n   // what is x if recover returns nothing? This is an impossible situation.\n}\nSwift itself cannot compile this scenario, which is a reason promises in typed languages work so well.\nIf you find yourself with no logical value to return then you should probably be using Void promises.. > Just realized this is possibly going to create two separate promise chains. damn. :(\nIt does not, at least the code above does not.. Yes it should do that.\nMight be sensible not to ignore all errors though.. How are you using PromiseKit 3 with Xcode 8.3? PromiseKit 3 uses Swift 2. Xcode 8.3 doesn't support Swift 2.. Yeah, I dunno about PromiseKit-AFNetworking it is not maintained by us. Probably it will work without much modification and probably isn't more than a couple of files you can drop into your project.. @nikhilwhizdhavale like I was saying in your ticket, you need to rebuild all your Carthage frameworks because they were built with Xcode 8.2 and you are now using Xcode 8.3. This is how Carthage works, for further information please see their documentation.. Dupes #669. @girees take @nikhilwhizdhavale's advice carefully as his problem is unrelated to this ticket. . Thanks, and 4.2.1 tagged.. If you have any interest in getting our CI to build on Linux too, then we will for sure avoid this sort of thing in future.. Promises are slightly worse than general asynchronous programming for this, but this is just the nature of asynchronous programming. Sorry. There isn't much to do except add a lot of logging.\nEdit: well you could generate errors that include more information. If you control the errors.. As a debugging method you could make the creation of the error include #file and #line implicitly which would help a lot. If you control the errors.\nif you don't control the errors I'm not sure there's much that can be done to help. You just have to add a lot of breakpoints and logging. Sorry, but this is just the nature of it, at least at this layer of our understanding.. Every handler (then, recover, Promise.init, etc.) would need to record #file and #line and then if an error is thrown in that handler, it would need to record this information with the error objects the promise stores.. Thinking about it, we could probably add this as a feature to PMK 5.. PMK 5 adds #file and #line to every then.. swift\nreturn Promise { fulfill, reject in\n    var x = 0\n    func attempt() {\n        doSomeAsyncTask { success, error in\n            if success {\n                fulfill()\n            } else if x < 5 {\n                x += 1\n                after(interval: 1).then {\n                    attempt()\n                }\n            } else {\n                reject(error)\n            }\n        }\n    }\n    attempt()\n}. > And how can i make this thread safe as x can be called by multiple response thread? \nPromises are implicitly thread-safe. See the FAQ.\n\nJust a query in your code the next call is made when the response of the previous calls come but actually i need to make the next call irrespective of previous response or not.\n\nI'm finding it very difficult to understand what you want. This is my best attempt, if this isn't correct maybe you could try to explain your needs again:\n```swift\nreturn Promise { fulfill, reject in\nsuccess = false\nx = 0\n\nfunc go() {\n    x += 1\n    asyncTask {\n        if $0 { success = true }\n    }\n    after(interval: 1) {\n\n        if x < 5 {\n            go()\n        } else if success {\n            fulfill()\n        } else {\n            reject()\n        }\n    }\n}\n\ngo()\n\n}\n```\n. \n```swift\nreturn Promise { fulfill, reject in\nenum State {\n    case polling(Int)\n    case finished(PromiseKit.Result<T>)\n}\nvar state = State.polling(0)\n\nfunc go() {\n    switch state {\n    case .polling(let attempts) where attempts < 5:\n        asyncTask { success, error in\n            var interval = 0\n            if success {\n                state = .finished(.fulfilled(success))\n            } else if attempts == 4 {\n                state = .finished(.rejected(error))\n            } else {\n                state = .polling(attempts + 1)\n                interval = 1\n            }\n            after(interval: interval).then(execute: go)\n        }\n    case .polling:\n        fatalError(\"Shouldn't be possible (state machine error)\")\n    case .finished(.rejected(let error)):\n        reject(error)\n    case .finished(.fulfilled(let success)):\n        fulfill(success)\n    }\n}\n\ngo()\n\n}\n```. Really great!\n\n@mxcl I'm not sure if an update to the README with some instructions about docker-compose is required.\n\nProbably not. The README is really for consumers of the library. Us maintainers can record the specifics of its maintenance here.\n\nLet me know if we want to expand on that.\n\nSeems great and I'm very happy we can now ensure Linux will not break.. What is FitShop-Swift.h for? Usually it would be a bridging header for your ObjC code to your Swift code in your project. Is that what it is? Why is it there?. Closing due to lack of response.. Do a clean. You have to clean whenever you upgrade Xcode when building anything that contains swift, not just promise kit. . The compiler message is very clear. Something is compiled with swift 3.0 (Xcode 8.2) and something is compiled with Swift 3.1 (Xcode 8.3). Modules compiled with different versions of swift cannot be linked.\nClean is the solution. Try a more thorough clean.. I see you are using Carthage. Do a Carthage update\nFor more information see the Carthage documentation.. Dupe. I closed #669 in favor of this one.. I would have fixed this by now if I was provided with a test project. As it stands fixing it is otherwise a lot of work. And I already have a lot of work.. At this point I think this is too old to be worth fixing.. swift\nwhen(fulfilled: images.map(upload)).then { results in\n     //\u2026\n}\nOr if for some reason you really want to do them serially:\nswift\nvar images = images\nreturn Promise(value: ()).then { _ -> Promise<Void> in\n    if let img = images.popFirst {\n        return self.upload(img)\n    } else {\n        return Promise(value: ())\n    }\n}\nHowever you should have good reason to not use when because it will be n times faster.. I've not personally noticed this.. Like, a test project that proves it would be good.. Possibly if you specify the return types of the closures it helps?. Interesting, thanks for bringing this to our attention.. If you will, please report this to http://bugs.swift.org\nI cannot, it's quite possible that people at Apple will not listen to me anymore.. Obviously I'm not the expert, but my layman's observation is this looks like an O(n) situation. Linear chain.. I find Swift 4 much improves this.. Swift compiler bug. Wait for Swift 4.. Well, it's the only fully-proper solution. There are other ways to do it though, like the ones we already do.\nI don't think we can do this, but if we could it would be perfect.. Not possible.. Also, you can use our Alamofire extensions: https://github.com/PromiseKit/Alamofire\nWe already did the work for you.. In case someone gets here via Google the solution is: \nswift\npublic func getToken() -> Promise<String> {\n    return Promise { fulfill, reject in\n        Alamofire.request(\"url\", method: .post, encoding: JSONEncoding.default)\n            .responseData { response in\n                if let data = response.data {\n                    let xml = SWXMLHash.parse(data)\n                    fulfill(xml[\"authResponse\"][\"authToken\"].element?.text)\n                } else {\n                    reject(MyError.errorCase)\n                }\n            }\n    }\n}. swift\ngetUserName().then{ username in\n    self.update(username).then{ ($0, username) }\n}.then { isSuccess, username in\n    self.search(username)\n}\nBut like Nathan says, rather than have a success boolean you should reject the getUserName() promise if it fails with a custom error.. Assuming resolved.. http://promisekit.org/docs/objc/. Closing due to lack of response. . Sounds sensible to me and indeed, not sure how we missed this.\nPR welcome. If you don't get to it, I'll do it by the next release. But it should be an easy enough PR and if you fancy it, we'd love to have it.. This is good.\nHowever, I fear deprecating after(interval: but then adding a new function called after(interval: will just confuse Swift in use.\nI'd like to do some testing in a playground first before we can decide.. \n. You solved your problem ok?. np, we're here to help.. PromiseKit 5 allows this.. We support it in that we don't not support it. If you have a fix we will apply it. . I cannot fix this, I don't know how to make an objective C++ project.. The issue still exists, but I'll need your help or someone else\u2019s.. Closing due to stagnancy.. > \"PromiseKit: Pending Promise deallocated! This is usually a bug\" \nYou don't reject or fulfill the promise in one path. I just about see that path in your screenshot. Troubleshooting tips for this issue are documented here.\n\nAfter the error appears in the log, my .catch or .always closures are never called.\n\nCanceled errors do not run catch typically. See the cancelation documentation.. Ah, yeah this is a dupe of some other ticket.\nApple marks this error as a cancelled error which is surprising to us and you.\nI thought we had added logging for this situation though.. The issue is that Apple are incorrectly using a \u201ccancelation error\u201d for this API.\nGenerally this is a useful feature because it allows you to handle cancelation as you would want it to be handled in cases where things are canceled.\n\nFor the record: other approach is to change the cancelation NSError to a custom type, for example an error enum called \"networkCancellation\", and reject with that. So PromiseKit catches it, but you can still say that there was a cancelation error.\n\nThis is what happens.. We have justification in the 2.0 release post: http://promisekit.org/news/2015/05/PromiseKit-2.0-Released/\nThis is a useful feature that makes it less likely you'll throw an alert in the user's face that says \"ERROR YOU CANCELED THE REQUEST\".\nI am considering removing NSURLErrorCanceledError from the list of canceled error types since it causes this issue.. As I say, it's a bug, just not at a layer we can fix. So if everything worked you never would have been surprised.. Please provide a code sample or some context.. I think you are using NSURLSession?\nIf so PromiseKit is merely a wrapper around the Apple API. Apple doesn't provide an error for a non 200 status code, so we don't reject the promise.\nIf you require this then the suggested path is to create a class that handles HTTP, or to use Alamofire.. The join resolves the promise.. Joint exists to replace:\n```swift\nlet (foo, fulfill, reject) = Promise.pending()\npromise.then(fulfill).catch(reject)\n// with\nlet (foo, joint) = Promise.joint()\npromise.join(joint)\n```\nSo for your situation you probably want just .pending().\nI'm not improving the docs on Joint as it was an experimental feature we intend to remove due to insufficient value and we have a different way to do it for PMK5.. PromiseKit 5 abandons this construct..     Promise(error: err). It takes ~40 minutes for cocoa pods to lint PMK and every time I tried it failed. I succeeded in not killing myself in frustration, but have been unable to summon the courage to try again.. You can use it without it being published (docs are online for using a tag), and next time I have the time, I will try to push again.. Pushed.. PromiseKit is a minimal wrapper around asynchronicity.\nHow would you cancel all the asynchronous tasks your app is doing without PromiseKit? That is how you do it with PromiseKit too.. Sorry cannot merge, the after is correct for the next version of PromiseKit which I intend to release quite soon. The rest is fine though.. https://github.com/mxcl/PromiseKit/blob/master/Sources/after.swift. You're a star \u2b50\ufe0f. The only easy way to do this is to add the chain to the completion handler.\nThe harder way would be to write your own .then for the firebase object returned from observe which returns your own \u201cpromise-like\u201d objects that do the same as above but you'll get your cleaner code.\nPromises only complete once, which is their feature, and in places like this, their curse.. Yes, it is possible. Try specifying return types on your then blocks to see if it helps the compile solve it faster.\nHowever you can't add a then to a catch, if that was what you were trying.. The code for Swift is pretty simple:\nprivate func _race<T>(promises: [Promise<T>]) -> Promise<T> {\n    return Promise(sealant: { resolve in\n        for promise in promises {\n            promise.state.pipe(resolve)\n        }\n    })\n}\nThe state property is internal however, so you'd have to split that out into a fulfill and reject.\nAnd PR welcome on this.. In fact for ObjC you must write it in ObjC because of the Swift->ObjC rules.\nI think you can use the AnyPromise.__pipe function that is provided to ObjC, PMKWhen uses it too.. I doubt we'll merge PMKTimeout since it can be expressed as:\nPMKAfter(2).then(^{ @throw myTimeoutError; })\n\nI'm not sure what PMKTimeoutExec is meant to do, but isn't it just:\nobjective-c\nid timeout = PMKAfter(2).then(^{ @throw myTimeoutError; })\nPMKRace(foo, timeout).then(^{\n    return promise;\n});\n?\nYou didn't provide your sample for PMKRace.. Code was trivial:\nobjc\nAnyPromise *PMKRace(NSArray *promises) {\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n        for (AnyPromise *promise in promises) {\n            [promise __pipe:resolve];\n        }\n    }];\n}. This is \u201ctuplegate\u201d, you can google it for more information. You may also want to let the Swift team know how awful it is for you so they are further incentivized to fix it before 4.0-gold.\nHere's the current fix:\npublic func shouldReturnVoidPromise() -> Promise<Void> {\n    return Promise { fulfill, reject in\n        fulfill(())\n    }\n}. I'm not sure this specific change is being backed-out.. https://twitter.com/slava_pestov on Twitter specifically told me it wasn't a bug and the fact it worked nicely before was the bug. Might be worth bugging him.\nOtherwise you can report the bug to http://bugs.swift.org or make fuss on the swift-dev mailing list.\nI agree it is lame.. There is no fix\u2026\nEdit: do you mean you're having trouble compiling PromiseKit? If so you need to update. PromiseKit 4.4 has been compiling with Swift 3.2 and 4 for weeks now.. Leaving this open so people can find solutions. Will eventually close.. @nalexander50 been waiting for your ticket, happy to help, if you open it.. @cvoisey please open a new ticket as what you are talking about doesn't seem related to this thread.. > I'm definitely interested in progress on this.\nLike, there's nothing we can do about this. PromiseKit 4 compiles with Swift 3.0, 3.1, 3.2 and 4.0 with Xcode 8 and 9. After that you have to modify your code that uses promises as described above because this is what Swift 4 requires.\nThe other option is to stick with Swift 3.2, which Xcode 9 supports.. I'd probably just do this:\nmyTask() -> () -> Promise<Void> {\n    return {\n        // return promise\n    }\n}\nThere is no API for this though, no.. Thanks!. 1. How did you install PromiseKit?\n2. Did you import PromiseKit?. You are having a link error and have not provided the link error message. I cannot help until you provide the link error message. To do this you need to open up the build log and click through, then copy the message here.. Your project cannot find PromiseKit to link it, this means your CocoaPods installation is incorrect. I suggest following the instructions at cocoapods.org for how to integrate with an existing xcodeproj.. The usual steps are:\n\nCreate the Podfile\npod install\nOpen the xcworkspace NOT the xcodeproj. Perhaps you need to tell your Podfile to depend on PromiseKit in the test target also.\n\nhttps://github.com/CocoaPods/CocoaPods/issues/4944. Please open a new ticket.\nEdit: quick tips:\n\nCheck that PromiseKit is in your link and embed lists in your project settings\nCheck that PromiseKit.framework can be found in your framework search path in build settings\n\nRe-add PromiseKit following the Carthage homepage guide to adding frameworks installed by Carthage. Closing due to lack of response.. 1. You can not import the Foundation extensions by specifying:\npod 'PromiseKit/CorePromise'\n\n\nYou can specify import class PromiseKit.Promise in files that are effected.\n\nYou can specify the return type of the dataTask type so Swift knows which version to use.\n. FFR in PromiseKit 5 (unreleased next major version) we do not cause ambiguity. I regret that there is ambiguity currently.. You will experience this with all pods with Xcode 9 until Xcode 9 is fully released.. Use when(resolved:)\n\nhttps://github.com/mxcl/PromiseKit/blob/master/Sources/when.swift#L212-L231. Or more simply:\nwhen(fulfilled, p1, p2, p3.recover{ defaultValue }).then {\n    //\u2026\n}. Something like this?\ntokenizeCard().then { token -> Promise<Payment> in \n  return makePayment(token)\n}.then { payment -> Promise<Void> in\n  return updateUserModel().}.then { user in\n  //\n  }.asVoid().recover { }\n}.catch { error in \n  print(\"ERROR\")\n}. Your two comments are correct.\nasVoid() returns a new promise that is Void, it is directly equivalent to then{ _ in } which can be seen if you check the sources.. Yes sorry, I am in the process of fixing all the extensions. As we speak even.\nFYI: you can do this:\npod \"PromiseKit\", \"~> 4.3\", subspecs: ['CorePromise']\n. Should be fixed with (the just released) 4.4.0. LMK if this isn't fixed.. Please open a new ticket including files and line numbers. Thanks.. According to the CocoaPods documentation swift_version in the Podfile controls the Swift version used for the generated project.\nThat's all I know. If you need to know more you will have to ask team CocoaPods.\n\nNote: Also the same documentation points to a \"swift4-beta1\" which does not exist.\n\nPromiseKit 4.4.0 supports Swift 3.0, 3.1 and 4.0 now. I will update the documentation you are talking about if I can find it.\nI only released 4.4.0 8 hours ago, so please forgive this lapse.\nUpdate: You probably don't need to specify this in your Podfile. Xcode 9 supports side by side usage of Swift 3.2 and 4.0. Your app can be 4.0 but the pods can be 3.2.. I have removed this instruction as it no longer seems recommended by CocoaPods.. I suggest a fresh pod install as the function it cannot find is absolutely part of PromiseKit 4.4.0:\nhttps://github.com/mxcl/PromiseKit/blob/6b18b8826ea46f970d4c580614c492cb30a3f314/Sources/Error.swift#L110-L113. Notably this is a function that the compiler generates the header for, so it seems like the compiler failed to generate the header.. So I would clean and try again.\nLike always, if you don't actually use any of PromiseKit\u2019s UIKit extensions then you can remove them from your Podfile:\npod 'PromiseKit', subspecs: ['CorePromise']. There is not a better solution with promises that I know of.. Works for me.. I will push the new Pod this evening.\nUntil then you can use this tag thus:\npod 'PromiseKit', :git => 'https://github.com/mxcl/PromiseKit.git', :tag => '4.4.1'. Please forgive me, pushing to CocoaPods takes an hour, during which time my computer is out of action due to the 100% CPU usage required. Every time I do the push it fails. I have wasted tens of hours on this.\nFor now use the above work around is completely identical to the eventual push.. K done.. Yeah, none of this code has changed for years. For serious.\nThe swift4 branch was merged to make 4.4.0.. Please check our Troubleshooting guide regarding this warning. It is serious and the fact you saw it probably means that some part of your code does not handle all completion paths. If a path is not handled it will result in non terminating chains that to the user will look like a \u201ctask\u201d that never completes.. Fixed with the 5.0.0 release.. Well since the code is Swift and this crash is inside the reference counting machinery, if it is inside PromiseKit then it's a Swift bug (and you are using a brand new Swift version).\nPossibly the crash is in your closures that PromiseKit invokes, though the backtrace doesn't suggest that, backtraces often seem to skip such information. If your closure is using an unowned reference of some kind (PMK has no such use), then that would crash like this.\nPossibly of course it is a bug in PromiseKit, but we haven't received this report before and this code hasn't changed in years, and we are a top 100 pod.\nSo I can't offer a lot of advice. Certainly if you keep seeing it then maybe we can get a bit more from the backtrace and perhaps figure it out.. Closing as not heard this from anyone else and probably is a Swift bug.. then is only fulfilled once this is a foundational feature of promises. If you need a closure to be called many times you have to use something else. Facebook's KVOController is good IMO, or if you are using Swift 4, type-safe closure-based KVO is now part of the runtime, so use that.. Indeed, there is no good solution for Firebase with PromiseKit. I should probably add this to the FAQ.. I included an example of something you can do in the above referenced document. It's probably not what you were hoping though.. 4.1.8 had a specific change for Carthage only, so had no reason to be released for CocoaPods. Why do you need it?. OK, well it doesn't hurt. But linting takes ~1 hour, so I can only do it last thing as otherwise my computer is out of action, plus I cannot guarantee the linting will work since I am now on Xcode 9 and this requires Xcode 8. In fact I'm pretty sure it will not work. Hmm.. > This should work, right?\nLike I said, I doubt it will lint unless I install Xcode 8 which I guess I can do, but this will be a lot of time for me to spend, and I don't have much time available currently. Linting takes an hour and it probably will fail for some other revlock issue which will then waste more time.. K, I disabled lint and pushed it.. Our Carthage has never provided the Foundation, UIKIt, etc extensions because Carthage is not flexible like CocoaPods so we cannot provide \u201csubmodules\u201d so users could not choose whether or not to have the extensions like they can with our Pod.\nThus you have to add them yourself. Grab the sources for each extension you want at https://github.com/PromiseKit either manually or with submodules.\nIf you were to use a newer version of PromiseKit you can add these dependencies additionally in your Cartfile, however we did not add this feature until PMK3, so you cannot do without causing Carthage to pull at least PMK3.\nThere are more details in our installation instructions, but we don't really go into the details for PMK1 since we honestly didn't think anyone was still using it! Sorry.. Actually, IIRC the extension sources are provided with PMK1, so you can just add them from the Carthage checkout.\nStill manual though.. Good spot! Thanks.. Super, thanks!. This is a CocoaPods issue, here is a thread where solutions are offered: https://github.com/CocoaPods/CocoaPods/issues/6791. Confirmed, please upgrade to 4.4.2.. 4.1.8 is now deleted.\nHowever, please upgrade. There is no reason I can see you'd want to stick with 4.1.x.. Indeed, PromiseKit has nothing to do with this.\nMaybe CocoaPods does though.. PMK does not define its inter module dependencies, CocoaPods and Xcode are responsible I recommend opening a bug report with one of those two entities.. Oh interesting.\nIt's been a while, but I don't think we can rewrite in Swift since we are doing objc hackery. Maybe there's a better solution though.\nAnd yeah, well I should have known this would break stuff.. I will fix this when I have time, but currently I do not.\nI use Carthage with all my projects. I recommend switching if possible. It has other advantages, for example one project went from having an incremental build time in the minutes to seconds.. Carthage pre-builds the frameworks so there can be no dependency cycle.\nEdit: well I am assuming the dependency cycle is generated only when PMK is a dependency. But either way Carthage by-passes it because it doesn't use the new build system.\nObviously we will fix this, but I don't have time currently.. Fix incoming, requires use of PMK 6 though.\nWill accept a back port PR.. https://github.com/mxcl/PromiseKit/commit/d1248ae5115306b31ae6e931af630d23862686ae. Fixed in PMK6 that I will push to CocoaPods this afternoon.. Upgrade. We\u2019re up to 6.8.3 now.. If attributionDetails is empty you call neither reject or fulfill. We provide more details of this kind of issue in our trouble-shooting guide.. Your above sample does not correct the issue I refer to. If attributionDetails is empty, then you don't fulfill or reject.. swift\nfor (type, adDictionary) in attributionDetails! {\n    let attributionDictionary = adDictionary as! Dictionary<AnyHashable, Any>\n    return fulfill(attributionDictionary)\n}\nreject(SomeError.emptyAttributionDetails)\nThe last line fixes the path where attributionDetails is empty and thus you never resolved the promise.. swift\nfunc getSearchAdsInfo() -> Promise<[AnyHashable: Any]> {\n    return Promise { fulfill, reject in\n        ADClient.shared().requestAttributionDetails{ attributionDetails, error in\n            if let attributionDetails = attributionDetails {\n                for case let value as [AnyHashable: Any] in attributionDetails.values() {\n                    return fulfill(value)\n                }\n                reject(MyError.invalidAttributionDetails)\n            } else if let error = error {\n                reject(error)\n            } else {\n                reject(PMKError.invalidCallingConvention)\n            }\n        }\n    }\n}. If all paths are covered then almost certainly your code in requestAttributionDetails is not calling the callback under certain circumstances.\nPromiseKit is 5 years old now, it works.. Oh it\u2019s Apple's function? Well, I'd be surprised if theirs does not call the callback. I could be wrong, but that's unusual.\nStill, I'd be super surprised if it's PromiseKit not working. This is so thoroughly tested at this point.. I'd look elsewhere, the warning doesn't give any context (unfortunately, but fixing that is hard). Is there another promise that may be causing this warning?. Well if it does turn out to be Apple's fault (bad Apple!) then you can work around by adding a timeout:\nswift\nfunc getSearchAdsInfo() -> Promise<[AnyHashable: Any]> {\n    let p1 = Promise<[AnyHashable: Any]> { fulfill, reject in\n        ADClient.shared().requestAttributionDetails{ attributionDetails, error in\n            if let attributionDetails = attributionDetails {\n                for case let value as [AnyHashable: Any] in attributionDetails.values {\n                    return fulfill(value)\n                }\n                reject(PMKError.nilPromisable)\n            } else if let error = error {\n                reject(error)\n            } else {\n                reject(PMKError.notPromisable)\n            }\n        }\n    }\n    let p2: Promise<[AnyHashable: Any]> = after(seconds: 10).then{ throw E.timout }\n    return race(p1, p2)\n}. Closing due to stagnation.. 4.4.3 pushed.. With what? URLSession? Alamofire? OMGHTTPURLRQ? BoogieFoogiePlats?. You add them to the URLRequest just like if you weren't using PromiseKit.. Sorry for my delay here, I am pressed for time currently.. I may have to say: use Carthage. CocoaPods barely works, here is an example of it. I cannot change the macOS deployment target to a lower value or the podspec won't pass even though there is no reason for this to be the case.\nEdit: k this works now with CocoaPods 1.4.. K this is now live on CocoaPods too for 6.0.1.. I need some official docs before I'm going to implement support. Been bitten otherwise in the past. Is there any do you know?. I\u2019m still waiting on some kind of  official blessing from the CocoaPods team. . I can's support this then I guess. The docs suggest we either say we are a static or a dynamic framework, but static frameworks are less useful.\nI don't really get why CocoaPods chose to implement this feature this way. Really it should be something the Podfile decides on and not the .podspec. Documented workarounds here: https://github.com/mxcl/PromiseKit/blob/master/Documentation/Troubleshooting.md. I don't think we ever had this property on AnyPromise.. K well, this was a long time ago.\nI don't particularly want to rock the AnyPromise boat. It is a mess of badness due to how it uses the Swift/ObjC boundary.\nQuite possibly this is how they came to be removed.. np, and I appreciate the thanks. I am but human too. This fix is not yet released, but will release 6.0.1 soon.. Please provide the following information:\n\nInstallation method (I'm assuming you are building manually, but how? Bundling the xcodeproj? Building separately and copying in the binary?)\nPlatform target. K, sucks. PR welcome, or I can do it.\n. I've done it.. Something like:\n\n```swift\nfunc next() -> Promise<\u2026> {\n    return firstly {\n        return showThirdPopup()\n    }\n    .then { info3 -> Promise in\n        dismissThirdPopup()\n        if foo {\n            return next()\n        } else\n            return showForthPopup()\n        }\n    }\n}\nfirstly {\n    return showFirstPopup()\n}\n.then { info1 -> Promise in\n    dismissFirstPopup()\n    return showSecondPopup()\n}\n.then { info2 -> Promise in\n    dismissSecondPopup()\n    return next()\n}\n.catch { error in\n    //\u2026\n}\n``. It'sPMKWhen().. You probably just have to runpod update` again.. For your reassurance: PromiseKit is 100% extension-API-safe. You could tell by opening the xcodeproj and observing we have this checkbox set, or using Carthage which doesn't exhibit these sort of issues.. > is the order of the [Result] array the same as the Promises I passed in?\nYes.. You have to specify the type of deletes. This is in our troubleshooting guide.. let deletes: Promise<YOURTYPEHERE> = \u2026. PR welcome, otherwise I don't have a clue what to do with this output.. I'd like something to be done if necessary. Keeping open for discussion.. I ran it against PMK 6 and I don't think any of the issues it continues to highlight are valid, eg:\nobjc\nSources/after.m:9: error: DEAD_STORE\n  The value written to &time is never used.\n  7.   AnyPromise *PMKAfter(NSTimeInterval duration) {\n  8.       return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n  9. >         dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));\n  10.           dispatch_after(time, dispatch_get_global_queue(0, 0), ^{\n  11.               resolve(@(duration));\nWell\u2026 clearly time is used.. PMK5 (recently released has wait())\nhttps://github.com/mxcl/PromiseKit/blob/master/Sources/Promise.swift#L73-L98\nNow, it operates differently, and I don't know which approach is better.\nAlso, do you use PMK5 and not 4? I haven't pushed 5 to CocoaPods yet is why I ask. I planned to write a blog post and document it better first.\nAnyway, this is much appreciated. What do you think? Do you want this in 4, maybe also in 5? Do you think the approach you have taken with runloops is the more sensible choice?\nI'm not sure really, I added wait() to PMK5 as an experiment, so I don't have firm feelings on this matter.. K cool, then I think we need to offer both, so I'll figure out how to merge this.. Tests fail for iOS, tvOS and watchOS.. Will merge, when CI passes.. Change line 2:\nreturn Promise<Void> { fulfill, reject in. We provide a promise function as an extension on DispatchQueue for this usage. eg:\nswift\nDispatchQueue.global().promise {\n    return foo()\n}.then {\n    //\u2026\n}\nfirstly cannot take a queue without meaning it has dual behavior, the default case executes the closure immediately, if it also took a queue it would mean in some cases it would immediately execute the closure and in others it would execute it later. This violates the principle of least surprise and allow zalgo to be unleashed.\nhttp://blog.izs.me/post/59142742143/designing-apis-for-asynchrony. > Also, while I am here, do you see any immediate way to put that LoadingViewHelper.present call into the chain besides just making it a statement inside firstly?\nI don't know what this function does so cannot really advise.. ```\nlet q = DispatchQueue.global(qos: .background)\nq.async {\n    firstly {\n        self.createUser(newUserParametersDictionary: parametersDictionary)\n    }\n    .then(on: q) {\n        self.createNewUserSession(username: username, token: $0)\n    }\n    .then {\n        Session.current = $0\n    }\n    .always {\n        //\u2026\n    }\n    .then {\n        //\u2026\n    }\n    .catch { error in\n        // error stuff\n    }\n}\n```. Or with PMK 6:\n```swift\nlet q = DispatchQueue.global(qos: .background)\nPromise { seal in\n    q.async {\n        self.createUser(newUserParametersDictionary: parametersDictionary).pipe(seal.resolve)\n    }\n}.then(on: q) {\n    self.createNewUserSession(username: username, token: $0)\n}\n.then {\n    Session.current = $0\n}\n.always {\n    //\u2026\n}\n.then {\n    //\u2026\n}\n.catch { error in\n    // error stuff\n}\n```. PR welcome. K added to the appendix, please review the above patch.. Next time open a new ticket :P. Can't see an issue. Please follow our troubleshooting guide, it contains steps to figure out what Swift is finding troublesome.. Specify types.. Presumably: make some global function that returns a promise that ensures a valid token: either returning the token or doing the UI/networking dance to get one. Probably it will need to return the same promise object if the token is being discovered.\nHowever, be careful with this sort of thing. I have tried these sort of patterns and find that the complexity of the app's state machine gets out of control. I prefer to just have the other requests fail nowadays.. fulfill retains its associated promise, so either the listener is released or the ReachabilityManager instance is released\u2026 would be my guess anyway.. Oh, more likely is that you are calling networkIsReachable() multiple times, but there is only one listener so the previous listener is deallocated and the promise you bound to it deallocates without being resolved.\nIf so I'd trust the warning since you probably have code that was waiting on the promise that now will never resolve.. ```swift\nprivate var promise = Promise()\n/// contract: must only be called on main thread (otherwise TODO: add thread locking)\nfunc networkIsReachable() -> Promise {\nguard promise.isResolved else { return promise }\n\npromise = Promise { fulfill, _ in\n    reachabilityManager?.listener = { status in\n        switch status {\n        case .notReachable:\n             log.debug(\"The network is not reachable\")\n         case .unknown :\n            log.debug(\"It is unknown whether the network is reachable\")\n        case .reachable(.ethernetOrWiFi):\n            log.debug(\"The network is reachable over the WiFi connection\")\n            fulfill(())\n        case .reachable(.wwan):\n            log.debug(\"The network is reachable over the WWAN connection\")\n            fulfill(())\n        }\n    }\n}\n\nreturn promise\n\n}\n```. Your promise code is fine.\nVerify that indeed all the uploads are happening, and that they for such situations the fulfill or reject is indeed being called for each promise.\nIf all promises resolve then either the then or catch in your chain will be called. We're 99.999% certain these code paths in PromiseKit have no bugs at this point after 5 years of triage.. FYI this code:\nswift\nstatic func uploadMultipleToS3(photos: [S3Photo], exp: AWSS3TransferUtilityUploadExpression? = nil) -> Promise<[AWSS3TransferUtilityUploadTask]> {\n    return Promise<[AWSS3TransferUtilityUploadTask]> { fulfill, reject in\n        firstly {\n            when(fulfilled: photos.map { uploadToS3(rawImage: $0.raw, photoId: $0.id, ext: $0.ext, exp: exp) })\n        }.then { results -> () in\n            print(\"S3 upload\")\n            fulfill(results)\n        }.catch { error in\n            print(\"upload err\")\n            reject(error)\n        }\n    }\n}\nis the same as:\nswift\nstatic func uploadMultipleToS3(photos: [S3Photo], exp: AWSS3TransferUtilityUploadExpression? = nil) -> Promise<[AWSS3TransferUtilityUploadTask]> {\n    return when(fulfilled: photos.map { uploadToS3(rawImage: $0.raw, photoId: $0.id, ext: $0.ext, exp: exp) })\n}. That is the old documentation,. please use: https://github.com/mxcl/PromiseKit/tree/master/Documentation\nIn addition we provide a Troubleshooting guide that exactly tells you how to deal with your error. This guide is linked from the README, always start at the README.. I am not ready to publish it to CocoaPods. Until then if you need it you can amend your Podfile too fetch ~> 5.0 via its tag.. I need to write a blog post explaining the changes, I need to rework the docs so there are branches for v4 and v5 and then update the README. So it's contingent on that. Hopefully I'll have time over the holidays.. I respect semver so there will be no breaking changes until 6. Closing in favor of #760 . Like usual, it's possible swift is lying about the error, so try putting the code in the closure outside the closure with an inline function.\nAlso try firstly { () -> Promise<JSON> in since the error suggests it doesn't like _. Still I'd be surprised if that works.\nSwift may in fact be erroring later in the chain, so eyeball it and see if you can spot a syntax error elsewhere.. You didn't specify which PromiseKit version you are using, this was part of the template so you deliberately refused to provide that information. I cannot help you without that information so you are wasting everyone's time.. The issue was you were using PMK5 but with a PMK4 API.. You could try conforming a custom object to Thenable. Closing due to lack of response.. If you get ambiguous use errors, annotate the closures with their return type.\nFor more information on this on other common errors see our trouble shooting guide.. Per the troubleshooting guide, you can solve this by specifying return types for your closures.. PR welcome.. PromiseKit is a light wrapper around whatever you wrap. It has no bearing whatsoever on the performance or behavior of the things you wrap. If you are having issues with Alamofire then it is Alamofire that is the problem.\nAs an aside, why are you using DispatchGroups? If you are using PromiseKit then I'd suggest using Promises for such things.. With when obviously.. I pushed 1.7.4 to CocoaPods and tagged it for Carthage.. If you require documentation, continue to use v4. v5 documentation will be provided when I have time. You will not have to upgrade to v5 as both v4 and v5 will be supported forever.. Feel free to use PMK5 and then if you then feel able to update the documentation, feel free.. I'm releasing PMK 6 (which is 5, with a minor breaking change) today.. > Is recover guaranteed to be called if the geocode promise fails but is not chained directly after it?\nYes, recover will any previous part of its chain fails.\n\nIs there a better way to achieve what I want?\n\nBased on what you want, the way you are doing it is correct.. Yes, fulfill(()). This is not an issue specific to PromiseKit (it is in fact an issue with Swift 4), there are actually maybe 4 or 5 closed issues that ask this question and there are maybe 40 or 50 examples of fulfilling Void promises here on GitHub in the PromiseKit sources, but I will add it to our TroubleShooting documentation.. Changes from 3 to 4 were much less severe so hopefully 4 to 5 will be hardly anything.\nSearching tickets can be hard, especially when there are so many, so it's good you opened the ticket as it made me add a proper note in the trouble-shooting guide.. This is fixed in PMK5, but I can't fix it in PMK4 without changing behavior, which considering the wide usage of PromiseKit, is not responsible.\nIn PMK5 catch returns a special object (a PMKFinalizer) which you can call finally on (finally provides no object) but not catch, which IMO is the only correct behavior. PMK3 did not allow you to do anything after a catch, PMK4 returns the parent promise, so what you are doing above is actually this:\nswift\nmyPromise.catch{ /* block 1 */ }\nmyPromise.catch{ /* block 2 */  }\nEnabling this was a mistake on my part.\nI will close this ticket when PMK 5 is available on CocoaPods. Refs #760.\nLMK how else I can help. More discussion welcome, justification for PMK5 behavior can be provided\u2013just ask\u2013etc.. A work-around would be to use recover:\nswift\nmyPromise.recover(on: myQueue1) { error in\n    // Block 1\n    throw error\n}.catch(on: myQueue2) {\n    // Block 2\n}. > Although this would mean source breaking changes for users who are using their promises in the promise.catch{...}.catch{...) fashion, if I'm not wrong?\nPMK5 includes many, many source breaking changes, this is the least of them.\n\ndon't know whether I can call a recover on a recover--haven't tried it\n\nYes, it works as you would expect.. I'm releasing PMK 6 (which is 5, with a minor breaking change) today.. > Firstly, is this the right way to go about solving that problem?\nProvided stuff that uses thenIfKeyNotSet understands the semantics, then it's cool. I've never personally ever done things like that, but I don't have your context. I'm sure it's fine.\n\nSecondly, any idea why the following code is causing the compiler to spin indefinitely?\n\nYou don't have a return?. swift\nwhen(fulfilled: items.map(runasyncTask)).then { values in\n    // tada!\n}. Thanks, pushing 1.7.5 to CocoaPods.. Yes, you use OMGHTTPURLRQ directly. There's some docs here: https://github.com/mxcl/OMGHTTPURLRQ\nThough not for Swift, but should give you some initial direction.. ```swift\nfunc firstThing() -> Promise { /\u2026/ }\nfirstly {\n    firstThing()\n}.then {\n    if !ok {\n        return refreshToken().then(firstThing)\n    } else {\n        return Promise(value: something)\n    }\n}\n. Sorry I don\u2019t understand your question..\n@IBAction private func loadNotification() {\nfunc foo() -> Promise {\n    firstly {        \n        provaRequest()\n    }.then { dictionary -> Void in\n        //\u2026\n    }\n}\n\nfirstly {        \n    provaRequest()\n}.recover { error in\n    if case Error.foo = error {\n        return provaRequest()\n    } else {\n        throw error\n    }\n}.then { dictionary -> Void in\n    //\u2026\n}.catch { error in\n    // other errors\n}\n\n}\n``. The async tasks inrefreshimmediately start executing, so no, it isn't doing what you want. You need to wrap the whole thing in a function that returns the promise just like the example code I provided.. You got a warning because you didn'treturn`, it's telling you the result in unused, because it is unused.\nSeems like Promises are too advanced for your knowledge of Swift, I recommend going back to completion handlers.. Hi, the template for issue tickets explicitly asks for the promiseKit version you are using. You chose to ignore the template. How am I expected to help you if you won't help me?. Hi, we removed it between version 3 and 4 because the framework didn't use it. There is no replacement.. There is no documentation for these constants. You can search the source code for their usage if you require more insight.. Specifically where sorry?. OK, in the blog post? Please be more specific in your bug reports in future, it really takes away from an otherwise excellent ticket. :P. I'm copying flatMap from Swift\u2019s Optional, which behaves this way. Also the Array form behaves this way especially now one version was renamed compactMap. So it seems to me that I'm being consistent with the Swift standard library, which is my intent and we'll change our names if we are wrong. It's not too late, though the deprecations would be ugly, but I'd rather be right for sure.\n```swift\nOptional.none.flatMap(UIImage.init)  // => nil\nData().flatMap(UIImage.init)  // => nil\nvalidImageData.flatMap(UIImage.init)  // => UIImage\nOptional.none.map{ $0 + 1 } // => nil\nOptional.some(1).map{ $0 + 1 }  // => 2\n``. I didn't have time right this second to read your post thoroughly, but I will. Just thought I'd throw the above in in case it helped.. OK, what do you suggest?. For me, the way to think about promises is to imagine they didn't exist, to abstract away the asynchronicity. Thus it's like you calledflatMap` on the promise's value and not the promise, so the functional names should be named as though they act on the values rather than the promises.\nOf course this falls flat since the value is not an optional mostly. So really we should call it ifLet I guess, but this sucks too.\nAnyway, I'm all for not confusing functional names more in any land, especially Swift land. So provided we can figure out good names, I'm down.\nIn this respect, is map also bad?. Just brainstorming:\n\nmapIfSome\nmapIfNotNil\n\nOr should we stick clear of map here?. Yeah, so really then is flatMap, which I kinda already knew.\nK, well I don't want to muddy anything here, let\u2019s rename both flatMaps, the non-sequence one can have a nice name we can invent, the latter should probably be flatMapInner though I think this maybe this just confuses things (or maybe it's the opposite?). Still it's ugly. But IME it is rarely used.\nMainly my concern is a sensible set of names that people understand without having to read the documentation. Then after that is that we don\u2019t contribute to a wider misunderstanding of functional principles, and since PromiseKit is a popular library, we have that responsibility.\nThanks for the input, let's keep it going.. swift\nfirstly {\n    fetchImageData()\n}.ifLet {\n    UIImage(data: $0)\n}\nClear, but ugly. Probably should be our choice, but boy\u2026. swift\nfirstly {\n    fetchImageData()\n}.unwrap {\n    UIImage(data: $0)\n}. So we have:\n\nPromise<Sequence>.flatMap ~> Promise<Sequence>.flatMapValues\nPromise<Sequence>.compactMap ~> Promise<Sequence>.compactMapValues\nPromise<T>.flatMap ~> Promise<T>.unwrap\n\nHow are we feeling about these? Additionally, how about filter which we also provide? Finally, do we feel that if we go to this length the Swift stdlib team will also?. Could unwrap be compactMapValue and should it be? At this point I'm feeling a little hazy on understanding again.. Please review this preliminary PR: #782. Merged for release with 6.1.0 (today hopefully).. Tremendous, thanks.. Sure, I'll just do that for you right away.. Thanks for the PR~!!!!!!. https://github.com/mxcl/PromiseKit/commit/9a34665995832e942e07dc588726fbd95351fe75. I fixed this and supplemented the migration guide. Thanks for the report and sorry for the omission.. Much appreciated that you provided the error message so I wouldn't have to open a new project and compile it myself.. ```swift\nfunc attempt(interdelay: DispatchTimeInterval = .seconds(2), maxRepeat: Int = 3, body: @escaping () -> Promise) -> Promise {\n    var attempts = 0\n    func attempt() -> Promise {\n        attempts += 1\n        return body().recover { error -> Promise in\n            guard attempts < maxRepeat else { throw error }\n        return after(interdelay).then {\n            attempt()\n        }\n    }\n}\n\nreturn attempt()\n\n}\n``. K, updated. Trivial amendment that surely you could have figured out by youself, all you had to do was look at the function definition forafter()`.. Hi, I'll add this to the guide, I forgot. I removed this from the library because I didn't feel it was a good general solution (as well as a bad pattern due to violating encapsulation) and instead I recommend a custom solution each time. Our common-patterns guide contains this:\n```swift\nclass ViewController: UIViewController {\nprivate let (promise, seal) = Promise<\u2026>.pending()  // use Guarantee if your flow can\u2019t fail\n\nfunc show(in: UIViewController) -> Promise<\u2026> {\n    in.show(self, sender: in)\n    return promise\n}\n\nfunc done() {\n    dismiss(animated: true)\n    seal.fulfill(\u2026)\n}\n\n}\n// use:\nViewController().show(in: self).done {\n    //\u2026\n}.catch { error in\n    //\u2026\n}\n```\nWhat do you think?. LMK if you have any new ideas about it that we can supplement our guides with.. This is unreadable. Can you please use markdown to format your ticket? Even better, fork the project and fix these issues yourself.. Restored, very sorry. I need to get the hang of force pushing with \u201creceipt\u201d so it cannot lose new commits.. For PMK 2+ we renamed PMKPromise to AnyPromise. Not sure how to document this without being confusing to the 90% of people who use PMK 2+.\nIt's safer to use PMK6 nowadays since Swift is less volatile, so perhaps we should reconsider our recommendation. Certainly, it's a lot better code and API than 1.7 is at this point.\nIf your intent is for people to use your library with both Swift and ObjC then honestly, PMK6 is much better for that. If your library is just ObjC though, then 1.7 will be stable forever, while using Swift in libraries is going to be painful (albeit less painful than it used to be) for years yet.. >  from what I've understood using PMK6 will force my consumers to link against the Swift standard libraries, which might be unacceptable to some of them.\nYes, it will, but TBH nowadays avoiding Swift is pretty hard.\n\nJust to be sure: If a consumer depends on PMK6, will it be possible to use PMKPromise from my API without depending also on PMK 1.7?\n\nNo, the APIs are different. In addition CocoaPods will refuse to install two versions of the same library side by side.. See our release notes and migration guide, you need to use done, then requires you to return a Promise.\nNext time something is confusing, check the function signature of the thing you are using (then here), it would make it clear what is expected of you when Swift is incapable of telling you.. But I'm pretty sure the one I commented on is wrong, is it not?. | Form | Currently | Proposed |\n|-------------------------------------------|---------|------------|\n| Promise<T> => ((T) -> U?) => Promise<U> | flatMap | compactMap |\n| Promise<[T]> => ((T) -> U) => Promise<[U]> | map | mapValues |\n| Promise<[T]> => ((T) -> [U]) => Promise<[U]>) | flatMap | flatMapValues |\n| Promise<[T]> => ((T) => U?) | compactMap | compactMapValues |\n| Promise<[T]> => ((T) -> Promise<U>) => Promise<[U]> | thenMap | map\u2020 |\n| Promise<[T]> => ((T) -> Promise<[U]>) => Promise<[U]> | thenFlatMap | flatMap\u2021 |\n\u2020 should be flatMapValue or something.\n\u2021 seems correct as flatMap since we are flattening it back into a single promise from promises of the same value-type.\nEdit: Actually I guess \u2020 is flatMap and \u2021 is flatMapFlatten.\nEdit: Well, I guess not, since for \u2020 we flatten the promise but also our closure is the elements of the array, really it should be the whole array, so we are flatMapInnerMap and \u2021 is flatMapInnerFlatMap\nEdit: So therefore since then is just flatMap really, maybe we should go with thenMap and thenFlatMap as before.. K I pushed with this result:\n| Form | Currently | Proposed |\n|-------------------------------------------|---------|------------|\n| Promise<T> => ((T) -> U?) => Promise<U> | flatMap | compactMap |\n| Promise<[T]> => ((T) -> U) => Promise<[U]> | map | mapValues |\n| Promise<[T]> => ((T) -> [U]) => Promise<[U]>) | flatMap | flatMapValues |\n| Promise<[T]> => ((T) => U?) | compactMap | compactMapValues |\n| Promise<[T]> => ((T) -> Promise<U>) => Promise<[U]> | thenMap | unchanged |\n| Promise<[T]> => ((T) -> Promise<[U]>) => Promise<[U]> | thenFlatMap | unchanged |\n| Promise<[T]> => ((T) -> Bool) => Promise<[T]> | filter | filterValues |\n| Promise<[T]> => Promise<T> | last | lastValue |\nLMK what you guys think.\n/cc @nathanhosselton . I rebased the branch, hence CI is going again, but it is the same diff as the previous pass. Here is the CI for master:\nhttps://travis-ci.org/mxcl/PromiseKit/builds/343420367. Thanks!. Thanks!. Specifically what line is the error happening on?. OK, I just added your code to the PMKAlamofire project and it compiles fine\u2026\nSuggests to me the error is elsewhere in your code and Swift is lying.. I'm adding your code to the next PMK release, thanks!\n. Travis: https://travis-ci.org/PromiseKit/Alamofire-/builds/343145363. https://github.com/PromiseKit/Alamofire-/commit/0eff96092fadf5e23a7365a155a3660853d64266. Like the migration guide says, you need to use done.. The ObjC AnyPromise interface no longer supports cancellation. All errors go to the catch.. I updated the migration guide to include this. Sorry it was missing.. I consider 97% good enough.. Wow! Amazing work. . Per our FAQ we don\u2019t believe you need weak self:\nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/FAQ.md#do-i-need-to-worry-about-retain-cycles\nThanks for the thought though.. Well, if you install them yourself (without CocoaPods), then they should be able to coexist since they have different class names. There may be a little overlap, but probably easy to fix.\n6 is definitely the best PromiseKit, but unless you are also using Swift, then the objc side is pretty much the same as 1.x.\nCertainly there is nothing I know of that can help with the migration, but if you can get them installed side by side then you can do it gradually.. Yes install yourself is like via a submodule.. Closing, but discussion here can continue.. CI says we build on Xcode 9.3 already: https://travis-ci.org/mxcl/PromiseKit. Oh, ok. Sorry didn't see the branch you were merging into and since you didn't specify I assumed we were talking about the latest version.. Ugh, CocoaPods is so tedious. Coming up.. > I keep forgetting to skip ci \nWe all do, which is why there are hundreds of tickets to Travis asking for an exclude list. They have done nothing about this for years. Which makes no sense since it\u2019s their cost.. Considering this variant only existed for 4 days I'm cool to remove it.. I'd rather have a smaller reference to finally as an aside in the existing ensure section. I don't feel it deserves a section to itself.. You rule.. Can't be helped, you just have to keep typing or provide a return type like our troubleshooting guide says.. Thanks, I have update the troubleshooting guide to suggest this scenario.. A missing in is covered in our Troubleshooting guide.. https://github.com/mxcl/PromiseKit/blob/master/Documentation/Troubleshooting.md#acknowledge-all-incoming-closure-parameters. Here's the code:\nswift\npublic init(resolver body: (Resolver<T>) throws -> Void) {\n    box = EmptyBox()\n    do {\n        try body(Resolver(box))\n    } catch {\n        box.seal(.rejected(error))\n    }\n}\nSo it's hard to see how the behavior would be different. Do you have a minimal testcase to hand?. swift\npublic extension Resolver {\n    func reject(_ error: Error) {\n        box.seal(.rejected(error))\n    }\n}\nAnd here\u2019s the code for Resolver.reject.. 6.2.0 release coming up.. See our release notes and migration guide for PromiseKit 6. You are writing PromiseKit 4 code with PromiseKit 6.\nYou could easily figure this out by looking at the function definition for Promise.init please in future read the definitions of the functions you are using.\nConsider using our Alamofire extension, it does all the work of using Alamofire and promises for you. The fact this extension exists is documented in many places.\nThe error message was a complete hint as to what you had to do, it said (literally) that you are providing two arguments to a function that expected one, here is the trivial fix:\nswift\n func apiCall() -> Promise<[Class]>  {\n    return Promise { seal in\n        Alamofire.request(URL(string: apiUrl)!, method: .get)\n            .validate()\n            .responseJSON { response in\n                switch response.result {\n                case .success(let value):\n                    let json = JSON(value)\n                    let jsonString = json.description\n                    let output = Class.decode(json: jsonString)\n                    seal.fulfill(output)\n                case .failure:\n                    seal.reject(response.error!)\n                }\n        }\n    }\n}. > I updated PromiseKit yesterday, before the update everything worked fine now it does not anymore.\nSpecify the major version of your dependencies so that they do not update to new major versions. This is how versions work, new major versions have breaking changes.\nLearn to use your tools.. Finally is executed after the whole chain. Ensure is executed where it is in the chain.. Like both are executed WHERE THEY ARE in the chain. Not sure how you came to think otherwise.. This is an omission, finally should take a queue. PR welcome.. > Would the difference be that with the first example, the isNetworkActivityIndicatorVisible = false code is executed before the self.show block, and with the second example it is executed after the self.show line?\nThat's correct.\n\nIs that the only difference, or does it have any other side effects?\n\nThis is the only difference with the example code.. This makes the syntax for PromiseKit 4, our documentation represents PromiseKit 6. Thanks, but we opt to only maintain documentation for the latest release.\nThough if you want the documentation for PMK4, you simply have to browse the sources at that tag.. This is superb, you deserve massive kudos.\nIs it possible to generate a JS TypeError? If so I think I can get 2.3.1 to pass.. BTW your implementation of the then that the A+ tests expect seems good to me. You\u2019re using the right equivalents that JS will expect (ie. then and recover) and there's no additional dispatches happening which may have made the behavior incorrect.\nWell I guess there is one extra, the second then should probably be on: nil to prevent this.\nWe cannot test catch in the way A+ expects, so the only pity is not to test map but not much we can do really. I guess we could use pipe since it doesn't dispatch, then based on the input do the right method. But I think even if we decided this was more correct it can wait for this PR first.\nSo all that remains is fixing or disabling the tests and merging, really great work!. I figured that we could test for PMKError.returnedSelf and somehow get the JS typeError back to Javascript, but I'm just guessing about it. It seems like it would work since your JSPromise is just a thin wrapper around Promise<T> but maybe I'm missing something.. Remaining failures seem to be Swift 4 and Swift 3.1, I can probably fix these.\nEdit we run the tests with the same Swift as we build, because otherwise supporting Xcode 8.3 on Travis would require mangling the xcodeproj, it's a PITA. The easier way would be to have a fixed Swift version for the tests.. I don't have permission to push to your branch, but here's the diff for Swift 4:\ndiff\ndiff --git a/Tests/JS-A+/MockNodeEnvironment.swift b/Tests/JS-A+/MockNodeEnvironment.swift\nindex 0cdab5f..60edf64 100644\n--- a/Tests/JS-A+/MockNodeEnvironment.swift\n+++ b/Tests/JS-A+/MockNodeEnvironment.swift\n@@ -99,7 +99,12 @@ class MockNodeEnvironment {\n             }\n         }\n         let timer = Timer.scheduledTimer(timeInterval: interval, target: block, selector: #selector(Operation.main), userInfo: nil, repeats: repeats)\n-        let hash = UInt32.init(truncatingBitPattern: UUID().uuidString.hashValue)\n+        let rawHash = UUID().uuidString.hashValue\n+    #if swift(>=4.0)\n+        let hash = UInt32(truncatingIfNeeded: rawHash)\n+    #else\n+        let hash = UInt32(truncatingBitPattern: rawHash)\n+    #endif\n         timers[hash] = timer\n         return hash\n     }. And here's the diff for Swift 3.1:\ndiff\ndiff --git a/JSUtils.swift b/JSUtils.swift\nindex 16addfe..5c3afd7 100644\n--- a/JSUtils.swift\n+++ b/JSUtils.swift\n@@ -102,3 +102,15 @@ enum JSUtils {\n         print(lines)\n     }\n }\n+\n+#if !swift(>=3.2)\n+extension String {\n+    func split(separator: Character) -> [String] {\n+        return characters.split(separator: separator).map(String.init)\n+    }\n+\n+    var first: Character? {\n+        return characters.first\n+    }\n+}\n+#endif. I made a PR: https://github.com/ldiqual/PromiseKit/pull/1. https://travis-ci.org/mxcl/PromiseKit/builds/348545693. Strangely it fails in the JS for iOS 8 and 9 (we only test these with Xcode 9.2 and Swift 4):\nTest Case '-[PMKJSA_Tests.AllTests testAll]' started.\nJS Exception at 82:5: Unexpected token '>'\n    > eval@[native code]\n    > ./index.js\n    > __webpack_require__\n    > global code\nJS Exception at undefined:undefined: undefined is not an object\n    > undefined\nI can't see any reason for this off hand.. Can we increase the timeouts on the JS tests? Travis is stressed and we keep timing out for the final CI checkmark.. All pass! Anything you want before I merge? I was going to squash the merge unless you object.. > I'm a bit concerned that it will still timeout for PRs unrelated to this commit, preventing future contributors from getting their code merged quickly. \nIt probably will at times, but all our tests fail occasional (Xcode sucks in CI), so it's not new, but if you know a way off hand to increase the timeout, that would be good. If not, I can look later, I'm sure some sed can do the trick!\n\nSide question: are there other test suites that you're thinking about complying to? Something that'd test map, when, Guarantee etc.\n\nI don't know any other test suites. Do you?. Yes, we should have this, mainly I haven't added it due to fear of ambiguity and the lack of an easy way to know in advance how it will affect the ambiguity of when. And yes the specialization for Void should stay.\nAside: it's a pity that Swift itself can\u2019t specialize this for us, I'm sure they have reasons, but who ever wants: [Void]?. Impossible to help since you don't say what the error is or which line it happens on.. Like at the very least your code is identical to the much shorter:\n```swift\nUIApplication.shared.isNetworkActivityIndicatorVisible = true\nreturn firstly {\n    getIPNumbers(withAPI: .incomingPhoneNumber)\n}.ensure {\n    UIApplication.shared.isNetworkActivityIndicatorVisible = false\n}\n```\nThis is mentioned in the appendix under \u201ccommon misusage\u201d. Specify the return type or do what I did in my above example where I make the firstly one line.. Yes, this is expected behavior.\nYou returned the chain before it was recovered.\nLike, here's some equivalent code:\nswift\nlet a = \"foo\"\na.replacingOccurrences(of: \"f\", with: \"b\")  // Swift warns about unused l-value\nreturn a  // returns foo, not boo. If you have any insights about why you thought this would work we can update our docs to help others avoid this situation.. There is nothing new, but you can do the usual:\nobjc\n/// available to Swift somehow\nAnyPromise *foo() {\n   manifoldPromise.then(^(id a, id b){ @[a, b] }\n}. It's not impossible for us to add this feature.\nextension AnyPromise {\n    var manifoldValues: [Any] { return valueForKey(@\"__manifoldValues\"); }\n}\nWhere we have to write __manifoldValues. Like I said in my immediate reply, do this:\nswift\n/// available to Swift somehow\nAnyPromise *foo() {\n   manifoldPromise.then(^(id a, id b, id c){ @[a, b, c] }\n}. As per our troubleshooting guide, specify the return type:\nswift\npublic func foo() -> Promise<Data> {\n    return firstly { () -> Promise<Data> in\n        let data = try Data(contentsOf: URL(fileURLWithPath: \"path\"))\n        return .value(data)\n    }\n}. yes this is expected, we document it in four places that this is expected including our troubleshooting guide that is linked from the template for creating new issues and that you didn't read:\nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/Troubleshooting.md#result-of-call-to-fooon_-is-unused. swift\nfunc executeJob() -> Promise<Void> {\n  let p = request().done {\n     // Do something\n  }\n  p.catch { _ in\n     // Schedule a local push notification, etc\n  }\n  return p\n}\nIn PMK 5 catch returned self which let you do what you did, but was a confusing pattern since unlike all other handlers it could not mutate the promise, and instead returned the previous promise. This led to confusion about what catch did to the chain (the answer being nothing, but the implication being: something).. I feel I must ask, what situations are you doing something but only for an error condition? It suggests misusage. . > but I guess this is not possible because recover has to return a Guarantee.\nThis is untrue, what you want to do is possible. LMK if I can help.. Yes, this is the main suggestion in our Troubleshooting Guide.. This is an omission.\nI am assuming you are talking about PromiseKit 6, since you didn't specify even though the issue template asked for.. a37e91a0fa3c6b2b01d8a65918aa661cc348081e\nWill be available on CocoaPods in ~30 minutes. Provided the trunk push lint succeeds.. Live.. This has been asked before.\nThe documentation that CocoaPods is not clear but to me it looks like I have to make PromiseKit either static or dynamic with no choice to the end-user, thus no, we cannot become static, it makes us much less useful to everyone.\nIf you want static, use Carthage or SwiftPM, which both alllow the end-user to choose how their libraries are packaged.. I see, well if there is documentation or some kind of information on the Internet that guarantees this, then I'll do it. Otherwise I cannot risk >1M installs with this change of metadata.. Thanks for the info @nolanw and don't apologize; you helped!. To use PromiseKit with Android use SwiftPM.. No, it is Swift. You can use Swift on Android since a while, you can google it. Thanks.. PromiseKit 6 no longer provides the Promise { fulfill, reject in initializer. Please read our migration guide and documentation.. You can call finally on catch that's it. If you were asking something else, then sorry, I didn't understand your question.\nGuarantee doesn't provide a resolver because it cannot error, Resolver provides functions that take work for completion handlers that error.\n. > I wasn't trying to criticize, just sharing my upgrade experience. First I switched all my let (promise, fulfill, reject) to let (promise, seal), then when I switched to using Guarantee I had to revert to let (guarantee, fulfill), and that surprised me, I expected Guarantee.pending and Promise.pending to have similar return types. But they don't! No worries. Thanks as always!\nnp, I didn't take anything personally. I'm just saying: it's logically impossible to have Guarantee take a Resolver, so I can't really do anything to aid people's migrations there.\nSwift would also compile time prevent resolving the Guarantee with an Error, so the only option we'd have is to fatalError.. Let\u2019s do the return one too while we\u2019re here. If possible.. No this is also an omission.. Hi, your function expects you to return Promise<[BCTodayCardModel]> but you don\u2019t return in your function. I think you meant to return your when.. Also, in case you're interested, you have a few redundant promises in your code:\n```swift\nfunc todayDataRequest(_ APIService: BCAPIService, imperial: Bool, forDate date: DateComponents) -> Promise<[BCTodayCardModel]>? {\nlet attributesPromise = APIService.attributes()\nlet insightsPromise = APIService.insights()\nlet averagesPromise = self.averages()\n\nenum E: Error {\n    case noModels\n}\n\nreturn firstly {    \n    when(fulfilled: attributesPromise, insightsPromise, averagesPromise)\n}.then { attributes, insights, averages -> [BCTodayCardModel] in\n    if let models = BCModelFactory.todayCards(withAttributes: attributes as! [Any], insights: insights as! [String: Any], averages: averages as! [Any], forDate: date) {\n        return models\n    } else {\n        throw E.noModels\n    }\n}\n\n}\n```. It's just for readability. So removing it will change nothing.. Anytime, hope PromiseKit proves useful for you.. I had no plans, but am happy to accept the PR, or a new ticket with a list of methods that need adding, then I could probably quickly add them since I've done this a bunch of times now. That would be fine with me, but I would need pointers to which methods to do it for since I've not used HealthKit before.. I'd like to hear what CocoaPods think here since presumably we aren't the only library that is affected by this issue.\n```\nif __has_include(\"PromiseKit-Swift.h\")\n#import \"PromiseKit-Swift.h\"\n\nelse\n#import <PromiseKit/PromiseKit-Swift.h>\n\nendif\n```\nSeems safe, but I am hesitant, I have applied similar hacks before and then had three new bugs show up after release.. Thanks, I've added myself as a watcher on the thread.. Hi, I assume you got it working? Was our troubleshooting guide any use?\nAlso you are doing one of our documented common-misusages, that is: nesting a promise chain within a promise chain. I'd show you but you didn't post your code as text.. This is a bug in Swift.. PromiseKit is written in Swift and according to #828 this is a bug in the Swift language itself.. I require a test case that demonstrates the leak.. Merged and fixed. Many thanks.. Closing due to inactivity.\nI require a test case that verifies this leak and proves the fix before I will apply this, preferably also an open bug against swift itself so we can track the fix there.. What PromiseKit version and what file is this exactly? Closing because these bits of information were asked for in the issue template and the template states I will close tickets that don't provide this information and I will smirk. So: smirk.. This was fixed in 1.7.6 months ago, please update if you are using PMK 1.x:\n1ce256172bb8a4c35cff4c270582ae3e7847e54e. ```\npod search PromiseKit\n-> PromiseKit (6.3.0)\n   Promises for Swift & ObjC.\n   pod 'PromiseKit', '~> 6.3.0'\n   - Homepage: http://promisekit.org\n   - Source:   https://github.com/mxcl/PromiseKit.git\n   - Versions: 6.3.0, 6.2.8, 6.2.7, 6.2.6, 6.2.5, 6.2.4, 6.2.3, 6.2.1, 6.2.0, 6.1.2, 6.1.1, 6.1.0,\n   6.0.3, 6.0.2, 6.0.1, 6.0.0, 4.5.2, 4.5.1, 4.5.0, 4.4.4, 4.4.3, 4.4.2, 4.4.0, 4.3.2, 4.3.1, 4.2.2,\n   4.2.0, 4.1.7, 4.1.4, 4.1.3, 4.1.2, 4.1.0, 4.0.5, 4.0.4, 4.0.3, 4.0.1, 4.0.0, 3.5.3, 3.5.2, 3.5.1,\n   3.5.0, 3.4.4, 3.4.3, 3.4.2, 3.4.1, 3.4.0, 3.3.0, 3.2.1, 3.2.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1,\n   3.0.0, 2.2.1, 2.2.0, 2.1.3, 2.1.2, 2.1.1, 2.1.0, 2.0.6, 2.0.5, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0,\n   1.7.7, 1.7.6, 1.7.5, 1.7.4, 1.7.2, 1.7.1, 1.7.0, 1.6.0, 1.5.3, 1.5.2, 1.5.1, 1.5.0, 1.4.3, 1.4.2,\n   1.4.1, 1.4.0, 1.3.0, 1.2.5, 1.2.4, 1.2.3, 1.2.2, 1.2, 1.0.3, 1.0.2, 1.0.1, 1.0, 0.9.21, 0.9.19,\n   0.9.18, 0.9.17.1, 0.9.17, 0.9.16.6, 0.9.16.5, 0.9.16.4, 0.9.16.3, 0.9.16.2, 0.9.16.1, 0.9.16,\n   0.9.15.3, 0.9.15.2, 0.9.15.1, 0.9.15, 0.9.14.3, 0.9.14.2, 0.9.14.1, 0.9.14, 0.9.13.2, 0.9.13.1,\n   0.9.13, 0.9.11.1, 0.9.11, 0.9.10, 0.9.9, 0.9.8.1, 0.9.8, 0.9.7.5, 0.9.7.4, 0.9.7.3, 0.9.7.2,\n   0.9.7.1, 0.9.7, 0.9.6, 0.9.5, 0.9.4, 0.9.3, 0.9.2, 0.9.1, 0.9.0 [master repo]\n```\n1.7.6 is there.\nPlease open new tickets. This is the standard practice for all projects on the Internet.. This is all you need:\nswift\nreturn firstly {\n    performFirstNetworkingOperation()\n}.then { firstResponse in\n    self.secondNetworkingOperation().map { (firstResponse, $0) }\n}. Wrapping promises in promises makes things harder than necessary. I suggest reading our common mis-usage guide in the Documentation appendix.. https://github.com/mxcl/PromiseKit/blob/master/LICENSE. I expect it can be done, but I do not have experience with it. PR welcome.. Closing since this is a feature-request, the PR is welcome but I do not leave feature requests open, the tracker is for bugs.. This is a bug in Swift itself.\nCan you provide the value of TWTRRequestEmailCompletion since without this there is no way I can assist.. What are the two variants of wrap that Swift claims it cannot choose between?. You can see the variants in the build log. . Closing due to inactivity.. @hashemp206 it means there is a different error in the closure, see our troubleshooting guide.. If you want help, open a new ticket.. Use Promise.value(_) this is detailed in our migration guide which I recommend reading: http://promisekit.org/news/2018/02/PromiseKit-6.0-Released/. This usually means you are returning the wrong type . I mean. The wrapped type is probably wrong. . Try splitting out the function, like our Troubleshooting Guide recommends:\n```swift\nfunc fetchSettings(forAnimalsGuids animalsGuids: [String]) -> Promise<[JSON]> {\n    let packageSize = 100\n    let animalsPackages = animalsGuids.chunked(chunkSize: packageSize)\nfunc fetch(_ animalsPackage: Foo) -> Promise<[JSON]> {\n    let predicates = animalsPackage.map { .atomic(.equal(\"Animal.ObjectGuid\", .string($0))) }\n    let predicate = !predicates.isEmpty ? .or(predicates) : nil\n    return gatewayConnector.fetchObjects(type: AnimalMilkSetting.self, predicate: predicate)\n}\n\nreturn firstly {\n    when(fulfilled: animalsPackages.map(fetch)\n}.map {\n    Array($0.joined())\n}\n\n}\n.\nlet p = Promise()\np.catch {\n    //\u2026\n}\nreturn p\n```. Update, this was fixed in 6.2.2. Yes I've needed something like this before, seems like this would be enough:\nswift\nfunc ensure(on: DispatchQueue? = conf.Q.return, _ body: () -> Promise<Void>) -> Promise {\n    let promise = Promise<T>(.pending)\n    pipe { result in\n        on.async {\n            body().pipe {\n                promise.box.seal(result)\n            }\n        }\n    }\n    return promise\n}\nI think this would not cause ambiguity, so we can call it ensure still. But we'd have to test for that. Ambiguity when using Swift is annoying to work around in such cases.. True. Which makes me think that we can only have a Guarantee<Void> version of this, and probably this is why I didn't implement this before.\nBecause if the promise you return rejects which error and the promise we are part of is already rejected which Error do we propagate?\nswiftswift\nfunc ensure(on: DispatchQueue? = conf.Q.return, _ body: () -> Guarantee) -> Promise {\n    let promise = Promise(.pending)\n    pipe { result in\n        on.async {\n            body().done {\n                promise.box.seal(result)\n            }\n        }\n    }\n    return promise\n}\n``. It seems reasonable that any async thing you do inensureshould not be able to error. What do you think?. We once nested errors forPMKWhen` so you could know the index of the promise that error'd and it led to bad error handling since you may handle the error very far from the error site and then you have to check for the error you want and the nested error type and if that nested error is the error you want.\nSo I think it better we don\u2019t do that.\nDo you have examples where you have to return a Promise?. Both these examples would be Guarantees though, right? Any examples which would return Promise? I looked back over every time I ever needed such a thing and had no examples that could error.\nIn the past I had a ticket with some networking cleanup though. That ofc. could error, but certainly it's a rarer situation IME.. K cool. I've prepared a PR.. Merged, will release when I have stable master.. Wow, super thanks.\nAnd I confirmed the leak. We really should open a ticket with Swift proper. They aren't my biggest fans, so coming from you would be best.. Merging. The Linux failures are not our fault: https://github.com/kylef/swiftenv/issues/125. I'll push a release.. Just waiting on the CI, which is waiting on:  kylef/swiftenv#125. Something like this presumably is what you want.\nswift\nfirstly {\n  asyncOpThatReturnsAPromise()\n}.done(on: myBgQueue) {\n  syncOpThatDoesntReturnAPromise()\n}.done {\n  displaySomethingToUser()\n}. Like, if it's synchronous, then it holds up the chain; if that's your disconnect.. This?\n```swift\nfunc displayImagesAsync(_ images: [UIImage]) -> Guarantee {\n    self.animatedImageView.image = nil\n    self.frameImageStore = nil\nreturn firstly {\n    ImageStore.createAsync(images: images)\n}.done { store in\n    self.frameImageStore = store\n    self.animatedImageView.image = store.frameImage()\n}\n\n}\n.swift\nfunc displayImagesAsync(_ images: [UIImage]) -> Guarantee {\n    return DispatchQueue.main.async(.promise) {\n        self.animatedImageView.image = nil\n        self.frameImageStore = nil\n    }.then {\n        ImageStore.createAsync(images: images)\n    }.done { store in\n        self.frameImageStore = store\n        self.animatedImageView.image = store.frameImage()\n    }\n}\n. Yes, the migration guide has more details. Let us know if you need more help..swift\nfunc poll() -> Guarantee {\n   task()\n   return after(.seconds(N)).then(poll)\n}\n```\nFurther reading:\n\nhttps://github.com/mxcl/PromiseKit/issues/594\nhttps://github.com/mxcl/PromiseKit/issues/387\nhttps://github.com/mxcl/PromiseKit/issues/659. swift\nfunc poll(seconds N: Int, task: () -> Void) -> Guarantee<Void> {\n   task()\n   return after(.seconds(N)).then(poll)\n}. Probably you need task to return Promise, you weren't specific.\n\nswift\nfunc poll(seconds N: Int, task: () -> Promise<Void>) -> Promise<Void> {\n   return task().then{ after(.seconds(N) }.then(poll)\n}. Please refer to the other issues I already highlighted, I literally copy and pasted from them.. This is impossible with promises, they either fail or succeed. You will need to carry the error-message through the chain separately presumably with a custom object.. This is what Swift 4 requires. We have discussed this previously:\n\n\n763\n\n\n697\n\n\nWe also document the fix and talk about the problem in our Troubleshooting Guide. I can't add everything to the README, it's already pretty full.. The README specifies ~> 6.0 which means the latest version of version 6. So the README is correct.. Please indicate which lines the errors happen on.. Read the migration guide for PMK 4 -> 6 or don't upgrade major versions of libraries.. We should add this to doubling promised entry. It\u2019s stumped a few for sure. . Something like:\n```swift\nfinal class VideoPlaybackManager {\nprivate let player = AVPlayer()\nprivate var cancel = {}\n\npublic var video: Video? {\n    didSet {\n        cancel()\n\n        guard let video = video else {\n            return player.replaceCurrentItem(with: nil)\n        }\n\n        let promise: Promise<String>\n        (promise, cancel) = APIClient.shared.fetch(video.url)\n\n        promise.then { complete -> Void in\n            if let url = URL(string: complete.url) {\n                self.playerItem = AVPlayerItem(url: url)\n                self.player.replaceCurrentItem(with: self.playerItem)\n            } else {\n                self.player.replaceCurrentItem(with: nil)\n                self.postErrorNotification(error: MyError.url)\n            }\n        }.catch {\n            //\u2026\n        }\n    }\n}\n\n}\n```\nMake sense?. Cancellation is documented here. Too much code, cannot review.. Looks right, but there is so much code I don't promise anything.. It worked?. Sorry, as @samrayner says, this is outside the bounds of PromiseKit, you will need to research how to use NSProgress:\nhttps://www.google.com/search?client=safari&rls=en&q=urlsession+nsprogress&ie=UTF-8&oe=UTF-8. NSProgress already supports progress and you can use it to monitor the progress of your URLSession, so we don't intend to add this feature. Thanks.. Swift bug, report against swift.. We already provide Codable support in our Alamofire extension.\nAnyway, Swift is trying to figure out T, so to do this it uses your completion parameter, which takes (Bool, Error?), thus it is trying to use Decodable to produce Bool which is impossible.. It doesn't work because Swift can only infer types for one line closures.\nYou can make it work by specifying the type of user in you done.\nThis is mentioned in the troubleshooting guide.. The initial then was what required it, sorry, we missed the fact in your subsequent example it became a then. Key is that Swift needs to understand the type at that point.\nIs this issue resolved? If so please close.. Basically I removed open because things often don\u2019t behave as you like when chaining, where you return your subclass in a chain and then out the other end pops good 'ol Promise, so you only have a very specific time where your subclass exists, which for most people is confusing.\nI could add it back, there's nothing dangerous (I can foresee) about allowing it. But will it actually be as useful to you as you think?. Originally I tried to make it so the chains returned Self but Swift is difficult about this, maybe with Swift 4.1 it is now possible\u2026. Did you read our documentation on cancellation?\nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/CommonPatterns.md#cancellation. Want to add a link to this in our cancellation documentation?. Thanks! Any clue how we can run a CI for Android?. That would be amazing! Thanks!. Dupes #660. We have no solution, it's a Swift bug. You have to upgrade PromiseKit. v4 is not much different.. Or you can remove the UIKit subspec by specifying just PromiseKit itself. Documentation exists all over for how to do this.. We have decided not to do this, pending advisement from CocoaPods if we should do anything or not.\nLike I said in #825, your fix\u2026\n\nSeems safe, but I am hesitant, I have applied similar hacks before and then had three new bugs show up after release.\n\nI do not want to break a whole bunch of other stuff.. Reopening pending my question at CocoaPods/CocoaPods#7594. Yes, will try!. done. When I initially tried to provide all the logical types of when Swift found the situation ambiguous making it impossible to provide all without making all painful.\nSo for now, until Swift is better, you can do what our documentation recommends and asVoid() all the guarantees and then extract out their value afterwards because you kept a reference to each one from before.. Is this a breaking change for consumers? Seems so since you had to change the test sources.. K, thanks for clearing that up!. > From what I've understood, you're using id a lot, so determining the result type of a promise chain seems unfeasible.\nThe return type for all the handler blocks is inferred, but maybe something can be done in a later PR, not sure.. Thanks. PMKArrays are not created by much, the only example I can think of that is exposed by PromiseKit itself is NSURLSession promises. Are you creating NSURLSession promises somewhere?\nCertainly, throwing errors does create a PMKArray. PMKArray is an internal class used by the PMKManifold function.. K well, it turns out @throw violates ARC:\nhttps://www.eltima.com/dev/2014/08/11/objective-c-arc-and-exceptions/\nNothing we can do. If you don't want memory leaks, don't @throw.. Oh, apparently you can enable -fobjc-arc-exceptions and this will be fixed.\nPR welcome to supplement our docs.. It's valid yes.. Many thanks \ud83d\udc4d\ud83c\udffb. ``swift\nfunc makePromise() -> Promise<Foo> {\n    return Promise {\n        //\u2026\n    }\n}\n````. If you need a lazy promise, use thelazy` keyword. If you need a new promise every time you call a function, make it a function like in my example above.\nYour test is a normal way of creating a promise, and the closure you pass is always executed immediately.. Closing but re-open if your question is still not answered.. There's existing tickets that show how to do this, I am going to say go find them because I cannot remember exactly what you have to do, it comes down to the way we return a block to a block in objc, so you have to double unwrap to use them from Swift.\nBasically, we do not recommend using Swift with PMK 1.x. Upgrade.. K glad you found a solution.. This is an omission, PR welcome.\nAs a workaround do: recover{ fatalError(\"\\($0\") }\nIf you are sure there are only guarantees above this is safe.\n. PR merged.. The test needs to use XCTestExpectations or it may not finish.. Specify:\npod 'PromiseKit', '~> 6.0.0'\nYou specified exactly 6.0.0, we have release 28 bug fix releases since then, one of which fixes this issue for > Xcode 9.2. I expect you want that.. Please provide the build errors.. Ok, you\u2019re building against macOS, FYI that is important omitted information.\nFix coming. Thanks for the report.. K pushed Foundation 3.1.0 which bumps the macOS deployment target to match PromiseKit 6.3.0\u2019s updated deployment target.\nSorry for the issue. Sadly this level of testing is not automated.. From https://github.com/mxcl/PromiseKit/blob/master/Documentation/Troubleshooting.md:\n\nPromise deliberately avoids the @discardableResult annotation because the unused result warning is your hint that you have not handled the error in your chain. So do one of these:\n\nAdd a catch\nreturn the promise (thus punting the error handling to the caller)\nUse cauterize() to silence the warning.\n\nObviously do 1. or 2. in preference to 3.\n\nWe asked you to read the troubleshooting guide before creating this ticket as part of the text you deleted before creating this ticket, you refused, may I ask why?. This is a commonly requested feature that we have decided to reject. Sorry. Justification can be found in the ticket tracker.. Oh my bad, I thought this was for firstly.. Like, I said, the fix for Linux is import Dispatch at the top.\n\n(I'm not sure using just this precondition would ensure that a closure passed in the finally block truly is executed after every other closure in the promise chain. I'm open to adding more tests to validate this condition. Let me know your thoughts on this.)\n\nWe have other tests that validate this so I don't consider it necessary, OTOH we have other tests that do this so you can just copy and paste.. This breaks the tests, see Travis.. Tagged 6.3.1. I'm cool, and agree it would be useful, but there are a few conditions:\n\nWe cannot break the public API, this includes that, for example, this must continue to work:\n       foo.then(on: .main)\nIt must not create ambiguity in use, we worked hard to reduce ambiguity for PMK6\n\nWe could put this in PMK 7 though. Although I'd still want on(.main) etc. to work.. We have a test breakage in CI for Linux, any ideas? https://travis-ci.org/mxcl/PromiseKit/builds/492338166. Merged into v7.. Impossible to help you since you didn't provide the error messages or line numbers of the errors.. I'm sorry but I really don't understand what you mean by:\n\nif I want to execute a function in sequential order or mapping (unordered sequence).\n\nIf you can explain your issue, preferably with specific error messages, please re-open.. Yes, this is a mistake.. Fixed in latest commit.. Thanks, but why did you change the capitalization of all the headers to non-title case?. You are not going to be here next week, or next month or next year.\nLet\u2019s keep things my style. Thanks.. Thank you for this thorough work and thoughtful work.. As our common mis-usage guide states, don\u2019t wrap promises in promises:\nswift\nfunc Foo(id: String) -> Promise<Any> {\n    return daoClient.get(id: id).recover { _ in\n        self.apiClient.get(id: id)\n    }\n}. The Promise initializer catches for you, so we can strip that:\nswift\nfunc daoClient.get(id: String) -> Promise<Any> {\n    return Promise { seal in\n        guard let data = try Realm().object(ofType: DataEntity.self, forPrimaryKey: id) else {\n            throw Errors.DataError(error: \"no data found with id \\(id)\")\n        }\n        seal.fulfill(data)\n    }\n}. This final is pretty fine, but here's what I'd do just to clean it up a little (IMO):\nswift\nfunc apiClient.get(id: String) -> Promise<swiftyJson.JSON> {\n    return firstly {\n        oiRequestClient.request(endpoint, method: .get, encoding: JSONEncoding.default).responseJSON()\n    }.get { arg in\n        if let response = arg.response.response, response.statusCode > 399 {\n            let json = JSON(arg.json)\n            let error = json[\"error\"].dictionary?.description\n            throw Errors.NetWorkError(error: error)\n        }\n    }.compactMap {\n        JSON($0.json)\n    }\n}. This is an omission. PR welcome. I can assist with directions.. This is in the troubleshooting guide.. Troubleshooting Guide. The failing test is my fault.. Many thanks \ud83d\udc4d\ud83c\udffb. Sorry, restored.. Depends on #888 . Nice patch, and very thoroughly PR\u2019d.\n\nSecond, the fact that wrappers have a flags: argument and canonical functions do not heads off any potential function overloading ambiguities. Swift strongly prefers to resolve function calls to the signature that requires the fewest defaulted arguments.\n\nProbably not true, since flags has a default. But the fact you added all the existing function signatures as separate functions will probably make Swift happy for most cases.\nI'll merge this and try it on a few projects to see if it just works.\n\nArguably, wrappers should be right next to their canonical versions for ease of maintenance. Currently they are all bundled into Dispatcher.swift.\n\nI\u2019m cool with it this way. It's already pretty crowded in the other files.\n\nDispatcher.dispatch(.promise) {}\n\nThe .promise namespacer maybe should be removed. We added it for eg. DispatchQueue.async so Swift wouldn't error due to ambiguity for usual usage with the non promise version. Eg:\nlet p = DispatchQueue.global().async { foo() }\n\nIs ambiguous (sadly) despite the normal version returning Void.\nBut since Dispatcher is our own class we don't need the namespacer, I understand it is consistent, but since the original purposes is disambiguation I think we should stick with that rationale.\nPossibly we should just bite the bullet and make this PMK7, this would allow us to be more ruthless with making this system the default and provide some convenience overloads so dispatch works well (since most people will use that).\nMainly I just worry about corner case issues that may result for our innocent and unsuspecting PMK6 users who didn't want this feature (yet).. Any clue on the Linux 3.x failures on Travis?. I think we should make this a version 7 feature, along with #896, thus there's no risks.\nThen it's easy for us all to test an alpha release of that and offer feedback.. So we should merge into a branch like 7-alpha, and well, the CI issues should be resolved first.. It\u2019s weird but I can\u2019t change the branch this merges into, can you change it to v7 which I just pushed? Then we\u2019ll merge and review in actual code, we can apply any changes as subsequent PRs.. Shall I close in favor of #975?. No, but the connection is in the other, so we can refer back. I'll close so this one doesn't distract.. Many thanks \ud83d\udc4d\ud83c\udffb. Many thanks \ud83d\udc4d\ud83c\udffb. Seems like a fine use of when(resolved:).\n\nyou mentioned you hardly use when\n\nTo be clear, I hardly use when(resolved:), I use the other when variants all the time though.\nI cleaned this up, maybe (I had to infer some bits):\n```swift\nprivate func getContent(for alert: Model) -> Promise {\n    return firstly { () -> Promise in\n        switch AlertContentType(rawValue: alert.type) {\n        case .news?:\n            return newsService.get(contentId: contentId, superareaId: superareaId)\n        case .insight?:\n            return insightService.get(contentId: contentId, superareaId: superareaId)\n        default:\n            throw DataError.Missing(error: \"Could not retrieve type!\")\n        }\n    }.map { content in\n        var viewModel = alert.toViewModel()\n        viewModel.content = content\n        return viewModel\n    }\n}\nprivate func attachContents(to alerts: [Model]) -> Promise<[ViewModel]> {\n    return firstly {\n        when(resolved: alerts.map{ self.getContent(for: $0) })\n    }.compactMapValues {\n        $0.value\n    }\n}\n``. Closing but re-open if your question is still not answered.. Per the troubleshooting guide, you need to usedoneand notthen`. Please read our documentation since it contains full instructions on how to use PromiseKit 6.. Thanks for this, I appreciate the work and I think you have good direction.\nI will take some time, maybe a lot, since this is a lot to review. I'm confident we can work this into the framework, but I am very cautious about things with this project: there are many alternatives to PromiseKit, and I feel the reason PMK is popular is I am careful to keep it high quality.\nAnyway, I will review.. I would like to remove cancelation from all extensions that are not inherently cancelable, eg:\nAlamofire is inherently cancelable, the networking can be canceled.\nafter() is not.\nHowever I understand that sometimes you want to just ignore something like an after and the effect of ignoring it is to cancel the chain. To facilitate this we (could) provide a wrapper:\nlet context = cancelable(after(.seconds(2)))\n\nThis removes a lot of the additional API in the extensions and reduces the overwhelmingness of someone reading The API significantly.\nI still have concerns, I fear that in practice the burden on people constructing APIs and chains with promises will increase significantly due to this change. Because I think it is important that in general users are encouraged to not offer cancellation in situations where it would cause them to leak methods that allow the caller to break the state machine of the callee. So in general it should be opt-in to return a cancellation context.\nBut we can see how it is in a 7-alpha release.\nThe cc suffix can stay for now, but certainly we will lose it for a final release.\nI feel CancellableGuarantee is incorrect from a idiomatic stand point, with my wrapper suggestion above, we can drop it entirely.. Merged and tagged 7.0.0-alpha1, available for testing!. Many thanks \ud83d\udc4d\ud83c\udffb. I'm not sure it's actually true, I did some testing and .global() maybe does always return the same queue. Not sure.\nEither way rather than have the variable be : DispatchQueue the ticket is for it to be : () -> DispatchQueue. We should behave how people will expect. I would expect it to behave exactly the same as it would if I called .global() in any other context, not differently.. Should Guarantees be cancellable? My immediate reaction is: no. It\u2019s not much of a guarantee if it may be canceled.. > When finished try to squash all of the commits .. git squash\nWell we can do that from GitHub nowadays. So don't worry about it.. K, this is way overdue, I have created a v7 branch, can we alter this PR to merge into that?. It\u2019s waiting on me. And will be a new major version of PromiseKit. I think we can approach this by merging here and perhaps in PromiseKit/Foundation (v4) initially. Thoughts?. I have pushed the start of v7, and I have stripped it quite a bit, my thinking being that v7 can be modernized, and we'll maintain v6 as the back-compat version.\nI will merge #975 first, and then we'll merge this.. v7 is ready for this PR! \ud83c\udf89. No need, I'll probably squash it anyway.. > My team is considering incorporating these cancel features into one or more of our apps. Is there anyway we can pull this version into our app using Cocoapods to start playing around with it and giving you guys some feedback?\nThat would be useful thanks! You can specify branches for a pod spec, though currently this is not merging. Though that shouldn't matter since you can specify @dougzilla32\u2019s fork and branch.. > One outstanding item: what name should be used for the 'cancellable' function?\ncancellize? It's not great, but I haven't come up with anything better yet.\nWe'll alpha v7 after merging and I'll test it out in all my apps, so we can figure out changes to names etc. then.. I'm going to merge so this doesn\u2019t get out of sync again, which is painful for @dougzilla32 \nSorry it took so long, I wanted to do a thorough review, but it's a big patch and I couldn't get my head around it properly in a PR. So let\u2019s try it out in real code and see what we think.\nThanks everyone!. Superb!\n\nWhat level of test coverage are you looking for?\n\nAs much as you can be bothered with. IME this stuff is hard to test and the tests are not often that useful (for the extensions that is, the core library is about as close to 100% as we can get it).\n\nIs objc support required?\n\nNowadays? No.\n\nIs coverage of 100% of HomeKit's async APIs required?\n\nNo, any amount is great. If other people come along and find they need more, they can supplement the library.\nLMK when you want to go forward and I'll create the repo at the PromiseKit organization. Many thanks.. > not sure how to test it as a Pod subspec\nI can handle that, the podspec is on this repo, but it's a bitch of a podspec so I can do it.\n\nAnything else that should be tested or done?\n\nNope! Looking forward to your submission. I'll create the repo.. > Specifically, should I tag the initial release and if so does the version have to be anything specific?\nOh sorry, just did that for you. Carthage needs a version tag, so I added it.. This is a fine usage, though you may want to log the error to something like Sentry.. Everything is possible, I have no experience with this library though so could not write the PromiseKit extension.. We have documentation on how to write your own promises. It's pretty simple.. This is unreadable, please format it then I will help.. This is still unreadable.. > when(resolved: guarantees) that return a guarantee\nGuarantees cannot error so they always resolve. This is why there is only one variant of when for Guarantees.\n\nwhen(fulfilled: tenables) that return a guarantee\n\nWell, we don\u2019t have that actually, when(fulfilled:) returns a Promise.. https://github.com/mxcl/PromiseKit/blob/master/Sources/when.swift#L256. Yes, do this:\nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/Appendix.md#voiding-promises\nWe don\u2019t provide when<T>(guarantees:) because the Swift compiler breaks. This has been discussed in several other tickets.. I don't think this adds enough value while also not being sufficiently intuitive. Sorry.\n\u201cPromise-async\u201d does not imply to me that it will be execute the provided closure on the global queue. It suggests some kind of closure executed \u201clater\u201d and since this relates to promises quite intimately I think people will expect this to be some kind of promise initializer.\nThanks for the contribution.. I would like something, but I've not come up with anything so far.. This is a Carthage bug, since the watchOS target builds fine in Xcode 10 itself.\nLeaving open for others to find. The workaround is not to build platforms you don\u2019t need, eg:\ncarthage bootstrap --platform iOS\n\nI am not reporting the bug against Carthage, I never do, I have only so much time and energy, other people with time and incentive should do so.. According to the referenced issue this is fixed, though maybe not yet released.\nYou can build a version of carthage that has the fix with brew:\nbrew install carthage --HEAD. The new Carthage is released and in Homebrew, closing.. Specify the return type of the closure of the first `then`, eg:\n\nswift\nreturn itemCreateInternal(item)\n            .then { item -> Foo in. Optional promises are generally considered a code-smell, I suggest reading our common misusage documentation, also our troubleshooting guide includes the above fix I suggested, so probably read that too.. What generic promises statement?. Must be converted to nil somewhere which is the false as a Bool. I\u2019ll have a look but on the road all day today. . Oh right. You have to do NSNumber not BOOL. AnyPromise only works with objects. Anything else in your block definition will come out as nil/zero. . Closing due to stagnation, if you have further questions reopen.. I imagine swift is lying and there\u2019s another syntax error there actually. This is usually what it is. . Closing because travis didn't run. Thanks but this is deliberate, it's Ruby style inline closures that I prefer.. Can you provide example code that justifies this addition?. I guess I have recently found a situation this would be useful. But I just used recover. Using recover here was a little unwieldy, but still I am hesitant to add more API that makes learning PromiseKit less straight forward.. > recover would make the chain success\nYou can re-throw:\nswift\n.recover { error -> Promise<Foo> in\n    print(\"Do something\")\n    throw error\n}. I agree it's more readable, but I have already specified my concerns above. My concerns would be mitigated somewhat with a good name for the function.. > Is it fine we will have side effects inside recover?\nI don't really understand; the same caveats apply to whatever you do inside the function as for all other PromiseKit handlers.. It's as fine to have side-effects that affect UI or global state in any PromiseKit handlers, typically though it is a better pattern to avoid this until the end of the chain though, since it allows you to reason about the process better, 1) set UI state 2) promises 3) set UI state.\nTherefore, it doesn't matter if you modify the state in map or then, it's just not typical since they are usually mid-chain functions.\nThere are no hard and fast rules in programming, just understandings and patterns.. Closing since I closed the PR. Again, thanks so much and sorry this wasn\u2019t accepted!. Our choice emphasizes that you read between the lines to see the sequence of operations, which I think is more readable for our use.\nPromises are sequences of tasks, so this is different to the other examples you provide, which functionally modify things. With promises, mostly the function that you are calling is irrelevant, all that matters is the content of the closures.. Closing due to stagnation, if you have further questions reopen.. The foundation pod is included in the default PromiseKit pod. So to not be able to use the URLSession extensions you had to explicitly exclude them at some point. Also the docs say how you need this in the comment above\u2026 . We've been building against Xcode 10 for over 2 months, and have the travis successes on CI to prove it.\nMaybe you can provide some more information, like the build log.. Closing due to stagnation, if you have further questions reopen.. Thanks, I won't have time for at least a week, but I'll revaluate near the 24th.. Not adding HKObserverQuery as it completes more than once.. PR referenced above, please review the API.. If you or your employer found this work useful please consider donating to my patreon, thank you.. Many thanks!. You'd get the same error without the promises, so yes, this is normal. Looks like the watch doesn't have networking capabilities in some manner.. PromiseKit 4 has an unhandled error handler, so you can use v4.\nOtherwise we removed this feature in 6 since it was complicated to implement and very hard to test, and due to the way we implement @discardableResult, ignoring errors requires you (almost always) to actually opt-in to that.. Closing due to stagnation, if you have further questions reopen.. This breaks our support for some Swift versions. I saw IBM doing something where they specify Package@4.0.swift or something, I wonder if that is legal?. Would be good if we can add a travis test to verify we are actually getting 4.2 out of the swift compiler. If you can't think of a way, I'll merge and I can try to figure it out at a later time.. Seems like making a test Package.swift that depends on ours could specify other variants. But I can do it. . I published 6.4.1. Use when(resolved:) it tells you if each of the promises are rejected or failed per your requirements.. I\u2019m not available to comment right now, but I\u2019m pretty sure our documentation shows several ways to do this. . Indeed! Thanks @bellebethcooper, sorry I didn't get back to you @Banck, was abroad.\nwhen(resolved:) is one option. The other is to get off the promise you care more about:\n```swift\nlet p1 = foo().get {\n    // do something with $0\n}\nlet p2 = bar()\nwhen(fulfilled: p1, p2).done {\n     // p1\u2019s get will have already been executed, provided p1 succeeded\n}.catch {\n     // p1 or p2 failed\n}\n```\nWith when(resolved:) you would do something like:\nswift\nwhen(resolved: [p1, p2]).done { results in\n    if p1.isRejected {  // alternatively use `results[0]` which is of type `Result<T>`\n         // special code\n    }\n    //\u2026\n}\nBoth are valid, it just depends what you intended. when(resolved:) can be fiddly, partly because it requires all promises to have the same type, which is due to Swift\u2019s generics system being basic in this area.. Seems good to me. Should I not merge? This was an omission by me since I\u2019m on vacation. . Oh I get it. You closed the other one to open this one since the other had a merge commit. Nps. I\u2019ll force update the tag to include this. Yes, I apologize for not doing it sooner, the trouble is it takes hours for trunk push to complete with PromiseKit due to our number of subspaces and I've been abroad. Just got home, will do it after Xcode finishes installing on this fresh Mojave install.. Having trouble getting the linter to pass.. Pushed.. We already support Swift 4.2. Of you have a specific issue please open a new ticket. . This is CocoaPods fault. . I ported everything months ago, but maybe I didn\u2019t update the UIKit extension.\nYou probably don\u2019t even use it, and if so you can specify your pod line without as shown in the README. . K, I did indeed port this: \nhttps://github.com/PromiseKit/UIKit/commit/9c686799d23b12d01596ec1a0844265511acb586\nAnd it's part of PromiseKit 6.4.0, so check you are up-to-date, if you still have problems then we will have to investigate further, but very much looks like issue with your cocoapods checkout to me.. Most likely because Cocoapods generates the Pod.xcodeproj for Swift 4.0 and Xcode is not being very smart here.\nI imagine there's a ticket open to get pod to generate its project for 4.2 that you can subscribe to.. As already stated this is Cocoapods\u2019 fault, I suggest opening a ticket there. PromiseKit is Swift 4.2 ready and has been for months. . CocoaPods defines what version of Swift its generated project supports and they provide no way for pods to specify what versions of Swift they support. So it\u2019s up to CocoaPods.\nThe other way to prevent this is for CocoaPods to generate the Xcodeproj with the flag that states this warning has been ignored. Which is something CocoaPods would have to do, so again, it's up to CocoaPods.\n\nI would probably suggest either using only PromiseKit Core (user) or removing the condition and having the library Swift 4.2 fully (you as an author of the library).\n\nCocoaPods generate the Xcode-project, it's up to CocoaPods.\n\nI would probably suggest either using only PromiseKit Core (user)\n\nThis would have no impact on the warning since the warning is due to generated Xcodeproj specifying its Swift version as 4 (and not 4.2) and not containing the ignore-this-warning-flag and that is up to CocoaPods.. > having the library Swift 4.2 fully\nWe 100%, completely and totally support Swift 4.2 fully. 100%. Totally. Fully. Please don\u2019t think contrarily just because CocoaPods generates an Xcode project that pretends otherwise.. > Sorry to not be clear - \"Having the library only Swift 4.2\" without #if swift(>=4.2) conditions is what I meant. :)\nWe support all the way back to Swift 3.2 so that our library is more useful to people who cannot or do not upgrade their Swift versions. While this warning is irritating to CocoaPods users, we do not think the trade-off of losing backwards compatibility makes sense.\nThanks for your input.. I did nothing towards this fix. If anything changed it was in cocoapods.. Or perhaps your local configuration (deployment target, Swift version).\nAlso which specific warning, the UIKit warnings or the Xcode upgrade-swift warning? This ticket refers to both.. Just to investigate this further I have been trying to reproduce the warnings for the UIKit extensions, and I cannot. No combination of Xcode settings or Podfile settings will produce these warnings for me. Maybe someone could provide me with a testcase?. Maybe this will help in your Podfile:\nruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    if target.name == 'PromiseKit'\n      target.build_configurations.each do |config|\n        config.build_settings['SWIFT_VERSION'] = '4.2'\n      end\n    end\n  end\nend. Cocoa pods bug open with them. We have absolutely nothing to do with the build system this is 100% them. . We have a lot of tests designed to prove that this doesn\u2019t happen, so basically: cannot reproduce. Can you provide a test-case?. I supplemented an existing test adding more subsequent calls. One can see they occur in order. Travis passed.. Oh, you forgot to return, this is why you are seeing the behavior you are seeing. If you don\u2019t return the next then runs before the promise completes.\nEasy mistake to make, in this time of Swift, where \u201cimplicit return\u201d is a thing.. ```objective-c\n[self firstMethodReturningAPromise].then(^(someValue){\n    return [weakSelf secondMethodReturningAPromise:location];\n}).then(^(someValue){\n    return [weakSelf thirdMethodReturningAPromise:location];\n}).then(^(someValue){\n    return [weakSelf fourthMethodReturningAPromise:location];\n}).catch(^(NSError *error){\n}).ensure(^{\n});\n```. nps, glad it wasn't more serious.. You didn't install it correctly.\nPlease use Carthage or CocoaPods if you are new to programming, doing it manually is definitely for advanced users.. I suggest cocoapods for beginners, use homebrew to install it: https://brew.sh\nThen do brew install cocoapods, then follow our cocopods instructions, please refer to CocoaPods documentation if you need to.. I'll close, but if you need more help, feel free to reopen.. Waiting to rebase onto #933 . I deliberately removed this. Cocoapods is broken. They have tickets open for a true fix where I can specify the range of Swift versions I support. If I don\u2019t remove this we don\u2019t sctuslly support all versions with Cocoapods and are lying.. That thread has a fix you can apply in your pod file. But even better stop using Cocoapods it\u2019s a pos. Or open a ticket and tell them to fix their bullshit.. IMO Cocoapods should generate a project with this flag cleared so xcode doesn\u2019t prompt you to upgrade the dependency\u2019s swift version. I think the reasons they don\u2019t are not good, but I can\u2019t influence their decisions. The most I can do is recommend Carthage over CocoaPods which is what I do.. Notably Alamofire also does not set this for the same reasons. Setting it to 4 was mostly acceptable IMO, but setting it to 4.2 to fix this warning would limit PMK a lot, so I just removed it instead, since the warning would be there for everyone on Xcode 10 anyway.\nI updated our documentation to provide the \u201cfix\u201d and am watching the ticket to add version ranges to CocoaPods and may even step up and do the damn work.. Update: I decided to try and add the feature myself, so followed the \u201cgetting started for contributors\u201d guide for CocoaPods, they provide a script to setup the environment, it took 40 minutes to run (wtf?) and failed. So fuck that shit. CocoaPods is awful.. Or in fact use GitHub actions. Once we have access.. Per our installation documentation this is a CocoaPods issue that you have to add code to your Podfile to work around:\nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/Installation.md\nIf this is a problem you can switch to Carthage or comment on the issue ticket they have that is open for them to fix this problem.\n\nThere is swift version if/else statement in UIView+Promise file. That causes swift 4.2 conversion warning on xcode 10.\n\nThis is not the problem the problem is CocoaPods does not set the correct Swift version on the target it generates for PromiseKit. PromiseKit supports Swift 3 through 4.2 and thus this if/else statement is required or we would not actually support this full range of Swift versions.\nThis issue has now been opened three times, please consider searching for existing closed issues before opening new ones in future.. You have no return type on your function.. Closing due to stagnation. Reopen if you still need assistance.. 1. Clone the extensions you want\n2. Drag and drop the sources for the extensions you want into your project.. We have some details about this here: https://github.com/mxcl/PromiseKit/blob/master/Documentation/Installation.md#using-git-submodules-for-promisekits-extensions. Closing due to stagnation.. Many thanks \ud83d\udc4d\ud83c\udffb. This usually means one of the promises is returning a type that the next part of the chain is not using, or the chain itself returns a different type to what is specified Promise<AccountInformation>\nIf you provide the signatures for all the above functions I can probably help more.. Well also you are using the wrong version of when, the version you are using takes an array and gives an array, so you cannot destructure it into a tuple, so instead use the tuple version of when:\nswift\nfunc fetchAll(includeClosed: Bool) -> Promise<AccountInformation> {\n    return when(fulfilled: auth.currentUserIdPromise(), auth.getIdToken())\n        .then { (uid, token) in self.db.get(userID: uid, uri: \"accounts\", token: token) }\n        .then { /* Some more stuff */ }\n   }\n}. Many thanks \ud83d\udc4d\ud83c\udffb\nIf you found my work helpful, please consider supporting its development.. Needs to be a freeform function. I imagine it can be used.. swift\nfunc iAmAFreeformFunction() {\n    print(\"Hi, I am not part of a `class` or `struct`\")\n}. You should use CocoaPods. It manages this stuff for you. Manual installation is much harder to do.  Our instructions miss a bunch of steps because they assume previous experience. . PromiseKit is no different to any other framework. There are resources online that describe how to install frameworks. Please note it is substantially more complicated once you have extensions like watch apps. I cannot provide support beyond Cocoapods and Carthage for free.\nYou can support my Patreon and I provide paid support.\nI suggest googling and or stackoverflow.com. Sorry. . That's kind thanks \ud83d\udc4d\ud83c\udffb. There are several things to watch for:\n\nCheck that PromiseKit is listed as a dependency in the build phases for both your iOS app and watch app targets (probably just the watch extension since the app is just a wrapper). See first screenshot, you'll want to tap the plus.\nCheck the framework search paths for both targets (see second screenshot)\nTry building just PromiseKit.framework, you can select it from the target/platform chooser (third screenshot) select a Watch platform, if it builds then that is good news.\n\n\n\n\n. LMK if any of this works, we can work further based on your feedback.. I have created a new project with a watch app to try and replicate this, and indeed, Xcode won\u2019t build the  watch version of PromiseKit in this scenario (strictly only for watch-app + iOS app). Like you say, it is ok if you build the watchOS version of PromiseKit manually first.\nI know why, we're using a hack to have a single target in the Xcodeproj for all platforms, and apparently, it doesn't work here.\nAs a workaround, in the PromiseKit node in your project: \n\nDuplicate the main target and name it PromiseKit.watchOS\nIn the build settings search for Supported Platforms and edit it, select only watchOS\nMake your watch extension depend on this new target and not PromiseKit-vanilla.\n\nIt will now build.\nI don't think this is acceptable, so I will be creating this target and adding it to the main release, this may take a few days however as I need to do a bunch of testing to make sure it doesn't break anything.\nSorry for this issue, hopefully Apple will support multiple platform frameworks better in Xcode 11.\nPromiseKit 6.6 will have the fix.. \nScreenshot for reference.. LMK if anything isn't clear.. OK, this is a little puzzling but I have a workaround for now.\nPlease note, this is only acceptable if you only intend to work with Swift, if otherwise, we'll have to figure something else out\n\nIn the PromiseKit.watchOS target\u2019s Compile Sources build-phase remove all objective-c (*.m) files\nJust under that, delete everything in the Headers section\n\nIt now should build, if not go over to the build-settings for the PromiseKit.watchOS target and make it look like the following screenshot:\n\n. If this works I\u2019ll figure out a better solution and release a new version of PromiseKit if possible.. Also note that when using PromiseKit in the watchOS target you will need to:\nimport PromiseKit_watchOS\nThis is ugly, but I don't think we should try to fix it until everything is working.. K, I did some more things and they seem necessary, for the PromiseKit.watchOS target:\n\nRemove AnyPromise.swift from the Compile Sources build-phase\nAdd SWIFT_PACKAGE to Active Compilation Conditions build-setting\n\n\n. You also need to remove this code from the end of Resolver.swift since the module name is now different:\nswift\npublic extension PromiseKit.Result {\n    var isFulfilled: Bool {\n        switch self {\n        case .fulfilled:\n            return true\n        case .rejected:\n            return false\n        }\n    }\n}. Yes, . is invalid in module-names, Xcode will make it a _ instead. We can change the module-name to PromiseKit in the build-settings, but I wouldn't recommend it if everything is now working.\nWill leave this open until I have a better solution that I will publish with 6.6.0.. I couldn\u2019t get it working well. I\u2019ll take another stab today.. Seeing if this passes CI: #1010. It passed, can you try the branch?. Re-open if you want this still.. Seems like we should make the queue concurrent instead, the only other use is a \u201cread\u201d operation.. The queue should be iniatlized concurrent. . QoS utility seems wrong, this is often a user-initiated situation, where scrolling will trigger the need for an image to download. I would just leave it as default since there are many various situations where the QoS could be different, even where eg. you are pre-loading the images so you go with utility but then the user scrolls that cell into view and now you need it with userInitiated but this caching system has no way to upgrade the existing fetch to be a higher QoS.. You have to use use_frameworks with Swift frameworks.. tap and ensure are called for all errors by design.\ntap is for debug purposes, and ensure is a guaranteed handler for everything, including cancellation.. Can you please provide usage examples justifying this desired feature?. > Also not clear why for one recover cancelation is handler, but for second - not\nCan you please provide a link to the recover you refer to which is incorrect.. Hi, this recover returns a Guarantee, guarantees cannot error, so it is logically impossible for this recover to be able to ignore some kinds of error.\nPlease note the documentation for this function explicitly states this.. > But if we throw cancel error above, why do we need recover anything?\nIf you don\u2019t want to recover cancellations in such a chain use the other variant of recover that returns a Promise.\nAs said, this variant is provided so you can recover everything and return a Guarantee, this implies that you are also recovering cancellations.\nIf you don't want to recover cancellations use the recover variant that returns Promise.. To clarify my position, I am not against this feature, however I would like to see usage examples so I can understand your need; the usage you provided above does not show the bodies of the handlers, so I cannot infer why you are using tap and ensure such that you want to ignore cancellation.\nAlso we cannot break existing code, so the catch-policies for both tap and ensure would have to default to allErrors.. IMO, there is no sensible catch-policy situation for these functions, they are designed to be called in all scenarios, especially ensure. It would be confusing to add the parameter to them thus reducing the clarity of our API. A user would wonder why a function that has no relation to catching or errors has a catch-policy.. I am remiss: thank you for your effort and the thought here though. I suggest in future though, opening the ticket before making the pull request to save potentially wasted effort.. Closing, rationale in associated ticket #948.. This is a private method. And if you remove it PMK won\u2019t compile. So I don\u2019t recommend it. . AWSTask doesn't seem to derive BFTask, so that\u2019s why it has no then.\nI believe this is possible because we do it ourselves and we have CI that proves this compiles and can be used.\nIs it intentional that your then can only \u201cthen\u201d with other AWSTasks? I would have thought you'd want it to then with a closure that returns a Promise like is typical for then.. Oh OK, well in your first example AWSTask doesn\u2019t have then, it's an extension of Promise, you will need to return an AWSTask in a then off a promise for that one to work.\nI suggest something like:\nswift\nPromise().then {\n    return awsTask\n}.then {\n    //\u2026\n}\nUsing your first code example.. > I see so can I use Promise() like a Void, always fulfilled promise to start a chain of AWSTasks?\nIt's a hack, but if the AWSTask extension won't compile then it'll do.\n\nWhat do you think of third example as far as an approach?\n\nWhatever works and you like is good IMO.\n\nI really wish I could add a then to AWSTask as that would be the most syntactically clear, and a pretty useful extension.\n\nIt's a shame Swift hasn't fixed this objc-generics/swift-bridge issue yet.. > If you think this would be a useful extension to PromiseKit I'd be happy to assist with that.\nYou can add a PMKAWSKit to https://github.com/PromiseKit if you want. Though we may be better off just adding it as a snippet to this repo and linking there.\nGlad to have helped, if you found my work helpful, please consider supporting its development.. If you want to submit it, add it the Documentation directory on this repo under a new folder \u201cSnippets\u201d. Let\u2019s verify: \n\nThat both PromiseKit.framework and PMKFoundation.framework are in both the link and embed parts of your project settings.\nThat you are importing both PromiseKit and PMKFoundation in any places you are using PromiseKit\u2019s Foundation extensions\n\nCan you confirm how many targets your app has, and the platforms you are targeting.. They must both be in the embedded binaries section, what issue do you get if you add them there.. Delete that script, does it work now?. Have you tried rebuilding the frameworks with carthage bootstrap? Could be the binaries are old and Swift is not ABI compatible.. > My app compiles fine, but immediately crashes with the error below. If I read the error right, then the 3rd party framework is expecting to find the URLRequest extension method in PromiseKit.framework rather than in PMKFoundation.framework?\nDo you have some third party framework that uses PromiseKit?. Is that framework binary only, did it get compiled from source in the same carthage bootstrap operation?\nCheck it is also getting correctly installed, then go to the folder it is installed into and run:\notool -L foo.framework/foo\nLet\u2019s examine the output.. Sorry I wasn't specific, I need the same command run but on the installed version, in the built .app bundle.. It is odd that it doesn't link to PMKFoundation though. If it uses it that is. Is it possible it has a vendor copy of PromiseKit it builds with?. Oh ok, sounds like the third party framework expects CocoaPods then. with CocoaPods everything is built into PromiseKit.framework, including the PMKFoundation extensions. And thus it expects that symbol in PromiseKit.framework, but with Carthage builds that is not the case.\nSounds like they are giving you a binary framework, otherwise I don't see how it could be in this state.\nI don't really know enough other details to offer more specific advise, but they shouldn't be building a binary (if that is what is happening) which is built with CocoaPods, since that ties you to CocoaPods, they should build it using Xcode, we support that, for this purpose explicitly.. It certainly seems like they have given you a binary that linked against a pod-built PromiseKit. But it\u2019s hard to say. I prefer Carthage personally but you may have better luck using pods here. . Sorry I want more use. LMK how it goes. . Thanks but I don't think it would be much use, this third party is packaging their framework wrongly, anyone who follows the instructions CocoaPods and Carthage provide wouldn't provide a framework in this mixed and failing state. You should report the bug to them.. I would certainly be interested in learning what it is they are doing exactly, so if there's anything for us to do to mitigate it I can. I would be surprised if how they package for Carthage is legitimate, I expect they are building a binary using CocoaPods and distributing that, which really, is a hack, and they have suffered the consequences here with your wasted time.. OK, well thanks, and if you found my work and assistance here helpful, please consider supporting PromiseKit\u2019s development.. Please provide the example code that fails.. I'm sorry I have no experience with JSPatch, I don\u2019t know how it works or have heard of it and cannot help you.. ```swift\nfunc request(for point: NetworkPoint) -> (Promise, cancel: () -> Void) {\n    let request: Request\n    let promise = Promise { seal in\n        request = provider.request(point) { result in\n            switch result {\n            case .success(let moyaResponse):\n                do {\n                    let json = try JSON(data: moyaResponse.data)\n                    seal.fulfill(json)\n                } catch {\n                    seal.reject(\"Cannot serialize response data\")\n                }\n            case .failure(let error):\n                // If Moya behaves well it will give you an error for cancellation here\n                seal.reject(error)\n            }\n        }\n    }\nrequests.append(request)\n\nreturn (promise, request.cancel)\n\n}\nlet (promise, cancel) = request(for: point)\n```\nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/CommonPatterns.md#cancellation. It can be inserted anywhere you want:\n```swift\nfunc loadData() -> Promise {\n   var cancel = ()() -> Void)?\nlet promise = firstly {\n      exampleService.loadData()\n   }.then {\n      let promise: Promise\n      (cancel, promise) = request()\n      return promise\n   }.then {\n      // ...\n   }.done {\n      // ...\n   }.catch {\n      // ...\n   }\ncancel()\n}\n```. Many thanks \ud83d\udc4d\ud83c\udffb\nIf you found my work helpful, please consider supporting its development.. No, it is correct as is. Usually you want when and not to use sequential thens.\nMany thanks \ud83d\udc4d\ud83c\udffb for the though though. And I\u2019m glad PromiseKit is useful to you!\nIf you found my work helpful, please consider supporting its development.. Fixed, sorry. I have Travis to verify releases, it failed and Travis didn't email me about it.\nWith Carthage just do a new update, with CocoaPods you will have to eradicate the cache which is a series of 3 commands that I forget.. Is this worth it?\nYou don't usually care which error happens, and when you do, you often enough need associated values. Most of the time with Promises when I care about specific errors it is in order to recover. Which this PR doesn't handle.\nThe fact that our catch cannot be as elegant as a Swift catch means this PR could never deliver the kind of value everyone really wants.\nHowever it's not as though I've never wanted this. It's just that most of the times I've wanted it I've got a good Swift error with associated values. Seems like this could be mitigated by provided the error to the handler, but since it will be passed by type, you'd have to unwrap it to get that associated value still.\nEither way returning a Promise is a definite no. I've seen in the past when catch returned Promise people getting confused about the chains, this becomes much easier when chains are returned via multiple levels of functions, which is typical with promises, you lose track of where the error is handled leading to code that expects errors but isn't getting them because an earlier catch already consumed the error.\nWe would have to return a PMKFinalizer which is adapted to handle subsequent catches.. I will merge this if we can do the same as a Swift catch statement. I believe this means:\nswift\ndo {\n    //\u2026\n} catch ErrorType {\n    //\u2026\n} catch ErrorType.specificError {\n    //\u2026\n}\nAnything else?. Seems like we can do both, would look like:\nfoo.then {\n    //\u2026\n}.catch(ErrorType.self) {\n    //\u2026\n}.catch(ErrorType.specificCase) {\n    //\u2026\n}.catch {\n    //\u2026\n}\nWe need some mechanism to force the catch all I think. Otherwise errors would go uncaught.. Your usage example did not demonstrate this:\nswift\n}.catch(ErrorType.self) {\n    //\u2026\n}\nSo you\u2019re saying this is also supported?. K finally, which of these is triggered?\nswift\nfirstly {\n    throw ErrorType.specificCase\n}.catch(ErrorType.self) {\n    //\u2026\n}.catch(ErrorType.specificCase) {\n    //\u2026\n}.catch {\n    //\u2026\n}. > I'm assuming you would like the middle catch to be called in this case.\nWell the order is bad, so the first should be called and not the second I think. For example with this:\n```swift\nenum E: Error {\n    case foo\n}\ndo {\n    throw E.foo\n} catch is CocoaError {\n    print(0)\n} catch E.foo {\n    print(1)\n} catch E.foo {\n    print(1.4)\n} catch is E {\n    print(2)\n} catch {\n    print(3)\n}\n```\n1 is printed.\nEdit: and if you put is E first, then that is caught and no others.. Cool, well this is good IMO. I'd like to review the tests to ensure everything is covered. Also I'd prefer just catch not catchOnly (etc.) what you think that?. Even if the parameter had no default?. Can we change to a v7 submission @nathanhosselton. Seems good. Can we add this to the already existing configuration object?. No need you can push she the amendment here. I tried to fix the CI errors, but I don\u2019t have push access to your branch, so you\u2019ll have to do it.\nThe Logging.swift file is not in Sources so CocoaPods does not pick it up.. > you're now a collaborator on the fork\nThanks, but well, there's some setting you can set so when you PR the destination user of the PR can push to your repo for that branch. I forget where it is.. Is there a technical reason all the tests are within a single function?. I think we can simplify this to just:\nswift\npublic struct PMKConfiguration {\n    var log: ((PMKLogEvent) -> Void)? = {\n        print($0)\n    }\n}\nThis makes the API less overwhelming to users, uses Swift standards for \u201cnothingness\u201d (ie. nil) and allows the user to do whatever they want while providing a sensible default.\nWhat do you think?. And we can drop waitOnLogging() and the loggingQueue.. As it stands the tests are failing on CI and it's pretty hard to debug them since it is 30 lines of code which I cannot easily reason about.. > Really? Isn't there a risk of a race between one thread changing the logging closure and another thread firing that closure?\nThe rules for PMKConfiguration are that you must set these things before any Promise machinery executes. I used to have enforcement for this using dispatch_once but Swift does not expose these methods sadly, so when I was making PromiseKit usable for pure swift, this is the result: a contract to consumers.\nLibraries that use PromiseKit could change these things, but that would make them bad libraries.. We test for all the swifts we support to insure that we never break on all the Swifts we support, so yeah, sorry.. > I think the problem is that using an enum with an associated value within a string interpolation gave a different output in previous versions.\nWell, you could ifdef for each version.\nStill, I suggested dropping the enum above anyway. Edit: oh no, my bad, I didn't mean that.. How do you feel about this just being a closure on PMKConfiguration without the rest, I believe in keeping APIs minimal.. Will be live when this finishes: https://travis-ci.org/mxcl/PromiseKit/builds/463580751\nI changed the function name, hope that's cool. See the recent commits to master for changes.. Oops, thanks.. Done.. This is hard to understand, can you succinctly explain your question?. This still isn't clear to me. I will provide examples and you can tell me if I have it right:\nswift\nfoo.ensure {\n}.catch {\n}\nHere ensure will always fire first, closures fire in the order they are added to the chain.\nThe fact that closures fire in order is a fundamental promise of promises.. K thanks \ud83d\udc4d\ud83c\udffb I\u2019ll amend the docs to make this clearer. \nIf you found my work helpful, please consider supporting its development. You . Many thanks \ud83d\udc4d\ud83c\udffb I'm surprised we didn't already add this\u2026 much like yourself!. Unfortunately we are having to revert this until PMK7, see #990.. Please provide the crash log.. How about a screenshot of the backtrace.. It's crashing in the dynamic linker which suggests to me the binary for PromiseKit is corrupt. You didn't specify how you installed PromiseKit, whichever method you used, clean it, and rebuild it. Ensure all build artifacts are cleaned including your app.. You should delete the Pods directory, and then deintegrate and reintegrate. Of course, quit Xcode first.. nps lmk if it doesn't work.. Make sure to clean Xcode before reintegrating.\nDeleting all Derived Data may help too (in Terminal):\nrm -rf ~/Library/Developer/Xcode/DerivedData. Great \ud83d\udc4d\ud83c\udffb\n\nIf you found my work helpful, please consider supporting its development.. Yes. Just install.. Looks fine, what\u2019s the error?. Specify the return type for that .then. This solution and others provided in our \nTroubleshooting Guide.. swift\nfirstly {\n    UIDevice.microphoneAuthorized()\n}.then {\n    UIDevice.cameraAuthorized()\n}.then {\n    UIDevice.checkNetworkOnWifi()\n}.then { isOnWifi -> Promise<Bool> in\n    if isOnWifi {\n        return .value(true)\n    } else {\n        return viewController.showAlertView(content: \"Are you sure?\", cancelTitle: \"exit\", confirmTitle: \"confirm\")\n    }\n}.done { success in\n   //\u2026\n}.catch { error in\n   //\u2026\n}. Great \ud83d\udc4d\ud83c\udffb\nIf you found my work helpful, please consider supporting its development.. The first warning is a Swift symbol: https://developer.apple.com/documentation/swift/contiguousarray\nThis suggests you maybe have a build system issue that is causing 2 versions of some swift symbols to be used in your final binary. Not PromiseKit related.\nThe second is related to XCAssets management. Not PromiseKit related.. Per our \nTroubleshooting Guide, you need to specify the return types for multiple line then statements.. Yes, Box is internal, so I didn't document it. Apologies. The Box class represents the wrapped Result of a promise and exists to ensure access to it is thread safe.\n\nthe Box class is particularly essential yet it contains various FIXME/TODO comments that make it sound half finished.\n\nThere is one FIXME and one TODO which both represent the same single potential issue. However I have since concluded this situation is fine since the issue relates to the order of handlers being correct, yet this situation can only occur for a handler added independently of any others, so the order would be unimportant to the caller.\n\nAlso, the use of the barrier syncs is not entirely clear (I presume 99% of the time these have no effect at run time, but handle that 1% of the time race condition or other)\n\nYes, they are there for thread-safety.\n\nThis class has two variants on the inspect method that are called from the Promise class pipe method, in succession, again not documented why.\n\nOne of them returns the wrapped Result, the other provides a closure that is wrapped in a barrier sync to allow thread-safe modification of the box.\n\nFinally, objects of EmptyBox type only start out 'empty' so wondering as to the naming here.\n\nThe name is opposed to the SealedBox type, the SealedBox starts sealed, which is used as an optimization when a Promise is initialized with a value, thus we avoid needing barrier syncs. The EmptyBox starts empty, but is eventually \u201cfilled\u201d when the promise it represents is resolved.. Promises only resolve once. If you need some kind of pulse then you will have to write your own.. Please read our troubleshooting guide.. You should be using map rather than then. You should probably read the rest of our documentation, these details are part of the first chapter. then can only have Promises returned, hence we offer map.. LMK if you feel it is lacking still, documentation is a hard balance.. Sorry, this slipped away from me and I have no system for pinging me.. Well, this is completely broken, so I will have to revert.\nIt reports all Guarantees as deallocated pending even fulfilled Guarantees. . K fortunately I have found a simple enough workaround: #1002. AnyPromise feeds Any (as per its definition), therefore:\nswift\nthingFetcher.fetchThings().map {\n    $0 as! [String]\n}.done {\n    // $0 is `[String]`\n}\nThough the map isn't required:\nswift\nthingFetcher.fetchThings().done { (any: Any) in // `: Any` is not required\n    let foo = any as! [String]\n}. nps \ud83d\udc4d\ud83c\udffb\nIf you found my work helpful, please consider supporting its development.. Are the .travis.yml changes required for this PR?. K I see, is it possible to lose all the rearrangements? It's hard for me to reason about the changes in the travis file because of this. And I'm nervous about the changes there because I have spent gosh knows how many hours on it and it's fiddly and flakey and breaks mean that are CI testing is less certain.. I have pushed the start of v7, and I have stripped it quite a bit, my thinking being that v7 can be modernized, and we'll maintain v6 as the back-compat version.\nThis means we have a lot less worry about older versions having ambiguity for this patch.\nSorry that the branch now needs merging again. If you like, I can do it.. > There doesn\u2019t seem to be an Xcode project at the current V7 tip. Is this the intended state?\nYes, you have to generate it: swift package generate-xcodeproj\nI will add a README section for contributing.. Don\u2019t worry about CI, it's not going to work until Travis have an Xcode 10.2 image.. Looks ready to merge to me, what you say?. Probably: https://github.com/mxcl/PromiseKit/blob/master/Documentation/CommonPatterns.md#cancellation. Calling reject will eventually always call a catch block provided that the catch is part of the same promise chain, unless it is a cancellation error (unless you disable this behavior, see the documentation).\nAs the documentation says catch(policy: .allErrrors) will also handle cancellation errors.. PMK 4 should work fine with Xcode 10. What problems are you experiencing?. So to prove this, I added Xcode 10.1 to the v4 test matrix: https://travis-ci.org/mxcl/PromiseKit/builds/472596784. This is just a warning. Ignore it. . swift\nfirstly {\n    getAListOfIds()\n}.thenMap { id in\n    Alamofire.request(APIURLWITH(id), headers: head).validate().responseJSON()\n}.done { data in\n    print(\"ListMatches:\", data.count)\n}\nUse: https://github.com/PromiseKit/Alamofire-. Incidentally the reason your code didn't work is asynchronicity. The Alamofire callbacks all happen in the future, but you fulfill immediately with an empty array.. It will do a request for every id, as the documentation for thenMap states. please read our documentation. . If you found my help useful, please consider reimbursing my time by contributing to my Patreon.. Do done(on: .global()).\nSee our FAQ for more information on server-side promises.. If you found my help useful, please consider reimbursing my time by contributing to my Patreon.. Please answer the questions in the issue template. Closing until done.. Can you specify how you installed PromiseKit. Carthage, CocoaPods, SwiftPM or manually.. The logs will also say which symbols are missing, you should specify. This may have nothing to do with PromiseKit.\nEither way, CocoaPods is probably at fault, deintegrate, reintegrate, clean, rebuild. That will almost certainly fix it. It has about 100 times so far on this ticket tracker anyway.\nEither way, this is nothing to do with PromiseKit, it is a build system issue and CocoaPods is generating that build system.. Please provide the missing symbols that are specified in the log.\n\nIs there a more reliable way to install than from CocoaPods where I won't introduce these additional points of failure?\n\nWe recommend Carthage.. It's missing enormous amounts of symbols, seems like you are not embedding and linking to the Swift runtime.. I cannot. Best of luck.. I cannot help. Sorry. I suggest Stack Overflow.. Usually it was greedy inferment, where sometimes:\nswift\nlet foo = Promise { seal in\n   //\u2026\n}\nfoo would (in some cases) be inferred to be a resolved promise with type:  Promise<(Resolver) -> Void)>.\nI cannot off hand remember an example case though.. Not sure why this doesn\u2019t work, putting it on hold for now.. Glad to please! LMK if you have any other trouble or questions.. Yes: https://github.com/mxcl/PromiseKit/blob/master/Documentation/CommonPatterns.md#retry--polling. Don\u2019t double up promises: \nhttps://github.com/mxcl/PromiseKit/blob/master/Documentation/Appendix.md#doubling-up-promises\n\nBut how can I handle that it only retries on case Error.IDInvalid and Error.documentInvalid, without breaking the maximumRetry cycle?\n\nUse recover.. Looks good \ud83d\udc4d\ud83c\udffb. Closing but re-open if your question is still not answered.\nIf you found my help useful, please consider reimbursing my time by contributing to my Patreon.. Thanks \ud83d\udc4d\ud83c\udffb. Basically, -1 from me. Sorry.\nThis would make these functions inconsistent with the rest of our library, which (when including all the extensions) is a very large API surface now.\nI agree with the sentiment that it is useful to know if a PromiseKit function returns a guarantee or a promise without having to read its documentation (especially because throwing functions in Swift must be annotated try), but unfortunately we have a lot of cases like this, and I'm in general unwilling to uglify the library with naming them promise or guarantee the whole time. \n\nThe (.promise, ) naming scheme was added only because Swift makes disambiguating the functions tedious otherwise, it is a namespace and not a statement about the return type. While I acknowledge this is confusing, and would change it to something else now if I could, we do not use it consistently (only where necessary) so even if we added .guarantee to the enum we would only be annotating a small portion of our APIs that return Promises/Guarantees.\n\nAdding the explicit type as a parameter is not consistent with the rest of our library and isn't necessary IMO since you can add the return type to the closure. Swift does not provide eg. map(Int.self) the only occasions where the standard library do this are for non-closure functions like JSONDecoder.decode since otherwise you would have to specify the type on the variable declaration.\nFinally I'd argue if it isn't clear if you have a Promise or a Guarantee in specific code portions that maybe it's a code smell? Like for me, it's usually clear, since the code is inside a function that returns a chain that is one or the other. Certainly it is possible to have chains that accidentally change from guarantees to promises, and having more clarity would help, but as said 95% of our APIs that return Guarantees are not the ones in this PR, so we're not really helping overall.\nUltimately though you know if you have a Guarantee chain or a Promise chain, does it demand a catch? If so, it's a promise chain.\nI did once consider making Guarantee/Promise initializers that start on another queue, but in the end decided it was not easy to make it clear it was another queue executing. Adding an extension to DispatchQueue means we are using the user's existing knowledge about GCD to communicate what is happening.. > Am I missing something?\nIt's now difficult for people to use the version that Apple provides that returns neither Promise or Guarantee.. Oops, thanks!. * It means cancelation will cause your promises to never resolve\n It makes it trivial to create chains that don\u2019t resolve by mistake since you could easily overlook a place you need to \u201cdouble-up\u201d\n It makes it harder to read the chains, thus violating one of the main reasons to use promises in the first place\nSo the first one is a definite problem unless you make all your catches catch(policy: .allErrors), but cancelation is rare. See the cancelation documentation for more information.\nI sincerely recommend correcting the doubling up, it hides bugs.. Undoubling is usually easy, eg:\nswift\nreturn Promise { seal in\n    foo().then {\n        bar()\n    }.then {\n        seal.fulfill($0)\n    }.catch {\n        seal.reject($0)\n    }\n}\nBecomes:\nswift\nreturn foo().then {\n    bar()\n}\nWhich I think shows how much clarity you gain too.\nAnd fortunately it's very hard to do it wrong, since Swift is type safe; the compiler will tell you if you did it wrong (almost always).. Thanks, this is a serious API breakage and I thank you for your patience. I am reverting the change even though it has been months and no doubt some people have worked-around this issue. This is unfortunate, but it\u2019s the right thing to do.\nWe will reintegrate this for PMK7 and the ambiguity will then have to stand, the workaround will be to pass a closure that calls fulfill().. Happy to help! Though it\u2019s only possible to be this prompt because I'm full-time.\nDonate if you can! https://patreon.com/mxcl. Oh indeed! Sorry, I need to be better at recognizing that. Thanks so much for your contribution, it\u2019s much appreciated. You qualify for me tweeting out thanks actually, you want me to do that for Signal app?. Great! Will schedule for tomorrow.. Battling CI with the PR, but should be merged soon and then will release 6.8.0.. 6.8.0 is tagged, it is processing through CI and will deploy once done.. Not good news: this is no longer possible in Swift 5. Our ambiguity test fails.. Actually, no, we do a full lint when we push, so this is just a waste of resources.. You can report the bug to Apple, maybe they will fix it.. There is nothing we know that can be done about it.. I\u2019m going to leave this open until Travis adds Xcode 10.2 support.. I cannot merge this because it imports headers that may not be in the final framework. Specifically the core location headers are a subspec that only some consumers specify.. Yeah that would be fine, if it works, IIRC I tried to do this years ago and CocoaPods wasn't cool with it.\nThe fact we import with \"\" is also because of something CocoaPods isn't cool with. I think if the user chooses to have pods be compiled to static libraries, edit: probably not, I don't think users can control that at this time.\nPossibly we don't need to provide our own umbrella header anymore (again I added because CocoaPods wasn't cool with something I forget). And that would fix it. CocoaPods will generate its own which would also include all subspec headers.\nEdit: well Carthage will require we provide one, but we can remove the DSL that has CocoaPods use ours rather than generate its own.. Yeah I'm pretty sure we can just let CocoaPods generate the header now.\nIf you change your PR to do that .github/PromiseKit.podspec is the file, and it passes CI, we should be good. (well that isn't a full lib lint, but if I can't push the pod then we'll know it's no good).. This will be unnecessary in v7 since I am removing all subspecs and making them their own pods.\nv7 will however be Swift 5 only, so you may still want to apply the fix to v6.. I think it's cool if we do it like so:\nswift\nextension EKEventStore {\n    public func requestAccess(to entityType: EKEntityType) -> Promise<EKAuthorizationStatus> {\n        return Promise { seal in\n            let status = EKEventStore.authorizationStatus(for: entityType)\n            switch status {\n            case .authorized, .denied, .restricted:\n                seal.fulfill(status)\n            case .notDetermined:\n                requestAccess(to: entityType) { granted, error in\n                    if let error = error {\n                        seal.reject(error)\n                    } else {\n                        seal.fulfill(EKEventStore.authorizationStatus(for: entityType))\n                    }\n                }\n            }\n        }\n    }\n}\nI'm not sure we should do the initial call to EKEventStore.authorizationStatus though. Maybe we do in CLLocationManager but that code is pretty complex for all the different things it handles. Generally we try not to do more than call through to Apple API we claim we will.. Done https://github.com/PromiseKit/PMKEventKit. Yeah, makes sense, race()\u2019s promise deallocates when the first of its arguments resolves, so the others arguments will deallocate too.\nSolution is probably to unset the deallocation monitor for all Thenable arguments when the first one resolves.\nNotably this bug predates #973, but we didn't notice it because we weren't logging deallocations of guarantees.. Yes this is the same as race\u2019s implementation. Once the pending.resolver is resolved, it deallocates, this cascades through and causes the after to be deallocated before it has resolved.. Please note your timeout function follows the common misusage pattern of doubling up promises, please don't do this, it is a code smell. See our Appendix for more information.\nHere it is \u201cundoubled\u201d:\nswift\nextension Promise {\n    func timeout(seconds: TimeInterval) -> Promise<T> {\n        let pending = Promise<T>.pending()\n        after(seconds: seconds).done {\n            pending.resolver.reject(TimeoutError())\n        }\n        pipe(to: pending.resolver.resolve)\n        return pending.promise\n    }\n}. K, I have confirmed that #973 is broken. I will have to revert.. K I'm waiting on CI for the fix. I have tested the warning works as intended now, though I have not added tests to prevent regression, will do after release, which seems more urgent currently.\nWill release 6.8.2 once CI passes which may be as much as 2 hours from now unfortunately.. Deployment: https://travis-ci.org/mxcl/PromiseKit/builds/485611249. Deploy failed, and I'm having to download Xcode 10 (10.1 is broken with CocoaPods) to figure out why. The tag is released though if you use something else. Closing though as fix is in master.. Deploy happened last night. . Clean and rebuild.. You have to delete the Carthage folder in order to clean a Carthage installation.. No problem! If you found my help useful, please consider reimbursing my time by contributing to my Patreon. Thank you so much!. Link from where?. I updated what I could find, thanks for the report.. nps. Thanks for the report! And if you find my work useful, please consider reimbursing my time by contributing to my Patreon. Thank you so much!. This is Swift itself crashing in your code. . There is no reference to PromiseKit in any of the crash log or errors. So it doesn\u2019t seem like PromiseKit is the problem to me.\nIf you can isolate a piece of code that causes this we might be more use.\nThe fact that it crashes compiling every file in your project makes me think you have a bad Xcode installation.\nReopen if you can find anything that indicates PromiseKit in any way.. Closing due to stagnation.. I squashed this into the bigger commit and rebased.. Thanks, I'll fix, I recently decided to let promisekit.org lapse which is probably what broke here.. Should be fixed.. There's some remaining broken links that I\u2019m looking into.\n[edit] all links fixed, and I applied a broken link checker.. More information for this and many other compile issues in our Troubleshooting Guide.. This is really great, and truly shows the value of your changes, my sincere thanks and respect!. I imagine a multiple line attempt would be ambiguous, but possibly not (hopefully not).\nIn general one must do multiple line attempts since one liners are inferred differently (and more leniently).. That is how you combine them yes. If you have compiler problems, see our Troubleshooting Guide. catch doesn\u2019t return a Promise. You have to do the below or use recover, for documentation on how to use recover see our documentation.\nStill, having separate catches like you are doing is typically a code-smell, I\u2019d suggest this:\n```swift\nfunc subChainOne() -> Promise {\n    return firstly {\n        //\u2026\n    }.then {\n        //\u2026\n    }\n}\nfunc subChainTwo() -> Promise {\n    return firstly {\n        //\u2026\n    }.then {\n        //\u2026\n    }\n}\nfunc mainChain() { \n    firstly {\n        subChainOne() \n    }.then {\n        subChainTwo()\n    }.catch { error in\n        print(error)\n    }\n}\n```. This function no longer exists, please read the PMK6 migration guide or read the API docs.. People have asked this before (being able to change the default queue for a specific chain) and my argument generally was you return promises all over the place, and in use of such returns you wouldn't know what dispatcher you were getting which could easily lead to bugs.\nLike the argument still stands, but perhaps we should just make this a thing the user has to be aware of, that is, you need to reset the dispatcher before you return or document the fact that the dispatcher is not the default?\nCertainly we\u2019ve all wanted this feature from time to time. Though PMKv7 distinguishing between in-between closures and done-type closures has helped me a lot there at least since I typically now set conf.Q.map to .global().\nSide note: conf.Q is meant to be one-time-set app-wide; it used to be set with a dispatch_once and thus if you created any Promises before setting it, setting it failed. But Swift does not expose dispatch_once so in PMKv7 I had to remove it (hacks with objc bridging wouldn't work with SwiftPM etc.).. Appears to missing the fulfiller()\n. Really?\n. You don\u2019t need to submit a new PR, you can just push again to this branch.\nI don\u2019t actually mind the change, I would revert that part in a later commit. But typically PRs should only make a specific fix, etc.\nThe fix is much appreciated though.\n. Like specifically\u2014in case you want your patch in PMK\u2014we should return a rejected promise here. Otherwise we will crash for invalid URLs.\n. I think these should be reversed, as it more consistent with other such manifolds in PromiseKit.\n. Can't @import (or #import) as this imposes framework requirements on our end users. Since objc is dynamic, we don\u2019t need to, hence we were using NSClassFromString. We do in Swift though as working around that is too hard right now.\n. 4 is PMKAccessDeniedError, so we should use the symbol and not a magic number. Still it seems the wrong code. We may need a new code. It is bizarre that this part of MessageUI doesn't provide an NSError! I vote for PMKOperationFailed which is as generic sounding as Apple should be embarrassed.\n. The description should be: The user\u2019s attempt to save or send the message was unsuccessful. as that is what Apple says in the docs.\n. We should be consistent with code and message as the Swift variant.\n. I guess there isn't a 4 for Swift PMK? Still we should fix it with a new code for both.\n. Yes, that does suck. Well it's ok to hard code the int values, they won't change. Apple won't risk it. but it is sucky.\nFor PMK2 I am changing this sort of stuff so we can @import, by making the end user compile the categories into their own end binaries. I have an easy way to facilitate that so it won't be a PITA.\n. Add a new one to both I reckon. Make them the same int value.\n. Should be CLRegion? if mirroring the underlying API.\n. IMO it's an error to race an empty array. when can logically work with an empty array since whatever the count: it completes when they all complete, if there are no promises to complete, it is already completed. With race one must succeed so if you feed none, it will fail.\n. _ = is sufficient.\n. whitespace changes\u2026\u00a0let\u2019s not.\n. Use zalgo, it's safe here and we should use it with library code.\n. Yes, please don't change the name, strictly this is a major semantic version bump.\n. Well, this one isn\u2019t associated with Swift code.. This one is in an ObjC header\u2026. NSURLSession is the class name IMO. When you talk about this class in person, what do you say? Everyone I know still says \"NSURLSession\" and I expect them to for quite some time to come.. Fair do\u2019s. Like, I'm not sold on either way, so if you think it should be URLSession I'm cool with it.. This means the objc value for this function will be different to the Swift version.. I don't understand this question, sorry.. Yes they are the same, the code you removed is what makes them the same\u2026. I guess this one is wrong actually.. Or maybe the flatMap one is wrong. Man.. Let me create a summary of each function for you. Will add to main discussion.. Good spot\u2026 commit that fixes this pushed.. Use as!. This is unnecessary.. This is unnecessary.. NSError is defined as : Error so this particular check surely cannot make a difference. If it does then 100% we need a comment to justify this existence of this check.. Oops thanks. . Unfortunately this doesn\u2019t work as expected. It immediately dispatches to this queue, we need to pass the queue and flags to the done.\nAlso the test didn't flag this, so we should make it so it does. The reason it doesn't is your check doesn't actually verify which queue we are on, use dispatchPrecondition(.onQueue(q)) to detect this.. > Thanks for the feedback \ud83d\ude03. I tried using dispatchPrecondition(condition: .onQueueAsBarrier(q)) since it was used elsewhere in tests but it wouldn't pass\nWell, this proves that it is not executing on the right queue. The assert passes because it is essentially testing if 1 == 1.. lazy is not thread-safe.. Just pushed this to master #909 . You\u2019re right, thanks!. Fulfilled & rejected are established Promise nomenclature. The fact that we use a Result type underneath the promise is an implementation detail. So I'm not sure we need to change all these examples.. I would have thought simply when was ok here. The compiler knows what to do and the return type will have to explicitly specified somewhere by the user so they will see.. To be consistent with our other errors this should be timedOut. M is not very descriptive, I'd prefer a name that gives context here.. I'm not a fan of this particularly, I believe in powerful primitives, and thus would prefer something more like:\nswift\nrace(foo, timeout(.seconds(10))\nAnd that the race function itself knows to cancel all its cancellablePromises if any of them reject.. This is not a promise, it\u2019s a PMKCancellableFinalizer I don\u2019t think we should encourage people to call such return values promise.. typo initiazed. typo cancelleed. typo chainm. This is true for all of PromiseKit, and we deal with it in Troubleshooting.md, so we can remove this.. In general let\u2019s move troubleshooting to our dedicated Troubleshooting.md. But I\u2019m very glad you added these. In general we need more such help.. I think cancellize may be better, but let\u2019s talk about it below as I'm not a fan of either really.. I'd prefer cancel(with error: Error) also seems like it should be a CancellableError, the default should be PMKError.cancelled and not nil.. We can instead add this to the exclude list in Package.swift for this target.. Nice, we can remove the when() that does this manually. I figure. Haven't analyzed them both.. ",
    "ide": "Wonderful! \n. A category of NSOperationQueue seems more flexible than subclassing NSOperation e.g. it accomodates projects that already subclass NSOperation. From my experience using Bolts, one of the most important features was being able to choose the dispatch queue / NSOperationQueue to run a block so being able to do that in PromiseKit would be good.\nFor then, I think it's simplest to always return a Promise and later add a convenience method to convert Promises to NSOperations. \n. The discussion at https://github.com/CocoaPods/swift/issues/9 indicates that iOS 7 isn't compatible with dynamic frameworks if you want to publish to the App Store. Your code will run but iTunes Connect will reject it.\n. ",
    "maximkhatskevich": "\"I will make it possible for then to specify a queue\" -->>  Max, tell me please, when do you think this feature will be ready and available via CocoaPods?\n. Okay, thanks. Look forward to it. In the mean time, does current implementation execute each then block in chain on Main queue?\nFor example:\ndispatch_promise(^{\n    return md5(email); // main queue???\n}).then(^(NSString *md5){\n    return [NSURLConnection GET:@\"http://gravatar.com/%@\", md5];  // main queue???\n}).then(^(UIImage *gravatarImage){\n    self.imageView.image = gravatarImage;  // main queue???\n});\nExplain please how can I know on which thread/queue a block in the chain would be executed?\n. Okay, thank you very much for the explanation!\n. @mxcl I would suggest to allow set a queue (lets name it defaultQueue) where to process all the blocks by default at promise constructor and allow specify queue as a parameter to change target queue for a particular \"then\"/block. Also use dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) (system background concurrent queue) by default (I mean use it if no defaultQueue specified explicitly at promise creation time). I think this would be the most flexible way to implement it, because you give full control on where (on which queue) each block is being processed.\nFor most cases you can specify needed queue only twice (at creation time and at last block) like this:\n```\ndispatch_queue_t myQueue = dispatch_queue_create(...); // custom queue\ndispatch_promise(myQueue, ^{\n    return md5(email); // myQueue\n}).thenOn(^(NSString md5){\n    return [NSURLConnection GET:@\"http://gravatar.com/%@\", md5]; // myQueue\n}).then(dispatch_get_main_queue(), ^(UIImage gravatarImage){\n    self.imageView.image = gravatarImage; // dispatch_get_main_queue(),\n});\n```\n... or even once (if you it is okay to perform everything on DEFAULT concurrent system queue except last block where you set explicitly MAIN queue) like this:\ndispatch_promise(^{\n    return md5(email); // default queue\n}).thenOn(^(NSString *md5){\n    return [NSURLConnection GET:@\"http://gravatar.com/%@\", md5]; // default queue\n}).then(dispatch_get_main_queue(), ^(UIImage *gravatarImage){\n    self.imageView.image = gravatarImage; // dispatch_get_main_queue(),\n});\n. ",
    "Zyphrax": "Perhaps this notation would work?\n``` objective-c\ndispatch_queue_t myQueue = dispatch_queue_create(...);\ndispatch_promise(^{\n    return md5(email);\n}).thenOn(myQueue, ^(NSString md5){\n    return [NSURLConnection GET:@\"http://gravatar.com/%@\", md5];\n}).then(^(UIImage gravatarImage){\n    self.imageView.image = gravatarImage;\n});\n```\nBy the way, nice design on the block methods!\n. I think the solution should cover at least these cases, in a clear and simple notation:\n1) You start a task on a concurrent queue and end up on the main (UI) queue.\n2) You start a task on a serial queue and end up on the main queue\n3) You do multiple concurrent actions and bring them together to a serial queue or the main queue\nFor option 1: PromiseKit could create the concurrent queue for us, priority argument would be nice.\nFor option 2: PromiseKit should be fed a queue argument, the serial queue is likely used in other parts of the code.\nFor option 3: This is probably were support for NSOperations is necessary to tie actions together.\nMost people will probably need option 1 in their apps, which is in line with the current implementation.\nThe current implementation however is somewhat vague in terms of which queue is being used.\nPerhaps .then should always continue on the same queue and simply add a .thenOn (for specific queue) and .thenOnMain or .thenOnUI (calls thenOn with main queue).\n. This would mean that all your current examples would have to change the last .then to .thenOnMain.\n(I'm on my phone at the moment, otherwise I would have created a code example).\n. Ok, that makes sense.\nPerhaps use a different method to continue on the same queue (something like .continue)? Or wouldn't that be necessary because you could simply combine it with the first block?\n. In my app I have the following case:\n1. Display HUD to user\n2. Upload logs to server\n3. When 2 is done, hide HUD and upload data dump to server\n4. When 3 is done, perform some internal clean-up (remove temp files etc)\nSo basically we want to upload the logs and data dump in the background, but during the logs upload we want to show a HUD to the user. The HUD needs to be controlled by the main queue, the two uploads on a serial or concurrent queue.\nHow would you solve that with PromiseKit?\nI'm thinking: upload-log (background) => then => hide-hud (main) => then => upload-data-dump (background) => then => clean-up (background)\n. Looks good :+1: \n. Reading the V6 news item, I find the difference a bit confusing too.\nLooking at the example in the PromiseKit readme:\nswift\nfirstly {\n    when(fulfilled: fetchImage, fetchLocation)\n}.done { image, location in\n    self.imageView.image = image\n    self.label.text = \"\\(location)\"\n}.ensure {\n    UIApplication.shared.isNetworkActivityIndicatorVisible = false\n}.catch { error in\n    self.show(UIAlertController(for: error), sender: self)\n}\nvs the use of finally:\nswift\nfirstly {\n    when(fulfilled: fetchImage, fetchLocation)\n}.done { image, location in\n    self.imageView.image = image\n    self.label.text = \"\\(location)\"\n}.catch { error in\n    self.show(UIAlertController(for: error), sender: self)\n}.finally {\n    UIApplication.shared.isNetworkActivityIndicatorVisible = false\n}\nWould the difference be that with the first example, the isNetworkActivityIndicatorVisible = false code is executed before the self.show block, and with the second example it is executed after the self.show line?\nIs that the only difference, or does it have any other side effects?. ",
    "andrebraga": "Would you find the syntax\n.foreground() and .background(queueOrNull)\naffecting subsequent calls to .then() to be too offensive?\nMaybe make it so that only the next call to .then() runs on the designated queue?\nPerhaps .background() could be chained to a call to .then() and only affect the immediately previous link? Would take some decent wrapping magic to achieve.\nAnyway, that's just a quick snack for thought. :)\n. ",
    "hfossli": "Well, reading and understanding the code behind any library is essential to me. I'm sure there are more dev-heads which feels the same about this matter as me. \n. Cool! :+1: \n. :+1:\n. ",
    "cdzombak": "@mxcl thank you!\n. @mxcl I think this'll be resolved by adding s.compiler_flags = '-fmodules' to the podspec.\n. Which PromiseKit-related headers have you included in this file?\n. ",
    "robinwit": ":thumbsup:\nHere's a Belgian beer of your choice: :beer: !\n. ",
    "nickynick": "@mxcl Thought I'd throw my five cents in - if you don't mind a dependency on libffi, it is definitely possible to have primitive types as parameters as well. Like this!\n. ",
    "jallen": "Great! Thanks for PromiseKit.\n. ",
    "lloydsheng": "Xcode Version 5.1.1 (5B1008)\n. ",
    "benjamingr": "Thanks.\nIn JavaScript, the deferred pattern is something like\njs\n    (function(){\n    var d = lib.defer();\n    var foo = bar();\n    someUnpromisifiedThing(function(result){\n           d.resolve(result);\n    });\n    return d.promise()\n    }).then(...\nWhere the \"promise constructor pattern\" is something like:\njs\n    (function(){\n    return new Promise(function(resolve,reject){\n         var foo = bar();\n         someUnpromisifiedThing(resolve);\n     });\n     }).then(...\nThe big difference IMO is that with the constructor pattern, if var foo = bar() throws synchronously, the exception is caught by the returned promise's catch.\nI'm not sure how this applies to objective C though. \nFor what it's worth, I think not supporting onRejected in .then is a perfectly reasonable design choice, I find .then(a,b) rather \"confusing\" compared to .catch(b).then(a). \n. Sorry for the late reply, great work! Good luck with this project, will definitely use the next time I write ObjectiveC code.\n. Note that promise cancellation is very problematic in the case two .thens are performed and then one of them cancels. It affects the other .then where it shouldn't.\n. @csotiriou on 'other languages', as far as I can tell most languages do support cancellation - be it Tasks in C# or the cancellation spec in JS which most libraries support.\nKris had an interesting idea that if you make a promise cancellable only one subscriber may subscribe to it - that is: you can only .then it once.\n. @csotiriou \nFirst, in C# tasks do not represent asynchronous networking at all, they are much more often an abstraction over 'doing something' and are used as \"easier to reason about\" threads in many places. In JS it's mainly for concurrency although some people have implemented parallelism with it through web workers. \nIn C#, tasks are cancelled with a CancellationToken. Here is an example  of how to use it.\nBasically, it's more of a if (ct.IsCancellationRequested) - that is, like you said \" the promise may or may not stop\". Alternatively, it throws an exception in the async keyword case. You can handle it and recover but you're expected to cancel. In JavaScript a similar approach is taken.\nIn general, you can see how we handle it in JS here although we are not really satisfied with it.\nBased on @KrisKowal 's idea. Here is a very basic adaptation I wrote which is just a suggestion that should be scrutinized before being used or even considered: \n- You get a promise that is not cancellable.\n- If you want to cancel it, you call .cancellable on it, this only works if no one called .then on it and cancellation only propagates to this level and not higher. That is - if it originates from another promise cancellation does not propagate higher.\n- At this point, you may only attach a single .then handler to it which creates a promise you may only attach a single .then handle to and so forth. Each of these promises have a .cancel method which propagates up to the promise you called .cancellable on.\n- If for some reason you need to attach more than one .then method to it, you call .fork() on it, in turn .fork() returns a promise which is not cancellable. You may attach as many .then handlers to the forked promise as you want but none of them are cancellable. \n. I totally missed the named parameters, that works :+1: \nI can give a map example:\nlet pages = Promise(value: [1,2,3,17]).map { \n     NSURLConnection.GET(\"http://api?page=\\($0)\") \n }.then { (pages:[String]) in \n      // process all the pages downloaded as strings\n }\nIt would also be nice to have built in POST support in the NSURLConnection extensions, I'd make a PR but I'm not confident enough in my abilities in Swift or in the API yet.\n. Also, it would be very beneficial to have an API.md file like we have in Bluebird for all this, I can make one if you'd like.\n. Any ETA on post being available? I'd rather not write my own wrapper for posting JSON and promisifying it if that's possible.\nTry that map example when you're inside a chain :)\n. In JS land promises solve this with .spread and .all\n. ",
    "jnozzi": "Closed without comment or consideration? :-/\n. Thanks for reconsidering. Prefixing is standard practice for good reason - a pre-1.0 rename won't hurt much but a major clash down the road with wider adoption of your project most definitely will.\n. @sey Not sure what you mean, no.\n. @sey Ah, I see your point now but that's only for those who (will) use Xcode 6. Presumably @mxcl would want this library to be useful for existing and prior OS and Xcode versions.\n. @sey It's a problem if you (or your employer) can't or won't yet update to 10.10 / Xcode 6. This scenario happens more often these days considering Apple's insistence on dropping SDKs for older OS versions with new Xcode versions (ie, using Xcode 4/5 means you can no longer build apps that must support 10.5). \n. ",
    "laptobbe": "I agree with @jnozzi here, its a simple rename that could save someone some trouble.\n. ",
    "amarcadet": "What about a #define to add/remove the prefix?\nSome inspiration could be found here in PSTCollectionView or here in Expecta with EXP_SHORTHAND.\n. ",
    "mbinna": ":+1: I support the suggestion to prefix classes. I also want to suggest to prefix methods in categories that extend classes external to PromiseKit to prevent accidentally overwriting a private method of that class.\n. Ah, I see. That makes sense. I was just curious about your intentions to go \"all in\" with both error handling and exception handling. Thank you for the explanation.\n. :+1: \n. ",
    "lukabernardi": ":+1:  for the class prefix, but I think that the prefix is even more important in the category class methods.\n. ",
    "mackross": ":+1: \n. Thats just one way to do it. I can think of a few others but that's small and no casting needed.\n. ",
    "sey": "This will probably won't be necessary if you see what I mean.\n. Modules...\n. I don't see how this is a problem. Using A newer version of Xcode usually doesn't break previous OS versions compatibility. But maybe I am wrong as I often push projects to only be compatible with the latest two iOS versions.\n. Did you take look at this article? \nhttp://www.splasmata.com/?p=2798\n. ",
    "wiruzx": "Great! Thanks!\n. Unfortunately it doesn't help.\n\nEven if i write:\n\n. What if it returns () Or Promise<()>? And what difference between () and Void?\n. oh, i see, thanks\n. ",
    "Abizern": "Tests pass with this.\n. Thanks!\n. ",
    "marklarr": "I like the idea of PromiseKit, but the fact that it catches all exceptions inside a promise and converts them to NSError is a deal-breaker for me. Catching exceptions in objective-c is a really bad idea. There should at least be an alternative solution for only catching NSErrors.\n. Do you also do that with the rest of your code? Catch any exception?\nIt's good to know that you can turn it off :+1:  thanks for replying so quickly\n. Sorry, I wasn't clear. I was just curious if you try to catch exceptions in the rest of your applications and alert the user the way that you do in your asynchronous code.\n. What if an exception in your promise chain dirties the state of your application? Dead Programs Tell No Lies and all that\n. To each their own, I suppose. Thanks for taking the time to explain everything.\n. The preprocessor redefine is definitely good. Though, I no longer work on the Venmo iOS app, I now work on Ruby at Braintree for transaction processing. I was investigating this for a personal project :)\n. I think that it's up to the programmer to program defensively to avoid exceptions. In some languages (like Objective-C, unfortunately) this is harder than others. For example, in Ruby, indexing outside of an array just returns nil. While in Objective-C, you should check the array's length before accessing it to be safe.\nAre these NSJSONSerialization and array exceptions coming from other frameworks you're using? They should hopefully just be checking if data is nil before parsing it for JSON, etc? Are they not?\n. ",
    "mrcrow": "Thanks @mxcl !\n. ",
    "csotiriou": "I have just began a new Github project (it's still in its infant stages) here:\nhttp://github.com/csotiriou/PromiseKit-AFNetworking\nSo far it works with AFHTTPRequestOperation and AFHTTPRequestOperationManager, which are the most widely used classes (since the AFHTTPRequestOperationManager also offers backwards compatibility). I will implement more on the way, but feel free to use them and provide your feedback.\n. I made the necessary changes and implemented the way you showed me, because I also feel that this method is much more intuitive.\nOn a side note, by saying \"will not work\" you mean that it will not produce the expected result? With the old method, this was the result I was getting by making a request using a false URL:\nRequest:\n[self.manager GET:@\"http://www.error-url.ss/\" parameters:nil].then(^(id responseObject, AFHTTPRequestOperation *operation){\n        NSLog(@\"first request completed for operation: %@\", operation.request.description);\n        return [self.manager GET:@\"http://www.apple.com\" parameters:nil];\n    }).then(^{\n        NSLog(@\"second request completed\");\n    }).catch(^(NSError *error){\n        NSLog(@\"error happened: %@\", error.userInfo[PMKThrown][0]); //this will hold the actual error reported by the HTTP Client\n    });\nResult\n2014-05-19 01:46:51.222 PromiseKit+AFNetworking[28370:60b] PromiseKit: Error Domain=NSURLErrorDomain Code=-1003 \"A server with the specified hostname could not be found.\" UserInfo=0xb3085f0 {NSErrorFailingURLStringKey=http://www.oramind.co/, NSErrorFailingURLKey=http://www.oramind.co/, NSLocalizedDescription=A server with the specified hostname could not be found., NSUnderlyingError=0xcf0b6c0 \"A server with the specified hostname could not be found.\", afHTTPRequestOperationError=<AFHTTPRequestOperation: 0xb51f940, state: isFinished, cancelled: NO request: <NSMutableURLRequest: 0xb50ecb0> { URL: http://www.oramind.co/ }, response: (null)>}\n... which is the result I expected. I looked at the PromiseKit code to see how could I do that, and it seemed to me that by using \"PMKThrown][0]\" I would be able to get the error by AFNetworking.\nHowever, as I mentioned, whatever the result I was getting before, your proposal is by far better, so I have already changed the code. Thanks for the quick feedback!\n. Yes, that's why I changed it and implemented the method you showed me. In the coming days, I will try to implement categories for AFHTTPSessionManager.\nI have to admit that by Promising the project I am working on right now has improved readability and scalability quite a bit. Well done. \n. Well, seems like it but:\n-- It's outdated, even though he created it later than me.\n-- Doesn't have AFHTTPSessionManager integration\n-- It seems it's not available to the main repo (at least I cannot find it). mine is. http://cocoapods.org/?q=promisekit-afnetworking\n. I'm not trying to undermine the importance of the issue here, but I have some different thoughts on the matter. Although cancelling a promise would be nice to have, I feel that implementing a cancel action in a promise:\n-- Will produce logical problems (see @benjamingr 's comment above)\n-- Will conflict with the cancellation logic of frameworks that have a cancellation logic on their own (e.i AFNetworking and the likes).\n-- It may produce more functional problems that it solves with multithreading, in case many promises depend on each other - what will a promise cause to a Promise chain, with some Promises in this chain being concurrent?\nIn most programming languages that have implemented a similar API (Javascript, for example), wrappers of functions (like Promises) don't actually handle cancellation on their own, if I am not mistaken. They keep things simple, for other developers to build their own frameworks on top of them, and have their own cancellation logic.\nAsynchronous networking in all forms covers 90% of the cancellation needs of modern platforms. Asynchronous networking cancellation works like a breeze with PromiseKit and frameworks such as AFNetworking (shameless self-promotion : https://github.com/csotiriou/AFNetworking-PromiseKit ). You cancel an AFHTTPUrlRequestOperation, and the promise automatically stops. I have already implemented it into a high-profile project and it works flawlessly.\nIf you implement cancellation in a Promise, you must also provide a consistent API for frameworks supporting PromiseKit to integrate also their own cancellation logic. The rules (and limitations) for cancelling a Promise seem to be the same as the ones for cancelling an executing GCD block, which is a bit tricky, and not supported out of the box, for good reasons.\nIn the end, I am wondering, if it's worth all the effort, and if it will work (from a technical and logical standpoint) as we have it in our minds right now.\n. @benjamingr thank you for correcting me. However, I have a question, which may or may not be relevant to this thread: When you cancel a Task (or anything similar) is it certain that execution will actually stop, or that means that you give a \"stop signal\" and the promise may or may not stop according to the block being executed? Again, don't think only in terms of asynchronous networking, think in terms of other blocks, that may not have a cancellation logic by design (like a large image resizing algorithm).\n@dbachrach I have indeed solved that issue, by cancelling the specific operation by looking at AFHTTPRequestOperationManager's operation queue. That means searching for the operation to cancel and identifying it using the URL and method. However, it works. Another logic is to create an AFHTPRequestOperation, keep it somewhere, and then call \"-promise\" on it and work as before. I use the first method, however.\nAfter your answers, I believe I should stand corrected, and say that cancellation logic would be nice to have, if it's not always mandatory to use.\n. Not sure if I add to the conversation much, but I have tested tgaul's solution.\nI am being involved in a mission critical application, and PromiseKit with AFNetworking handle the core networking. Everything went fine, until I started receiving crash notifications. (\"Promise about to be deallocated before it has been resolved! This is likely a bug and you are likely to crash. @see https://github.com/mxcl/PromiseKit/issues/50 \") The code that does this is the part of the normal POST operation, where I check if a token is expired, and if it is, I inject a piece of code into the login function, perform the login again, and make the request I missed again after login. With PromiseKit, I have experience many issues, than although they didn't make my application crash, they certainly didn't have the correct results (which is worse). \nI would welcome and appreciate any resolution to this matter. With Tgaul's solution, not only I've solved my issues, but also I have seen a networking performance boost. \nJust thought I should mention this, because I believe it's good to have a feedback of something so important when trying to figure it out.\nBTW, thanks for taking the time to create such a good library, and work on it.\n. Same here. It seems an Objective C++ issue. Could it be because C++ doesn't allow any keywords to be used as parameter names, even if they are used in a totally different context? \nUPDATE: It's definitely an issue with Objective C++.\nHowever, the fix is easy. Create a category like this, in separate files.\n```\n@interface PMKPromise (CPPFix)\n- (PMKPromise *(^)(id))error;\n@end\n@implementation PMKPromise (CPPFix)\n\n(PMKPromise *(^)(id))error;\n{\n    return [self catch];\n}\n\n@end\n```\nand use the '-error' method, instead of the catch method inside your .mm file. That seemed to do the trick for me. Note that the category file should have the extension .m, otherwise, it will be compiled as Objective C++ and you will have the same problem.\n. I feel I must answer my own question here:\nBy testing the following code:\nfirstly { () -> Promise<AnyObject?> in\n    println(\"one\");\n    return Promise(\"one\");\n}.then { object -> Promise<AnyObject?> in\n    println(\"two\");\n    return HTTPClient.sharedClient.getJSONP(\"test2\", parameters: nil);\n}.finally(on: dispatch_get_main_queue()) { () -> Void in\n    println(\"finally called\");\n}.catch(policy: .AllErrors) { (error) -> Void in\n    println(error);\n}\nI get the following output:\n```\none\ntwo\nfinally called\nError Domain=NSURLErrorDomain Code=-1002 \"unsupported URL\" UserInfo=0x7f8733d86fd0 {NSUnderlyingError=0x7f8733c9e600 \"The operation couldn\u2019t be completed. (kCFErrorDomainCFNetwork error -1002.)\", NSErrorFailingURLStringKey=test2, NSErrorFailingURLKey=test2, NSLocalizedDescription=unsupported URL}\n```\nWhich means that the 'finally()' which I placed before the 'catch()' was called, even if there was an error in the chain (in this case, there was a, invalid URL passed as parameter). This seems different from the Objective C implementation, but I suppose it's clearer to have just one 'catch()' clause at the end of a chain, handling all errors.\n. Thanks for answering this. It don't believe it should be considered bug, since this is done by design. \nI just would like to know, if putting a \"finally()\" before a \"catch()\" is the proper way of having both a 'catch' and a 'finally' present in a chain, with PromiseKit 2.0, as per my observation in my second post on this thread.\n. I have the same problem. Why does it happen only in PromiseKit, though?. ",
    "djtarazona": "I just ran pod update and am still experiencing the same thing.  Digging into it a bit, it looks like it is matching the following case and therefore the block is never called\nobjc\n            case '^':\n                if (strcmp(sig.methodReturnType, \"^v\") == 0)\n                    return PMKNull;\n                // else fall through!\nwhereas if the block doesn't return anything (void) it matches this case\nobjc\n            case 'v':\n                if (nargs > 1) {\n                    void (^block)(id) = frock;\n                    block(result);\n                } else {\n                    void (^block)(void) = frock;\n                    block();\n                }\n                return PMKNull;\nI hope that helps!\n. Perhaps return [Promise promiseWithValue:nil]?\n. I finally got around to documenting the category and submitting a pod.  The pod is named Parse+PromiseKit\n. Ah, yes that is definitely a problem.  Thanks for the heads up.  I'll do some research and change the license shortly.\n. The code is now licensed under the Apache v2 license :+1: \n. > Other possible feed values are aPromise / anotherPromise / somePromise, right?\n\nAs none of them are (NSError *), it doesn't catch up any other cases at all!\n\nWhat do you mean?  A promise is either pending, resolved (with a value or nil) or failed.\nIf any of the promises in you example code (p, aPromise, anotherPromise, somePromise) fail or if someValue is an NSError, your catch block will be \"fired\".  Your catch will indeed catch any errors or exceptions in the chain.  Try it out!\n. The documentation is referring to the then method on a promise.\nobj-c\nPMKPromise *promise = [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\npromise.then(^(UIImage *image) {\n    // You can now access the result with `image`\n});\nSo \"then off a promise\" => aPromise.then()\n. :+1: \n. Actually this doesn't work. Any suggestions?\n. Ah, got it. We just need to make when<T>(promises: [Promise<T>]) -> Promise<Void> public?\n. PR updated so that when is not ambiguous.\nUnfortunately I'm not too familiar with Carthage yet so I haven't run the tests.  I can do so later but I probably won't have time to tinker with it until another week or so.  If anyone wants to run the tests for me, that would be great!  PromiseKit compiles (and seems to work) just fine for me with this code in my iOS project.\n. :+1: \n. Ya, at WWDC they informed us Xcode 8 will support both Swift 2 and 3.\n. ",
    "jessedc": ":thumbsup: Thanks for the clarification. \n. ",
    "dbachrach": "Interesting, I haven't used NSProgress yet. So you're suggesting:\nobjc\nPromise* myPromise = [obj GET:@\"/\"];\n// .. later\n[myPromise.progress cancel];\nMakes sense. My question would be how much of the NSProgress API do you want to commit to. If it's just cancelation then having -cancel live on Promise would be clearer. If you want fractional progress indication and pausing too, then NSProgress looks right.\n. Here's a simple CancelToken, I've been using: https://gist.github.com/dbachrach/296586173a303c17c0ad\n@mxcl I'm wondering if this is worth expanding upon and including in PromiseKit.\n. @csotiriou In your library you have:\nobjc\n- (PMKPromise *)GET:(NSString *)URLString parameters:(id)parameters\n{\n    return [[self GET:URLString parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {} failure:^(AFHTTPRequestOperation *operation, NSError *error) {}] promise];\n}\nHow would I cancel that GET request? From a quick look through your code, I don't see how the caller of that method can cancel the task.\nIn my code I do this right now:\n``` objc\n- (PMKPromise)GET:(NSString)URLString\n    parameters:(NSDictionary)parameters\n    cancelToken:(MHCancelToken)cancelToken\n{\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter) {\n          NSURLSessionDataTask task = [self.sessionManager GET:URLString\n                                                     parameters:parameters\n                                                        success:^(NSURLSessionDataTask resultTask, id responseObject) {\n                                                            fulfiller(responseObject);\n                                                        }\n                                                        failure:^(NSURLSessionDataTask resultTask, NSError error) {\n                                                            rejecter(error);\n                                                        }];\n      [cancelToken onCancel:^{\n          if (task.state != NSURLSessionTaskStateCompleted) {\n              [task cancel];\n          }\n      }];\n}];\n\n}\n```\nThis was the main difficulty I ran into, which made me turn to cancelation tokens. If you've solved that without tokens, that would be great.\n. Just want to through out one more thing I've been thinking about. With collectionview/tableview cells that start asynchronous work, I could see it being useful to have a form of cancelation like so:\nobjc\n[ImageFetcher fetchImage:imageURL].ensure(^BOOL(){\n    return /*whether this image request is still for this cell.*/;\n}).then(^(UIImage* image) {\n    cell.imageView.image = image;\n});\nensure would continue then propagation if the result is YES. Otherwise, no thens or catches occur.\n. This all seems to make a lot of sense. I like the default policy of not raising cancelations to catch blocks, but do allow it via explicit indication. In the ensure() example we discussed previously, ensure could just be a generic extension to PromiseKit that would raise the cancelation NSError. I think that pattern needs to be vetted before inclusion in the library, though. I think this issue can be closed. Thanks Max.\n. @mxcl Consider this scenario. A network GET API returns a promise. To handle an error in the network request, the client should attach a catch handler. However, callers can cancel network operations. Network operations that are cancelled internally throw a Cancelation error (indicating the operation was not completed). A caller of this API should not receive a cancelation exception in their catch handler. It should effectively be swallowed and neither a then nor a catch should run.\nHow I would expect to do this is to wrap the promise I return from the GET api with a catch:\nobjc\nreturn [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter) {\n   // .. do network request\n}].catch(^id(NSError* error) {\n            if ([error.domain isEqualToString:NSURLErrorDomain] && error.code == NSURLErrorCancelled) {\n                NSLog(@\"Swallowing cancel error\");\n            }\n            else {\n                return error;\n            }\n});\nIs this achievable with PromiseKit today?\n. See https://github.com/mxcl/PromiseKit/issues/36 for the addition to all: to support empty promises array. \nRelevant checkin: https://github.com/mxcl/PromiseKit/commit/cbcbd9bbfefee2275f6204c7d82fe1fb99435870\n. if (self.avatar) fulfill(self.avatar);\nYou need a return statement after this. As it right now, both fulfill() statements are executed, causing it to resolve twice.\n. Yeah understood. I think thenOnBackground is more objc-like and still pretty terse. I think this is a useful standard to define in the library. Happy to make a PR.\n. Good point. In over On. A quick browse of the thesaurus provides:\nobjc\n[obj fetch].later(^(id response) {\n    // in background\n});\nWhich is interesting, but vague. I'll put a PR together for thenInBackground\n. Yeah looks like unleashing zalgo is the definition of what I'm looking for. I guess I'll switch back to just doing another dispatch. The only thing I'm tossing around is if you dispatch_promise_in_background inside of a queue that's already previously dispatch_promise_in_backgrounded then you are releasing zalgo internally but not externally to the root promise creation.\nAs an example, I have an API that provides:\nobjc\n- (PMKPromise*)fetchStuff {\n    dispatch_promise_in_background(^{\n         // do some work, take some locks, whatever\n         return [networkManager fetchRequest:xyz];\n    });\n}\nWhere networkManager's fetchRequest method is also a promised API whose implementation dispatches in background.\nThe caller of fetchStuff should see no zalgo because the promise is already forced to dispatch_async. \n. Right. That's what I thought too, but swift is complaining. I'm on Xcode 6.4. Here is the swift code that works:\nswift\nlet p = MHObject.fetch() as! AnyPromise\np.then { obj -> Void in\n    // do something\n}\nIf I remove the as! like this:\nswift\nlet p = MHObject.fetch()\np.then { obj -> Void in\n    // do something\n}\nI get the following error:\nViewController.swift:28:12: Cannot invoke 'then' with an argument list of type '((_) -> Void)'\n. 2.1.1 PromiseKit as well.\n. swift\nlet p = MHObject.fetch()\np.then { (obj: AnyObject?) -> Void in\n    // do nothing\n}\nDoing the above I still get the error: Cannot invoke 'then' with an argument list of type '((AnyObject?) -> Void)'\nSimply by as!ing to an AnyPromise, the code then works. So it seems like somehow the compiler doesn't think that PMKPromise and AnyPromise are quite the same thing. When I do the as! I get this warning:\nCast from 'PMKPromise!' to unrelated type 'AnyPromise' always fails\n. I sent you an email with our project. Thanks for the help!\n. No worries. Thanks for taking a look at it. Let me know if you need anything from me.\n. @mxcl Mad work! Thanks. Will try this out this weekend.\n. So the then behavior I expect is that if a return an Int from a then, the promise chain resolves with that Int value. If I return a PMKAnyPromise from a then, I do not expect the promise chain to resolve with a PMKAnyPromise. The chain should continue and resolve with the result of that promise. \nI am not seeing that behavior though. It resolves directly with a PMKAnyPromise rather than the value that that promise resolves with.\nDoes that make any sense?\n. Ah gotcha. Hey thanks so much for taking a look and fixing this so quickly. Really appreciate it. I will check this tomorrow morning and let you know if it fixes our bug.\n. :+1: 2.2.0 fixes the issue and we can now chain our promises. Awesome work!\n. We've got promises working in tvOS as is.\n. Hmmm. We integrated with cocoapods and used that branch. \n. We are on cocoa pods 0.38.2, and here's our podfile:\n``` ruby\nplatform :ios, '8.0'\nuse_frameworks!\ninhibit_all_warnings!\npod 'PromiseKit'\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        target.build_configurations.each do |config|\n            config.build_settings['SUPPORTED_PLATFORMS'] = ['appletvos', 'appletvsimulator'];\n        end\n    end\nend\n```\nThis doesn't use the new tvOS branch, and just manually updates the build settings to support tv and tv simulator.\n. ",
    "Strilanc": "You might also want to consider doing cancellation from the requester side, by passing in a cancel token that the async operation can hang off of. Often the thing that triggered the future is what knows when it should be cancelled. More reasoning here.\nThat's what I did in collapsing futures, anyways.\n. ",
    "kriskowal": "My position on cancellation has evolved. I am now convinced that cancellation is inherently impossible with the Promise abstraction because promises can multiple dependess and dependees can be introduced at any time. If any dependee cancels a promise, it would be able to interfere with future dependees. There are two ways to get around the problem. One is to introduce a separate cancellation \"capability\", perhaps passed as an argument. The other is to introduce a new abstraction, a perhaps thenable \"Task\", which in exchange for requiring that each task only have one observer (one then call, ever), can be canceled without fear of interference. Tasks would support a fork() method to create a new task, allowing another dependee to retain the task or postpone cancelation.\n. Rejection from the producer is different than rejection from the consumer. Rejection from the consumer  is a POLA violation, giving consumers the ability to interfere with each other\u2019s progress. This manifests as the \"Action-at-a-distance\" antipattern. Since errors can flow both upstream and downstream, they can be broadcast laterally throughout a system. The reason for keeping the resolver and promise separate is to ensure that data flows in one direction, making programs robust and composable.\n. POLA as in Authority in this case. And my argument is that cancellation does not work on promises, but could work on a different primitive mostly of the same shape and sharing the same principles.\n. Regarding cancelation in general [WIP] https://github.com/kriskowal/gtor/blob/master/cancelation.md#canceling-asynchronous-tasks\n. ",
    "albsala": "I'm using [PMKPromise +when:] in order to synchronize two data download processes and I would find very useful to have a canceling option when one of these processes fails. In other case, I mean now, PMKPromise's behavior causes me problems.\n. I have reproduced it isolated:\nhttps://github.com/albsala/PromiseKitIssue\n. ",
    "zdnk": "ensure is better, but I would also appreciate cancelling the promise if I am doing some networking.\n. I see, it seems to be close enough, however, it still has 2 thens. Same thens actually. It gives you option to skip the \"cached\" data UI update, however it would be nice to make this work with single then, something like calling the fulfiller twice I guess?\n. what about something like startWith like in https://github.com/ReactiveX/RxSwift/?\n. You cant define branch in Podspec. You can do it in Podfile, but not in Podspec.\n. but it doesnt actually help if I need it in podspec :(\n. One thing that concerns me is the CC postfix. It is very un-Swifty and not developer friendly.\nOthervise it looks good.\nThe question is, if it is really needed to touch all Promises. Wouldn't it be enough to have Regular Promise and CancellablePromise to go with that? By return type of the promisified function, the developer knows that the task is cancellable and can treat the the chain accordingly. Of course I do not know anything about how PromiseKit is done, but it is important to also provide good developer experience with this.. Hello, thanks for extensive response!\nWell, the thing I do not understand why you would need 2 versions of URLSession.dataTask(_:..) for example. You need just cancellable one, because it simply is cancellable procedure/task/future/promise. It should be up to the developer if he us going to use the cancel-ability of the Promise. And the developer knows the promise is cancellable from the signature of the function/method, its return type (eg func dataTask(request: URLRequest) -> CancellablePromise<(data: Data, response: URLResponse)>).\nI believe then firstly, then, after etc. can very simply work based on that.\nMaybe there is something more complex that I am missing and it surely has obstacles, but I believe this would be the best developer experience.\nOn rule: Non-cancellable tasks return Promise, cancellable ones return CancellablePromise, if someone needs to introduce both versions for the same task (whatever might be the reason), they should figure out the naming themselves.\nLet me know your thoughts :). Well I like the idea of having a chain member like your cancelIf, but for me, the most important is cancelling promises externally. Imagine you have a UITableViewCell subclass that got and URL of image to download and display. I image that cancellation of the image download and display chain would happen in the prepareForReuse() as it is the simplest solution.\nAlso, the cancelIf on your example is called only after the Promise in the chain is completed right? In case of network requests this is simple waste of data and power.\nI believe the goal of cancellable promises should be external cancellation as the cancelIf may have limited usage and might lead to people creating yet another cancellation tokens to be able to cancel the chain externally.. ",
    "jkolb": "@kriskowal Thank you, I had found that link somewhere but it was tricky to stumble onto when searching on the subject of promise cancellation. The last paragraph in it gave me inspiration.\nIn my promises library I've implemented cancellation by tying it to the lifetime of the Promise. When a promise is deinitialized the work it is doing can be cancelled early if not already finished. Only if all promises depending on another promise are deinitialized will it really cancel, otherwise it must stay alive and finish its work for the ones that are keeping it alive. Just because one section of the code cancelled doesn't mean other places in the code should be interrupted. The application programmer can then structure the promises to support early cancellation by making sure when needed they can be deinitialized at appropriate times.\nTo help support this, when you create a new promise you are provided with fulfill, reject, and isCancelled callbacks. Both fulfill and reject have weak references to the original promise so that if you call them and the promise has been deinitialized they safely have no effect. The isCancelled callback allows your long running background process to periodically call it to see if the owning promise has been deinitialized and exit early if it has. All promises in a chain have a reference to their parent promise and any promises returned within their callbacks, that way the lifetime of a promise is well defined. As long as the last promise returned from then is alive, then the entire chain is alive.\nAny thoughts on if this is a viable strategy for implementing cancellation for PromiseKit?\n. ",
    "krzysztofzablocki": "Sounds good :+1: right now at least PromiseKit user won't need to worry about extra error condition in their social sharing. \nIt's a bit verbose to check if the error you receive was status code error, but I never saw a compact way of handling that.\nWhat do you think about having a simple syntax sugar that would allow to verify errors like this? This could be easily implemented without breaking anything in normal NSError implementation.\nif([error isKindOfError:PromiseKit.Social.StatusCodeError]) {\n}\n. catch with same approach as then would look awesome, but I think index will suffice just fine :+1: \n. :+1: \n. @mxcl +1 on this, annoying to modify pod source each time I update just for this right now\n. ",
    "stefanpenner": "Basically, if something can every be asynchronous is should always be asynchronous or you will unleash zalgo this is a promise a+ invariant.\nSorry for the JS but a super simple example of the issue.\njs\nvar a = 1;\nUser.find(1).then(function() {\n  a++;\n  a === 3; // should always be 3, in the case of PromiseKit, this would depend on data locality\n});\na++;\na === 2; // should always be one, but in case of PromiseKit, it would depend on data locality\nTypically the only constraint is, information cannot be extracted from a promise (regardless of data locality) until the next clean frame.\nFeel free to ping me on gtalk: stefan.penner@gmail.com or irc: iamstef \nAlso, feel free to pop by #promises on freenode.\nI would love to help you get this implementation aligned with a+ (as it advertises)\n. @mxcl is their interest in conforming to the spec?\n. @mxcl :+1: , if you have further questions let me know.\n. This is a bug, nil is a valid fulfillment, and rejection value.\nFor example, the asynchronous task is done, but we have nothing to report.\n. 0 should also be a valid fulfillment (or reject), I do not believe this works. Although this could be the lack of objective-c foo\n. This issue then may be an objective-c'ism which would be fine.\ncan you fulfill with a NO ?\nI still recommend tracking the state in a separate slot, which you will need to to handle fulfilling with errors.\n. Sounds good. I think this issue is not applicable to this platform\n. Rigid adherence.\n. https://github.com/domenic/promises-unwrapping#promise-resolve-functions\n. @mxcl it is, and is actually a very important \"state\".\nA small window exists, where a promises fate is sealed, but no yet available for observation. Although the this may be a slight implementation detail.\n. @mxcl ya sealed can be used as, its fate is known. But we either don't care, or don't know what that fate is yet.\n. This is still a valid issue, it should not yet be closed\n. No, sorry my fault. My phone didn't show the diff.\nIt is strange to log, but not the end of the world.\nSG\n. @mxcl returns nothing\n. :+1:\nthoughts on renaming (aliasing) when -> all ?\n. @mxcl all as an alias would be great, as it is now shipping in Firefox and Chrome (and all other browsers, as they implement es6).\n. ",
    "nikolaykasyanov": "This part of the spec probably makes sense on server-side, but it breaks some scenarios in UI code. For example, your API client class can have the following method:\nobjc\n- (Promise *)loadPhotoForUser:(User *)user\nIt checks local in-memory cache and returns resolved promise if there's a matching image, otherwise network request is performed and promise resolved/rejected accordingly.\nYour client code may look like:\nobjc\nPromise *userPhoto = [[client loadPhotoForUser:me] then:^(UIImage *photo) {\n    self.imageView = photo;\n}];\nThe point is, if -then: is always async, image from in-memory cache will hit image view only on the next run loop iteration, and user may notice flickering.\nReactiveCocoa's signals, for example, could be completely synchronous and I haven't noticed any Zalgo, just FYI.\n. @mxcl legacy-1.x branch doesn't though.\nA similar code fragment in master uses id promises, hence no compilation error.\nEDIT: wording.. @mxcl thanks! Sorry for confusion.. @mxcl would you be so kind to push 1.7.6 to CocoaPods?. ",
    "myell0w": "By using NSProgress (http://oleb.net/blog/2014/03/nsprogress/) the progress-reporting can be decoupled from PromiseKit entirely.\n. ",
    "inf0rmer": "NSProgress looks sweet, but I noticed it's been introduced in iOS7. I think that, for now at least, iOS6 compatibility is desired, no?\n. Ah yes, this was my exact backup strategy :). For future progress functionality I also think NSProgress is a good fit. Thank you!\n. ",
    "couchdeveloper": "I fear you underestimate the issue: strictly, with a C (and Objective-C) compiler, if you access the same data without synchronization from more than one thread where at least one thread is modifying the data you get a \"data race\".  The C11 standard permits to exhibit any behavior in this case. This isn't a good thing, though - it effectively means \"undefined behavior\".\nIn practice that might mean for example, that whenever you access ivar result you might get an invalid pointer value (well, that depends on the hardware whether pointer modifications are atomic or not, though). Or you might get a stale value (that is nil), where the actually value has been already changed by the resolver executing on another thread some time ago - the actual value is just not visible to the current thread. It's quite obvious, that you have to fix that in the code, otherwise all bets are off what you get as the result. You will need to use correct memory barriers or other synchronization techniques which guarantee that read accesses will retrieve the actual values.\nI would state the assertion, that for the usual usage scenarios utilizing promises, the implementation requires to be thread-safe, in all aspects.\n. First-off: I believe the current approach using GCD is preferable to using any other synchronization primitives available from Cocoa or pthread. I also think the implementation is well done - with one potential issue (see below).\nHowever:\n\nSomething I did consider, but didn't pursue, is that once a promise transitions from the read-write state into a read-only state (after it's been resolved), it may be possible to have it no longer use the queue for reads. \n\nThis is not a good idea. In fact you still require the queue - otherwise the implementation is not thread-safe anymore: Suppose, thread A has written the value with either fulfilling or rejecting it. Now, when any other thread (say thread B) will read the value without synchronization primitives a data race will occur, no matter what. What actually might happen is, that the value written in thread A is not visible in thread B - that is result might be still nil in thread B. Using dispatch queues will utilize suitable memory barriers which prevent this.\nAnother potential improvement is to use a global synchronization queue - instead a sync queue per instance. Contention is likely never a problem. Even when contention is high, dispatch lib is designed in a way to perform exceptional well in this conditions (well, due to using \"queues\"). The code that will be executed in this \"critical section\" is minuscule as well.\nUsing a global sync queue will also solve the potential issue mentioned above:\nCurrently, the \"sync queue\" is an ivar of the object. Having a pointer to a promise object, accessing this queue is not thread-safe (cannot be). This may cause a data race, if the promise will be created in thread A, and the pointer is passed through to another thread B. Since promises are used in arbitrary complex scenarios involving many threads, this design is strictly problematic. In order to alleviate the problem I've used a global sync queue (dispatch_once)  in my implementation of a promise which I consider is fully thread-safe. It also has the advantage that two promises can be synchronized with respect to each other - e.g. when one promise \"adopts the state\" of another.\n. The term \"immutability\" as you denote an initially resolved promise isn't the right criteria to judge whether we need synchronization primitives or not. When creating an object (any object), the system first allocates raw storage with a certain size which has been zero initialized and returns a pointer to it. When initializing an ivar to any value which differs from the zero initialized storage, then we already modify this object. When we then pass along the object to another thread which already existed when the object has been created, we risk a data race when accessing ivars from the other thread.\nThat is, in order to prevent a data race when accessing ivars, we need to utilize memory barriers, for example using a dedicated dispatch queue. And this dedicated dispatch queue must be used for all read and all write accesses to any ivar (strictly also including the \"sync queue\", which is impossible with this design though). It isn't sufficient that the promise appears to be fully initialized when looking from thread A to it: in any other thread, the modified values may not be visible.\n. @bruzenak Unfortunately, the issue isn't really that simple ;)\nFor example: \"... unless you pass the object/variable/pointer to another thread before you initialize it.\"  \nIt\u00b4s exactly that: How would you guarantee that? Actually you can't  - unless you have a CPU architecture with \"Sequential Consistency\" and a compiler that doesn't reorder or otherwise optimize your statements. But that is not going to be practicable.\nThe real thing is that the compiler can reorder your statements - albeit still being correct regarding all the language rules. Then it might happen that the other thread got this pointer before the thread that should initialize the object was able to set the ivars. And even if initializing happened before the other thread would start reading the ivars, there is no guarantee that the changes are visible in the other thread, due to relaxed Cache Coherency rules implemented in silicon on the CPU. \nYou might read more about \"Memory Consistency\", \"Cache Coherency\", and the allowed optimizations a C compiler can apply to your code (that is, statement reordering, etc.)  in the Web.\n. > Could be the deinit which we don\u2019t guard access to because it doesn't matter. \nThere can  be an issue where deinit causes a conflict (aka data race) with a previous write operation executed on a different thread for the same memory location.\nIf this is not a false positive, but a true data race, it actually matters. It may lead to additional race conditions and eventually lead to undefined behaviour.\nThat \"can\" depends entirely how the Swift compiler generates the code for deinit. If there are proper memory barriers set which synchronises with any store operation (I doubt, this is the case), then it is OK and ThreadSanitizer would unlikely find a false positive.\nUnfortunately, there's nothing we can do to fix a race in deinit easily: it is generated by the compiler. \n. Well, after looking into the sample provided by @antiraum  - the good message is, that it's not occurring in deinit.  ;)   And, by the way - it might not help to remove custom code in deinit if the compiler would generate the access to the memory location which causes a data race. In this deinit the compiler needs to destroy an enum - and it at least needs to read the \"tag\" which determines the current type and value in the enum. It then might invoke a destroy function for the current value, if required by type. So, if there were a data race in this access, the design of the class would need to be changed (there's a workaround for this).\nThe data race occurs here:\npublic func then<U>(on q: DispatchQueue = .default, execute body: @escaping (T) throws -> Promise<U>) -> Promise<U> {\n        var rv: Promise<U>!\n        rv = Promise<U> { resolve in   // <== write value `rv`\n            state.then(on: q, else: resolve) { value in\n                let promise = try body(value)\n                guard promise !== rv else { throw PMKError.returnedSelf }  // <== read value `rv`\n                promise.state.pipe(resolve)\n            }\n        }\n        return rv\n    }\nThreadSanitizer thinks, there's a conflict while reading and writing the variable rv.\nSince the variable (a reference) rv is declared var and imported into an escaping closure  the compiler allocates a helper struct on the heap and copies the reference rv to it and then, subsequent accesses to rv actually access the copy in the helper struct.\nSo, TS seems to think, that the assignment of rv (outside the closure) and the read access within the closure on a memory location allocated on the heap in the helper struct is not synchronised.\nI am not that profoundly into details of block copy helpers generated by the compiler, so honestly, I don't know for sure if this is a false positive. But looking at the direction Swift is planing to go regarding concurrency, and the current state of concurrency, I tend to say, that a synchronisation is very likely not applied - and if so, only by accident and not the proper one. (A sound solution would require, that the helper struct acts like a wrapper and  guards accesses with appropriate memory barriers. This helper struct would then also be returned as the function result, not just the reference itself.)\nSo, TS is probably right. Of course, that would mean, that any construct importing a var value into an escaping closure would be a potential data race. \nThere's no such issue with let values, though.\n. A possible fix:\nEDIT:  Does not work!!\nThe value of the captured variable rv will be evaluated before the constructor Promise initialises it - that is, it equals nil in the closure. Too bad. What we need is probably a separate call to the constructor and a member function that registers the continuation with then - instead of merging everything in one statement.\n\nLooking more closely, I figured, that within the closure registered with then, a modifiable rv isn't required. So, a constant - aka let would do the trick:\npublic func then<U>(on q: DispatchQueue = .default, execute body: @escaping (T) throws -> Promise<U>) -> Promise<U> {\n        var rv: Promise<U>!\n        rv = Promise<U> { resolve in   // <== write value `rv`\n            state.then(on: q, else: resolve) { [rv] value in\n                let promise = try body(value)\n                guard promise !== rv else { throw PMKError.returnedSelf }  // <== read value `rv`\n                promise.state.pipe(resolve)\n            }\n        }\n        return rv\n    }\nNote the explicit capture list, e.g. [rv] which captures rv as a \"value\" (that is, it will be imported directly as a const reference, without going through the helper struct allocated on the heap.\nMaybe, @antiraum can try this out and check if the data race disappears?\nIf this helps, I would suggest to find similar patterns in the sources and change these accordingly. \n\nhave fun\n. Yes, this change (capture rv as a const) should fix it.\nNote: We still require memory barriers that synchronises with the two operations: writing to the imported copy of rv executed in thread A and reading from it in thread B when the closure executes, where A != B. When dispatching to a dispatch queue, dispatch lib will take care of this.\nOf course, all accesses to a promise's members must be synchronised as well - which I assume is the case. Importing a const reference into the closure does not solve this kind of problem.\nIMHO, it would be a good idea to enable ThreadSanitizer in Unit Tests. This may increase the detection of potential data races.\nA note to detecting data races when synchronising with dispatch lib:\nWhen using dispatch lib, the scheduler optimises the use of threads. If the total load on all CPUs and thread usage is low, it may happen that the same thread will be used (if possible), even if you dispatch in both cases to DispatchQueue.global(). So, it may happen that operations on this concurrent queue use the same thread.\nOperations on the same thread are always synchronised and ThreadSanitizer won't detect (potential) data races in this case. \nWhen the load on the CPUs will increase, and the chances increase that execution of code may block, it may then happen that the operations will be executed on different threads - which results in a data race. . > Is this necessary considering the promise itself is immutable: it\u2019s the underlying State object that mutates?\nYes, since the object will be initially mutated in the constructor. But (in all cases I known) proper memory barriers are set by the system or libraries already when you import this reference into another thread by means of certain system functions or library functions, for example dispatch_async, NSThread.detachNewThreadWithBlock, std::thread.\nOnly because of this memory barriers, when the other thread eventually executes and accesses the imported copy of this reference, it's guaranteed that the reference value itself and all their member values (and their members as well) are visible in this thread. \nSince the promise does not subsequently modify its member, a data race cannot occur for this member.\nMore subtle is the question whether the deinit applies appropriate memory barriers, so that when on  thread A the value will be destroyed all previous write operations executed on other threads became visible in thread A.\n. ",
    "tgaul": "My thread-safety changes are now available on my company's fork at: https://github.com/IdeaSwarm/PromiseKit\nIf you'd like, I can make a pull request for these changes.\nIt looks fairly involved, but the concept is pretty simple: Use a concurrent dispatch queue to control access to the ivars and use barriers when writing changes to them.\nAlso, it was necessary to handle the case where a promise is resolved between a call to the then, catch, and finally methods and the call to the block it generated.\nIn the course of making the changes, I found that the then, catch, and finally methods were all sufficiently similar that I could reduce the amount of code by putting the boilerplate into a single helper. In the course of doing this, it became useful to provide catchOn and finallyOn as the actual implementations of these to go with thenOn, so if you want to reveal those methods in Promise.h, you could add them there now.\n. Sorry, I'm not at home today, but could submit it tonight when I get back. I'm pretty sure this is better than NSLock or @synchronized, and will post more details about why when I'm not on my phone. :-)\n. Just to follow up a bit on possible performance implications of the approaches:\nThe approach to using GCD with dispatch_barrier is something I read about on Mike Ash's blog from a while back which I found when researching the synchronization options that could be used to fix this issue in PromiseKit. There's also some detail on dispatch barriers in Effective Objective-C 2.0.\nOne reason this should perform better than using @synchronized or NSLock is that it uses a concurrent queue so that there is actually no locking during simple reads. Instead, there can be multiple readers of the same promise's state happening at the same time with just the amount of overhead you normally have to perform a block on a GCD queue. When a write needs to happen, the barrier means that the write will wait for any ongoing reads to finish, and then while the write is happening, it will cause other reads to wait on the barrier until the write block is finished before they are allowed to run.\nThis actually implements a read-write lock as described here in Apple's documentation except that it's not implemented with pthreads (directly) but rather GCD (apparently this document hasn't been updated since this support was added to GCD?). As this says, a read-write lock \"can significantly improve performance if the protected data structure is read frequently and modified only occasionally\". Writes in a promise happen only when a new then, catch, or finally is added to a promise and when the promise is resolved.\nAlso, using a separate queue per promise helps to minimize contention that would occur during write operations (and reads having to wait more often on them) if they all used the same, shared, concurrent queue.\nWith @synchronized or NSLock, all reads and writes will wait for each other, causing more potential for contention. Of course, in practice this probably won't be much more overhead, but it also won't be less. NSLock probably also has a bit more overhead as it requires message dispatch.\nA double-checked lock, as noted in Apple's documentation, is potentially unsafe, so that technique is not used.\nAlso, since promises are inherently asynchronous in nature, code written in promise form is generally going to be able to handle any small amount of extra overhead that the dispatch queue usage might produce.\nSomething I did consider, but didn't pursue, is that once a promise transitions from the read-write state into a read-only state (after it's been resolved), it may be possible to have it no longer use the queue for reads. However, the only way to determine this with the current design is to read an ivar, which by definition is using shared state and needs protection. Maybe an atomically-incremented value could be used for this, however.\nThe place where it would be easiest to make this speed-up would be on a promise created with a constant value, in which case one could avoid ever creating the queue and have the reading code treat this condition (nil queue) as not needing to dispatch reads to it. But also note that in this case there will never be any barriers used on the queue, so all this saves you is the small amount of queue dispatch overhead and it would make the code somewhat more complicated. (If you want me to pursue this addition, though, I think I could implement it fairly quickly.)\n. As you note, once you create an object that needs to use a queue (or other means) for synchronization because it's not immutable, you have to always use this mechanism, as access to the internal state (or even the queue if it might change) without going through some common synchronization will make it be thread-unsafe.\nThis is why I think the easiest safe change is to make the always-immutable version of a promise (created via promiseWithValue:) not need to use a queue.\nAs for your contention that it's a problem that the queue is an ivar of the object at all: I don't agree with that. What's required is that the object get fully initialized before it is passed to any code that can call it on another thread or queue (and that the queue ivar is never mutated after init, which as you noted above is a change that would make it unsafe).\nIn the case of PMKPromise, that's handled by the new: and promiseWithValue: class methods. Those run on a single calling thread/queue, and only after the object is returned to the caller can something occur that causes calls to this object to happen on different queues. By this time, the object is fully initialized and the queue ivar will no longer be mutated.\n. From my reading of the PromiseKit.m code, I think what is at play here is a multi-thread (or multi-async queue in this case) problem. The Promise class doesn't synchronize access to the handlers and result ivars, and that leads to this crash when conditions are just right.\nWhere does this present a problem? Consider that you have a promise you create from code on the main queue by using dispatch_promise. Now, after creating this promise, someone on the main queue calls .then on that promise. In the course of this, .thenOn checks to see if the promise is resolved (and it's not yet). Then it calls addObject: on the handlers block.\nNow, let's say that the main thread is pre-empted at this point (inside the call to addObject:), and then the promise's (default) queue is scheduled and calls the fulfiller block. This block calls all the handlers (but note that addObject: hadn't yet gotten to the point where the new handler is in the array \u2014 it was preempted before that could happen) and sets this->handlers to nil, which since it was the only reference to the array causes the array to be deallocated.\nNow execution continues on the main thread where it is inside the addObject: call to a now-deallocated NSMutableArray object, so you get the access violation seen in this issue when the innards are accessed by addObject:.\nIn order to fix this, access to the state in the promise needs to be synchronized across the threads/queues in some way. One way would be to use @synchronized in the right places. Another would be to make sure all access/editing of the state of the promise were performed on the same queue (which should be enforced by the code in PromiseKit.m in such a way that the client code doesn't need to know the rules, as I assume you want to continue to allow client code to call the fulfiller and rejecter blocks from arbitrary queues/threads).\n. FWIW, I've been working on some changes to PromiseKit.m in my project to add thread safety.\nMy approach uses a per-promise concurrent dispatch queue, moves all reading of the ivars into dispatch_sync blocks on that queue, and puts the writing of the result and handlers (and reading of the result when it might need to add a handler) into dispatch_barrier_sync.\nIf you're interested, I could port my changes to the latest version of PromiseKit (the project I did it in is using a somewhat older version) and put it up as a fork on GitHub for you to look at. I'm not convinced it's 100% correct yet, but I think it's a start of one possible way to handle this.\n. I added a note to #33, but thought I should mention it here. My thread-safety changes are available in my company's fork at https://github.com/IdeaSwarm/PromiseKit.\nI've found they fix this crash, which I could reproduce fairly easily in an app we're working on.\n. Ah, didn't consider that A+ might specify this behavior. It's not a huge issue (returning the error is easy), just something I thought might surprise people. I'm fine with whatever call you make on it.\n. I think it's fine the way it is. It's easy enough to return the error in the catch block. You probably do, however, want to make sure the documentation for catch (especially) and then indicate that they will resolve as a non-error nil for any chained code if there's no return at the end.\n. In the presence of proper cancelation support in PromiseKit, you likely want to add an on-cancel handler that can be chained like the then and catch handlers.\nThe question then is whether it's possible to return from a cancelation handler with a value which, if an error, would call the next catch handler and if not, would call the next then. Of course, in that case, you probably would want the lack of a return with a value to chain to the next cancel handler.\nI'd think that you'd probably want this capability in the presence of such a feature.\nAs for your example, today the code you wrote would call the next then handler with a nil value in the case of a cancel error. There's no way to skip the then handler unless you return the error (and allow the cancel error to propagate up to callers, who will have to know to look for it).\n. Will look into it, when I get out from under deadline. You want a PR only for 2.0, or also 1.6? (Also, congrats on the new \"situation\", if it's what it looks to be.)\n. ",
    "bruzenak": "I believe you may be misunderstanding how Objective-C/C manages memory. Each thread doesn't get its own view of a variable. A pointer to memory is just that, a pointer to a region of memory. That pointer denotes the same memory, regardless of which thread you're on. You need to worry about changes to that region of memory with respect to the control flow of a particular thread, but you DO NOT need to worry about the value not being properly initialized unless you pass the object/variable/pointer to another thread before you initialize it. \nIn the case of Troy's changes, the queue is never modified after it is initialized, nor is it modified after it leaves the thread, so it's inherently thread safe for reading except in the case that the variable is being actively changed.\n. Fascinating. My old days as a higher level language engineer are showing. However, based on some research (and practical knowledge of the runtime), I'm not sure this isn't just a theoretical problem on modern ARM processors. My initial reading into the subject implies that the combination of LLVM and modern iOS CPUs has made this a reasonably solved problem provided you stick with the higher level APIs (like GCD). Of course, I could be wrong, but I wouldn't really worry about this until I saw a reproducible case on a modern code base.\nIn particular, I'm basing this premise on the fact that modern Apple iPhone CPUs with dual cores do support snooping: \nhttp://infocenter.arm.com/help/index.jsptopic=/com.arm.doc.ddi0407e/CDDEHDDG.html\n. ",
    "gonzalezreal": "Great, thanks!\n. Yep, now it works. Thanks for fixing it so quickly!\n. ",
    "MaximusMcCann": "All good. Nice to see the active upkeep. Cheers\n. Solid\n. check PromiseKit+Foundation.m Line 56 \nreturn [self promise:[OMGHTTPURLRQ POST:url :payload filename:name]];\nthat method is not in the current master of OMGHTTPURLRQ\n. Cool.  Using a static lib here, no Cocoapods for PromiseKit, so that got me.\n. Cheers \n\n. Can still repeat.  Sometimes I would like to just return the promise and have 'then' continue.  \nExample:\n[StaticClass promiseMethod].catch(//error stuff).finally(//show screen no matter what);\n//StaticClass\n+promiseMethod {\nif(YES) { // T/F statement\n   return [StaticClass otherPromiseMethod]; // load conditional data\n} else {\n   return dispatch_promise(^{ return; }); // no data to load\n   // just want it to return the promise as nothing is needed to load\n   // essentially a 'continue' here\n}\nis there a better way to just have the promise return?\nCheers\n. Appears to have done it @djtarazona.  Cheers.  Prior attempts with [Promise new] had failed.\n. The following setup, I believe my return dispatch_promise(^{ return; }); issue was Not the actual issue and was solved via the block() add to the final statement.\nWhat I've found:\n[StaticClass promiseMethod].catch(//error stuff).finally(//show screen no matter what);\n+promiseMethod {\nif(YES) { // T/F statement\n   return [StaticClass otherPromiseMethod]; // load conditional data\n} else {\nreturn dispatch_promise(^{ return; }); //works\nreturn [Promise promiseWithValue:nil];  //works\nreturn [Promise new]; //does not work (hangs)\n}\n. Cheers\n. Correct, am not using CocoaPods.  PK is in a static library\n. Appreciate the help.  Overlooked the simple answer. Cheers\n. Saw that, cheers.  PK is awesome. Keep up the good work.\n. Wanting both OMGHTTP.. and PK I created both via the pod packager as frameworks.  I have some categories for NSURLConnection dependent on OMG.  However I receive a duplicate symbol error since PK includes OMG.  Ideally, I think I should be able to access OMG if PK framework is installed and not need to put it in there twice.  Tried using their --no-mangle and --embedded options, but still can't figure out how to import the OMG symbols via the PK framework. Thoughts?\n. ",
    "josejulio": "Also, sorry but by inexperience made it all on one bulk instead of two or three smaller pull requests. (as will be on next time)\n. 1. Yes, absolutely, I'm unfamiliar with pods, but i'll dig what needs to be done for it.\n2. Yes please, provide me some basic guide and I'll clean the PR.\n. I'll need something like this, and will implement myself, so if you have any suggestion on what could be tweaked would be great to know.\n. Thanks, I will consider that.\n. We added CALayer promise when animation finishes, but i'm not proficient with cocoapods, is the podspec ok? Or should i remove the podspec changes from this pull request?\n. Pushed the commit with new manifold order reversed, thanks.\n. @DrAma999 could you provide your race implementation? (it is not provided above). Whops, sorry, I guess that i'll discard some changes and repack them into another pull request.\n. Thanks, i reverted the commit.\n. You are right, i missed that.\n. ",
    "maml": "Howdy! Re: renaming to +AVFoundation, sounds good to me.\n. ",
    "dlg": "Thanks Max--that almost certainly explains it: It goes out of scope at the end of the function it was created in.  I assumed that it held onto itself until the chain was done.\n. Hmm, maybe a [Promise newHoldsReference] that lets you specify that you want it to hold a reference to itself?\n. I had\nobjc\nPMKPromise *startupChain = dispatch_promise(^{/*stuff*/}).then(/*stuff*/).etc\nI added\nobjc\nstartupChain.then(^{\n    [startupChain description];  //Hack to force promise chain to hold on to itself. \n});\nAnd I still got\nThread 0 Crashed:\n0   libobjc.A.dylib                      0x39b4e626 objc_msgSend + 6\n1   Treasure                             0x00247dcb __19-[PMKPromise catch]_block_invoke62 (PromiseKit.m:214)\n2   Treasure                             0x00035f07 -[TrAppDelegate applicationWillEnterForeground:] (TrAppDelegate.m:327)\nI assume that would have gotten it to hold on to itself.  Any ideas?\nThanks so much!\n. Will do.\nThis promise chain is started during -applicationWillEnterForeground\u2014it's my only big chain so far.  When the app comes out of background, there are a tons of different things I want it to do.  Initially I was firing off a lot of threads in parallel, but it would sometimes get killed for memory usage when I had lots of apps running.  So I looked at serial queues but there are http requests and dependencies, so it looked like it'd be messy.  Hence why I'm using promisekit.\n. Alas, not thus far.  I added the call to the last .then() that just does a [self description];.  What what I can tell the problem count dropped but I'm still sometimes seeing the problem in the wild.\n. Thank you both.  I assume starting with with [PMKPromise new:^...] is ok?\nAlso, I wrote RKRestKit+PMKPromiseKit (which I plan to open source).  RestKit I think calls back to its completion block on another thread.  Does I need to ensure it calls fulfiller() from the same thread the promise was started from?\nReally appreciate it\n. I haven't tried @tgaul 's branch, but getting rid of the dispatch_promise() + the other suggestions from @mxcl seem to have solved my crashes.  At least, I haven't yet seen that crash again among our tiny group of testers.  Thank you both.\n. ",
    "schazers": "Awesome, thanks :]\n. ",
    "ethanmick": "Is the main way you expect promises to be created is through [Promise new:]? Which does run on the main thread.\n. Alright, that sounds good. I'll change how my promises start. Thank you!\n. ",
    "scriptease": "Thanks, i will think about it.\nNever heard of zalgo a good read when you google it :-)\n. ",
    "hariseldon78": "sorry, i cannot see how this is a compiler issue. There are 3 forms of catch:\n(0) public func catch(onQueue:dispatch_queue_t = dispatch_get_main_queue(), body:(NSError) -> T) -> Promise<T> \n(1) public func catch(onQueue:dispatch_queue_t = dispatch_get_main_queue(), body:(NSError) -> Void) -> Void \n(2) public func catch(onQueue q:dispatch_queue_t = dispatch_get_main_queue(), body:(NSError) -> Promise<T>) -> Promise<T>\nIf T==Void, and you don't capture the result of catch, there is no possibility for the compiler to infer what is the desired version of the function (choosing between 0 and 1), they both have the same signature, apart from the return type.\nBased on this principle i found a better workaround:\nlet _:Void=promise1.catch { (e:NSError) -> Void in\n    [...]\n}\n. thanks to you for the framework, it's very useful!\nIl venerd\u00ec 12 settembre 2014, Max Howell notifications@github.com ha\nscritto:\n\nThanks, and good thinking.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mxcl/PromiseKit/pull/82#issuecomment-55442352.\n\n\nroby\n. i have the same problem with the CoreAudio library: \ndyld: Library not loaded: @rpath/libswiftCoreAudio.dylib\n  Referenced from: /Users/robertoprevidi/Developer/moving-circles/Build/Products/Debug-iphonesimulator/PromiseKit.framework/PromiseKit\n  Reason: image not found\n. ",
    "coppercash": "Hi, I maintain my own promise lib and involved into a similar Promise<Void> problem. I believe I found a way out.\nI have 2 kinds of catch at this line and this line. I give the closure of the first one a forced name ignored. Because if you return Void, it means you give up to save the situation from an error.\nFor Promise<NotVoid>, all the catch can be called with a trail closure. There is no necessary to show the name ignored:\n- Promise returns Void in catch with trail closure\n- Promise returns String in catch with trail closure\nFor Promise<Void>, you need to offer the name ignored to differentiate the special catch from the others:\n- Promise returns Void in catch with name ignored\nThe only loss is no trail closure available when Promise<Void> catch Void. \n. ",
    "paztis": "The catch signature is strange\nswift\n(0) public func catch(body:(NSError) -> T) -> Promise<T> \n(1) public func catch(body:(NSError) -> Void) -> Void \n(2) public func catch(body:(NSError) -> Promise<T>) -> Promise<T>\nA catch must always return a new Promise, otherwise we can not chain new promises:\nswift\npromiseA.then { result -> T in\n ...\n}.catch { error in\n ...\n}.then {\n ...\n}\nSo the signature may be\nswift\n(0) public func catch(body:(NSError) -> T) -> Promise<T> \n(1) public func catch(body:(NSError) -> Void) -> Promise<Void>\n(2) public func catch(body:(NSError) -> Promise<T>) -> Promise<T>\n. ",
    "allen-zeng": "IMO this is definitely a compiler issue.\nGiven the function signatures as they currently are:\n[0] func catch(onQueue q:dispatch_queue_t = dispatch_get_main_queue(), body:(NSError) -> T) -> Promise<T>\n[1] func catch(onQueue q:dispatch_queue_t = dispatch_get_main_queue(), body:(NSError) -> Void) -> Void\nWhat the compiler should be able to see is the fact that there is a specialized implementation of catch, i.e. 1, and use that implementation instead unless there is another constraint that invalidates that selection, e.g.\n// the compiler should pick implementation 0 in this case\nlet p: Promise<Void> = promiseA.catch {\n    error -> Void in\n    ...\n}\nOtherwise the implication is a generic implementation without very specific constraints always gets picked over its specialized counterpart.\n. Ah of course! My bad for not understanding the syntax properly. Hope you enjoyed your holiday, thanks for your help!\n. There was a bit of weirdness going on with that particular setting. I still don't quite understand it but this doesn't appear to be needed.\n. No thank you for all the awesome work! :)\nInteresting point on line 44, is it because that it isn't related to the pull request or is it because there is a specific coding style that you'd like to see?\n. :+1:\n. I'm assuming breaking changes in API doesn't really matter? This was the main reason why I didn't change more.\nI don't see the need for func ABAddressBookRequestAccess() -> Promise<ABAuthorizationStatus> so I think removing that is probably a good idea.\nYou're right about needing to check for NSError but I also rather like the fact that I can get a reject reason within recover. I suppose in this particular case one could just call ABAddressBookGetAuthorizationStatus() within the recover so it doesn't really matter too much.\n. Either way it looks like this change isn't the way to go. Closing.\n. If you're using Cocoapods, and not using anything in the subspec PromiseKit/Foundation, a less hacky solution (not deleting files, changing repo etc.) is to split up the pods in your Podfile:\n``` ruby\npod 'PromiseKit/CorePromise'\npod 'PromiseKit/UIKit'\netc.\n```\n. Hmm ok, the failed check seemed to have stalled, is there a way to rerun it?\n. Thanks for getting on top of this so quickly!\n. I'm assuming we are following semantic versioning? I do wonder whether this constitutes a minor version bump though. The behaviour has changed, if only subtly.\n. The setting is NO, but changing it to YES doesn't make a difference.\nI'm able to build PromiseKit project by itself as well, just not when it's imported as a pod\n. That's the one thing I haven't tried. Will give that a go and report back.\n. Yeah CocoaPods 1.0.1 fixes the problem! I'll close this.\n. Yeah that part is easy enough. I can't create a pull request into a tag though, so we'll have to have a branch created where 3.5.1 is. I'll create the pull request then\n. Looks like Travis timed out. What do I need to do?\n. Still no luck. I wonder why :/\n. Great! What takes care of releasing 3.5.2 to cocoa pods?\n. Good point. I've added the label back in. The parameter name is still fulfillmentType, so that it reads more nicely when used.\n. ",
    "pgherveou": "just noticed that in swift 1.2 you can not do that anymore \n``` swift\n    let p = Promise(value: true)\n    let onError = { (error: NSError) -> Void in\n      println(\"handle some error\")\n    }\nlet _: () = p.then { (_) -> Void in\n  println(\" I made it! \")\n  }.catch(onError)\n\n```\nyou have to write it this way\n``` swift\n    let p = Promise(value: true)\n    let onError = { (error: NSError) -> Void in\n      println(\"handle some error\")\n    }\nlet _: () = p.then { (_) -> Void in\n  println(\" I made it! \")\n  }.catch(onQueue: dispatch_get_main_queue(), body: onError)\n\n```\ncalling a closure directly work though\n``` swift\nyou have to write it this wayswift\n    let p = Promise(value: true)\nlet _: () = p.then { (_) -> Void in\n  println(\" I made it! \")\n  }.catch  { (error: NSError) -> Void in\n  println(\"handle some error\")\n}\n\n``````\n. cool that works thks for the tips\nOn Thu, Apr 9, 2015 at 3:22 PM, Max Howell notifications@github.com wrote:\n\nlet _: () = p.then { _ -> Void in\n      println(\" I made it! \")\n}.catch(body: onError)\nis enough.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/56#issuecomment-91230274.\n\n\n\nPG\n. I get a warning now when compiling, is this related?\n```\nLd /Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Products/Debug-iphonesimulator/PromiseKit.framework/PromiseKit normal x86_64\n    cd /Users/pg/Jogabo/app-v2/ios-app/PromiseKit/swift\n    export IPHONEOS_DEPLOYMENT_TARGET=7.1\n    export PATH=\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch x86_64 -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk -L/Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Products/Debug-iphonesimulator -F/Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Products/Debug-iphonesimulator -filelist /Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKit.build/Objects-normal/x86_64/PromiseKit.LinkFileList -install_name @rpath/PromiseKit.framework/PromiseKit -Xlinker -rpath -Xlinker @executable_path/Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -Xlinker -objc_abi_version -Xlinker 2 -fapplication-extension -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator -Xlinker -force_load -Xlinker /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_iphonesimulator.a -Xlinker -add_ast_path -Xlinker /Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKit.build/Objects-normal/x86_64/PromiseKit.swiftmodule -fobjc-arc -fobjc-link-runtime -Xlinker -no_implicit_dylibs -mios-simulator-version-min=7.1 -single_module -compatibility_version 1 -current_version 1 -Xlinker -dependency_info -Xlinker /Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKit.build/Objects-normal/x86_64/PromiseKit_dependency_info.dat -o /Users/pg/Library/Developer/Xcode/DerivedData/Jogabo-fhrfmmlapzdgnseyyatthkyulkde/Build/Products/Debug-iphonesimulator/PromiseKit.framework/PromiseKit\nld: warning: embedded dylibs/frameworks only run on iOS 8 or later\n```\n. that sucks :(\n. Can you set a variable in the deployment target field so it use the projects value?\n. That would be great, unless you see another work around?\n. Cool thanks!\nCan you details the manip described here http://promisekit.org/getting-started/#integrating-by-hand\nI am not sure which command to run to generate the static library\nI wish we could just use cocoapod but it does not seem to work cause we are using AWS SDK which does not support yet the latest version of cocoapod.\n. So I cloned, opened the project and built\nit complained that OMGHTTPURLRQ was missing\nI ran carthage update to add the dependency and rebuilt\nit failed with\nwarning: directory not found for option '-F/Users/mxcl/src/PromiseKit/Carthage/Build/iOS'\nI removed it from it from the framework search path \nnow it seems to work better but I get the following errors \n```\nCompileSwift normal x86_64 /Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.2.3.swift\n    cd /Users/pg/Github/PromiseKit\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.1.2.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.1.3.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.2.2.swift\" -primary-file \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.2.3.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.2.4.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.2.6.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.3.2.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.3.3.swift\" \"/Users/pg/Github/PromiseKit/Specs/Promises:A+ Specs/2.3.4.swift\" /Users/pg/Github/PromiseKit/Specs/test-utils.swift /Users/pg/Github/PromiseKit/Specs/Promise.test.swift /Users/pg/Github/PromiseKit/Specs/NSURLConnection+Promise.test.swift -target x86_64-apple-ios8.0 -target-cpu core2 -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk -I /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Products/Debug-iphonesimulator -F /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Products/Debug-iphonesimulator -F /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk/Developer/Library/Frameworks -F /Users/mxcl/src/PromiseKit/Carthage/Build/iOS -F /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Frameworks -F /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk/Developer/Library/Frameworks -g -module-cache-path /Users/pg/Library/Developer/Xcode/DerivedData/ModuleCache -Xcc -I/Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/PromiseKitTests-generated-files.hmap -Xcc -I/Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/PromiseKitTests-own-target-headers.hmap -Xcc -I/Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/PromiseKitTests-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/PromiseKitTests-project-headers.hmap -Xcc -I/Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Products/Debug-iphonesimulator/include -Xcc -I/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include -Xcc -I/Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/DerivedSources/x86_64 -Xcc -I/Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/DerivedSources -Xcc -DDEBUG=1 -Xcc -DDEBUG=1 -emit-module-doc-path /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/Objects-normal/x86_64/2.2.3~partial.swiftdoc -Onone -module-name PromiseKitTests -emit-module-path /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/Objects-normal/x86_64/2.2.3~partial.swiftmodule -serialize-diagnostics-path /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/Objects-normal/x86_64/2.2.3.dia -emit-dependencies-path /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/Objects-normal/x86_64/2.2.3.d -o /Users/pg/Library/Developer/Xcode/DerivedData/PromiseKit-ddiuqrexnqwbmibowarhoclcxeqb/Build/Intermediates/PromiseKit.build/Debug-iphonesimulator/PromiseKitTests.build/Objects-normal/x86_64/2.2.3.o\n/Users/pg/Github/PromiseKit/Swift Sources/PromiseKit.h:11:9: error: module 'OMGHTTPURLRQ' not found\n@import OMGHTTPURLRQ;\n        ^\n:0: error: could not build Objective-C module 'PromiseKit'\n```\nIf I remove the Test Target then the project build without errors\n. Thanks it works!, quick question though\nif I clone and build the binary, does it build an universal binary that will works on simulator and devices? \nIf not I guess it safer to create a submodule and drop the xcodeproj as you suggested\n. @mxcl it seems that the build is failing again after XCode upgrade \nit seems that only the OSX build is failing \nFWI here is the log report\n```\n Fetching PromiseKit\n Fetching OMGHTTPURLRQ\n Downloading OMGHTTPURLRQ at \"2.1.3\"\n Checking out PromiseKit at \"1.5.0\"\n xcodebuild output can be found in /var/folders/yt/8jvhqpp51m364c10xc19ltfm0000gn/T/carthage-xcodebuild.OFFl2v.log\n Building scheme \"PMKiOS\" in PromiseKit.xcodeproj\n Building scheme \"PMKOSX\" in PromiseKit.xcodeproj\n2015-04-09 10:58:34.648 xcodebuild[11938:124248] [MT] PluginLoading: Required plug-in compatibility UUID 9F75337B-21B4-4ADC-B558-F9CADF7073A7 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin' not present in DVTPlugInCompatibilityUUIDs\n* BUILD FAILED \nThe following build commands failed:\n    CompileSwift normal x86_64 /Users/pg/Sandbox/TestPromiseKit/Carthage/Checkouts/PromiseKit/Swift Sources/NSTask+Promise.swift\n    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler\n(2 failures)\n```\n. thks @mxcl actually I was just using the IOS binary so I was fine, but just wanted to let you know\n. shouldn't we do the same for the cartfile?\nright now its specifying github \"mxcl/OMGHTTPURLRQ\" >= 2.1.3\nbut this cause the 3.x to be downloaded by default and this break the NSURLConnection + Promise extension\n. you already merged, you still want me to change code indent and change region to inRegion?\n. Sorry about this @mxcl, I was not connected when you replied \nbut I was ready to do it, you were just too fast for me on this one\n. Yes thats what I thought too, but It didn't go through all the promises even though the condition flags where set to true,  instead it when straight to the last one\n. Thks Max i will try to reproduce the test case and see why it was not working for me\nSent from my iPhone\n\nOn Jul 18, 2015, at 9:30 AM, Max Howell notifications@github.com wrote:\nI made this test case:\nhttps://github.com/mxcl/TestCase-223\nHere's the example output:\nThe test case was made with Xcode 7, but could be adapted to Xcode 6.\n\u2014\nReply to this email directly or view it on GitHub.\n. THks for the test case, Couldnt reproduce the bug, closing for now I let you know if I find anything\n. oups bad commit, sorry about that resubmitting\n. fixing https://github.com/mxcl/PromiseKit/issues/241 ...\n. I think I was having issue running this code in the simulator, but it might be cleaner to remove the delay and wait for a new event\n. Oups ok doing it now\nI am using carthage so no need to push anything i will use the commit id until next version\n\nSent from my iPhone\n\nOn Jun 30, 2015, at 12:08 PM, Max Howell notifications@github.com wrote:\nIn Categories/CoreLocation/CLGeocoder+Promise.swift:\n\n@@ -35,6 +35,15 @@ extension CLGeocoder {\n             }\n         }\n     }\n- \n-  public func geocode(addressString: String, region: CLRegion) -> Promise<[CLPlacemark]> {\n  Should be CLRegion? if mirroring the underlying API.\n\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "tkqubo": "I have this workaround so far:\nswift\nextension Promise {\n    func then(body: T -> Void) -> Promise<Void!> {\n        return then { result -> Void! in\n            body(result)\n            return ()\n        }\n    }\n}\nthen the code below will compile:\n``` swift\nclass SomeClass {\n    func somePromiseFunc() -> Promise {\n        return Promise { (fulfill, _) in\n            fulfill(42)\n        }\n    }\nfunc someFunc() {\n    somePromiseFunc()\n        .then { result in\n            println(result)\n        }\n        .catch { error in\n            println(error)\n        }\n}\n\n}\n```\n. ",
    "ivanovvitaly": "@tkQubo your extension works for me in following way. Thanks!\npromiseFunction()\n            .then { result in\n                // code here\n            }\n            .catch { error -> Void in // can't compile for me without -> Void\n                // code here\n            }\n. Right, but if any promise fails, the success code is not called at all. \nIs is possible to run success code in any case even if any promise fails ? (like in jquery deferred)\n. xcode version 7.0 (7A220). Attached images with errors, please let me know if its works for you.\n\n\nPlease note, that if I use following pod file, application compiles without errors and works fine. Just to remind - I use Objective C as base language and don't use any swift files, bridging headers, etc in the project.\nplatform :ios, \"8.0\"\ntarget \"MyProject\" do\n...\npod \"PromiseKit\", :git => \"https://github.com/mxcl/PromiseKit.git\", :branch => \"swift-2.0-minimal-changes\"\npod \"PromiseKit/CoreLocation\", :git => \"https://github.com/mxcl/PromiseKit.git\", :branch => \"swift-2.0-minimal-changes\"\n...\nend\nThanks!\n. ",
    "nyankichi820": "Thanks .check my code.\n\nI also approve of the mainThread assert. That's a good library addition. Though I wonder if instead we should reject the promise? (To be clear I am on the fence about this change, so have opened it for discussion).\n\nI think I ought to reject the appointment. First of all, we have included an assertion for I want you to notice in the time of implementation, but What do you think?\n. Can you please merge? Thank you\n. Thanks!\n. Thanks!\n. ",
    "tanis2000": "I think I solved it by changing my fetchData method to the following. I forgot that the database call was also running in a promise, thus the wrapping of the result:\nobj-c\n- (PMKPromise *)fetchData {\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter) {\n        id fresh = [self downloadDataFromWS];\n        [self fetchObjectsFromDb].then(^(id cached) {\n            fulfiller(PMKManifold(cached, fresh));\n        });\n    }];\n}\n. @mxcl I used that notation because I followed the example in the docs, the Cache & Fetch chapter. It shows this code:\n``` obj-c\n- (PMKPromise *)fetch {\n    return dispatch_promise(^{\n        id fresh = [NSURLConnection GET:self.fetchURL];  // start fetching ASAP\n        id cached = [NSData dataWithContentsOfFile:\u2026];  // hence dispatch_\u2026\n        return PMKManifold(cached, fresh);\n    });\n}\n\n(void)go {\n    self.fetch.then(^(NSData cachedData, PMKPromise freshData) {\n        [self updateWithData:cachedData];\n        return freshData;\n    }).then(^(NSData *freshData){\n        [self updateWithData:freshData];\n    });\n}\n```\n\nMaybe it should be updated so that other people do not make the same mistake as I did :)\nThanks for this super library btw! ;)\n. I'm using the latest version available on CocoaPods. I even tried to update it today before releasing this test version and the pod was already up to date. \nI don't know if I can help you with further details as it's not happened to me during debug runs.\n. Thanks @mxcl. I will try that this monday when I'm back in the office and I'll let you know. Cheers!\n. I've released an updated version to testers and so far there have been no crashes. Maybe that fixed it. Thanks!\n. ",
    "nunofgs": "Yes. Sorry for not replying. I see what you mean and completely agree.\nI'm now resolving with nil in those cases, as per your suggestion.\n. I'm seeing the same issue.\n\u276f pod --version\n0.35.0\n. ",
    "jackkwong": "thank you for the snippet, will try it out and report :)\n. I have tried the OMGHTTPURLRQ approach (the snippet) to get header-only response from rails 4.1.4 (head 200), it worked as expected ('then' is called and 'catch' is not called)\n. @mxcl \nwould like to try out v0.9.14.3, any way to install it using cocoapods?\nI tried \" pod 'PromiseKit', '0.9.14.3' \" but it doesn't install (Error name: Unable to satisfy the following requirement)\n. the only requirement\n\" pod 'PromiseKit', '0.9.14.3' \"\n. i used \"pod install --no-repo-update\", the flag is used because executing \"pod install\" always remain at the step \"analyzing dependency\", adding the flag prevents the problem\n. ahhh, i get it, you are right. silly me.\n. will try to pull version 0.9.14.3 and try it out\n. Yes, PromiseKit version 0.9.14.3 worked as expected ( Rails 4.1.4 is used for server btw ), it correctly does the following:\nhead 200 response -> execute 'then' and then 'finally'\nhead 500 response -> execute 'catch' and then 'finally'\n. For the sake of others' information, I solved the pod install hanging problem by executing the following commands:\npod repo remove master\npod setup\npod install\n. ",
    "ckornher": "Thanks for fixing this and all your great work!\n. ",
    "sticksen": "Thanks for pointing to the right direction. We didn\u00b4t import the umbrella header...:/\n. ",
    "ghost": "Yes. It's not official way. We can wait until the error of the compiler fixed. You can find the info of autoclosure at https://developer.apple.com/swift/blog/?id=4 \n. You're welcome. It is not a final or perfect solution. I will keep an eye on it\n. Thank you so much for the quick help, Max! :)\n. > should only appear when code signing entitlements are specified, but there are none for any of the test targets\nThe code signing entitlements are added to the PMKiOSUITestsHost target (file on disk is Tests/Entitlements.plist and, judging by the contents, appear to have been added to disable the authorization dialogs for automated UI testing(?).\n\nPerhaps it is better to simply code sign the test targets?\n\nSince I'm getting the dependency via Carthage and the build warnings appear on carthage update, I'm not sure what I would have to do to influence the signing process to work different to the way it does now. Any suggestions?\n. What I'am trying to accomplish is to remove four firebase references all at once with a single catch method. With nodeJs I would easily use:\nPromise.all ([\n  someRef.remove(),\n  someRef.remove(),\n  someRef.remove(),\n  someRef.remove()\n]).then (function({\n  //\u2026\n}).catch({\n  //handle error\n})\nwhat is the equivalent for that in swift. @mxcl Ty so much! But is there any more general solution? For example where I can specify delay and function and pass them as parameters . Thank you, that worked! It would be worth changing the readme.md, because it states to use 6.0, not the latest one. That is what I followed. Thanks again,. ",
    "mxswd": "It's not really a hack. That program is valid regardless of if recursive enums work or not, plus it is sometimes what you want to write, an enum with a function in it. Since the Api doesn't need to change when the recursive enums get fixed, I would go with this.\n. ",
    "dtrukr": "Would it possible to make the 'when' function work in Swift? I just tried to use it, but it seems the demo code has the following TODO around the when function and doesn't compile in Xcode 6.0.1:\n//TODO how to make this compile?\nThanks.\n. Sorry, I wasn't clear enough. The demo.swift file included in the project contains the following commented out code to test the when function:\n```\n        //TODO how to make this compile?\n//        Promise.when(p1, p2).then{ (hero: NSDictionary, location: CLLocation) -> () in\n//\n//            let name = hero[\"name\"] as String\n//            let home = CLLocation(latitude: hero[\"lat\"] as Double, longitude: hero[\"lon\"] as Double)\n//\n//            CLGeocoder.reverseGeocode(location).then{ (placemark: CLPlacemark) -> Void in\n//                println(\"(name) lives at (placemark).\")\n//            }\n//        }\n```\nIf I try to uncomment it and compile I'm getting the following error on the first line:\nExtra argument in call\nIs the when function still work in progress?\n. ",
    "chasseurmic": "Why did u close the issue without commenting?\n. Thanks! :thumbsup: \n. ",
    "gicappa": "Thx for the fix! Is this fix in the latest version already or will I find it in the next one?\n. Thx! :+1: \n. ",
    "Glavin001": "Yeah I thought it was strange, too. I both deleted my Derived Data (Window->Organizer->Delete.. for Derived Data) and Cleaned the Project.\n. - My current target is Streamlyne-Mac-SDK for Mac 64 bit\n- Podfile (I now have it forced to the work 0.9.14 version of PromiseKit):\n``` ruby\ntarget 'Streamlyne-iOS-SDK' do\nplatform :ios, '7.0'\npod 'AFNetworking', '~> 2.0'\npod 'MagicalRecord', '~> 2.2'\npod 'PromiseKit', '0.9.14'\n\n#post_install do |installer|\n#    installer.project.targets.each do |target|\n#        target.build_configurations.each do |config|\n#            config.build_settings['ARCHS'] = \"$(ARCHS_STANDARD_INCLUDING_64_BIT)\"\n#        end\n#    end\n#end\n\nend\ntarget 'Streamlyne-Mac-SDK' do\nplatform :osx, '10.9'\npod 'AFNetworking', '~> 2.0'\npod 'MagicalRecord', '~> 2.2'\npod 'PromiseKit', '0.9.14'\n\nend\n```\n- Building with Xcode version 5.1.1 5B1008\n- CocoaPod version 0.33.1\n- Mac OS X version 10.9.4\n. Could it be an issue with PromiseKit for Mac trying to use UIKit on the Mac?\nSee https://www.parse.com/questions/uikituikith-file-not-found-error-on-mac-os\nSo since I am building for Mac and Mac does not support UIKit then potentially the issue lies in the fact that I am for some reason building with that iOS-only file included. Any reason why that would be?\n. If there is anything else I can do to help, please let me know, @mxcl.\n. Everything continues to be working with 0.9.16.1. Thank you for this awesome library and the prompt fix!\n. Here is the project I am working on, specifically this file: https://github.com/Streamlyne/Cocoa-SDK/blob/master/Common/SLStore.m\n. Even more specifically, around this: https://github.com/Streamlyne/Cocoa-SDK/blob/master/Common/SLStore.m#L226-L252\nwhich calls https://github.com/Streamlyne/Cocoa-SDK/blob/master/Common/SLStore.m#L67-L94 and https://github.com/Streamlyne/Cocoa-SDK/blob/master/Common/SLStore.m#L278-L348 \nI hope that helps! Looking at my commits, I had about a lull of 4 hours last night/this morning where I was receiving this error and could not figure it out. And something as strange as commenting out the contents of the then block would allow it to not error, however, of course the program would not pass the tests because it was missing steps.\n. Oh wow, that's awesome!! Thank you for that optimization, @mxcl! I am still learning all of the exciting PromiseKit tricks and you've been a great help so far.\n. I had been trying to go through and clean up when I read that if you return a Promise it will resolve it, so I could omit the [PMKPromise new..] part. That's really great how condensed it really can go!\n. I think I may have committed a typo in my morning rush to my office. I'll let you know once I've fixed that error. Working only now. \n. Hey @mxcl. I apologize for not getting back to you sooner: I ended up having other high priorities to do at work and was unavailable for the weekend.\nWould you be able to try running the tests again and let me know how it goes and potentially what it shows in the console logs? I will be pushing to master branch with what I have been working on and appears to work for me, so you can successfully run tests such as testFindAllAttributes and others.\n. I have stepped through the code and found for case where it breaks the sig is returned as nil. So when the following line below is executed it results in EXC_BAD_ACCESS (code=2 address=0x0): \nobjective-c\n// sig = nil\nconst char rtype = sig.methodReturnType[0];\nSee https://github.com/mxcl/PromiseKit/blob/master/objc/PMKPromise.m#L42-L44\nImportant\nI may have forgot to mention: I am seeing the error on the front-end application for iOS I am developing, that uses the Streamlyne Cocoa SDK that is public. However, the iOS app I am developing is closed source, so I am unable to show you the complete source code. \nI am hoping that you recognize why the sig would be nil and I could look into it further on your behalf and get back to you with any relevant information that would help debugging my usage.\n. On my iOS app I have debugged it down to the following snippet of code:\nobjective-c\n    NSLog(@\"Attempt login\");\n    [client authenticateWithUserEmail:email\n                              withPassword:password\n                          withOrganization:organization]\n    .then(^(SLClient *client, SLUser *me) {\n        NSLog(@\"Logged in\");\n        // Removed for brevity\n    }).catch(^(NSError *error) {\n     // Removed for brevity\n   });\nIt successfully logs Attempt login and crashes before Logged in. See authenticateWithUserEmail:withPassword:withOrganization here.\nHere is a sample of my console log (I redacted the unimportant information, just wanted to show you the starting message of those logs so you know where it is flowing):\n2014-08-25 13:06:09:112 Streamlyne[58980:60b] Attempt login\n2014-08-25 13:06:09.113 Streamlyne[58980:60b] absPath: /api/v1/me\n2014-08-25 13:06:09.113 Streamlyne[58980:60b] Full path: http://54.183.15.175:5000/api/v1/me\n2014-08-25 13:06:09.113 Streamlyne[58980:60b] Secret: REDACTED\n2014-08-25 13:06:09.114 Streamlyne[58980:60b] theParams is empty.\n2014-08-25 13:06:09.114 Streamlyne[58980:60b] HMAC message: GET:/api/v1/me:1408982829:\n2014-08-25 13:06:09.114 Streamlyne[58980:60b] HMAC: REDACTED\n2014-08-25 13:06:09.115 Streamlyne[58980:60b] GET http://54.183.15.175:5000/api/v1/me\n2014-08-25 13:06:09.333 Streamlyne[58980:60b] Success, JSON: {\n    // REDACTED\n}\n2014-08-25 13:06:15.710 Streamlyne[58980:60b] normalizeRelationships Payload: {\n    // REDACTED\n}\n2014-08-25 13:06:16.235 Streamlyne[58980:60b] push: {\n    // REDACTED\n}\n2014-08-25 13:06:16.251 Streamlyne[58980:1303] record:forId:, before find node\n2014-08-25 13:06:16.251 Streamlyne[58980:60b] normalizeRelationships data: {\n    // REDACTED\n}\n(lldb)\n- record:forId:, before find node is from https://github.com/Streamlyne/Cocoa-SDK/blob/master/Common/SLStore.m#L67-L95\n- normalizeRelationships data is from https://github.com/Streamlyne/Cocoa-SDK/blob/master/Common/SLStore.m#L274-L344\nI hope that helps! I believe I have used PromiseKit inappropriately in the Streamlyne Cocoa SDK and hopefully it is a simple fix / typo.\n. I believe I have found the issue! I am calling [PMKPromise when:arrayOfPromises], and in certain cases the array is initialled but empty (length of 0). \nLooking deeper into the PromiseKit source code I found that you have already covered this case in + (PMKPromise *)all:(id<NSFastEnumeration, NSObject>)promises: https://github.com/mxcl/PromiseKit/blob/master/objc/PMKPromise%2BWhen.m#L24-L25\nobjective-c\n    if (count == 0)\n        return [PMKPromise promiseWithValue:@[]];\nThat leads me to https://github.com/mxcl/PromiseKit/blob/master/objc/PMKPromise.m#L324-L329\nobjective-c\n+ (PMKPromise *)promiseWithValue:(id)value {\n    PMKPromise *p = [PMKPromise alloc];\n    p->_promiseQueue = PMKCreatePromiseQueue();\n    p->_result = value ?: PMKNull;\n    return p;\n}\nAnd that is as far as I have gotten so far to finding a solution. Manually adding checks in my SDK code to prevent from using PMKPromise when: with an empty array has resolved those cases thus far, however I feel that PromiseKit should handle this empty array of promises case, and I believe you are in agreement, since you've put the check in for length of 0.\nI am going to try and look into how the promiseWithValue: works, however I may need help at this point. Hope what I've found is helpful! I think we are getting close to a resolution.\n. Not a problem. Let me know when you're working on it so I can help out :). \n. Thanks @dbachrach! I did find that commit and even the passing test; I was writing a comment here about my findings, but must have forgot to hit send.\nSo looks like there is still another issue at play.. :frowning: \n. Shoot. Sorry about that. Looks like I could be accessing a Core Data context from the wrong thread. I went through the other day and optimized most of the methods with the PromiseKit optimizations you suggested. I may have wrote another typo.. I'll take another look. Thanks\n. If I run all of the tests together, it errors like you have; however if I run them individually it appears to work (sometimes intermittently). \n\nI will have to take a closer look later. Must be some form of side-effect between the tests..\n. I am not entirely sure. The tests pass for the SDK, however when used in the closed source iOS application that uses this SDK they fail with something as simple as authenticateWithUserEmail:withPassword:withOrganization.\nI was hoping, after reading the comment\n\n\nEXC_BAD_ACCESS\n   ARC is pretty good, but in some cases it is possible for your Promise chain to be partially deallocated. Usually when wrapping delegate systems. PromiseKit itself has macros that force additional retains and releases to avoid this.\n\n\nthat there may be something I should wrap my usage in to prevent from deallocating and causing the EXC_BAD_ACCESS errors.\nI was also wondering if it could be an issue between the Mac and iOS version of PromiseKit. Since I am using the Mac version for the SDK tests and the iOS for the breaking app.\nI have narrowed it down to a basic call to authenticateWithUserEmail:withPassword:withOrganization:organization, \nsee https://github.com/mxcl/PromiseKit/issues/77#issuecomment-53285989 \nI'm not sure how else I can help. I wish there was some way I could distribute the reproducing App to you so you can experience what I am, however it's company IP.\nI think I will try to build a basic iOS app as an open source project, just to demo a reproduction of the error I am experiencing. I hope that will help.\n. @mxcl here is a demo app that successfully reproduces the same error I am having: https://github.com/Streamlyne/cocoa-sdk-iso-demo\nLet me know if there is anything else I can do! Thank you! :)\n. It worked! Thank you!\n. ",
    "tommy60703": "Thank you!\n. ",
    "bcattle": "I had 0.9.16.4 via Cocoapod. Upgrading to 0.9.16.5 fixed it. Thanks @mxcl. \n. OK thanks for the heads up\n. ",
    "niklassaers": "Thanks for the info, Max.\nThis is a new project (couple of days of code so far), and I did what I usually do for projects, make a Podfile and included what I needed, including PromiseKit, PromiseKit/CKContainer and PromiseKit/CKDatabase. In my bridging header I added\nimport \nand then I wrote the code in the sample above. I didn't really get any problems before my PMKPromise.when().then() call.\nWhat I wanted to do was to do a bit of work on CloudKit without interrupting the user, and just give a little visual or audio queue when the work was done afterwards. If there were errors, I wanted to make a retry-mechanism.\nCheers\nNik\n. Thanks for the explanation, I'll be following your changes closely. It sounds I'll be able to learn a lot from them. :-) Keep up the great work! :-) And thanks for the project. :-)\n. ",
    "turbokuzmich": "Cannot convert the expression's type '(($T4) -> ()) -> ()' to type '() -> ((AnyObject!) -> PMKPromise!)!'\n. ",
    "pocketpixels": "No worries, it was not exactly an urgent fix ;-)\n. ",
    "jschmid": "Currently the code does\nif (!consumed)\n    NSLog(@\"PromiseKit: Unhandled error: %@\", self);\nWhich \"only\" logs the error to the console. It would be nice to be able to hook this to a block or a delegate that can handle this. In my case, I would take unhandled promise and log an error with CocoaLumberjack. My CocoaLumberjack setup is hooked with Crashlytics and Sentry. Having this error showing in my logs would be great to understand a crash. \n. I am using v0.9.17.\n. No worries for the delay :+1: \nI did not think about when indeed.\n. Here is an example when I run pod install \n\nNote that I use pods that themselves use PromiseKit.\n. Well, I wish I fully understood why this breaks. \nI sadly do not have an example here because I had error problems with my setup and I removed my whole xcworkspace. I will create screenshots of the problem after PromiseKit's next release. \nBut as you see in my previous screenshot, cocoapods installs two versions of PromiseKit: 0.9.17 and 0.9.17.1. Xcode therefore generate binary code twice and fails to link the project because some parts have the same signature (obviously).\nFrom what I understand 4 dots versioning is not semver.\n. I am sorry I could not give you an example. But this has happened to me since I began using PromiseKit (0.9.14) so I finally took time to create an issue. \nThanks for sticking with 3 versions. Keep up the good work! :+1: \n. ",
    "allenhumphreys": "I'll expand for my colleague. \n- After doing some research into the issue, I found that the crash only happens when using the PMKManifold macro. \n- Then I verified that the issue is not caused by the macro, by creating the PMKArray directly. The analyzer still crashed.\n- Then, I was able to successfully fix the crash by giving the class method on PMKArray a name for the first method argument. It seems that clang's analyzer has trouble with the specific usage of a class method with no name.\nUnless there is a larger reason for not having an argument name, I'd suggest adding one to fix the issue.\n. I created a PR. Thanks.\n. When will the next pod version be so I can plan to switch back to your pod?\n. ",
    "codecaffeine": "No worries, I wish I could drop 10.7. Thanks for the quick merge! I\u2019m loving PromiseKit.\n. No worries, thanks for the update\n. So, I know very little about how method signatures work, but I tried printing out the ones get passed into [NSMethodSignature signatureWithObjCTypes:signature]; and seeing which one breaks.\n```\n10.7\n9/26/14 6:36:37.893 PM signature: v16@?0@\"NSError\"8\n10.9\n2014-09-26 18:35:32.202 signature: v16@?0@8\n```\nThe 10.7 version breaks, but the 10.9 version works fine.\n. ",
    "oztune": "+1 This seems like a bug.\n. The behavior is indeed correct, though it's perfectly valid behavior for multiple promises to get rejected within a when group, and a log warning could be misleading (not to mention cluttering an otherwise clean log). I'd suggest wrapping this line https://github.com/mxcl/PromiseKit/blob/master/objc/PMKPromise%2BWhen.m#L31 in an if statement checking if the promise is already resolved. @mxcl do you think that's the most correct place for that logic to live?\n. Right, and agreed. I'd be glad to give this a shot if no one else takes a stab at it.\n. @mxcl Here it is :)\n. The fulfiller only gets called when count is 0, which it never will be if one of the promises fail. Would be nice to have a formal test for this, but mocking the logger sounds messy. \n. ;) thanks for this incredible library, it's been really great!\n. ",
    "michael-mckenna": "@mxcl So just to revisit this a bit later from when it was asked - is this still your recommended solution, or is there a new suggested flow?. Thanks for the quick response.\nI was getting an error which brought me here. I'm following the failing chains section and I'm getting the error: Ambiguous reference to member 'firstly(execute:)'. Can you see what I'm doing wrong here? Also, if you prefer that I make a new issue let me know so others can easily see my question. \n```\n            // if user confirms invite, then send invite\n            firstly {\n                AlertControllers.confirmInvite(self)\n            }.then { confirmed -> Void in\n                guard confirmed else { try throwError() }\n                API.sendInvite(to: user)\n            }.done { (success: Bool, emailTaken: Bool) in\n                if success && !emailTaken {\n                    self.navigationController?.popViewController(animated: true)\n                } \n            }.catch { error in\n                print(error)\n            }\n       enum MyError: Error {\n           case rejectedInvite(String)\n       }\n\n      func throwError() throws {\n          throw MyError.rejectedInvite(\"Rejected invite\")\n       }\n\n```. @mxcl Whoops! Thanks for your quick help. By the way, I recently used your library to rewrite a lot of our syncing/networking logic. You've done an excellent job.. ",
    "fangpenlin": "hmm.... I think maybe this is not a problem of promise kit\n. Turns out it's my own stupid problem :/\nTarget for test project doesn't contain PromiseKit \n. ",
    "tokorom": "ok :+1: \n. ",
    "pckhoi": "Such simple mistake... I suck! I have more faith in PromiseKit now.\n. ",
    "plivesey": "Thanks for merging this in, and fantastic library. I'm new to promises, but just wrote a all my asynchronous code for a new library using this library. Open sourcing hopefully soon.\n. I'll try running the tests again.\nAlso, how often do you release to cocoapods?\n. Yeah, still getting this:\n$ ./tests \nSelected tests\nTest Suite 'Selected tests' passed at 2014-11-18 16:23:30 +0000.\nExecuted 0 tests, with 0 failures (0 unexpected) in 0.000 (0.001) seconds\nI'll check my config and try and debug a bit.\nMy xcode-path is pointing to the next XCode 6.1 (not GM, app store version). Not sure what else it depends on.\n. Yeah, can't see anything. Not sure if printing selected tests is expected? Suggests its not running everything? Can't see any reference to that in the source file, and as far as I can see, source looks good.\nAnyway, no worries. I'll try and work it out next time I commit. \nps. how's the swift project coming? I may be interested in contributing. I tried to a few months ago, but there were too many bugs in swift...I just spent all my time filing radars against apple instead of contributing, lol.\n. Nice. By limitations to the compiler, you mean that rather than swift right? As in, the compiler is breaking on legitimate swift?\nI remember trying to make it easier to consume and having trouble. Either way, I'll check it out.\n. Cool. I'll take a look. Thanks.\n. ",
    "texel": "Awesome, glad to help!\n. ",
    "kennyk-peplink": "Actually, I'm counting high on PromiseKit, and am trying to make use of AFNetworking+PromiseKit to mimic the common coding pattern as in jQuery's $.ajax() deferred logic, like this:\nswift\n$.ajax(taskA)\n.then(function(resultFromTaskA, text, jqXHR) {\n    if (prefer_taskB) {\n        return $.ajax(taskB);\n    }\n    return jqXHR;\n})\n.then(function(resultFromTaskAorB, text, jqXHR) {\n    // make cleanedData from resultFromTaskAorB\n    return $.Deferred().resolve(cleanedData).promise();\n})\n.done(function(cleanedData) {\n    // code to take care with cleanedData, from A or B as logic drives\n})\n.fail(function() {\n    // real collector or failure in any $.ajax() call.\n})\nThe difference:\njQuery's deferred-then returns Deferred object, that subsequent .then()/.done()/.fail() will receive result from that deferred object. jqXHR is a deferred object, which can carry over in chain.\nIn PromiseKit, according to the documentation, however, does not expect to chain any new / carry-forward \"Promise object\". Each .then() is merely return some value for the next .then() only, under this flat code pattern.\nI wish I'm wrong, and really wish to get ways to chain promise object in such a flat pattern. Please tell me I'm wrong. Thanks!\n. Thanks for the info.\nI missed the point the returning a [Promise] is treating different from returning just a [value].\nI'm make some real test to try out on this!\n. ",
    "ldiqual": "This issue also happens to me, even though I specifically linked AssetsLibrary to my project. This is what I already tried:\n- Adding AssetsLibrary to Link Binary With Libraries on the Build Phases tab of my project\n- Adding AssetsLibrary to Embedded Binaries on the General tab of my project\n- Do both of those in PromiseKit.xcodeproj\n- Clean, close xcode\nThis is the exact error:\ndyld: Library not loaded: @rpath/libswiftAssetsLibrary.dylib\n  Referenced from: /Users/ldiqual/Library/Developer/Xcode/DerivedData/Project-fnfstourilvobohjponyidexdzcd/Build/Products/Debug-iphonesimulator/PromiseKit.framework/PromiseKit\n  Reason: image not found\nThere's a couple related threads on StackOverflow that didn't fix the issue:\n- https://stackoverflow.com/questions/24333981/ios-app-with-framework-crashed-on-device-dyld-library-not-loaded-xcode-6-beta (top answer is about adding AssetsLibrary to  Embedded Binaries, which I've tried)\n- https://stackoverflow.com/questions/27021828/ios-crash-libswiftassetslibrary-dylib-not-loaded (OP's tried all the same proposed solutions)\nAny other solution you can think of? I'm running Xcode 6.2 beta on Yosemite.\n. Thanks @mxcl, I fixed it with the unused variable. I really hope we'll have a cleaner solution in the future and I understand that it'll be tricky.\n. Would it be possible to also have subspecs for Promise and the different extensions? Something like PromiseKit/Swift/Promise or PromiseKit/Swift/NSURLConnection.\nI'm facing this issue: https://github.com/mxcl/PromiseKit/issues/115 and my solution with Obj-C was to only include PromiseKit/Promise so extra headers wouldn't get included. With this PR, there's no way to be finer with what I want in my project.\n. Oh, apparently you can have nested subspecs: http://guides.cocoapods.org/syntax/podspec.html#subspec (end of the page). It'd be awesome to have that!\n. I see, thanks for the details. Let's hope that improvements will come in the next beta, incremental compilation and no-crashes are what are missing in 6.2 and it really plays with my nerves now :/\n. Cool, thanks Max!\n. @johanwigmo What I do is this:\n```\nlet promise1 = myPromise1()\nlet promise2 = myPromise2()\nwhen([promise1.asVoid(), promise2.asVoid()]).then {\n    let value1 = promise1.value\n    let value2 = promise2.value\n}\n```\nMight not be the prettiest solution though. Maybe @mxcl can hint on a better one?\n. @mxcl The problem only occurs in UI test targets when waitForExpectationsWithTimeout is called right after a then/catch is chained on a promise. The then block is not blocked when performed on another queue than the main queue, but there's no way to change the queue of the report block. Alamofire has the same issue with its default queue here: https://github.com/Alamofire/Alamofire/issues/809. I'll provide a test project asap, thanks for asking.\nSide note: I tried to checkout the project and run the tests but I'm unable to setup the carthage dependencies (it keeps asking me for my github credentials when I run carthage bootstrap). How do you usually proceed to checkout and run your tests?\n. @mxcl Here's the example project: https://www.dropbox.com/s/2c6vfqgxtuzltlj/PromiseKitReportQueueExample.zip?dl=0\nThe interesting stuff is in PromiseKitReportQueueExampleUITests.swift, you'll see 3 tests as part of the UI test target:\n- A successful promise with a then on the default queue (fail)\n- A successful promise with a then on a concurrent queue (pass)\n- An unsuccessful promise with a report on the default queue (fail)\nI couldn't find any documentation on the behavior of waitForExpectationsWithTimeout in a UI test target, but I believe that it blocks the main queue from receiving further messages until all expectations are met. It doesn't block the actual UI though (you can still interact with the app in the simulator), which is weird.\n. @mxcl More info on the waitForExpectationsWithTimeout behavior: http://masilotti.com/xctest-documentation/Classes/XCTestCase.html#//api/name/waitForExpectationsWithTimeout:handler:\n\n-waitForExpectationsWithTimeout:handler: runs the run loop while handling events until all expectations are fulfilled or the timeout is reached. Clients should not manipulate the run loop while using this API.\n. @mxcl I think it's totally reasonable to have async logic in a UI test bundle, a real world example from my app is this:\n- Signup\n- Validate email by querying an email service API (this logic is in the test)\n- Wait for the \"please verify your email\" view to disappear automatically\nXcode 7\u2019s UITest stuff is not designed to have logic in the testing portion\n\nI don't think I agree with this, you can pretty much write any kind of code, perform http calls, do async stuff, as long as you don't try to perform stuff on the main queue while it's blocked with waitForExpectationsWithTimeout:handler:. I've never seen any documentation saying that there shouldn't be any logic in UI tests.\nI'd even go one step further and say that being unable to choose the catch queue is a blocker for making performant threaded apps since you can't control where your code is executed. If your logic in catch is heavy, you block the UI for a while and this may be an issue. You could add a few lines to execute your catch code in another queue, but there'd be a performance hit if the queue doesn't exist already (potentially creating another thread), in addition to being inelegant.\n\nI am reluctant to add a queue parameter to catch\n\nI think I see one issue in the order of arguments (you'd have to specify a policy before specifying a queue), but aside from this, what drawback do you think there is?\n. Oh yes sure, I misunderstood your comment. You can't interact with the code of your app, but your tests can contain logic (async or not) that's separated from the running app.\n\nError handling really must succeed or an end-user\u2019s data may be at risk. By forcing all error handling to occur serially on the main thread PromiseKit is helping create a world of robust applications.\n\nI think it makes a lot of sense as the default behavior for the catch handler. In this case though, there's definitely an issue because the handler cannot be called at all since the main queue is blocked. With that in mind, can you think of another way to deal with this?\n. It happens to me often when the code within the error block has compiler errors. For instance:\nAPI.instance.cancelTripRequest(tripRequest).then { _ -> Void in\n    self.onTripRequestCancelled(tripRequest)\n}.error { error in // Cannot call value of non-function type 'ErrorType?'\n    Kugel.publish(TripRequestCancelFailed, object: error.nsError)\n}\nBut the actual error is within the error block: TripRequestCancelFailed is a static member of the current class, not a global variable. A good way to debug this is by moving your error code outside of the error block, and see what the compiler says.\nNot sure it's the cause of your issue, but I thought it was worth mentioning.\n. @mxcl @nathanhosselton would you be open to the addition of a changelog file as part of the repo? From experience I know that maintaining release notes in tags can be painful, and it doesn't seem like it consistently done in the recent releases. A changelog might help with that.\nFor context: was trying to see what's new in 6.2.0 but there was no release note and the commit history was hard to read.. @mxcl thanks a lot.\nJust to clarify my point about commit history, when you look at the diff between 6.1.2 and 6.2.0 this is what you get:\n\nIt's pretty cluttered: important changes get buried among all the behind the scene work, it includes irrelevant information like merge commits (usually solved with squash merges), and more importantly: it's unclear how user-facing changes affect the API / user codebase just from the commit title.\nMy company updates dependencies every 2 weeks \u2013 which I think is pretty aggressive \u2013 so in this case it's 6 versions of PromiseKit that I need to go over. That's 66 commits. I understand this is most likely a result of releasing a major version but usually PromiseKit is pretty good at getting regular maintenance updates, so a couple versions every 2 weeks is not that rare of an occurrence. I would imagine that most companies don't upgrade this aggressively so it's most likely even harder for them.\nMaintaining a changelog is notoriously hard though so I definitely get your point. Thanks again for the release notes, super useful!. @mxcl yes, this is why I was asking whether you'd be open to it in https://github.com/mxcl/PromiseKit/issues/354#issuecomment-369117769.\nOne way to maintain a changelog that is low effort for maintainers is to enforce authors to modify the changelog as part of their PRs. This is what Cocoapods does and I believe it's been working pretty well for them. This can even be enforced with tools like danger. I'm happy to help adding this process in place if you think it's valuable. I agree that maintaining it manually is too much work.. @nathanhosselton Oh cool, thanks for the tip! Closing\n. @mxcl I return void promises a lot in my code and I find both syntaxes \u2013 Promise(value: Void()) and Promise(value: ()) \u2013 to be confusing. I ended up adding Promise.void. Would it be appropriate to have that in the library? I'm thinking about something like this:\nextension Promise {\n    static var void: Promise<Void> {\n        return Promise<Void>(value: ())\n    }\n}\nAnd how I use it:\nfunc doSomething() -> Promise<Void> {\n    return .void\n}. @yuvalrakavy Please take a look at http://promisekit.org/docs/, there's a whole section about cancellation. You'll want to throw a CancellableError which you can catch with policy = .allErrors and error.isCancelledError.. @mxcl Just curious, what would be an effective place for wishlists? PRs seem fair but they involve having to show some code, which might refrain some people from adding their wishes.. I've seen projects \u2013 like react-navigation \u2013 use https://canny.io/. Not too sure how effective/visible it is though. Just a thought.. That's completely fair, thanks a lot for your insight.. Fyi since I had experience with JSC from a past job, I've started working on this here: https://github.com/ldiqual/PromiseKit/tree/lois-jsaplus/Tests/JS-A%2B\nSome (most?) of the tests pass but I still have a large amount of debugging to do. Working with JSC is pretty tedious since stacktraces don't have line numbers.. @mxcl Done. Let me know if I should remove the example, I feel like it's helpful.. @mxcl Awesome! Yeah I think we can generate a new TypeError() by using JSUtils.sharedContext.evaluateScript(). There might be less hacky ways but that's a start.. @mxcl I added JSUtils.typeError(message: String) -> JSValue. Not sure I'll have time to get our then to throw it but it's there if you want to give it a try.. @mxcl Got it to throw properly but I'm not super happy with the solution since I think it should be thrown from PromiseKit as opposed to JSPromise re-implementing the logic. If you can think of another way, let know or feel free to edit my branch.\nAll tests now pass. I wish there was more reliance on PromiseKit itself for some of the validation and return values because sometimes it feels like we're testing JSPromise itself while it's meant to be a super thin JS wrapper. But some of the tests are very much JS centric so I don't feel too bad about it.\nNext week I'll look into while Travis is failing, I assume it's just because JSC is not linked against.. I'm a bit concerned that it will still timeout for PRs unrelated to this commit, preventing future contributors from getting their code merged quickly. Do tests now pass reliably or should I spend more time looking into it?\nIf it's all good, then \ud83d\udc4d Thanks a lot for reviewing!\nSide question: are there other test suites that you're thinking about complying to? Something that'd test map, when, Guarantee etc.. I guess bluebird has tests that would be nice to have like Promise.all which is our when(), or constructors that take a resolved value. Probably a hell to maintain though, prob not worth it.. ",
    "fabb": "I know there is XCTestExpectation, but I use Kiwi and this is not available as it seems.\n. ",
    "Ricardo1980": "That's better. Thanks.\n. ",
    "davidchin": "Yes, I'm using tags/1.2 (ee3550edc1257553362eacb7d0038edbb2b23d1c)\n. Yes, I noticed the difference between the allocation instrument and Xcode memory metre after I reported this issue. But I didn't really understand the reason behind it and which one was more reliable. Anyway, I guessed Instrument was correct so I kept using PromiseKit in our project. Thanks for looking into this issue - now I know why.\n. ",
    "philmitchell": "Okay, here goes: http://philmitchell.github.io/PromiseKit/\nPlease feel free to let me know if I've misunderstood anything ...\n. Bump ... just in case this fell off the radar!\n. Glad you like it! That sounds good, is that something you can do?\nOn Fri, Jan 30, 2015 at 1:51 PM, Max Howell notifications@github.com\nwrote:\n\nYes, I like the approach. Can we put it on the main site in a new tab?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/121#issuecomment-72276424.\n\n\nLearn Bird Songs, Support Conservation: http://www.larkwire.com\nBikewise: http://www.bikewise.org\n. Max, you are obviously passionate about docs, which is awesome. I have no problem with relegating my cookbook to an appendix ... but I do think that you underestimate the need for a more gentle guide for the less sophisticated devs such as myself! Just my $0.02 ...\n. Okay, thanks for the offer! I'll think about whether I have anything useful\nbeyond what I already sent ... At any rate, huge fan of PK! Thanks, again\n...\nOn Thu, Feb 19, 2015 at 7:43 PM, Max Howell notifications@github.com\nwrote:\n\nLike by all means, lets work together, submit some PRs to adapt what we\nhave.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/121#issuecomment-75185239.\n\n\nLearn Bird Songs, Support Conservation: http://www.larkwire.com\nBikewise: http://www.bikewise.org\n. ",
    "eldereal": "sent a pull request\nhttps://github.com/mxcl/PromiseKit/pull/124\n. ",
    "dmiotti": "Hi, any plan when this will be available through cocoapods ? :)\n. ",
    "danthorpe": "Thanks Max - appreciate your position. I've also been swamped at the moment to get to it myself.\n. Nice! :+1: \n. Hmm, that a good point, it is quite a significant change, adding in an extra generic type. \nYou don't think it would be sufficient that the error will be something conforming to ErrorComponents or whatever, which NSError does automatically (or could be made to)?\n. Yeah, it's a like a default type.\nI've found the technique to be really handy. My typical use case is in taking a strongly type error, (from an IDL like ProtoBuf, or Thrift) which comes from the server, and then mapping it to the app domain, and then transforming that generic server error to one with richer details, like the failed request, or a model type, which is then used to \"handle\" the error effectively.\nAt the very least, it allows me to use Swift's pattern matching on the error type directly, without resorting to status codes. \n. Maybe the best way forward is for you to model your own Error type, as you'd like to use with PromiseKit, and see what we can come up with?\n. For easy interoperation with NSError based APIs. \n. Well, I just think that if you need to pass the E object to some API which is expecting NSError (which is the Cocoa convention), then you'll need to be able to create such an object, which will require being able to determine error codes etc.\nSo... my intention would be that the core Promise type in PromiseKit would be able to mediate from NSError -> E: ErrorType -> NSError.\n. Yes, but this means jumping through conversions whenever your error handling has to interact with PromiseKit. And, unless you write a lot of glue code, any associated types you might define with your own error type get lost. PromiseKit is designed to be used with chains, and error handling will typically be done at different points along that chain. Making the error type a generic will remove, the quite frankly limiting, NSError from this process.\n. Yes, the biggest drawback to a generic error parameter is that the definition might look a little daunting.\nSubclassing NSError is feasible if you want to use enum types for your error type.\nOne possible solution which i will investigate is just to subclass Promise<T> to add my own error type.\n. @mxcl because that restricts the error type to being a class, and excludes using an enum.\n. Maybe, probably not a good idea to try to please the 1% though! :)\nRelated, have you seen: https://github.com/ReactKit/SwiftTask?\nI think we can probably close this issue, as it's not a huge priority for me personally.\n. Also, just out of interest, I'm currently at SwiftSummint (https://www.swiftsummit.com) in London. And, so far 50% of the speakers have advocated using an ErrorType protocol to make errors a generic type, in a simplified Future pattern, and ReactiveCocoa 3.\n. Well, it happened \ud83d\ude04 - from the Swift book: https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508\nRepresenting Errors\nIn Swift, errors are represented by values of types conforming to the ErrorType protocol.\n. Yeah, I'm trying to frantically update my open source projects too. :)\nFirstly, I'm not suggesting PromiseKit should adopt a generic error type at all. There are other FRP projects which offer this level of customisation, I think PromiseKit is great when it makes UIKit more FRP ready.\nMy take-away on the error handling, is that Apple recognise that NSError is a bit of a bloated mess, and enums are a great fit for each API or framework to provide its own error type. And I've only seen this in use in NSFileManager so far, but I wouldn't be surprised if NSError begins to fade away as frameworks go from Objective-C -> Swift.\nIf I was writing a PromiseKit-like library, in Swift 2.0, then I would try to decompose the Promise type into a PromiseType protocol which supported a generic error type. And have the concrete implementation Promise use NSError. And then, extend PromiseType constrained with NSError for UIKit promise APIs. But, just thinking out loud really. :)\nBut, seeing as you've just done 2.0 (huge work I'm sure) - then forget about it until Swift 3.0!\n. ",
    "russbishop": "FYI, I've run into zombie object crashes with nested NSProgress objects (specifically _NSProgressFraction). NSProgress appears to have a fundamental assumption that intermediate child progress objects aren't being simultaneously created and deallocated which only really works if you can create all necessary progress objects up front. \n. It seems like cancellation makes reasoning about progress in a decoupled way impossible because some later piece of code trying to chain may find that neither its then nor its catch executes. In the C# world, Task<T> cancellation is handled by exceptions so it always appears to be an error condition. I suppose that could be one path forward?\nBut mostly I'm worried about stability problems. I'd strongly prefer to have a way to turn this off!\n. @mxcl I would never open a PR with a test that has any chance of generating spurious test failures. \nThe unreliability of this test is that it can in theory pass when it should have failed. Never the other way around... If there is a data race present there is a small chance that the data race occurs in just such a perfect way as to allow the test to pass. I tried to set the iteration and stress counts high enough to make sure that doesn't happen, but it depends on how the system allocates dispatch queues, the number of processors, and other factors outside of our control.\nI don't think proving the absence of a race in this context is a computable problem. \n. ",
    "alexlee002": "@mxcl Hi,  I read the WhenTestCase code, but I'm not sure how to report the download progress in http download request. Can you please show a sample?. @mxcl Thank you! Yes, I know I can do that outside of PromiseKit. But I suppose if we can add this as a feature.  The other promise-pattern framework \"SwiftTask\" has implemented this feature.. ",
    "mowens": "PR: https://github.com/mxcl/PromiseKit/pull/130\n. Not really sure that rescue is a great name for the new catch which @mxcl  has already mentioned doesn't actually rescue from errors. Additionally there is already a recover feature which does rescue from errors and recovery is a synonym for rescue \n. ",
    "sdolidze": "What's wrong with error type being unconstrained like Promise<T, E> not Promise<T, E: ErrorType> or something similar?\n. I'm sorry, I don't think I understand the problem. Can you give me an example where unconstrained error type would cause problems?\n. Oh, now I think I understand what you mean. But why should that be Promise type's responsibility? In my opinion, if you have an error type from you domain, it should be client code's responsibility to convert that domain error into NSError wherever needed.\n. What if Promise<Value, Error> had a subclass PromiseWithNSError<Value> to make things less verbose? (name should obviously be shorter). Here's an example to show what I mean:\n``` swift\nclass Pair {\n    let left: L\n    let right: R\ninit(left: L, right: R) {\n    self.left = left\n    self.right = right\n}\n\n}\nclass PairWithString: Pair {\n    override init(left: L, right: String) {\n        super.init(left: left, right: right)\n    }\n}\nlet pairWithString: PairWithString = PairWithString(left: 5, right: \"PromiseKit\")\nlet pair: Pair = pairWithString\nprintln(pair.left)\nprintln(pair.right)\n```\n. ",
    "frizzy75": "I found an example in UIAlertView+Promise.swift - but also read the warning in the docs against combining promises and delegates, so closing this. Would still welcome any examples or suggestions how to do this better. Thanks.\n. Thank you!\n. @mxcl - I'm curious: why the println(self) to force a retain vs. PMKRetain( ) and PMKRelease( ) ?\nThanks\n. Thank you @mxcl \n. @mxcl Thanks - both Swift versions are 3.0.2. Any other possible differences that might explain this?. Thanks, @mxcl. I've tried carthage --configuration Debug and I can step through the PromiseKit code. All works well until the recover closure; execution never enters recover(on: policy: execute) but inexplicably jumps to then<U, V, X>(q: body:). I'm pulling my hair out :-) . Thanks, @mxcl. I'll keep trying for a little while longer. \nI'm trying to add Carthage support to an existing framework that supports CocoaPods and depends on PromiseKit - and which uses the default CocoaPods file & project hierarchy. \nAfter clearing the slate (deleted derived data directories, restart Xcode, etc.), Carthage no longer builds in a test project due to a missing PromiseKit.modulemap. So perhaps I was using cached, but out-of-date files yesterday, when Carthage successfully built, but the test app crashed?\nIn any case, I appreciate your help - and love PromiseKit.. @mxcl I finally got everything to work. I was probably tripping over cached builds of an earlier version of PromiseKit, built with CocoaPods. \nThanks for the quick responses, and the suggestions, which led me in the right direction. \nClosing this issue.. @mxcl:\n1. Both PromiseKit.framework and PMKFoundation.framework are in the \"Linked Frameworks and Libraries\" section of the target's \"General\" tab. But if I add them to the \"Embedded Binaries\" section, too, then the project doesn't compile.\n2. I've removed all calls that required importing PromiseKit or PMKFoundation, and the import statements; cleaned the build directory, deleted derived data, and restarted Xcode and the app in simulator is still crashing.\n3. I have 2 targets, one of which is test target\n4. Targeting only iPhone, with iOS 12.\nThanks. The compiler error results from conflict with the 'Run Script' phase I set up, per Carthage's instructions. The error is:\nerror: Multiple commands produce '/Users/frizzy/Library/Developer/Xcode/DerivedData/XXXX*/Build/Products/Debug-iphonesimulator/XXXXX.app/Frameworks/PMKFoundation.framework':\n1) Target 'XXXXX' has copy command from '/Users/frizzy/Documents/Projects/XXXXX/Carthage/Build/iOS/PMKFoundation.framework' to '/Users/frizzy/Library/Developer/Xcode/DerivedData/XXXXX*/Build/Products/Debug-iphonesimulator/XXXXX.app/Frameworks/PMKFoundation.framework'\n2) That command depends on command in Target 'XXXXX': script phase \u201cRun Script\u201d. @mxcl The project does compile now, but the app still crashes with same error. @mxcl I have not - will try that shortly. Thank you.. @mxcl I tried rebuilding all frameworks with carthage bootstrap -- same result: app crashes with symbol not found error.\n. @mxcl yes - that framework has a Cartfile that looks like this:\ngithub \"mxcl/PromiseKit\" ~> 6.0\ngithub \"PromiseKit/Foundation\" ~> 3.0. @mxcl will do - that framework was compiled from source in the same carthage bootstrap operation. Thanks.. @mxcl I ran the otool command in the project subdirectory Carthage/build/iOS and got the following output. It doesn't mean much to me, but I don't see a reference to PMKFoundation - is that significant?\nFoo.framework/Foo:\n    @rpath/Foo.framework/Foo (compatibility version 1.0.0, current version 1.0.0)\n    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1556.0.0)\n    @rpath/PromiseKit.framework/PromiseKit (compatibility version 1.0.0, current version 1.0.0)\n    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)\n    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1556.0.0)\n    /System/Library/Frameworks/SafariServices.framework/SafariServices (compatibility version 1.0.0, current version 1.0.0)\n    /System/Library/Frameworks/Security.framework/Security (compatibility version 1.0.0, current version 58286.202.3)\n    /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)\n    @rpath/libswiftCore.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftCoreFoundation.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftCoreGraphics.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftCoreImage.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftDarwin.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftDispatch.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftFoundation.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftMetal.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftObjectiveC.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftQuartzCore.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftUIKit.dylib (compatibility version 1.0.0, current version 1000.11.37). @mxcl - hopefully I did it right this time; ran otool in the derived data directory and got the output below. Again seems that PMKFoundation is not included. \nWhat is a 'vendor copy of PromiseKit'? -- I know the framework was built from the Github source here, and originally with Cocoapods in mind. Carthage supported was added more recently. Does it look like the framework's Carthage configuration is off?\nThanks\n```\n$ pwd\n/Users/frizzy/Library/Developer/Xcode/DerivedData/XXXXX/Build/Products/Debug-iphonesimulator/XXXXX.app/Frameworks\n$ otool -L Foo.framework/Foo\nFoo.framework/Foo:\n    @rpath/Foo.framework/Foo (compatibility version 1.0.0, current version 1.0.0)\n    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1556.0.0)\n    @rpath/PromiseKit.framework/PromiseKit (compatibility version 1.0.0, current version 1.0.0)\n    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)\n    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1556.0.0)\n    /System/Library/Frameworks/SafariServices.framework/SafariServices (compatibility version 1.0.0, current version 1.0.0)\n    /System/Library/Frameworks/Security.framework/Security (compatibility version 1.0.0, current version 58286.202.3)\n    /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)\n    @rpath/libswiftCore.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftCoreFoundation.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftCoreGraphics.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftCoreImage.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftDarwin.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftDispatch.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftFoundation.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftMetal.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftObjectiveC.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftQuartzCore.dylib (compatibility version 1.0.0, current version 1000.11.37)\n    @rpath/libswiftUIKit.dylib (compatibility version 1.0.0, current version 1000.11.37)\n``. @mxcl they support both Carthage and CocoaPods; I was just thinking maybe the Carthage support isn't entirely correct. It did work fine for me in another CocoaPods project *and* another Carthage project - but that was before I upgraded to Xcode 10 so there are still too many variables for me to figure this out...\nThank you for your help.. @mxcl Thank you - I appreciate the help. I may give up and go with CocoaPods.. @mxcl I finally got it to work. I forked the 3rd party framework and made some corrections & changes. The key was changing the framework's Podspec dependency fromPromiseKittoPromiseKit/CorePromiseafter reworking the code so it didn't require thePromiseKit/FoundationURLSessionextension -- I couldn't get it work with thePMKFoundation` extension.\nIf useful, I'd contribute a pull request with code sample for others who are trying to create a framework that depends on PromiseKit and properly supports both Carthage and CocoaPods -- at least without any PromiseKit extensions. I'd need some help with syntax to support the extensions.\nThank you again very much for your help, your responsiveness and for creating & maintaining the great PromiseKit! . I have reported it.. It's not a binary - I was always rebuilding from source. I also had multiple issues with Xcode's new build system, another framework that was acting up, etc etc. So still not sure about the root cause - may very well have been on my side. It's working now, so far, so I'm moving forward.. Will do!. ",
    "chkpnt": "I don't see PMKRetain / PMKRelease in the current release. Was it renamed at some time?. Unfortunately, version 4.4.1 is still not available via CocoaPods.. ",
    "tikitu": "If you find a precedent that suggests a different API (or have any better ideas) I'm happy to work on it further. (Particularly unsure about not being able to map results back to their originating promises, but I think making that possible would complicate things quite a lot.)\n. I'm not totally sold on wait, it sounds a bit like it should be blocking. (Your project = your call, just my 2c.) Some alternatives:\n- after\n- afterAll\n- whenFinally (by analogy with .finally() which collapses the reject/fulfill distinction)\nIf you make a decision I'll rebase the PR and make the changes.\n. I like. Will do renaming and rebasing; if you come up with something better in the meantime it's no trouble to redo.\n. Huh, I was still trying to rebase at my end (with not much success, I must say). Thanks!\n. Our original use case was uploading a bunch of items that were created offline to an API server when next online. We want to track failures, but just because one item fails doesn't mean we should abort all the other uploads.\n. Two other considerations from that use case:\n- if we short-circuit on first failure, as you say nothing gets explicitly cancelled, but we do start having to worry about retaining references long enough to make sure the other requests don't get garbage-collected;\n- with short-circuiting it is not easy to defer an action until all the results are in (e.g. reporting \"3 uploads succeeded and 4 failed\").\n. ",
    "iosengineer": "What comes through is a single information page rather than all of the new documentation. Perhaps I need to re-import it?\n. Hi Max,\nTerribly sorry for the delay. Work went off the rails and then I was bedridden sick for a week. Not fun. I'm catching up on email so I'll try to review this in context shortly.\nThanks,\nAdam.\n. ",
    "jordanbrown": "+1\n. ",
    "LinusU": "Nice! I could really use it. You know you been doing too much Node.js programming when your swift code looks like this: :laughing: \n``` swift\ntypealias Callback = (NSError?, AnyObject?) -> Void\nfunc send(method: NSString, params: NSDictionary?, cb: Callback) {\n    ...\n}\n```\n. Nice! Thank you so much for the quick update :+1:\n. @ldiqual I don't know if you have already seen it but just wanted to point out that there is a branch for swift 1.2 support. You might want to base your work on that one if you are tinkering this week, happy hacking :)\n. ",
    "frizull": "Well, that was quick. Thank you so much!\n. Unfortunately, it would seem the pod is unusable as it is. The updated Podspec has not been picked up in the CocoaPods repo. And forcing the spec URL in the Podfile yields \"xcodebuild: error: 'swift/PromiseKit.xcodeproj' does not exist.\" when trying to pod install.\n. ",
    "danyalaytekin": "Had this a couple of days ago. Ended up going back to submodules.\n. ",
    "tp": "Awesome solution!\nSince you're already checking hasInfoPListKey(\"NSLocationAlwaysUsageDescription\"), would this be a good place to return an error if the required one is not set?\nIf I recall correctly, iOS does not error when the developer has not set these keys, but just does not show the dialog.\n. ",
    "pieisgood": "awesome thanks!\n. to clarify, I believe this happens when the server sends back a 401. In my case I was sending an incorrect token to the server and got back a 401 because of this.\n. ",
    "bevbomb": "It's swift, I've had promisekit installed for quite awhile now and hadn't updated it till the other day, I've submoduled it and installed it in the exact same manner as you would alamofire, but because promise kit now relies on a third party framework, I've also submoduled that and added it, but promisekit doesn't seem to recognise the framework\n. I've had it installed as a submodule since the day I started using it months ago, \nI did also try installing as cocoa pods but that doesn't install them as frameworks, which means that it still won't import because it isn't a framework\n. I will provide images shortly of my settings \n. \n. I can now see that OMGHTTPURLRQ framework is red.. Which is weird because it came straight from the git repo, I've also tried manually downloading and its still red\n. \nIts weird because it will build fine and run on both simulator and device, but won't archive\nI can also see that it does actually build OMGHTTPURLRQ, it just doesn't link it to PromiseKit\n\n. Ok so now its recognising it, but i have a new problem, it seems to think OMGHTTPURLRQ is a OS X framework and giving me a code signing error: \nCode Sign error: No matching codesigning identity found: No codesigning identities (i.e. certificate and private key pairs) matching \u201ciPhone Developer\u201d were found.\nUPDATE: \nscratch that, did a fresh pull and its fine, but its still not building the module, it won't even build it when i try and run on a device now\n. \n. They seem to all be pointed at extensions, PromiseKit isn't an extension, i assume it has something to do with the actual Project file containing references to the OMG framework,\n. As far as i can gather, you can't directing link a framework to another framework which is exactly what your doing with PromiseKit\n. Also if your plans for the future involve it being an umbrella framework, http://stackoverflow.com/questions/27484997/how-to-create-an-umbrella-framework-in-ios-sdk\n. ",
    "rodsfreitas": "Are you using Carthage? I'm having a problem that probably is related. \ndyld: Library not loaded: @rpath/PromiseKit.framework/PromiseKit\n  Referenced from: /var/containers/Bundle/Application/596AA7ED-98FB-4704-BF1D-897DA3492262/App.app/App\n  Reason: image not found\n(lldb)\nI added the OMGHTTPURLRQ to the linked frameworks.\n---->\nUpdate:\nI've fixed this using the copy-framework to the OMGHTTPURLRQ.\n. ",
    "webdevotion": "Fixed my problem by reading http://promisekit.org/breaking-the-chain/.\nTIL: just return the NSError instance in stead of reject(myError).\n. Thanks for your interest @mxcl. I went back in my git repo and checked different version up to 4 days ago but could not find a single instance in which I am returning NSError in stead of rejecter(error).  So while the docs as mentioned above are still valid, I do not have or did not find an issue that could help you.  I will keep this problem in mind and will post relevant code.  Thanks for PMK.\n. My public interface has:\n``` objc\nimport \n```\n. Thank you @mxcl  and @cdzombak. \nTo further clarify the common misusage cases:\nis this a good use case to warrant the use of an extra PMKManifold?\n``` objc\n- (PMKPromise ) promiseToDoSomething;\n{\n    return [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject) {\n        [Thing fetch].then( ^(id result){\n            [thirdParty doSomethingInBlock:^(BOOL succes, NSError error){\n                if( error )\n                {\n                    reject( error );\n                    return;\n                }\n            fulfull( success );\n        }];\n    });\n}];\n\n}\n```\n. Very useful example.  Thank you.\n. ",
    "stefanfisk": "```\ndefine PMKDeclPromiseBlockMethod(name, ...) \\\n\n(PMKPromise* (^)(VA_ARGS))name\n```\n\nWould probably also make sense.\n. For both I'd say, so that it becomes easier to implement methods returning block just like PMKPromise does today.\nBut I only out like five minutes of thought into it, so YMMV, I've yet to write any functioning code with PMK, although I've used promises a lot on node.\n\nOn 14 Mar 2015, at 02:13, Max Howell notifications@github.com wrote:\nIs this for PMKPromise.m? Or for your code in general? Just interested.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "warpling": "Sorry I was unclear. What you describe is exactly what I'm trying to achieve.\nI've been unable to find a straightforward way to construct the above from an array of promises.\n. Interesting! I had come up with something similar but it was recursive with a lot of rightward-drift hah. This is perfect. I hadn't realized I could keep appending .then(...) to the original Promise but that makes complete sense now. Thank you! \n. Ah because calling .then(...) on a promise returns a new promise right?\n. Makes sense :)\nOn Tue, Mar 17, 2015 at 5:20 PM, Max Howell notifications@github.com\nwrote:\n\nYes, or you wouldn't be able to call then again.\nReply to this email directly or view it on GitHub:\nhttps://github.com/mxcl/PromiseKit/issues/163#issuecomment-82650439\n. The title is the only error I'm receiving. I took these screenshots after cleaning the build, deleting derived data, and rebuilding. The highlighted error is coming from line 64 in PMKPromise.h. As far as I can tell, modules are enabled in release/debug for all of my targets including Pods and PMKPromise's.\n\n\n\n. I figured the same, but modules are turned on in all my targets (MyApp, MyAppTests, Pods (and each pod's target)). Is there somewhere other than build settings to enable modules?\nOn Fri, Jul 24, 2015 at 11:09 PM, Max Howell notifications@github.com\nwrote:\n\nYour project has modules disabled. These are headers so they are included into your app's target and this is not CocoaPods related. Turn modules on in your app target.\nReply to this email directly or view it on GitHub:\nhttps://github.com/mxcl/PromiseKit/issues/224#issuecomment-124807524\n. Now that you mention it, I remember this happening last time I updated (when I installed 2.0.6)! At that time I think I just made the fix by hand; updating to 2.1.0 must have overridden the change :)\n\nStill, if modules are enabled, why might \u00a0this still throw off the compile?\n. Strange, I had to change a couple more @import instances, but it's good to know that that's all it takes to fix. Hopefully this issue helps anyone else with the same problem. Thanks for the help and library, Max :)\n. Sorry that was extremely unclear. I meant that I had to replace all of my imports of PromiseKit:\n```\n//@import PromiseKit;\nimport \n```\n(There are plenty of other Pod libraries I include as @imports like Pop, Masonry, etc)\n. Gotcha, just found that note in the 2.0 release notes. Sorry I missed that when converting all my Pods to Frameworks.\n. Ah! Thank you, that did the trick!\nI feel really stupid saying this, but I first gave up on that route when Xcode wouldn't autocomplete that path. I obviously don't know enough about linking/modules yet.\nThank you again.\n. @TheArtOfEngineering That'd be great! If the only thing in that branch needing a refresh is the syntax I can try to take a stab at it, but as mentioned I unfortunately haven't kept up with Swift much at all. \n. @nathanhosselton eagerly looking forward to it :) \n. Fantastic! Installing\u2026\n. Hitting some build issues in NSURLConnection+Promise.swift\nDid you use any special config in your podfile?\nI'm currently using:\n```\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n  # Turn off code signing (is this a bad thing?)\n  config.build_settings['EXPANDED_CODE_SIGN_IDENTITY'] = \"\"\n  config.build_settings['CODE_SIGNING_REQUIRED'] = \"NO\"\n  config.build_settings['CODE_SIGNING_ALLOWED'] = \"NO\"\n\n  # (May be able to remove eventually: https://github.com/CocoaPods/CocoaPods/issues/5521)\n  config.build_settings['SWIFT_VERSION'] = \"3.0\"\n\n  config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'\nend\n\nend\nend\n```\n. Guessing it's the symptom of something else? \n\n. It compiles!! Thank you so much @nathanhosselton \ud83d\ude0a\nJust to confirm for future readers, there currently is no Swift 2.3 branch right?\n. Sounds like a plan!\nFor what it's worth, when I tried doing a conversion to 2.3 I'm pretty sure Xcode 8 told me that swift 2.3 was supported but would be deprecated in the future (insinuating Xcode 9?).\n. @nathanhosselton you're awesome. Downloading the new beta now; just came here to check ;)\n. Tada \ud83d\ude01\n. ",
    "tonyarnold": "Great stuff, thanks @mxcl!\n. This appears to be due to our use of Objective-C++ (in this instance \u2014 not sure if you want to share the sample project here @DominikDeak?). \n@mxcl are you open to a PR for this issue, given that the fix shouldn't have any adverse effects on plain old Objective-C?\n. ",
    "robertomg": "Since I did not find any solution, I tried to fix it. To address this problem I have created a category of PMKPromise that allows creating promise then blocks out of a Swift closure:\n``` swift\nextension PMKPromise {\nprivate func objCBlockFromPromiseClosure(closure: (AnyObject) -> (PMKPromise?)) -> AnyObject {\n    return unsafeBitCast(closure as @objc_block (AnyObject) -> (PMKPromise?), AnyObject.self)\n}\n\nfunc swiftThen(closure: (AnyObject) -> (PMKPromise?)) -> PMKPromise {\n    return self.then()(objCBlockFromPromiseClosure(closure))\n}\n\n}\n```\nTo use it: \n``` swift\nlet fetchUserPromise : PMKPromise = ...\nfetchUserPromise.swiftThen({object in\n   if let user = object as? User {\n      self.doSomeWorkWithUser(user)\n      return nil\n   }\n})\n```\nThe problem is that it only accepts one object (AnyObject) as a parameter of the then closure. But it solves my problem, at least, for the transition time between objective-c and Swift. \n. I know that this is not a long lasting solution but for those developers who use PromiseKit for Obj-C and they would like to start using Swift gradually, it may help. I would be glad to see a better solution to integrate the library in both languages. Thank you for adding it to the documentation page.\n. Thank you @andi357 for fixing this, this code should be merged. I tested this and I am happy to get the missing userInfo back. Apparently the conversion to CancellableErrorType was causing the problem.\n. ",
    "jspavlick": "Will 2.0 be iOS 8 and above only?\n. ",
    "carlhunterroach": "Here is a method for using dynamic frameworks with target < iOS 8\nhttps://github.com/quellish/Weakness\n. ",
    "Kirow": "Yep, this will help too, but not sure that someone use these deprecated headers\n. ",
    "rfgallagher1": "Nevermind. Problem on my end. \nYour framework is amazing, btw!\n. ",
    "nathanhosselton": "Sorry, I'll get to it by this weekend at the latest as long as that's ok. I've just been super busy this week.\n. Changes are in. Let me know if anything further is needed.\n. The example they gave doesn't map directly into a promises system because they are using a callback twice. And they are using a callback twice because they are combining a synchronous task with an asynchronous one. This wouldn't make sense in a promises system, which is intended to abstract asynchronicity, not fake it. Of course, you could still do it. One example: https://gist.github.com/nathanhosselton/ab23e210ce4c6cab79b1\nBack in the context of the caller you could then use when on realPromise to execute additional code when realPromise resolves. This would achieve the goal of having the UI respond to both the fake request and the real one (i.e. mimicking using a callback twice) with an advantage over the article's example in that the responses would have context and could be discrete. And there are likely plenty of other ways the same effect could be reached; it just depends on the situation and how you've configured your API manager and your model.\nI want to state however that I think this example smells weird, not least because I think it betrays the purpose of promises. Instead, I would look more closely at the context of the request and determine whether the tasks (the fake request and the real request) should be combined and/or coupled to their UI responses in the first place, or whether a fake request is even necessary. My guess would be that there is probably a cleaner way.\n. I agree, @jefferythomas, that system seems to work quite nicely here. Good catch.\n. I don't see an obvious example of startWith's functionality. Can you summarize?\n. Fixed in https://github.com/mxcl/PromiseKit/pull/260\n. #271 fixes\n. I believe this is resolved now as I have no longer have an issue building Bolts with Carthage. But feel free to reopen if it persists.\n. QuartzCore is only used within the CALayer+PromiseKit category. Many of the categories will not be relevant on watchOS, so CorePromise should be all that you need. If not, you can selectively include categories from there.\n. Which part? The documentation currently includes direction for excluding/including the categories. There's no mention of watchOS or tvOS, so that could be added.\n. @morten-holm This is currently planned for inclusion in 3.0.0 which will be released soon (hopefully).\n. Resolved by #272 \n. The latest version (3.0.2, just released) includes proper tvOS support so the workarounds mentioned here should no longer be necessary. Please test and report back. Thanks!\n. Hey there. Have you checked out when? Like you, I am not strong in Swift, so you'll have to forgive me if I haven't discerned all of your requirements. But I've dealt with the scenario you describe multiple times by passing when an array of promises that represent each of the tasks I need completed. If this doesn't meet your needs or if you would like additional examples let me know.\n. I believe the @import PromiseKit is unnecessary and (potentially) the source of the issue, though this is mostly a hunch. Have you tried removing it?\n. I'm confused. This doesn't appear to be a PromiseKit issue. Unless I'm misunderstanding?\n. Are you asking that report pass NSError instead of ErrorType?\n. @XBeg9 agreed, I simply did not understand what you were trying to ask. Given that the individuals in the stack overflow you linked experience the same behavior, I'm still unsure if this is something PromiseKit can or should attempt to resolve. Barring a way to construct objects of ErrorType so that they cleanly cast to NSError, I don't know what can be done. Do you have recommendations?\n. Can you share some of the errors that you're receiving?\n. Fixes #278 \n. Looking into this. Bitcode is, in fact, enabled in the scheme and the scheme builds fine with xcodebuild.\n. This should be resolved with the latest version of Carthage. Feel free to reopen if the issue persists.\n. I worry that the delay may preemptively reject the promise, cancelling out the advantage of ignoring the error in the first place. Unless you have tested that this does not happen.\n. duplicate of #285 \n. Yes, this will be fixed today.\n. 3.0.0 is now available via CocoaPods\n. Sorry about that. Should be fixed. Let me know if it isn't.\n. Hey again. Thank you once more for all of your efforts here. It is greatly appreciated. I'm currently working out how to match this up with some of the work already performed that I haven't pushed yet as there is some overlap and also some differences. But I wanted to go ahead and leave a comment so you know it isn't being ignored. I'll do my best to merge as much of your work as possible.\n. @svenmuennich In the interest of time I have pushed to CocoaPods with what I had working today. I sincerely apologize that I did not end up using any of the work you submitted in this PR. But PromiseKit is working at this moment thanks in part to your efforts. I hope this won't be a deterrent for you to continue contributing in the future as your work was of excellent quality. Please stick around. I'm sure there will be more work to do very soon. And I have proven unable to keep up with it alone.\n. From your description I'm having trouble seeing what purpose this would serve outside of the syntactic. Could you maybe provide an example?\n. Are you simply looking to then on a specific queue? If so, you can use then(on:_:). (See here)\n. @LukeDefeo I'll let Max speak to the time frame (if he can), but in the interim, I will be performing all high priority updates and maintenance. So the library will not be abandoned.\n. @skela Sorry for the delayed response. The Objective-C catchOn block takes the queue parameter. So without testing, I think your method signature and returning method call syntax should be:\nswift\nfunc swiftCatch(closure: (dispatch_queue_t, NSError) -> AnyObject?) -> PMKPromise {\n    return self.catchOn()(objCBlockFromPromiseClosure(closure))\n}\nBut since it appears you're only ever interested in catching on the main queue anyway, just use catch, which always executes on the main queue.\nswift\nfunc swiftCatch(closure: (NSError) -> AnyObject?) -> PMKPromise {\n    return self.catch()(objCBlockFromPromiseClosure(closure))\n}\n. Also, agreed on the inclusion of some extra method aliases whose signatures make their use in Swift nicer. Could maybe provide them in a separate header so as to not unnecessarily pollute the API either.\nI can take this on.\n. > The main reason why I wanted to use the catchOn method is because i think catch is a keyword in Swift 2 \nOh duh. Sorry about that. Still, I don't understand why my first suggestion wouldn't work. Can you post a screenshot?\nHopefully you'll have access to better methods for Swift soon anyway and this won't matter, but in the meantime I'll try my best to troubleshoot.\n. @skela I assume you need a different closure cast as your current one only accepts single-parameter closures.\n. Related: There doesn't seem to be a way to force Swift to accept closures for Objective-C method parameters of type id without extra casting on the Swift end. However, updating the methods to explicitly accept blocks mandates a parameter count for the block, and since Objective-C does not have typed methods, we cannot create multiple versions of then: for each block parameter count. This seems to leave us with still no good way to better support Swift. The following options are all I see at the moment:\n``` objective-c\n//only accepts a single parameter within the block\n- (PMKPromise *_Nonnull)then:(__nullable id (^_Nonnull)(__nullable id))block;\n/\n  accepts arbitrary parameters in the block, but casting would be required \n  on the Swift end for every parameter count\n/\n- (PMKPromise _Nonnull)then:(id)block;\n/\n  accepts arbitrary parameters in the block, but boilerplate code would be\n  required on the Swift end for each method using a vararg signature\n/\n- (PMKPromise _Nonnull)then:(__nullable id (^_Nonnull)(__nullable id, ...))block;\n```\nThe first is a non-starter. The second and third would require Swift code, which we cannot put in the library, and thus would need to be manually added on the application end by the developer. Of the two, the last seems the most viable because it would at least be boilerplate that could be copied+pasted from promisekit.org or something. But then, it's effectively still library code, so the question becomes if that's really any better than it being internal when Swift breaks it next, given that the whole point of using this version of PK is for it to not break with Swift.\nI'm not a user of 1.x in Swift, so I'm unfamiliar with the pains of using it in this way. I'll leave it up to the community to decide if any of these options would be significantly better than what's available right now.\n. TL;DR It seems we're going to need Swift code to make things nicer for Swift, so is it even worth it?\n. @skela Changes between 2 and 3 are also in the README. They are relatively minimal compared to 2. 3 is a progression from 2 whereas 2 is effectively a rewrite from 1.\n. Yes, this was my mistake. I apologize @kdubb, yours should have been the PR that I merged.\nIf you would like to resubmit the PR for the master branch without https://github.com/reTXT/PromiseKit/commit/19a5ffe851ae55fefbbdf83679cf1c5aa6cd2732 I will merge.\n. Merged but, again, had to do it locally, so this PR does not reflect. Closing manually.\n. And thank you, @kdubb! Both for your efforts and your patience.\n. Again, sorry this was never merged. Can you resubmit the PR for the master branch?\n. Your commits are now merged into master. This PR still targeted changes-for-3.0 so I had to perform the merge locally then push and GitHub isn't smart enough to detect so I'm closing the PR manually.\n. This should be resolved with the latest version of Carthage. Feel free to reopen if the issue persists.\n. @mofirouz release it in what way, exactly?\nEdit: I'm assuming you mean pushed to the pod trunk, which I am working on. Will post back when it's ready.\n. So there are numerous failures occurring when attempting to lint the podspec related to the new inclusion of watchOS and tvOS. Aside from the 1.x version of the podspec file not being written in such a way as to trivially handle additional operating system targets, detailed exceptions are going to have to be declared for most of the subspecs' watchOS and tvOS source files, if not in the source code itself.\nFor example, CLLocationManager's startUpdatingLocation method is not available on watchOS or tvOS. On the master branch we simply don't include the CLLocationManager+PromiseKit source files for watchOS in the podspec (which is really a workaround since the functionality could theoretically be provided for those OSs), so the same could be done for 1.x, but this is just one of many updates that will be required. And again, the 1.x and 3.x podspec files are currently very different, so this unfortunately isn't a case where we could just copy+paste.\nAll this is to say that pushing 1.7.0 to the cocoapods trunk is going to take longer than expected. I have done minimal work to this end since pushing the latest changes to the legacy-1.x branch, so if you were interested in taking this task on then you could start from there. Otherwise I will chip away at it when I can.\n. OK, I think I understand what changes need to be made to the podspec file now. I can probably knock this out tonight or tomorrow.\n. Alright, 1.7.0 should be available via CocoaPods now. I tested it locally with watchOS and tvOS targets and everything seemed to be fine, but let me know if you try it out and have issues.\nFor now I had to make the general sacrifices that I mentioned above in order to at least get it to lint, so some of the category subspecs are unavailable on watchOS and tvOS, most notably the NSURLConnection category. I've left comments in the podspec file at the subspec lines which can work with tvOS/watchOS but don't currently due to API availability differences, so anyone who is feeling adventurous enough can try to take those TODOs on.\n. Duplicate of https://github.com/mxcl/PromiseKit/issues/326\n. The NSHTTPURLResponse object is one of the key/values in the error's userInfo dictionary and contains the status code. I believe you can access it like so:\nswift\nlet response: NSHTTPURLResponse = error.userInfo[PMKURLErrorFailingURLResponseKey]\nprint(response.statusCode)\nBut I have not done this in Swift, so let me know if this doesn't work.\n. PromiseKit should now have proper tvOS support.\n@tjdhome I want apologize that your contribution was not utilized in said support, but would still like to thank you for your time and effort towards making PromiseKit better. It is always appreciated.\n. Seems fine. PR welcome.\n. Resolved by #374 \n. @randomiser I think this topic probably deserves it's own discussion thread. If you would like to make a proposal of sorts we can definitely consider such a feature.\n. Is this still necessary?\n. Thanks for this. Is there some way that PromiseKit could be cleanly updated to resolve this problem that you know of, or should this workaround simply be included in the documentation?\n. Seems simple enough. If you'd like to submit a PR I will merge. Otherwise I will include this with the next round of updates. Thanks again for pointing this out.\n. In cases where it makes sense, promises should always be resolved. In @ehuynh's example, I would argue that the user dismissing the view without selection is 'cancellation' and therefore the promise should be rejected with cancelledError().\nMore broadly, if someone receives this message and it is not a bug - i.e. the developer wants the promise to deallocate without resolving - then the message I think can serve as a tip that the promise system has perhaps been configured incorrectly, or that promises aren't the right tool for the job. So I think the message still has value.\nHowever, I understand that there may still be situations where conditions arise that make logical flow towards promise resolution fuzzy, so for these cases I can agree that a mechanism for silencing the warnings could be warranted. At this time I'm not sure what that would look like though. Ideas and PRs welcome.\n(Edited 3/3/2016 for added clarity)\n. Currently, unless you are using one of the categories that inherently support cancellation (e.g. UIActionSheet), the only supported way to \"cancel\" a promise chain is from within the chain itself using cancelledError(). Although I have not done this myself, a solution for your situation might be to create your synchronization promise with pendingPromise() so you have access to the fulfiller and rejector outside of the promise chain. Then in your cancel button handler you can reject the promise with cancelledError().\nAgain, I haven't tested this, but it sounds like it should work in theory. Let me know how it goes if you try it.\n. Actually this won't work. Sorry, I need to think on this some more.\n. Alright, sorry for getting back so late on this.\nUsing Swift, you could do what I detailed before and then wrap both the promise from pendingPromise() and your syncAllData() promise in a when. That way, when the cancel button is pressed, you could call reject() with the cancelledError() and your sync would halt (because when rejects as soon as any of its containing promises reject). Likewise, you could add a then handler to the end of your sync chain to call fulfill() once it completes, satisfying when. I think this would work and would satisfy your requirements.\nUnfortunately, pendingPromise() is only available via Promise<T> and not AnyPromise, so you'd have to write some Swift to get access to it in your Objective-C code. I am not sure what Max had in mind for his solution, but I don't currently see any way to do this using AnyPromise. I didn't realize there wasn't an analogue for pendingPromise() on AnyPromise, so that's something I'll probably try to add to PromiseKit in the near future.\n. What are you including in your Podfile?\n. Also include pod 'PromiseKit/CoreLocation'\nIncluding all categories was the default prior to 3.0.0 but appears to be no longer.\n. I think it makes the most sense on when/join since it doesn't seem the parameter will have relevance outside that context. But then again, this makes the implementation potentially prone to duplication compared to if the functionality were on error. Perhaps this is why Max didn't specify one over the other. Regardless, it sounds like you have enough knowledge of the issue to select the solution that makes the most sense. Your PR would be happily accepted.\n. Good catch. And sorry for the delay. In reviewing, I noticed that promiseWithAdapter: on line 219 in the same file similarly needs updated to promiseWithAdapterBlock:. If you wouldn't mind also including that in your PR I will merge.\nThanks for the contribution!\n. Yes, the return type must be specified for complex closures or the Swift compiler becomes confused. So the following should correct the error:\nswift\n}.recover{ error -> () in\n    //...\n}\n. Thanks for the contribution! I think this is a good idea but the code duplication isn't ideal. If the implementations can be identical, as it seems they can, I would recommend simply having one method call the other. Though I would imagine you thought of this so perhaps there's some reason why this isn't trivially possible.\n. Resolved by #374. But nevertheless, your efforts are very much appreciated @paweljankowski.\n. I've seen this before but it didn't immediately jump out at me so while I knew it wasn't an PK problem I was coming up empty handed with an answer for you. Happy you figured it out. And you're right, seems like a Swift shortcoming.\nAs an aside, and for my own curiosity, does your error handler get called as expected? Asking because I've never attempted adding a handler to a promise chain in this manner (i.e. outside of the initial chain). I see no reason why it wouldn't of course, just wondering.\n. @w0mba7 can you post the full promise chain (i.e. what comes before }.error {)?\n. @gunnarblom did you try it with the syntax in orj's answer? { (error:ErrorType) -> Void in\n. With the merging of #397 as an interim workaround, this issue should now be permanently resolved. If Swift is still not able to properly infer the use of error() by the time we next reach a point where a major semantic version bump is required, we will rename it. More than likely this will not be until Swift 3.0 is released.\n. Thanks!\n. I'm not sure if this is related to your issue, but why are you seemingly calling fulfill and reject on the main queue? Even if it's not the issue, this could certainly cause side effects. Allow PromiseKit to execute as designed. You can access the value of the promise on the main queue via then and catch after it resolves. See error handling.\n. If this doesn't resolve your issue let me know. Nothing else in your example immediately stands out to me, so I may need more detail.\n. See: when (or alternatively: join)\n. Sorry for the delayed response. If you haven't already, try specifying the return type in your closures that are returning promises. This has historically satisfied the Swift compiler in circumstances like these.\n. Currently there is a changelog maintained at promisekit.org but I will begin including release notes in the tags as well for future releases. Thanks for the recommendation!\n. Indeed, maintaining separate changelogs and even summaries in tags is painful. Especially considering all of the information already exists and GitHub simply doesn't surface it well.\nYou probably already know this, but it's possible to view the repo history by tag via the branch selection dropdown. You can select Tags instead and jump to a specific tag's point in time. Maybe this helps. Obviously would be more helpful if GitHub only showed commits specific to a tag.. Thanks!\n. @b123400 Swift should be performing the bridging automatically. I am unsure why this isn't happening.\nI've included new convenience inits in #359 as a workaround. @mxcl If you think this is the way to go I will merge.\n. @b123400 I did some testing with your code as well and I agree that your examples seem to pinpoint the source of the bridging failure, although to be a bit more specific it seems to only fail when the parameter is both generic AND optional. The closest reference I could find to this issue is this SO question whose answer indicates that the issue is really to do with not being able to cast optionals to AnyObject or vice versa. This is in line with PK's implementation as well as AnyPromise's default initializer takes a T? where T conforms to AnyObject, and each of the convenience initializers added to work around the bridging issues for the ObjC types accepts strictly T.\nIf this is the case (and I could be off base) there seems to be three possible courses of action from here:\n1) Continue adding convenience inits for these exceptions (simplest resolution though not as nice)\n2) Replace AnyObject conformance with Any in the designated AnyPromise init (based on my testing, I think this would work)\n3) Remove the optionality of T in the designated init.\nUnfortunately the latter two would require substantial refactoring in the PromiseKit codebase - the implications for which I have yet to fully research - and as such could potentially demand a 4.0.0 release. I'm also unsure if the reasoning behind making the designated init accept T? extends beyond simply allowing users of the library to pass nil (an expected convenience to be sure but perhaps unnecessary?). I suspect not, but I don't know as of now.\nRegardless, I think this topic demands some community input.\n. Went ahead and merged the fixes for now but I think the discussion mentioned in my last comment is still warranted. Reopening.\n. Promises do not create retain cycles, so it's safe to use self in the handlers. Meaning that you won't even need to think about this the majority of the time. In fact, retaining self is probably what you want so to allow the promise to resolve before self is deallocated.\nIf you reach a situation where you do want self to be allowed to deallocate before your promise resolves then that's when you would employ weak or unowned. I believe the latter will catch in your error handler should it come up nil, but if you go this route I recommend testing. If you decide to use weak then you will need to refactor your promise chain to account for optional promises, which is why your second example did not compile.\n. Not sure what exactly you're going for, but you can create a rejected promise with Promise(yourErrorType) which is a bit cleaner.\n. Thanks for this! I see that you posted in the gitter chat about getting this under testing. Let's see if we can get that working before merging.\n. This looks good! Again, so, so sorry for the month+ delay on this. Do you mind rebasing onto the current HEAD of master and resolving the conflict? It's just the new Bolts framework reference. Keep the new reference and delete the old one (line 89 in the project.pbxproj file). Then this can be merged.\n. Went ahead and rebased on my end. GitHub did not detect. Closing manually.\n. Shouldn't be a limit. Certainly not with 10 anyway. How can you be certain the build hangs are due to PromiseKit? Can you share your specific code? Your examples look fine.\n. The content of the methods and closures may in fact be relevant. Unfortunately I don't think I can offer much assistance without seeing more as I cannot reproduce the issue.\n. I agree that this sounds like an issue that needs resolved. I'd like to not have anyone prevented from using PromiseKit just because their configuration is different. And automated build systems are fairly common. However, I'm hesitant to introduce that level of complexity into the project just for Carthage. Forgive me, I haven't used an automated build system myself and am not super familiar with Carthage; can you elaborate a little more on the specifics of the issue?\n. Sorry, my questions was why specifically is copying the relevant category files into the Carthage checkout folder not sufficient under your automated build system? Again, I'm asking because I'm not familiar with your situation, so I'm trying to understand.\n. I believe the intention with pendingPromise() was for the user to hold references to each of the values in the returned tuple individually rather than the tuple itself. May I ask what your needs are that you are retaining the tuple? I agree that a typealias would make sense here if that's the case.\n. This makes sense. But I'm assuming when you need to call fulfill and reject or access the promise you then do pendingAdd.fulfill() etc. My question was why not create separate properties for each of the values in the tuple (the promise, fulfill, and reject) as I believe this was the intention and why a typealias wasn't provided.\nHopefully I'm not coming off as trying to be difficult because that's not my intention. Just trying to understand your needs before moving forward.\n. What I meant was:\n``` swift\nclass Foo {\n    var promise: Promise<(String, NSDate)>?\n    var fulfill: ((String, NSDate) -> Void)?\n    var reject: ((ErrorType) -> Void)?\nfunc startPromise() {\n    (promise, fulfill, reject) = Promise<(String, NSDate)>.pendingPromise()\n}\n\n}\n```\nWhich I think is a little cleaner if only because it breaks the declaration down into smaller pieces that are easier to digest. However, you're onto something in that there appears to be some sort of Swift shortcoming that prevents the mapping of tuples when the references being assigned to are declared Optional. So in order for this to work, I had to do:\nswift\n    func startPromise() {\n        let t = Promise<(String, NSDate)>.pendingPromise()\n        promise = t.promise\n        fulfill = t.fulfill\n        reject = t.reject\n    }\nWhich is slightly better than having to access the values via the tuple whenever you need them, though I'll admit not by much. However, I can't see how the introduction of the typealias will skirt this issue since you'll still be declaring the property as optional and, more than that, the values within won't be typed. Have you tested? I have attempted to but am having some Xcode problems at the moment.\n. Ah I see. I misunderstood how typealiases worked with generics. The typing is not an issue with the typealias, but the optional mapping of the tuples still is. I receive the same error with the typealias property as I received before and that I assume you received with your third example in your message before last. I think this would be a valuable addition to PK if we can make it work, but I don't understand why we're having different experiences at the moment.\n. I apologize, I realize my last response wasn't entirely constructive. I implemented the same as in your prior example and all is fine until I actually assign to the property the return value of pendingPromise():\nswift\nself.pendingAdd = Promise<(String, NSDate)>.pendingPromise()\nOn that line, I receive the tuple mapping error I've mentioned previously that I believe to be a Swift issue:\nCannot assign value of type '(promise: Promise<(String, NSDate)>, fulfill: ((String, NSDate)) -> Void, reject: (ErrorType) -> Void)' (aka '(promise: Promise<(String, NSDate)>, fulfill: (String, NSDate) -> (), reject: ErrorType -> ())') to type '(promise: Promise<(name: String, date: NSDate)>, fulfill: (name: String, date: NSDate) -> Void, reject: (ErrorType) -> Void)?'\nJust to be safe I also updated the PK source to match your PR but had the same result. Again, I'm not sure why our results would conflict with the same apparent code. Let me know if you have any ideas.\n. OK, I think I have this all figured out, the result being that your typealias inclusion definitely has value.\nThe reason it wasn't working for me was an error on my part. I had included the parameter names in the property declaration but weren't including them when I was actually assigning to the property. It works either way, as long as there's consistency with the parameter names. And the typealias for the pendingPromise() return value does help a lot by cutting out all of the complex syntax when assigning directly to an optional tuple property as you are doing:\n``` swift\nclass ViewController: UIViewController {\n    private var pendingAdd: Promise<(String, NSDate)>.PendingPromise?\nfunc waitForAdd() -> Promise<(String, NSDate)>  {\n    pendingAdd = Promise<(String, NSDate)>.pendingPromise()\n    return pendingAdd!.promise\n}\n\n}\n```\nIn contrast, this is the best solution I could find for holding separate properties for each of the returned tuple's values:\n``` swift\nclass ViewController: UIViewController {\n    var promise: Promise<(String, NSDate)>?\n    var fulfill: (((String, NSDate)) -> Void)?\n    var reject: ((ErrorType) -> Void)?\nfunc waitForAdd() -> Promise<(String, NSDate)>  {\n    let (p, f, r) = Promise<(String, NSDate)>.pendingPromise()\n    promise = p\n    fulfill = f\n    reject = r\n    return promise\n}\n\n}\n```\nWhich I don't think is bad by any means, but it's certainly not as clean if the preference is for a single property.\nThe reason (promise, fulfill, reject) = Promise<(String, NSDate)>.pendingPromise() doesn't work is because the properties are optionals and the values in the returning tuple are not, therefore they do not map and must be explicitly assigned outside of the tuple. So when it is not possible to call .pendingPromise() during the calling class' initialization one of the above patterns must be used. And I think it makes sense to provide the typealias for those who would prefer the single-property pattern.\nSo that brings us to naming. I agree that \"PendingPromise\" is preferable to \"ExpandedPromise\" since it is more specific to its related method, and even though it may be a little confusing to name the typealias for the return value of a method the same as the method itself, it kind of makes sense. So if you want to rename it on your fork I will merge. Or I'm happy to pull the PR locally and make the change. I'm going to add some documentation anyway. Up to you.\n. Good point. Hadn't even thought of that yet.\n. Thanks!\n. Unfortunately there are a number of methods/classes used among the PromiseKit categories that were deprecated in iOS 9 that we will have to continue to support for the time being (UIAlertView etc). I've looked into updating this specific method but it does not trivially map to its replacement. I'll leave this open anyway because unlike the other deprecations it should be possible to update this one without breaking the API. PR welcome.\n. Without seeing your code, I'm assuming your promise types are varying. Due to the nature of Swift, Promise when() can only accept up to three promises when the types do not match (technically we could include more, but we'd just have to keep adding definitions for when() with the explicit number of parameters). If you need to have more than three promises of varying type in a when, you'll need to use PMKWhen on AnyPromise, which is more dynamic.\nIf you believe this isn't your issue, please share the relevant code and I'll review.\n. Create a bridging header if you haven't already and in it #import <PromiseKit/PromiseKit.h>.\n. Yes, it should be rejecting immediately if one of the passed promises was rejected. I'm not sure why it would be fulfilling.\n. I believe I ended up addressing this myself recently when I ran into the same issue without remembering that this PR existed. So my apologies.\n. Closed by https://github.com/mxcl/PromiseKit/commit/3b079f6dd6f0c67d85c6ef02f9ed42804dfe4171\n. Not sure if it's proper to take someone else's code. Push up your fix though. I'll see if @rbobbins would like to resubmit her PR with only the tests. Or we'll figure out some other arrangement. You both have contributed so I think both of you should be credited for your respective work.\n. Will review at length ASAP. Though at first glance everything seems good.\n. Thanks a bunch to @feighter09  and @rbobbins both.\n. Hah, yes, well #374 came in just before yours did. Your tests are much appreciated though. Would like to include them.\n. Duplicate of #374 \nI apologize that your effort went unthanked this time around but please continue to contribute!\n. Will remove the : here and give a look through the rest of the directory tree to ensure we're not using any reserved characters elsewhere.\n. Agreed on the new branch. Not sure what to call it though. 1.x would work fine, but its purpose would not be self evident. Something like objc? Open to suggestions before creation.\n(Edited: including the library name in the branch name is redundant)\n. I think I like 1.x more despite my own criticisms. Will go with that unless there's objections.\n. The new branch is now available at legacy-1.x. Sorry for the delay.\n. Thanks!\n. Thanks for your and @tonyarnold's diligence in researching and correcting this.\n. Sorry for not merging this yet. Been caught out of town in a snowstorm. In my initial review I didn't notice any API breaking changes but I would like to give it a second look to be certain before merging. Probably later today.\n. Will bump the minor version and get this into CocoaPods by tomorrow evening.\n. > In order to use the full advantage of typed Promise<T>, I came up with this downcasting approach\nCan you provide some examples where you're using the converted promise in a way that you could not with its AnyPromise counterpart? This may help me figure out what the best solution here is. I've personally never needed to cast an AnyPromise to Promise<T>, and don't recall it ever coming up before, but that doesn't mean there isn't a valid use case for it.\n. Understood. This makes sense and seems necessary, so I agree this should be added.\nEventually we may have implicit casting, but we can't wait for that.\n. Sorry for the delay on getting to this. I've been reviewing it off and on since submission, and have been trying different approaches to make this better, but I can't find any I like. This seems to be the best implementation we can provide at this time (at least that I have found).\nI would however like to make some adjustments to the documentation and maybe add some tests. I'll simply amend/squash them onto your commit before merging if you approve.\n. Thanks for the notice. Though, the minimal changes branch was never meant to be a continually supported version of PK, I'm sorry to say. It was mostly provided as a convenience to prevent forcing users to adopt all changes of PK3 right away. If it is now broken, it's unfortunate, but it's unlikely that one of us will get to it unless there is an outpouring of requests or some greater need emerges. And in fact, any updates would likely need to go on a branch off this one, as updating to support Swift 2.2 would break compatibility for anyone relying on this branch for Swift 2.0 support. Of course if someone were to provide a PR, we could merge it into a new swift-2.2-minimal-changes branch, but officially it's not something that is in scope.\nAgain, apologies. But due to already-strained developer-hours available from primary contributors, our focus will likely remain on the critical branches for the foreseeable future.\n. @brianhv thanks for pointing us to this. I've messaged him to ask if he would like to open a PR. If not, I guess I'll just apply this myself after all as it is quite tiny, assuming nothing else needs to be done.\n. #393 looks like what I would expect the TODO intended. However, it seems to me that this would be API breaking, so I cannot apply it to master as-is without a major version bump.\nThough it would add complexity, I think ideally the interim fix would check if initialization of the [err class] returns nil and only in that case utilize this new solution. It's still not ideal, but at least this way we aren't breaking error handlers in our users' codebases and we don't have to wait for or force a major version bump to fix this issue.\nSince this is such a special case, I think it would also be warranted to print to the console when execution is forced to follow the new path, letting the user know that they need to use the NSUnderlyingError key of our userInfo dictionary to access their own. This message, along with the old implementation, would then be removed with 4.0.0 where we would document the new process for accessing the underlying error of a failed PMKWhen.\nAn alternative would simply be to crash when we can't reproduce the error object and inform the user that PMKWhen is not supported in Swift. I don't like this as much, but it's the easiest workaround.\n. Ah, well that's not really nice. I dislike the idea of checking for the specific class, even if it is likely to catch all of the cases we want. Perhaps we should catch the exception then, since this crash is our own fault, not the library consumer's.\n. The above would require a little extra syntax for it to work within the macro:\n``` objective-c\ndefine NSErrorSupplement(_err, supplements) ({ \\\nNSError *err = _err; \\\nid userInfo = err.userInfo.mutableCopy ?: [NSMutableArray new]; \\\n[userInfo addEntriesFromDictionary:supplements]; \\\nid whenErr; \\\n@try { \\\n    whenErr = [[[err class] alloc] initWithDomain:err.domain code:err.code userInfo:userInfo]; \\\n} \\\n@catch (id exception) { \\\n    whenErr = [[NSError alloc] initWithDomain:err.domain code:err.code userInfo:userInfo]; \\\n} \\\nwhenErr;\\\n\n})\n```\n. Neither option is especially nice and they're both temporary. So choose whichever you think is best.\n. We can check for a class by string if we know the class name (and we do):\nobjective-c\nif ([NSStringFromClass([error class]) isEqualToString:\"_SwiftNativeNSError\"]) {\n    // instantiate generic error and print instructions for accessing underlying error to the console\n} else {\n    // recreate the error (current method)\n};\nIf we must hard code the class name then so be it. It's probably safe.\n. Good find! A PR would be great. And it sounds like you satisfied that TODO.\n. Thanks again!\n. > I do not know what could break by not building the test targets together with the framework targets.\nNothing breaks to my knowledge, but this does prevent us from conveniently running all tests associated with a target. Instead, they much be run individually or associated with a new scheme that groups them together (e.g. \"PMKiOSTests\" which would link the test targets previously associated with the PMKiOS scheme).\nThe latter of these alternatives isn't terrible but it does feel unnatural to me and I think shouldn't be necessary. It's unfortunate that associated test targets must be built with their parent target even when tests are not being run, but Xcode doesn't appear to give us any way around that. Perhaps it is better to simply code sign the test targets? I'm not sure why they are not currently, and I can't think of what issue this could cause.\nI'm also not sure why this warning is appearing in the first place. Taking it at face value, it should only appear when code signing entitlements are specified, but there are none for any of the test targets. Only the host app target for UI tests has code signing entitlements set, and it also has a code signing identity set.\nIf you can, try code signing the test targets to see if that removes the warning without adverse side effects. If so, I think that's probably the way to go.\n. > Since I'm getting the dependency via Carthage and the build warnings appear on carthage update, I'm not sure what I would have to do to influence the signing process to work different to the way it does now. Any suggestions?\nSorry, I realize now that's not a thing you can trivially test.\nThinking on this more, is this causing Carthage update to fail or otherwise preventing use of PromiseKit via Carthage? Or is it merely an informational warning that Carthage passes along from xcodebuild? It sounds like it's the latter, but I'm not sure why I'm not also seeing these warnings.\n. OK, I assume xcodebuild doesn't set a code signing identity for targets by default. I have one set for PMKiOSUITestsHost on my end, so I do not see the warnings. But when using carthage update, it builds before a valid identity can be set. Thus, the warnings appear.\nNot really sure what can be done about this. I thought it was that the test targets needed a code signing identity set simply because they were associated with the test host app target which contains entitlements. But it sounds like the problem is simply what I stated above, which means there isn't anything that can be done as I would expect that even creating a new scheme specifically for the tests would still cause this issue. Sorry if you understood this from the start and had to wait until now for it to click with me.\nYour PR does fix the issue, but it also prevents us from being able to run the tests, so I cannot merge it. Assuming I'm understanding the problem correctly (and perhaps I am not), this seems like an issue that Carthage needs to solve rather than developers working around it.\n. Looks good to me \ud83d\udc4d. Will get merged tomorrow and pushed up to cocoapods if I don't hear otherwise from @mxcl.\n. Hey sorry for the delay. Thought of something in the meantime though. What expectation are we setting with these alternatives in terms of their longevity? Obviously they're meant to be temporary, so should we explicitly state that in their documentation, or even mark them as deprecated from the start to more strongly convey that? Or is that to heavy handed given that we can't necessarily expect this issue to be resolved even by Swift 3.0?\n. Ok, I think these aliases should be marked as deprecated then since they're only intended to be used as a temporary workaround for cases when the Swift compiler cannot be made to distinguish between the originals, and they will be removed as soon as...\n1. Swift is updated to better handle our names, or \n2. we decide on permanent name alternatives...\nwhichever comes first. The deprecation warnings and/or documentation should communicate this so users don't become dependent on these aliases or use them inadvertently. It think this PR can be merged in after that and we can start planning what the final solution will be.\nNaming is hard. PK's current prefix-less naming scheme felt more complete when we could still use catch. Though I like the name onError better than simply error, it's inconsistent with our other handler names, so ideally the naming scheme as a whole would be revised before we keep it (which is an option of course, though I like all of our other names). Otherwise we need another name for error(), since I like error as the property name.\nI digress, though; that's a conversation for a different thread.\n@ReneB do you want to include the deprecation warnings in your PR, or do you prefer I add them? Either way is fine with me.\n. @ReneB no problem. Will get this added in and merged by tomorrow probably.\n. @ReneB Done. Thank you again for the excellent recommendation and the PR!\n. Thanks!\n. Short answer is no. Our PMKAlertController does not expose its underlying UIAlertController and doesn't currently have a cancelPromisedViewController method in its UIViewController extension. However, this would be a trivial addition: https://github.com/mxcl/PromiseKit/blob/master/Categories/UIKit/PMKAlertController.swift#L70\nPR welcome!\n. Actually I guess it wouldn't be all that trivial now that I'm really looking at it. We will have no reference to the PMKAlertController instance from the UIViewController extension. So the options then would be to either pass the PMKAlertController instance back into the new cancelPromisedViewController method, which does follow UIViewController's dismissViewController API that we would be mimicking, else place the method on PMKAlertController itself, which would be inconsistent with our own API.\nStill, neither option would be difficult. It's just deciding which one to go with. I think I'm personally leaning towards the former.\n. Thanks! Been meaning to add this myself and kept forgetting.\n. Fixes #390 \nMerged into new branch swift-2.2-minimal-changes. Thanks!\n. I do not have knowledge of Max's intentions with this part of the API, and I do not speak for him. But from my perspective they seem to be provided out of convenience, since the NSURLSession API is somewhat clunky I think, and for me at least they fulfill on that goal. But I can understand that working with them, especially if refactoring existing code that uses NSURLSession's default API, may not always be convenient. Is this your concern, and is the provided promise(request:) on NSURLSession then not sufficient?\nI am open to the idea of providing more familiar methods with the extension. Is @jschmid's implementation in line with what you're seeking?\n. Looks good to me.\n. Tomorrow morning if not tonight!\n. Squashed and merged. Closing manually.\nThanks again, @programmerdave!\n. Nice. Thank you. This test is a little frustrating because the dates also seem to inconsistently change with new versions of iOS. So I'm always updating it. Hopefully this will make it more resilient in addition to solving the time zone issue you found.\n. Can you provide a code example?\n. Which version of PromiseKit are you using? How are you including it in your project (CocoaPods, Carthage, other...)?\n. We have no documentation on writing tests, but PromiseKit itself is very well tested. I'd imagine you could reference our tests and come up with some ideas for how to test your own promises.\n. Thanks for reporting. Check in over at #415 as it appears to be a dup and will be where discussion is continued.\n. Many thanks for the test project. Looking into this now and will get back on it ASAP.\n. Unfortunately I haven't had extensive time to research this today, though I am giving it as much time as I can. More than likely though this is simply a swift bug. And although there may be a way we can work around it in our code, it might be simpler to just revert to the prior version of Xcode for the time being or, if you're not using it, remove the NSNotificationCenter+Promise.swift file. In the meantime I will continue looking for a solution.\n. @rad3ks This doesn't work for me. I receive the same error whether I'm using your branch or modifying my own local source to match your changes. No sure why it is working for you.\nA clash between the class method name and the instance method name would be weird anyway. I would expect much more to be breaking if that were the case. Then again, who knows what's really going on right now.\nIn my testing, commenting out the class once moved the seg fault down to the instance once. Commenting that one out only moved it down to the init on NotificationPromise. So a name clash does not appear to the be the issue.\n. Removed my prior comments as they were just noise.\nI have personally found once useful and also dislike the idea of a premature version bump. But if it gets the library back into an archivable state with the current Xcode version perhaps it's worth it.\n. Our sincerest apologies that this fix was over two months delayed. Things should be back to normal now with 3.2.1 which is currently being pushed to the Cocoapods trunk.\n. Well, during linting another seg fault occurrence was revealed. This appears it will be an issue most of the places that we use pendingPromise(), which is 6 or 7 other classes. The current fix I think could be applied in each case, but I'm going to research a little more to see if I can come up with a better fix and maybe identify the specific compiler issue to include in the open radar along the way. I won't delay much longer though, I promise.\n. Found a better workaround. Patch incoming either later tonight or early tomorrow.\n. Alright, I think we're good now. 3.2.1 has the fix and is live on the Cocoapods trunk. If you updated to 3.2.1 yesterday you may need to pod cache clean PromiseKit and pod install again.\nAgain, apologies to all and thanks for bearing with us.\n. All the first script does is cd to the directory of the Xcode project that is currently open. It's just a shortcut. You can cd manually otherwise. I will fix it though since it does need to be able to account for spaces in directory names.\nAnd the second script simply closes the Xcode project file and opens the new Xcode workspace file that is created after running pod install. So you can also do that manually.\nNot sure why cocoapods is forcing you to specify an Xcode project file. Did you put your Podfile in the same directory as the Xcode project file? You can also just do what the error says i.e. in the Podfile specify the path to the project file relative to the location of your Podfile.\n. Also, welcome to iOS! We're stoked you're starting off with PromiseKit.\n. Thanks for the report. Currently tracking in #415.\n. Thanks. Currently tracking at #415.\n. @jonasman Interesting. Can anyone else having this problem confirm that a clean cocoapods install resolves the issue?\n. Closing manually since GitHub will not auto close commits not merged into master.\n. Yep, this is currently being tracked in #415. Check out that thread for some workarounds while we either wait for Apple to fix this, or commit a workaround ourselves.\n. > It seems that this has something to do with NSURLConnection deprecations.\nCan you elaborate?\nIf there is no key, then there was no NSURLResponse generated by the underlying sendAsynchronousRequest:queue:completionHandler: call on NSURLConnection. I'm not sure why this would happen, but you could set a breakpoint on line 91 of NSURLConnection+AnyPromise.m to verify.\n. > sendAsynchronousRequest:queue:completionHandler: was deprecated on iOS 9.\nRight, I wouldn't expect that to affect the response though. That's why I asked if you had more insight.\n\nI'm not sure what you mean with \"If there is no key\", but the rsp (line 91) is nil.\n\nWe only create the PMKURLErrorFailingURLResponseKey key in the userInfo dictionary when there is a corresponding value. In this case, response does not have a value, so there is nothing to pass on in the userInfo dict.\n. Pushing to trunk now. TYVM.\n. Hey there. Thanks for this! Currently reviewing and will provide feedback (by tomorrow I hope). I know you mentioned that you will be including tests. We will need them before merging, so feel free to push those whenever you have them. Things like ensuring the max pending promises and max promises in queue are not exceeded and checking for races on their counters come to mind immediately.\n. That's fair. This looks good on first glance and I don't expect major changes but better safe than sorry with your time, for sure.\n. Alright so after spending a bit of time reviewing and playing with it, I don't have any concerns with the API; I think it's solid. But I am seeing some opportunity for refinement. Potentially. I'm going to take a bit more time and construct some proposals to see what you think. I think this could be elevated above a niche feature to something a bit more intrinsic to PK itself - perhaps even integrated into existing functions (e.g. when, join). But, again, I need to think on it a bit more. It may end up being better as is.\n. Interesting. I've not see the GeneratorType protocol used before. Feel free to push that change up if you'd like.\nSorry I have not followed up yet. I wanted to collect more concrete thoughts but while I'm here I'll go ahead and mention some of my observations thus far:\n\u2022 @mxcl mentioned using a term other than queue and I feel like chain is a logical replacement.\n\u2022 I disliked generator as a parameter name initially, but perhaps it will make more sense with the changes from your prior comment.\n\u2022\u00a0Mirroring a comment from @mxcl, I feel the generator closure on when is unintuitive. Reading a call to the function, it isn't obvious what the trailing closure is for. This is somewhat exacerbated by the fact that our API frequently uses trailing closures as completions. A possible solution may be to require passing a fully constructed PromiseQueue object to the function, but I also liked the abbreviated nature of it preventing this extra effort, so I'm conflicted. Since the function doesn't actually take any promises, perhaps we shouldn't even call it when.\n\u2022 I'll handle all the documentation so don't worry about this.\nI'll of course keep digging through and thinking on all this but if you have thoughts please feel free to share.\n. @shergin I would say so.\n. I have a minimal changes branch for Swift 3.0 incoming. Better updates to follow.\n. Up at https://github.com/mxcl/PromiseKit/tree/4.0.0-beta1\n. This is something I overlooked. Apologies. I will get it updated ASAP.\n. Updated and pushed. Try it now @warpling.\n. Not yet. Hopefully soon. Not really sure what Apple is planning with 2.3 vs 3.0 in terms of Xcode 8 GM. If both are available and non \"beta\" at that point in time then 2.3 support will probably be merged in for the final PMK 3.x release, with Swift 3.0 support rolled into the PMK 4.0 official release at the same time (assuming PMK 4 is ready).\n. There is now a swift-2.3 branch which should compile.\n. New branch up with changes for Xcode 8 beta 2: https://github.com/mxcl/PromiseKit/tree/4.0.0-beta2\n. PromiseKit 3.0 can be used for both Swift and Objective-C, it's just nicer when used with Swift. Legacy PromiseKit 1.x is pure Objective-C and is therefore nicer if you aren't using Swift. Apologies that the docs were not clear enough on this.\nSpecifying a target in your Podfile is good practice but shouldn't be necessary (unless something was changed for Cocoapods 1.0). What issue did you run into?\n. Agreed. Docs really need to be gone through with a fine tooth comb at this point. Then again, a lot of things will probably be changing again with Swift 3.0 and PMK 4.0, so maybe it's not worth it just yet. I'll give myself a todo for these tasks though unless you'd like to submit a PR.\n. Thanks!\n. Closes #456 \n. Our 4.0.0-beta branches are Swift 3.0 compatable.\n. Probably http://promisekit.org/sealing-your-own-promises/ is a good place to start. It even has examples that use Parse.\nAlso, building off the prior example, if you only want two() to run when one() is successful (which is the common pattern), you would use then instead of always and act on failure of either within error:\nswift\none().then { (likes) -> Promise<[Post]> in\n    // handle likes...\n    return two()\n}.then { (posts) in\n    // handle posts...\n}.error { (error:ErrorType) in\n    // Display a message to the user, etc\n}\nAgain, presuming that one() and two() both return promises.\nNote that error ends the promise chain. If you wish to handle an error and continue the promise chain you would use recover before error.\n. Only values/objects returned from the immediately preceding then are available in the following then. If you want access to earlier things, you could, for example, construct tuples to pass along in order to avoid leveraging variables at a higher scope. This was just my immediate thought though. May not be the best solution.\n. I've not looked into ReactiveX/RxSwift, but our brief on Reactive Cocoa is probably relevant (from our docs):\n\nReactive Cocoa is amazing, but requires a large shift in the way you program. PromiseKit is a happier compromise between the way most people program for iOS and a pure reactive paradigm. However, reactive programming is probably the future of our art.\n. Otherwise this LGTM.\n. The swift-3.0 branch is not yet released, so your podfile will have to be:\n\npod 'PromiseKit', :git => 'https://github.com/mxcl/PromiseKit.git', :branch => 'swift-3.0'\nuntil that time.\n. @gsabran There is no released version of PMK with Swift 3.0 support. So the only other thing the readme on that branch could say is the above. Is that what you're asking?\n. @gsabran Gotcha. Sorry for the confusion. Eventually the branch will be pushed to pods and merged to master, at which point it will be accurate.\n. @gsabran A thought: ensure the setting is also configured in the Pods project for the PromiseKit target.\n. I'm unable to reproduce. Can you provide a test project?\n. According to the Quality Indexes documentation, greater than 90% of the public API must be documented for the pod to receive this badge. At the time of this comment we are at 80%. The live status can be checked here under \"doc_percent\".\n. The default subspecs for PromiseKit include our Foundation, UIKit, and QuartzCore extensions. So we provide the PromiseKit/CorePromise subspec for when you don't want those.\nLooking into the conflict.\n. Hmmm. What's in your podfile? Might recommend blowing away your Pods directory and doing pod install again if you haven't.\n. It should be installing 4.0.2. If it's installing 4.0.1 then something is amiss with cocoapods. Blow away your Pods directory, do pod repo update and then pod install.\nEdit: Thanks Max. Didn't realize 4.0.2 wasn't pushed yet.\n. Intentional, but discussion is welcome.\nDupes #548 and #549.\n. You're not handling errors. We think you should be, so we don't allow results to be discardable as our way of pushing developers to terminate all of their promise chains with acatch. Although you can also silence the warning by assigning the result to _. See also #548 #549. If you feel this is overbearing, discussion is welcome.\nAlso, we do have a \"finally\"! We call it always.\n. If the problem is due to namespacing (I have not researched yet, just going off your observations), should be able to fix by doing PromiseKit.URLError....\n. You're calling somePromise(), so yes, its returned promise will execute. This is expected behavior.. >So I import import PromiseKit and then try\nFIRDatabase.database().reference().child(\"somechild\").removeValue().then  {\u2026}\nobviously this doesnt work...\nWe don't currently have an extension for Firebase the way we do for e.g. Alamofire, so we have no out-of-the-box functionality like this unfortunately. We probably should, as we used to for Parse and Firebase is the common replacement. We make this kind of stuff easy though. For example, to create an overload of Firebase's removeValue() that returns a Promise:\nswift\nextension FIRDatabaseReference {\n    func removeValue() -> Promise<FIRDatabaseReference> {\n        return PromiseKit.wrap { resolve in\n            removeValue(completionBlock: resolve)\n        }\n    }\n}\nThen you can use removeValue() as in your example above. This will also, in turn, let you utilize our when, as @zlangley mentioned, which acts as Promise.all from your example:\n```swift\nPromiseKit.when(fulfilled: [someRef1.removeValue(), someRef2.removeValue(), someRef3.removeValue(), someRef4.removeValue()]).then { values in\n    //\u2026\n}\n````\nTake note of the two variants of when though (when(resolved:) and when(fulfilled:)) as they behave differently.. \ud83d\udc4c. carthage build should take care of this, I would think. It uses xcodebuild, so ensure you've set yours to Xcode 8.3 then run carthage build again.. I've also not seen this. Can you provide more detail? An example would be even better.. See: https://github.com/PromiseKit/CoreLocation. There are a few options. You can:\n\n\nMake self.update fulfill with username instead of with the boolean isSuccess value (which is unnecessary since if the process was unsuccessful the promise should be rejected and you should handle that in a catch).\n\n\nAssign username to a higher scope (which self.update may already be doing?)\n\n\nAccess the value of the promise underlying getUserName(), which in your case could be accomplished my making the function into a property since it takes no parameters (unless you need to make the request multiple times).\n\n\nLet me know if you'd like examples of any of these. Also, your use of when is superfluous as it is only taking a single promise, so you can drop it.. tl;dr I think the feeling of the way PMK uses these functions is spot on, which IMO is at least as important as using them accurately.\nI don't feel qualified to comment on the technical underpinnings of @stephencelis's reasoning here, which I'm sure is sound. I don't have any experience with functional programming, and my understanding of these transforming functions has come to me more through feeling than concrete expectations. I imagine I'm not the only PMK user in this boat though. So I'm gonna throw in my two cents, which admittedly is mostly opinion.\nI understood the purpose of these new functions almost immediately. I did need to read the documentation on them first. What did it mean to map a promise? What did it mean to flatMap a promise? But as soon as I read the docs, I got it. Oh, maping a promise means I'm returning something that's not a promise. It's like a transform. Got it. Oh, flatMaping a promise means I'm returning an Optional and I want to remove that optionality. Just like how I (most often) use flatMap in Swift. Got it.\nThese understandings were based on the feeling of my experience with the functions they're based on, not the technical expectations, which I've never had to think about. A lot of people do think about these things of course, and I can understand how our co-opting of the functions might be confusing due to that. So if some better names are found, then cool. But I do worry about adding qualifiers to the names (e.g. ifSome, ifNotNil), or changing the names entirely for the simple purpose of disassociating them from the pure counterparts. I worry it'll actually make the purpose less clear. I believe my quick understanding of their purpose came from the simple naming that (at least somewhat closely) mirrored behavior I was already familiar with in Swift.. Apologies, restating information here so I am sure I'm on the same page.\nThe issue with our flatMap that operates on Optionals is that it is called on a promise, and this is mismatched with the transform return type, which is an Optional. A true flatMap's transform return type matches the type on which the function is called.\nThe issue with our flatMap that operates on Sequences is essentially the same: it is called on a promise, but the promise is ignored in the transformation; it's the sequence type within the promise that is actually flatMaped.\nIs this right?. I'm just trying to restate the specific issue(s) with our flatMaps as succinctly as possible. But I want to confirm with you that I have it right, since this is my first time considering such things.\nAs you said, the shape of a pure flatMap looks like:\nswift\n(M<A>) => ((A) -> M<B>) -> M<B>\nAnd the shape of our flatMaps actually look like:\n```swift\n//Optional Thenable.flatMap\n(Promise) => ((A) -> Optional) -> Promise\n//or\n(M) => ((A) -> N) -> M\n//Sequence Thenable.flatMap\n(Promise>) => ((A) -> Sequence) -> Promise>\n//or\n(M) => ((A) -> B) -> M\n```\nIn the case of our flatMap on Sequences, the shape becomes correct if the promise containers are ignored, which is why you suggested the name flatMapInner.\nIn the case of our flatMap on Optionals, the shape is still incorrect even when the promise containers are ignored:\nswift\n(A) => ((A) -> N<B>) -> B\n\u2026which is why @mxcl mentioned that the name ifLet would actually be more accurate.\nDo I have this right?. What about flatMapValue or flatMapResult? And compactMapValue/compactMapResult for our flatMap variant that removes Optionals from a Sequence?\nValue/Result of course refer to the promise's internal value, so we're being explicit about what is actually being flatMapped while using PMK-familiar terminology.. This was fixed by 762e322d9f8832ba56fb2eaa4442375f4e80e570 which seems to have been lost?. I dislike how wordy so many of the names are becoming, but I do think the names are clear, which is the most important thing. In a perfect world I think we'd have promise-themed names (in the vein of then, firstly, etc) unique from functional names. But that's a lot of names to come up with, and the functional names are accurate to the operations.\nMy one tiny gripe is with compactMap. It doesn't feel like a compactMap since it's not operating on a sequence, and since it continues or fails the promise chain based on whether or not the unwrapped value exists. compactMap on sequences doesn't fail. So even though it breaks away from the naming convention we have going here, I do think e.g. unwrap is more accurate. This is a minor complaint though.\nI think these names are good.. I keep forgetting to skip ci \ud83d\ude2b\ud83d\ude2b\ud83d\ude2b. swift\n// assigning recover here instead\np.recover{ \u2026 }\nreturn p\nThis creates a new promise and that's not the promise you're returning. You should even be receiving a warning indicating such (Result of call to 'recover' is unused).\nInstead, you should be returning the result of p.recover{ \u2026 }, so:\nswift\nreturn p.recover{ \u2026 }. What is your goal? I think we may be able to suggest some options for you if we know what you're trying to achieve.. You are using an older version of PromiseKit. We are currently at 6.2.5, with numerous fixes and improvements in between. I recommend upgrading.\nYou likely either specified 6.0.0 in your Podfile, or you need to pod update.\nIf you're still experiencing errors after upgrading I'll help you debug.. Does service.registerUser return a promise? It looks like it probably does since there\u2019s no completion on it. In which case the wrapping Promise { seal in \u2026 } is unnecessary and would constitute doubling up. You could simply return firstly { \u2026.\nOtherwise this looks good to me!\n(Edit: removed recommendation for tap in place of map when the latter is in fact the correct choice in this case.). Apologies, I haven't written this pattern recently and it appears that it has in fact changed due to catch returning PMKFinalizer which cannot be chained with another catch.\nFor the moment at least, you could do this instead which accomplishes the same though a little less succinctly:\n```swift\nfunc register(facebookAccessToken: String) -> Promise {\n    let promise = firstly {\n        service.registerUser(facebookAccessToken: facebookAccessToken)\n    }.map { accessToken in\n        self.storeAccessToken(accessToken) // returns Void\n    }.then {\n        self.updateAuthenticatedUser() // returns Promise\n    }.done {\n        NotificationCenter.default.post(Notification(name: .userAuthenticated, object: self))\n    }\npromise.catch { _ in\n    self.discardAccessToken()\n}\n\nreturn promise\n\n}\n//elsewhere\nregister(facebookAccessToken: token).catch { error in\n    //this catch will get called as well\n}\n``. Ah, in fact this is in our [migration guide](https://promisekit.org/news/2018/02/PromiseKit-6.0-Released/) even (scroll to the bottom). And the above is the given solution for catching before and after the return.. Alternatively, you could check the status of the chain withtap` and perform your failure cleanup there instead of in a catch:\nswift\nreturn firstly {\n    service.registerUser(facebookAccessToken: facebookAccessToken)\n}.map { accessToken in\n    self.storeAccessToken(accessToken) // returns Void\n}.then {\n    self.updateAuthenticatedUser() // returns Promise\n}.tap { result in\n    if case .rejected = result { \n        self.discardAccessToken()\n    }\n}.done {\n    NotificationCenter.default.post(Notification(name: .userAuthenticated, object: self))\n}. >How do I sepecify the type of user in done?\nswift\n}.done { (user: User) in. >how can I know in the .catch section uploadImages or updateProfile was failed\nPresumably the error passed into your catch will indicate which task failed. You\u2019ll have to check it.\nFor the photos, the simplest solution is to do something with them in your then where you currently have them or assign them to a higher level variable (e.g a property). If neither of these are good for you let me know. There are other options.\n. Swift can\u2019t infer the return type of closures with 2+ lines. You\u2019ll have to specify the type of promise you\u2019re returning from the closure.. We do have when which behaves as you describe. Though I assumed that you wouldn\u2019t want to update the profile until after the photos upload. If you want to do them at the same time, then when is what you want, and the following closure will contain the results of each of the promises passed in.\nYou can\u2019t chain anything after a catch except for a finally. A catch will get called for any promise the errors prior in the chain. It\u2019s up to you to determine which promise failed via the error object. This is a feature of promises. It reduces your error handling to a single place. Though there are alternatives when you really them.\ndone does not in fact contain the results of all prior promises in the chain as you describe. We don\u2019t have a method for that. Though it sounds like when will fit the bill for you in this case. . >We would have to return a PMKFinalizer which is adapted to handle subsequent catches.\nWent ahead and played with this and got an implementation working. So this can potentially be an option if it's desired.\n\nMost of the time with Promises when I care about specific errors it is in order to recover.\n\nI could adapt this functionality to exist on recover instead/additionally (e.g. recoverOnly(\u2026)) if you think that would make sense. Might make for some nice chains, recovering specific errors right after the relevant tasks.\n\nThe fact that our catch cannot be as elegant as a Swift catch means this PR could never deliver the kind of value everyone really wants.\n\nYeah, this bums me out. When I realized this I almost stopped. But I knew I'd still use it, even with the limited usability on associated values. I felt like it added some nice explicitness and separation, even in those cases. And there was prior interest. So I wanted to see what others thought.. So even though this may not be merged I wanted to go ahead and push up what some of the discussed changes/issues might look like implemented/addressed. Both for fun and reference.\n\nI created a new PMKCascadingFinalizer object to be returned by the catchOnly methods. It behaves the same as PMKFinalizer only wraps a promise instead of a guarantee. It has both catchOnly methods as well as catch which call their respective Promise<T> counterparts for chaining and chain completion.\nI implemented recoverOnly with both an object and type accepting variant to mirror catchOnly.\nThe type accepting variants of catchOnly and recoverOnly can have a catch policy specified for handling or ignoring any cancellation errors within the passed type.\n\nIf there ends up being interest to merge this just lmk if there are any changes desired and I'll happily oblige.. AFAIK this isn't possible. So feel free to close.. Forgive me, I don't think I'm totally following. The last example feels like what is currently implemented (only using an overload). What would you like to see on top of this?. Oh yep. Apologies for omitting that use case in the example, but it's there, including falling back to the (still required) final catch handler if prior specific handlers are not triggered.. Let me verify. I may not have handled this, meaning the first would be triggered with the middle skipped, even though it's a more specific match. I'm assuming you would like the middle catch to be called in this case.. Yep, the first catch would be called with the following two skipped. I have a test verifying this.. Fair enough. So, it'd be considered a developer error in that case.\nFor quick reference, here are all of the features currently implemented in this PR:\nswift\nfirstly {\n    throw ErrorType.specificCase\n}.recoverOnly(ErrorType.specificCase) {\n    //\u2026\n}.recoverOnly(ErrorType.self) { error in\n    //\u2026\n}.recover {\n    //Executed only if specific recovers are not triggered\n}.catchOnly(ErrorType.specificCase) {\n    //\u2026\n}.catchOnly(ErrorType.self) { error in\n    //\u2026\n}.catch {\n    //Executed only if specific catches are not triggered\n}. I initially attempted using a catch overload, but even with a named parameter in the signature (e.g. catch(only: Foo \u2026)), Swift was not able to disambiguate. I couldn't think of a way to make it work. But I can certainly give it another shot.. Okay I played around again and remember the issue. It's the two new variants that don't disambiguate well between each other (Error.specificError vs Error.self). Whenever only one is named catch it's fine, but once both are Swift starts getting confused.\nIt actually does compile out now once the closure is completed. I assume because I have since removed the closure's parameter in one and not the other. But up until that point Swift generates false errors (e.g. Missing parameter on: in call\u2026). Okay I don't think this is bad at all now actually. I think they can all be catch/recover and it'll be good so long as the placeholder autocompletions are used or the closure parameters aren't otherwise omitted.. One case where this could be confusing is when switching between the two variants after completing the code. It'll be easy to forget to remove/include the closure parameter for the error object and Swift won't provide the correct compiler error.\nThis is unrelated to dropping \"Only\" off of the function names. Just something that's occurring to me now.. Ah, makes sense. I wasn't going to import originally but since the MessageCompose delegate method doesn't provide an error I needed to check the result value directly which left me with the option of either importing or assuming the int value of the Failed result.\n. Ok yes I wasn't sure what error code to use here so I used 4 because I didn't see it used for anything in the swift implementation.\n. Alright so what are we doing with the error codes? Right now they don't match at all between Swift and ObjC. Are we going to try to match them up? Or just add a PMKOperationFailed code to both and be done?\n. Why the method signature change?\n. My justification for cutting out the end of this paragraph was that is seemed like noise to new PMK user. But I'll add it back if you like.. ",
    "khaullen": "Thanks for the quick fix. What kinds of tests do you have in mind? Is the one above unreliable?\n. Ah yes, this is what stubs are for right? Could we stub out CLLocationManager to always provide a fixed set of coordinates?\n. ",
    "donnywals": "The code sample you put here seems to work, thanks a lot!\nI've been messing for way too long..\n. ",
    "segiddins": "Don't need this, but it made looking at the pod spec lint output a bit difficult :)\n. ",
    "Dridus": "FWIW I have this working on Xcode 6.3.1 targeting iOS 7. I did the whole source approach, including both the OMGHTTPURLRQ and PromiseKit sources in my project, sticking this in my bridging header:\n``` objc\nimport \"OMGHTTPURLRQ.h\"\nimport \"PromiseKit.h\"\n```\nand with this diff to the PromiseKit sources:\n``` diff\ndiff --git a/Swift Sources/NSURLConnection+Promise.swift b/Swift Sources/NSURLConnection+Promise.swift\nindex db860d2..18552b7 100644\n--- a/Swift Sources/NSURLConnection+Promise.swift\n+++ b/Swift Sources/NSURLConnection+Promise.swift\n@@ -1,5 +1,5 @@\n import Foundation\n-import OMGHTTPURLRQ\n+//import OMGHTTPURLRQ\nextension NSURLResponse {\ndiff --git a/Swift Sources/PromiseKit.h b/Swift Sources/PromiseKit.h\nindex 9316b59..4b25f31 100644\n--- a/Swift Sources/PromiseKit.h\n+++ b/Swift Sources/PromiseKit.h\n@@ -8,4 +8,4 @@ FOUNDATION_EXPORT const unsigned char PromiseKitVersionString[];\n// for convenience and better error messages if you don\u2019t\n // have OMGHTTPURLRQ available and to hand\n-@import OMGHTTPURLRQ;\n+//@import OMGHTTPURLRQ;\n```\nalso I had this hanging around in my sources to fix an old linking error but I'm not sure if it's still required:\n``` swift\nimport AssetsLibrary\n// reference this to force libswiftAssetsLibrary to be linked\nlet assetsLibrary = ALAssetsLibrary()\n```\n. ",
    "avdwerff": "Thanks, guys, I guess I didn't realise I was also adding the osx sources (NSTask etc.). \nDo I as well need to include the OMGHTTPURLRQ manually..? Or that could be a pod install, right?\nI will try it again.\n. ",
    "robrix": "Further, since promises enjoy monadic properties, it\u2019s only fitting that one elephant defines the shape of another elephant. Put another way: Elephants, like promises and other monads, have the closure property.\n. ",
    "christianbundy": "This is now officially the stupidest thing I've ever fallen in love with.\nMy ex will be thrilled.\n. ",
    "jessepollak": ":+1: \nThank you for all of your hard work, you're awesome.\n. ",
    "eytanbiala": "While it would be nice to have PMKManifold handle it, I think you are correct to keep it as is. The alternatives you provided are perfectly fine, I don't think this kind of functionality is frequently needed.\n. Sure, thanks for the advice.\n. I found my issue - in some parts of the code a promise is returned, but I am not attaching then or catch handlers to that promise.\nI am thinking to add catch handlers to any calling code where a promise is returned, but it seems like it should not be necessary to do that. In many of these cases I don't need the catch handler, so it will just be an empty block. Do you have any suggestions?\n. I suppose it depends on your use case for promises. I am using it extensively now, so if I need to debug an unhandled promise later on it will be difficult since so many are not handled. \n. I agree - for most cases this would be a pretty bad practice. In my case it is for network requests that should fail silently so the category is helpful, thanks!\n. Did you find a way to suppress the compilation warnings?\n. This is the Xcode version I'm using: Version 8.0 beta 6 (8S201h)\nSo in the PromiseKit target, \"Use Legacy Swift Language Version\" was set to \"Yes\".\nIf I change it to \"No\", then I just get these errors:\n\nIf I comment out the finally's it complains about, it seems to work for that file. I use finally all the time though, so I haven't gone through to see if the whole project will build if I take them out.\n. Ahh ok, that seems to work.\nSeems I have one last issue - No known class method for selector 'promiseWithValue:'.\nI'm using Obj-c, and currently importing #import <PromiseKit/PromiseKit.h>. Do I need to be importing something else?\n. Hmm, I don't think it's specific to that method actually. If I comment out the instance that is causing the build error, it then findsNo known class method for selector 'promiseWithResolverBlock:' \nWhat's weird is that the methods show up in autocomplete, and I can cmd+click to go to the definition.\n. Hmm no, unfortunately not, getting the same errors.\n. Yep works now, thanks for all your help!\n. ",
    "Vaseltior": "Can't you reproduce, I was on google all day long with this search query\n. Good to know, \nyour answer here: http://stackoverflow.com/questions/28634995/chain-multiple-alamofire-requests\nis giving me the same results\n. How could I know? :-)\n. Sorry for that! I can do it if you prefer.\n. Thx for your time, it was nice from you ta have a look.\n. You're great! I owe you one pack of beer\n. ",
    "camapblue": "I got the same problem with Vaseltior, it's not from XCode I sure. The root cause is from Alamofire.request(...) => it's return an Alamofire.Request() object, not Void (although you don't call return, it's automatically revoke in a closure with single-expression)\nYou can fix it by: \n```\nfunc getBlogs() -> Promise<[AnyObject]> {\n    return Promise{ fulfill, reject in\n        Alamofire.request(Router.GetBlogs(query: \"\")).response { (, , data, error) in\n            if error == nil {\n                if let xwsse = data as? [String:AnyObject] {\n                    Swell.debug { data!.description }\n                if let result = data as? [AnyObject] {\n                    fulfill(result)\n                }\n            }\n\n        } else {\n            reject(error!)\n        }\n    }\n    return\n}\n\n}\n```\nThe code isn't nice anymore but it works for me. :D\n. ",
    "SparrowBlaze": "Will do. Thanks for the help!\n. In case it's still relevant, I have a method wrapping a Parse save, which I'm trying to call in my AppDelegate. As mentioned in the ParseKit documentation, a bridge a Promise to AnyPromise is done similar to the generalized example of my current code below:\n``` swift\n@objc func createObjectWithName(name: String) -> AnyPromise {\n        return AnyPromise(bound: createObject(name: name))\n    }\nfunc createObject(#name: String) -> Promise<AnyObject> {\n    return Promise() { (fulfill, reject) -> Void in\n\n        let newObject = PFObject(className: \"Object\", dictionary: [\"name\" : name])\n\n        newObject.pinInBackgroundWithBlock { (success, error) -> Void in\n\n            if error == nil {\n                newTopic.saveEventually { (success, error) -> Void in\n                    if error == nil {\n                        fulfill(success)\n                    } else {\n                        reject(error!)\n                    }\n                }\n\n            } else {\n                reject(error!)\n            }\n        }\n\n    }\n}\n\n``\n. Awesome, import order fixed the issue! Thanks!\n. By the way, would you happen to know why the compiler doesn't see the category symbols? I only found out about this thing from GitHub, and digging through the source folders on my end... Xcode balks when I try to use any of thepromiseViewController()methods, or thePMKAlertController`, claiming neither exist. I'm trying it via CocoaPods to see if it makes a difference, but would you happen to have any advice in the meantime?\n. Not using Carthage. Sorry, I should've specified. I actually downloaded the .xcodeproj and added the framework as an embedded binary.\nUsing CocoaPods now, and still getting similar troubles. Told it both PromiseKit (3.4) and PromiseKit/UIKit. Installed, updated, import PromiseKit, clean built, the works, and Xcode still doesn't know what the heck promiseViewController() is supposed to do.\n. \n\nThis the one?\n. The Swift header doesn't mention UIViewController at all, but that's probably more of the symptom than the cause...\n. I deleted old PromiseKit before starting on CocoaPods. Same behavior. Rebuilding now, then I'll try deleting the DerivedData entry and rebuilding again.\nCould it be that Pods did something weird with build phase ordering?\n. Hmm... The build just finished, and I'm getting Undefined symbol errors in the console, referencing everywhere I was using PromiseKit... Gonna try tweaking build orders. Maybe it's not copying the sources before linking, or something...\nEDIT: Yeah, no luck. Might just remove CocoaPods again and copy the sources manually... Gross, but what can ya do?? \ud83d\ude43\n. ",
    "carlshimer": "Which specific tests? I didn't see any that exercised chaining.\nOn May 18, 2015 4:19 PM, \"Max Howell\" notifications@github.com wrote:\n\nWhat I see is that B and C get called at the same after A completes.\nThis shouldn't happen, and well, we have tests that prove it doesn't. Can\nyou provide a code sample that shows the behavior you are seeing?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/193#issuecomment-103198032.\n. Will have to test.  Knew I was doing something wrong.  Weird that isn't a\ncompiler error.\nOn May 18, 2015 4:54 PM, \"Max Howell\" notifications@github.com wrote:\nActually looking closer something is wrong here:\npromise.then { _ -> Void in\n   return B()\n}.then { _ -> Void in\n   return C()\n}.then { _ -> Void in\n  return D()\n}\nYou're stating that all the clojures return Void. Shouldn't they be\nreturning a Promise? If you return void, nothing is chained.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/193#issuecomment-103208338.\n. Ok, so I got it to work.  Unfortunately my example was too contrived and not really close to what I was actually doing.  Here is the code that does the wrong thing.  In my opinion this is a compiler bug.\n\nlet promise = self.A()\n    promise.then { onComplete -> () in\n      return self.B()\n      }.then { onComplete -> () in\n        return mgr.C()\n      }.then { onComplete -> () in\n        return self.D()\n      }.then { onComplete -> () in\n        return self.E()\n      }.then { onComplete -> () in\n        return self.F()\n    }\nThe closure is defined to return void.  Since the swift syntax is still new to me I missed that.  However, every of my methods is returning a Promise.  This should have failed for returning the wrong type.  However, it compiles cleanly and the return is ignored.\nThis code works fine and acts serially:\nlet promise = self.A()\n    promise.then { onComplete -> Promise<AnyObject> in\n      return self.B()\n      }.then { onComplete -> Promise<AnyObject> in\n        return mgr.C()\n      }.then { onComplete -> Promise<AnyObject> in\n        return self.D()\n      }.then { onComplete -> Promise<AnyObject> in\n        return self.E()\n      }.then { onComplete -> Promise<AnyObject> in\n        return self.F()\n    }\nSo I guess the only suggestion would be to make an example in swift that shows the correct type signature.\n. Well, as the swift docs are a bit sparse now I had been looking at http://promisekit.org/chaining/.  A good swift example might help :)\n. ",
    "apendley": "Interestingly, this compiles fine, and afaict everything chains together fine too:\nfirstly {\n    Promise(0)\n}\n.then { _ -> Void in\n    println(\"1\")\n}\n.then { _ -> Void in\n    println(\"2\")\n}\n.then { _ -> Void in\n    println(\"3\")\n}\n.then { _ -> Void in\n    println(\"4\")\n}\n.then { _ -> Void in\n    println(\"5\")\n}\n.then { value -> Void in\n    println(value)\n}\nIn the last closure, I print the \"value\" returned from the previous Void-returning closure, and it prints \"()\".\n. Ah yes, sorry. It definitely gives me a compiler error when I try to return a promise when the closure specifies a Void return.\nI take your point about needing to return a promise if you want to wait on it, that makes sense to me.\n. I have not yet tested this yet, however the new reference is available at https://itunes.apple.com/us/book/swift-programming-language/id1002622538?mt=11.\nIn this reference, \"catch\" has been added as a reserved keyword (look in the section 'Lexical Structure', subsection 'Keywords and Punctuation')\nI will be downloading the Xcode 7 beta later today, at which time I will test this to verify, and will update here after I've done so.\n. FWIW:\nFor catch replacement, I like fail or failed.\nFor defer replacement I like deferred(). My rationale for this is that using the alternate form:\nlet deferred = Promise<Int>.deferred() \nseems more natural than the other alternatives, as would accessing it's members:\ndeferred.promise, deferred.fulfil, deferred.reject.\n. ",
    "andrei4002": "i've actually tried both and got the same result\n. ",
    "TYRONEMICHAEL": "Awesome - thanks.\n. Ya exactly. Does that solve your issue?\n. ",
    "cesar-oyarzun-m": "@TYRONEMICHAEL hey I have the same problem I'm using xcode 6.4, How did you solved this problem??? Just adding the alamo request to a var???\n. @mxcl Hi I'm trying to create a promise and then save the function fulfill and reject into in array or dictionary . I don't know if this is possible to do I get some compiler erros. I know you can store functions inside array but I think since is inside the promise I need to do something else, here is my code \nlet requestPromise = Promise<Bool> { fulfill, reject in\n        self.socket.emit(message,dic)\n        let dicFunc = [ \"fulfill\": fulfill, \"reject\":reject]\n    }\nI get error\nType of expression is ambiguous without more context\n '_' is not convertible to '(NSError) -> Void'\n. I was able to save the fulfill but when I add the reject I get error\nvar request = Dictionary<String,Any>()\n   let requestPromise = Promise<Any> { fulfill, reject in\n       self.socket.emit(message,dic)\n       var resolved = Dictionary<String,Any -> Void>()\n       resolved  = [ \"fulfill\": fulfill,\"reject\":reject]\n       self.request.updateValue(resolved, forKey: uuid)\n   }\nCannot assign a value of type '[String : (NSError) -> Void]' to a value of type 'Dictionary Void>' I think must be because of the type\nFunction signature 'Any -> Void' is not compatible with expected type '(NSError) -> Void'\n. thanks @mxcl that will work to save it in the same Dictionary, but the problem is when I take it out of there and call the function, do I need to cast.\nvar dictionary:Dictionary<String,Any> = self.request[id] as! Dictionary\n                if((error?.isEmpty) == nil){\n                    let fun = dictionary[\"fulfill\"]\n                    fun(true)\n                }else{\n                    let rej = dictionary[\"reject\"]\n                    rej(NSError())\n                }\n. I think this will work \nif((error?.isEmpty) == nil){\n                    let fun = dictionary[\"fulfill\"] as! Any -> Void\n                    fun(true)\n                }else{\n                    let rej = dictionary[\"reject\"] as! Any -> Void\n                    rej(NSError())\n                }\nthanks for the help! @mxcl \n. Thanks @mxcl I will make that change, but how will be the syntax to take it out from the dictionary I have this \nvar dictionary:Dictionary<String,Any> = self.request[id] as! Dictionary\n let fun = dictionary[\"fulfill\"] as! Any -> Void\nbut I think I will need something else I get cast error, How do I get out from the dictionary? also updateValue is a method from Dictionary. I still need to take the reject or fulfill by some condition that I get from the server, that is why I have that in a Dictionary with key value.\n. I have the same problem, how can I fix this? I'm trying to submit my library to cocoapod by pod trunk push --allow-warnings  ExpSwift.podspec, I already try with changing the compiler level no luck @mxcl Do you have the complete podspec file @lvdaqian her is my podspec\n```\nPod::Spec.new do |s|\n    s.name             = \"ExpSwift\"\n    s.version          = \"1.0.2\"\n    s.summary          = \"Exp IOS SDK library. Native IOS library for EXP platform.\"\ns.description      = \"Exp IOS SDK library. Native IOS library for EXP platform will allow you to   communicate directly to EXP platform.\"\n\ns.homepage         = \"https://github.com/ScalaInc/exp-ios-sdk\"\n# s.screenshots     = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\"\ns.license          = 'MIT'\ns.author           = { \"Cesar Oyarzun\" => \"cesar.oyarzun@scala.com\" }\ns.source           = { :git => \"https://github.com/ScalaInc/exp-ios-sdk.git\", :tag => 'v1.0.2' }\n# s.social_media_url = 'https://twitter.com/<TWITTER_USERNAME>'\n\ns.platform     = :ios, '8.0'\ns.requires_arc = true\n\ns.source_files = 'Pod/Classes/**/*'\n\n\n# s.public_header_files = 'Pod/Classes/**/*.h'\n# s.frameworks = 'UIKit', 'MapKit'\n s.dependency 'PromiseKit','3.0.0'\n s.dependency 'Alamofire','3.1.5'\n s.dependency 'Socket.IO-Client-Swift','4.1.2'\n s.dependency 'JSONWebToken','1.4.1'\n\nend\n```\n. anyone has some kind of solution for using podspec file?\n. thanks @nathanhosselton I really hope we can fix this I'm just waiting for this to publish my library\n. yes I just test it and it works thanks!\n. @mxcl I did try with a new clean build, the same problem. Do you think maybe something with overload a method? \n```\n/*\n Get output from Feed\n @return Promise.\n /\npublic func getData() ->Promise{\nreturn Promise { fulfill, reject in\n    Alamofire.request(Router.getFeedData(uuid))\n        .responseJSON {response in\n            switch response.result {\n            case .Success(let data):\n                fulfill(data)\n            case .Failure(let error):\n                return reject(error)\n            }\n        }\n}\n\n}\n/*\n Get output from Feed\n @return Promise.\n /\npublic func getData(query:[String:AnyObject]) ->Promise{\nreturn Promise { fulfill, reject in\n    Alamofire.request(Router.getDynamicFeedData(uuid,query))\n        .responseJSON {response in\n            switch response.result {\n            case .Success(let data):\n                fulfill(data)\n            case .Failure(let error):\n                return reject(error)\n            }\n    }\n}\n\n}\n```\nalso Xcode keeps crashing if I have it open and I run pod update\n. hey I just clean and build like 5 times and now it works, also I need to do pod update anytime that if I change something on my code, it crash almost every time, but I make it work, thanks\n. ",
    "schemers": "so is defer\n. ",
    "ZerdaH": "Coming from JS promises, deferred was sometimes used and seems like a natural replacement. fail was also used by jQuery in place of catch, though their promises aren't compliant.  Not that javascript needs to have any influence on whatever you decide.\n. ",
    "pjechris": "What about rescue? This is used in Ruby and I guess some other languages.\nIMO It's give a good insight of what it is doing, juste like catch\n. ",
    "andriichernenko": "Has the decision been made yet? If not, what about\np.then{ /*\u2026*/ }.ifFailed { error in }\np.then{ /*\u2026*/ }.whenFailed { error in }\n?\n. As for defer, I haven't used it much, so I might not completely understand its meaning, but handle (as in door handle) seems like a candidate to me:\nlet (promise, fulfill, reject) = Promise<Int>.handle() or \nlet (promise, fulfill, reject) = Promise<Int>.createHandle()\nOr maybe some other, better name for object which can be used to do stuff.\n. ",
    "mythz": "Went to upgrade to Swift 2.0 and just found out catch was renamed to report which IMO is an unfamiliar and non-obvious replacement for catch that I don't think has any association with error handling. \nLooking at the existing naming used in a popular Promises like API like jQuery ajax, it uses fail for catch and always for finally:\njs\nvar jqxhr = $.ajax( \"example.php\" )\n  .done(function() {\n    alert( \"success\" );\n  })\n  .fail(function() {\n    alert( \"error\" );\n  })\n  .always(function() {\n    alert( \"complete\" );\n  });\nIt also uses done for complete and then for chaining which supports an overload for both success and failed callbacks. This API is also what's defined in ES6 Promises API:\njs\np.then(function(value) {\n  console.log(value); // Success!\n}, function(reason) {\n  console.log(reason); // Error!\n});\nFWIW I think your earlier suggestions of:\n- fail\n- failed\n- error\n- onerror\nAre all better replacements than report. I'd go with fail just because it's already a well known alias.\n. > Looking at that, the only complaint I really have is that the token error repeats\nSince it's something I do frequently I'd use an e or ex abbreviation myself. There's always onerror to differentiate from the error argument but IMO is better without it.\n. ",
    "amacneil": "I'm fairly new to both Swift and this library, so take this with a grain of salt, but .error looks much nicer to me than .report. The problem with .report is that to me it reads as though it could be either positive or negative (am I reporting to the user that their download finished?). I agree with your points against .fail sounding imperative though.\nEither way, look forward to an official release for Swift 2, thanks for all your hard work :+1: \n. Actually from reading the docs I can't figure out why both catch and recover exist in the current version. Why not just drop catch/report/error in favor of .recover? Is there a reason why one would want to use the former?\n. Yeah, I eventually figured that out after reading the Scala promise docs and some other libraries. \nI was reading this page which I found by Googling \"promisekit recover vs catch\". For someone who already knows why they would want to use recover it does a decent job of explaining the syntax, but it could probably use an introductory sentence explaining that recover is used to provide a default return value, and not for general error handling.\nMy search also returned your blog post which mentions that recover was added to \"work around ambiguity in catch\" (linking to a github issue related to compiler errors), which makes it sound like it's some sort of workaround and not a separate feature.\n. ",
    "sebastien-de-saint-florent": "Thanks a lot\n. Hi,\nI would need also PromiseKit to be tvos compatible.\n@tjdhome, is it normal you haven't updated the podspec file to include something like s.tvos.deployment_target = '9.0' ?\n. ",
    "oddanderson": "+1, PromiseKit should be specifying a OMGHTTPURLRQ version for the podspec.  It's unsafe to assume Swift libraries will maintain backwards compatibility at this point.\n. ",
    "bruceflowers": "Thanks! I'll look for the new change.\n. @mxcl @katopz  I looked away from this repo for a day and just saw this - thanks to both of you for your help!\n. I'm trying to build the swift2-beta5 branch (a413bbad4c539dadf36312d471e932e0ce980fd4) using carthage update --platform tvOS.\nPerhaps there's a more current swift2 branch I didn't see, or maybe I'm missing something else?\nAnyway, this is the output I get:\ncarthage update --platform tvOS\n* Fetching PromiseKit\n* Fetching OMGHTTPURLRQ\n* Checking out PromiseKit at \"a413bbad4c539dadf36312d471e932e0ce980fd4\"\n* Checking out OMGHTTPURLRQ at \"3.0.0\"\n* xcodebuild output can be found in /var/folders/66/7ttbxjv94md42tvryd7ww0fc0000gn/T/carthage-xcodebuild.ehAk9Q.log\n* Skipped building OMGHTTPURLRQ due to the error:\nDependency \"OMGHTTPURLRQ\" has no shared framework schemes for any of the platforms: tvOS\nIf you believe this to be an error, please file an issue with the maintainers at https://github.com/mxcl/OMGHTTPURLRQ/issues/new\n*** Skipped building PromiseKit due to the error:\nDependency \"PromiseKit\" has no shared framework schemes for any of the platforms: tvOS\n. What version of CocoaPods?\nI ask because it looks like tvOS support was worked on, but only lives in this PR right now:\nhttps://github.com/CocoaPods/CocoaPods/pull/4152\nBut it doesn't look like it's been merged in...\n. I've got problems with some other pods not being compatible with use_frameworks!, so it's Carthage for any swift libraries in the project. But your fix is interesting!\n. ",
    "PrideChung": "You're right, then is all I need. By the way, according to your last answer, there's a way to defer a Promise's execution? That would be quite handy, because I want to past a Promise between objects as data source, and I don't want to start that Promise until it's actually needed.\n. Thanks, now I'm crystal clear.\n. ",
    "XBeg9": "What I have tried already:\n1) Optimisation level is set to None\n2) Tried xcodebuild to get exact error with no luck. \n3) A lot of possible code changes. If you drop fulfill inside other block, you should get error.\n. @mjbeauregard wow! That's nice. Thanks!\n. @nathanhosselton that's strange and needs more investigation, because in simple Playground without PromiseKit -> I never lost userInfo inside NSError\n. @nathanhosselton also making NSError instead of ErrorType is not that good solution. \n. @nathanhosselton using own ErrorType will solve problem with NSError, so I think we can close this issue.\nI asked this before discovering how to solve the problem, so maybe I will file a radar for Apple.\n. ",
    "mjbeauregard": "I had to do something like this:\n```\npublic class UserService {\n    class func login() -> Promise {\n        let (promise, fulfill, reject) = Promise.defer()\n    Alamofire.request(.GET, \"http://httpbin.org/get\")\n    .responseString { (_, _, string, _) in\n        fulfill(User())\n    }\n\n    return promise\n}\n\n}\n```\n. ",
    "licx": "@mxcl  Thank you very much! That's really helpful.\n. ",
    "katopz": "@mxcl Thanks for workaround, working like charm! :D\n. @bruceflowers  Same situations and here's workaround.\n\nJust fork and checkout before beta3 commit and you're good to go. which is https://github.com/katopz/PromiseKit/commit/f9896a86d1d662c6a58d793ade5b421914df293d\nor temporary point to here https://github.com/katopz/PromiseKit/tree/xcode7-beta2\nPS : I promise I won't delete/rebase it tho ;)\n. ",
    "weien": "The first question at the FAQ is also relevant: http://promisekit.org/faq/. ",
    "jflinter": "Thanks!\n. ",
    "yangmeyer": "Thanks for replying.\n- Deployment target is OS X 10.10 (Yosemite).\n- I'm installing PromiseKit through CocoaPods (pod \"PromiseKit\", \"~> 1.5\").\n- Xcode 6.3.2.\nUsually, po _promiseQueue gives me something like this:\n(lldb) po _promiseQueue\n<OS_dispatch_queue: org.promiseKit.Q[0x608000102e20] = { xrefcnt = 0x1, refcnt = 0x1, suspend_cnt = 0x0, locked = 0, target = com.apple.root.default-qos[0x100a0ad80], width = 0x7fff, running = 0x0, barrier = 0 }>\nHowever, when the debugger catches the EXC_BAD_ACCESS, the _promiseQueue is nil:\n(lldb) po _promiseQueue\n<nil>\nIf I comment out the dealloc, the app doesn't crash \u2013 but I\u2019m assuming this leaks memory?\n. Googling OS_OBJECT_USE_OBJC, I found this: http://stackoverflow.com/questions/26339672/cocoapods-how-to-enable-os-object-use-objc-gcd-queues-as-proper-objc-objects\nApparently Cocoapods uses 10.6 as the default deployment target if I don\u2019t specify otherwise. So I added the platform to my Podfile:\n```\nplatform :osx, \"10.10\"\ntarget :Gemba do\n  # ...\n  pod \"PromiseKit\", \"~> 1.5\"\nend\n```\nStill crashes, though.\n. Yep, using ARC.\nIs there a way I can override PromiseKit's deployment target for my project, e.g. in the Podfile or Xcode build settings? (I\u2019d really like to avoid having to fork the repo just to delete those lines\u2026)\n. ",
    "Avtolic": "Not sure it is the best solution (I am new to CocoaPods) but I have fixed this error by explicitly adding OMGHTTPURLRQ git URL to pod file:\npod 'OMGHTTPURLRQ', :git => 'https://github.com/mxcl/OMGHTTPURLRQ'\npod 'PromiseKit', :git => 'https://github.com/mxcl/PromiseKit.git', :branch => 'swift-2.0-beta2'\n. ",
    "rizhang": "I just added to my PodFile as a temp fix:\npod 'OMGHTTPURLRQ', '~> 2.1.3'\n. ",
    "peres": "Thank you. The actual code shows a UIAlertController in the first promise, and cancelledError is used to handle cancellation. I had looked at the documentation before, and was tricked by the swift example which handles that case in its catch branch. Next time I will read the text between the samples in the docs before wasting your time :P\n. The framework switch had left a number of stale files in the build directories, which Xcode was picking up instead of the new versions. Once I deleted every possible reference to PromiseKit in the build directories, the problem went away. Sorry for the false alarm.\n. Since everybody is meant to include PromiseKit.h, it should be enough to wrap its contents like below. This is by the way what my workaround does, except that it's in client Objective-C++ code, and thus doesn't need the #if guards.\n```\nif __cplusplus\nextern \"C\" {\nendif\n// Regular contents of PromiseKit.h go here.\nif __cplusplus\n}   // Extern C\nendif\n```\n. Thank you. I will hold off updating for the moment, then.. ",
    "mcudich": "The reason I pulled out those imports is that Xcode was complaining about importing a module while it's being compiled (this is perhaps a new beta 3 requirement?). I got this compilation error by importing PromiseKit as a pod - do you not see the same error if you do so?\n. Right on - that makes sense. Thanks!\n. ",
    "fastboatster": "This doesn't seem to work with PromiseKit 6 because after now returns a Guarantee instead of Promise. What do I need to change to make this code work with PK6?\nI'm doing this:\nreturn Promise { seal in\n            // automatic rejection after the timeout?\n            after(seconds: MyTimeoutInterval)\n                .then { Guarantee { $0(TimeoutError) }\n            }\n            self.doLongOperation() { success, error in\n               seal.resolve(success, error)\n           }\n        }\nand it has no effect (I did notice however that a breakpoint set at .then in the after clause does get hit after roughly MyTimeoutInterval seconds)\nIf I do\nafter(seconds: MyTimeoutInterval)\n                .then { seal.reject(TimeoutError) }\nit first complains that Contextual type for closure argument list expects 1 argument, which cannot be implicitly ignored and suggests to insert _ in before seal.reject. However, it brings up another error:\nCannot convert value of type '(_) -> ()' to expected argument type '(Void) -> Guarantee<_>'. Whoa, that was fast! Will try this now.\nUPD: it works! Thanks!. ",
    "jlew-nevo": "I have a similar situation.  In PK4, I would race(promise,timeout) but now that timeout is a Guarantee, the generic parameter on race will not work out.  Any opinion on this as a solution:\nextension Promise {\n    func timeout(seconds: TimeInterval, timeoutError: Error) -> Promise<T> {\n        return Promise<T> { seal in\n            after(seconds: seconds).done {\n                seal.reject(timeoutError)\n            }\n            self.done { result in\n                seal.fulfill(result)\n                }.catch { err in\n                    seal.reject(err)\n            }\n        }\n    }\n}\nI assume it's safe (no-op) to resolve a seal more than once.. Thanks, ended up doing something similar.  In 6.8.x, this is triggering the new \"PromiseKit: warning: pending guarantee deallocated\" on the after guarantee.  Not sure why exactly.  I will update if I find the cause.. The only Guarantee involved here is the after, so it must be related to that, but have not yet worked out how.. A little more info: notice if you run this repro (below), you will see the warning come up immediately, well before the fulfill executes. \n```\nlet p = Promise.pending()\np.promise.timeout(seconds: 5.0).done { val in\n    print(\"Fulfilled (val)\")\n}.catch { err in\n    //\u2026\n}\nDispatchQueue.global().asyncAfter(deadline: .now() + 2.5) {\n    p.resolver.fulfill(10)\n}\n. Same early-warning behavior in the following implementation, when `race` is not in the mix:\nextension Promise {\n    func timeout(seconds: TimeInterval) -> Promise {\n        let pending = Promise.pending()\n        after(seconds: seconds).done {\n            pending.resolver.reject(TimeoutError())\n        }\n        self.done { result in\n            pending.resolver.fulfill(result)\n            }.catch { err in\n                pending.resolver.reject(err)\n        }\n        return pending.promise\n    }\n}\n``. Fair enough, I haven't read up on 'pipe' yet, will do so.  However, the warning does seem to be happening *before*pending.resolveris resolved.  In my demo code up there, the warning appears immediately, but the asyncfulfill` doesn't happen for 2.5 seconds.. Many thanks! . Upgrading, thanks!. ",
    "alexvimpekable": "Got it! Thanks!\n. ",
    "joamaki": "Ah sorry, noticed that the latest version guards against this now. Closing.\n. ",
    "ded": "Awesome! Some responses\n- finally cannot come after catch (yes it's unfortunate, but Swift was difficult about it any other way)\nOk good to know! I will keep that in mind.\n- The when is unnecessary, but it will work.\n  Right. I forgot about that for a quick sec. The same is true for when.js (I don't know why I added the extra when). The good part about the when() wrap is that would at least wrap a known value, and then \"Promisy\" it.\n- Your syntax for Swift closures was a little off.... So I\u2019d write it more like this:\nThank you! This was exactly what I was looking for! I'll leave a lil something in the tip jar :+1: \nWill definitely be moving forward with this in my future iOS projects.\n. I'd love to re-open, (sorry I see you just closed this about 12 days ago).\nI'm looking for a clean solution as such, where the implementor of the Promise (not the issuer) can cancel the Promise.\nMy case is an autocomplete... where a user continues to type new values, if the previous request has not been completed, I want to abort it.\n``` swift\nvar request: Promise?\n. . .\nfunc valChanged(sender: UITextField) {\n  if self.request != nil && !self.request.isCancelled {\n    self.request.cancel()\n  }\n  self.request = getNewResults(sender.text)\n  self.request.then { (response) ->\n    self.results = response[\"data\"].arrayValue\n    self.tableView.reloadData()\n  }\n}\n``\n. months later... thank you for this! i'll have a play with this style.\n. in full,ok` looks like this:\n@discardableResult func ok() -> Promise<Void> {\n    let (promise, fulfill, reject) = Promise<Void>.pending()\n    self.handler = (promise, fulfill, reject)\n    return promise\n  }\nso i'm not sure why it's not letting me do this basic syntax.... ",
    "paultsui": "Thanks for the quick response! : )\n. ",
    "jefferythomas": "Thanks for the quick turnaround. I also added in some code which could solve the problem in a more generic way.\n. Hey Max,\nI would agree that PromiseKit\u2019s categories are more for simple examples then for the general messiness of production code. I supported my the Duck Duck Go behavior by adding my own then() clause to the promised NSData object. My then() clause turned the data into a JSON object and returned a promise for that JSON object.\nIt was a few lines of code which actually added another example of how to take advantage of chaining promises.\nAt some point in the future, when the Xcode 7/Swift 2.0 issues have been sorted out, it might be nice to enhance the URLConnection category with a response processing callback. I would have it do the work I did in my then() clause, except it would be called from every URLConnection promise.\nWith this feature, the default handing of JSON and images would simply be the default response processing callback.\nThanks for taking the time to hear me out,\nJeff\n. While not perfectly analogous, this feels like Cache & Fetch.\n```\n- (PMKPromise )follow {\n    return [Promise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject) {\n        PMKPromise real = [self.requestManager followPerson:self.person];\n        Person *fake = [self.person copy];\n        //\u2026\n        fulfill(PMKManifold(fake, real));\n    }];\n}\n\n(void)go {\n    self.follow.then(^(Person fake, PMKPromise real) {\n        [self updateWithPerson:fake];\n        return real;\n    }).then(^(Person *real){\n        [self updateWithPerson:real];\n    });\n}\n``\n. If-waitForExpectationsWithTimeout:handler:` is blocking the main thread of execution, then it is the problem. Before expectations, I created something similar for my unit testing called JLTWaiter. Swapping JLTWaiter for expectations allowed the tests to succeed. Perhaps you need to roll your own wait mechanism, if your UI tests must dispatch promises.\n\n```\nfunc testSuccessOnDefaultQueue() {\nlet waiter = JLTWaiter()\n\nPromise<Void>().then { Void -> Void in\n    XCTAssert(true)\n    waiter.finished = true\n}\n\nwaiter.waitWithTimeOut(2)\n\n}\n```\nand \n```\nfunc testFailureOnDefaultQueue() {\nlet waiter = JLTWaiter()\n\nlet error = NSError(domain: \"com.ldiqual.PromiseKitReportQueueExample.UITests\", code: 500, userInfo: nil)\nPromise<Void>(error: error).report { error in\n    XCTAssert(true)\n    waiter.finished = true\n}\n\nwaiter.waitWithTimeOut(2)\n\n}\n```\n. ",
    "marlowcharite": "Hmmmmm interesting @mxcl. I can now build. I looked through my past commands and don't know what the problem could've been. I'm going to chalk it up to hazards of coding late. Thanks for the response @mxcl, Love the library!\n. I'm having the same issue with that class. \n``` swift\nsudo xcode-select -s /Applications/Xcode-beta.app\nprojects/gryphon media/dopehood  feature/json-parse-argo \u2717       23h51m \u2716 \u2691 \u271a\n\u25b6 carthage update\n Fetching PromiseKit\n Fetching OMGHTTPURLRQ\n Checking out OMGHTTPURLRQ at \"3.0.0\"\n Checking out PromiseKit at \"027a5c321042dcd4ef42a54e6225d8bf6611afc1\"\n xcodebuild output can be found in /var/folders/3r/kpdj1c916rj_gy_4l99g1klw0000gn/T/carthage-xcodebuild.UnRaUB.log\n Building scheme \"OMGOSX\" in OMGHTTPURLRQ.xcodeproj\n Building scheme \"OMGiOS\" in OMGHTTPURLRQ.xcodeproj\n Building scheme \"PMKiOS\" in PromiseKit.xcodeproj\n BUILD FAILED \nThe following build commands failed:\n    CompileSwift normal x86_64 /Users/marlowcharite/Developer/iOS/projects/gryphon media/dopehood/Carthage/Checkouts/PromiseKit/Sources/URLDataPromise.swift\n    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler\n(2 failures)\nAssertion failed: (PAI2->use_empty() && \"Should not have any uses\"), function foldInverseReabstractionThunks, file /Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-700.0.52.2/src/swift/lib/SILPasses/SILCombinerVisitors.cpp, line 549.\n:0: error: unable to execute command: Abort trap: 6\n:0: error: swift frontend command failed due to signal (use -v to see invocation)\nA shell task failed with exit code 65\n``\n. @mxcl builds fine through cocoapods so might want to switch to that @dgrekov\n. I hate this issue. Started running into it again this morning :( \n. Sometimes in yourthen` block you do have to specify that there is no return value so:\nswift\nmy_promise.then { asynly_fetched_data -> Void in \n    self.data = asyncly_fetched_data\n    self.tableView.reloadData()\n}\nshould work \n. This is so weird as I've opened up an issue a little while back about the same error. But then it started to work... so now I'm even more confused on what the issue is. \nSN: the previous issue was #237 \n. Yeah it might definitely be a Carthage bug as I've been building fine on my MacBook Pro \n. ",
    "gerchicov-bp": "I worked with bluetooth beacons. I meaned a code to find peripherals and get their characteristics. Here is an example of the tutorial:\nhttps://www.invasivecode.com/weblog/core-bluetooth-for-ios-6-core-bluetooth-was/\nSorry but I don't have a code now and I also don't have any bluetooth device to rewrite it again. But the main idea is:\n1)to look for a device\n2)to try to connect to the discovered one\n3)to \"discover services\" of the connected one\n4)to \"discover characteristics\" for the discovered service\n5)to read characteristic's values\nAnd there is error handling somewhere here.\nEach action from the listed above is a separate delegate method which is called asynchronously and may be called multiple times for the same device. I think it could be better to link all these methods into one \"promise sequence\".\nBut anyways you need at least a BLE device. I recommend you a beacon for 2 reasons:\n- it is enough cheap\n- specifically for beacons apple added iBeacon library which you can also use to check the result.\n. but carthage seems to be workable\n. I have found out that it is the same problem as the following one:\nhttps://github.com/mxcl/PromiseKit/issues/244#issuecomment-132622760\n. AdvancedSearchPlugin is the name of my project in which I try to import PromiseKit. It doesn't work even if I try to remove it from the xcode plugins folder with the same error.\nJust install Alcatraz, then install \"xcode template\" via it, then create an empty project from this template and try to use PromiseKit in it\n. contrawise it seems more common problem (which belongs to cocoapods too). Plugin target doesn't have \"general\" section so for example you can't simply drag a framewok into your project. If cocoapods depends pn the same or similar feature then it is the problem of xcode or cocoapods, or the similar importing system but not because of the target.\nAnd of course you could avoid this problem by giving a way to import your library as sources.\n. When I said \"silly\" I just meaned that the included instructions are totally unclear and ambiguous. But yes, anyway that won't solve my problem\n. unclear for me:\n2. ?\n3. ? And a lot of errors occur if I just try to import something which uses your framework. And in general doesn't your framework already include these sources?\n5. Just for swift project or for objective C too?\n. Thanks. But this extended info is also needed to include in that txt file with instructions.\n. ",
    "foobar8675": "@gerchicov-bp you can also look bluetoothkit. doesn't take u all the way there, but might be helpful, if you only have 1 char on ur services\n. got it. thanks!\n. @lifely that's exactly what i was looking for!\n. ",
    "dgrekov": "Also noticed that it builds fine through Xcode directly. It seems to only crash when building command line. \n\nOn Aug 16, 2015, at 18:44, marlowcharite notifications@github.com wrote:\n@mxcl builds fine through cocoapods so might want to switch to that @dgrekov\n\u2014\nReply to this email directly or view it on GitHub.\n. More specifically it's an issue with this line (45-47):     \n\nprivate override init(@noescape resolvers: (fulfill: (NSData) -> Void, reject: (ErrorType) -> Void) throws -> Void) {\n        super.init(resolvers: resolvers)\n    }\nthis is what the compiler takes issue with.\n. ",
    "samritchie": "It\u2019s not an issue with command line builds per se, it crashes for all release builds. Definitely a bug in the compiler, but it might be worthwhile turning off optimisations on Release builds for the beta5 branch.\n. ",
    "benzguo": "looks like the \"swift-2.0-minimal-changes\" branch compiles fine with carthage, but \"swift-2.0-beta5\" does not.\n. ",
    "tomblah": "Ah, whoops, good point, sorry\n. ",
    "newlix": "Nice!  Swift 2 branch is elegant. Thank you. \n. ",
    "cmckni3": "Should probably add support for the Contacts framework since ABAddressBook was deprecated in iOS 9.\n. I just ran into the same problem.\nIs there additional documentation available? I don't mind looking through the code but it's not as convenient.\n. ",
    "sethsamuel": "Looks like it was a finicky casting issue. Thanks for the tips, still getting used to Swift and the compiler is, shall we say, less than helpful at times.\n. ",
    "pidjay": "Hi there! Did you have any luck with this code signing error? I've just got the same issue today, and I can't seem to figure out how to solve it...\n. It did help at least one person. Thank you nevans!\n. ",
    "kylemiller3": "I am using the lowest priority possible DISPATCH_QUEUE_PRIORITY_BACKGROUND and it still crashed the app. So there is no other way to do this but to manually manage the threading? Is there some sort of example you could provide where I could use wrap dispatch groups with promises?\nEdit: I noticed you considered implementing NSOperationQueues on a separate issue. Are you still considering this? If I could dispatch on a NSOperationQueue, I could change its maxConcurrentOperationCount property - which would make this issue trivial, and let PKMWhen scale up with task counts efficiently. \n. Yes I am sure. It's happening on multiple iPhones. Here is a crash log:\n\nApplication Specific Information:\nfailed to scene-update in time\nElapsed total CPU time (seconds): 8.260 (user 8.260, system 0.000), 40% CPU \nElapsed application CPU time (seconds): 0.005, 0% CPU\nThread 2 name:  Dispatch queue: com.apple.root.default-qos\nThread 2:\n0   libsystem_kernel.dylib         0x00000001966b4e48 semaphore_wait_trap + 8\n1   libdispatch.dylib              0x0000000196597f3c _dispatch_semaphore_wait_slow + 252\n2   My work function\n.....\nThread 71 name:  Dispatch queue: com.apple.root.default-qos\nThread 71:\n0   libsystem_kernel.dylib         0x00000001966b4e48 semaphore_wait_trap + 8\n1   libdispatch.dylib              0x0000000196597f3c _dispatch_semaphore_wait_slow + 252\n2   My work function\n\nSome threads are fulfilled in between some are not. If I serialize the code on a serial queue it works just as expected. I have an idea maybe for dispatch group I'll see if I can come up with something to work around this.\nEdit: I should note that the above was from a higher priority queue . I have tried it with the lowest and I get the same results. Nearly 70 threads spawn before stuff breaks, priority doesn't seem to matter.\nHere is one from a different phone an hour ago on DISPATCH_QUEUE_PRIORITY_BACKGROUND queue:\n\nThread 70:\n0   libsystem_kernel.dylib         0x0000000195e34e48 semaphore_wait_trap + 8\n1   libdispatch.dylib              0x0000000195d17f3c _dispatch_semaphore_wait_slow + 252\n2   My work function\n\nThere are a total of 75 threads in this one.\n. Is this not an issue though? I feel like I cannot use PMKWhen for it's intended purpose since I cannot select how little or how much concurrency happens in the system and there is no way to work within the framework to do so. If I do make a workaround using dispatch groups, does that not make PMKWhen pointless?\nEdit: Perhaps more appropriate solution for me would be plain old semaphores - for 4 threads:\nsemaphore create(4)\nfor {\ngrab semaphore blocking forever\ndispatch promise background priority q {\ndo work here...\nrelease semaphore\n}.then store results in fake PMKWhen array\n}\nfor 1:4 {\ngrab semaphore blocking forever //done condition\n}\nreturn PMKPromise with value fake PMKWhen array\nNo function for PMKWhen or, more appropriately, I might be reinventing the PMKWhen wheel with this code, so to speak.\n. There are a few reasons why I do not believe I am actually blocking the main thread. Firstly, the main thread UI remains responsive until I go to another view that adds more background work. That is when it locks the main thread, not before. Secondly, all the work units are independent with each other. None of them use the same resources except the same network queue. Thirdly, when I serialize the code on a background thread, there is no locking at all on the main thread. Lastly, the worker threads \"freeze\" while the main UI is still responsive. These combined suggest to me that it is due to too many threads, not a real deadlock on the main thread. I will do another test, to see if they are truly independent or not, with something modest like 4 threads to see if I still experience the same problem. \nRegardless, I see 70+ threads as undesirable even if there is some bug in the code causing the lock on the main thread. That is so many for worker threads that the performance hit from context switching probably outweighs the gains from threading itself - that is conjecture on my part but theoretically there is a point where too many threads outweigh any parallelism you apply. \nI understand and appreciate the design philosophy and that it should be agnostic to the underlying mechanism of concurrency. It's not in the scope of the project to make a scheduler or anything of that nature. However, I do think it would make sense to give the programmer more options to deal with this issue though. I'd be willing to work on a NSOperationQueue implementation but I do not really know where to start nor have a good idea to make it general. My only idea would be to make an implementation that is parallel to the dispatch_promises on NSOperationQueue. Not sure how that it would interact either.\n. I have implemented the solution I sketched above with semaphores. I can tell you that it works with 4 threads and as many as 50 as expected with no deadlocks on the main thread. I do not believe this is in any way related to a real deadlock on the main thread, combined with the reasoning above.\n. I'll go ahead and close this. You are probably correct in saying there is a problem somewhere in the code and since it is not in the scope of PromiseKit to care about how many threads are spawned, then the issue is resolved with the semaphore code. Thank you for your time.\n. ",
    "brianhv": "For the moment I've been able to work around this by creating a header with the following:\n``` objc\n@protocol Promisable\n@end\nimport \"MyProductModule-swift.h\"\n```\n...and having my ObjC code import that instead of importing MyProductModule-swift.h directly.\n. To be clear, I'm not actually trying to use the class in question in ObjC at all. It gets put into the autogenerated header even though I don't want it to be. Just implementing the protocol in a Swift class causes the compilation to fail.\n. Someone created a fork here with the (very small) change required to fix this error.\nFork: https://github.com/SLab7/PromiseKit/tree/swift-2.0-minimal-changes\nCommit: https://github.com/SLab7/PromiseKit/commit/1ffca8f0bb5dbce68d7f921a208527896b98a1fd\n. ",
    "rupertdaniel": "Ahh yeah sorry should have included a comment.\nThis allows for the framework to be used as an embedded framework within the app bundle. The current setting means the framework needs to be installed in /Library/Frameworks for it to be found at runtime.\nI think the most common use case is the framework to be used as an embedded framework.\n. ",
    "bgerstle": "Sorry I didn't do this at first, but I created an example project which:\n- Uses mxcl/PromiseKit swift-2.0.beta5 via Carthage\n- Has a Swift NSObject subclass, which has a function returning AnyPromise\n- Has an ObjC ViewController which tries to import the project's Swift class and call the function returning AnyPromise\nWhich results in the following error:\n\n/Users/bgerstle/Code/PMKInteropExample/PMKInteropExample/ViewController.m:22:50: error: property 'then' cannot be found in forward class object 'PMKAnyPromise'\n    [[SwiftClassWithPromise new] doSomethingAny].then(^(id value) {\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\nIn file included from /Users/bgerstle/Code/PMKInteropExample/PMKInteropExample/ViewController.m:11:\n/Users/bgerstle/Code/PMKInteropExample/Build/Intermediates/PMKInteropExample.build/Debug-iphonesimulator/PMKInteropExample.build/DerivedSources/PMKInteropExample-Swift.h:94:8: note: forward declaration of class here\n@class PMKAnyPromise;\n. If I update the Cartfile to point at my fork, the problem goes away.\n. So you're proposing to drop PMKAnyPromise entirely?  Seems like a decent trade-off of user convenience for breaking Cocoa namespace prefix conventions.\n\nOTOH, what would happen if you let the definition in AnyPromise.swift stand alone?\nswift\n@objc(PMKAnyPromise) public class AnyPromise\nThis should allow all Swift code to reference AnyPromise and all ObjC code to reference PMKAnyPromise.  I wonder if you could even add an empty AnyPromise ObjC class with an unavailable attribute which warns users to use PMKAnyPromise in ObjC instead?\n. ",
    "johanwigmo": "I tried the asVoid() method as @ldiqual mentioned but sometimes promise.value returns nil and I can't figure out why. \n``` swift\nlet promise1 = getGames() // func getGames() -> Promise<[Game]>\nlet promise2 =  getUser() // func getUser() -> Promise\nvar promises: [Promise] = [promise1.asVoid(), promise2.asVoid()]\nwhen(promises).then {\n  _ -> Void in\nif let games = promise1.value {\n    self.games = games\n  }\nif let user = promise2.values {\n    self.user = user\n  }\n}\n```\n. ",
    "sahandnayebaziz": "I don't believe it does. These are the messages I get when trying pod install.\nmaster:\n[!] The platform of the targetFSWatchKit Extension(watchOS 2.0) is not compatible withPromiseKit (2.2.1), which does not supportwatchOS.\nswift-2.0-beta5:\n[!] The platform of the targetFSWatchKit Extension(watchOS 2.0) is not compatible withPromiseKit (3.0.0), which does not supportwatchOS.\n. I forked to add the deployment target and discovered this! \nThe platform of the targetFSWatchKit Extension(watchOS 2.0) is not compatible withOMGHTTPURLRQ (3.0.0), which does not supportwatchOS.\nShould I create an issue in OMGHTTPURLRQ?\n. No, not using any of the networking. I just want to make this as easy as possible for you. \nMade an issue in OMGHTTPURLRQ and made PR's in both.\n. I just discovered something that I'm not sure how to handle. \nIncluding all of PromiseKit into a watchOS target doesn't build because it hits a snag trying to import QuartzCore/QuartzCore.h. Including only CorePromise works just fine (and maybe makes more sense?).\nHow do you think we should handle this?\n. Great. That makes sense. Do you think that should be in the documentation?\n. Thank you! I didn't know you could do that. I will do that next time :)\n. @rlam3 at a higher level too, Promises (and PromiseKit) are just a tool you can use to write code that needs to go off and do some stuff and return at some unknown time. \nWhere a simple line print(\"hello world\") executes immediately, something like fetchWeatherIn(state: California) doesn't execute immediately because it makes an HTTP request, and then waits for a response, and then parses the response, (etc, etc, etc). So if you wanted to have something happen  after fetchWeatherIn was all done, you'd have to write some tricky code yourself to wait for it to finish, or keep checking to see if it's finished, or something even more clever. Promises are a well-accepted way for writing code like this, and saying \"this runs, at some point it comes back when it's finished, and then ..... do the next thing!\". Promises also exist in the other big languages, so learning how to use them is valuable for the world outside of Swift.\nSo with Promises, you can write code that \"waits\" for things to happen and yet is easy to read. It's possible to do everything you can do with Promises without using Promises, but you'll end up writing a lot of code to do very basic things that have nothing to do with what your app is actually trying to accomplish.\nRxSwift is a much bigger idea and promotes a different way of writing apps in general. PromiseKit is great to include in any project that does asynchronous stuff (stuff that does not execute immediately), regardless of whether or not you are using RxSwift.\n. ",
    "morten-holm": "Could you please add a target 'PMKWatchOS' to PromiseKit so it's possible to use with Carthage?\n. ",
    "x-l-ent": "Is it possible to use CocoaPods to get PromiseKit working on watchOS 2? If so, how? Thanks.\n. ",
    "mofirouz": "Please refer to this if you are using PromiseKit 1.6.x:\nhttps://github.com/mxcl/PromiseKit/issues/311#issuecomment-187140360\n. Thanks @staminajim - It seems like WatchOS is working, but tvOS is still no go.\n. Sadly I don't have a target that will enable that as well. I've added support for it in the library that I'm building for whenever PromiseKit adds that in.\nOn 24 February 2016 at 10:05:12, James V (notifications@github.com) wrote:\n@mofirouz does it work if you add\ns.tvos.deployment_target = '9.0' to the 1.6.0 pod spec?\nI don't have any tvOS targets set up to quickly try that.\n\u2014\nReply to this email directly or view it on GitHub.\n. @mxcl I would but I honestly don't know where/which branch the code for the 1.6.x release is - similar to what @staminajim said above. \nIf you could advise on the git strategy for this project, I'll open a PR asap.\n. Hi @nathanhosselton thanks for merging the PR in. Could I kindly ask for a new release of the 1.x branch so I can upgrade to it and use it in my code please? Thanks.\n. @nathanhosselton A tag + cocoapods, please :)\n. Thank you ever so much @nathanhosselton for this. I've integrated it and it seems to work. :+1: \n. @mxcl As you said, you can't create a PR based off a tag, but you can still commit the code without a branch to a new tag - the catch is only the owners can do that (because you are pushing directly to a commit/tag not to a PR).\nI personally vote that for the sake of clarity for potentially future PRs, we create a branch for 1.x branch?\n. Thanks a lot @nathanhosselton - Let me know when I should rebase the code for easier merge for you guys.\n. I'm closing this in favor of a new PR that is based on the legacy-1.x branch.\n. This is the error I get when I try to do carthage update on the 1.7.2 version:\nA shell task (/usr/bin/xcrun xcodebuild -project /heroiclabs-sdk-ios/Carthage/Checkouts/Promisekit/PromiseKit.xcodeproj -scheme PMKOSX -configuration Release CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES -showBuildSettings) failed with exit code 66:\nxcodebuild: error: Scheme PMKOSX is not currently configured for the build action.\n. Hi @mxcl thanks so much for the prompt work. This works as expected now. Cheers.\n. ",
    "alexd6631": "Please forget this issue,\nI have overlooked that the NSError contains the response object, which allows me to retrieve the status code.\n. Seems it was fixed by this commit : https://github.com/mxcl/PromiseKit/commit/cc91705174a4f331b24ebb22fcd12f03f16776e3\n. ",
    "slavikus": "Yay! :) Thanks.\n. ",
    "wovencharlie": "+1 \n. ",
    "JALsnipe": "@dbachrach has a great solution, but also causes PromiseKit to import some UIKit extensions that are unavailable on tvOS.  I modified his Podfile to import only the modules I needed:\n```\nhttps://github.com/mxcl/PromiseKit/issues/268\nplatform :ios, '8.0'\nuse_frameworks!\ninhibit_all_warnings!\npod 'PromiseKit/CorePromise'\npod 'PromiseKit/Foundation'\npod 'PromiseKit/SystemConfiguration'\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        target.build_configurations.each do |config|\n            config.build_settings['SUPPORTED_PLATFORMS'] = ['appletvos', 'appletvsimulator'];\n        end\n    end\nend\n```\n. ",
    "lagerkoller": "it does not seem like this still works in the current version of cocoa pods (1.0.0.beta.2). my podfile requires this as the platform: 'platform :tvos, '9.0''\nso this does not work:\n```\nplatform :tvos, '9.0'\nuse_frameworks!\ntarget 'XYZ' do\n  inhibit_all_warnings!\n  pod 'PromiseKit'\npost_install do |installer|\n      installer.pods_project.targets.each do |target|\n          target.build_configurations.each do |config|\n              config.build_settings['SUPPORTED_PLATFORMS'] = ['appletvos', 'appletvsimulator'];\n          end\n      end\n  end\nend\n```\nany ideas on how this could work in the current cocoa pods version?\n. ",
    "ml-tx": "How did you include it into your existing project, I'm having some problems\n. ",
    "franksrevenge": "@chimp7: Downloaded the project, loaded it in Xcode, let Xcode auto-convert the Swift code, and built. Very straight-forward.\n@mxcl: Understood. Could you consider a Swift 2 build at some point, though? This is stopping use of the standalone build on Xcode 7, after all.\n. ",
    "toddrick": "Is there a timeline for this? Pretty obnoxious to build from source if you're using Carthage, means you have to remove PromiseKit altogether and re-add.\n. ",
    "cjhenck": "The 2.2.2 download also doesn't seem to have the framework in the iOS folder (or am I missing something?)\n. ",
    "fallback": "@cjhenck Observing the same.\n. ",
    "gPinato": "That's exaclty what I was looking for, I dont' know how I missed it.\nI manage to get it work by pushing all promises into an array and put that array into a when.\n(Seems to) work like a charm.\nThanks!\n. ",
    "remotevision": "thanks @mxcl, I appreciate the quick response. I'm familiar with javascript promises but this is my first Swift app so perhaps I'm stumbling over the syntax. I am using Swift 2, so I appreciate the recommendation for cleaner syntax using guard. \nIt still throws a similar error on these 2 lines:\nswift\nguard let weight = sample as? HKQuantitySample else { return self.kUnknownString }\nguard let pounds = weight.quantity.doubleValueForUnit(HKUnit.poundUnit()) else { return self.kUnknownString }\nError: \nswift\nCannot convert return expression of type 'String' to return type 'Promise<String>'\nwhat am I missing?\n. \n. wow, that did it! Ok, so this is my first Swift app. Would you consider this a bug in Swift or is this expected behavior? Seems odd considering weightFormatter.stringFromValue() returns a String.\nThanks for your help!\n. ",
    "opfeffer": "Tried every possible variation. No luck.\nWeirdly enough, including <PromiseKit/PromiseKit.h> in my *-Prefix.pch seems to fix it. Can't really make sense out of that though.... Open for ideas!\n. I am seeing this issue resurface with PromiseKit 3.4.0 and Carthage 0.16.2\n. Thanks boss!\n. someOtherAnyPromise() returns an instance of AnyPromise (as it is written in ObjC). See code:\n- (AnyPromise *)someOtherAnyPromise {\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver  _Nonnull resolve) {\n        dispatch_time_t dispatchTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC));\n        dispatch_after(dispatchTime, dispatch_get_main_queue(), ^{\n            resolve(@NO);\n        });\n    }];\n}\nI should have mentioned, in a pure ObjC implementation the second then correctly has the NSNumber as parameter..\nIts only in Swift where the parameter suddenly is of type AnyPromise... which doesn't seem to make sense to me\n. Yea that was it. Without specifying my return type, Swift did assume the wrong then() method..\n. Devil is in the details. --platform iOS works. --platform ios (all lowercase) doesn't. My bad! Thanks for all the hard work, great framework! Closing\n. #love.  thanks sir\n. ",
    "charlyliu": "Hello,\nI'm having this problem too and I found a workaround that may be a bit ugly but seems to work.\nI paste here my playground so you can see the whole process.\n```\nimport Foundation\nimport PromiseKit\nimport XCPlayground\nlet error = NSError(domain: \"a\", code: 1, userInfo: [\"hello\":\"hello\"])\n// Only casting won't lose the user info\nlet castedError = error as ErrorType\nlet stillHaveUserInfo = castedError as NSError\n// when using promises\nfunc convert(error: ErrorType) -> Promise {\n    return Promise {\n        (fulfill, reject) in\n        reject(error)\n    }\n}\nlet promiseA = convert(error)\n// Seems to lose the user info once we cast back to NSError\npromiseA.report { (promiseError) -> Void in\n    let lostUserInfo = promiseError as NSError\n}\n// Workaround\nprotocol CastingNSErrorHelper {\n    var userInfo: [NSObject : AnyObject] { get }\n}\nextension NSError : CastingNSErrorHelper {}\npromiseA.report { (promiseError) -> Void in\n    let castingNSErrorHelper = promiseError as! CastingNSErrorHelper\n    let recoveredErrorWithUserInfo = castingNSErrorHelper as! NSError\n}\nXCPSetExecutionShouldContinueIndefinitely()\n```\n. ",
    "andi357": "I experienced the same issue. I found that the problem occurs only within the report block and only if the ErrorPolicy is set to .AllErrorsExceptCancellation. So I took a look at the code and saw that PromiseKit makes a cast to CancellableErrorType before and passes that casted error object to the body block:\ncase (let .Rejected(error as CancellableErrorType, token), .AllErrorsExceptCancellation): // Cast to CancellableErrorType\n    dispatch_async(dispatch_get_main_queue()) {\n        if !error.cancelled {    \n            consume(error, token) // Pass the casted error object to body\n        }\n    }\nWhen I now try to cast the error within the report's bodyblock again (to a NSError) I loose all my userInfo (which is really important for me to keep):\nreport { error in\n    let myError = error as NSError\n    // ... do something with the error, but without the userInfo :-(\n}\nThe problem seems to be solved if report casts the error into an intermediate variable and performs its check for !cancelled on this private instance and then passes the original error to the body block:\ncase (let .Rejected(error, token), .AllErrorsExceptCancellation):\n    dispatch_async(dispatch_get_main_queue()) {\n        if let cancellableError = error as? CancellableErrorType where !cancellableError.cancelled {\n            consume(error, token)\n        }\n    }\nUsing this implementation I can cast the error to an NSError like shown in my report{...} implementation above and will keep the userInfo.\n. Oh no, I saw that I made a mistake in my pull request. I will fix it later. The fix should be more like this:\nguard let cancellableError = error as? CancellableErrorType where cancellableError.cancelled else {\n    consume(error, token)\n    return\n}\nInstead I checked exactly the opposite condition and consumed the error only if the error IS a cancellation error.\nif let cancellableError = error as? CancellableErrorType where !cancellableError.cancelled {\n    consume(error, token)\n}\n. I fixed the issue. Now everything works fine and as expected.\n. ",
    "thomasneuteboom": "I'm (still) having the same problem using 'when':\nwhen(promiseOne, promiseTwo).then { responseOne, responseTwo -> Void in\n      // response handling here..\n    }.error { error in\n        print(error)\n        print(error as NSError)\n}\nPrints:\nWhen(0, Error Domain=com.alamofire.error Code=-6006 \"JSON could not be serialized. Input data was nil or zero length.\" UserInfo={NSLocalizedFailureReason=JSON could not be serialized. Input data was nil or zero length.})\nError Domain=PromiseKit.Error Code=0 \"(null)\"\n. @swaffoja It returns: \nError\nStrangely this seems to work:\n```\npromiseOne().then { responseOne -> Promise in\n        // Handle response one..\n    return promiseTwo()\n\n}.then { responseTwo -> Void in\n\n    // Handle response two..\n\n}.error { (error: ErrorType) -> Void in\n\n    // Workaround\n    // See: http://stackoverflow.com/questions/32572033/casting-customnserror-to-errortype-to-nserror-loses-userinfo\n    print(((error as Any) as! NSError))\n\n}\n```\nPrints:\nError Domain=com.alamofire.error Code=-6006 \"JSON could not be serialized. Input data was nil or zero length.\" UserInfo={NSLocalizedFailureReason=JSON could not be serialized. Input data was nil or zero length.}\n. ",
    "swaffoja": "Out of curiosity, what does the dynamicType for error show? E.g. \n}.error { error in\n    print(error.dynamicType)\n}\nI wouldn't expect error to be of type NSError in Swift. It should be some sort of ErrorType.\n. That gave a complier error Value of type 'ErrorType' has no member 'userInfo' but I think it set me down the correct track. I have been able to get the statusCode using this:\n```\nif let response: URLError = error as? URLError {\n    print(response.NSHTTPURLResponse.URL)\n    print(response.NSHTTPURLResponse.statusCode)\n    print(response.NSHTTPURLResponse.allHeaderFields)\n}\n// ALTERNATIVELY\nswitch error {\n    case let response as URLError:\n        print(response.NSHTTPURLResponse.statusCode)\n        print(response.NSHTTPURLResponse.statusCode)\n        print(response.NSHTTPURLResponse.allHeaderFields)\n    default:\n        print(error.dynamicType)\n}\n```\nHowever, I haven't been able to figure out how to get the body of the response yet. Error.swift seems to show that URLError BadResponse knows about the body (i.e. NSData?) but doesn't seem to make it accessible:\ncase BadResponse(NSURLRequest, NSData?, NSURLResponse?)\nAny thoughts on how to get the body? Thanks for the help!\n. \"Enumeration > Associated Values\" documentation for Swift showed me the correct syntax.\n```\nswitch error {\ncase URLError.InvalidImageData(let request, let data):\n    print(\"(request) (data)\")\ncase URLError.UnderlyingCocoaError(let request, let data?, let response?, let nserror):\n    print(\"(request) (data) (response) (nserror)\")\ncase URLError.BadResponse(let request, let data?, let response?):\n    print(\"(request) (data) (response)\")\ncase URLError.StringEncoding(let request, let data, let response):\n    print(\"(request) (data) (response)\")\ndefault:\n    print(error.dynamicType)\n}\n```\nhttps://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID148\n. +1\n. Here's how I would write it. If you don't want to use firstly then I can rewrite it without... I just really like how it reads.\n```\nimport Foundation\nimport UIKit\nimport PromiseKit\nimport SwiftyJSON\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = true\n\n    firstly {\n\n        return when(getUsers(), getPhotos(), getComments())\n\n    }.then { (userData: NSData, photoData: NSData, commentData: NSData) -> Void in\n\n        let userJson = JSON(data: userData)\n        print(userJson)\n\n    }.always {\n\n        UIApplication.sharedApplication().networkActivityIndicatorVisible = false\n\n    }.error { error in\n\n        print(error)\n\n    }\n\n}\n\nfunc getUsers() -> URLDataPromise {\n    return NSURLConnection.GET(\"http://jsonplaceholder.typicode.com/users\")\n}\n\nfunc getPhotos() -> URLDataPromise {\n    return NSURLConnection.GET(\"http://jsonplaceholder.typicode.com/photos\")\n}\n\nfunc getComments() -> URLDataPromise {\n    return NSURLConnection.GET(\"http://jsonplaceholder.typicode.com/comments\")\n}\n\noverride func didReceiveMemoryWarning() {\n    super.didReceiveMemoryWarning()\n    // Dispose of any resources that can be recreated.\n}\n\n}\n```\n. Here is a version that shows you chaining...\n```\nimport Foundation\nimport UIKit\nimport PromiseKit\nimport SwiftyJSON\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = true\n\n    firstly {\n\n        return getUsers()\n\n    }.then { (userData: NSData) -> NSData in\n\n        let userJson = JSON(data: userData)\n\n        return getPhotos()\n\n    }.then { (photoData: NSData) -> NSData in\n\n        let photoData = JSON(data: photoData)\n\n        return getComments()\n\n    }.then { (commentData: NSData) -> Void in\n\n        let commentData = JSON(data: commentData)\n\n        // Not returning anything, so closure returns Void... not AnyPromise\n\n    }.always {\n\n        UIApplication.sharedApplication().networkActivityIndicatorVisible = false\n\n    }.error { error in\n\n        print(error)\n\n    }\n\n}\n\nfunc getUsers() -> URLDataPromise {\n    return NSURLConnection.GET(\"http://jsonplaceholder.typicode.com/users\")\n}\n\nfunc getPhotos() -> URLDataPromise {\n    return NSURLConnection.GET(\"http://jsonplaceholder.typicode.com/photos\")\n}\n\nfunc getComments() -> URLDataPromise {\n    return NSURLConnection.GET(\"http://jsonplaceholder.typicode.com/comments\")\n}\n\noverride func didReceiveMemoryWarning() {\n    super.didReceiveMemoryWarning()\n    // Dispose of any resources that can be recreated.\n}\n\n}\n```\n. I probably wouldn't include these exact examples as they rely on SwiftyJSON, but I agree that updated Swift documentation on promisekit.org would be appreciated. I know there are are swift compiler issues that cause some of the existing examples to fail. It comes down to who is willing to revist the documentation and who has access to make changes.\nMy mastery of Swift isn't even close to that of the original PromiseKit author's mastery, so I have been hesitant to suggest updates to the documentation. It's also not clear on how someone would contribute as I haven't found a github repo that maps to the promisekit.org site. I actually enjoy writing documentation and would be willing to take a stab at updating Swift examples.\nI would assume there are apps in production that use PromiseKit. I've been writing an app for a few months and I think PromiseKit is amazing. I certainly plan to use it for all of my future projects. I'm secretly hoping that Apple implements Promises because the resulting code is so much cleaner.\n. Are you using PromiseKit 2 or 3? There were some changes between the two versions. catch was renamed to error. PromiseKit 3 would be:\nNSURLConnection.GET(\"http://placekitten.com/\\(width)/\\(height)\").then { (image: UIImage) in\n    self.imageView.image = image\n}.error { error in\n    // do stuff\n}\n. It would be nice for one of your solutions to be implemented. I like idea 3 myself. In my case I really don't care which of my \"when\" promises failed and thus don't need the index. It is important to have the index available in some cases, but my code would be cleaner if I could wrapErrors: false. I currently have code that looks something like this and it feels pretty clunky.\n```\n}.error { error in\nswitch error {\ncase Error.When(_, let err):\n\n    switch err {\n    case URLError.BadResponse(let request, let data?, let response?):\n        // handle BadResponse\n    default:\n        // ...\n    }\n\ndefault:\n    // ...\n}\n\n} \n```\nI'll probably use your flattenPromiseError function in the meantime.\n. This should be covered on StackOverflow now. I added a longer example that I think will explain what is going on.\nhttp://stackoverflow.com/questions/34501537/ambigous-use-of-recover-error-while-using-promisekit/34502275#34502275\n. Check out the method signatures for when. It takes up to 3 promises. You can however give it an array of promises if you need more than 3.\n```\nlet promise1 = Promise(1)\nlet promise2 = Promise(2)\nlet promise3 = Promise(3)\nlet promise4 = Promise(4)\n// SUCCESS, up to 3 promises OK\nwhen(promise1, promise2, promise3).then { response1, response2, response3 in\n    print(\"test promises fulfilled (response1) (response2) (response3)\")\n}.error { error in\n    print(\"error\")\n}\n// FAIL, when only accepts up to 3 promises. look at method signature\nwhen(promise1, promise2, promise3, promise4).then { response1, response2, response3, response4 in\n    print(\"test promises fulfilled (response1) (response2) (response3) (response4)\")\n    }.error { error in\n        print(\"error\")\n}\n// SUCCESS, Just use an array of promises if you need more than 3\nlet promises = [promise1, promise2, promise3, promise4]\nwhen(promises).then { responses in\n    print(\"test promises fulfilled (responses)\")\n}.error { error in\n    print(\"error\")\n}\n```\n. I'm not familiar with SLRequest, but the last post on this thread may help you access the BadResponse if you are using Swift.\n. ",
    "gregkerzhner": "@thomasneuteboom and @swaffoja I stumbled onto this discussion trying to figure out why I was losing my errors as well.  After some digging, it turns out the errors are not being lost.  It just happens that in the case of a \"when\" call, the errors are being wrapped inside a PromiseKit.Error object which looks like this:\n``\npublic enum Error: ErrorType {\n    /**\n     The ErrorType for a rejectedwhen.\n     - Parameter 0: The index of the promise that was rejected.\n     - Parameter 1: The error from the promise that rejected thiswhen`.\n    */\n    case When(Int, ErrorType)\n/**\n The ErrorType for a rejected `join`.\n - Parameter 0: The promises passed to this `join` that did not *all* fulfill.\n - Note: The array is untyped because Swift generics are fussy with enums.\n*/\ncase Join([AnyObject])\n\n/**\n The closure with form (T?, ErrorType?) was called with (nil, nil)\n This is invalid as per the calling convention.\n*/\ncase DoubleOhSux0r\n\n/**\n A handler returned its own promise. 99% of the time, this is likely a \n programming error. It is also invalid per Promises/A+.\n*/\ncase ReturnedSelf\n\n}\n```\nNote that this is different from a simpler \"then\" call which just returns the errors directly (presumably because \"when\" failures are more complicated and this extra error enum container returns additional information about how the multiple promises failed.\nTo get to the actual error that happened inside the promise, you need to unwrap that Enum, like so:\n```\npromiseOne().then { responseOne -> Promise in\n        // Handle response one..\n        return promiseTwo()\n}.then { responseTwo -> Void in\n    // Handle response two..\n}.error { (error: ErrorType) -> Void in\n        switch error as? PromiseKit.Error {\n        case .When(_, let error)?:\n            //here you finally have access to your original error object\n            print(error)\n        default:\n            break\n        }\n\n}\n```\n. ",
    "michaelzoech": "+1 for having a report/error with a custom queue. I'm currently integrating PromiseKit into an existing application where the error handling is not executed on the main thread most of the time. Not having this functionality changes the threading behavior of the app. It would be easier to simply replace the current dispatch_* and queues with promises if error/report could be executed on a custom queue, instead of doing it in one big change.\n. I have quite a few blocks that look similar to this:\nfunc doSomething(param0: String) -> Promise<String> {\n    return dispatch_promise(on: queue) {\n        if someCheck(param0) {\n             throw MyError\n        }\n    }.then(on: queue) {\n        return self.obj.doActualWork(param0)\n    }\n}\nThe if block and self.obj.doActualWork belong to each other. They are tied to each other. Having the additional line with }.then(on: queue) { adds a mental separation where none should be.\nFurthermore, the code should run as one atomic action on queue, which is not possible if the additional then is necessary.\n. Still new to PromiseKit. Would this be the way to go then?\nreturn Promise().then(on: queue) {\n    ....\n}\nI initially thought that init() is not exposed.\n. ",
    "kdubb": "I incorrectly pushed to this branch which compounded the original changes I was trying to get integrated.  I will break them out into their own branches/PRs for clarity.\n. Status?\n. The typo was fixed in another commit so cancel rejects the promise.  My PR also makes the Error a CancellableErrorType so that you can use the cancel button as a way to cancel the promise.  That doesn't appear in the latest version of the file.\n. Rebased.\n. Good catch... no idea what I had done there.  Fixed.\n. Status?\n. Rebased. Not sure why Github decided to show the entire history to rebase my 2 commits.\n. ",
    "Sljux": "+1\n. ",
    "kanekin": "+1\n. @soundbites Do you need to use PromiseKit for watch development?\nOtherwise, you can avoid the error by using:\ncarthage update --platform iOS\n  carthage update --platform Mac\n. ",
    "soundbites": "thx @kanekin this will work for now.\n. ",
    "loryhuz": "Yes this is the content of saveAddress, which is not executed. Seems to be logic since I've read from the doc I've to use promiseWithResolver. PromiseWithResolver work fine if I just put a native block like \"UIView withanimation on completion\" but not when I wrap my own block (the one you copy-pasted).\nYes it's resolve since it's catch an error when it fail and continue to the next then after\nSo at the end I've also tested with these things:\n```\n- (AnyPromise *)test {\nNSMutableDictionary *parameters = [[NSMutableDictionary alloc] init];\n\nDataController *dataController = [DataController sharedController];\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver  _Nonnull resolve) {\n    [dataController\n     saveAddressWithParameters:parameters\n     andOnCompletion:^(BOOL success, NSString *message, GDataXMLDocument *xmlDoc) {\n         resolve(message);\n     }];\n}];\n\n}\n```\nAnd the call in my controller:\n```\n[self getCleanAddressFrom:userInputDic].then(^(SSStreetAddressResponse addressResponse){\n                cleanAddress = addressResponse;\n            }).catch(^(NSError error){\n                NSLog(@\"%@\", error);\n        }).then(^(){\n            return [self test];\n        });\n\n```\nWith this test I've the same behavior, code isn't executed and I've the message \"Pending promise deallocated\" called twice\n. Here it is:\n```\npragma mark - Smartystreets validation\n\n\n(AnyPromise )getCleanAddressFrom:(NSDictionary )userInputDic {\n    NSError err;\n    SSStreetAddressRequest addressRequest = [[SSStreetAddressRequest alloc] initWithDictionary:userInputDic error:&err];\nreturn [self.smartyStreetClient verifyStreetAddress:addressRequest].then(^(SSStreetAddressResponse *response){\n    return response;\n});\n}\n```\n\n\nAlso the veryfyStreetAddress promise:\n```\n- (AnyPromise )verifyStreetAddress:(SSStreetAddressRequest )address {\n    NSMutableDictionary *requestParams = [[NSMutableDictionary alloc] initWithDictionary:[address toDictionary]];\n    [requestParams setObject:self.authID forKey:@\"auth-id\"];\n    [requestParams setObject:self.authToken forKey:@\"auth-token\"];\nreturn [NSURLConnection GET:[self urlForEndpoint:SSServiceEndpointStreetAddresses] query:requestParams].then(^(NSArray *dataAR) {\n    if (dataAR && [dataAR count] > 0) {\n        NSDictionary *data = [dataAR firstObject];\n        NSError *err;\n        SSStreetAddressResponse *response = [[SSStreetAddressResponse alloc] initWithDictionary:data error:&err];\n\n        if (err) {\n            @throw err;\n        }\n\n        return response;\n\n    } else {\n        @throw [[NSError alloc] initWithDomain:@\"SmartyStreetsFailure\" code:0 userInfo:@{NSLocalizedDescriptionKey:@\"Smartystreets API returned nothing\"}];\n    }\n});\n\n}\n``\n. I'm onPromiseKit 3.0.0andXcode 7.0`\nThis bug only appear when I wrap chained non-promise async blocks into a promiseWithResolverBlock\nOr I missed that promiseWithResolverBlock can only wrap non chained block ?\nAnyway, actually I'm trying to refactor all the DataController to use only promise and it's work fine for the few methods I've re-worked.\n. Oh didn't see it, thanks !\n. Yes sure\n. ",
    "MaxDesiatov": "still not fixed :(\n. ",
    "svenmuennich": "Since we're desperately in need of a fix for this to use PromiseKit in one of our own pods, I looked into the linting problem. It looks like v3.0.0 of OMGHTTPURLRQ is not ready for watchOS. I sent a PR (mxcl/OMGHTTPURLRQ#12) to OMGHTTPURLRQ which fixes a deprecation warning. As a result OMGHTTPURLRQ's podspec passes the linting for all platforms (incl. watchOS), which gives me hope that, if merged, PromiseKit will pass the linting too.\n. I sent a PR #294 which makes the podspec lint again. For more details please check its description.\n. Okay, shall I revert the commit on this branch or will you just pick the stuff you like to keep and push it directly?\n. Don't worry about it. The most important thing is that it works now :+1: \n. ",
    "atheken": "@nathanhosselton Thanks, not a problem. I was able to just explicitly define the version in my Cartfile (and Carthage properly \"downgraded\" to this version):\ngithub \"mxcl/OMGHTTPURLRQ\" \"3.0.0\"\nI will see if it works with 3.0.2\nI appreciate your work on PromiseKit, it's a really helpful tool.\n. ",
    "excaliburnan": "@mxcl Hi I am new to Swift and PromiseKit as well. Here is an error when I am trying to use dispatch_promise.\n\" Cannot invoke 'dispatch_promise' with an argument list of type '(() throws ->())' \". It may related to this issue, can someone give me a hand, thx in advance :)\n. ",
    "LukeDefeo": "Im not sure what cancelling a promise would mean in terms of its completion, i could call error() and pass a flag to say if was cancel or maybe it would just fall through to always as we probably dont want to do any error handling if we programatically cancel\n. Ive read that but i cant see how i support it, particually in Swift, The initialiser for Promise only takes two closures, fulfill and reject.\nDo you have any samples of what i should do, will i need a subclass of Promise?\n. Thanks thats brilliant, i need to learn how to write more functional, do you have any suggestions? You can probably close this now. \nCheers\n. Yeah also the documentation is confusing as it references some deprecated function. If you like I could make a pr to fix the inline docs in the code\nCheers\nLuke\n\nOn 21 Oct 2015, at 18:13, Michael Taylor Scheer notifications@github.com wrote:\nThis exact example may be worthwhile to include in the documentation... Thoughts?\n\u2014\nReply to this email directly or view it on GitHub.\n. Hi could you elaborate on this please max, I am trying to convince my team to use this library but if its main contributor can't work on it then that's not going to fly . Is it a temporary thing, Will you be able to work on it in the future.\n\nCheers\nLuke\n\nOn 22 Oct 2015, at 03:34, Max Howell notifications@github.com wrote:\nPR for the docs is welcome. I would do it myself but am legally unable currently.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "ScheerMT": "This exact example may be worthwhile to include in the documentation... Thoughts?\n. What would be the benefit of removing the master repo?\nI did get this working by instead pointing directly to the repo here on github and it compiled just fine.. Swift 2 and Xcode 7\n. Thank you for explaining that to me! I haven't tried this yet but will soon. I will report back if I have any problems\n. I believe I am experiencing the same issue. Running XCode version 7.3.1 (7D1014) and running on a device with 9.3.2. \nPromiseKit version: \n- PromiseKit (3.2.1):\n    - PromiseKit/Foundation (= 3.2.1)\n    - PromiseKit/QuartzCore (= 3.2.1)\n    - PromiseKit/UIKit (= 3.2.1)\nThe relevant code that results in a SIGABRT is this:\n(Code highlighted in red starts on the line }.always { and goes until the }.error { err in line)\nswift\nfunc toggleNetworkSpinnerWithPromise<T>(funcToCall: () -> Promise<T>) -> Promise<T> {\n        return Promise { fulfill, reject in\n            firstly {\n                setNetworkActivityIndicatorVisible(true)\n                return funcToCall()\n            }.then { result in\n                fulfill(result)\n            }.always {\n                setNetworkActivityIndicatorVisible(false)\n            }.error { err in\n                reject(err)\n            }\n        }\n    }\nThe error in the PromiseKit library is on Line 457 of Promise.swift\nPart of the stack trace with thread that crashed: \n```\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libsystem_kernel.dylib          0x0000000182f8811c pthread_kill + 8\n1   libsystem_pthread.dylib         0x0000000183054ef8 pthread_kill + 112\n2   libsystem_c.dylib               0x0000000182ef9e4c __abort + 148\n3   libsystem_c.dylib               0x0000000182ef9db8 __abort + 0\n4   PromiseKit                      0x000000010063fa6c Promise.(catch_(policy : ErrorPolicy, body : () -> ()) -> Promise).(default argument 0) (Promise.swift:0)\n5   AppName                         0x00000001000d7488 0x100044000 + 603272\n6   PromiseKit                      0x000000010063dec8 Promise.init(resolvers : (fulfill : (A) -> (), reject : (ErrorType) -> ()) throws -> ()) -> Promise (Promise.swift:72)\n7   AppName                         0x00000001000d53fc 0x100044000 + 594940\n8   AppName                         0x00000001000d6414 0x100044000 + 599060\n9   AppName                         0x000000010007a484 0x100044000 + 222340\n10  AppName                         0x00000001000aa038 0x100044000 + 417848\n11  AppName                         0x00000001000aa090 0x100044000 + 417936\n12  UIKit                           0x00000001885653d4 -[UIViewController _setViewAppearState:isAnimating:] + 724\n13  UIKit                           0x0000000188565980 -[UIViewController _endAppearanceTransition:] + 300\n14  UIKit                           0x0000000188623f14 -[UINavigationController navigationTransitionView:didEndTransition:fromView:toView:] + 1044\n15  UIKit                           0x0000000188701508 __49-[UINavigationController _startCustomTransition:]_block_invoke + 232\n16  UIKit                           0x000000018867d114 -[_UIViewControllerTransitionContext completeTransition:] + 116\n17  UIKit                           0x00000001887e837c __53-[_UINavigationParallaxTransition animateTransition:]_block_invoke95 + 684\n18  UIKit                           0x000000018858812c -[UIViewAnimationBlockDelegate _didEndBlockAnimation:finished:context:] + 628\n19  UIKit                           0x0000000188587c28 -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 312\n20  UIKit                           0x0000000188587ab0 -[UIViewAnimationState animationDidStop:finished:] + 108\n21  QuartzCore                      0x0000000185ee19a0 CA::Layer::run_animation_callbacks(void*) + 284\n22  libdispatch.dylib               0x0000000100e6da3c 0x100e6c000 + 6716\n23  libdispatch.dylib               0x0000000100e734e4 0x100e6c000 + 29924\n24  CoreFoundation                  0x00000001833a4d50 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE + 12\n25  CoreFoundation                  0x00000001833a2bb8 __CFRunLoopRun + 1628\n26  CoreFoundation                  0x00000001832ccc50 CFRunLoopRunSpecific + 384\n27  GraphicsServices                0x0000000184bb4088 GSEventRunModal + 180\n28  UIKit                           0x00000001885b6088 UIApplicationMain + 204\n29  AppName                         0x000000010009d968 0x100044000 + 366952\n30  libdyld.dylib                   0x0000000182e6a8b8 start + 4\n``\n. Downgrading to PromiseKit version 3.0.3 while commenting out theNSNotificationCenter+Promise.swift` file allows the previous code paths that were crashing to work.\n@PocketPro - Can you confirm yours is working under the same condition? (Not sure if this is actually helpful or not)\nedit: 3.1.1 not working either\nedit2: 3.1.0 is working! (with commenting out the NSNotification file)\nLink to commit diff for ease (between tags)\n. Dropping the catch on the error in my function.. I am guessing it will still reject the promise automagically then?\n3.2.1 does not fix the issue for me - the original backtrace i provided is from that version.\n@PocketPro - do you have a test project already from your original post? \n. ",
    "renatorodrigues": "Remove the master repository and then try to install the pods:\nsudo rm -fr ~/.cocoapods/repos/master\npod setup\n. Like @mxcl said, removing the master repo will simply delete the local cache. No harm done by doing it.\n. ",
    "nevans": "I'm also seeing this confusing compiler error, and I can't make sense of what is confusing the Swift compiler so badly, but your suggestions (remove the ()) didn't work.  However, after much playing around, I got it working...\nWith a func doThing() -> Promise<Void> and another func handleError(e: NSError), I tried:\nswift\n      firstly {\n          doThing()\n      }.then {\n          NSLog(\"DONE!\")\n      }.error { (e) -> () in\n//      ^^^^^  Cannot call value of non-function type 'ErrorType?'\n          handleError(e)\n      }\nBut adding a second line to the method changed the error.  Any second line would do, NSLog(\"error\") or return were what I tried.  The following gave a different error:\nswift\n      firstly {\n          doThing()\n      }.then {\n          NSLog(\"DONE!\")\n      }.error { (e) -> () in\n          handleError(e)\n//                    ^ Cannot convert value of type 'ErrorType' to expected\n          return\n      }\nWhich was easily enough fixed, and then I could remove the superfluous second line too:\nswift\n      firstly {\n          doThing()\n      }.then {\n          NSLog(\"DONE!\")\n      }.error { (e) -> () in\n          handleError(e as NSError)\n      }\n// Compiles fine\nI hope this helps someone else who gets here via google. :smiley: \n. also for join\n. ",
    "RyanCCollins": "Make that two.  Been pulling my hair out on this.  Thanks @nevans !!\n. ",
    "o15a3d4l11s2": "I am currently using PromiseKit 3 and Xcode 7.1\nWhat I actually refer to is the finally clause.\nI am also including a code to show what is my point. In short - there is no guarantee that the finally clause of getUsers will be finished before the next promise getMessagesForUsers start execution.\nThe case that I describe is that we should create a token which is used to execute a query and then destroy it. If the finally logic is not executed on time, the next createToken will fail, as the server already has a token created.\n```\n- (AnyPromise )getUsers\n{\n    __block NSString serverToken = nil;\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver  _Nonnull resolve) {\n    [self createTokenOnServer:^(NSString *token) {\n        serverToken = token;\n        resolve(token);\n    }];\n}].then(^(NSString *token) {\n    return [self fetchServerUsersUsingToken:token];\n}).finally(^{\n    if (serverToken) {\n        [self destroyToken:serverToken];\n    }\n});\n\n}\n\n\n(AnyPromise )getMessagesForUsers:(NSArray )users\n{\n    __block NSString *serverToken = nil;\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver  _Nonnull resolve) {\n    [self createTokenOnServer:^(NSString token) {\n        serverToken = token;\n        resolve(token);\n    }];\n}].then(^(NSString token) {\n    return [self fetchServerMessagesForUsers:users usingToken:token];\n}).finally(^{\n    if (serverToken) {\n        [self destroyToken:serverToken];\n    }\n});\n}\n\n\n(AnyPromise )doTheWork\n{\n    return [self getUsers].then(^(NSArray users) {\n        [self getMessagesForUsers:users];\n    });\n}\n```\n\n\nI am doing this whole logic, because I should follow the rules on the server - to create a token, use it for one request only and then destroy it. If there is any other mechanism to achieve this logic, please advise.\n. Probably what you mention is the exact cause of the problem - that I am not returning anything from the finally block.\nWith the current version that I use - PromiseKit 3 there is an error if I try to return a result from the finally:\nIncompatible block pointer types passing 'id (^)(void)' to parameter of type 'dispatch_block_t  _Nonnull __strong' (aka 'void (^__strong)(void)')\n. Since the declaration is (AnyPromise *(^)(dispatch_block_t))finally, the finally clause returns void. Is there something that I am missing here? How is it possible to return something from the finally?\n. Actually my case is even trickier - destroy should always happen if a token was successfully created, but not before executing the real request - i.e. fetchServerUsersUsingToken. If the destroy happens before the request - the token actually does not exist anymore on the server.\nI though for a different scenario:\n1. Create the token\nthen\n2. Make the request with the token\nthen\n3. Destroy the token, passing through the previous token result (the result from 2)\nthen\n4. Do anything additional\nThe only drawback of this logic is that the destroy might not get called if 2. fails\n. Thanks you for the good idea. Although not very elegant, it will be sufficient for my needs.\n. Objective-C would be better for me. If you prefer giving an example on Swift, this will also suffice to get the idea how to implement this.\n. I am still using PromiseKit and haven't implemented a cancellation yet.\nOn another project I used Bolts: https://github.com/BoltsFramework/Bolts-ObjC and it was very easy to do cancellation. Keep in mind that there are some differences in the way these two libraries work.\n. ",
    "skela": "Just to add to this, as I'm also stuck in between 2 worlds at the moment (1.6). So there was a code snippet in another issue that made it easier for me to use the v 1 promises in swift, but the issue there is it only lets me do the \"thens\", but not catches or finallys. I've tried to add the needed extension methods manually, but something in my head breaks when I try, and I can't make sense of it.\n\nAnybody know what to do to make this work?\n. @nathanhosselton thanks for the help. I tried your snippets and they have the same issues really, some weird error message about non-function type etc..\nThe main reason why I wanted to use the catchOn method is because i think catch is a keyword in Swift 2 :( \n. \n. \n. @mxcl , sure, but can you show an example of what you mean by that, I don't fully understand where and what needs to be cast. Sorry about that, would love to move to version 3, but I can't afford the refactor now.\n. At the moment I'm stuck with being unable to make use of catches and finally's when using this library in swift. If there's a snippet of code I can copy into my project to make that work, that's all thats needed, and I'm sure it would be much appreciated by other people, just as a stop gap to people moving to version 3 of the library. Needing to use swift code to make things nicer for Swift is what I'm doing already, its not a big problem, I just need a tiny bit of help to get the catch / finally methods to work, once that's done I have the most important tools I need to keep using this, at least until I move to PromiseKit 3.\n. @nathanhosselton thanks to some of the comments you made, I think it sort of started making sense as to why it wasn't working\n```\nprivate func objCBlockFromPromiseClosure(closure: (AnyObject) -> (PMKPromise?)) -> AnyObject\n{\n    return unsafeBitCast(closure as @convention(block) (AnyObject) -> (PMKPromise?), AnyObject.self)\n}\nprivate func objCCatchBlockFromPromiseClosure(closure: (NSError) -> (PMKPromise?)) -> AnyObject\n{\n    return unsafeBitCast(closure as @convention(block) (NSError) -> (PMKPromise?), AnyObject.self)\n}\nfunc swiftThen(closure: (AnyObject) -> (PMKPromise?)) -> PMKPromise\n{\n    return self.then()(objCBlockFromPromiseClosure(closure))\n}\nfunc swiftCatch(closure: (NSError) -> (PMKPromise?)) -> PMKPromise\n{\n    return self.failed()(objCCatchBlockFromPromiseClosure(closure))\n}\n// TODO: func swiftFinally..\n```\nAll it took was this extension in objective-c:\n```\n@interface PMKPromise (Swift)\n\n(PMKPromise *(^)(id))failed;\n\n@end\n@implementation PMKPromise (Swift)\n\n(PMKPromise *(^)(id))failed\n{\n    return [self catch];\n}\n\n@end\n```\nNow I just need to figure out how to do that for finally ;)\n. Since we are talking anyway, just wondering, is there a list of the main changes between version 1 and version 3 of the library? Some gotchas, or anything in particular I would need be aware of when moving over. (Just asking because I know I'm going to have to update at some point).\n. That's version 2 though, so no big differences between 2 and 3 that I need to be aware of, migrating to version 3 can be treated as migrating to version 2 ?\n. Thanks!\n. Yeah I don\u2019t want to keep using version 1 , but I\u2019m stuck as I can\u2019t upgrade to higher versions due to the time that would take to do so :( i looked at having both versions side by side and upgrading as I go along, but I was never able to do so. So I better keep using version 1. It works amazingly well still, not had a single issue with it.\n:(. Anyway thx , I\u2019ll give the submodule approach a try.. Yeah I had the exact same idea, but I'm getting some exceptions when doing that, so trying to figure out why thats happening (i.e. no build time errors, but some run time exceptions):\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '+[NSURLConnection promise:]: unrecognized selector sent to class 0x10cc00348'\n. Never mind, had added the files to the xcode project but xcode didnt mark them to belong to the target. Once i updated the target memberships for these files, it started working.\nThanks as always @mxcl ! \nPS: If you have any guides  or have any tips on how to bring both new and old promisekit into the same project, let me know. \ud83d\udc4d . I like the look of 6, so def going to go with that if I can. And yes my plan is to have them side by side then gradually faze out all the version 1 stuff. \nSo was planning on integrating promise kit 1 via a git submodule , then integrate promisekit 6 via carthage. That not a good way to do it?\nWhen you say install it yourself, do you mean adding the Sources stuff directly to my project, or adding the projects to the workspace and integrating it that way?. Thx max. ",
    "adrianbg": "I think there is more going on here than type inference failure. Nothing is working for me here. Do you have any other suggestions?\nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then { data in\n        Auth.setContact(data)\n    }\n// Cannot convert value of type '()' to closure result type 'AnyPromise'\nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then { data -> () in\n        Auth.setContact(data)\n    }\n// Declared closure result '()' is incompatible with contextual type 'AnyPromise'\nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then { data -> AnyPromise in\n        Auth.setContact(data)\n        return AnyPromise(bound: Promise<Void>(Void()))\n    }\n// Cannot invoke 'then' with an argument list of type '((NSDictionary) throws -> AnyPromise)'\nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then(body: { (data: NSDictionary) throws -> AnyPromise in\n        return AnyPromise(bound: Promise<Void>(Void()))\n    })\n// Cannot invoke 'then' with an argument list of type '((NSDictionary) throws -> AnyPromise)'\nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then(Auth.setContact)\n// Cannot invoke 'then' with an argument list of type '((NSDictionary) throws -> AnyPromise)'\nNote that none of the functions above throw anything. The compiler is just coming up with that on its own.\n. It was (NSDictionary) -> AnyPromise.\nGiven that this was failing too I don't think it had to do with an error in the closure:\nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then(body: { (data: NSDictionary) throws -> AnyPromise in\n    return AnyPromise(bound: Promise<Void>(Void()))\n})\n. ",
    "Lxrd-AJ": "You can try \nreturn NSURLConnection.POST(AuthUrl, JSON: params).asDictionary().then { data -> Void in\n        Auth.setContact(data)\n    }\nseemed to solve the problem for me\n. ",
    "xezero": "Ah, darn. Thanks anyways!\n. ",
    "aral": "I get a similar fail:\n```\n Cloning PromiseKit\n Cloning objective-git\n Cloning OMGHTTPURLRQ\n Checking out OMGHTTPURLRQ at \"3.0.2\"\n Downloading objective-git.framework binary at \"0.8.8\"\n Checking out PromiseKit at \"3.0.0\"\n xcodebuild output can be found in /var/folders/vp/l22f5841353_6v24wxvpxvw00000gn/T/carthage-xcodebuild.NCTnYp.log\n Building scheme \"OMGOSX\" in OMGHTTPURLRQ.xcodeproj\n Building scheme \"OMGwatchOS\" in OMGHTTPURLRQ.xcodeproj\n* BUILD FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\nA shell task failed with exit code 65:\n BUILD FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\n```\nThe workaround for me (as I only need the iOS scheme) is to install it with carthage update --platform iOS. The OMGwatchOS scheme is what\u2019s making it fail.\n. ",
    "diogoguimaraes": "I'm not able to build PromiseKit 3.0 iOS scheme with Carthage too:\n``` Bash\n Building scheme \"PMKiOS\" in PromiseKit.xcodeproj\n* BUILD FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\nwarning: Capabilities that require entitlements from \"Tests/Entitlements.plist\" may not function in the Simulator because no development team was selected and no provisioning profiles matching an applicable signing identity were found. Select a development team in the target editor.\nCode Sign error: No matching provisioning profiles found: No provisioning profiles matching an applicable signing identity were found.\nA shell task failed with exit code 65:\n BUILD FAILED \n```\nI think it's due to the PMKiOSUITestsHost scheme having an iOS application target. Removing it fixes the carthage build.\nIs it really necessary to have the iOS app target on the lib?\n. I've fixed the issue by unchecking the Run and Archive build options for the PMKiOSUITeststarget as seen below:\n\n@mxcl, @nathanhosselton is it possible to include this fix in a 3.0.1 tag?\nThank you.\n. No, with the latest carthage version I can build PromiseKit.\nThanks.\n. ",
    "ypresto": "Building with Carthage 0.11 fixed this issue (warnings are still printed).\n. ",
    "MrAdamBoyd": "Actually, I believe I found a bug. I submitted a pull request here. Basically, what is happening now is that only the Cancel button is fulfilling the promise, whereas all other buttons are rejecting it. I reversed that.\n. I closed my pull request because I realized this fix is already a waiting pull request. Link.\n. Actually, realized there is already a pull request for this here.\n. ",
    "staminajim": "I can confirm that by adding \ns.watchos.deployment_target = '2.0'\nto the pod spec with the v1.6.0 tag that using PromiseKit 1.6 works on watchOS.\nI could make a pull request, but I'm not sure how you guys plan to keep maintaining 1.6.x as it looks like it's currently all a linear history in master?\n. @mofirouz does it work if you add \ns.tvos.deployment_target = '9.0' to the 1.6.0 pod spec?\nI don't have any tvOS targets set up to quickly try that.\n. @mxcl , but don't we need a PK 1.6.x branch to make the pull request against and do future v1 releases from?  We can't clobber master since that's the v3 tree.\n. Never mind, I just found the discussion continued in the pull request ;)\n. Awesome thanks @mxcl!. ",
    "jasonzurita": "I had a need to use Heroic Labs with tvOS, so I figured I would provide an update:\nI locally copied both Heroic Labs and PromiseKit (v1.6), modified the pod spec files to include the tvOS target, and the pods successfully installed!\n. ",
    "stanchiang": "fixed with \"when\"\n. oh cool. thanks! where would i look to see all my available options when picking functions like this?\n. ",
    "danielt1263": "hmm... I did the obvious thing:\n```\npublic func join(promises: Promise...) -> Promise<[T]> {\n    return join(promises)\n}\npublic func join(promises: [Promise]) -> Promise<[T]> {\n/.../\n```\nBut I get a console message \"PromiseKit: Pending Promise deallocated! This is usually a bug\". I don't see that message when I use when... I don't understand the code well enough at this point...\n. I'm sending join a [Promise<Int>] and the console message is getting called on a Promise<[Int]>...\n. It turns out that neither join nor when did what I needed anyway. I wrote a new function for myself... https://gist.github.com/dtartaglia/2b19e59beaf480535596\n. I am holding the result of a pendingPromise call as a property of a class, but I can't create the actual promise at initialization time. As a consequence I have the following line of code in my class:\nprivate var pendingAdd: (promise: Promise<(name: String, date: NSDate)>, fulfill: ((name: String, date: NSDate)) -> Void, reject: (ErrorType) -> Void)?\nwhich is pretty ugly. With the addition of the typealias I could write this instead:\nprivate var pendingAdd: Promise<(name: String, date: NSDate)>.ExpandedPromise?\nOtherwise, I am using it exactly as intended.\n. Hmm... I'm not sure how I could do that... For example:\nclass Bar {\n    var (promise, fulfill, reject): (promise: Promise, fulfill: (Int) -> Void, reject: (ErrorType) -> Void)\n    // Create a promise in some method.\n}\nI can't do the above. The tuple needs to be initialized in the init method (which, as I said, I can't do.)\nclass Bar {\n    var (promise, fulfill, reject): (promise: Promise, fulfill: (Int) -> Void, reject: (ErrorType) -> Void)?\n    // Create a promise in some method.\n}\nThe above doesn't work either. I get the error \"tuple pattern cannot match values of the non-tuple type.\"\nclass Bar {\n    var (promise, fulfill, reject): (promise: Promise?, fulfill: ((Int) -> Void)?, reject: ((ErrorType) -> Void)?)\n}\nThe above allows me to define the variable, but then I won't be able to assign the return of pendingPromise() to it.\nAnd in any case, all of these constructs are very messy.\nMaybe I've missed something fundamental and I should be doing what I am trying to do in a completely different way?\n. That's an interesting construct. I hadn't thought of it. As for my testing, I am currently using the following in my code and it works fine:\n```\nextension Promise {\n    typealias PendingPromise = (promise: Promise, fulfill: (T) -> Void, reject: (ErrorType) -> Void)\n}\nclass Foo {\n    private var pendingAdd: Promise<(name: String, date: NSDate)>.PendingPromise?\n}\n```\nI'm happy to leave it in my code but it seemed to me like something that should be in the library.\n. No problem Nathan. Two things I noticed that are, or at least may be. different between what I have and what you have...\nI am doing this in an @objc class (specifically a UIViewController subclass.)\nprivate var pendingAdd: Promise<(name: String, date: NSDate)>.PendingPromise?\nand I am assigning to it like this:\nfunc waitForAdd() -> Promise<(name: String, date: NSDate)>  {\n    pendingAdd = Promise<(name: String, date: NSDate)>.pendingPromise()\n    return pendingAdd!.promise\n}\nSo it could be that it only works in an @objc class, or it could have something to do with the fact that I used named parameters in my tuple. ?\nI just tried removing the named parameters, and my code still worked... Hmm...\n. Also, if the user needs to hold more than one pending promise, then forcing them to keep three variables per promise and keep straight which promise, fulfill, rejects go together would be a huge pain.\n. It doesn't make a lot of sense to have it IMHO. Notifications are inherently multi-fire things but Promises aren't. \n. Another work around is to simply remove NSNotificationCenter+Promise.swift from the PromiseKit target. There is no need to edit the file itself or remove the file at all. Just uncheck it's target membership status.\n. ",
    "mkhl": "I needed something like join on an Array as well, so I wrote an extension that implements traverse on CollectionType.\nMaybe that helps?\n. ",
    "huchenqiang90": "iPhone framework\n. ",
    "adampilks": "Think I missed the then... had to be something simple :), thanks for your help \n. ",
    "hartbit": "Found the problem:\n- PromiseKit redefines SWIFT_CLASS but not SWIFT_CLASS_NAMED\n- Project-Swift.h checks defined(SWIFT_CLASS) before defining both\n- So if PromiseKit is imported before Project-Swift.h (as instructed), SWIFT_CLASS_NAMED never gets defined.\nI'm preparing a Pull Request with a fix.\n. ",
    "hongkongkiwi": "Agreed with this, seems like a bug.\n. ",
    "tjdhome": "Normal for me :-) I do not use cocoa pods. Too many unintended consequences of updates!\n- tjd\nOn Nov 27, 2015, at 2:37 PM, \"S?bastien De Saint Florent\" notifications@github.com<mailto:notifications@github.com> wrote:\nHi,\nI would need also PromiseKit to be tvos compatible.\n@tjdhomehttps://github.com/tjdhome, is it normal you haven't updated the podspec file to include something like s.tvos.deployment_target = '9.0' ?\n\nReply to this email directly or view it on GitHubhttps://github.com/mxcl/PromiseKit/pull/325#issuecomment-160201111.\n. ",
    "tmandry": "+1\n. ",
    "randomiser": "Can we also have the join changed so that it can be chained along with the other functions like \"then\".\nie:\nfirstly {\n}.then {\n}.join {\n}.always {\n}.error {\n}\n. +1 \nUntil this gets resolved:\nhttps://bugs.swift.org/browse/SR-128\nWe need to be able to dynamically provide a list of promises at runtime.\n. Can you add some details about how best to handle this to the documentation? Thanks in advance!. Can you add your example above to the documentation? Seems like a common question and task. Thanks!. ",
    "tomquist": "This isn't better as the previous solution. Now the acknowledgement plist will contain a URL but the MIT licence requires inclusion of the full licence text:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nSo people using PromiseKit will not be able to use the auto-generated acknowledgement plist.\n. Ok, then there are several alternatives:\n1. Remove license section from README to avoid duplicate license information\n2. Add full license text to podspec, keep license section in README and delete LICENSE file\nI'd be happy to change my PR accordingly. I think being able to use the acknowledgement Plugin for CocoaPods is a very important.\n. ",
    "rlaferla": "+1  I can't build any versions 2.1, 2.2 or 3.0 using Carthage\n. I think I tried that but ended up using the CocoaPod.\n. Thank you!!!!  Let's put this example in the project.  I think it will help others.  Also, is PromiseKit being used in any shipping apps?  Is it stable enough?\n. I then removed the catch and added a -> Void but that doesn't work either.\n. I'm using the PromiseKit CocoaPod - not sure of the version.  The code you provided doesn't work with it.  I could only get it to work using NSData:\n```\n            NSURLConnection.GET(imageURL).then { (data:NSData) in\n               self.imageView.image = UIImage(data: data)\n             }\n```\n. Same issue today with Xcode 7.3.1\n. I just commented out the code (didn't use it) and it works.  Seems like this is one of many Xcode bugs.\n. ",
    "beingadrian": "@rlaferla this worked for me (might work for you if you're developing specifically for iOS)\ncarthage build --platform iOS\n. @rlaferla Ah, alas. Whatever works for you :+1: \n. ",
    "ehuynh": "I have a question regarding whether not fulling a promise is a practise used often? For example if I was using a promise to replace a delegate pattern on a view, where the delegate indicated what item was selected. If I present that view and then it is dismissed with no item selected, then that promise would go unfulfilled. Is this considered a correct use case for promises? Only wondering as right now, I'm getting the same warning message.\nPromiseKit: Pending Promise deallocated! This is usually a bug\n. @nathanhosselton thanks for that. Didn't realise you can cancel a promise with an error that won't be caught. Maybe thats something that can be added to the documentation?\n. ",
    "mcfedr": "This warning comes up when using race as well, is there any way it could be avoid for that specific use?\n. Ah, interesting, I had better investigate further.\n. http://promisekit.org/docs/handbook/Classes/Promise.html\n. ",
    "basememara": "Leaving promises unresolved are generally bad practice and a sign to code smell. Even if you don't need to resolve promises, always and other API's will not fire as expected if you leave things unresolved which can lead to several bugs. I'm wondering if this could also cause memory leaks as well but not sure.\n. Does this also work for when? I can't seem to get it to work with the following:\n```\nfunc testWhenRetry() {\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002let ex = expectation(description: \"test -when- with retry\")\nvar promises: [Promise] = (1...5).map { _ in\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002promises.append(Promise { fulfill, reject in\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002self.count += 1\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002})\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002}\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002retry(times: 5) {  _ -> Promise in\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002when(resolved: promises)\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002.always { _ in print(\"when.always (self.count)\") }\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002if self.count == 10 {\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002ex.fulfill()\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002}\nreturn Promise(error: PromiseError.noResult)\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002}\nwaitForExpectations(timeout: 5)\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002XCTAssert(count == 10, \"test -when- failed\")\n\u2002\u2002\u2002\u2002}\n```\nI think it's because the recover in the retry function is being called on when, but shouldn't it be called on the individual promises? It would be slick if the retry skips the promises that were fulfilled and keep going through the rejected. Or is there a better approach to what I'm doing?\n. ",
    "bbqbaron": "loadSnapshot is returning a Promise whose execution block dispatches two further async processes, one of them a Promise. If the fulfill condition in observeEventType completes first, won't the Promise returned by after be deallocated before resolution? What if you race the after and a Promise that only contains the call to observeEventType? I haven't used race, but the doc suggests that it's the whoever-resolves-first condition that you want.\n. ",
    "zaneclaes": "@bbqbaron this was a pattern for timeouts I copied from elsewhere (and the problem persists if I remove the after). What's more, I use the loadSnapshot function many other places in the code without any problems. The problem ended up being that the GameObject.factory had a when() call that could be fired with an empty array. Apparently, when([]) leads to the error above.\n. ",
    "adrenalin": "Any news? This does interest me as well, because I am new to Swift and iOS and looking for an easy way to handle promises as a convenience for multithreading processes that might never need to finish due to the user-initiated changes.\nI am able to think of workarounds by using out-of-scope variables that the promise checks for termination, but @mxcl 's last comment sounds as if there might be also other possibilities to terminate the block from the outside.\n. ",
    "tib": "I am trying to solve the same thing, your example above is not compiling because of the self requirement in the init block. Do you have a working solution for this issue maybe?\n. Thank you for the help, I could make it:\n``` swift\npublic class MyPromise: Promise {\nprivate var task: NSURLSessionDataTask?\nprivate var fulfill: ((NSData) -> Void)?\nprivate var reject: ((ErrorType) -> Void)?\n\noverride init(@noescape resolvers: (fulfill: (NSData) -> Void, reject: (ErrorType) -> Void) throws -> Void) {\n    super.init(resolvers: resolvers)\n}\n\ninit(request: NSURLRequest) {\n    var fulfill: ((NSData) -> Void)?\n    var reject: ((ErrorType) -> Void)?\n\n    super.init { f, r in\n        fulfill = f\n        reject = r\n    }\n\n    self.fulfill = fulfill\n    self.reject  = reject\n\n    self.task = NSURLSession.sharedSession().dataTaskWithRequest(request) { data, response, error in\n        if let error = error {\n            if error.code == NSURLErrorCancelled {\n                return\n            }\n            self.reject?(error)\n            return\n        }\n        guard let data = data else {\n            self.reject?(NSError(domain: \"no-data\", code: 0, userInfo: nil))\n            return\n        }\n        self.fulfill?(data)\n    }\n    self.task?.resume()\n\n}\n\npublic func cancel() {\n    guard !self.rejected else { return }\n    self.task?.cancel()\n    self.reject?(NSError.cancelledError())\n}\n\npublic class func go() -> MyPromise {\n    var fulfill: ((NSData) -> Void)?\n    var reject: ((ErrorType) -> Void)?\n\n    let promise = MyPromise { f, r in\n        fulfill = f\n        reject  = r\n    }\n\n    promise.fulfill = fulfill\n    promise.reject  = reject\n\n    let url      = NSURL(string: \"https://jsonplaceholder.typicode.com/users\")!\n    let request  = NSURLRequest(URL: url)\n    promise.task = NSURLSession.sharedSession().dataTaskWithRequest(request) { data, response, error in\n        if let error = error {\n            if error.code == NSURLErrorCancelled {\n                return\n            }\n            promise.reject?(error)\n            return\n        }\n        guard let data = data else {\n            promise.reject?(NSError(domain: \"no-data\", code: 0, userInfo: nil))\n            return\n        }\n        promise.fulfill?(data)\n    }\n    promise.task?.resume()\n\n    return promise\n}\n\n}\n```\nUsage example:\n``` swift\nlet promise = MyPromise.go()\npromise\n        .then { data -> Void in\n            print(\"data\")\n            print(data)\n        }\n        .error { error in\n            print(\"error\")\n            print(error)\n        }\npromise.cancel()\nprint(promise.rejected)\n```\n``` swift\n    let url = NSURL(string: \"https://jsonplaceholder.typicode.com/users\")!\n    let request  = NSURLRequest(URL: url)\n    let promise = MyPromise(request: request)\n\n    promise\n    .then { data -> Void in\n        print(\"data\")\n        print(data)\n    }\n    .error { error in\n        print(\"error\")\n        print(error)\n    }\n\n    promise.cancel()\n\n    print(promise.rejected)\n\n```\nJust in case if anyone needs something like this. ;)\n. ",
    "sudhakrish": "could you give some sample in Objective c\n. ",
    "bitwit": "@tib Thanks for your code. It helped us solve a similar issue. However, isn't there a potential issue with retain cycles with the way you strongly reference self inside of init from within the data task closure? We modified our code to use the local fulfill and reject functions so that no reference to self was necessary and all appears to be fine.. Bugger, one of the linux tests failed due to timeout. I'm going to squash these commits to try triggering again. . ",
    "bavarskis": "I would like to use the above discussed solution but subclassing Promise is not possible (release 6.5) because it's not an open class. Is it now necessary to create a new class conforming to Thenable or is there a better way to cancel an underlying dataTask?. ",
    "syzdykov": "pod 'PromiseKit'\n. Thank you!\n. ",
    "radex": "@mxcl would you rather have the parameter on when or on error?\n. Thank you \u2014 I'll think about it and will open a PR.\n. Thank you. Apologies I haven't had the time to work on this \u2014\u00a0I will check out your solution in free time and leave feedback if needed :)\n. Hey Max! I looked at your solution more closely and thought about it some\u2026 I think it's the right way to go! Don't see any problems with it for me.\nThanks again!\n. ",
    "thaterikperson": "Included your suggestion in the PR. Looked like the only remaining reference to promiseWithAdapter:.\n. Addressed feedback from @nathanhosselton in #342.\n. ",
    "orj": "OK.  So perhaps this is a situation where Swift's Type Inference system is screwing me.  As this compiles:\nlet (p2, _, _) = Promise<Void>.pendingPromise()\np2.error { (error:ErrorType) -> Void in\n        NSLog(\"Error: \\(error)\")\n}\n. Yeah.  Swift can be a bit confusing at times.  As for the use of error I'm not actually doing it this way.  It was just the smallest code snippet that showed the compile issue.   Anyway. Closing this issue as it was my dumb fault not PK. :)\n. Adding the parameter types is what worked for me. Swift compiler needs a little type inference help.\n. ",
    "w0mba7": "I get this error even when similar code is used in other parts of my application. \n                    }.error {\n                        (error: ErrorType) -> Void in\n                        dest.failureToLoadAlertForError(error) {}\n                }\n            }\n. ",
    "gunnarblom": "@orj @nathanhosselton \nI get the same error and can't figure out how to solve it. Any tips?\n``` swift\nfunc promise1() -> Promise\nfunc promise2() -> Promise\nfunc promise1and2() -> Promise {\n    return promise1().then { class1object in\n        return promise2()\n    }.error { error in\n        log.error(error)\n    }\n}\n```\nThanks!\n. @ldiqual this was my problem as well, hard to track down when you are focusing on the compiler confusion issues\n. ",
    "ReneB": "This has been bugging me over and over again and I can't quite figure out when it does and does not work. In most cases, helping the type inference along a little bit will help, but I'm currently in a situation where even that doesn't help.\nA simplified version of the code would be this:\n``` swift\nclass AuthenticationRequest {\n  // ...\n  func perform() -> Promise {\n    // ...\n  }\n}\nclass User {\n  public static func login(userName userName: String, password: String? = nil) -> Promise {\n    // some setup\n    return AuthenticationRequest(forUser: currentUser, withPassword: password).perform().then { response -> Promise in\n      // some handling of the response\n      // ...\n  return Promise(currentUser)\n}\n\n}\n}\nfunc processCredentials() -> Promise<()> {\n  let login = User.login(userName: userName, password: password).asVoid()  // <- Tried this with and without the 'asVoid'\nreturn login.error { (error: ErrorType) -> Void in  // Cannot call value of non-function type 'ErrorType?'\n    print(\"something\")\n  }\n}\n```\nI can't be much more explicit about types than this, and the compiler still rejects it...\nBasically, I'm not entirely sure if Swift supports having both a property and a function with the same name. I mean, it should be possible for the compiler to correctly infer the type and make it work - I'm just not sure if it's supposed to. The question, then, becomes \"should both of these things be called error?\"\nBrowsing around things like StackOverflow, I think this might not be legal Swift (but somehow, the compiler approves it, which might be a bug triggered by the fact that one of them is in an extension while the other is in the Promise<T> class itself). This post has a very convincing argument about allowing the use of the same names for properties and methods.\n. I understand there's a lot of pain involved right now in maintaining such a codebase as this for the... slightly unstable demands of the Swift compiler throughout versions, especially when it comes to type inference and all. Still, I really appreciate the effort because the project I'm currently on would have been a lot - that is, a lot harder without PromiseKit.\nHaving said that, I think any call will do. Becoming Swift-standards compliant sooner rather than later would have my preference, simply because it occurs to me that the compiler bug (again, I'm speculating, but it seems plausible) which makes this possible might be removed by Apple at any point right now...\nThe easiest fix from a library standpoint would probably be to just duplicate the error method and properties with different names, so that you're still backwards compatible but also allow escaping situations such as this one, where there is no really good way to tell the compiler which one we need. For example, if the error method was aliased as onError or handle or some other dramatically bad name I can come up with, I might just work around this bug for now...\n. Here you go. Comments are welcome - although I have worked with Swift a lot over the last eight months, libraries and testing are not yet the points I know most about.\n. If you ask me, any decision will do. I think these could be removed as soon as the Swift compiler stops bugging out on us. Having said that, as I said in #347 (the thread that inspired this pull request), I think having the error property and an error() function on the same object might not be valid Swift, in which case we might want to look for a slightly more permanent solution. \nThe Promises/A+ spec has some terminology for what Promises are expected to do (things like onFulfilled and onRejected). It might be smart to let that terminology inspire any naming decisions, but I'm a total newbie to this codebase so I'm not sure how well that would work...\n. I'm currently really pressed for time, so if you could do it, that would be great. Otherwise, I'll get around to it somewhere around next Tuesday or so, which is also fine with me :-)\n. First off, this kind of things is often slightly dependent on the Swift compiler version you're using. Are you on XCode 7 or 8 (or some other compiler)?\n. ",
    "Retolinho": "Thank you for the hint with the main queue. I removed the manual queue handling now, but that does not resolve the issue. \nSince the provider of my API decided to move away from Basic Auth and use another kind of authentication, i can no longer reproduce the behavior. I am sure the problem is still out there, but with that API change i do not see it anymore...\n. ",
    "adamszeptycki": "I like the idea ;)\n. ",
    "wangii": "when iOS device is unlocked, the first http request always fails with the UnderlyingCocoaError, due to Apple's incorrect implementation of keep alive. before retry mechanism is implemented, how to handle it gracefully? currently I use ugly nested .error handler. \n. Isn't it \"when\" designed for?\n. ",
    "mdhornet90": "This would be an awesome addition!\n. I've been thinking about this since I first endorsed the inclusion of it,\nand I realized it's a feature very specific to networking. While promises\nare used extensively for async network calls, that's not all the library\ncan be used for, and so \"retry\" would be useless or unnecessary in a lot of\nvalid use cases. This might make more sense as an extension to the library.\nThat said, I haven't come up with a decent pattern when there is a network\ncall that fails and I want to retry. Everything I've written feels\nungainly, even with PromiseKit.\nOn Wed, Jul 27, 2016 at 9:58 AM, Max Howell notifications@github.com\nwrote:\n\nThe endpoint cannot be fixed? Adding retry to the library feels like\nfixing things with duct tape when really we should be fixing the underlying\ncause properly.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/350#issuecomment-235650265,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAZ4nIsHIdw-KrtaizwmCcgFkgFKijxAks5qZ45SgaJpZM4HDJEE\n.\n. A simple case of my complete illiteracy. Thanks for the prompt response, and I love the library!\n. Works exactly as advertised. Thanks for the guidance!\n. Back to the drawing board, I think. I forgot that this particular call is also wrapped in a PMKWhen, so I think something screwy is happening when I try to unbox this error.. I appreciate the follow up! I realized I could access the underlying error pretty easily, but I wouldn't mind a change to bring it in line with how Swift does it.\n\nIs there any chance I could take a crack at a PR for it? I've really enjoyed using this framework, and I'd love to give back.. ",
    "jonasman": "This is a good idea to implement in PromiseKit \nHere is an alternative version while you don't have it natively:\nthe promiseClosure in the beginning is needed otherwise so that the promise can resolve again and again.\n``` swift\nfunc retry(promise:(() -> Promise), times:Int = 5, delaySeconds:NSTimeInterval = 0.0) -> Promise {\n    return promise().recover { (error) -> Promise in\n        if times == 0 {\n             throw error\n        } else {\n            if delaySeconds > 0.0 {\n                return delay(delaySeconds).thenInBackground { retry(promise, times: times - 1, delaySeconds: delaySeconds) }\n            } else {\n                return retry(promise, times: times - 1, delaySeconds: delaySeconds)\n            }\n        }\n    }\n}\nfunc delay(delay:NSTimeInterval) -> Promise<()> {\nlet (promise, fulfill, _) = Promise<()>.pendingPromise()\n\nlet delayTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC)))\ndispatch_after(delayTime, dispatch_get_main_queue()) {\n    fulfill()\n}\n\nreturn promise\n\n}\n```\n. I use retry in our app for some critical network requests. \nWe use an endpoint to give urls for the other endpoints. If this first call fails it makes all the other calls to fail. The initial call will be recalled again anyway when the user presses retry or goes to another screen. But just because one network call failed we shouldn't display an error to the user before we try for a couple of times. \n. For example, if for any reason your internet is down for 1 sec a retry would help.\nSent from my iPhone\n\nOn 27/07/2016, at 19:58, Max Howell notifications@github.com wrote:\nThe endpoint cannot be fixed? Adding retry to the library feels like fixing things with duct tape when really we should be fixing the underlying cause properly.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Ok i found a way. Just return:\n\nfunc getStuff() -> Promise<([String]?,Promise<[String]>)> {\n}\n. +1 For me the problem is similar:\nWe import PromiseKit via another dependency. And then we cannot import the categories because of that.\n. just tried to do the import the categories from carthage checkouts. It seems to be a good idea but fails here:\n``` swift\nif !COCOAPODS\nimport PromiseKit\nendif\n```\nRemoving the #if checks solves the problem.\nThe issue is tricky in this project. We have cocoapods + carthage . Carthage is used to import 1 library. this one lib imports Promisekit. \n. Im still waiting for the day that SPM will be the default :)\n. Same results. I'm guessing this is a bug with cocoapods. Can't get the subspecs to be installed with 1.0. \n. I reported this to cocoapods\n. I created a completely clean project and it works fine. This is probably something else. Will close for now.\n. Downgrading is not my fav \n. I think the problem is only when updating cocoapods from 0.X to 1.0. Starting fresh works fine.\n. the project at work still doesn't run. Not sure yet why. At home my projects work fine...\n. Yeap. Closing it down\n. I did make a project but wasn't able to reproduce the issue. I will keep trying until i can reproduce it. I must mention im using for this project PromiseKit 3.0.3\n. I found the bug. Sorry this was a misuse of a pending Promise somewhere else. \nSome code din't fulfil a promise. \n. Thanks!\nI was thinking the same. \nSent from my iPhone\n\nOn 01/09/2016, at 17:13, Max Howell notifications@github.com wrote:\nIt's a bug in CocoaPods: CocoaPods/CocoaPods#5778\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Downgrade is not needed \n\npod _1.0.1_ install this should be enough to use the older version\n. <unknown>:0: error: filename \"NSURLSession+Promise.swift\" used twice: '/Users/joao/DEV/StockPortfolio/Pods/PromiseKit/Extensions/OMGHTTPURLRQ/Sources/NSURLSession+Promise.swift' and '/Users/joao/DEV/StockPortfolio/Pods/PromiseKit/Extensions/Foundation/Sources/NSURLSession+Promise.swift'\n<unknown>:0: note: filenames are used to distinguish private declarations with the same name\nseems like OMGHTTPURLRQ and Foundation both create a NSURLSession+Promise.swift and swift compiler doesn't allow it\n. https://github.com/mxcl/PromiseKit/pull/526\n. Im on cocoapods. If i dont change that line it wont compile\nSent from my iPhone\n\nOn 04/09/2016, at 06:54, Max Howell notifications@github.com wrote:\nSpecifically it will be #import  with CocoaPods, but as you specified for Carthage. This is unfortunate but not avoidable afaict.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I mean im using cocoapods and the file NSURLSession+OMG+AnyPromise.m doesnt compile when importing the omg extension. This is not my code but Promisekit code\n. cant reproduce this anymore. If it ever happens again i will reopen.\n. \n",
    "zhenjiangliu24": "swift\n@discardableResult func retry<T>(times: Int, wait: TimeInterval = 2, body: @escaping () -> Promise<T>) -> Promise<T> {\n    var attempts = times\n    func attempt() -> Promise<T> {\n        return body().recover { error -> Promise<T> in\n            attempts -= 1\n            guard attempts > 0 else { throw error }\n            return after(interval: wait).then(execute: attempt)\n        }\n    }\n    return attempt()\n}\n@mxcl This is what we tried for the retry for Promisekit, but did not work. Can you double check the code please?\n. @zlangley for me, what inside the retry function is been called only once.\n. ``` swift\n func samplePromise(result: Bool) -> Promise {\n    return Promise<Int> { fulfill, reject in\n        guard result else {\n            count += 1\n            reject(PromiseError.noResult); return\n        }\n        fulfill(count)\n\n    }\n}\n\nfunc testRetry() {\n    retry(times: 5) {\n        self.samplePromise(result: false)\n        }.then{_ in\n            print(\"goes here.\")\n    }\n    XCTAssert(count == 5, \"retry failed\")\n}\n\n```\nThis is our unit test.\n. @zlangley It works! Thanks man, you are awesome.\n. ",
    "zlangley": "@zhenjiangliu24 What doesn't work about it? It seems to work fine for me.\n. XCTAssert will be called immediately after retry is kicked off; it will not wait for the async work to execute and will therefore always fail.\nConsider using XCTestExpectation.\n``` swift\nfunc testRetry() {\n    enum Error: Swift.Error {\n        case test\n    }\nlet ex = expectation(description: \"\")\n\nvar count = 0\nretry(times: 5, wait: 0) { _ -> Promise<Void> in\n    count += 1\n    if count == 5 {\n        ex.fulfill()\n    }\n    return Promise(error: Error.test)\n}.then {\n    XCTFail()\n}\nwaitForExpectations(timeout: 1)\n\n}\n``\n. There are a number of issues in the test you provided. For one, the count will never exceed 5 because each of the promises inpromisesis only instantiated once; it's only the block provided toretrythat will be executed multiple times. You're also not ever resolving any of the promises inpromises. And remember that yourXCTAssert` will always fail because it will be called immediately.\nIf you have further questions, please open a new issue or ask them via gitter. :)\n. > We should re-work how we dispatch, we need to do a single dispatch to the current queue before any handlers execute.\nJust curious, how do you intend to do that? I tried taking a stab at this, but GCD intentionally doesn't allow you to dispatch to the current queue.\nBy the way, this isn't too hard to repro locally if you just run the body of that test, say, 100 times.\n. > Lastly - we can just document that fact and require user to use then(on q:...) parameter. I get that it's not satisfying though.\nI don't think this helps. We need to know the queue that they are calling then from, not the queue they intend to run the block on.\n. We cannot assume the caller knows what queue it is running on, just like we cannot determine what queue we are running on. (Not to mention this would be a very easy API to misuse; simply pass the wrong queue and you may be deadlocked.)\n. You're right, I typed that comment too quickly.\n. FYI doc_percent is -1 right now, now sure how it gets computed.\n. Code coverage is above 90% FYI.\n. Thanks for the quick reply. Makes sense.\n. > I think the most compelling example of catch-less Promise is infallible async operations.\nThis is the example I was going to give, but they seem rare in enough in practice. Also, it may still be better to catch anyway and assert your claim:\ninfallibleTask().then {\n    // \u2026\n}.catch { _ in\n    assertionFailure(\"\u2026\")\n}\n. Ah, okay. Apparently allowing subclassing is intentional.\n. Actually I'm not sure about this. It's awkward to have an \"instance\" method that checks against the instance to determine what to do.\n. Ah, I see, that makes sense. Thanks for the sample code! I think adding this as documentation will encourage people to experiment with the feature.\nWill update.\n. Updating the docs now. Just to be clear, this is basically just a convenience for specific use of pending promises? As far as I can tell, you could have also written your example as:\n``` swift\nclass Engine {\n    static func make() -> Promise {\n        let (enginePromise, fulfill, reject) = Promise.pending()\n    let cylinder = Cylinder(explodeAction: {\n        enginePromise.then { engine in\n            engine.checkOilPressure()\n        }\n    })\n\n    firstly {\n        Ignition.default.start()\n    }.then { plugs in\n        Engine(cylinders: [cylinder], sparkPlugs: plugs)\n    }.then(on: zalgo) { engine in\n        fulfill(engine)\n    }.catch(on: zalgo) { error in\n        reject(error)\n    }\n\n    return enginePromise\n}\n\n}\n``\n. Cool, let me know if I should make any changes.\n. @mxcl Curious about your thoughts on this.pendingWithPipe()isn't a great name, but I didn't want to overloadpending()` and introduce ambiguities at the call site.\n. A couple more thoughts on this.\nWe could overload pending. If you unpack the tuple, there's no ambiguity. It would, however, require you to specify the type if you didn't want to unpack it, and we'd still have to name a type alias for the (Promise, Pipe) variant.\nswift\nlet (promise, fulfill, reject) = Promise<Int>.pending() // fine\nlet (promise, pipe) = Promise<Int>.pending() // fine\nlet root = Promise<Int>.pending() // ambiguous, compile error\nlet root: PendingTuple = Promise<Int>.pending() // fine, but PendingTuple should be renamed since there are now two PendingTuples\nThere's also the option of having a PendingPromise type, which you can then choose how to resolve later.\nswift\nlet pendingPromise: PendingPromise<Int> = Promise<Int>.pending() // or would you just instantiate with PendingPromise<Int>() ?\npendingPromise.fulfill(3)\npendingPromise.reject(error)\npendingPromise.pipe(promise)\nI think a previous version of PromiseKit may have had this PendingPromise type?\n. Oh, I like that idea. One potential concern is that it's possible to misuse the API, and say, accidentally mix and match fulfill and reject blocks from different pending promises.\nWhat do you think about the PendingPromise type approach I mentioned? I'm thinking PendingPromise is a subtype of Promise (or maybe they conform to a common protocol).\n``` swift\nfunc make() -> Promise {\n    let enginePromise = PendingPromise()\nfirstly {\n    // \u2026\n}.then {\n    // \u2026\n}.pipe(enginePromise)\n\nreturn enginePromise\n\n}\n```\nPendingPromise would also have fulfill and reject methods, and we'd deprecate Promise.pending().\nThat is, we'd have something like:\n``` swift\nclass PendingPromise: Promise {\n    func fulfill(value: T) { / \u2026 / }\n    func reject(error: Error) { / \u2026 / }\n}\nextension Promise {\n    func pipe(pendingPromise: PendingPromise) { / \u2026 / }\n}\n```\n. Come to think of it, I guess we already have a pending promise type. There's no reason to unpack the tuple in your example, we could just do:\n``` swift\nlet pending = Promise.pending()\nfirstly {\n    //\u2026\n}.then {\n    //\u2026\n}.join(pending)\n```\nI guess then you'd have to chain your blocks on pending.promise, which is a bit ugly.\n. Awesome!. Going to close this PR since it sounds like you found a better solution.. I'm not totally sure what's going on here, but as a work-around, you can either explicitly annotate your parameter as Any or use a more concrete type, like Promise<Int>.\nswift\n_ = firstly { () -> Promise<Any> in\n    return \u2026\n}.then { (any: Any) -> Promise<Any> in\n    return \u2026\n}.then { (any: Any) -> Promise<Any> in\n    return \u2026\n}.then { (any: Any) -> Any in\n    print(\"HERE IS A NUMBER \\(any)\")\n    return any\n}\nor\nswift\n_ = firstly { () -> Promise<Int> in\n    return \u2026\n}.then { value -> Promise<Int> in\n    return \u2026\n}.then { value -> Promise<Int> in\n    return \u2026\n}.then { value -> Int in\n    print(\"HERE IS A NUMBER \\(value)\")\n    return value\n}\n. To illustrate what's going on more concretely:\n`` swift\n_ = firstly { () -> Promise<Int> in\n    return Promise(value: 1)\n}.then { value in\n    //valueis inferred to beInt` (expected)\n    return value\n}\nlet foo = firstly { () -> Promise in\n    return Promise(value: 1)\n}.then { value in\n    // value is inferred to be Promise<Any> (surprisingly)\n    return value\n}\nfoo.then { value in\n    // value is inferred to be Any (expected)\n    return value\n}\n```\n. Dupes #549, #551, #561, #574, #584.\nThis was intentional. See the other tickets for the rationale and discussion.. Since this is consistently brought up, we might want to add something about it to the FAQ. We could also mention your fatalCatch() suggestion. (Although I'm not sure people are checking the FAQ before creating issues here.)\nI agree that something like UnfailablePromise could simplify a several APIs (after, non-throwing recover, non-throwing UnfailablePromise.then) and would therefore be worthwhile.\nIt would be nice if we could customize the unused result warning to indicate that you're expected to terminate promises with a catch, but I don't think that's currently possible.. Check out when(fulfilled:).. Fixed, thanks.. This should basically work; if ok returns Promise<Void>, you should be able to use the then syntax you want. You can also omit the parentheses around _, leaving you with:\nswift\nok(\"Are you sure?\").then {\n  // do something\n}.catch { _ in\n  // do something else\n}\n. The following compiles for me:\n```swift\nclass Foo {\n    var handler: Promise.PendingTuple?\n@discardableResult func ok() -> Promise<Void> {\n    let (promise, fulfill, reject) = Promise<Void>.pending()\n    self.handler = (promise, fulfill, reject)\n    return promise\n}\n\nfunc foo() {\n    ok().then {\n        // do something\n    }.catch { _ in\n        // do something else\n    }\n}\n\n}\n```\nWhat's the error you're getting?. Seems to be in a bunch of files. Just updated, thanks @vpdn.. I think all the changes made are either in Swift code or associated with Swift code.. What do you expect value to be in that example? There's when which would give you an array of the promise values once they all resolve and race which would give you the value of the first promise to resolve. See http://promisekit.org/docs/handbook/Functions.html.\nOr are you looking for something different?. There's nothing that ships with PromiseKit that provides this functionality. You can store your function in a variable and pass that in to each then. Or use when.\nswift\nlet handle: (Type -> Void) = { val in ... }\npromise1.then(handle)\npromise2.then(handle)\nOr\nswift\nlet handle: (Type -> Void) = { val in ... }\nwhen(promise1, promise2).then { $0.forEach(handle) }\nYou can make your own function for this, but it's probably not common enough to belong in the library.. See the documentation on Making Promises; your specific use case is covered.. If you are queuing these DeferredPromises, you may find these classes helpful: https://gist.github.com/zlangley/e6c7ea0b49f8a3cea0df35bd20c9c865. Adding the types should help the compiler.\nswift\n}.then { () -> Void in\n    self.resetValues()\n}. You are missing the in keyword.. Since the sample code below is in Swift I don't find it strange to prefer URLSession here.. Yes, this should be reverted.. I would probably say URLSession, but I have no problem reverting this.. ",
    "nalexn": "For those who is looking for more robust implementation of the retry function that takes arbitrary number of retries and delay:\nSwift\nfunc retry<T>(times: Int, cooldown: TimeInterval, body: @escaping () -> Promise<T>) -> Promise<T> {\n  var retryCounter = 0\n  func attempt() -> Promise<T> {\n    return body().recover(policy: CatchPolicy.allErrorsExceptCancellation) { error -> Promise<T> in\n      retryCounter += 1\n      guard retryCounter <= times else {\n        throw error\n      }\n      return after(interval: cooldown).then(execute: attempt)\n    }\n  }\n  return attempt()\n}. ",
    "namanhams": "Is there anyway to do this in Objective C ? I can't seem to be able to use the recover function in Objective-C. ",
    "bibhas2": "OK, cool when will do the trick. It will be great to see a mention or link from the chaining section of the doc. Right now chaining only mentions sequential calls. Thank you all!\n. ",
    "FruitAndAShape": "What does one do if the promises are of a different type?\n. Here is my actual code...\n```\n    open func getTours(_ parameters: SearchParameters) ->\n        (apiRequest: ApiRequestProtocol, promise: Promise<(count: Int64, tours: [Tour])>) {\n    return when (fulfilled: tourRepository.fetchTours(parameters), iApHelper.getProducts())\n\n        .then { results in\n\n\n        }\n}\n\n```\nError is...\n\nCannot convert value of type '(apiRequest: ApiRequestProtocol, promise: Promise<(count: Int64, tours: [Tour])>)' (aka '(apiRequest: ApiRequestProtocol, promise: Promise<(count: Int64, tours: Array)>)') to expected argument type 'Promise<_>'\n. oh yeah! Thanks.\n. This works...\n\n```\n    open func getTours(_ parameters: SearchParameters) ->\n        (apiRequest: ApiRequestProtocol, promise: Promise<(count: Int64, tours: [Tour])>) {\n    var tours = tourRepository.fetchTours(parameters)\n\n    tours.promise = when (fulfilled: tours.promise, iApHelper.getProducts())\n\n        .then { results in\n\n            return results.0\n        }\n\n    return tours\n}\n\n``\n. So you need to explicitly return a Promise, which can be created using.value()`. I get it.. I thought I had. I reckon there should be an example that shows that, for example...\n.then { v -> MyClass in\n   ...\n   return v\n}\nShould become...\n.then { v -> Promise<MyClass> in\n   ...\n   .value(v)\n}\n. Great, thanks. I'll keep reading.. ",
    "chrisze": "Fantastic! Thanks for the follow up. \n. ",
    "b123400": "I thought it will be bridged to NSString as well, but it doesn't.\n\nThe functional signature init<T: AnyObject> means that T has to be an AnyObject but String is not.\nMay I ask where does the bridging happen? \n. I think I know why is it not getting bridged.\nSeems that Swift only bridge types when it is not a member of a generic. \n```\nfunc foo(input:T) {}\nfoo(\"a\") // no problem\nfunc baz (input:Optional) {}\nlet b:Optional = .Some(\"b\")\nbaz(b) // error: Cannot convert value of type 'Optional' to expected argument type 'Optional<...>`\n```\nNot sure if this is an expected behaviour or not.\n. Suggestion 2) would be the best if it can be implemented, but I wonder if it is possible. Some Swift types cannot be bridged to Objective C (like array of enum), is there way to handle case like this?\n. ",
    "afladmark": "I get the same compilation error with Promise<Bool>.\n. ",
    "nivanchikov": "thanks @nathanhosselton, \n\nIf you reach a situation where you do want self to be allowed to deallocate before your promise resolves then that's when you would employ weak or unowned. I believe the latter will catch in your error handler should it come up nil\n\nI suppose unresolved promise wouldn't reach the error handler and dealloc instead in case we use unowned, giving the following log: \"PromiseKit: Pending Promise deallocated! This is usually a bug\". \nAnyway, thx for pointing me to the source of truth, closing the issue\n. ",
    "alexth": "Solved by creating enum with custom ErrorType and passing it into reject().\nGot rid of NSError usage. Now validateNameLength() returns custom ErrorType\n. I did the the same you explained. Thank you @nathanhosselton !\n. ",
    "lammertw": "I managed to run the test with the fix in #373 and added a test. Hopefully this can be approved and merged now.\n. The problem is also with CLLocationManager+Promise.swift\n. But watchos support was only added for watchos 2 right? (According to #265)\n. You're welcome!\n. This changed has been undone in commit eca0eba82db2dcecc75c7eb648a5fefe81e7b672 and therefore the NSURLSession+Promise.swift is again unavailable to watchos targets.\n. It only happens once and a while and I have no idea under which conditions since I never ran into it myself. I also see it back at crash reports.\n. ",
    "jotajota05": "Unfortunately I cannot share any specific code, but the examples represent what Im doing, the content of the methods is irrelevant. How I know is Promise Kit?, because the compiling time is being increasing with any new promise that I add. Even when I just try to edit one of the methods, Xcode start a very heavy and slow process of indexing, losing my colors in the IDE editor and everything, and then the compiling take ages or get stuck. And this only happens when I modify the file where I have the Promises. If I work in every other file the compiling process runs fine. \nIn some cases I reduce the number of promises, putting a bunch of them inside another method that runs in the original promises chain. This got things a little better (at least the code compile in a decent amount of time)\nInside the promises methods normally I run calls to backend using Alamofire, I don't know if this can be messing with something.\nThe library works like a charm, but everytime I need to modify the specific class that contains the promises is a pain.\n. I understand. Sorry I cannot share the code. Basically every method runs some background operations, use the GCD, call backend services with Alamofire or communicate with devices using the thunder port, They are indeed not trivial methods. And the problem is only during compile time, and only if I modify the file that runs the promises. \nWell, at least keep an eye on this behaviour, so maybe in the future you can have a more concrete scenario where you can replicate it. \nThank you.\n. ",
    "leoMehlig": "The thing is that I usually don't want to include the code of a external framework in my internal codebase, because this makes updating way more complicated. \nSo in my case I want to use only the Foundation category in my iOS App. Obviously it would be inefficient to include all categories and with that link all necessary system frameworks. \nBut you are right that this would add a whole new level of complexity to the project and most users would be confused by all the binaries that were build.\nAnother solution would be to create separated repos for each category which would allow much finer control over which categories get build and included. I don't know how this correspond with the cocoapods subspecs.\nI really would love to help making the library more accessible to carthage users :)\nPS. Carthage currently produces some warnings due to missing code sign identities. I suspect the test and host target to be the cause of this. Maybe you should considers putting them into a subproject, but I'm not sure about the specifics.\n. Oh, right.\nThe Carthage checkout folder isn't in our git (or in our case svn). On our build server we run carthage update which downloads all the dependencies and builds them. This is all done automatically with each commit.\nFor now I include the needed category classes in my project, but I don't really like this solution. \n1. When copying the files into the project you are unable to automatically update them\n2. Its third-party code in your project (which I personally don't like). \n3. A small thing is that you don't have the usual access control. Because the classes are in your project you can access internal (swift) function/variables instead of only public\n. @mxcl I see you are putting all the categories in separate repo. That solution is way better and cleaner!!!\n. Is it ok that the PR contains multiple commits and does the last commit correct all the whitespace?\n. Done!\n. Pretty sure it doesn't break any API. All changes (++, --) are in functions bodies and the currying only was used with a private function.\n. I've added a small note above all import statements. This should probably point everyone in the right direction.\n. ",
    "NinjaSudo": "@mxcl you mentioned a subspec for the NSURLConnection category that can be used in PMK4, where does this live? I plan to migrate over to different methods, but after a migration to Swift 3, etc needed to upgrade.. ",
    "peterwarbo": "@nathanhosselton yes that is the case, I'm having varying promise types. So how would I use PMKWhen (which I believe is from the Obj-C library) in my Swift project?\n. @nathanhosselton thanks didn't know the objective-c code was bundled together with the Swift code. \nDo PMKWhen() and when() work the same way? It seems that PMKWhen is fulfilled even though one of my promises is failed. It was to my impression that when should only be fulfilled when all promises are fulfilled?\n. ",
    "feighter09": "Ah the pains of swift we take for the good, huh? \nThat's understandable, and I don't have every version of Xcode ever to test em all, so do with this what you wish\n. Although when has had this since August of last year, so I think it'll be alright\nhttps://github.com/mxcl/PromiseKit/commit/a2718b2d3ef2aedab42bca376aec45ee343ed9a4#diff-65c2204ae94d363ee89e320cf7f237d3\n. Don't merge, think I found an issue. Will also include tests from #375 in final \n. @rbobbins do you want to replay your commit on top of mine? I'll make you a contributor to my fork if you'd like\n. added join tests and array-based race tests. Anything else preventing this from merge?\n. I'm uncertain what the contract here is - should an empty array of promises to join immediately resolve or should an \"invalid use\" error be produced like below?\n. Not sure how this should be handled, I'm unable to make this immediately resolve in the case of an empty array because we cannot instantiate a T for a use like return Promise<T>(value: T()). This forces me to throw an error or return an optional promise Promise<T>?, but the optional seemed less desirable.\n. There's an issue here if the array param is empty, the promise will never fulfill. I've handled this in #374 but could really use your tests, would you like to merge?\n. ",
    "rbobbins": "D'oh! Should have looked at #374 before doing this. This includes test for the 1 method (race) that I updated.\n. ",
    "WhaleWatching": "This is a mistake of mine, sorry.\n. ",
    "DominikDeak": "Mac Pro (Mid 2010)\nEl Capitan 10.11.3 (15D21)\nXcode Version 7.2.1 (7C1002)\n. > in this instance \u2014 not sure if you want to share the sample project here @DominikDeak? \n@tonyarnold Yes, I was going to, but held off posting it here until you  confirmed the build error independently. \n@mxcl Minimal test project is available here:\nhttps://www.dropbox.com/s/oyqguv9im3mksgq/Foo.zip?dl=0\n1. Unzip and open Foo.xcworkspace.\n2. Optional: Run carthage update in the terminal under the Foo directory and rebuild PromiseKit. However, for convenience, I have included the PromiseKit binaries in the Zip, so this step may be unnecessary.\n3. In Xcode open Test.mm to see where PromiseKit  header is imported.\n4. Build, and you should see the error \"Please #include  instead of this file directly.\"\n5. In Test.mm importing <dispatch/dispatch.h> before PromiseKit header fixes the problem.\n6. Renaming  Test.mm to Test.m also fixes the problem. \n\nso I wonder why nobody else is getting this error?\n\nI'm speculating two possible causes:\n1. Most projects import <Cocoa/Cocoa.h> before PromiseKit, which presumably already has <dispatch/dispatch.h> part of its headers. The test code above imports PromiseKit first.\n2. As @tonyarnold mentioned earlier, this might be also related how Objective-C++ imports/includes headers. Interaction between Objective-C++ and modules appears to be different, so presumably the preprocessor falls back to the C and C++ inclusion model. \nSide note:  Headers in version 1 of PromiseKit  did actually reference <dispatch/dispatch.h> instead of <dispatch/queue.h>, but that changed somewhere in version 2, I believe.\n. > Surely your synchronization tools can handle this?\nWe're using both git command line and GitHub's synchronisation tool. PromiseKit was added on a Mac platform, the issue was discovered once we tried to sync with a local copy on Windows. For example, a clone attempt onto an NTFS partition raises the following error:\nfatal: cannot create directory at 'Carthage/Checkouts/PromiseKit/Tests/Promises:A+ Specs': Invalid argument\nwarning: Clone succeeded, but checkout failed.\nYou can inspect what was checked out with 'git status'\nand retry the checkout with 'git checkout -f HEAD'\nAnyway, at least PMK tests is not particularly critical for us, so I might have to .gitignore that directory for the time being.\n\nI understand your pain, but we hardly consider Windows support important.\n\nFair enough, just raising awareness.\n. No problem.\n. ",
    "Sega-Zero": "You could use a unicode equivalent, \u2805 for example.\n. Having Include of non-modular header inside framework module 'PromiseKit.CLGeocoder_AnyPromise' on latest release in my swift project \ud83d\ude1e\ncocoapods 0.39.0, xcode 7\n. Did anyone filed a bug on bugs.swift.org? Couldn't find any. . ",
    "lifely": "Hey @foobar8675,\nI was looking for something similar, i since i think i might have my answer, i'll take some time and share it for you.\nI think we can both achieve what we want through a simple PMKWhen : \n\nhttp://promisekit.org/when. \n\nHowever if you read the documentation right you'll might also be interested in a join: promise: \n\nhttp://cocoadocs.org/docsets/PromiseKit/1.4.2/Classes/PMKPromise.html#//api/name/join:  \n\nNote there's also some drawback to using a join closure. One of the other drawback i find is that there not easy way to apply a timeout to such grouped promise.\nThe documentation does reference the availability of NSProgress on promise, but i wish a timeout behaviour would be available out of the box.\nAnyway, thanks for the work peeps.\n. ",
    "danlozano": "Hi @mxcl great library!\nThis issue is helping me a lot in my quest to implement an API polling system.\nI just have an issue with this sample code. Even if it times out and catches the error, the pollRecursive and signal keeps getting called.\nThis is my updated version of your code.\n```swift\nenum PromiseError: Error {\n    case Timeout\n}\nfunc poll(signal: @escaping () -> Bool, interval: TimeInterval, timeout: TimeInterval) -> Promise {\n    func pollRecursive() -> Promise {\n        return signal() ? Promise(value: ()) : after(interval: interval).then(execute: pollRecursive)\n    }\nreturn race(after(interval: timeout).then { throw PromiseError.Timeout }, pollRecursive())\n\n}\npoll(signal: randomSignal, interval: 1, timeout: 2).then {\n    print(\"done\")\n}.catch { error in\n    print(\"error\")\n}\nfunc randomSignal() -> Bool {\n    let r = arc4random_uniform(4) == 0\n    print(r ? \"Complete\" : \"Not complete\");\n    return r\n}\n```\nIsn't the throwing of the timeout supposed to error out and stop everything?\nThanks for your help, sorry if it's a dumb question.. This is the console output\nNot complete\nNot complete\nNot complete\nerror                      <- Shouldn't it have stopped here?\nNot complete        <- kept calling pollRecursive() & therefore signal()\nNot complete        <- kept calling pollRecursive() & therefore signal()\nComplete               <- until it completed. Sorry for adding this here. Will add this to it's own issue.\n:). Thanks @mxcl ! This makes total sense. Made it work with a \"max attempts\" instead of a timeout, but will implement it with a timeout now that I know how \ud83d\udc4d \nNow I'm completely stuck again :( haha\n```swift\nfirstly {\n    searchService.search(searchQuery)\n}.then { searchResults -> Promise in\npoll(interval: 1, maxAttempts: 10, body: { () -> Promise<PlanePollResults> in\n    self.searchService.pollPlane(searchId: searchResults.info.id)\n}, signal: { (planePollResults) -> Bool in\n    planePollResults.state == .finished\n})\n\n}\n```\nI first need to do a search which gives me an ID so I can start doing polling. Doing polling for \"plane flights\" works perfectly as in the code above. But I also need to simultaneously/concurrently do polling for \"bus trips\". I'm thinking of something like so:\n```swift\nfirstly {\n    searchService.search(searchQuery)\n}.then { searchResults -> Promise in\nlet busPoll = poll(interval: 1, maxAttempts: 10, body: { () -> Promise<BusPollResults> in\n    return self.searchService.pollBus(searchId: searchResults.info.id)\n}, signal: { (busPollResults) -> Bool in\n    print(\"ATTEMPT MADE: PLANE POLL RESULTS: COUNT = \\(busPollResults.trips.count)\")\n    return busPollResults.state == .finished\n})\n\nlet planePoll = poll(interval: 1, maxAttempts: 10, body: { () -> Promise<PlanePollResults> in\n    return self.searchService.pollPlane(searchId: searchResults.info.id)\n}, signal: { (planePollResults) -> Bool in\n    print(\"ATTEMPT MADE: PLANE POLL RESULTS: COUNT = \\(planePollResults.flights.count)\")\n    return planePollResults.state == .finished\n})\n\nreturn when(fulfilled: busPoll, planePoll)\n\n}\n```\nTwo problems with this.\n\nIt errors on the \"return when\" line because it says that it expects a void promise and mine is not.\nI don't know if its possible to do a when with different type of promises. One is for PlaneResults and the other is for BusResults.\nAs far as my understanding goes, JOIN or WHEN, wait for all of them to complete. I don't really care, they don't need to complete \"at the same time\" and one does not depend on the other. I just want them to run at the same time.\n\nSo I could \"separate\" them out into different promise \"chains\", BUT they both depend on the first search promise. So in summary, they both depend on the first search promise to be able to start, but once that happens, they can go on their own separate ways and don't depend on each other in any way.\nIs there an easy way to do this? Is this a dumb question :( haha\nAgain, thanks allot for the framework and for the help!. This is great! Can't thank you enough for this. It all makes sense now.\nSo promises start as soon as they're initialized, or until .then is called?\nThanks again. Using Promises is really making a really complex mess of requests of a weird API backend into a really concise easy to understand peace of code. \ud83d\udc4d \nAs soon as I get a good understanding of how Promises work I would love to try and contribute to this library. Thanks again!. This is the final code. Does it seem reasonable?\nI was thinking, knowing that both poll promise chains have finished might be useful for UI purposes, like stopping an activity indicator for example.\nI could use join or when, so the promise completes when all of them complete, that way I know when they are all finished. \nBUT then I'm back to square one, because I also want to know when each one is finished, I don't need to wait for all of them to complete to update UI. That's why I followed your example of creating separate promise chains each one with their own .then handler. \ud83e\udd14 \ud83e\udd14 \ud83e\udd14 \n```swift\nfunc start() {\n    firstly {\n        searchService.search(searchQuery)\n    }.then { searchResults -> Void in\n        self.pollBus(searchId: searchResults.info.id)\n        self.pollPlane(searchId: searchResults.info.id)\n    }.catch { error in\n        print(\"SEARCH ERROR = (error)\")\n    }\n}\nfunc pollBus(searchId: Int) {\n    poll(body: { () -> Promise in\n        self.searchService.pollBus(searchId: searchId)\n    }, signal: { (results) -> Bool in\n        print(\"ATTEMPTING BUS POLL : COUNT = (results.trips.count)\")\n        return results.state == .finished\n    }).then { (finalResults) -> Void in\n        print(\"FINISHED BUS POLL : COUNT = (finalResults.trips.count)\")\n        dump(finalResults)\n    }.catch { error in\n        print(\"ERROR POLLING FOR BUS = (error)\")\n    }\n}\nfunc pollPlane(searchId: Int) {\n    poll(body: { () -> Promise in\n        self.searchService.pollPlane(searchId: searchId)\n    }, signal: { (results) -> Bool in\n        print(\"ATTEMPTING PLANE POLL\")\n        return results.state == .finished\n    }).then { (finalResults) -> Void in\n        print(\"FINISHED PLANE POLL\")\n    }.catch { error in\n        print(\"ERROR POLLING FOR PLANE = (error)\")\n    }\n}\n```\nBTW your POLL implementation is working perfectly! ... Just thought of something. If one of the polls fails, like the first one out of 10 for example, I don't really care, because much more polls are coming after that one. Right now if one fails I guess the whole poll promise chain fails.\nI think I need to somehow merge the POLL implementation, with the RETRY implementation in the docs, and implement some form of RECOVER. But the recover function returns a \"default\" value of some sort. I just really want to tell the promise chain to continue, and ignore the error. \ud83e\udd14 \ud83e\udd14 \ud83e\udd14 . This is awesome! Can't thank you enough.\nOk. I will consolidate all error handling to a single .catch block. The only issue I thought that could happen was that I would get a generic API error and I would not know to which of the requests that error belongs to.\nBUT I guess I could just create a more specific error type for each of the requests which wraps the api error as an associated value. Makes sense?\nWill post the final \"correct\" code in a second just in case some other Promise newbie arrives here \ud83d\udc4d . Just say your comment on recover. Totally get it.\nI guess what I was trying to do is something more like this.\nswift\nfunc poll<T>(interval: TimeInterval = 1.0, maxAttempts: Int = 20, body: @escaping () -> Promise<T>, signal: @escaping (T) -> Bool) -> Promise<T> {\n    var attempts = 0\n    func attempt() -> Promise<T> {\n        attempts += 1\n        return body().then { result -> Promise<T> in\n            guard attempts < maxAttempts else { throw PollingError.maxAttemptsReached(forType: T.self, maxAttempts: maxAttempts) }\n            return signal(result) ? Promise(value: result) : after(interval: interval).then(execute: attempt)\n        }.recover { error -> Promise<T> in\n            guard attempts < maxAttempts else { throw PollingError.maxAttemptsReached(forType: T.self, maxAttempts: maxAttempts) }\n            return after(interval: interval).then(execute: attempt)\n        }\n    }\n    return attempt()\n}\nI basically \"merged\" my own polling with the retry sample code. This way, if somewhere in the middle of the 20 attempts there is an error, it \"ignores\" it and continues on the chain.\nJust realized this is possibly going to create two separate promise chains. damn. :(. Oh awesome! ... I guess not.\nSo do you think the above POLL function would achieve the objective of polling 20 times, and ignoring any error that comes along, UNTIL it reaches the max attempts and then errors out.\nCool \ud83d\udc4d . - Oooh interesting! as asVoid() ignores the promise type and let's me recover with \"nothing\" ?\n\nAnd just for curiosity. Would my previous code of using the nested catch work but it's considered bad practice? or would it not even work like I assume?\n\n\nSo, with your code\nswift\ntokenizeCard().then { token -> Promise<Payment> in \n  return makePayment(token)\n}.then { payment -> Promise<Void> in\n  return updateUserModel().then { user in\n    // Do something with user\n  }.asVoid().recover { }\n}.then { () -> Void in \n   // Would this still be called after all the chain finishes?\n   // I don't care if update user model succeeds, BUT I only want to \"continue\" \n   // when updateUserModel() is finished, either by succeeding or failing, doesn't matter\n      self.goToNextScreen()\n}.catch { error in \n   // And this would only be called if error in tokenize and payment, correct? \n   // because of the .recover in updateUserModel()\n  print(\"ERROR\")\n}. It's all making sense now. Can't thank you enough!. ",
    "kominak": "I encountered several annoying obstacles when working with AnyPromise in Swift, so this approach brought in several advantages (not only syntactic ones), which unifies the access to both types of promises in Swift code.\n- AFAIK there's no way to call catch, recover nor finally on AnyPromise in Swift. I had to add a dummy call like .then { _ -> Void in }\n- I found it nicer to use .toPromise(Type) than the code below (although I acknowledge that the second example is perhaps more clear and obvious - but requires a lot more writing):\nswift\n.then { value in\n    guard let value = value as? Type else { throw SomeError }\n}\n- Then there are the small syntactic differences like AnyPromise.value() vs. Promise.value\n- Imagine a situation where you want to store several promises to an array, or return a promise from a method - and they can originate both from ObjC part (AnyPromise) and from Swift (Promise<T>). You'll probably want to convert them to be of the same type, and if you plan to use them in Swift, chances are that Promise would be a better candidate.\n. I'm glad you found that useful. Feel free to modify it any way you like it, including adding some tests :) I should've added them myself.\nI agree that calling .toPromise(T) on top of every \"legacy\" promise is a bit awkward, but we couldn't find any better (less weird) way either.\n. ",
    "PerishableDave": "The comment in NSErrorSuplement mentions that wrapping the original error with NSUnderlyingError is a todo. If thats something the maintainers would still like to do I can do the work to make the changes.\n. The interim fix sounds fine. We'd have to check the class to see if it's _SwiftNativeNSError, since trying to instantiate it produces an exception rather than returning nil. I'll make the changes so long as you're ok with it.\n. Hrm, actually none of those solutions work. Trying to instantiate _SwiftNativeNSError throws EXC_BAD_ACCESS and can't be caught. We also can't check for the class since _SwiftNativeNSError isn't public. I'm trying to think of other options, but don't have any other ideas at the moment. Do you want to leave it broken till 4.0 or disregard it entirely? Anyways, whatever you want to do.\nFor reference:\n_SwiftNativeNSError\n. @boardmain \nI was having the same problems. I tried rm -rf Pods/ with no success. Eventually I upgraded to Cocoapods 1.0.1 and removed all my Xcode cached files as per the link below. I then removed Pods/ again, pod installed, rebuilt, and finally got a success. Give it a try and see if you have any luck?\nhttp://stackoverflow.com/questions/5714372/how-to-empty-caches-and-clean-all-targets-xcode-4\n. ",
    "jgrantr": "I've submitted a pull request.  Let me know if you need anything else.\n. Yep, it was there in the AnyPromise.h  header (along with 3 other properties) until July 31, 2015, when it was removed with commit 444dcdd with the message \"Fixes #225\", but it (and the other 3 properties) remained in AnyPromise.swift with an @objc decorator, so they were still accessible from Objective-C.  Then on Sept 7, 2016,  2 of them were put back into the AnyPromise.h header in commit 67bc256, at which time the 'rejected' property was removed from AnyPromise.swift (also in the same commit).. Thanks for fixing this!  Love using PromiseKit in my apps.  It's become a staple pod on every Objective-C  (and Swift) project I work on, so thanks for all you do!. ",
    "DesignatedInitializer": "I've just merged my private account and my professional account, that's why I'm appearing as ghost above.\n. Sorry for taking so long to reply.  The Carthage build isn't failing, but it's printing a number of warning and we'd just like it to build without any warnings.  Understand what you're saying, will close the PR.\n. Looks like I don't have access rights to close the PR as I created it with a now deleted account, if you can, please go ahead and close it.\n. ",
    "gsabran": "I'm having issues with return types:\nswift\nprivate func connect() -> Promise<Void> {\n    return tryToConnect()\n        .then { payload -> Void in\n            // do something here\n            // don't return anything\n        }\n        .onError { _ -> Void in\n    }\n}\nRaises the error Cannot convert return expression of type '()' to return type 'Promise<Void>' (aka 'Promise<()>')\ntryToConnect is of type () -> Promise<JSON> if that helps\n. duuh sorry about that!\n. Sure. For instance.\nswift\nsomePromiseStuff\n.thenWhile(thereIsNotEnoughItemLoaded, loadMoreItems)\n.then(...)\nWhere thereIsNotEnoughItemLoaded would check if there's enough items loaded and loadMoreItems would be a promise that does an API call and fetch some more items.\n. Yup sure enough. But it'd be great to use promise to remove some of what I see as async boilerplate.\nI think that'd go well with the idea behind promise that is to make all the async things much more natural :)\n. Ah nice! Plus it's in the docs :)\n. Thanks. Which version do you prefer to have in the readme atm?\n. Just that on the swift-3.0 branch the readMe says to run pod \"PromiseKit\", \"~> 4.0\" (under quick start)\nIt's pretty minor :)\n. sure thing!\n. Yes I already done that, and googled :) First result is http://stackoverflow.com/questions/38446097/xcode-8-beta-3-use-legacy-swift-issue, which is where my podfile code is coming from. It's still annoyingly not working. But no worries if you have better things to do. I'm just frustrated of not getting Promise in my new project!\n. Thanks all. I fixed it. I was stupidly running the version 5 of the beta, and I needed to point to the commit that supports that version instead of the latest version of the swift3 branch:\npod 'PromiseKit', :git => 'https://github.com/mxcl/PromiseKit.git', :commit => '0e8d157a7b56e6dc1e2c8190dfaea03ddf1059de'\nSorry for wasting your time\n. Ah excellent good point. I should have taken the warning much more seriously. Thanks a lot for the help!\n. ah nice to have PromiseKit/CorePromise thanks for the quick response\n. I see. So unless specified then execute in the main thread? Like\nsomePromise.then(on: DispatchQueue.global(qos: .background)) { x in\n    ...\n  }.then { y in\n    // this is is executed in the main thread, correct?\n  }. ok great thanks. It gets verbose when using promises in a background queue since at every step I've to specify to stay in the background, but I don't see a better solution since we can't remove the default being going back to the main thread as it would break a few apps for sure. So that's ok.\nI've also had a few times where I'd like the promise to be executed in the thread it's called in. Like usually when you do\nswift\n...\nsomeFunction()\n...\nyou'd expect someFunction to run in the current thread, ie the caller is responsible for choosing the thread, while promises have the opposite behavior where by default the block is dispatched in the main thread and the caller cannot specify which thread to run the promise in, and can only do so for what happens next.\nBut I don't see what a better solution would look like.. Also I've been surprised that, even when called in the main thread, the block doesn't run synchronously as is the case in javascript. But that just a surprise that comes with platform switch :). Sorry about the confusion. I was thinking about the first block, and I didn't write my test correctly. This indeed executes the first block synchronously:\nswift\nprint(1)\nlet p: Promise<Void> = Promise { resolve, reject in\n  print(2)\n  resolve()\n}\np.then {\n  print(3)\n}\nprint(4)\n// prints:\n// 1\n// 2\n// 4\n// 3\nand not the second one as excepted.. ",
    "sstadelman": "@nathanhosselton @mxcl Thanks, that's fair.\n. ",
    "programmerdave": "@mxcl I changed the name, made it accessible from both, and all tests pass (aside from an existing Issue which I submitted a separate PR for). Thanks!\n. No problem! Thanks! Do you know when this would be merged into master?\n. If you want to make it more resilient in the future, and all you need is any photo, you can just use the \"SELF.label LIKE %@\", \"Photo\" predicate instead so it's even more future proof \n. ",
    "ryanschneider": "I was originally think a Bool as well, but realized there needs to be a second promise involved since the Promisable.promise is what triggers us to call dismissViewController, we still need another promise to fulfill when the dismissal completes.  I thought it'd be wrong in some way if setting the Bool actually changed which promise was returned (the Promisable.promise or the \"dismissed\" promise that wraps it), and then decided that passing in the dismissal completion handler is more generic (in case someone wanted to do something non-promise-based in the handler as well).\nBut if returning the wrapping promise passes the smell test for you I'm all for encapsulating everything in the function with a Bool.\n. Thanks for the quick turnaround!  3.4.2 works perfectly for me.\n. Ah, I totally missed the Promise+Properties.swift file when looking through the code. :)\n. Oh, also, I just realized this error was occurring when building my watchOS app, not the iPhone app, so maybe it's an issue with the watchOS SDK headers being slightly out of sync with the iOS SDK ones.\n. Ok, updated to use the new after(interval: DispatchTimeInterval) signature.. I'm late to the Swift 4 bandwagon, but just hit this same issue and spent the last 20 minutes sprinkling () in all my fulfill()s.  Is there a specific location you'd recommend for us to communicate our displeasure to the Swift team at? \nIt sounds like most people think \"tuple gate\" has been resolved, but it sounds like this change at least hasn't been.. ",
    "blakebyrnes": "Well, strangely.. I don't seem to be able to.  I created a playground that does basically what my code is crashing on, but it's not reproducing that behavior.   This works fine...\n```\nfunc getResult() -> Promise {\n    return Promise { fulfill, reject in\n        print(\"running\")\n        fulfill(nil)\n        print(\"fulfilled\")\n}\n\n}\ngetResult().then { val -> Promise in\n    print(\"Got value (val)\")\n    return Promise(nil)\n}.then { val in\n    print(\"Got number (val)\")\n}\nXCPSetExecutionShouldContinueIndefinitely()\n```\nAttached you can see where the code is crashing, and the source:\n\n\n. ",
    "morishin": "I found the same crash in my app.\nThis crash was shown not on swift-2.0-minimal-changes branch but on swift-2.2-minimal-changes) branch.\nSo It seems to occur because of 1ffca8f.\nThe following is a crashlytics log.\nCrashed: com.apple.main-thread\n0  libsystem_kernel.dylib         0x1838c811c __pthread_kill + 8\n1  libsystem_pthread.dylib        0x183994ef8 pthread_kill + 112\n2  libsystem_c.dylib              0x183839dac abort + 140\n3  libswiftCore.dylib             0x100ca3928 swift::fatalError(char const*, ...) + 50\n4  libswiftCore.dylib             0x100c8c0f0 swift::swift_dynamicCastFailure(void const*, char const*, void const*, char const*, char const*) + 70\n5  libswiftCore.dylib             0x100c8c180 swift::swift_dynamicCastFailure(swift::Metadata const*, swift::Metadata const*, char const*) + 142\n6  libswiftCore.dylib             0x100c8d4e8 swift_dynamicCast + 2616\n7  libswiftCore.dylib             0x100c8d148 swift_dynamicCast + 1688\n8  libswiftCore.dylib             0x100c8cda4 swift_dynamicCast + 756\n9  PromiseKit                     0x10076a7d0 Promise.(then<A> (on : OS_dispatch_queue, (A) -> Promise<A1>) -> Promise<A1>).(closure #1).(closure #1) (Promise.swift:204)\n10 libdispatch.dylib              0x1837794bc _dispatch_call_block_and_release + 24\n11 libdispatch.dylib              0x18377947c _dispatch_client_callout + 16\n12 libdispatch.dylib              0x18377eb84 _dispatch_main_queue_callback_4CF + 1844\n13 CoreFoundation                 0x183ce4dd8 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12\n14 CoreFoundation                 0x183ce2c40 __CFRunLoopRun + 1628\n15 CoreFoundation                 0x183c0cd10 CFRunLoopRunSpecific + 384\n16 GraphicsServices               0x1854f4088 GSEventRunModal + 180\n17 UIKit                          0x188ee1f70 UIApplicationMain + 204\n18 Bentopad                       0x100132100 main (AppDelegate.swift:12)\n19 libdispatch.dylib              0x1837aa8b8 (Missing)\n. ",
    "mobileexpert1": "This helps me to resolve my issue:-\nhttps://github.com/mxcl/PromiseKit/pull/408\n. ",
    "maxday": "Hi,\nThanks for your quick answer. I found a way to test, I will share this tonight so you can have a starting point to discuss\n. ",
    "mjhpretorius": "Hi @maxday and @mxcl would you be able to share your answer? I am having the same problem.\nHere is my MockLogInService, which I am injecting into our controller spec. \n```\nclass MockLogInService: LogInServiceProtocol {\n    var firstName: String?\n    var familyName: String?\n    var birthday: String?\n    let deferred = Promise.pendingPromise()\nfunc logInUserWith(firstName: String,\n                   familyName: String,\n                   birthday: String) -> Promise<String> {\n    self.firstName = firstName\n    self.familyName = familyName\n    self.birthday = birthday\n    return deferred.promise\n}\n\n}\n```\nFrom tests, when I am wanting to test what happens when the call is a success I am doing:\nmockLogInService.deferred.fulfill(\"success\")\nand this for failure:\nlet error = NSError(domain: \"\", code: 401, userInfo: [ NSLocalizedDescriptionKey : \"This is the error message\" ])\nmockLogInService.deferred.reject(error)\nExcept my success and failure blocks are not being called. \nCan you please help direct me in the right direction on this?\nThanks so much for your help!\n. Thanks, I realized I needed to use .toEventually for my Nimble matcher as the test was completing before the code was executed.\n. ",
    "okulak": "I have the same issue.\n. ",
    "robm92": "Having the same issue after upgrading to 7.3.1 - my project can build correctly but will not archive.\n. ",
    "skyebook": "Can confirm issue in a CocoaPods project using 3.1.1\n. Same issue (using Promise instead of AnyPromise), same system configuration. Not using the umbrella pod, just PromiseKit/CorePromise and PromiseKit/Foundation\nLooked in the Pods/PromiseKit target and confirmed NSURLSession+Promise.swift is included for compilation in Build Phases.\n. ",
    "komocode": "I never seem to learn to wait a few days before updating Xcode. Time to roll back...\n. ",
    "rad3ks": "UPDATE: NSNotificationCenter+Promise/AnyPromise files are removed on this branch.\nEasy fix for everybody: https://github.com/rad3ks/PromiseKit/tree/bug/415\nUse in Podfile:\npod 'PromiseKit',\n    :git => 'git@github.com:rad3ks/PromiseKit.git',\n    :branch => 'bug/415'\nI wonder do we really need \nswift\nextension NSNotificationCenter {\n    public class func _once(name: String) -> NotificationPromise\n}\n?\n. I think I rush too much with this one. It worked (somehow) locally. I'm having this issue while running Tests and it just run and passed. I just noticed that CI failed, so sorry for the confusion.\nI don't use these categories, so I'm removing those files from bug/415 branch. Feel free to use it as a workaround if you don't use those categories.\n. @joemcsorley specify pod 'PromiseKit', '~> 3.2' and run pod install if you didn't have PromiseKit or pod update if you already had PromiseKit in your project.\n. ",
    "mnespor": "Seems like a new bug in Swift's type inference? Changing public class NotificationPromise: Promise<[NSObject: AnyObject]> to public class NotificationPromise<T>: Promise<T> prevents the segmentation fault\n. @hiromi2424 My code is here: https://gist.github.com/mnespor/be0d60bfefc04e54608b3cf67cbf0c43. To be clear, this is an exploration of the problem, not a fix\u2014it breaks anything that uses the NSNotificationCenter extension.\n. ",
    "hiromi2424": "@mnespor I've tried such a change but other errors occurred.\nCan you show full code/commit for fix that seg fault?\n. ",
    "esteluk": "There's a tracker for the compiler bug here: https://bugs.swift.org/browse/SR-1427 \n. @johneke as above, you should run pod repo update or similar to update your local cache.\n. ",
    "mildm8nnered": "Looking at https://bugs.swift.org/browse/SR-1427, this was first reported 8 days ago. I suspect that reverting to Xcode 7.3 for now will fix. \n. ",
    "MikeThomas1": "This can be fixed temporarily by setting the Swift Compiler Optimization Level for the Pods project to None. \n\n. ",
    "philippeauriach": "Another temporary fix if you dont use the particular class NSNotificationCenter+Promise.swift , I commented it in a fork : https://github.com/philippeauriach/PromiseKit/tree/fix-archive-xcode-7\nYou can use it with cocoapod :\n    pod 'PromiseKit', :git => 'https://github.com/philippeauriach/PromiseKit.git', :commit => '266cfeb5073277b757efc4a37aa049efc96c596f'\n. ",
    "CFKevinRef": "Assuming you don't need that category, here's a post_install step for your Podfile that doesn't require switching to a fork:\nruby\npost_install do |installer|\n    filename = 'Pods/PromiseKit/Categories/Foundation/NSNotificationCenter+Promise.swift'\n    contents = '// This file removed due to Swift compiler bug https://bugs.swift.org/browse/SR-1427\\n'\\\n               '// PromiseKit tracking of this issue: https://github.com/mxcl/PromiseKit/issues/415\\n'\n    system(\"chmod +w #{filename}; printf \\\"#{contents}\\\" > #{filename}; chmod -w #{filename}\")\nend\nSorry if there's a more standard way than dropping to bash, I'm not an expert in CocoaPods internals or Ruby for that matter.\n. That spec is somewhat ambiguous. Usually you would specify those dependencies like this:\nruby\npod 'PromiseKit', '~> 3.0', :subspecs => [ 'UIKit', 'CoreLocation' ]\nSo that's worth a shot. Keep in mind that the default subspecs include Foundation and QuartzCore too.\n. ",
    "thomasbaldwin": "@MikeThomas1 setting optimization level to \"none\" doesn't seem to fix this issue for me when product archiving. I'm using PromiseKit through CocoaPods 3.0.0\n. I'm having a similar issue\n. I got it working by downgrading to cocoapods 0.37 and downgrading to Xcode 7.3.0 from 7.3.1 @jonasman\n. Thanks for the help!\n. Is there a reason that when I reject an error of type NSError, in my .error callback, it's of type ErrorType and I have to convert it over to NSError to use it?\n. ",
    "lvdaqian": "I need the subspec PromiseKit/Foundation. @MikeThomas1 's solution is working for me. But I am using Cocoapods and do not want to adjusting the pods project setting manually.\nSo I just add this script to my podfile and it works fine.\nruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    next unless (target.name == 'PromiseKit')\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'\n    end\n  end\nend\n. ",
    "MartinJNash": "My team found a workaround for this issue. We don't explicitly need the swift versions of the NSNotification and CLLocationManager promise categories, so we commented out those files. The Objective-C versions work fine.\nThis worked for us in our mixed Swift and Objective-C environment. That said, we can't say how this will work for pure Swift environments.\n. ",
    "kaosdg": "Can confirm works on my projects as well.  Thanks for the hard work!\n. ",
    "joemcsorley": "In my Podfile I'm specifying pod 'PromiseKit', '3.2.1', but I get an error on pod install indicating that version can't be found.\n. ",
    "aziz-boudi4": "@rad3ks even though I specify pod 'PromiseKit', '~> 3.2and then run pod install I keep having PromiseKit 3.2.0being installed and not the desired  3.2.1\n`Analyzing` dependencies \n Downloading dependencies\n **Installing PromiseKit 3.2.0 (was 3.2.0)**\n Generating Pods project\n Integrating client project`\n. @mxcl When I do pod update PromiseKit I get this message : \n``[!] /usr/bin/git fetch --unshallow\nerror: RPC failed; curl 56 SSLRead() return error -36\n fatal: The remote end hung up unexpectedly\n fatal: early EOF\n fatal: index-pack failed```\n. @mxcl never mind, it just worked after multiple attempts \n. I already havepod 'promiseKit/OMGHTTPURLRQ'in my podfile . If I usegetI get the errorType URLSession' has no member get\nBut If I do this, I don't have an error anymore and the compiler is happy : \n            return URLSession().GET(\"http://api.xxx.com/api/\").asDataAndResponse().then { (data , _) -> [Station] in\ninstead of : \n            return URLSession.GET(\"http://api.xxx.com/api/\").asDataAndResponse().then { (data: NSData, _) -> [Station] in\nIs it an acceptable solution, I don't know if it works because I still have other errors, but the compiler seems to be ok with this implementation. After some more digging I found a solution : \nFirst I have to init URLSession with a configuration:\n    let URLSession1 = URLSession(configuration: .default) \nThen I can call the 'GET' method  and use (data, ) instead of (data:NSData,): \n```swift\nopen static func getData() -> Promise<[Station]> {\n  return URLSession1.GET(\"http://api.xxx.com/api/\").asDataAndResponse().then { (data, _) -> [Station] in\n var stations = [Station]()\n // rest of the code to retrieve the data\n ...\n ...\nreturn stations\n\n}\n}\n```\nSome helpful StackOverflow links:\nhttp://stackoverflow.com/questions/32905874/nsurlsession-datataskforrequestcompletion-unrecognized-selector-sent-to-instan\n. ",
    "johneke": "This might be a stupid question but I cannot find 3.2.1 in cocoa pods. cocoapods.org Says the latest version is 3.4.0 but when I do a pod search PromiseKit I only see version 3.1.1 as the latest\nNot sure what I am missing :/\n. @esteluk I knew it was a stupid question!! Thanks a lot, that worked! \ud83d\udc4d \n. Thanks for the speedy response @mxcl! I was able to fix the issue by taking out all spots where I had #import \"AnyPromise.h\" and replacing them with @import PromiseKit;\nThat fixed it! Error was super weird though. Sorry for the bother! Hopefully this helps someone else in the future\n. ",
    "MatteoManni": "There is now a partial explanation for this (see linked StackOverflow question): it seems to be an overload resolution / type inference issue in the AnyPromise'd Obj-C implementation of those systems. Using the Swift version and fully specifying the return type seems to make it work. Leaving it open in any case for further investigation (resolution and/or documentation).\n. ",
    "LBPPlayer7": "Lol issue #420 lol.\n. ",
    "juanjo-ramos": "I don't want to create a deadlock, just to resolve 2 promises synchronously and on the same thread. So, when calling addObject the method doesn't return until both the promises in the firstly and then clauses have been resolved.\n. ",
    "Lidbetter": "@mxcl I have a similar need for a method in swift to block/wait for a promise to resolve...\nI have a small library which expects data to take a while to build (or be retrieved over the network) and as such, ensures it is not being run on the main thread, it looks something like:\nfunc load() {\n    ...\n    dispatch_async {\n        data = self.closure()\n        // do something with data\n    }\n}\nCurrently all of my API calls are promises, so I would like to run my regular api calls inside the closure and wait for the results, then return them.\nIs there anyway this can be achieved?\n. Thanks! Thats perfect for my usecase.\n. ",
    "cloutiertyler": "Understandable, thanks anyway!\n. @warpling That is certainly possible. I was working off of a Swift 3.0 development branch prior to the Preview 1 release. I would be willing to work on a Swift 3.0 transition if I can steal away some time.\n. @mxcl Do you happen to know if a bug was ever filed with Swift?. ",
    "yannickl": "Sorry, here is a link to an example (this is more explicit): https://github.com/yannickl/AwaitKit/blob/d648e7d840546d99157727b7f85f1cb5b0f1f219/Sources/AwaitKit.swift#L54\nMy library uses your PromiseKit as promise implementation. As you can see I need to block the main thread with a semaphore. So if an error occurred, I need to notify the semaphore.\nI could update the PMKDefaultDispatchQueue but if the user also modify it on his own side (with the main queue), it can alter my library behaviour and entered in a deadlock.\n. Yes, of course, I would like to have this feature before the release of PMK4 to be able to release my library.\nI'll send you a pull request with an errorOnQueue() method to not break the compilation for Swift 2.x users.\nThank you!\n. I just updated the pull request. I hope it'll be ok for you.\n. Forget what I'll told. After a pod repo update everything is good! Sorry for the inconvenience.\n. ",
    "matteonovelli": "I'm using Xcode 7.3 and PromiseKit v 1.7 installed via cocoapods 1.0\nErrors occur only when I try to compile on release.\n- ERROR | xcodebuild: ../Release-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/PromiseKit.h:44:9: error: 'NSNotificationCenter+PromiseKit.h' file not found with <angled> include; use \"quotes\" instead\n- ERROR | xcodebuild: ../Release-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/PromiseKit.h:50:9: error: 'NSURLConnection+PromiseKit.h' file not found with <angled> include; use \"quotes\" instead\n- ERROR | xcodebuild: ../Release-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/PromiseKit.h:59:9: error: 'UIActionSheet+PromiseKit.h' file not found with <angled> include; use \"quotes\" instead\n- ERROR | xcodebuild: ../Release-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/PromiseKit.h:62:9: error: 'UIAlertView+PromiseKit.h' file not found with <angled> include; use \"quotes\" instead\n- ERROR | xcodebuild: ../Release-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/PromiseKit.h:65:9: error: 'UIView+PromiseKit.h' file not found with <angled> include; use \"quotes\" instead\n- ERROR | xcodebuild: ../Release-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/PromiseKit.h:68:9: error: 'UIViewController+PromiseKit.h' file not found with <angled> include; use \"quotes\" instead\nHere is my podfile:\n```\ntarget 'OMApi' do\npod 'AFNetworking', '2.6.0'\npod 'AFNetworkActivityLogger', '2.0.4'\npod 'PromiseKit', '~> 1.0'\npod 'JSONModel', '~> 1.0'\n\nend\n```\nThanks!\n. I'm running pod spec lint\n. Thanks!\n. ",
    "ManueGE": "In case anyone is still interested, I fixed the issue by adding this lines in the bottom of my Podfile: \nruby\npost_install do |installer|\n    `find Pods -regex 'Pods/PromiseKit/objc/PromiseKit.h' -print0 | xargs -0 sed -i '' 's/\\\\(<\\\\)\\\\(.*\\\\)\\\\(>\\\\)/\\\\\"\\\\2\\\\\"/'`\nend\n. ",
    "KTachyon": "It seems that this has something to do with NSURLConnection deprecations. I ended up creating a NSURLSession category that is pretty similar to the current NSURLConnection+AnyPromise implementation (attached).\nNSURLSession+AnyPromise.zip\n. > Can you elaborate?\nsendAsynchronousRequest:queue:completionHandler: was deprecated on iOS 9.\n\nIf there is no key, then there was no NSURLResponse generated by the underlying sendAsynchronousRequest:queue:completionHandler: call on NSURLConnection. I'm not sure why this would happen, but you could set a breakpoint on line 91 of NSURLConnection+AnyPromise.m to verify.\n\nI'm not sure what you mean with \"If there is no key\", but the rsp (line 91) is nil.\n. Ok, but my problem is that there is a response. I'm returning a 401 status code from the REST API. I can get it with curl -v:\n< HTTP/1.1 401 Unauthorized\nIt works as expected if I use NSURLSession instead.\n. I'm having the same issue on iOS 8.4 Simulator (besides 9.0 through 9.3). Code sample:\n```\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://apps.testinsane.com/rte/401\"]\n                                                       cachePolicy:NSURLRequestReloadIgnoringCacheData\n                                                   timeoutInterval:60.0];\n[NSURLConnection promise:request].catch(^(NSError *error) {\n    NSLog(@\"%@\", error.userInfo[PMKURLErrorFailingURLResponseKey]);\n});\n```\nThis is printing (null), but if I run curl http://apps.testinsane.com/rte/401 -v, I get this:\n```\n   Trying 143.95.247.15...\n Connected to apps.testinsane.com (143.95.247.15) port 80 (#0)\n\nGET /rte/401 HTTP/1.1\nHost: apps.testinsane.com\nUser-Agent: curl/7.43.0\nAccept: /\n< HTTP/1.1 401 Unauthorized\n< Cache-Control: no-cache\n< Pragma: no-cache\n< Expires: -1\n< Server: Microsoft-IIS/8.0\n< X-AspNet-Version: 4.0.30319\n< Date: Wed, 01 Jun 2016 10:46:11 GMT\n< Content-Length: 0\n< \n* Connection #0 to host apps.testinsane.com left intact\n```\n\nIt also works as expected if I use NSURLSession. If I add the promise categories I have posted before, I'm getting the correct behaviour:\n```\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://apps.testinsane.com/rte/401\"]\n                                                       cachePolicy:NSURLRequestReloadIgnoringCacheData\n                                                   timeoutInterval:60.0];\n[NSURLConnection promise:request].catch(^(NSError *error) {\n    NSLog(@\"NSURLConnection: %@\", error.userInfo[PMKURLErrorFailingURLResponseKey]);\n});\n[NSURLSession promise:request].catch(^(NSError *error) {\n    NSLog(@\"NSURLSession: %@\", error.userInfo[PMKURLErrorFailingURLResponseKey]);\n});\n```\nResult:\n2016-06-01 11:53:35.282 SamplePMKBugProject[6429:4127293] NSURLSession: <NSHTTPURLResponse: 0x7a21df80> { URL: http://apps.testinsane.com/rte/401 } { status code: 401, headers {\n    \"Cache-Control\" = \"no-cache\";\n    \"Content-Length\" = 0;\n    Date = \"Wed, 01 Jun 2016 10:54:34 GMT\";\n    Expires = \"-1\";\n    Pragma = \"no-cache\";\n    Server = \"Microsoft-IIS/8.0\";\n    \"X-AspNet-Version\" = \"4.0.30319\";\n} }\n2016-06-01 11:53:35.284 SamplePMKBugProject[6429:4127293] NSURLConnection: (null)\nI'm using XCode 7.3.1 (7D1014). Sample project attached. \nSamplePMKBugProject.zip\n. ",
    "jacobwallstrom": "I'm using Xcode 7.3 (7D175).\nWhen thinking some more about this I realize that the calling site is expecting Promise<Void> but the join is returning Promise<[Void]>. So a workaround is to at the call site do join(promises).then { _ -> Void in }\nSo this could be seen as a convenience for void promises since an array of voids are equivalent to just void.\n. ",
    "PocketPro": "Here you go: TrapTapLogger  2016-06-06, 3-08 PM.txt\nMy apologies for not giving you a fully symbolicated crash report, not all dependencies play nicely with post processing, bitcode, swift, etc. \n. ",
    "shergin": "Let's assume that we have a number of items (or stream of items) that we have to process. And we have promise-fabric that can process this type of items.\nUsually we can use when() function, like this\n```\nfunc processor(item: Item) -> Promise {\n    return Promise { ... }\n}\nlet items: [Item] = [....]\nwhen(items.map { processor($0) }).then { processedItems in\n    // Done!\n}\n```\nThat really great but... I know that I have system resources that allow me process only 3 items in parallel (otherwise iOS will kill my app under memory pressure).\nSo I decided to use pattern that very common (kind of) in front-end-promise-world: promise queue.\nIt can be done like this:\n```\nfunc processor(item: Item) -> Promise {\n    return Promise { ... }\n}\nlet items: [Item] = [....]\nlet queue = PromiseQueue(maxConcurrent: 5, maxQueue: 100)\nfor item in items {\n    queue.add(processor(item))\n}\nqueue.resultPromise.then { processedItems in\n   // Done!!\n}\n```\nDisclaimer: I am aware of how GCD's queues work, I believe it cannot be done thought this kind of queues.\nMy question actually is: Dear mxcl, as maitainter, do you think that such kind of (more high-level) functionality has to be in (pretty low-level, which I really love) library like PromiseKit or not?\nPS: This pattern also is very useful with UI/UX programming when we need to deal with some user input but we can throttle some of pieces of user input.\n. I believe, we actually cannot use/extend when because it accepts promises, so if we already have the promises, it immediately means that they already started resolving process (but we want to postpone it).\nmaxQueue parameter can be useful in UI programming when we are implementing something like asynchronous throttling. I have used it.\nLet's assume that we have some process that takes a second, and it has a visual effect (animation). When the user presses some button we perform the effect. So we put these processes into promise queue. And now the user starts clicking that button very fast (with semantic \"show me next result\"). So with parameters (concurrently: 1, maxQueue: 1) we can easily skip some internal animations.\nMy fast, simplified and buggy proof-of-consept implementation: \n```\nfunc applyPromise(items: [T], task: (T -> Promise), numberOfQueues: Int = 1) -> Promise<[U]> {\nreturn Promise<[U]> { fulfil, reject in\n    var processed = 0\n    var index = 0\n\n    var results: [U] = []\n\n    func block() {\n        while index < items.count && (index - processed) < numberOfQueues {\n            let promise = task(items[index])\n\n            index += 1\n\n            promise\n                .recover { error -> Promise<U> in\n                    reject(error)\n                    return Promise(error: error)\n                }\n                .then { result -> Void in\n                    processed += 1\n                    results.append(result)\n                    block()\n                }\n        }\n\n        if processed == items.count {\n            fulfil(results)\n        }\n    }\n\n    block()\n}\n\n}\n``\n. And the syntax with dedicated objectqueue` allows working with streams of objects.\nOh, my syntax introduced in second comment is wrong! There is no resultPromise; every call of add() should return new promise (like in mentioned npm library).\nThat's really tricky. )\n. Should I do real implementation and pull-request?\n. Let's discuss the first approach. )\nhttps://github.com/mxcl/PromiseKit/pull/445\n(Of course, I will add tests later.)\n. Hey Nathan,\nThis is actually my production code.\nI will definitely add tests after we will conceptually agree about entire API. I just don't want to rewrite these tests. )\nThank you!\n. That's would be awesome! I will add the tests soon... I hope.\n. I just realised that signature of when function can be\npublic func when<T, PromiseGenerator: GeneratorType where PromiseGenerator.Element == Promise<T> >(promises: PromiseGenerator, maxPendingPromises: Int = 1) -> Promise<[T]> { ... } which  looks pretty awesome to me.\n. Nathan, Max, you are awesome.\nI love to have discussion with you about one of my favorite themes. Actually two of them Swift and Promises. )\nI absolutely agree that the library should be solid and just right amount of functionality. Or be more modular, so we can have additional module like \"Operations\" witch can contain set of complicated functionality like queues, barriers, and so on.\nI have implemented another approach in PR #449, so: \n- This implementation is much more simpler and I believe more fit to existing PromiseKit API.\n- It is using generators instead of blocks which I found more conceptual and swift-idiomatic.\n- I have tried to use zalgo but... to be honest I don't understand this (zalgo-waldo) concept very well yet.\n- I will add more tests little bit later.\n- I get fid of maxQueue parameter because it doesn't fit to new approach at all.\n. Guys,\nWhat do you think about the second (#449) approach?\n. Cool!\nSo, I will add some more tests and we good to go (merge)?\n. I have just added several tests for it.\nWhat do you think?\n. Ough! Thanks! But I thought it is not finished yet. ) I am on vacation right now so I have not time to work on it. Sorry.\nI have a fix for the crash that was shown on screenshot and I would love to discuss about thread-safety. I will open new PR for that. )\nPS:\nMax, nice avatar!\n. @mxcl Awesome! Your approach is much better! Thank you, Max!\n. Yeah, in terms of #449 it would be:\nwhen(\n    AnyGenerator<Promise<Void>> {\n        return thereIsEnoughItemsLoaded ? nil : after(0.1)\n    }\n)\n.then { _ -> Void in\n    // ..\n}\n. I just realized that probably I should not do it because standard library should (aggressively enough) extend capacity automatically.\n. ",
    "baltameme": "Yes it's the same case with the same Xcode version...\n. ",
    "seriyvolk83": "It still exists. If promise is not assigned to any variable then there is a change that it will be deallocated. However, sometimes the Promise object is not needed. Not sure why it is deallocated.. @mxcl It's not the case. The initial promise was not saved into a variable and as a result the sequence of promises was interrupted due to deallocation because no object is pointing to the initial promise.. ",
    "GertjanSmits": "I also get this, any known workaround for it? Kinda new to it all, not sure which one is deallocated, im chaining 3 promises.. You're right, 1 of of my promises had a state heen it never called fulfilled/reject. Thanks!. ",
    "NikKovIos": "In my case it was, when i used PromiseKit.wrap {} on function, which returned nothing.\nAnd don't forget to fulfill promises =). I've already tried this and it didn't help:\n\n. typedef void (^TWTRRequestEmailCompletion)(NSString *_Nullable email, NSError *_Nullable error);\nNow i did rewrite to \nswift\n    private func getEmail() -> Promise<String> {\n        return Promise { fulfill, reject in\n            let client = TWTRAPIClient.withCurrentUser()\n            client.requestEmail(forCurrentUser: { email, error in\n                if let error = error { reject(error) }\n                if let email = email { fulfill(email) }\n            })\n        }\n    }\nbut it's easier to use wrap\n. I don't mind. Perhaps it relying to Swift 4.1, because in Swift 4.0 there wasn't such the error. . ",
    "besi": "This is the verbose output when I run:\nset -o pipefail && xcodebuild -workspace ./MyApp.xcworkspace -scheme MyApp -destination 'generic/platform=iOS' -archivePath '/Users/me/Library/Developer/Xcode/Archives/2016-06-14/MyApp 2016-06-14 00.05.57.xcarchive' archive | tee /Users/me/Library/Logs/gym/MyApp-MyApp.log\nbash\nCompileSwift normal arm64 /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSNotificationCenter+Promise.swift\n    cd /Projects/MyApp/Pods\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Projects/MyApp/Pods/PromiseKit/Sources/after.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/afterlife.swift /Projects/MyApp/Pods/PromiseKit/Sources/AnyPromise.swift /Projects/MyApp/Pods/PromiseKit/Sources/dispatch_promise.swift /Projects/MyApp/Pods/PromiseKit/Sources/Error.swift /Projects/MyApp/Pods/PromiseKit/Sources/join.swift -primary-file /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSNotificationCenter+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSObject+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSURLConnection+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSURLSession+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/PMKAlertController.swift /Projects/MyApp/Pods/PromiseKit/Sources/Promise+Properties.swift /Projects/MyApp/Pods/PromiseKit/Sources/Promise.swift /Projects/MyApp/Pods/PromiseKit/Sources/race.swift /Projects/MyApp/Pods/PromiseKit/Sources/State.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIActionSheet+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIAlertView+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIView+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIViewController+Promise.swift /Projects/MyApp/Pods/PromiseKit/Sources/URLDataPromise.swift /Projects/MyApp/Pods/PromiseKit/Sources/when.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk -I /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/PromiseKit -F /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/PromiseKit -F /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/OMGHTTPURLRQ -g -import-underlying-module -module-cache-path /Users/me/Library/Developer/Xcode/DerivedData/ModuleCache -D COCOAPODS -serialize-debugging-options -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-generated-files.hmap -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-own-target-headers.hmap -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-project-headers.hmap -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/PromiseKit/include -Xcc -I/Projects/MyApp/Pods/Headers/Private -Xcc -I/Projects/MyApp/Pods/Headers/Public -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/DerivedSources/arm64 -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/DerivedSources -Xcc -DPOD_CONFIGURATION_RELEASE=1 -Xcc -DCOCOAPODS=1 -Xcc -working-directory/Projects/MyApp/Pods -emit-module-doc-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise~partial.swiftdoc -O -module-name PromiseKit -emit-module-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise~partial.swiftmodule -serialize-diagnostics-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise.dia -emit-dependencies-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise.d -o /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise.bc\n0  swift                    0x0000000103afc66b llvm::sys::PrintStackTrace(llvm::raw_ostream&) + 43\n1  swift                    0x0000000103afb956 llvm::sys::RunSignalHandlers() + 70\n2  swift                    0x0000000103afcccf SignalHandler(int) + 287\n3  libsystem_platform.dylib 0x00007fff8772a52a _sigtramp + 26\n4  libsystem_platform.dylib 0x00000000000003fd _sigtramp + 2022530797\n5  swift                    0x000000010199816d emitApplyArgument((anonymous namespace)::IRGenSILFunction&, swift::SILValue, swift::SILParameterInfo, swift::irgen::Explosion&) + 365\n6  swift                    0x0000000101997971 (anonymous namespace)::IRGenSILFunction::visitFullApplySite(swift::FullApplySite) + 2497\n7  swift                    0x000000010198523b swift::irgen::IRGenModule::emitSILFunction(swift::SILFunction*) + 9787\n8  swift                    0x00000001018e05c8 swift::irgen::IRGenModuleDispatcher::emitGlobalTopLevel() + 600\n9  swift                    0x000000010196c04e performIRGeneration(swift::IRGenOptions&, swift::ModuleDecl*, swift::SILModule*, llvm::StringRef, llvm::LLVMContext&, swift::SourceFile*, unsigned int) + 1278\n10 swift                    0x000000010196c4f6 swift::performIRGeneration(swift::IRGenOptions&, swift::SourceFile&, swift::SILModule*, llvm::StringRef, llvm::LLVMContext&, unsigned int) + 70\n11 swift                    0x000000010184fc8c performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef<char const*>, int&) + 15004\n12 swift                    0x000000010184b68d frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 2781\n13 swift                    0x00000001018470ac main + 1932\n14 libdyld.dylib            0x00007fff8802c5ad start + 1\nStack dump:\n0.  Program arguments: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Projects/MyApp/Pods/PromiseKit/Sources/after.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/afterlife.swift /Projects/MyApp/Pods/PromiseKit/Sources/AnyPromise.swift /Projects/MyApp/Pods/PromiseKit/Sources/dispatch_promise.swift /Projects/MyApp/Pods/PromiseKit/Sources/Error.swift /Projects/MyApp/Pods/PromiseKit/Sources/join.swift -primary-file /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSNotificationCenter+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSObject+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSURLConnection+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSURLSession+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/PMKAlertController.swift /Projects/MyApp/Pods/PromiseKit/Sources/Promise+Properties.swift /Projects/MyApp/Pods/PromiseKit/Sources/Promise.swift /Projects/MyApp/Pods/PromiseKit/Sources/race.swift /Projects/MyApp/Pods/PromiseKit/Sources/State.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIActionSheet+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIAlertView+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIView+Promise.swift /Projects/MyApp/Pods/PromiseKit/Categories/UIKit/UIViewController+Promise.swift /Projects/MyApp/Pods/PromiseKit/Sources/URLDataPromise.swift /Projects/MyApp/Pods/PromiseKit/Sources/when.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk -I /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/PromiseKit -F /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/PromiseKit -F /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/OMGHTTPURLRQ -g -import-underlying-module -module-cache-path /Users/me/Library/Developer/Xcode/DerivedData/ModuleCache -D COCOAPODS -serialize-debugging-options -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-generated-files.hmap -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-own-target-headers.hmap -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/PromiseKit-project-headers.hmap -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/BuildProductsPath/Release-iphoneos/PromiseKit/include -Xcc -I/Projects/MyApp/Pods/Headers/Private -Xcc -I/Projects/MyApp/Pods/Headers/Public -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/DerivedSources/arm64 -Xcc -I/Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/DerivedSources -Xcc -DPOD_CONFIGURATION_RELEASE=1 -Xcc -DCOCOAPODS=1 -Xcc -working-directory/Projects/MyApp/Pods -emit-module-doc-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise~partial.swiftdoc -O -module-name PromiseKit -emit-module-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise~partial.swiftmodule -serialize-diagnostics-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise.dia -emit-dependencies-path /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise.d -o /Users/me/Library/Developer/Xcode/DerivedData/MyApp-akhhtogptxupztdlflwbeyhxnsje/Build/Intermediates/ArchiveIntermediates/MyApp/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/PromiseKit.build/Objects-normal/arm64/NSNotificationCenter+Promise.bc \n1.  While emitting IR SIL function @_TZFE10PromiseKitCSo20NSNotificationCenter4oncefSSCS_19NotificationPromise for 'once' at /Projects/MyApp/Pods/PromiseKit/Categories/Foundation/NSNotificationCenter+Promise.swift:22:12\n. dupe of https://github.com/mxcl/PromiseKit/issues/415\n. ",
    "nobre84": "Hey! This is a great under documented feature! Any reason why it isn't available for when(resolved:) as well ?. If your // do something has more then a single line, swift compiler is not smart enough to infer the closure return type, thus you need _ -> Void in. That's unfortunate.. ",
    "tcunning": "Looks like this is resolved in the latest\n. This issue only effects the swift implementation as the objective-c implementation shuts down the location manager after an error occurs.\n. ",
    "sryze": "Sorry for the dumb question, I haven't used PromiseKit in Swift yet, but is there any particular reason why the CorePromise module is not written in Objective-C for maximum compatibility, except strongly typed promises?\n. Nevermind, updated to PromiseKit 3.\n. Oops, sorry. Should be OK now.\n. Well, this is kind of complicated. There are a lot of promises involved in the chain, I highly doubt I will be able to give a minimal example code to demonstrate this.\nHowever, I think it might be related to my NSProxy subclass and the way it retains (or doesn't retain) promises. Here's what its main business looks like:\n``` objective-c\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    [invocation retainArguments];\n__unsafe_unretained AnyPromise *promise;\n[invocation invoke];\n[invocation getReturnValue:&promise];\n\nAnyPromise *newPromise = promise.catch(^id (NSError *error) {\n    // ... Return another promise or error here...\n}).then(^id (id result) {\n    NSManagedObjectContext *context = [NSManagedObjectContext MR_defaultContext];\n    if (!context.hasChanges) {\n        return result;\n    }\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n        [context MR_saveToPersistentStoreWithCompletion:^(BOOL contextDidSave, NSError *error) {\n            if (error != nil) {\n                resolve(error);\n            } else {\n                resolve(result); // <-- appears in call stack\n            }\n        }];\n    }];\n});\n\n[invocation setReturnValue:&newPromise];\n\n}\n```\nThe purpose of this proxy is to forward the method call to one of two objects that implement the same protocol based on a certain condition (availability of internet connection).\nDo you see anything obviously wrong / possibly problematic here?\n. Forgot to mention: I spotted this error in a totally different place on iOS 9 too (which happens to use PMKWhen as well), it may be not OS version specific after all. \nI'll try downgrading to PromiseKit 1 and see what happens. I'll let you know what I find.\n. Thanks for the reply. I replaced PromiseKit 3 with 1.7 a couple of days ago and it's been working great so far. I think I'll close this for now.\n. Does PromiseKit support Objective-C++? I've discovered that the only file that was producing these errors was a .mm file I added yesterday that imported PromiseKit.. I think you're right, it's probably a bug in Swift compiler/runtime. Nevertheless, I gathered a little more info, perhaps it could be helpful.\nI've noticed that this only happened when I profiled the app with Instruments, specifically with the Allocations instrument (and those crashes I mentioned were from my profiling sessions actually). I could even reproduce it on a simulator - iPad 2 iOS 9.3, same as the device. But not on an iOS 11.0 simulator.\nYou can download a sample project that I created here:\nhttps://github.com/sryze/PromiseKitCrash\nIt simply makes a new promise that returns a string:\nobjective-c\n    [AnyPromise promiseWithAdapterBlock:^(PMKAdapter adapter) {\n        adapter(@\"Hello World\", nil);\n    }].then(^(NSString *string) {\n        NSLog(@\"%@\", string);\n    }).catch(^(NSError *error) {\n        NSLog(@\"%@\", error);\n    });\nI didn't know how to capture a stack trace while profiling so I hooked it to Crashlytics to get a crash report (it's already set up in the sample project, you'll just need to supply your own keys).\nCrashed: com.apple.main-thread\n0  libswiftCore.dylib             0x31356c9 swift_retainCount + 9\n1  libsystem_pthread.dylib        0x2b179ba pthread_setspecific + 26\n2  liboainject.dylib              0xcffeb oa_swift_retain + 341\n3  libswiftDispatch.dylib         0x34fb426 specialized String.utf8CString.getter + 54\n4  libswiftDispatch.dylib         0x34ff1dc specialized DispatchQueue.init(label:qos:attributes:autoreleaseFrequency:target:) + 524\n5  libswiftDispatch.dylib         0x34f6c6b DispatchQueue.init(label:qos:attributes:autoreleaseFrequency:target:) + 75\n6  PromiseKit                     0x2a579d specialized static AnyPromise.promiseWithResolverBlock(_:) (State.swift:85)\n7  PromiseKit                     0x2a3735 @objc static AnyPromise.promiseWithResolverBlock(_:) (AnyPromise.swift)\n8  PromiseKit                     0x294903 +[AnyPromise(Adapters) promiseWithAdapterBlock:] (AnyPromise.m:100)\n9  PromiseKitCrash                0x1499d -[AppDelegate application:didFinishLaunchingWithOptions:] (AppDelegate.m:19)\n10 UIKit                          0x4d018c -[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 337\n11 UIKit                          0x4d16a8 -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 3863\n12 UIKit                          0x4d8f0f -[UIApplication _runWithMainScene:transitionContext:completion:] + 2010\n13 UIKit                          0x4feb2c __84-[UIApplication _handleApplicationActivationWithScene:transitionContext:completion:]_block_invoke3246 + 68\n14 UIKit                          0x4d5b8a -[UIApplication workspaceDidEndTransaction:] + 163\n15 FrontBoardServices             0x7356110 __37-[FBSWorkspace clientEndTransaction:]_block_invoke_2 + 71\n16 FrontBoardServices             0x7355be7 __40-[FBSWorkspace _performDelegateCallOut:]_block_invoke + 54\n17 FrontBoardServices             0x737327f __FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 23\n18 FrontBoardServices             0x73730ab -[FBSSerialQueue _performNext] + 174\n19 FrontBoardServices             0x73734fa -[FBSSerialQueue _performNextFromRunLoopSource] + 52\n20 FrontBoardServices             0x73727e8 FBSSerialQueueRunLoopSourceHandler + 33\n21 CoreFoundation                 0x22a7e5f __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 15\n22 CoreFoundation                 0x229daeb __CFRunLoopDoSources0 + 523\n23 CoreFoundation                 0x229cf08 __CFRunLoopRun + 1032\n24 CoreFoundation                 0x229c846 CFRunLoopRunSpecific + 470\n25 CoreFoundation                 0x229c65b CFRunLoopRunInMode + 123\n26 UIKit                          0x4d52da -[UIApplication _run] + 540\n27 UIKit                          0x4daeb9 UIApplicationMain + 160\n28 PromiseKitCrash                0x148cd main (main.m:14)\n29 libdyld.dylib                  0x2814a25 start + 1\n. ",
    "dwabyick": "Thanks for the quick response. \nYes, it sounds like they changed the API in Cocoapods 1.0 - I get [!] The dependencyPromiseKitis not used in any concrete target.  Appears to be a new requirement.\nWhen I did add a target, I got the following warning:\npromisetest$ pod install\nAnalyzing dependencies\nDownloading dependencies\nInstalling OMGHTTPURLRQ (3.1.2)\nInstalling PromiseKit (3.2.0)\n[!] Pods written in Swift can only be integrated as frameworks; add `use_frameworks!` to your Podfile or target to opt into using it. The Swift Pod being used is: PromiseKit\nAnd then it didn't create a workspace project. As a sanity check, I tried with AFNetworking and things installed and created a project. This appeared to also work with PromiseKit 1.X, but I'd prefer to use the latest.  \nFYI, when I tried adding use_frameworks! it generated a project file, but opening the projectfile didn't appear to expose any Obj/C headers.  \nOne caveat to all of this - I do have XCode 8.0 beta installed on my system. However I was opening and testing with XCode 7.3.1. Since AFNetworking was ok, this makes me think this is a non-issue.\n. One other point of clarification, this project was created using one of the iOS application templates using Obj/C for a primary language.\n. Ok!  actually, turns out that use_frameworks! did solve my problem.  \nI didn't think I was getting Obj/C headers as the example I was using in Sealing Your Promises was using [PKMPromise promiseWithResolverBlock] syntax and not the newer [AnyPromise promiseWithResolverBlock]\nhttp://promisekit.org/sealing-your-own-promises/\n. I think it was a combination of the install issue I was having, combined with the  PromiseKit 3.0  paragraph only mentioning Swift. I am glad I was mistaken.\nBtw - Thanks for making such a great library! Time to unravel some existing code. ;)\n\nOn Jun 26, 2016, at 8:42 AM, Max Howell notifications@github.com wrote:\nWhat confused you as to thinking PMK3 is just Swift?\n2nd paragraph in README is:\nPromiseKit is a thoughtful and complete implementation of promises for iOS and OS X with first-class support for both Objective-C and Swift.\nSo presumably some other part made you think this didn't apply to version 3?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. So to close the loop I think there are two things to update.\n1. Updating the example of Cocoapods to something like: \n- pod init - This creates the file with a target for your project\n- Add the following \n\ntarget '<yourprojectname>' do\n   use_frameworks!\n   pod \"PromiseKit\"\nend\n1. Updating http://promisekit.org/sealing-your-own-promises/ to [AnyPromise promiseWithResolverBlock] ...\n. @nathanhosselton - I was looking to see where the promisekit.org site lived, and I didn't see it in this repos - Did I miss it?  Happy to put in a PR for these two things. \n. ",
    "kwstasna": "Is there any example in your files?\n. ",
    "zachbai": "thanks- this resolved my issue; didn't realize I had to definitely use then to first return a Promise from the AnyPromise.\n. ",
    "SebastianBoldt": "Yes, it would be great if you could extend you documentation to include this technique. I will close this issue for now. Thanks for that fast feedback. Have a nice day ..\n. Awesome, thank you. \n. ",
    "carayolthomas": "Thanks for the tip, I was facing this problem when I was trying to:\nfirstly. Update the user profile\nthen. Upload the user profile picture\nthen. Upload user id documents\nAnd in thedone, I wanted to have the response of the user profile update request.. ",
    "cyrille-legrand": "Much better now, thanks.\nTwo errors remain, though:\nPromiseKit/Categories/UIKit/UIViewController+Promise.swift:34:36: Missing argument for parameter 'animated' in call\nPromiseKit/Categories/UIKit/UIViewController+Promise.swift:47:40: Missing argument for parameter 'animated' in call\nThey're the same, on\nlet p: Promise<T> = promise(vc)\n. ",
    "Gerst20051": "Same Here @cyrille-legrand Screenshot Attached\n\n. I don't know if it still works as expected or if this is even a good solution but I got rid of the error by changing the line:\nlet p: Promise<T> = promise(vc)\nto:\nlet p: Promise<T> = promise(vc, animated: false, completion: nil) as! Promise<T>\n. PATCH should be lowercase as well as JSON.\n. Here is a screenshot of the remaining errors.\n\n. Resolved them by adding as URLRequest.\n```\n    public class func PUT(_ URL: String, JSON: NSDictionary? = nil) -> URLDataPromise {\n        return start(try OMGHTTPURLRQ.put(URL, json: JSON) as URLRequest)\n    }\npublic class func PATCH(URL: String, JSON: NSDictionary) -> URLDataPromise {\n    return start(try OMGHTTPURLRQ.patch(URL, json: JSON) as URLRequest)\n}\n\n```\n. I am using CocoaPods.\npod 'PromiseKit', :git => 'https://github.com/mxcl/PromiseKit.git', :branch => 'swift-3.0'\n. ",
    "simonnarang": "Solved\n\nI just dragged in the xcodeproj and then the framework showed up \ud83d\ude02\n. I am still unable to import\n.  \n. \nSorry to bother you again but I have done this and it still won't import\n. I am using the Swift-3.0 branch if that helps\nAlso, as I specified in the 2nd comment of this thread I didn't use Carthage to import because it would fail, instead I just dragged in the xcodeproj\n. I put only github \"mxcl/PromiseKit\" \"swift-3.0\" into my cartfile and ran carthage bootstrap\nUnfortunately I still get the error:\n** BUILD FAILED **\nThe following build commands failed:\n    CompileSwift normal x86_64\n    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler\n(2 failures)\nHere are some of the errors:\n/Carthage/Checkouts/PromiseKit/Sources/URLDataPromise.swift:60:119: error: variable binding in a condition requires an initializer\n/Carthage/Checkouts/PromiseKit/Sources/URLDataPromise.swift:62:38: error: boolean condition requires 'where' to separate it from variable binding\n/Carthage/Checkouts/PromiseKit/Sources/Zalgo.swift:69:46: error: function produces expected type 'Bool'; did you mean to call it with '()'?\n. Ok thanks\n. @mxcl I am not a collaborator so I cannot re-open issues\n. @mxcl, I am okay not using Carthage, originally I just dragged in the xcodeproj and imported the framework to the embedded binaries, but I am still wondering why I cannot import PromiseKit in my .swift files.\nThanks for the help!\n. By the new method after adding the framework to embedded binaries I get the error clang: error: no such file or directory: '/Users/Si/Library/Developer/Xcode/DerivedData/Toast-gezugqvyoyexybguzmdcmqmarefs/Build/Products/Debug-iphonesimulator/PromiseKit.framework/PromiseKit'\n. @Gerst20051 I am still unable to import PromiseKit to my project, how did you do it?\n. @mxcl I switched over to cocoapods: /Users/Si/Library/Developer/Xcode/DerivedData/Toast-gezugqvyoyexybguzmdcmqmarefs/Build/Products/Debug-iphonesimulator/Toast.app/Frameworks/OMGHTTPURLRQ.framework: No such file or directory\n. But I get that error @mxcl\n. ### Solved\n\nI wasn't using the xcworkspace\n. @mxcl I am\n. Oops I was using old beta\n. ### Solved\n\njust do \nswift\n.then { promiseOutput in\ncode\n}\n. I just did \n``` swift\n}.then { itemGuids -> Promise in\n                                    return Promise { fulfill, reject in\n\n                                        if let menuGroupName = menuGroup[\"name\"].string, let menuGroupGuid = menuGroup[\"guid\"].string {\n\n                                            menuGroups.append(MenuGroup(name: menuGroupName, image: menuGroupName, guid: menuGroupGuid, itemGuids: itemGuids as! [String]))\n\n                                            print(\"lalau: \\(menuGroups)\")\n                                        }\n                                    }\n                                }\n\n```\n. sorry about lack of response thank you so much\n. ",
    "JeanAzzopardi": "I'm having the same issue.\nI checked in the logs, I think the issue could lie in the PMKiOSUITestsHost:\nUndefined symbols for architecture armv7:\n  \"type metadata for (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions\", referenced from:\n      protocol witness for Swift.SetAlgebraType.init <A where A1: Swift.SequenceType, A.Element == A1.Generator.Element> (A1) -> A in conformance (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions : Swift.SetAlgebraType in PMKiOSUITestsHost in app.o\n      protocol witness for Swift.ArrayLiteralConvertible.init (arrayLiteral : [A.Element]...) -> A in conformance (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions : Swift.ArrayLiteralConvertible in PMKiOSUITestsHost in app.o\n      (extension in PMKiOSUITestsHost):__ObjC.UIViewController.(promiseViewController <A> (__ObjC.UIViewController, animate : (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions, fulfills : (extension in PMKiOSUITestsHost):__ObjC.UIViewController.FulfillmentType, completion : () -> ()?) -> PromiseKit.Promise<A>).(default argument 1) in app.o\n      function signature specialization <Arg[2] = Dead> of generic specialization <(extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions with (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions : Swift.SetAlgebraType in PMKiOSUITestsHost, (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions> of static (extension in Swift):Swift.SetAlgebraType.element (A.Element, subsumes : A.Element) -> Swift.Bool in app.o\n      function signature specialization <Arg[2] = Dead> of generic specialization <(extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions with (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions : Swift.SetAlgebraType in PMKiOSUITestsHost, (extension in PMKiOSUITestsHost):__ObjC.UIViewController.AnimationOptions> of static (extension in Swift):Swift.SetAlgebraType.element (A.Element, isDisjointWith : A.Element) -> Swift.Bool in app.o\n  \"type metadata for (extension in PMKiOSUITestsHost):__ObjC.SLComposeViewController.Error\", referenced from:\n      generic specialization <(extension in PMKiOSUITestsHost):__ObjC.SLComposeViewController.Error with (extension in PMKiOSUITestsHost):__ObjC.SLComposeViewController.Error : Swift.ErrorType in PMKiOSUITestsHost> of (extension in Swift):Swift.ErrorType._domain.getter : Swift.String in app.o\n  \"type metadata for (extension in PMKiOSUITestsHost):__ObjC.UIImagePickerController.Error\", referenced from:\n      generic specialization <(extension in PMKiOSUITestsHost):__ObjC.UIImagePickerController.Error with (extension in PMKiOSUITestsHost):__ObjC.UIImagePickerController.Error : Swift.ErrorType in PMKiOSUITestsHost> of (extension in Swift):Swift.ErrorType._domain.getter : Swift.String in app.o\n  \"type metadata for (extension in PMKiOSUITestsHost):__ObjC.UIViewController.Error\", referenced from:\n      generic specialization <(extension in PMKiOSUITestsHost):__ObjC.UIViewController.Error with (extension in PMKiOSUITestsHost):__ObjC.UIViewController.Error : Swift.ErrorType in PMKiOSUITestsHost> of (extension in Swift):Swift.ErrorType._domain.getter : Swift.String in app.o\nld: symbol(s) not found for architecture armv7\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. ",
    "aventurella": "This might seem like a silly thing, so I definitely want the critique if it is. Seems to me that mixing the 2 provides some benefit. I know from looking at my Rx code there tends to be a lot of chaining for different streams. Sometimes though it's nice to only surface up the:\n()\n.then{}\n.catch{}\nI know you can do the something similar with Rx and mixing things is including 2 libs that overlap in functionality. But if done in a disciplined way I think there are some benefits when viewing the code:\nRx\n```\nservice.register(for: registation)\n.subscribe(onNext: {\n    value in\n},\nonError: { err in\n})\n.addDisposableTo(disposeBag)\n```\nPromise\nservice.register(for: registation)\n.then(\n    value -> () in\n}\n.catch {\n    err in\n}\nI think the Promise handling looks cleaner at the call site than the Rx version. To be sure, behind the scenes the Promise could be totally coordinated by an Rx Pipeline and resolved or rejected via onNext onError of an Observable.  Maybe I'm crazy on this but aside from the added weight to the final distribution, why else am I crazy?\nObviously one of the downfalls of this is that you would get people mixing paradigms throughout a code base, which would definitely be bad. Again though, with a little discipline I think it's a problem that can be worked around.\nFor things like input validation etc, Rx will really shine by being exposed at the call site and provide the reader a nice way to capture what's happing to the data. On simple async calls though, I think the Promise provides a cleaner call site implementation.\nOf course I could just be holding it upside down and not even know it. I'm not SUPER 100% expert at the Rx paradigm\n. ",
    "codecov-io": "Current coverage is 52.94% (diff: 100%)\n\nMerging #489 into master will not change coverage\n\ndiff\n@@             master       #489   diff @@\n==========================================\n  Files           102        102          \n  Lines          3341       3341          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1769       1769          \n  Misses         1572       1572          \n  Partials          0          0\n\nPowered by Codecov. Last update df4f8e7...71ee218\n. ## Current coverage is 53.32% (diff: 100%)\nMerging #491 into master will not change coverage\n\ndiff\n@@             master       #491   diff @@\n==========================================\n  Files           102        102          \n  Lines          3173       3173          \n  Methods           0          0          \n  Messages          0          0          \n  Branches          0          0          \n==========================================\n  Hits           1692       1692          \n  Misses         1481       1481          \n  Partials          0          0\n\nPowered by Codecov. Last update 0013c98...f1d1283\n. \n",
    "FilipZawada": "I've spent some time to understand the problem better and these are workarounds I considered:\n1. Get the current queue and dispatch to it - fails since it's not possible in iOS. We only have a deprecated and unreliable dispatch_get_current_queue.\n2. Get current queue name - this way we can easily identify main queue, PMKDefaultQueue etc..., but we won't identify user created queues. Without having access to them, we can't dispatch there. However we could focus only on identifying a main queue so it works in majority of cases.\n3. We can try to defer then execution a bit (using asyncAfter) so it works in most cases, but not all cases. (This sounds like a very bad idea though)\n4. There is one workaround that is likely to work. It relies on a fact, that current dispatch queue is tied to a thread which we can access \n@inline(__always) func contain_zalgo(_ q: DispatchQueue, body: @escaping () -> Void) {\n       if q === zalgo || q === waldo && !Thread.isMainThread {\n           body()\n       } else {\n           let thread = Thread.current\n           let currentRunLoopCycle = thread.getCurrentRunLoopCycle // fictional method\n           q.async {\n               while thread.currentRunLoopCycle == currentRunLoopCycle {\n                   Thread.sleep(forTimeInterval: 0.1)\n               }\n               body()\n           }\n       }\n   }\nI think we could get currentRunLoopCycle somehow, however cost of that operation seems to be not worth the result I think.\n- Lastly - we can just document that fact and require user to use then(on q:...) parameter. I get that it's not satisfying though.\nIt all led me to the thinking that to solve that we need to fill a rdar :-)\nAlso I'm posting a test case I used for playing with that:\n```\n//PMKDefaultDispatchQueueTest.swift\n func testAlwaysWithDifferentQueue() {\n        var fulfilled = false\n        let testExpectation = expectation(description: \"resolving\")\n        Promise(value: 1).always {\n            XCTAssertFalse(Thread.isMainThread)\n        fulfilled = true\n        testExpectation.fulfill()\n    }\n\n    for _ in 1 ... 1_000_000_000 {\n        let _ = 0\n    }\n\n    XCTAssertFalse(fulfilled)\n\n    waitForExpectations(timeout: 1) { _ in\n        XCTAssertTrue(fulfilled)\n    }\n}\n\n```\nBTW, in what real-world scenario do you find a PMKDefaultDispatchQueue useful?\n. Correct, it should be additional returnOn: parameter or sth like that\n. > We cannot assume the caller knows what queue it is running on, just like we cannot determine what queue we are running on.\nTrue, that's why I said \"it's not satisfying too\". \n. (I don't know how could we cause a deadlock by passing a wrong queue though - we're not using dispatch.sync after all)\n. >  the only real option is to create an object and wait for it to be deallocated.\nHow do you want to achieve that?\nswift\n{\n  code...\n  Promise()\n  code...\n}\n// Promise() gets deallocated\nbut\nswift\n{\n  code...\n  promise = Promise()\n  code...\n}\n// promise is still in the memory. I have no idea how did you achieve that even within NSRunLoops \ud83e\udd14. For me since it's happening within promise, it's deallocated before returning to function that created promise.. >  so forgive me, but I'm not quite seeing how your example works.\nSorry, the example was broken, so I removed it before you posted an answer.\nRegarding your example, I can't make it to work too, but congrats on the idea anyway :) Will play with that again when I have more time.. If we assume there's no solution without changing syntax, then maybe worth using your solution (~50ms penalty in some cases) with slightly changed syntax? E.g. somePromise.deferred.then { ... }? (deferred would unlock your hack)\nStill way more convenient then asking user to write proper defer {...} statement. In docs we could describe potential perf penalty and show proper defer { ... } alternative for people interested in that.\n. Can you post an example of desired functionality please?\n. Cool, we'll have to add type declaration I guess:\nPromise(value: 0).then { _ -> (Promise<String>, Promise<String>) in\n    let foo = Promise(value: \"foo\")\n    let bar = Promise(value: \"bar\")\n    return (foo, bar)\n}.then { foo, bar -> Void in\n    print(foo + bar) // foobar\n}\nI'll try to have PR ready by tomorrow.\n. As a starting base I made a very minimalistic implementation.\nAnd now I wonder about few things:\n- I made a support only for 2 & 3-values tuples. I feel at least 5 values should be allowed, however as for now I wanted to be consistent with when.\n- I can't think about any way of allowing infinite number of promises in a tuple (except hacking with dangerous unsafeBitCast).\n- I haven't added tuples functionality to firstly, since firstly already doesn't match then functionality. I guess you kept it intentionally thin?\n- I haven't touched objc at all. Not even sure if there's anything to do on that side.\n- I've provided a very minimalistic set of tests. E.g. do you find a rejection test useful? (I can add it)\nWhat are your thoughts?\n. P.S. I will add a missing test case when one of returned promise is a self\n. PR: https://github.com/mxcl/PromiseKit/pull/593\n. @mxcl Any chances to look at that?. I also added support for firstly. Ah sorry :-) At least it'd be worth to re-work tests, so they don't spam with compiler warnings so much.. I like the idea of UnfailablePromise. I think we can make PromiseKit smart enough, that it analyzes whole chain and decides whether it may fail or not. It would follow simple rules when chaining:\ntext\nfailable + failable -> failable\nunfailable + failable -> failable\nfailable + unfailable -> failable\nunfailable + unfailable -> unfailable\nThe promise would become unfailable if:\n promise body not throws\n was constructed using an unfailable initializer like Promise { success: ()->Void in }\n* promise body returned an unfailable promise\nSo this chain would be unfailable:\n```swift\nfunc measureUserProgress(_ user: User, timespan: TimeInterval) -> \n    firstly { () -> Int           // user.getScore() doesn't throw, so this promise can't fail\n        return user.getScore()\n    }.then { score in             // after is unfailable; then {score} is unfailable too\n       return after(timespan).then { score }\n    }.then { oldScore in          // since user.getScore() doesn't throw, this would be unfailable too\n       let newScore = user.getScore()\n       return newScore - oldScore\n    }\n}\nmeasureUserProgress(user, timespan: 5).then { progress in\n    print(\"progress: (progress)\")\n} \n```. I don't think either (although haven't tried that hard yet).\nIf there would be some simple logic (forwarding calls) - is it a deal breaker?. Now I think that's doable. I'll try to create a PoC once I got more time.. That's how we can do it:\n```\nclass UnfailablePromise {\n    @discardableResult\n    func then() -> UnfailablePromise { fatalError(\"we want generic protocols!\") }\n}\nclass Promise: UnfailablePromise {\n    override func then() -> Promise {\n        return Promise()\n    }\n}\nlet promise: UnfailablePromise = Promise()\npromise.then() // no warning\nlet promise2: Promise = Promise()\npromise2.then() // warn: unused result\n```\nHowever it makes use of feature that is considered a swift 3 bug.\nRegarding swift bug, we can:\na) assume that before swift team fixes that bugs, they will give us much needed generic protocols\nb) maybe we could do other way around, so UnfailablePromise inherits from Promise. I'll have a think tomorrow.. I don't really think @discardableResult should be inherited. Therefore I made a comment to open that discussion. Once I get some feedback from swift team, I can make a PR here.. I made a significant progress today (branch). Snippet below works very well:\n```swift\n        // unfailable + unfailable #1\n        Promise.with(5).then { val in\n            return Promise(value: val + 10)\n        }\n    // unfailable + unfailable #2\n    Promise<Int>.with(5).then { (val: Int) -> Int in\n        return val + 10\n    }\n\n    // unfailable + failable #1 -> warning\n    _ = Promise<Int>.with(5).then { val throws -> Int in\n        return val + 5\n    }\n\n    // failable + unfailable -> warning\n    let p = Promise<Int>.with(E.dummy).then { val -> Int in\n        return val + 5\n    }\n    p.catch { _ in }\n\n    // failable + failable -> warning\n    _ = Promise(value: 5).then { val throws -> Int in\n        return val + 5\n    }\n\n```\nHowever there are still many unknown parts, so I don't know if this is 100% doable yet.\n@mxcl can you please review existing solution to see if it has a potential to get into production? I just don't want to do unnecessary work.\n. Awesome! I'll give it a try in my side project. So what you're saying is that the only solution is to require user for extra line with defer { }\nLike this?\nswift\nfunc test() {\n    defer { foo.proceed() }\n    foo.deferred.then() {\n        ...\n    }\n    ...\n}\nor equivalent without defer:\nswift\nfunc test() {\n    foo.deferred.then() {\n        ...\n    }\n    ...\n    foo.proceed()\n}. ",
    "morphinewan": "github \"mxcl/PromiseKit\" ~> 4.0\nJust one line.\n. *** Building scheme \"PMKwatchOS\" in PromiseKit.xcodeproj\n*** Building scheme \"PMKtvOS\" in PromiseKit.xcodeproj\n*** Building scheme \"PMKmacOS\" in PromiseKit.xcodeproj\n** BUILD FAILED **\nIt seems WatchOS and tvOS build is fine. Just macOS build failed for some reason I don't know.\n. Thanks, it works.\n. ",
    "jonahgabriel": "Makes sense. Thanks!\n. ",
    "patrickjquinn": "Yes brilliant thanks Max, the questions is around the minimal changes compat layer, will there be one for 2.3?\n. I'm sorry man, this is far too small fries for you to be worrying about, I'm returning PMKPromises instead of AnyPromise so I'm just being lazy and looking for a way to avoid having to migrate our project over to the new syntax, thanks for all your help and a solid project\n. Yes sorry, to be more specific, PMK2 for Swift 2.3 would be perfect, exactly what I was hoping for, our app is still objective C and due migration to swift but this would make all the difference in terms of timeline for the next couple of release, especially the upcoming iOS10 one\n. Issue is very much resolve! App now builds and runs perfectly on iOS 10 under Xcode 8 and Swift 2.3 \ud83d\udc4d Thanks for the amazingly quick turn around I'll report issues like this much sooner instead of looking for workarounds \n. Thanks Max, sorry you've to support us legacy users! We very much appreciate it \ud83d\udc4d . A ton, mostly syntax related i.e expected ';' joining parts of multi-clause condition in NSURLCondition+Promise.swift and complaints about 'dispatch_queue_t' being unavailable in swift in AnyPromise.swift \nI've attached a screenshot of the errors for what thats worth! \n\n. Ohhh thats possible \nuse_frameworks!\n  pod \"PromiseKit\", :git => \"https://github.com/mxcl/PromiseKit.git\", :branch => \"swift-2.3-minimal-changes\"\n end is how i'm including it in my pods.... Adding post_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '2.3'\n    end\n  end\nend\nTo the end of the pod file (Which is essentially exactly what you suggested, only more convoluted) did the trick! Sorry for blaming your wonderful library, the fault lies with me! . ",
    "ryancoughlin": "Oh yes, sorry about: return when(decodeWind, decodeCurrently). Specifically decodeWind, (maybe the compiler halted and didn't get to run decodeCurrently yet.. they are essentially the same promise.\n. Ok great, I read that as it needs to be specified within the promise declaration which I was doing not where I call the promise. \nWould be happy to help with docs as things pop up. Tearing down an old app made with ReactiveCocoa and ObjC and starting a new project with Swift + PromiseKit.\n. I noticed when() has several signatures and return values: [] vs Promise<(U, V)>\nThis worked as the solution:\n```\n        RequestLocation().requestUserLocation().then { locationCoordinate in\n            return NetworkRequest().makeRequest(locationCoordinate)\n        }.then { weatherJSON -> Promise<(Decoded <[Wind]>, Decoded )> in\n            let decodeWind = DecodeWind().decodeWind(weatherJSON)\n            let decodeCurrently = DecodeCurrently().decodeCurrentWeather(weatherJSON)\n        return when(decodeWind, decodeCurrently)\n    }.then { wind, currently in\n        print(wind, currently)\n    }\n\n```\nAppreciate it. \n. ",
    "evautherin": "Yes this is now fixed. Thank you!\n. ",
    "raphaelcruzeiro": "Did you get this to build on Beta 6 @uny ? I'm getting 2 errors here:\nPromiseKit/Sources/AnyPromise.swift:305:19: Ambiguous use of 'subscript'\nPromiseKit/Sources/URLDataPromise.swift:90:58: 'URLRequest' is inaccessible due to 'private' protection level\nSeems that on Beta 6, extensions can no longer access private members of the classes they extend.\n. ",
    "gmckenzi": "Yeah, @raphaelcruzeiro -- just change the declarations of URLRequest and URLResponse from private to fileprivate.\n. True enough. I hadn't considered that. It isn't how I'm using recover, but I understand your point. Carry on.\n. ",
    "uny": "Thank you!\n. ",
    "lchenay": "We have the same problem with Xcode 8 beta 6.\n- Pods/PromiseKit/Sources/dispatch_promise.m:5:24: No known class method for selector 'promiseWithValue:'\n- Pods/PromiseKit/Sources/dispatch_promise.m:5:46: Property 'thenOn' not found on object of type 'id'\n- Pods/PromiseKit/Sources/after.m:8:24: No known class method for selector 'promiseWithResolverBlock:'\nAs @eytanbiala we do see the function in autocompletion. But it failed during compilation of PromiseKit.\n. Allready done.\nTried with Pod 0.39.0 and 1.0 and 1.1.0.beta.2.\nEach times after cleaning pod cache and deleting Pods folder.\n. ",
    "repl-ullas-ml": "@mxcl Here you go https://github.com/repl-ullas-ml/TestingQuick.git\n. @mxcl Yes. Exactly my point. Promise resolves when you run. Problem i am facing is in regard to unit testing. Consider running cmd+U test fails\n. @mxcl The fact i had to file an issue is because i could not get answers in FAQ and docs. Could you please give some code snippet or if could fix the tests directly in my repo would be super helpful.\nAppreciate your help\n. @mxcl What i would actually want to implement is a way to defer the promise resolution and resolve it at a later point of time in tests. I strongly feel the solution lies somewhere in the way i am defining a promise and resolving it!\nPerhaps i strongly feel pending promise is way to go\nlet (promise, fulfill, _) = Promise<NSData>.pendingPromise()\n        stub(mock) { stub in\n            when(stub.requestWithURL(\"http://jsonplaceholder.typicode.com/users\")).thenReturn(promise)\n        }\n        UIApplication.sharedApplication().keyWindow!.rootViewController = viewController\n        XCTAssertNotNil(viewController.view)\nIn simple terms i am creating a promise and giving it back to the controller by stubbing.You can ensure the controller receives the pending promise which is yet to be resolved.\nAnd after view is loaded i resolve the pending promise by fulfill(result). Now then block execution needs to trigger in controller isn't it?\n. URLSessionClient returns promise with data from service to Controller, and if the promise is resolved then print(\u201cPromise resolved successfully\u201d) will execute.\nBut in tests you wouldn't want to hit an actual service. Hence you mock on dummy URLSessionClient and stub to return an promise with some test NSData.\nSo i return an promise which is yet to be resolved through the stubbing(If you enable breakpoint in the controller, promise you stub and return from the tests should be same as the promise that is received by the controller) and i force the viewDidLoad by calling XCTAssertNotNil(viewController.view)\nAt this point controller has a reference to the unresolved promise waiting for some one to fulfil. Now in tests when you need to verify behaviour of the success scenario you can fulfil the pending promise by calling fulfil(someNSData).\nNow you have actually resolved an pending promise and then block should be executed , and after which when you verify the title of the view should be \"My Title\"\n@mxcl Can't think of an better articulation than this. If you need reference to updated code please use https://github.com/repl-ullas-ml/TestingQuick.git\n. ",
    "mattdeckard": "Dang. Do you know of any workaround?\n. ",
    "634750802": "Is this bug fixed in Xcode8 release version?\n. I still need to define SWIFT_PACKAGE manually after I generate .xcodeproj file in that version.\n SwiftPM's recent commit has remove all the building setting including this one.\nThe commit is here.\nMaybe you should re-generate the .xcodeproj file ?\n. ",
    "werne2j": "I am also seeing this error. Using Xcode 8 release on macOS Sierra.\n. ",
    "marbetschar": "Thanks for the hint! It seems I also have to link the PromiseKit.frameworkwith the main app - and not only for the embedded framework. Now everythings working.\n. ",
    "rlam3": "@mxcl So in my case. should my self.alamofireRequest1 and self.alamofireRequest2 need to be promise functions too? Or is this method of using Promise to wrap two seperate async requests not the accepted way to use PromiseKit? \nMy problem involves Moya and PromiseKit. I'd like Moya to do the routing and the promisekit to handle the execution sequence. But there are not many examples out there using this approach. \n. @mxcl both alamofireRequest1 and 2 are both returning Request not Promise Is there a way for me to wrap two requests and do them synchronously? And I'm using PromiseKit 3\nThanks!\n. @mxcl I have a function which I would like to return a request from. But it seems like the Promises are in different closures. Is there a way to get the genericRequest to be returned back after chaining? Thanks.\n``` swift\n    func alamofireRequest(url:String?,completionHandler:(response:Response, error: NSError?) ->()) -> Request{\n    var genericRequest: Request?\n\n\n    firstly{\n        pp()\n    }\n    .then{\n\n        _ -> Promise<Request> in\n\n        print(\"BEGIN REQUST!!\")\n\n\n        // Obtain new token\n        let user = User() // User is still grabbing the old token?\n        let URL = APIURLFactory().makeURLFor(url!)\n\n        // Debugging\n        print(\"alamofireRequest: \\(URL)\")\n\n        let mutableURLRequest = NSMutableURLRequest(URL: URL)\n\n        mutableURLRequest.HTTPMethod = \"GET\"\n        mutableURLRequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n\n        print(\"USER JWT:::::::;\")\n        print(user.jwt_token)\n\n        mutableURLRequest.setValue(\"JWT \\(user.jwt_token)\", forHTTPHeaderField: \"Authorization\")\n\n        genericRequest = Alamofire.request(mutableURLRequest)\n            .validate()\n            .responseJSON{\n                response in\n                completionHandler(response: response, error: response.result.error)\n        }\n\n        return Promise{\n            fulfill, reject in\n            fulfill(genericRequest!)\n        }\n\n    }.then{\n        request in\n        return request <<<< This is not how we do it right? \n    }\n\n    return genericRequest! <<<< need to return here but nil keeps popping up\n\n}\n\n\nfunc pp() -> Promise<String>{\n    return Promise{ fulfill, reject in\n\n        if self.isCurrentAuthTokenIsExpired(){\n            print(\"Token is expired\")\n            //FIXME: locksmith not updated prior to running\n            self.updateAuthTokenInLocksmithWithNewToken()// ERROR HERE\n        }\n\n        fulfill(\"UPDATED TOKEN\")\n\n    }\n}\n\n```\nThanks!\n. ",
    "wokalski": "Oh, I should've checked. Thanks!\n. ",
    "orkoden": "Thanks. I hadn't checked PromiseKit 4, sorry.\n. ",
    "evgeniyd": "OMG, I come up with the following code, before found this:\nlet voidValue: Void = {return}();\nreturn Promise<Void>(value: voidValue)\n\nKISS!. ",
    "raygun101": "How about creating an extension for only  Promises?\nThough the deprecated init() function would cause a problem.\nextension Promise where T == Void\n{\n    convenience init()\n    {\n        self.init(value: ())\n    }\n}. ",
    "RobinDaugherty": "For future searchers out there, the current way (Swift 4) to do create a fulfilled promise for a Promise<Void> is:\nswift\nPromise<Void>.value(())\nor for example:\nswift\ndoSomething().then { result -> Promise<Void> in\n    if result.somethingIsIndicated {\n        return doSomethingElse()\n    } else {\n        return Promise.value(())\n    }\n}. Thanks @mxcl that does work, but I don't think the code is as readable. On the other hand, I can't find this in the documentation, can you point me to that?. ",
    "BilalReffas": "The problem is I get this :/\nA shell task (/usr/bin/xcrun xcodebuild -project /Users/ReffasCode/Documents/Development/iOS Development/Luubra/Carthage/Checkouts/PromiseKit/PromiseKit.xcodeproj -scheme PMKiOS -configuration Release CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES -showBuildSettings) failed with exit code 66:\nxcodebuild: error: Scheme PMKiOS is not currently configured for the build action.\n. Working after killing carthage... \ud83d\ude01\n. ",
    "aaronbrethorst": "Awesome, thanks @mxcl \n. ",
    "fadedblue": "same issue. Clean, rebuild, rebuild\uff0cit work.\n. ",
    "Slessi": "I have cleaned and rebuilt over and over again and to no avail.\n@mxcl \n\n. ... fml.\nWas coming from [NSURLConnection promise:request]; (now deprecated) and totally overlooked that\n. Seems unintuitive to me but thanks for pointing me in the right direction. I read your documentation  when I started using your library, but this was many many months ago now, you can't actually expect me to remember little nuances like this.\nI am coming from JavaScript where this would be a violation of the A+ promises spec I am used to in which a promise's state is either pending, fulfilled or rejected, whereas this is some weird 4th state between pending and fulfilled.\nBut anyway this is not JavaScript and its your library so do as you please. My use case was not as simple as cancelling a request, I just cut straight to the point for the purposes of simplifying the issue.\nI am implementing certificate pinning on my app. If you fail the auth challenge, iOS by default cancels the task. There is no special error code for it, just gets marked as cancelled. Pretty silly of Apple to not use an appropriate error code for this case but it is what it is and I couldn't find a way of ending the task with a custom error.\ntl;Dr I was expecting my catch function to run whrn my task was cancelled. I am on my phone or I'd link you to the relevant methods I am referring to for certificate pinning. @mxcl I do agree that the option to end a promise chain without it leading to a catch can be useful, maybe as a seperate function like abort, and having an option to automatically abort a promise chain in the event of cancellation can also be useful.\nWhere I do not agree is that by default any reject (for whatever reason) may not bubble down to a catch because of another user's preferences. Even if that may be the option everyone secretly wants.\nI think that as it goes against the expected default behaviour of reject it should be opt-in, not opt-out.\ni.e.\n[PromiseKit setAutomaticallyAbortsCancellation:YES]. It wouldn't because there would be a distinction between an abort and a reject.\nresolve([NSError errorWithDomain:NSURLErrorDomain code:kCFURLErrorCancelled userInfo:nil]);\nWould bubble to the next catch\nresolve([AnyPromise abort]) (or something similar)\nWould act as it currently does when resolving a cancellation\nNow, a reject will always bubble up to the next catch, which IMO is the expected behaviour unless you specifically state otherwise by making an abort or turning on the abort all cancellations feature with a flag like [PromiseKit setAutomaticallyAbortsCancellation:YES].\nMy primary concern was just the confusing nature of having rejected promises that dont trigger a catch and having the cancellation feature enabled by default without the user being able to know unless he remembers the documentation. The logging does resolve the user not knowing part though.. You're focusing on the wrong bit, the abort/reject thing is just semantics to distinguish between something which leads to a catch and something which does not.\nFrom your docs\n\nCancelled promises are still rejected promises\n\nEven if p. isRejected returns true, it hasn't behaved like a rejected promise unless it triggered a catch, so I am calling this an abort\n\nThe confusion is that an abort happens without informing the user. This is caused by it being both non-standard behaviour and also the default option. If it must remain this way, I would agree NSLog is the next best step.\nOtherwise, my proposed solution is to only abort cancellations if the user manually enables it.\nExamples of what I am talking about to make it non-default\n\n[PromiseKit setAutomaticallyAbortsCancellation:YES]\ndefault NO\nCheck automaticallyAbortsCancellation before deciding to abort\n\n\n[PromiseKit setDefaultCatchPolicy:PMKCatchPolicyAllErrorsExceptCancellation]\ndefault PMKCatchPolicyAllErrors\nChange implementation of catch to use defaultCatchPolicy\n\n\n\nI'm sure there are many other choices also.. ",
    "bennettl": "Thanks @mxcl . It works! I'm guessing because there's a lot of possible overloads for what can be returned from the closure? Strange because for my other .then(...) i didn't need to specified Void.\n. ",
    "yangzhixiao": "still error...\n. ```\n[!] Error installing PromiseKit\n[!] /usr/bin/git clone https://github.com/mxcl/PromiseKit.git /var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz --single-branch --depth 1 --branch 4.0.1 --recursive\nSubmodule 'Extensions/AVFoundation' (https://github.com/PromiseKit/AVFoundation) registered for path 'Extensions/AVFoundation'\nSubmodule 'Extensions/Accounts' (https://github.com/PromiseKit/Accounts.git) registered for path 'Extensions/Accounts'\nSubmodule 'Extensions/AddressBook' (https://github.com/PromiseKit/AddressBook.git) registered for path 'Extensions/AddressBook'\nSubmodule 'Extensions/Alamofire' (https://github.com/PromiseKit/Alamofire) registered for path 'Extensions/Alamofire'\nSubmodule 'Extensions/AssetsLibrary' (https://github.com/PromiseKit/AssetsLibrary.git) registered for path 'Extensions/AssetsLibrary'\nSubmodule 'Extensions/Bolts' (https://github.com/PromiseKit/Bolts.git) registered for path 'Extensions/Bolts'\nSubmodule 'Extensions/CloudKit' (https://github.com/PromiseKit/CloudKit.git) registered for path 'Extensions/CloudKit'\nSubmodule 'Extensions/CoreBluetooth' (https://github.com/PromiseKit/CoreBluetooth.git) registered for path 'Extensions/CoreBluetooth'\nSubmodule 'Extensions/CoreLocation' (https://github.com/PromiseKit/CoreLocation.git) registered for path 'Extensions/CoreLocation'\nSubmodule 'Extensions/EventKit' (https://github.com/PromiseKit/EventKit.git) registered for path 'Extensions/EventKit'\nSubmodule 'Extensions/Foundation' (https://github.com/PromiseKit/Foundation.git) registered for path 'Extensions/Foundation'\nSubmodule 'Extensions/MapKit' (https://github.com/PromiseKit/MapKit.git) registered for path 'Extensions/MapKit'\nSubmodule 'Extensions/MessagesUI' (https://github.com/PromiseKit/MessagesUI.git) registered for path 'Extensions/MessagesUI'\nSubmodule 'Extensions/OMGHTTPURLRQ' (https://github.com/PromiseKit/OMGHTTPURLRQ) registered for path 'Extensions/OMGHTTPURLRQ'\nSubmodule 'Extensions/Photos' (https://github.com/PromiseKit/Photos.git) registered for path 'Extensions/Photos'\nSubmodule 'Extensions/QuartzCore' (https://github.com/PromiseKit/QuartzCore.git) registered for path 'Extensions/QuartzCore'\nSubmodule 'Extensions/Social' (https://github.com/PromiseKit/Social.git) registered for path 'Extensions/Social'\nSubmodule 'Extensions/StoreKit' (https://github.com/PromiseKit/StoreKit.git) registered for path 'Extensions/StoreKit'\nSubmodule 'Extensions/SystemConfiguration' (https://github.com/PromiseKit/SystemConfiguration) registered for path 'Extensions/SystemConfiguration'\nSubmodule 'Extensions/UIKit' (https://github.com/PromiseKit/UIKit.git) registered for path 'Extensions/UIKit'\nSubmodule 'Extensions/WatchConnectivity' (https://github.com/PromiseKit/WatchConnectivity.git) registered for path 'Extensions/WatchConnectivity'\nSubmodule path 'Extensions/AVFoundation': checked out '0456c7dea92e676473b56730097a4c2ef8cbfcd0'\nSubmodule path 'Extensions/Accounts': checked out '6aa7ff68fb19c20e487cff2e1edc8e1fc759cb17'\nSubmodule path 'Extensions/AddressBook': checked out '42045c9b94421d845fdcb2ba283c12e2af97eaf1'\nSubmodule path 'Extensions/Alamofire': checked out 'e188ed4f13b9c4bcd9d344e65937ee5edcb3eefd'\nSubmodule path 'Extensions/AssetsLibrary': checked out '3268184eb1aed4dbb9b1037f02f84ccc401a53ce'\nSubmodule path 'Extensions/Bolts': checked out '341ec9fe113d795057c3fbfc5ae2cf826678de80'\nSubmodule path 'Extensions/CloudKit': checked out 'd48a7d862a31af44fbd95e92c594cbcd0efe1d72'\nSubmodule path 'Extensions/CoreBluetooth': checked out '9a7ed2bffbaca647be50f729b3e45761869d88f7'\nSubmodule path 'Extensions/CoreLocation': checked out 'bc3e9c9dc7b8659988d7bfb835eb05fa4ec0678f'\nSubmodule path 'Extensions/EventKit': checked out '6126aae80d9243f5c3bf2c5f04c020db3161f658'\nSubmodule path 'Extensions/Foundation': checked out 'a0f1c7c58e25042002aa201167b701ca92d68632'\nSubmodule path 'Extensions/MapKit': checked out 'defb8dd5aa5270e4c1203be2beeb85c02f56aec0'\nCloning into '/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz'...\nNote: checking out 'f8d7d24ee5c6cfa9cbe691779dd0a7175fc19aab'.\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\ngit checkout -b \nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/AVFoundation'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/Accounts'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/AddressBook'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/Alamofire'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/AssetsLibrary'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/Bolts'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/CloudKit'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/CoreBluetooth'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/CoreLocation'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/EventKit'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/Foundation'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/MapKit'...\nCloning into '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/MessagesUI'...\nfatal: unable to access 'https://github.com/PromiseKit/MessagesUI.git/': Failed to connect to github.com port 443: Operation timed out\nfatal: clone of 'https://github.com/PromiseKit/MessagesUI.git' into submodule path '/private/var/folders/47/5ccv4zrs413f28pwfskx53sh0000gn/T/d20160915-54412-klxhiz/Extensions/MessagesUI' failed\n```\n. ",
    "jakjothi": "@mxcl \nAfter upgrading It works, thanks \ud83d\udc4d \n. ",
    "jonybur": "PromiseKit 4.0.1 is being installed as a dependency of a repo called \"AwaitKit\". Should I push a ticket there?\nThank you\n. I'm happy to provide as much info as I possibly can. Anything in particular?\n. Understood. I'm uploading the Podfile and Podfile.lock\nPodfile.zip\nThank you\nEDIT: I will upload the project's repo later today.\n. No luck. Now getting this, not sure if related: \n\n[!] The Bais [Debug] target overrides the ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES build setting defined in Pods/Target Support Files/Pods-Bais/Pods-Bais.debug.xcconfig'. This can lead to problems with the CocoaPods installation\n    - Use the$(inherited)` flag, or\n    - Remove the build settings from the target.\n[!] The Bais [Release] target overrides the ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES build setting defined in Pods/Target Support Files/Pods-Bais/Pods-Bais.release.xcconfig'. This can lead to problems with the CocoaPods installation\n    - Use the$(inherited)` flag, or\n    - Remove the build settings from the target.\n\nWhich is amazing given that I am using the $(inherited) flag in my build settings and the only lib that is throwing a compiler error is PromiseKit with v4.0.1 being installed.\n. I duplicated the folder where my repo is located in order to clean the project to upload it here, and after I duplicated it and ran - everything complied and worked just well.\nGuess it's one of those days.\nThank you all\n. ",
    "andreyrd": "I had this issue as well, and clearing derived data is what ended up fixing it for me. \n. ",
    "FranciscoAmado": "Oh sure,\nI've just tried with github \"mxcl/PromiseKit\" \"swift-2.3-minimal-changes\"\n. That should be it.\nI've tried before with 3.5 and was having the same issue. Cleaned up everything, rebuilt it and worked now.\nSorry for the trouble and thank you for the help\n. ",
    "ignotusverum": "Understood, thanks for explanation \n. ",
    "ChristianKienle": "Just a quick comment: You can also just do something like this:\nthen { ... in }.always{}\n. And to make it even better you can extend Promise and \"give\" always a different name that internally just calls always and returns nothing. . ",
    "donpark": "@mxcl there are often times when some async. task needs to be performed inline inside a .then closure which returns the result via outer resolve because task is either too incidental to turn into a Promise returning function or to wrap with nested Promise needlessly.\nExample:\nfunc foo() -> Promise<URL> {\n    return Promise<URL> { resolve, reject in\n        firstly {\n            // do something async\n        }.then { something in\n            DispatchQueue.main.async {\n                // blah blah\n                resolve(url)\n            }\n        }\n    }\n}\nIn this example, error is either not expected or intentionally ignored. When error matters, reject would be called. Either case, trailing catch is omitted. Sloppy practice, maybe, but everyday code nonetheless.\n. if it seems reasonable to you, go with it. I only complied with your request for examples.\n. Yeah, _ = is what I use too.\nI think the most compelling example of catch-less Promise is infallible async operations.\n. ",
    "jomnius": "I have the same problem and noticed that this ticket is closed. However I couldn't clearly see the fix: just keep using the ugly _ = syntax? Not really complaining, just curious of what is the recommended fix.\n. ",
    "teaualune": "Hi @mxcl , i had exact the same problem with @boardmain but that doesn't work either\nI'm using PromiseKit 4.0 (resolved to 4.0.1), Xcode 8.0, CocoaPods 1.1.0.rc.2 and OS X 10.11.8\nThe error message in AAA-CocoaPods-Hack.h simply shows `'PromiseKit/PromiseKit.h' file not found\nimport `, so it is difficult to figure out what's going on\n. ",
    "boardmain": "tried to delete all.. same problem\nthis is my podfile\nafter pod install\n```\nUncomment this line to define a global platform for your project\nplatform :ios, '9.0'\ndef shared_pods\nend\ntarget 'astaLive' do\n  # Comment this line if you're not using Swift and don't want to use dynamic frameworks\n  use_frameworks!\n# Pods for astaLive\n  pod 'PromiseKit', '~> 4.0'\n  pod 'Alamofire', '~> 4.0'\n  pod 'AlamofireImage', '~> 3.0'\n  pod 'AlamofireObjectMapper', :git => 'https://github.com/tristanhimmelman/AlamofireObjectMapper', :branch => 'swift-3'\n  pod 'Firebase/Core'\n  pod 'Firebase/Database'\n  pod 'Firebase/Auth'\npod 'Realm', git: 'https://github.com/realm/realm-cocoa.git', branch: 'master', submodules: true\npod 'RealmSwift'\n  pod 'CryptoSwift', :git => \"https://github.com/krzyzanowskim/CryptoSwift\", :branch => 'master'\n  pod 'OpenTok'\n  pod 'SteviaLayout'\n  pod 'OpenTok'\n  #  pod 'RAMAnimatedTabBarController'\n  pod 'ReachabilitySwift', '~> 3'\nend\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n    config.build_settings['SWIFT_VERSION'] = '3.0'\nconfig.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = \"YES\"\nend\n\nend\nend\n```\n. ",
    "zhenyakoval": "Same error:\n.../Build/Products/Debug-iphonesimulator/PromiseKit/PromiseKit.framework/Headers/AAA-CocoaPods-Hack.h:14:9: error: 'PromiseKit/PromiseKit.h' file not found\n<unknown>:0: error: could not build Objective-C module 'PromiseKit'\nI'm using PromiseKit (4.0.1), Xcode 8.0, CocoaPods 1.1.0.rc.2 and OS X 10.11.6.\n. ",
    "rupalchawla": "Thanks @PerishableDave  cleaning out ~/Library/Developer/Xcode/DerivedData manually per link worked!\n. ",
    "alex-vasenin": "Having the same problem .../Pods/PromiseKit/Sources/AAA-CocoaPods-Hack.h:14:9: 'PromiseKit/PromiseKit.h' file not found with Xcode 8.3, PromiseKit 4.1.7 and CocoaPods 1.2.0. Deleting Pods, ~/Library/Caches/CocoaPods/, ~/Library/Developer/Xcode/DerivedData and even .../org.llvm.clang/ModuleCache didn't helped. Any other ideas?. Thank you Max! What did helped (temporary and very ugly) is replacing #import <PromiseKit/PromiseKit.h> with #import \"PromiseKit.h\" in the pod sources everywhere (plus the same substitute for AnyPromise.h). Any thoughts on this?. Damn, my workaround doesn't work while archiving \ud83d\ude15. For the record, for me the problem was still relevant even with PromiseKit 4.2.2 and after a lot of pain and despair I managed to solve it in two steps:\n\n\nError .../PromiseKit-Swift.h:141:9: 'PromiseKit/PromiseKit.h' file not found with following .../MyHeader.h:9:9: Could not build module 'PromiseKit' was solved by moving customization of FRAMEWORK_SEARCH_PATH from project level to individual targets.\n\n\nError .../PromiseKit.framework/Headers/PromiseKit-Swift.h:148:1: Duplicate interface definition for class 'AnyPromise' which appeared after step 1 was solved by changing #import \"PromiseKit.h\" to @import PromiseKit; in my own code.\n. \n\n",
    "Voxar": "Just want to record that I had this issue where xcode was complaining about some PromiseKit umbrella header and that I was heled by @rupalchawla's comment . rm -rf your app DerivedData folder. \nI'm guessing it's a xcode module cache issue that isn't cleaned with an xcode clean action. . ",
    "dropski": "Have 3.5.3 and the same error when archiving type metadata for (extension in PromiseKit):__ObjC.UIImagePickerController.Error Xcode 7.3.1. ",
    "george-gw": "It works now, thank you for fixing it so quickly :)\n. ",
    "krider2010": "(sorry, missed the code type off - formatted correctly now)\n. Nothing that clearing the cache (forcefully) doesn't solve \ud83d\udc4d \nThank you for such a speedy response. Much appreciated.\n. ",
    "stevenp": "This also occurs for me when trying to build a framework.\n. ",
    "RoninSTi": "Thank you for the quick reply!  Yeah that's what I figured, going to try a fresh install and see if that helps.  I'll close if that fixes it.\n. ",
    "AttilaTheFun": "@nathanhosselton @mxcl I think the name always is confusing, as it's unclear whether it executes only when the chain of promises completes successfully, or if it fires regardless of whether the chain rejects or fulfills. I think firstly / finally as bookends of a promise chain make sense, and i believe in a previous promise kit release that was the case. I'm not sure what the motivation was behind renaming it. And I understand the motivation behind wanting people to handle errors, but often you really don't want to do anything with that error beyond maybe logging it. Maybe a compromise would be an alternative to catch, drop which just logs the error so you can cleanly and explicitly indicate that you don't care about the error. \nFor example:\nfirstly {\n    return URLSession.shared.dataTask(with: request).asString()\n}.then { string in\n    print(string)\n}.drop()\n. ",
    "joshorr": "I wanted to merge it to our own master (though a review process) before I would merge request it to you. I selected the wrong repo is all.  I'll send another PR shortly.\n. (if your interested?)\n. ",
    "jsgoupil": "That seems to fix the problem.\nI have removed the import Foundation from the file but I was still getting an error.\nI'll let you decide what you want to do about this bug. Thanks!\n. Holy snap, I hate Swift 3... I seriously can't make anything work yet...\nThanks for the update.\n. For people reaching this thread searching how to get the URLError.badResponse to work with PromiseKit. It has been updated with the latest version to the following\nReplace:\nPromiseKit.UrlError.badResponse\nBy:\nPMKURLError.badResponse. ",
    "hamchapman": "Hmmm, that then produces this error:\n\n. It then tries to insist I turn that into an AnyPromise:\n\n. Yeah the way I solved it was just to create my own Promise<Data> instead. \nWould be cool if then could work with URLDataPromise as well. I'm not 100% clear on why it can't but that's potentially a question for another issue in the future so I'll close this one. \nThanks for the help!\n. ",
    "mortyccp": "OK. I have found that it's covered in the FAQ section. Thanks.\n. ",
    "pipacs": "Great, thanks! It was just CocoaPods catching up slowly.\n. Well, even describing the problem helped :) I came up with this:\n```\nfunc poll(count: Int, delay: TimeInterval, body: @escaping (() -> (Promise))) -> Promise {\n    let root = Promise.pending()\n    pollOnce(root: root, countdown: count, delay: delay, body: body)\n    return root.promise\n}\nfunc pollOnce(root: Promise.PendingTuple, countdown: Int, delay: TimeInterval, body: @escaping (() -> (Promise))) {\n    if countdown <= 0 {\n        root.reject(FIXME: an appropriate error)\n        return\n    }\n    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {\n        body().then { result -> Void in\n            if result == nil {\n                pollOnce(root: root, countdown: countdown - 1, delay: delay, body: body)\n            } else {\n                root.fulfill(result!)\n            }\n        }.catch { error in\n            root.reject(error)\n        }\n    }\n}\n```. Thanks!. ",
    "paulryanclark": "I prematurely blamed PMK for the memory leak. A part of my code held a long running reference to the success block of RandomFunctionWithSuccess to reuse the success block. This resulted in a retainment of the resolver argument.\n. ",
    "mojidabckuu": "@zlangley Thank you for the response. I understood the problem. But why Swift thinks that Promise<Any> it matches with Any?\n. @mxcl that's true. I made a POC too for that case. And pattern matching for functions works unexpectedly. So in my case as workaround I made an extension for Promise called next instead of then to support the case with Promise<Any> once Swift team fix it.\n``` swift\nclass B {\n    func h( block: @escaping (T) throws -> Alamofire.Result) -> B {\n        print(\"bro\")\n        return B()\n    }\n    func h( block: @escaping (T) throws -> U) -> B {\n        print(\"NOOOOO bro\")\n        return B()\n    }\n}\nB().h { (val) -> Alamofire.Result in\n            return .success(1)\n        }.h { (val) -> Alamofire.Result in\n            return .success(\"\")\n        }.h { (val) -> Alamofire.Result in\n            return .success(123)\n        }.h { (val) -> Alamofire.Result in\n            return .success(123123)\n        }\n```\nGives me\nbro\nNOOOOO bro\nNOOOOO bro\nNOOOOO bro\nSuper strange why they did like this.\n. ",
    "banxi1988": "Maybe  one of two different then method should change its name to a new one.\n. ",
    "LucianoPolit": "Yes, I solved it catching the error of the 'setSynchronize'. It was my mistake. Im sorry.\nAlso, it was a good warning \ud83d\ude02 !\n. ",
    "iThinker": "Thank you. I will try this solution.\n. I see. That's unfortunate. Errors can may include additional information, but it is hard to include same information as request origin would provide.\nHow do you think, would promises allow to record chain? I mean, if I would add #file and #line information when I create any promise, would it be possible to pass this information to each next attached promise?. Thank you for answers. Will try to do it.. Awesome! Thank you!. ",
    "kostickm": "I did try forking the project and making that change, but even on MacOS it doesn't recognize that as a module Foundation.Progress, though looking at the Foundation code that should be what is used.. I was able to build the latest PromiseKit release successfully on Ubuntu 15.10 Swift 3.0.1 Release. Thank you!. ",
    "rfdickerson": "Yeah, I think it's there as Progress in Linux, not NSProgress.. It looks like it's a new feature in the development toolchains of Swift- we are trying to figure out exactly which one will work for us.. ",
    "p21jerfeson": "I saw another ticket with a similar problem, I did the same, I changed the folder, and it worked, but I wanted to know how to solve it, is it some kind of macOS cache, in folder structures, would you say?. My project was done in a folder structure\n/Folder1/folder2/folder3/app, I changed to folderx/app\n. ",
    "mohamede1945": "What about a suppress error function?\nIt's very similar to the _ = solution but I think it's more elegant as it clearly states its purpose.\n. It looks very good. Is it possible to implement it with a tag parameter for the print? something like that:\nswift\npublic func cauterize(tag: String? = nil) {\n    `catch` { error in\n        if let tag = tag {\n            print(\"PromiseKit: [\\(tag)] unhandled error:\", error)\n        } else {\n            print(\"PromiseKit: unhandled error:\", error)\n        }\n    }\n}. ",
    "zayhero": "@mxcl I am using BUCK to build this, which I think is using normal Xcode toolchain to build. \nHere is the LLVM version I got from llvm-gcc\n$ llvm-gcc -v\nApple LLVM version 8.0.0 (clang-800.0.42.1)\nTarget: x86_64-apple-darwin15.6.0\nThread model: posix\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin\nIs there a particular concern in adding this header?. @mxcl just want to check if you already fix travis? If yes, I could push the branch again to make the build green. ",
    "adrixpho": "Hi @mxcl I think there's a typo in the documentation about cancellation, the example cannot return a variable inside another scope and is missing a curly braces. I did something like this fixing the typo:\nfunc foo() -> (Promise<Void>, cancel: () -> Void) {\n        var cancelme = false\n        var cancelClosure : (() -> Void)!\n        let promise = Promise<Void> { fulfill, reject in\n            let task = Task(\u2026)\n            cancelClosure = {\n                cancelme = true\n                task.cancel()\n                reject(NSError.cancelledError)\n            }\n            task.completion = { value in\n                guard !cancelme else { reject(NSError.cancelledError) }\n                fulfill(value)\n                task.start()\n            }\n        }\n        return (promise, cancelClosure)\n    }\nIs that correct?. ",
    "ragboyjr": "@ldiqual @mxcl from my own projects, I use resolved promises a lot when i'm trying to short circuit a promise chain.\nswift\nfunc doSomethingWithUser(user: User) -> Promise<Void> {\n    if !user.canDoSomething() {\n        return Promise<Void>();\n    }\n    // actually do something and return a promise that does work.\n    return Promise<Void>() { resolve, reject in \n        // do something\n    }\n}\nI don't know if this in correct usage of promises, but this is typically when I'd use a resolved promise.. ",
    "hk0i": "How about adding a setup link to reference the GitHub README? one more line will be just as concise more or less and solve the problem of people getting lost.\nI'm not sure how common of an issue this is but once I was on the PromiseKit site I felt like I had to stay there and hunt around for the documentation, which actually wasn't on the site even though there was link titled Doc. The problem is that the documentation is distributed across different sites. I clicked on Doc expecting the full story or some reference to it, anyway.. Yeah I'm cycling through the README, the Objective-C portion of the documentation, the FAQ and this other thing that claims to be the documentation that I found on a whim.\nIt's starting to come together.\nI have an add-on suggestion, if I may. The docs never talk about which headers to include for objective-c. Right now I'm using:\n```objc\nimport \"UIView+AnyPromise.h\"\nimport \n```\nWhich I'm assuming is right, but I had started off on the assumption that I only needed to #import \"AnyPromise.h\" since it was the \"Objective C\" implementation. The second import encapsulates everything I'm assuming (finding PMKAfter took some digging) through some random hacking I managed to get it working with this, more or less.. I still haven't taken a look at it yet, but are you saying the sources for promisekit.org are also hosted on GitHub? I took a quick peek but I couldn't find where it's at. Just point me in the right direction and I'd be glad to help out.. Wow. I never knew about this. That's pretty neat.\nI'll poke around with it when I get some time and send a PR :)\nThanks!. ",
    "cherishloveyou": "at firsts, I installed it by cocoa pods, I try clean all pod to install, it's now ok. . ",
    "hunganh0403": "Thank you guys, now i clearly understand. Sorry for long reply (because i feel so ashamed).. ",
    "antiraum": "A data race is reported when multiple threads access the same memory location without using proper synchronization.\nI haven't seen any real problems in my project, I was just curious why the ThreadSanitizer reports this problem.\nI have pushed my demo project if you want to run it yourself: https://github.com/antiraum/PromiseKit-DataRace-Demo\n. ",
    "JosephNK": "```\nimport PromiseKit\nimport Alamofire\nfunc requestGetAllImages(imageUrls: [String]) -> Promise<[Result]>  {\n    let promises = imageUrls.map { (imageUrl) -> Promise in\n        return Promise { fulfill, reject in\n            FTAPIManager.sharedInstance.requestIgnoringCacheImage(imageUrl, { (image, error) in\n                if image != nil {\n                    fulfill(image!)\n                }else {\n                    reject(error!)\n                }\n            })\n        }\n    }\n    return when(resolved: promises)\n}\n```\nThe above code is my sample code.\nerror location:  -> Promise<[Result<UIImage>]> \nerror desc : 'Result' is ambiguous for type lookup in this context\nI think it does not seem to support PromiseKit.Result\nPlease check. and fix it :). Thank you for your reply and resolved. \ud83d\ude04 . ",
    "johndpope": "if the code is \npublic func start() -> Promise {\n return PromiseKit.wrap(start)\n }\nhow to translate this code?\nyou should comment this in the docs - PromiseKit.wrap \nthere's a sea of this usage on github\nhttps://github.com/search?p=2&q=PromiseKit.wrap&ref=opensearch&type=Code\nit should be added to readme as breaking change and included as a removed function in code. \nI've wasted a couple of hours on this. \nCannot convert value of type 'Resolver<_>' to expected argument type '(Error?, User?) -> ()'\n\n. https://gist.github.com/johndpope/26589589d4c38dd47302d4d7ec7c3306. Sorry to hear about closure  woes. Not to add salt to wounds, but supposedly Flat map is deprecated.... does googles\u2019 promise iOS framework suffer same problems I wonder. \nFYI - projects I\u2019m using are based on Carthage and think the file didn\u2019t lock a specific version. Will look into downgrading. \nIt would be nice to include this link in source code / readme with BOLD Breaking changes as there are so many >2500 repos and developers that any help to upgrade the old code to new would go a long way. I\u2019m on train now, will attempt downgrade tomorrow or raise ticket to refactor. . ",
    "qiangyu": "Thank you @mxcl for the investigation :-). ",
    "cikpis": "In Build Setting under your Targets if you look for Compatibility Version and Current Library Version you should find them.. After changing the Compatibility Version and Current Library Version manually to 4.1.4, the Usabilla SDK runs as expected. \nPlease fix this issue which should be a critical one. It could be fixed in 1 sec :)\nKeep me updated, cheers!. Cool! Thanks!. ",
    "kubajakowski": "@mxcl ok maybe my thoughts went too far ;)\nbut when(fulfilled: array.makeIterator(), concurrently: 1) definetely should resolve one-by-one which is ilustrated in (failing) test.\nMaybe again I'm misunderstanding something but \n```\nlet promises = [promise1, promise2, promise3]\npromises[0].then{\n    return promises[1]\n}.then{\n   return promises[2]\n}.then{\n    //done\n}\nshould be eqiuvalent to\nwhen(fulfilled: promises, concurrent: 1).then{\n    //done\n}\n```\nAm I right here?. I've also updated testCase. @mxcl you mean like this?\nswift\nfunc testIfResolvedOneByOne()\n{\n    var current: Int? = nil\n    let expectation = self.expectation(description: \"\")\n    var onDone: (Int) -> () = { i in\n        if current == nil {\n            current = i\n        }else{\n            XCTAssert(i < current!, \"should count down but tries to fulfill \\(current!) before \\(i)\")\n            current = i\n        }\n        print(i)\n    }\n    when(fulfilled: { return [after(interval: 0.3).always {onDone(3)}, after(interval: 0.2).always {onDone(2)}, after(interval: 0.1).always {onDone(1)}]}().makeIterator(), concurrently: 1).then {_ -> Void in\n        XCTAssert(true, \"shoud enter here, all are fulfilled\")\n        }.always{\n            expectation.fulfill()\n        }\n    self.waitForExpectations(timeout: 1, handler: nil)\n}\nstill no luck.... I guess I finally figured it out but it's not the prettiest solution\n```swift\nfunc testIfResolvedOneByOne()\n{\n    var current: Int? = nil\n    let expectation = self.expectation(description: \"\")\nfunc promise(i: Int, onDone: @escaping (Int)->()) -> Promise<Int>\n{\n    return Promise { fulfiled, _ in\n        after(interval: Double(i)*0.01).always {\n            onDone(i)\n            fulfiled(i)\n        }\n    }\n}\nvar onDone: (Int) -> () = { i in\n    if current == nil {\n        current = i\n    }else{\n        XCTAssert(i < current!, \"should count down but tries to fulfill \\(current!) before \\(i)\")\n        current = i\n    }\n    print(i)\n}\n\nlet ints = [5,4,3,2,1]\nvar intGenerator = ints.makeIterator()\n\nlet generator = AnyIterator<Promise<Int>> {\n    guard let i = intGenerator.next() else { return nil }\n    return promise(i: i, onDone: { (i) in\n        onDone(i)\n    })\n}\n\nwhen(fulfilled: generator, concurrently: 1).then {_ -> Void in\n    XCTAssert(true, \"shoud enter here, all are fulfilled\")\n    }.always{\n        expectation.fulfill()\n}\nself.waitForExpectations(timeout: 1, handler: nil)\n\n}\n``` \n. @mxcl what do you think about such extensions?\n```\nextension Array\n{\n    func when(_ transform: @escaping (Element)->Promise) -> Promise<[T]>\n    {\n        var iterator = self.makeIterator()\n        let generator = AnyIterator> {\n            guard let i = iterator.next() else { return nil }\n            return transform(i)\n        }\n        return PromiseKit.when(fulfilled: generator, concurrently: 1)\n    }\n}\nfunc when(fulfilledOneByOne array: [T], transform: @escaping (T)->Promise) -> Promise<[N]>\n{\n    var iterator = array.makeIterator()\n    let generator = AnyIterator> {\n        guard let i = iterator.next() else { return nil }\n        return transform(i)\n    }\n    return when(fulfilled: generator, concurrently: 1)\n}\n```\nand tests:\n```\nfunc testIfResolvedOneByOneBasic()\n{\n    let expectation = self.expectation(description: \"\")\n    let ints = [5,4,3,2,1]\n    var current = (ints.max() ?? 0) + 1\n    when(fulfilledOneByOne: ints, transform: { i -> Promise in\n        return after(interval: 0.01 * Double(i)).then { _ -> Promise in\n            XCTAssert(i < current, \"should count down but tries to fulfill (current) before (i)\")\n            current = i\n            return Promise(value: ())\n        }\n    }).always {\n            expectation.fulfill()\n    }\n    self.waitForExpectations(timeout: 1, handler: nil)\n}\nfunc testIfResolvedOneByOneArrayExtension()\n{\n    let expectation = self.expectation(description: \"\")\n    let ints = [5,4,3,2,1]\n    var current = (ints.max() ?? 0) + 1\n    ints.when({i -> Promise in\n        return after(interval: 0.01 * Double(i)).then { _ -> Promise in\n            XCTAssert(i < current, \"should count down but tries to fulfill (current) before (i)\")\n            current = i\n            return Promise(value: ())\n        }}).always{\n            expectation.fulfill()\n    }\n    self.waitForExpectations(timeout: 1, handler: nil)\n}\n```\n. ",
    "scottandrew": "This just came in super hand for paged network.. ",
    "crarau": "@mxcl I've created this repository to demonstrate the issue: https://github.com/crarau/promise-kit-issue\nWhat I've meant is that I'd like to use PromiseKit using swift server side. For this I've create a project that is deployed on Ubuntu 16.04. While testing on XCode I noticed that PromiseKit doesn't work the same in this project when compared to an iOS one.. to reproduce the issue I've created this repository: https://github.com/crarau/SwiftKit-ServerSide-Issue\n```swift\nimport Foundation\nimport Kitura\nimport PromiseKit\nclass PromiseKitServerSide {\n    func test(completion:@escaping (String)->()) {\n        print(\"in test\")\n    firstly {\n        return Promise.init(value: \"promise\")\n        }.then { value in\n            print(\"in then\")\n            completion(value)\n        }.always {\n            completion(\"done!\");\n    }\n}\n\n}\nlet router = Router()\nrouter.get(\"/\") { request, response, next in\n    PromiseKitServerSide().test(completion: { (result) in\n        response.send(result)\n    })\n    RunLoop.main.run()\n}\nprint(\"starting server\")\nKitura.addHTTPServer(onPort: 8888, with: router)\nKitura.run()\ngoing in the browser and accessing http://127.0.0.1:8888/ in the console we see:\nstarting server\nin test\n``\nthe code doesn't get intothenorfinally`.\nAdding RunLoop.main.run() doesn't change and RunLoop.main.stop() doesn't exist.\nPlease advise,\nRegards. ",
    "ChristopherCarranza": "I'd love to get more info / guidance on this. I understand that a runloop is required, but wasn't aware that one wasn't available when running a server side swift project?\nPromises are such an integral part of my workflow that imagining the nested closure mess i would get into without them makes me want to solve this.\nI'm currently using the latest version of Kitura. I didn't quite get your example above. Would there be any way to get this to work? . ",
    "sonny-werghis": "Kitura blocks DispatchQueue.main, which is the default queue for then(). You will need to explicitly pass DispatchQueue.global to then, always, etc. As in:\nfirstly {\n            return Promise.init(value: \"promise\")\n      }.then (on:DispatchQueue.global()) { value in\n                print(\"in then\")\n                completion(value)\n      }.always(on:DispatchQueue.global()) {\n                completion(\"done!\");\n      }\n. ",
    "k1313": "\nYou can set the default queue that PromiseKit uses: https://github.com/mxcl/PromiseKit/blob/master/Sources/DispatchQueue%2BPromise.swift#L37-L52\n\nHow we can set it?\nswift\nfunc __PMKDefaultDispatchQueue() -> DispatchQueue {\n   return DispatchQueue.main\n}\n\u00a0\nfunc __PMKSetDefaultDispatchQueue(_: DispatchQueue)\n{}. Are these values the same in the current version?. sorry, don't know obj-c :). it's ok now?. ",
    "abl": "With PMK5, you can now do:\nswift\nconf.Q = (map: DispatchQueue.global(), return: DispatchQueue.global())\nHere's a quick example using Kitura:\n```swift\nimport Foundation\nimport Kitura\nimport PromiseKit\nimport HeliumLogger\nimport LoggerAPI\nHeliumLogger.use(.info)\nconf.Q = (map: DispatchQueue.global(), return: DispatchQueue.global())\nlet router = Router()\nrouter.get(\"/\") { _, response, next in\n    Log.info(\"Request received\")\n    after(seconds: 1.0).done {\n        Log.info(\"Sending response\")\n        response.send(\"OK\")\n        next()\n    }\n}\nLog.info(\"Starting server\")\nKitura.addHTTPServer(onPort: 8888, with: router)\nKitura.run()\n```\nThis produces output like:\n[2017-11-29T21:20:04.206-08:00] [INFO] [main.swift:21 promisekitura] Starting server\n[2017-11-29T21:20:04.213-08:00] [INFO] [HTTPServer.swift:124 listen(on:)] Listening on port 8888\n[2017-11-29T21:20:11.491-08:00] [INFO] [main.swift:13 promisekitura] Request received\n[2017-11-29T21:20:12.589-08:00] [INFO] [main.swift:15 promisekitura] Sending response\nYou can see that roughly a second elapses between the request being received and the response being sent, so the promise chain is working, and Kitura does send the response as expected:\n```\n~\n\u276f http http://localhost:8888\nHTTP/1.1 200 OK\nConnection: Keep-Alive\nContent-Length: 2\nDate: Thu, 30 Nov 2017 05:23:39 GMT\nKeep-Alive: timeout=60\nOK\n```\nHope this helps!. PR sent for the first issue which is, possibly, a memory leak - the remaining issues do not (yet) make sense to me.. > PMK5 (recently released has wait())\nWhoops, I forgot to mention that I tried wait() first and it deadlocked the main thread - for example:\nswift\nfunc testWait() {\n    let ex = expectation(description: \"block executed\")\n    after(seconds: 0.02).done {\n        ex.fulfill()\n    }.wait()\n    waitForExpectations(timeout: 0)\n}\nThis makes sense; it's possible to remove the deadlock by using done(on:, ...) but if any part of your chain hits the main queue you're sunk...and the GCD API doesn't seem to offer a clean solution to this. (dispatch_get_current_queue is missed.)\n\nAlso, do you use PMK5 and not 4?\n\nYes, I'm using PMK5 - figured it'd be best to start acclimating early. :)\n\nDo you want this in 4, maybe also in 5?\n\nHaven't tested this revision against 4 - I had something similar that worked in 4 but was less elegant. Would be happy to have it in 5 and if you think it'd be valuable to backport to 4 I can revisit my original attempt.\n\nDo you think the approach you have taken with runloops is the more sensible choice?\n\nI'm just copying your approach from PMKHang.m - I prefer your approach in wait(). wait() is conceptually cleaner with less overhead; hang() just happens to be useful when invoked from a non-runloop application.. Sorry, I've been out sick.\nInvestigating iOS et al - practically, there's no reason to call hang() over wait() as all iOS/tvOS/watchOS apps will have runloops.. Ok, the issue is that Apple-y platforms (that is, not os(Linux)) use a different CFRunLoop setup. After this tweak the ATV and iOS tests pass locally - the watchOS tests won't build with/without my changes for some reason on Xcode 9.2.\nLong term this may introduce other issues - other platforms being added to Swift (e.g. Haiku, Fuchsia) will have to be added to this conditional.. ",
    "RomanVolkov": "@mxcl ok, let me try to rephrase what I want to achieve. \nI have chain of requests. E.g., 3 requests, each is embedded in Promise.\nI make first request, get result inside .then {} and after I need to check this result\nIf condition == true - return next promise that calls next .then {} in chain. if condition is false - stop chaining and get direct to finally/always closure. \nCan you suggest how to do it with your lib?\nCause I don't want to make it like callback hell like this\npromise1().then { result in\n  if result {\n      promise2(). then {result2 in \n      }.catch....\n  }\n}.catch....\n. ",
    "aodhol": "@mxcl Sort of related, could you recommend a pattern for the following scenario: Storing / retrieving an API token:\n - check if token on disk.\n - if on disk, check if expired.\n - if not expired, return token.\n - else if expired or not on disk:\n    - retrieve from network.\n    - save to disk.\n    - return token.\n\nI'm not sure if this should involve a compactMap or throwing an error and catching or an optional or what?\nI'm imagining a single top level function: fetchToken() -> Promise<Token> and then several helpers: fetchTokenFromStorage() -> Promise<Token> and refreshToken() -> <Token> but tying these together is the problem.. \n. @mxcl Thank you! I will :). pod 'PromiseKit/Foundation' needs to be included!. My error entirely, for some reason I only included: pod 'PromiseKit/CorePromise' to begin with!. ",
    "drekka": "Cancelling . Just realised I've using different formatting.. Cool. Thanks for the suggestions.. PR Submitted. The change seem to be working in my code base. Hmm. Actually might change the PR to throw a fatalError.. Updated the test to wait for the results.. Hi guys, I'm not a developer of PromiseKit, I just use it. I'm struggling a bit to understand the use cases this solves and I'm presuming there are two:\n\n\nWhen executing a chain of promises, one of the wrapped closures wants to cancel the entire chain. For example, a series of API calls where a closure in the middle decides that there is no need to make any of the subsequent calls and wants to cancel the rest of the chain. Currently I thought we could do this sort of things by merely throwing a PMKError.cancel.\n\n\nWhen executing a chain of promises, an external influence wants to cancel the chain at some obituary point in time. Again using the chain of API calls, I'm presuming this would occur if the UI that initiated the chain, was unloaded by the user and therefore wanted to cancel the chain. Normally in the code bases I've worked on we've used guard blocks which check the UI at various points through a chain like this and if any of them detect the UI being unloaded they stop the chain. Usually without triggering any errors or UI displays.\n\n\nAm I correct in that scenario #2 is the one being addressed by this PR?\nThe idea of not having to add guard blocks to effectively monitor external state in order to cancel a chain sounds great. But I'm not keep on expanding the range of functions like the above. If feels like it's creating a large amount of complexity which will make life harder for both experienced and newbie PromiseKit user's alike. I'm especially keen on this because one of the things I love about PromiseKit is it's simplicity. \nI have another idea which just jumped into my head whilst writing this :-) so I don't know if it's practical at all. \nBasically it's to make Thenable 'cancellable'. :-) by default. A property could be added to Thenable -> var cancelIf: () -> Bool = { false } which could be tested before the promise's closure is called and after. If it returns a true then the promise chain cancels out using PMKError.cancel as if the closure had thrown it. Then any promise or guarantee can become a cancellable one simply by setting this property. Something like this:\n```\n    firstly {\n        doFirstThing()\n    }.cancelIf { [weak self] in self == nil }\n    .then { result1 in\n       doSecondthing(result1)\n    }\n    }.cancelIf { [weak self] in self?.userHasCancelled || result1.stop }\n    .then { result2 in\n       doSecondthing(result2)\n    }\n    .done { result3 in\n       doSecondthing(result3)\n    }\n``` \nNot sure if that's workable, just throwing around some ideas in my head.  . Yeah, the cancelIf I suggested was purely about allowing promises to reach out to check some condition. Cancelling the promise from an external execution would more difficult. \nPlease excuse me if I'm suggesting what you've already done. I really haven't had the time to research this like you guys have. \nI presume the builtin cancel methods you've been looking at work by executing the exit or cancel methods on the thread started by the promise (providing it's not the same thread) and then returning an error from the promise. Is that correct?. Cool. Luckily I actually don't need the WatchOS build, just happened to come across this :-) Thanks.. I like this. I was thinking it would be really useful to have this .catchOnly(MyError.self) { as I might handle situations where data errors are handled differently to networking errors and it would be nice for PromiseKit to save me from my obsession with switch statements (Only a slight exaggeration :-). Yep. I initially played around with adding .guarantee to the namespace, but that didn't stop me from saying .promise and returning a guarantee which I thought was disturbing and would be a confusing issues for developers who are not familiar with the API. \nI also messed with just using .async{, but I liked the idea of developers not having to specify the closure argument types. \nI agree with you on the type argument, not the best but I was trying for readability.\nI'll re-engineer back to .async in line with your comments as I don't mind either option. The thing I mostly needed was the sealable option.. Hmmm. Need some advise. In the unit tests for the async functions the closure argument is fully specified. ie.\nswift\nbackgroundQueue.async(.promise) { () -> Int in\n    return 5\n}\nBut some of the comments leave the closure argument out and in my tests they won't compile. ie.\nswift\nbackgroundQueue.async(.promise) { // Won't compile as it cannot infer type!\n    return 5\n}\nHaving to fully specify the closure lead me to suspect the .promise argument wasn't actually needed. So I tested removing it and the following code compiled just fine:\n```swift\nbackgroundQueue.async { () -> Int in\n    return 5\n}\nbackgroundQueue.async { () -> Int in\n    return 5\n}.catch { _ in }\n// and with the seal code I'm adding:\nbackgroundQueue.async { (seal: (Int) -> Void) in\n    seal(5)\n}\nbackgroundQueue.async { (seal: Resolver) in\n    seal.fulfill(5)\n}.catch { _ in }\n```\nAm I missing something?\n. Hi, can you give me some more details on what the confusion would be? \nI added a couple of test functions to call Apple's .async {....} functions and had no problem with code completion, etc. The only thing I noticed was that code completion listed the PK functions with the GCD ones. Is that what you mean? :-). Hmm. been thinking about this. I think I'll do it as an seperate library instead.. ",
    "emaloney": "No need for apologies; PromiseKit is great and I really appreciate you working on it and making it publicly available. Thank you!!. ",
    "euwars": "@mxcl  Swift version 3.0.2 (swift-3.0.2-RELEASE). ",
    "farshadtx": "@mxcl I think you should consider adding this (or similar method) to testing documentation. specially when there are more than one Async process (in my case, RxSwift hot stream and PromiseKit) chained together.. I meant testing section\nOn Sun, Apr 2, 2017 at 08:41 Max Howell notifications@github.com wrote:\n\ntesting documentation\nI don\u2019t understand what you mean.\nspecially when there are more than one Async process (in my case, RxSwift\nhot stream and PromiseKit) chained together.\nSorry, I don\u2019t know what this would look like.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/637#issuecomment-290994362,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFWyGf5rbP111xXqYZEWfNaRojfpNsrqks5rr8GsgaJpZM4MfK4Q\n.\n. \n",
    "willocdev": "How would you pass along a promise variable through the wait promise?. Ended up implementing like this and it works great:\nfunc returnObjectAfterWait(object:Any, waitTime:TimeInterval) -> Promise<Any>{\n     return Promise { fulfill, reject in\n          after(interval:waitTime).then {\n                fulfill(object)\n          }\n     }\n}\nAnd then:\nreturn firstly {\n    someMethod()\n}.then { object -> Promise<Any>\n    return returnObjectAfterWait(object:object, waitTime:1.5)\n}.then { object -> Void in\n    [use object here]\n}. ",
    "BennX": "I think the basic idea here would be to add a new catch method to the State which takes an NSError. Alternatively an Error & Compareable would be possible:\nSwift\nfinal func `catch`(on q: DispatchQueue, policy: CatchPolicy, `catch`: NSError, else resolve: @escaping (Resolution<T>) -> Void, execute body: @escaping (Error) throws -> Void) {\n    pipe { resolution in\n        switch (resolution, policy) {\n        case(let .rejected(error, token), _) where (error as NSError) == `catch`:\n            contain_zalgo(q, rejecter: resolve) {\n                token.consumed = true\n                try body(error)\n            }\n        default:\n            resolve(resolution)\n        }\n    }\n}\nInside the regular catch it is needed to have a check if the error is already consumed. If so do not execute the body.\nSwift\ncase (let .rejected(error, token), _):\n    contain_zalgo(q, rejecter: resolve) {\n        if token.consumed {\n            resolve(resolution)\n        } else {\n            token.consumed = true\n            try body(error)\n        }\n    }\n} \nNow the Promis itself need the function to catch with an NSError:\nSwift\n@discardableResult\npublic func `catch`(on q: DispatchQueue = .default, policy: CatchPolicy = .allErrorsExceptCancellation, _ `catch`: NSError, execute body: @escaping (Error) -> Void) -> Promise {\n    state.catch(on: q, policy: policy, catch: `catch`, else: { _ in }, execute: body)\n    return self\n}\nCatching then can look like this:\n```Swift\nfunc testCatchWithSpecificError() {\n    let ex = expectation(description: \"\")\nPromise(value: ()).then {\n    throw Error.more as NSError\n}.catch(Error.dummy as NSError) { _ in\n    XCTFail()\n}.catch(Error.more as NSError) { _ in\n    ex.fulfill()\n}.catch { _ in\n    XCTFail()\n}\nwaitForExpectations(timeout: 1)\n\n}\n```\nI am not into the whole concept in depth therefor i cant provide a fully working PR. (I am not into Objc and those Objc tests do not pass.) \nhttps://github.com/mxcl/PromiseKit/compare/master...BennX:master . ",
    "basvankuijck": "Just out of curiosity.\nWhat is wrong with:\n```swift\n// ...\n}.recover { error -> Promise in\n    if error is SomePositiveError {\n        return Promise(value: \"someString\")\n    } \n    throw error\n}.catch { error in\n    switch error {\n    case is AccountNotFoundError:\n        // Handle AccountNotFoundError \n    default:\n        // All the other errors\n    }\n}. Try:\nswift\n}.then { () -> Promise<Void> in\n    let observed = .... ",
    "mnearents": "I am having this same issue, what do you mean \"built PromiseKit for iOS first\"? I cloned the repo and opened the playground file. . So what do I do about it. I selected the iphone simulator from the dropdown, what more do I need to do?\n\n. My problem was I was on Swift 3.1 instead of 3.1.1. Updating Xcode fixed it.. ",
    "jonbrooks": "Ah well, too bad.  Nice to know that you already tried that.\nWhat you say matches my experience.  At least half the time its my fault.  I was just hoping the latter case - where I have to be explicit in my closure's return - would have improved.\n. ",
    "Phnx777": "Yes, this is an error: Cannot subclass a class with objc_subclassing_restricted attribute.\nI tried to find solution. It means problem inheritance objective-c and swift. How can I resolve this issue in my obj-c project?. how is your debugging?. ",
    "danhalliday": "Many thanks for your carefully considered reply. For me, I'd value the brevity more, but I can understand the argument. One thing I find better about the non-closure syntax is there's no need to pass arguments every time as long as the functions' argument and return types all match up. The closure syntax has you repeating arguments on every line.\nI'll take a closer look at the v5 branch, some interesting changes there!. ",
    "ridvank": "The problem occurs while casting Custom Error to NSError. I have posted an answer for this problem here: http://stackoverflow.com/questions/43225036/swift-3-1-crash-when-custom-error-is-converted-to-nserror-to-access-its-domain/43362207#43362207. I am using PromiseKit like this way:\nfunc fetchAvatar(user: String) -> Promise<UIImage> {\n    return Promise { fulfill, reject in\n        MyWebHelper.GET(\"\\(user)/avatar\") { data, err in\n            guard let data = data else { return reject(err) }\n            guard let img = UIImage(data: data) else { return reject(MyError.InvalidImage) }\n            guard let img.size.width > 0 else { return reject(MyError.ImageTooSmall) }\n            fulfill(img)\n        }\n    }\n}\nI will try to reproduce it with a simple project. ",
    "lluisgerard": "What worked for me is to conform to CustomNSError protocol.. ",
    "pgrosslicht": "I think I have the same error. The crash seems to have to do with Error.isCancelledError. It crashes only in Release builds and the crash is at the catch. If I use the allErrors catch policy, it doesn't crash. Conforming my error to CustomNSError does fix the crashes as well. \nI'll try to build a minimal crashing project.. @mxcl I have been able to build a minimal reproduction here: https://github.com/pgrosslicht/PromiseKitCrashReproduction\nBut it seems that this has been fixed in Xcode 8.3.2. The reproduction worked, then I updated and  it stopped working. I removed the workaround from my original app and it worked there as well when compiled with Xcode 8.3.2. So if you want to test the crash, it only works with Xcode 8.3.1.. ",
    "f0r3s1": "THE SAME. > The same it\u2019s fixed in Xcode 8.3.2 or the same it crashes?\nI have Xcode 8.3.2 and it crashes anyway with absolutely the same reason. \nedit: It crashes in CorePromise/Error.swift line 145 in \"release\" build configuration only. > Can you provide a testcase? Otherwise I can't verify any fix I attempt works.\nOk, I will do that and notify you in this thread after. As I see now, app crashes if PromiseKit getting the variable \"isCancelledError\". In other ways it doesn't crash. Yes, agree. I clean cache and try. It does not crash with 8.3.2. Yes, thank you.. ",
    "qq421680227": "This is a common problem, not the xcode version of the problem, but other versions still crash.. ",
    "pffan91": "Thank you @mxcl , that's what I need!\nYes, my error was \"Missing return in a closure expected to return 'Promise<()>'\". Thank you @mxcl ! This solved my problem. In my case I just set correct type to variables that affected.. Ok, thank you!. ",
    "victorg1991": "Oh sorry, I made a mistake, which I wanted to do is revert that change and use the default value which is what most of the frameworks use (instead of the current version of the framework which is problematic)  https://github.com/realm/realm-cocoa/issues/2180\nsegiddins:\n\nGiven the problems we've seen in CocoaPods with setting these version fields, I'd be against doing this.\n\n. No problem at all, thank you so much! \ud83d\udcaf . Any updates? :). \ud83c\udf89. ",
    "yood": "You're right, I was confused about promises. They start their work when constructed, so every promise is either executing/pending or resolved.\nI'll keep using when(fulfilled:concurrently:), though it's a bit awkward with the generator.. Hey, what's that variant of when you were talking about?. Haha thanks, but I'll stick to the generator. This is too clever for me.. ",
    "victoraraujo01": "recoverwas exactly what I needed! Don't know why I overlooked it when I read the documentation. Thank you very much for the answer!. ",
    "davidmurray": "Ah, I see.\nThanks for the heads-up!. Deleting Xcode derived data fixed this issue.. ",
    "petegerhat": "That's something I realized, but CocoaPods will not install higher version of PromiseKit, perhaps PromiseKit-AFNetworking requires PromiseKit 3 ?\nHere is my pod configuration\npod 'NUI',:git => 'https://github.com/peantunes/nui.git'\n  pod 'MBProgressHUD'\n  pod 'CocoaLumberjack'\n  pod 'AFNetworking'\n  pod 'PromiseKit'\n  pod 'PromiseKit-AFNetworking'. As mentioned in previous post, my solution consisted of removing 'PromiseKit-AFNetworking' (requires PromiseKit) 3 from list of pods.. ",
    "nikhilwhizdhavale": "But I get the following error when using xcode 8.3. \nI get complier error Module compiled with Swift 3.0.2 cannot be imported in Swift 3.1: .../Carthage/Build/iOS/PromiseKit.framework/Modules/PromiseKit.swiftmodule/x86_64.swiftmodule\nDo I need to use older version of Xcode. If you have multiple Xcodes in your mac you might face the problem. Check the Xcode build version\nxcodebuild -version.. use the command  xcodebuild -version on terminal to check. Then goto Xcode check location what is the command line tool selected. Select the correct one i.e. the version of Xcode used by you. Actually promise kit is used in one of the library in signal. When I open the project in Xcode 8.2 it works but in Xcode 8.3 it doesnt work. I did clean build etc.... What am I missing ?. I might do that but in their doc it mentions I should not do that https://github.com/WhisperSystems/Signal-iOS/blob/master/BUILDING.md. For now I am using Xcode 8.2 to solve the problem.. Even If I take a sample project in Xcode 8.3 and try what you want to try I get same. Error it would be great if you could build it in Xcode 8.3. The problem was solved by checking the xcodebuild -version.i.e. command line tool. It was lower to Xcode 8.2.1. ",
    "girees": "I am also facing same problem.could you please give any solution to achieve this one.Thanks in advance  . I deleted my previous Xcodes but still i am facing same problem. I am using AFNetworking-Promise kit frame work for web services calling.. ",
    "JaviLorbada": "Thanks @mxcl! Fantastic work for the promises! I will look into CI options to automate this :). @mxcl I'm not sure if an update to the README with some instructions about docker-compose is required.\nAlso, I tried to keep it simple for now, so the in docker-compose and travis.yml files the swift image version it is specified, currently swift:3.1, and Travis uses Ubuntu 14.04. \nLet me know if we want to expand on that.. ",
    "balraj-hike": "@mxcl - Just a query in your code the next call is made when the response of the previous calls come but actually i need to make the next call irrespective of previous response or not. And how can i make this thread safe as x can be called by multiple response thread?. Hey @mxcl thanks for your comment and i am sorry if I am not able to explain this properly. Let me try explaining question again:- \nThe above code that you have posted do take care about calling async func after every 1sec irrespective of whether the previous request has been answered or not. This is 1st requirement.\nThe second point to take care is: If any of the existing request which has been made gives a response of success. I need to stop all the recursive callbacks and send back Fulfilled with the result.\nThe third point is: After making all the calls over a duration of 5 secs. If all the responses comes back as failure then i need to send back reject with an error in it.\nIn the above code success is checked immediately after x == 5. Due to this we are not waiting for all the responses to comeback and then check if all responses are failure. This will satisfy 3rd point.\nAlso on success of even a single asyncoperation I need to  stop all the recursive callbacks and send back Fulfilled. This will satisfy 2nd point.\n. ",
    "startupthekid": "I would expect then to be called multiple times with value being of type T each time. The behavior I'm looking for is sort of a combination of race and when. Given a list of promises, as soon as each one resolves, send that value through the chain until they're all resolved.\nSo if I have two promises:\nswift\nlet promise1 = Promise(value: 1)\nlet promise2 = fetchNumberFromServer(2) // some async operation that resolves to an `Int` but not immediately\nmerge(promise1, promise2).then { value in \n    print(value)\n}\nIn this example, the output would be 1 and then 2 in succession as each one resolves. It's similar in behavior to ReactiveSwift's merge operator.. A more real example might be:\nswift\nlet promise1 = fetchFromCoreData()\nlet promise2 = fetchFromNetwork()\nmerge(promise1, promise2).then {}\nwhere one operation returns much quicker than the other but the results from both are still valid. It's like race but where every promise gets to finish.. I think it might go against the core nature of Promises since really what I need is more ReactiveSwift-esque where I can resolve things multiple times in a row.. I'll go ahead and close this, thanks!. ",
    "danielnakamashi": "Thanks a lot for your attention. I updated my project to Swift 3 and it worked perfectly.. ",
    "hengchengfei": "@mxcl Thank you,I really appreciate.. @QuentinArnault thank you.\n I updated the code,the imagePromise is changed. ",
    "QuentinArnault": "I guess this is not directly a PromiseKit. Compilation times go exponential if you chain generic functions that returns Promises.\nWith this function\nfunc genericPromise<T>(_ value: T) -> Promise<T> {\n    return Promise { fulfill, _ in\n        DispatchQueue.main.async {\n            fulfill(value)\n        }\n    }\n}\nI wrote 5 promises chains with 1, 2, 3, 4, 5 successive calls.\n```func testWith1GenericFunctions() {\n    _ = genericPromise(\"a string\").then {\n        print($0)\n    }\n}\nfunc testWith2GenericFunctions() {\n    _ = genericPromise(\"a string\").then {\n        return genericPromise($0)\n        }.then {\n            print($0)\n    }\n}\nfunc testWith3GenericFunctions() {\n    _ = genericPromise(\"a string\").then {\n        return genericPromise($0)\n        }.then {\n            return genericPromise($0)\n        }.then {\n            print($0)\n    }\n}\nfunc testWith4GenericFunctions() {\n    _ = genericPromise(\"a string\").then {\n        return genericPromise($0)\n        }.then {\n            return genericPromise($0)\n        }.then {\n            return genericPromise($0)\n        }.then {\n            print($0)\n    }\n}\nfunc testWith5GenericFunctions() {\n    _ = genericPromise(\"a string\").then {\n        return genericPromise($0)\n        }.then {\n            return genericPromise($0)\n        }.then {\n            return genericPromise($0)\n        }.then {\n            return genericPromise($0)\n        }.then {\n            print($0)\n    }\n}\n```\nCompilation times are:\n- testWith1GenericFunctions: 29 ms\n- testWith2GenericFunctions: 7 ms\n- testWith3GenericFunctions: 50 ms\n- testWith4GenericFunctions: 450 ms\n- testWith5GenericFunctions: 3276 ms\nSo I think that there is no bugs in PromiseKit, I just would like to have advice on how to optimise this situations with a readable solution.\nPromiseTestCompilationTime.zip\n. Indeed, with this function\n```\nfunc testWith5GenericFunctionsWithReturnTypes() {\n    _ = genericPromise(\"a string\").then { value -> Promise in\n        return genericPromise(value)\n        }.then { value -> Promise in\n            return genericPromise(value)\n        }.then { value -> Promise in\n            return genericPromise(value)\n        }.then { value -> Promise in\n            return genericPromise(value)\n        }.then { value -> Void in\n            print(value)\n    }\n}```\nCompilation time goes down from 3240ms to 21ms.\nThanks.. I'll try with swift 4 if the problem is still present. But maybe it is unavoidable, genericity has a price.. Actually this a normal behavior. There is no when signature which allow a uniq Promise (seen when.swift file.\nInstead, you can use directly your imagePromise variable.. The custom solution seems good to me. Thanks.\nIn my case, I will extract show and dismiss in another object (like a Coordinator) in order to remove navigation logic from view controller.\nAnd thanks for PromiseKit, I love this tool. \u2764\ufe0f . ",
    "maguro": "Maybe changing the deprecation comment to\n\"Use after(seconds: TimeInterval) or after(interval: DispatchTimeInterval)\"\n\nJust a thought.  With that said, reverting the change back to after(interval: TimeInterval) wfm.  I just thought that it was more concise/consistent. . ",
    "skk2142": "this is an awesome library. . yes, I was making a stupid mistake. Thanks for getting back to me. . ",
    "acecilia": "So, if I understand correctly:\n- Some more context: in this concrete case, I am experiencing an SSL pinning error coming from TrustKit (As explained here: https://github.com/datatheorem/TrustKit/issues/39)\n- This cancel error coming from TrustKit is wrongly identified by PromiseKit as a cancelation order (line 131 of the second screenshot I uploaded. NSURLErrorDomain, -999)\n- My catch is not being called due to this.\nRight?. So, after reading and testing it, the solution is to use .catch(policy: .allErrors) instead of just .catch\nThank you very much!. And now I am thinking: is the policy of \"not catching cancelation by default\" the best one?\nBecause I am using TrustKit, I found myself changing all .catch in my app to .catch(policy: .allErrors) so I am sure all my flows work as expected (even when there is an SSL pinning error). I can imagine many apps using PromiseKit+TrustKit. Will it make sense to capture cancelation by default? Why cancelation is not capture by default?\nFor the record: other approach is to change the cancelation NSError to a custom type, for example an error enum called \"networkCancellation\", and reject with that. So PromiseKit catches it, but you can still say that there was a cancelation error.\nThanks!. Yes, that NSURLErrorCanceledError was consider as a promise cancelation was a surprise for me. I was expecting that a reject() would lead to a catch in each an every case, until now. \nIn my mind I was sure that the code could only outcome with fulfill() [normal flow] or reject() [catch flow]. But knowing that cancelation is not catched by default, means that to be sure that all flow cases are covered I have to implement the behavior for fulfill() [normal flow], reject() [catch flow] AND cancelation: using recover [recover flow].\nI would prefer that cancelation is catched by default, leading to two possible flows. But of course the implementation is as it is for some good reasons. \nThis was just an idea you may consider.. Is there any more information about the issue? What I conclude after googling for a while is that we need to stick to fulfill(()). Ugly.. ",
    "dgaedcke": "Why would I use join instead of just fulfill?  Can you show an example?\nI've also been looking for docs re: dangers/best practices for saving a pending promise in an instance variable.    I have a Social login SDK that opens the Facebook App & asks the user to authenticate, and then returns the results to my AppDelegate external URL handler.   It's after that callback from the URL handler that I want to either fulfill or reject my stored promise... sure....if it's going away, I don't need to understand it....\nthat \"pending\" pattern makes much more sense to me anyway...\nat least the way I've been using it....but your example is quite a bit more concise....\nI think (line #2) is saying:\nif \"promise\" succeeds, then \"foo\" succeeds, else \"foo\" fails\nthis teaches me something....so you can pass the completion functions any place another promise is expected...... nevermind ... user error;  it seems the version in our Framework had been inadvertently upgraded to 6.2.8. ",
    "sidmani": "Thanks. I'll just put them in the completion handlers, then.. ",
    "DrAma999": "I will give a try.\nThank you,\nAndrea. I've added few features, but before making any PR, I'd like to receive your blessing.\nFirst the race function:\n```\nAnyPromise *PMKAfter(NSTimeInterval duration) {\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n        dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));\n        dispatch_after(time, dispatch_get_global_queue(0, 0), ^{\n            resolve(@(duration));\n        });\n    }];\n}\nThen I've seen that the `PMKAfter`when it has success returns the value of the time. Since my need is to catch an error if the timeout happens I've created `PMKTimeout`\nAnyPromise *PMKTimeout(NSTimeInterval duration) {\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n        dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));\n        dispatch_after(time, dispatch_get_global_queue(0, 0), ^{\n            resolve([NSError errorWithDomain:PMKErrorDomain code:PMKTimeoutError userInfo:@{NSLocalizedDescriptionKey: @\"PMKTimeout\"}]);\n        });\n    }];\n}\n```\nAfter that I thought that could be better have a promise that already executes using a timeout, this one I still didn't test.\n```\nAnyPromise PMKTimeoutExec(NSTimeInterval duration, AnyPromise * promise) {\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n        dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));\n        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n        // create timer\n        dispatch_async(queue, ^{\n            dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n            // Esegui la promises\n            [promise __pipe:^(id value){\n                if (IsError(value)) {\n                    NSMutableDictionary userInfo = [NSMutableDictionary dictionaryWithDictionary:[value userInfo] ?: @{}];\n                    [userInfo setObject:value forKey:NSUnderlyingErrorKey];\n                    id err = [[NSError alloc] initWithDomain:[value domain] code:[value code] userInfo:userInfo];\n                    resolve(err);\n                } else {\n                    resolve(value);\n                }\n                dispatch_semaphore_signal(semaphore);\n            }];\n            long timeout = dispatch_semaphore_wait(semaphore, time);\n            if (timeout != 0 ) {\n                resolve([NSError errorWithDomain:PMKErrorDomain code:PMKTimeoutError userInfo:@{NSLocalizedDescriptionKey: @\"PMKTimeout\"}]);\n            }\n        });\n    }];\n}\nHere I've used a semaphore, but since I'm not totally aware about how queues are used I have some concern about blocking everything in the global queue. Maybe it would be better to implement it using a timer.\nAnyPromise PMKTimeoutExec(NSTimeInterval duration, AnyPromise * promise) {\n    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n        dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));\n        // create timer\n        dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));\n        if (timer) {\n            dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, time, (1ull * NSEC_PER_SEC) / 10);\n            dispatch_source_set_event_handler(timer, ^{\n                resolve([NSError errorWithDomain:PMKErrorDomain code:PMKTimeoutError userInfo:@{NSLocalizedDescriptionKey: @\"PMKTimeout\"}]);\n            });\n            dispatch_resume(timer);\n        }\n        // Esegui la promises\n        [promise __pipe:^(id value){\n            dispatch_source_cancel(timer);\n            if (IsError(value)) {\n                NSMutableDictionary userInfo = [NSMutableDictionary dictionaryWithDictionary:[value userInfo] ?: @{}];\n                [userInfo setObject:value forKey:NSUnderlyingErrorKey];\n                id err = [[NSError alloc] initWithDomain:[value domain] code:[value code] userInfo:userInfo];\n                resolve(err);\n            } else {\n                resolve(value);\n            }\n        }];\n    }];\n}\n. yeah! now that you are pointing that out they are completely useless.. @josejulio \nThis is untested because we had proceeded in another way, but as far as I remember it was working.\nAnyPromise PMKRace(NSArray promises) {\n    if (promises == nil)\n        return [AnyPromise promiseWithValue:[NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:@{NSLocalizedDescriptionKey: @\"PMKRace(nil)\"}]];\nif ([promises isKindOfClass:[NSArray class]]) {\n    if ([promises count] == 0)\n        return [AnyPromise promiseWithValue:promises];\n} else if ([promises isKindOfClass:[AnyPromise class]]) {\n    promises = @[promises];\n} else {\n    return [AnyPromise promiseWithValue:promises];\n}\n\nreturn [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {\n    [promises enumerateObjectsUsingBlock:^(AnyPromise *promise, NSUInteger index, BOOL *stop) {\n        if (![promise isKindOfClass:[AnyPromise class]])\n            promise = [AnyPromise promiseWithValue:promise];\n        [promise __pipe:^(id value){\n            if (IsError(value)) {\n                NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithDictionary:[value userInfo] ?: @{}];\n                userInfo[PMKFailingPromiseIndexKey] = @(index);\n                [userInfo setObject:value forKey:NSUnderlyingErrorKey];\n                id err = [[NSError alloc] initWithDomain:[value domain] code:[value code] userInfo:userInfo];\n                resolve(err);\n            }\n            else {\n                resolve(value);\n            }\n        }];\n        (void) stop;\n    }];\n}];\n\n}\n```\n. ",
    "wfilleman": "Thanks mxcl! That explains other behavior I'm seeing in Swift 4 as well. For those reading, it appears the Swift team has announced that it's backing out of the change in Swift 4 that is causing this: https://lists.swift.org/pipermail/swift-evolution-announce/2017-June/000386.html. ",
    "nalexander50": "Still running into this problem on the Xcode 9 GM candidate so it seems that this has not been rolled back from Swift 4. Would it be possible to get the fix placed in a branch for Cocoapods users? It's feels dirty having to unlock the framework and make the change manually.. Yeah, I\u2019m getting a compilation error. I thought this was the same issue. I\u2019ll create a new issue with details. . @mxcl, sorry about that. Sat down for dinner and this slipped my mind. It actually seems to have cleared itself up. Looking at the source code here on GitHub, I see the exact change that I had to make to force it to compile. I had added PromiseKit to my Podfile a while ago (couple months). I'm thinking that I was just working off of a cached version of the Pod without the Swift 4 fix. Thanks for the followup.. I found in the source code that the execute body: () throws -> Promise<T>) -> Promise<T> overload of promise on DispatchQueue is marked unavailable due to Swift compiler issues.\nThis throws a pretty big wrench into my chain because my server call already returns Promise<String>, since we don't know when the server call will resolve.\nThis is the code that I want to write:\n```\nLoadingViewHelper.present(overView: self.view, labelText: \"Creating...\")\nlet username = self.usernameTextField.text!\nlet parametersDictionary = self.generateUserCreationParameters()\nDispatchQueue.global(qos: .background).promise {\n    self.createUser(newUserParametersDictionary: parametersDictionary) // Server POST -> Promise\n}\n.then(on: DispatchQueue.global(qos: .background)) {\n    self.createNewUserSession(username: username, token: $0) // Server GET -> Promise\n}\n.then {\n    Session.current = $0 // Void\n}\n.always {\n    LoadingViewHelper.dismiss() // Void\n}\n.then { _ -> Void in\n    // navigation stuff\n}\n.catch { (error) in\n    // error stuff\n}\n```\nHowever, this chain does not compile due to 'promise(group:qos:flags:execute:)' is unavailable. The source comments mention Swift compiler issues being the reason.\nI suppose for now I will just keep using the chain I had in the original post. It worked and doesn't seem to be an egregiously bad solution. Though, I would prefer to use the chain in this post since it's easier to reason about.\nI don't think that I have a fundamental mis-usage of Promises here. If I do, please let me know. This is my first foray into the world of Promises.. ",
    "cvoisey": "I'm definitely interested in progress on this.  I see a path to PromiseKit 5, however those links don't go anywhere yet.  I'm very anxious to get my app working on the iPhone X before it gets released, so the only way to do this is to be able to compile and run it, with its dependencies to PromiseKit in Xcode 9.   I've been unsuccessful in any of my experiments to get this working either.  . ",
    "jankaltoun": "Thank you for the info! \ud83d\ude42 . ",
    "PaulRBerg": "Nevermind. Deleted the derived data as suggested in #689 and it worked.. ",
    "queeeentin": "I have fixed it by dragging the Pod.xcodeproject to the Pods directory. But I am still having a problem as shown below:\n\nwill you happen to know how to fix it?\n . here is the message:\nShowing Recent Issues\nLd /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/MyAppTests.xctest/MyAppTests normal x86_64\n    cd /Users/user/Desktop/MyApp\n    export IPHONEOS_DEPLOYMENT_TARGET=10.3\n    export PATH=\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch x86_64 -bundle -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator10.3.sdk -L/Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Products/Debug-iphonesimulator -F/Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Products/Debug-iphonesimulator -F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Frameworks -filelist /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Intermediates/MyApp.build/Debug-iphonesimulator/MyAppTests.build/Objects-normal/x86_64/MyAppTests.LinkFileList -Xlinker -rpath -Xlinker @executable_path/Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -mios-simulator-version-min=10.3 -dead_strip -bundle_loader /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Products/Debug-iphonesimulator/MyApp.app/MyApp -Xlinker -object_path_lto -Xlinker /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Intermediates/MyApp.build/Debug-iphonesimulator/MyAppTests.build/Objects-normal/x86_64/MyAppTests_lto.o -Xlinker -export_dynamic -Xlinker -no_deduplicate -Xlinker -objc_abi_version -Xlinker 2 -fobjc-link-runtime -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator -Xlinker -add_ast_path -Xlinker /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Intermediates/MyApp.build/Debug-iphonesimulator/MyAppTests.build/Objects-normal/x86_64/MyAppTests.swiftmodule -framework XCTest -Xlinker -sectcreate -Xlinker __TEXT -Xlinker __entitlements -Xlinker /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Intermediates/MyApp.build/Debug-iphonesimulator/MyAppTests.build/MyAppTests.xctest.xcent /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Products/Debug-iphonesimulator/PromiseKit/PromiseKit.framework/PromiseKit -Xlinker -dependency_info -Xlinker /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Intermediates/MyApp.build/Debug-iphonesimulator/MyAppTests.build/Objects-normal/x86_64/MyAppTests_dependency_info.dat -o /Users/user/Library/Developer/Xcode/DerivedData/MyApp-hdbqgokcmjrkhjbktlbrgqjuvcfk/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/MyAppTests.xctest/MyAppTests\nld: framework not found PromiseKit for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n\n. I have done the what you said, but same error is still showing. \nPlease note that the error is occuring in the UnitTest file, not in the app level (The App run normall, just the Unit test not running) Please refer to the test example below. \n\n. ",
    "alastaircoote": "I have this same issue, but my project builds (and runs) fine. Yet Xcode 9 (beta 5) syntax/error highlighting continues to show that Promise isn't defined. Is there any useful debug info I can provide?\n(FYI, I'm using Carthage to manage my dependencies). ",
    "itanchao": "```Ruby\nsource 'https://github.com/CocoaPods/Specs.git'\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'PromiseKitTest' do\npod 'Alamofire', '4.4.0'\npod 'PromiseKit', '~> 4.0'\n\nend\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        target.build_configurations.each do |config|\n            config.build_settings['SWIFT_VERSION'] = '3.0'\n        end\n    end\nend\n```\nOK\uff0cI try this then it works. ",
    "corysullivan": "Ahh cool and thanks for all your great work!. Perfect! Thank you.. ",
    "Narsail": "Ah that helps. Thanks for your fast response!. ",
    "nathan-inge": "PromiseKit Version: 4.5.0\nCocoapods Version: 1.2.1\nXcode Version: 9.2\n@mxcl I am in the middle of migrating my project to Swift 4. \nOriginally I was trying to do:\npod 'PromiseKit/UIKit', '~> 4.5'\nBut then tried (as per your suggestion):\npod \"PromiseKit\", \"~> 4.5\", subspecs: ['CorePromise']\nHowever I am still getting just the two errors mentioned above:\nMissing argument for parameter #1 in call\nand \nContextual closure type '() -> Void' expects 0 arguments, but 1 was used in closure body\nAm I skipping over something or has this bug not been addressed in the UIKit extension? \n. Thank you for the quick response. I tried using \nfirstly { () -> Promise<JSON>\nand that seemed to do the trick. In the future I will definitely remember to try putting the code in the closure outside the closure to debug as well. \nThank for your time, I appreciate it!. ",
    "faimin": "if you set swift_version to 4.x, you should use the Xcode 9.x +, Xcode 8.x not contain Swift 4.x environment. you can try to look over the current swift version in your system by commond xcrun swift -version, \nand make sure have swift4.x environment, or use swiftenv library to control the swift version.. ",
    "joaomvfsantos": "Yes, I'm using XCode 9, as stated in my first post. The thing is when I do pod install, with swift_version = \"4.0\" in my podfile, the Pod PromiseKit framework is always using 3.2 instead.. ",
    "jaz-ah": "i had to clean out my derived data, etc.. and then it all worked fine thx @mxcl . ",
    "repomies": "Well, now after some pod reinstallations and rebuilds it seems to work again (in 4.4.0).. Thanks, your Troubleshooting guide sure helped me to understand the issue. Deep in the codebase I found this piece that was the culprit:\nif let error = error {\n    reject(error)\n} else if let json = json {\n    fulfill(json)\n}\n(And the real reason why it appeared now was my JSON parser's changed behavior and newly introduced failabilities.). ",
    "clarkcox3": "As I understand it, you cannot. A promise is meant to be fulfilled once, and only once.. ",
    "hashemp206": "so how PromiseKit observes object properties with KVO?\ndoes something like this works with PromiseKit? \nbecause by scrolling scroll view, content offset changes rapidly\n``` swift\n _ = collectionView.observe(keyPath: #keyPath(UIScrollView.contentOffset)).then { [unowned self] (newValue: CGPoint) -> Void in\nprint(\"change happened\")\n            }\n```\ndo you have any idea how can I overcome this issue? this is a big problem for me! because in my code there are a lot of dependent asynchronous tasks, which without PromiseKit, is too hard to maintain! . so it seems is not possible.\ud83d\ude41\nHere I don't have a property to observe and use KVO. instead Firebase just observe a DatabasePathReference for value changes and then call its completion block multiple times. \n```Swift\nprivate func getUserChatIds() -> Promise<[String]> {\n    let userChatIDsRef = Database.database().reference()\n        .child(FireDatabasePaths.UserInfoPath.rawValue)\n        .child(userID).child(\"chatIDs\")\n\n    return Promise { fulfill, reject in\n\n        userChatIDsRef.observe(.value, with: { snapshot in\n\n            if let chatIDdic = snapshot.value as? [String: AnyObject] {\n                let keys = Array(chatIDdic.keys)\n                fulfill(keys)\n            } else {\n                reject(FirebaseError.empty)\n            }\n\n        })\n    }\n}\n\nfunc fetchChatSummaryList() -> Promise<[ChatSummary]> {\n        return getUserChatIds().then { chatIDs in\n            self.fetchChatSummaryList(from: chatIDs)\n        }\n   }\n```\nin this scenario I converted it to use completion block, but it makes my code ugly. \nwhat would you do in this case?\nif there is no good solution you can close the issue.\n. Thanks for update. the new FAQ update has typo. please check\nwithout using Promises Firebase absolutely needs a solution. \nhow can I write a wrapper around Firebase to do multiple event chaining ?. I have the same issue:\nfunc searchMovies(withSearchTerm searchTerm: String, page: Int) -> Promise<[Movie]>\n    {\n        return wrap {\n            popcornApi.search(withQuery: searchTerm, page: page, completion: $0)\n            }.then { [weak self] movies -> Promise<[Movie]> in\n                // if search query had some result, store the successfull search term\n                if page == 1 && movies.isEmpty == false {\n                    // store new successfull search term\n                    self?.store(newSearchTerm: searchTerm)\n                }\n                return Promise(value: movies)\n        }\n    }\nif remove this part it works else it says ambiguous use of wrap\nif page == 1 && movies.isEmpty == false {\n                    // store new successfull search term\n                    self?.store(newSearchTerm: searchTerm)\n                }\nSwift 4.1. @mxcl Can you explain more? It was working in Swift 4.0\nBy reading troubleshooting guide, if I move code to inline function, it works.\nIt seem it resists the code in then block must to be one line.\ndo you have any idea? . simple and concise \ud83d\ude01\ud83d\udc4f. ",
    "SandroMachado": "Because I have a library that supports Carthage and CocoaPods and uses PromiseKit as dependency and it would be great to have the same dependencies versions.. git checkout 4.1.8\npod trunk push PromiseKit.podspec\nThis should work, right?\nThanks, I will wait \ud83d\udc4d . @mxcl Thanks \ud83d\udc4d . ",
    "mteece": "@mxcl Many thanks!. ",
    "SudoPlz": "Long story short, add the following to your pod file:\n```\nforce the sub specs in the array below to use swift version 3.2\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        if ['PromiseKit'].include? target.name\n            target.build_configurations.each do |config|\n                config.build_settings['SWIFT_VERSION'] = '3.2'\n            end\n        end\n    end\nend\n\n```. That's not an option I have, because of https://github.com/invertase/react-native-firebase/issues/1106#issuecomment-405030305\nOn the mean time, looks like adding a dummy (empty) swift file in the xcode project fixes those issues, I saw that here\n\u00af\\_(\u30c4)_/\u00af. ",
    "bmwalters": "Some additional information for future reference: https://twitter.com/UINT_MIN/status/917518438003703808\nThe failure is due to importing PromiseKit's generated Swift header within PromiseKit here.\nApparently this \"isn't supported\", but it's a bug in the build system that the error message isn't explicit about it.\nThis is documented here in the developer documentation; scroll to \"Referencing a Swift Class or Protocol in an Objective-C Header\".\nCould the categories in AnyPromise.h potentially be rewritten in Swift to avoid this behavior?\n  . ",
    "jgavris": "Just curious, since I (we) are very eager to try out the new build system (Swift is so slow!), is anyone trying to tackle this? I haven't dug into how this project is structured too deeply, but maybe clever use of a submodule / subframework could sidestep this issue?. I don't understand why Carthage is relevant here...the cycle is actually within PromiseKit itself right? . The issue is that PromiseKit imports its own bridging header, which is not supported by the new build system. It fails to report this condition correctly though in Xcode 9.2. \nhttps://github.com/mxcl/PromiseKit/blob/2df8580c927fe2fb173f489c1e2e7df4ff880976/Sources/AnyPromise.h#L10. \ud83c\udf89  @mxcl will you be pushing a new podspec today?. ",
    "Joshandrews43": "Still getting this issue with PMK 6.2.1. Any ideas?\n. ",
    "damianfitpotato": "@mxcl Hi Max, thanks for taking the time to reply, I really appreciate it. I tried what you suggested, as per below.. but the issue still remains. I debug this and the code never reaches any lines after the requestAttributionDetails() call.\nI have also tested the same thing with one of our own api calls, using AlamoFire and PromiseKit and with the High Latency DNS profile, it comes back after about 10 secs - no issues. \nBut when using Apple's ADClient.shared().requestAttributionDetails() we are seeing the Pending Promise deallocated! This is usually a bug message multiple times, within about 5 seconds of the call.\nI wonder if there is some DNS timeout whereby iOS cancels the request if it can't resolve a domain name within a certain time, and this somehow doesn't propagate through and the Promise just gets deallocated? Or if there is something else at play... \n2017-10-14 18:57:54.110485+1100  [MC] Loaded MobileCoreServices.framework\n2017-10-14 18:58:01.372098+1100  PromiseKit: Pending Promise deallocated! This is usually a bug\n2017-10-14 18:58:01.372306+1100  PromiseKit: Pending Promise deallocated! This is usually a bug\n```swift\n    func getSearchAdsInfo() -> Promise> {\n        return Promise { fulfill, reject in\n            ADClient.shared().requestAttributionDetails({ (attributionDetails, error) in\n            if attributionDetails == nil {\n                reject(PMKError.nilPromisable)\n            } else if error == nil {\n                for (type, adDictionary) in attributionDetails! {\n                    let attributionDictionary = adDictionary as! Dictionary<AnyHashable, Any>\n                    fulfill(attributionDictionary)\n                }\n            } else if error != nil {\n                reject(error!)\n            } else {\n                reject(PMKError.nilPromisable)\n            }\n        })\n    }\n}\n\n```. Thanks again for taking time to look into this! I have tried this, but the issue still remains...\nI am not sure if this is relevant, but we may not be using the same version of Swift+PromiseKit\nMy PromiseKit doesn't have PMKError.invalidCallingConvention\nI can only set one of these:\npublic enum PMKError: Error {\n        case navigationControllerEmpty\n        case noImageFound\n        case notPromisable\n        case notGenericallyPromisable\n        case nilPromisable\n    }\nAlso, attributionDetails.values() did not compile (had to remove the parentheses)\nswift\n    func getSearchAdsInfo() -> Promise<[AnyHashable: Any]> {\n        return Promise { fulfill, reject in\n            ADClient.shared().requestAttributionDetails{ attributionDetails, error in\n                if let attributionDetails = attributionDetails {\n                    for case let value as [AnyHashable: Any] in attributionDetails.values {\n                        return fulfill(value)\n                    }\n                    reject(PMKError.nilPromisable)\n                } else if let error = error {\n                    reject(error)\n                } else {\n                    reject(PMKError.notPromisable)\n                }\n            }\n        }\n    }. Cool thanks again for looking into it, I had a feeling it was an issue with Apple's requestAttributionDetails function.. Hi Max, in that part of the code, there is no other promise being called so nothing other than Apple's function. When I try the same test using one of our own functions that uses a Promise it works fine. But in this case where the Apple function is wrapped in a Promise, this issue is happening.\nI will see if I can isolate this into a simple one-file project and replicate just to be sure though. I too don't think it is a PromiseKit issue, I thought I may have been using PromiseKit wrong. But given this now seems unlikely, I will see if I can figure it out elsewhere.\nThanks again for your feedback and advice.. ",
    "udaypatial": "URLSession. ",
    "saagarjha": "As you can see by the tardiness of my replies I'm not really in a rush here.. Thanks!. ",
    "karosLi": "@mxcl hello, here is the cocoa pod detail info for static framework pod with swift source: https://github.com/CocoaPods/CocoaPods/pull/6811. Is there any reply?. ",
    "ataibarkai": "FYI, cocoapods 1.4.0 is officially out. They describe static framework support in the release post\nhttp://blog.cocoapods.org/CocoaPods-1.4.0/\n. ",
    "AnthonyUccello": "@mxcl \n\n\nInstallation method with both pods and manually failed. Regarding manually I tried linking the .framework file .and the xcodeproj itself. All fail the same way. I would put the .xcodeproj as a nested or top level workspace module. I would also try adding the .framework to the embedded frameworks and/or linked binaries and doesn't work. Sometimes I get the 4 error messages, but if it compiles I get the crash.\n\n\nPlatform target:\niOS 11. All devices fail (iPhone 6, iPhone 7). @mxcl Whenever I add the framework to the embedded frameworks and compile I get this error:\nextracting arm64 from PromiseKit\nfatal error: lipo: input file (/Users/auccello/Library/Developer/Xcode/DerivedData/ACSolution-ayflqupzywrptognbvuwwkmjssfk/Build/Products/Debug-iphoneos/App.app/Frameworks/PromiseKit.framework/PromiseKit) must be a fat file when the -extract option is specified\nMerging extracted architectures: arm64\nfatal error: lipo: can't open input file: /Users/auccello/Library/Developer/Xcode/DerivedData/ACSolution-ayflqupzywrptognbvuwwkmjssfk/Build/Products/Debug-iphoneos/App.app/Frameworks/PromiseKit.framework/PromiseKit-arm64 (No such file or directory)\nrm: /Users/auccello/Library/Developer/Xcode/DerivedData/ACSolution-ayflqupzywrptognbvuwwkmjssfk/Build/Products/Debug-iphoneos/App.app/Frameworks/PromiseKit.framework/PromiseKit-arm64: No such file or directory\nReplacing original executable with thinned version\nmv: rename /Users/auccello/Library/Developer/Xcode/DerivedData/ACSolution-ayflqupzywrptognbvuwwkmjssfk/Build/Products/Debug-iphoneos/App.app/Frameworks/PromiseKit.framework/PromiseKit-merged to /Users/auccello/Library/Developer/Xcode/DerivedData/ACSolution-ayflqupzywrptognbvuwwkmjssfk/Build/Products/Debug-iphoneos/App.app/Frameworks/PromiseKit.framework/PromiseKit: No such file or directory. Ok it turns out when I actually was able to embed the framework it works.\n\n\nThere was a bad run script causing some sort of corruption which was preventing this (causing the error posted right above).\nWhen I removed the run script and embedded the framework it works.. ",
    "dianapetrea91": "Thank you for pointing me in the right direction!\nThis is what I ended up using (in case it might help someone else):\n```\nfunc myFunc(info: Info) -> Promise<()>\n{\n    return Promise { fulfill, reject in\n    let firstPromise = shouldShowFirstPopup ? showFirstPopup() : Promise(value: info.info1)\n\n    firstPromise\n    .then { info1 -> Promise<Info2> in\n        info.info1 = info1\n\n        if (info.shouldShowSecondPopup) {\n            return showSecondPopup()\n        }\n\n        return Promise(value: info.info2)\n    }\n    .then { info2 -> Promise<Info3> in\n        info.info2 = info2\n        info.shouldShowSecondPopup = false\n\n        if (info.shouldShowThirdPopup) {\n            return showThirdPopup()\n        }\n\n        return Promise(value: info.info3)\n    }\n    .then { info3 -> Promise<()> in\n        info.info3 = info3\n        info.shouldShowThirdPopup = false\n\n        return processEverything()\n    }\n    .then { _ -> () in\n        fulfill(())\n    }\n    .catch { error in\n        switch error {\n            case MyErrors.backPressed(let popupType):\n                switch popupType {\n                    case .firstPopup:\n                    reject(MyErrors.userCanceled)\n                    return\n\n                    case .secondPopup:\n                    info.shouldShowFirstPopup = true\n                    info.shouldShowSecondPopup = true\n\n                    case .thirdPopup:\n                    info.shouldShowSecondPopup = true\n                    info.shouldShowThirdPopup = true\n\n                    default:\n                    reject(MyErrors.defaultError(message: \"Not implemented case exception\"))\n                    return\n                }\n\n                firstly {\n                    return myFunc(info: info)\n                }\n                .then { _ -> () in\n                    fulfill(())\n                }\n                .catch { error2 in\n                    reject(error2)\n                }\n\n            default:\n            reject(error)\n        }\n    }\n}\n\n} \n```. ",
    "lucabartoletti": "Yes, you are right, running pod update after turning on Allow app extension API only in my project did the trick.\nThanks @mxcl . ",
    "jyounus": "Thanks. ",
    "randy68040": "deletes needs to be  array of Promise ... error from the xcode build log:\nerror: cannot convert value of type '[Promise]' to expected argument type '[Promise]'\n            return when(fulfilled: deletes)\n. sorry, copy and paste was not so good. Here is exact error from xcode build log (deletes has skwiggely underlined):\ncannot convert value of type '[Promise]' to expected argument type '[Promise]'\nreturn when(fulfilled: deletes). How we fixed it:\nlet deletes = deletingJobs.map { (job : ENTJob) -> Promise<Void> in\n                Promise { fulfill, reject in\n                    job.delete()\n                }\n            }\n             return when(fulfilled: deletes). Thanks -- i should have tried that.. Yes, that fixed it.. still get the same error though have update the 3 lets as follows:\nlet getJobtype: Promise<ENTJobType> = job.jobType.resolve.asPromise(type: ENTJobType.self)\n        let getEncounter: Promise<ENTEncounter> = job.encounter.resolve.asPromise(type: ENTEncounter.self)\n        let getQueue: Promise<ENTQueue> = job.queue.resolve.asPromise(type: ENTQueue.self)\nI am swift 3 newbie -- ... my favorite upgrade to swift 3 error description: expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions. . final correction: \nwhen(fulfilled: getJobtype, getEncounter, getQueue).then. ",
    "Kaspik": "Okay, no worries, thanks. :). Ohh very nice @abl ! \ud83d\ude80 . @mxcl Well definitely because I searched for done(on:flags:_:) and didn't find anything there and because hint that you have not handled the error means you have to handle error even tho done() doesn't throw error - so done() could be @discardableresult - and that was the point... :)\nAnyways thanks again. :). It's not really CocoaPods' fault, it's XCode that recognises that you use Swift 4.0 code there (which is true even tho you have condition there.)\nI would probably suggest either using only PromiseKit Core (user) or removing the condition and having the library Swift 4.2 fully (you as an author of the library).\n(it doesn't mean that Swift 4 users can't install it, they still can use the library even if it's Swift 4.2).. > > I would probably suggest either using only PromiseKit Core (user)\n\nThis would have no impact on the warning since the warning is due to generated Xcodeproj specifying its Swift version as 4 (and not 4.2) and not containing the ignore-this-warning-flag and that is up to CocoaPods.\n\nUsing pod 'PromiseKit/CorePromise', '~> 6.3' means no warning in PromiseKit/UIKit so for user - it does fix the warning.\n\n\nhaving the library Swift 4.2 fully\n\nWe 100%, completely and totally support Swift 4.2 fully. 100%. Totally. Fully. Please don\u2019t think otherwise.\n\nSorry to not be clear - \"Having the library only Swift 4.2\" without #if swift(>=4.2) conditions is what I meant. :). ",
    "nitrag": "Correct:\nswift\nextension CollectionReference {\n    func addDocument(data: [String : Any]) -> Promise<DocumentReference> {\n        return Promise<DocumentReference> { resolve, reject in\n            var ref: DocumentReference? = nil\n            ref = addDocument(data: data) { error in\n                if let error = error {\n                    reject(error)\n                } else {\n                    resolve(ref!)\n                }\n            }\n        }\n    }\n}. Sorry, copy/paste error on my part. Also forgot to update pod for AlamofireKit, thanks for that.\nI still can't figure it out. The only difference is the complete() function which splits it out. How can I force the T to MYUser codable?\n```swift\n//Working\nfunc getUser( userId: String, completion: @escaping (MYUser?, Error?) -> Void) {\n    func complete( user: MYUser){\n        self.updateUserCache(user)\n        completion(user, nil)\n    }\n    Alamofire\n        .request(urlPath, method: .get, encoding: URLEncoding.default, headers: headers)\n        .responseDecodable(decoder: self.defaultDecoder).done{ user in\n            completion(user, nil)\n        }.catch{ error in\n            print(\"ERROR getUser: (error.localizedDescription)\")\n            completion(nil, error)\n    }\n}\n//Non-Working\nfunc getUser(_ userId: String, completion: @escaping (MYUser?, Error?) -> Void) {\n    Alamofire\n        .request(urlPath, method: .get, encoding: URLEncoding.default, headers: headers)\n        .responseDecodable(decoder: self.defaultDecoder).done{ user in\n             self.updateUserCache(user)\n             completion(user, nil)\n        }.catch{ error in              <<< Generic parameter 'T' could not be inferred\n            print(\"ERROR getUser: (error.localizedDescription)\")\n            completion(nil, error)\n    }\n}\n```\nAlso, removing the print():\n```swift\n}.catch{ error in\n      completion(nil, error)             <<< 'Error' is not convertible to 'Error?'\n}\n```\n. @mxcl Thanks for the quick replies and your awesome work on this project (and homebrew)!\nI'm not following the steps in your mention of Troubleshooting. How do I sepecify the type of user in done?\nSo I got the above example working by moving it to an internal function handler and reducing it to one line. Now I'm getting the same error for this one:\nswift\nfunc loginFacebook(_ accessToken: String, completion: @escaping (Bool, Error?) -> Void){\n        let urlPath = URL(string: self.endpoint + \"rest-auth/facebook/\")!\n        let parameters ...\n        func complete(){\n            print(\"Updating user\")\n            ...\n            completion(true, nil)\n        }\n        func completeError(_ error: Error){\n            completion(false, error)\n        }\n        Alamofire\n            .request(urlPath.absoluteURL, method: .post, parameters: parameters)\n            .responseCodable(decoder: self.defaultDecoder)\n            .then { me -> Promise<User> in\n                print(\"Setting user copy locally, Signing into Firebase\")\n                self.currentUser = me\n                return Auth.auth().signIn(withCustomToken: me.firebase_token!)\n            }.done { _ -> () in\n                complete()\n            }.catch{ error in            <<<Generic parameter 'T' could not be inferred\n                completeError(error)       \n        }\n    }\nBefore I added completeError() I was getting 'Error' is not convertible to 'Error?'. I can't follow either error and I've tried a lot of different permutations.\n. Thanks @nathanhosselton, @mxcl \nTurns out I had to apply that to not-only the .done but the initial .then as well. Perhaps because I've got several subclasses of User.. ",
    "Skornos": "@mxcl Thanks Max, I was just thinking about the same thing with the global promise but I was hoping that I am missing something. I'll go with the requests failing.. Understood, this totally makes sense. So I need to assign the value to listener only once but in the same time to keep it within the Promise? I am not sure I see the way out of this at the moment.. Closing the issue. It is caused by the calling function not returning the promise. ",
    "wqfan": "Hello Max,\nThanks for the response. It seems there is a problem with S3 SDK. All uploadings indeed happened but S3 returns the result of last uploading multiple times. I see multiple Finish one S3 is because the last one gets fulfilled multiple times instead of each one gets fulfilled.. ",
    "hamada147": "I found your detailed documentations. ",
    "nolanw": "Just in case anyone else wants to try out ~> 5.0 before it gets pushed to CocoaPods and tries to include a non-default subspec: you'll need to add submodules: true to your pod 'PromiseKit' line in your Podfile. Otherwise CocoaPods will silently fail to download and set up any of the subspecs.. CocoaPods 1.5 should (theoretically) enable this choice for the CocoaPods end-user instead of libraries having to choose one or the other. So I don't think there's anything for PromiseKit to do here.\n(Sorry for resurrecting a closed issue, it didn't seem worth opening a new one.). This seems to work ok as a replacement for line 1 of AnyPromise.m:\n```objc\nif __has_include(\"PromiseKit-Swift.h\")\n#import \"PromiseKit-Swift.h\"\n\nelse\n#import <PromiseKit/PromiseKit-Swift.h>\n\nendif\n```\nor at least it still builds ok when installed via CocoaPods both as a dynamic library and a static library.\nKinda ugly but honestly I'm a bit shocked it's the only change needed to get a static library building under CocoaPods. Happy to open a PR if this looks workable!. OK, I can confirm that\n```objc\nimport \"PromiseKit-Swift.h\"\n``\nfails when installed via Carthage. I can confirm that the__has_include` approach succeeds when installed via Carthage and when installed as dynamic and as static via CocoaPods.\nSorry for the rapid fire replies. I'm done for a little while :). Looks like someone beat me to it: https://github.com/CocoaPods/CocoaPods/issues/7594. ",
    "jsflax": "What is the estimated release date for 5.0 on CocoaPods?. Awesome, thanks for the quick response. What's the likelihood of the current API changing before release? We'd like to make our own major update and include 5.0.0 in our own library before the holidays, and it would be contingent on the current 5.0.0 API not changing.. ",
    "Meeks91": "I am using PromiseKit 5.\nFor anyone else with this issue you can fix it by using a pending promise.\n```\nfunc someMethod() -> Promise\nlet pendingPromise  = Promise.pending() \ndoAsynchronousWork() { error, value in\n   if let error = error {\n\n       pendingPromise.resolver.reject(error)\n }\n\nelse {\n\n      pendingPromise.resolver.fulfill(value)\n}\n\n}\nreturn pendingPromise.promise\n}\n```. ",
    "luke-gs": "Will do!. ",
    "martheli": "I am not sure how to get the same result with Promises. How would I control the Alamofire loop to make sure all of them finish before Promise returns without using dispatch group?. ",
    "Prince2k3": "I agree with this. I'd like to know what is new in PromiseKit 5.0 so that I can take advantage of the new features. If you need help updating the documentation I'm sure one of us can help do this so as not to take away from your time.. ",
    "pacification": "Try to return fulfill(()) for Promise<Void> statement.. ",
    "dboydor": "I actually looked through the closed tickets and code as well but I guess my searching foo isn't so good.  Thank you so much.  It's frustrating to learn Swift when the syntax changes from version to version!. ",
    "mayurdzk": "When the programmer writes the code:\nmyPromise.catch(on: myQueue1) {\n  // Block 1\n}.catch(on: myQueue2) {\n  // Block 2\n}\nthey probably expect Block2 to definitively run after Block1 (while honouring their choice of queues).\nEssentially,catchs should exhibit then-like serial execution behaviour.. Thanks for replying!\n\nIn PMK5 catch returns a special object (a PMKFinalizer) which you can call finally on (finally provides no object) but not catch, which IMO is the only correct behavior.\n\nMakes complete sense to me. Although this would mean source breaking changes for users who are using their promises in the promise.catch{...}.catch{...) fashion, if I'm not wrong? Just a thought.\n\nA work-around would be to use recover\n\nIn my case, I've already used a recover in my promise chain (don't know whether I can call a recover on a recover--haven't tried it). If you're curious, I'll explain the use case for my promise.catch{...}.catch{...) usage:\npromise.recover {\n  // Attempt to recover from a certain kind of errors\n}.catch {\n  // If error is `foo`: persist the error to a data store\n}\nThen in my tests:\n// Return a failed promise that has the error foo\npromise.catch {\n   // Verify error stored in persistent store == foo\n}\nHaving the catchs in concurrently executing blocks makes my test fail. I've found a workaround though.. > many, many source breaking changes, this is the least of them.\nAh, never mind then. Looking forward to it.\nThanks for your great work!. Hey @mxcl \nIn the commit that references this issue you write:\n\nfinally is the same as ensure, but it is not chainable\n\nHowever, there's another subtle difference between the two--ensure can be called on a DispatchQueue of a user's choice whereas finally can't. Am I correct in assuming that a user should resort to using ensure as a substitute for finally if they're interested in calling the closure on a specific queue? Also, I'm curious to know why finally has the limit of not being able to be called on any queue?\nThanks!. @mxcl Done: https://github.com/mxcl/PromiseKit/pull/876. @mxcl I've addressed the feedback.\nI don't have a way to check whether the CI tests pass/fail on Linux other than to wait for the results.\nAlso, let me know if we need to address the problem you mentioned... \n\nAlso the test didn't flag this, so we should make it so it does.\n\n...apart from just using the dispatchPrecondition(.onQueue(q)) check. (I'm not sure using just this precondition would ensure that a closure passed in the finally block truly is executed after every other closure in the promise chain. I'm open to adding more tests to validate this condition. Let me know your thoughts on this.). > the fix for Linux is import Dispatch at the top.\nOops, I remember adding it but it must've got undone. Sorry about that. \n\nwe have other tests that do this so you can just copy and paste.\n\nWill do!. Thanks for the feedback \ud83d\ude03. I tried using dispatchPrecondition(condition: .onQueueAsBarrier(q)) since it was used elsewhere in tests but it wouldn't pass. Settled for an equality check instead. I'll fix this.\nI was wondering if we should refactor the tests for finally in their own extension in the CatchableTests file instead of tacking on everything into the testFinally test function?. ",
    "sdgandhi": "Oh lol, the compiler kept spinning instead of highlighting that. Thanks!. ",
    "bellebethcooper": "Got it, thanks.. @mxcl Thanks. I guess this is a misunderstanding about Swift closures on my part, rather than PromiseKit. Appreciate you pointing me in the right direction, and editing your initial comment.. That looks much better, thanks! I haven't used firstly at all yet, because I wasn't totally sure what it does\u2014am I right in thinking it's just for readability, or does it serve another purpose here?. Cool. Thanks very much for your help!. It's definitely useful! I've already been using it and am just adjusting my usage here a bit. I really appreciate PromiseKit and it's improved my codebase a lot. I'm hoping to refactor my fairly extensive HealthKit code in future to use PromiseKit, as I have an awkward set up of something like this for each different category of HealthKit data:\n\nAsync call to HealthKit to see if I can access any data for the user ->\nAsync call to API to request syncing rights for any successful data from step 1 ->\nAsync call to HealthKit to request data for whatever data types succeeded in step 2 ->\nAsync call to API to POST data I successfully received in step 3\n\nIt's a mess, and I'm thinking PromiseKit will really help here. Just brought this up because I wondered if you have any plans for a HealthKit extension in future?\nThanks again for your help and all your work on PromiseKit!. Okay cool, I can give that a go. Thanks very much!. Thank you!. @mxcl That was so quick, thank you! Looks perfect for my usage. I really appreciate your effort\u2014this is going to make my code soooo much better \ud83d\udc4d . Done! Thanks again :). Someone else can probably help with a better answer, but I think you might want to switch from using when(fulfilled:) to when(resolved:). The info in the Getting Started guide under the heading \"when Variants\" says:\n\nwhen(resolved:) waits even if one or more of its component promises fails.. \n",
    "freedoom1984": "Thanks mxci\nI have another situation\n1- I call the authenticated api point\n2- I create the object if the call work fine\nIf the response is 401 I call the api for refresh the token and I need to return the point 1\nIf I want to return at the first point of the Promise?\nWith your example in this point\nif !ok {\n        return refreshToken().then(firstThing)\n    } else {\n        return Promise(value: something)\n    }\nI work out of the Promise workflow\nThanks. Hi,\n@IBAction private func loadNotification(){\n    firstly{\n        provaRequest()\n    }.then { dictionary -> Void in\n        print(dictionary)\n    }.catch{ (error) in\n        if true{\n            self.provaRefresh().then{ dictionary -> Void in\n                self.loadNotification()\n            }\n        }\n    }\n}\nIn this moment I solved my problem like this...but I don't like\nI need restart (from the firstly) when the self.provaRefresh is executed (in the catch I capture the expiring of token, I refresh it end I recall the first endpoint \"provaRequest()\"\nThanks\n. Thanks @mxcl but I have the warning on \"self.provaRequest() //WARNING\"\nResult of call to 'provaRequest()' is unused\nfirstly{\n            provaRequest()\n            }.recover { (error) -> Promise in\n                if true {\n                      return self.provaRefresh().then { dictionary -> Void in\n                        print(dictionary)\n                        self.provaRequest() //WARNING\n                    }\n                } else {\n                    throw HttpRequest.errorObject()\n                } \n            }.then { dictionary -> Void in\n                print(dictionary)  \n            }.catch{ (error) in\n                print(error)\n        }\n. Hi,\nI solved with this but I'm not sure it's okay\n```\nlet refresh:Promise = provaRefresh().then{_ in\n    self.provaRequest()  \n}\nfirstly {  \n    provaRequest()\n}.recover { (error) -> Promise in\nif true {\n\n    return refresh\n\n} else {\n\n    throw HttpRequest.errorObject()\n}\n\n}.then { dictionary -> Void in\nprint(dictionary)\n\n}.catch{ (error) in\nprint(error)\n\n}\n```. ",
    "ksathireddy": "Hi mxcl, I am using PromiseKit version 4.4. Hi mxcl, Where can i find docs related to PMKError types. Can you please post a link?. Ok mxcl. Thank you so much for your help.. ",
    "stephencelis": "Ah, so Optional's flatMap works this way because it's defined on Optional itself. flatMap generally expects that the container type (where flatMap lives, e.g. Optional) is the same as the return type of the transform function (again, Optional in that case).\nswift\nOptional<A> => ((A) -> Optional<B>) -> Optional<B>\nSo to define flatMap on Promise generically, the expectation is that the signature follows suit, where you can simply substitute every Optional for Promise.\nswift\nPromise<A> => ((A) -> Promise<B>) -> Promise<B>\nArray works the same way. (Sequence must convert the container to an Array because Swift's type system isn't quite powerful enough to return the same sequence type.)\nCompare with compactMap, where it's not as abstract:\nswift\n[A?] => ((A?) -> B?) -> [B]\nThese overloads on Promise are definitely handy! They're just not quite what folks expect when they see flatMap.\nHopefully this all makes sense! We're in abstract land, so it can be tough to convey this stuff. I'm hoping seeing the function signatures helps!. Just some renaming. Earlier I suggested the idea of sharing compactMap to mean failing on optional, and adopting flatMapInner to invoke flatMap on a sequence or optional that a promise contains.\nWhat do you think?. > In this respect, is map also bad?\nI don't think so! From what I gather map is being used as:\nswift\nPromise<T> => ((T) -> U) -> Promise<U>\nhttps://github.com/mxcl/PromiseKit/blob/0e150f87e895d849287e8fc5053e6dfe7919577d/Sources/Thenable.swift#L38\nThis is exactly what we want when we encounter map: it works with a transform function that has no knowledge of the container type, just the type contained within. Lemme know if there are other instances I missed, though, that have a different shape!. > For me, the way to think about promises is to imagine they didn't exist, to abstract away the asynchronicity. Thus it's like you called flatMap on the promise's value and not the promise, so the functional names should be named as though they act on the values rather than the promises.\nI hear ya! I just think this is a tough goal to achieve and it's what async/await constructs attempt to sugar over. Promise is a great solution but it lives squarely in the land of nested types, so I think we need to disambiguate between the container and the type within to avoid some confusion.. One other thought before I call it a night: there are some nice methods on observable/signal types in FRP libraries like ReactiveSwift and Rx that ignoreNil() or skipNil() to promote Signal<A?> to Signal<A>. If the goal is to easily transform a promise of A? to A and then act on that data, maybe some similar, concrete methods would be a nice alternative!. @nathanhosselton map is being used in the expected way! If follows in the footsteps of Array.map and Optional.map in Swift, and it follows in the footsteps of map in a lot of other programming languages, and in math, and in other disciplines! This is great! It means we can go between these different worlds and share this knowledge without having to start from scratch each time. As soon as we write map in a different way, we start to lose this, and we lose the trust of people who have built up these intuitions and expectations.\nThis is exactly why flatMap should do the same: it also has a very specific, established meaning over a lot of different places. Even Swift has cleaned house here: Array.flatMap only works with a closure that returns an array, and Optional.flatMap only works with a closure that returns an optional. (If you're used to using Array.flatMap with optionals, you'll be renaming those to compactMap soon.)\nThe current implementations in PromiseKit unfortunately deviate from the long history of what flatMap is and muddies the waters for functional and non-functional programmers alike! We need to be careful not to overload something with an established meaning (even if it's abstract) with something that doesn't match that meaning. Even though it kinda looks like a duck and it quacks like a duck, it's just not a duck. If we mistake a horse for a dog because we've seen some dogs but have never seen a horse, we're not going to keep on calling horses \"dogs\" when we learn about horses. And we're not going to reuse + for multiplication when we first learn multiplication because + already has a clear meaning, and overloading it (instead of establishing another operator to host this shared meaning, *) confuses things.\nI think the constructive way to continue the conversation here is to suggest new names that feel right and don't overload concepts that have well-established meaning.. @nathanhosselton I'm not exactly clear as to what you're asking, but none of the flatMap overloads on Promise fit the shape that flatMap expects:\nswift\n(M<A>) => ((A) -> M<B>) -> M<B>\nIt operates on a single container type, M, and works to transform Ms that contain As into Ms that contain Bs with a specific transform function from A to M<B>.\nI think it's important to realize that flatMap is a completely generic concept and doesn't know anything about Array or Optional. It just turns out that you can satisfy the flatMap function signature for both types by swapping M out, and it also turns out that these two functions are useful. You can also swap M with Promise and get something useful (the thing that then does, where you can return a promise from the closure). You can swap M out for a lot of things.. I think you have this right!\n\nIn the case of our flatMap on Optionals, the shape is still incorrect even when the promise containers are ignored:\nswift\n(A) => ((A) -> N<B>) -> B\n\nIn this case, no need to abstract with N! We have a concrete, failover operation that utilizes Optional. This is why I suggested compactMap over ifLet since it would provide a shape consistent with Array.compactMap:\nswift\nArray<A>   => ((A) -> Optional<B>) -> Array<B>\nPromise<A> => ((A) -> Optional<B>) -> Promise<B>\nIf we settled on this, we'd have to rename the existing overload from compactMap to compactMapInner, but we'd have a consistent set of methods if we adopted flatMapInner for the other two operations.. Either sound good to me!. > Could unwrap be compactMapValue and should it be? At this point I'm feeling a little hazy on understanding again.\nI think unwrap could just be plain old compactMap? It matches the overall shape of Array's compactMap but with Promise substituted in.\nswift\nArray<A>   => ((A) -> Optional<B>) -> Array<B>\nPromise<A> => ((A) -> Optional<B>) -> Promise<B>\nThen compactMapValue would be for this case:\nswift\nPromise<Array<A>> => ((A) -> Optional<B>) -> Promise<Array<B>>\n\nAdditionally, how about filter which we also provide?\n\nHm, interesting. So if I came across promise.filter, I'd maybe think that it was filtering a promise by the value it contains, not filtering the sequence a promise contains. Does such a thing live on promise under a different name? One nice thing is that a filter that works this way can be built with compactMap:\nswift\nfunc filter<A>(_ predicate: (A) -> Bool) -> Promise<A> {\n  return self.compactMap { predicate($0) ? $0 : nil }\n}. Theses all look good!. Oh dang, lemme give this one last look. My brain skipped right past Iterator. That should be mapValues.\nEdit: or maybe not. Going over this stuff slowly \ud83d\ude05. Alright, so both that map you called out and the flatMap below it are definitely doing something more than map and flatMap. Seems to me:\n\nmap: take a promise that contains a sequence, a transform from each element to another promise, and return a promise that contains an array of the result of all of those promises.\nflatMap: take a promise that contains a sequence, a transform from each element to another promise containing a sequence, and return a promise that contains an array of the result of all of those sequences, flattened.\n\nThe first, to me, sounds like a mapValuesThen, and the second sounds like a flatMapValuesThen. Kinda wordy, but descriptive of the action.. > My one tiny gripe is with compactMap. It doesn't feel like a compactMap since it's not operating on a sequence, and since it continues or fails the promise chain based on whether or not the unwrapped value exists. compactMap on sequences doesn't fail.\nI think this is a matter of considering what compactMap on sequence is doing. It processes every element in a sequence and discards those that are optional. If you ran compactMap on a sequence and always return nil, you'll get an empty array back, which has zero data you can process: it's failed, in a way. The optional type itself is often used to denote failure. This is a nice thing about looking at things in the abstract. The function signatures are the same so there is some weirdly shared behavior.\nAlso let's look at flatMap on sequences vs. flatMap on optionals (which, like promises, either have values or don't): flatMap on sequences can change the size of the sequence and feels different than flatMap on optionals, which can merely fail over to being nil, which in turn feels a little different than flatMap on promises, which allows non-failing promises to take their data and make another promise (failing or not). These all feel slightly different, all share the exact same signature, and all allow for a very basic operation: sequencing computations together!. If I understand this correctly, this is taking a promise that contains a sequence and return a promise that contains a list of promises. I don't know enough about the internals of this lib, but is this any different than mapValues above other than the fact that it constrains further on Thenables?. Oh, I see. It's processing the promises, like a method version of Promise.all. ",
    "JustinJiaDev": "After reading your conversation I feel that compactMapValues, compactMap, flatMapValues and flatMap make most sense to me. And it will follow Swift\u2019s naming convention (https://developer.apple.com/documentation/swift/dictionary/2894692-mapvalues). . ",
    "timbms": "Hi Max,\nthis was super quick.\nI still have an issue with attempt: Still fails to compile on after\nbecause of:\npublic func after(_ interval: DispatchTimeInterval) -> Guarantee\nafter (interval: interdelay)\n->\nafter (interdelay)\nTim\nOn Wed, Feb 14, 2018 at 8:13 PM, Max Howell notifications@github.com\nwrote:\n\nI fixed this and supplemented the migration guide. Thanks for the report\nand sorry for the omission.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/776#issuecomment-365713701,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFKRO--c7l0PolvD6UnrvBG7haehl6ndks5tUzBQgaJpZM4SFzDL\n.\n. \n",
    "theodelrieu": "Moving the pod 'PromiseKit/Hang' line to the enclosing target App_Example fixed the issue.\nThat's good enough for me, should have looked a bit more before opening an issue :). Thanks for the clarification!\nI'm quite new to iOS development, but from what I've understood using PMK6 will force my consumers to link against the Swift standard libraries, which might be unacceptable to some of them.\nJust to be sure: If a consumer depends on PMK6, will it be possible to use PMKPromise from my API without depending also on PMK 1.7?. >Yes, it will, but TBH nowadays avoiding Swift is pretty hard.\nTrue. I hope I'll be able to drop Objective-C then!. I've got the exact same problem with Xcode 9.3 9E145. Setting 'PromiseKit/Promise', '~> 1.7.6' explicitly + running pod install --repo-update works. I won't be available for two weeks, but I'll try to do that after.. No, I did change the tests to show that it works, but this can be reverted. Objc generics are almost only cosmetic. The compiler can emit warnings though:\nobjc\nPMKPromise<NSNumber*>* p;\nPMKPromise<NSString*>* p2 = p; // warning emitted\nThe warnings can be suppressed by using __covariant, as explained in the top comment of this article. But I believe they are quite valuable.\nI don't know if promises using PMKManifold can be annotated, that's a limitation of this PR.\nI would need to look further, but this looks like a good start.. ",
    "duyngn": "Oh sorry!  I should point out where it's complaining.\nIt's throwing me the error in the function \"loadNetworkObjects()\" on the line\nswift\nself.fetchNetworkObjects().then { myNetworkObject -> Void in\nIt's complaining that it can't infer the type for \"myNetworkObject\". Oh wow... Thanks so much for the quick responses!  Cheers!. ",
    "codecov[bot]": "Codecov Report\n\nMerging #797 into master will increase coverage by 0.2%.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #797     +/-\n========================================\n+ Coverage    97.7%   97.9%   +0.2%   \n========================================\n  Files          23      23           \n  Lines        1347    1347           \n  Branches      110     109      -1   \n========================================\n+ Hits         1316    1318      +2   \n+ Misses         31      29      -2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Thenable.swift | 97.8% <\u00f8> (\u00f8) | :arrow_up: |\n| Sources/Catchable.swift | 100% <\u00f8> (\u00f8) | :arrow_up: |\n| Sources/AnyPromise.swift | 98.1% <0%> (+1.4%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update eb6a6e0...47b6db3. Read the comment docs.\n. # Codecov Report\nMerging #804 into master will decrease coverage by 0.3%.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster   #804     +/-\n=======================================\n- Coverage    97.3%    97%   -0.2%   \n=======================================\n  Files          23     23           \n  Lines        1339   1339           \n  Branches      109    108      -1   \n=======================================\n- Hits         1302   1298      -4   \n- Misses         37     41      +4\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Promise.swift | 95.7% <0%> (-2.1%) | :arrow_down: |\n| Sources/AnyPromise.swift | 96.8% <0%> (-1.3%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 70970c3...db0c15b. Read the comment docs.\n. # Codecov Report\nMerging #805 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #805   +/-\n======================================\n  Coverage    97.3%   97.3%         \n======================================\n  Files          23      23         \n  Lines        1339    1339         \n  Branches      109     109         \n======================================\n  Hits         1302    1302         \n  Misses         37      37\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 70970c3...a7461c4. Read the comment docs.\n. # Codecov Report\nMerging #823 into master will decrease coverage by 0.2%.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #823     +/-\n========================================\n- Coverage    97.3%   97.1%   -0.1%   \n========================================\n  Files          23      23           \n  Lines        1339    1339           \n  Branches      108     109      +1   \n========================================\n- Hits         1302    1300      -2   \n- Misses         37      39      +2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Thenable.swift | 93.2% <100%> (\u00f8) | :arrow_up: |\n| Sources/Promise.swift | 95.7% <0%> (-2.1%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 54eadda...4f18c38. Read the comment docs.\n. # Codecov Report\nMerging #840 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #840   +/-\n======================================\n  Coverage    97.8%   97.8%         \n======================================\n  Files          27      27         \n  Lines        1169    1169         \n======================================\n  Hits         1143    1143         \n  Misses         26      26\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8992b4f...157a241. Read the comment docs.\n. # Codecov Report\nMerging #841 into master will increase coverage by 0.1%.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #841     +/-\n========================================\n+ Coverage    97.8%   97.8%   +0.1%   \n========================================\n  Files          27      27           \n  Lines        1162    1169      +7   \n========================================\n+ Hits         1136    1143      +7   \n  Misses         26      26\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Catchable.swift | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 98eaf18...c667ec7. Read the comment docs.\n. # Codecov Report\nMerging #858 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\nmaster    #858   +/-\n======================================\n  Coverage    97.8%   97.8%         \n======================================\n  Files          27      27         \n  Lines        1169    1169         \n======================================\n  Hits         1143    1143         \n  Misses         26      26\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/AnyPromise.m | 98.1% <\u00f8> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7dba562...c68986f. Read the comment docs.\n. # Codecov Report\nMerging #860 into master will decrease coverage by 0.1%.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #860     +/-\n========================================\n- Coverage    97.8%   97.7%   -<.1%   \n========================================\n  Files          27      27           \n  Lines        1169    1169           \n========================================\n- Hits         1143    1142      -1   \n- Misses         26      27      +1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Promise.swift | 98.6% <0%> (-1.4%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7dba562...84f1f29. Read the comment docs.\n. # Codecov Report\nMerging #871 into master will decrease coverage by 0.1%.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #871     +/-\n========================================\n- Coverage    97.8%   97.7%   -<.1%   \n========================================\n  Files          27      27           \n  Lines        1169    1173      +4   \n========================================\n+ Hits         1143    1146      +3   \n- Misses         26      27      +1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Guarantee.swift | 100% <100%> (\u00f8) | :arrow_up: |\n| Sources/Promise.swift | 98.6% <0%> (-1.4%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3e6763e...89c5829. Read the comment docs.\n. # Codecov Report\nMerging #872 into master will increase coverage by 0.1%.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #872     +/-\n========================================\n+ Coverage    97.8%   97.8%   +0.1%   \n========================================\n  Files          27      27           \n  Lines        1169    1173      +4   \n========================================\n+ Hits         1143    1147      +4   \n  Misses         26      26\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Guarantee.swift | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3e6763e...bb3b294. Read the comment docs.\n. # Codecov Report\nMerging #899 into v7 will increase coverage by 5.2%.\nThe diff coverage is 83.9%.\n\n\n```diff\n@@           Coverage Diff           @@\nv7    #899     +/-\n=======================================\n+ Coverage   87.3%   92.5%   +5.2%   \n=======================================\n  Files         15      32     +17   \n  Lines        793    1760    +967   \n=======================================\n+ Hits         692    1627    +935   \n- Misses       101     133     +32\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Guarantee.swift | 93.2% <100%> (+0.2%) | :arrow_up: |\n| Sources/when.swift | 100% <100%> (+0.9%) | :arrow_up: |\n| Sources/race.swift | 100% <100%> (\u00f8) | :arrow_up: |\n| Sources/after.swift | 97% <100%> (-3%) | :arrow_down: |\n| Sources/cancellable.swift | 100% <100%> (\u00f8) | |\n| Sources/hang.swift | 91% <100%> (+0.6%) | :arrow_up: |\n| Sources/firstly.swift | 100% <100%> (+22.3%) | :arrow_up: |\n| Sources/Promise.swift | 93.6% <66.7%> (-0.6%) | :arrow_down: |\n| Sources/CancellableThenable.swift | 67% <67%> (\u00f8) | |\n| Sources/CancellablePromise.swift | 78.5% <78.5%> (\u00f8) | |\n| ... and 33 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0070f3c...21a4ccf. Read the comment docs.\n. # Codecov Report\nMerging #926 into master will increase coverage by 0.1%.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster    #926     +/-\n========================================\n+ Coverage    96.6%   96.7%   +0.1%   \n========================================\n  Files          27      27           \n  Lines        1188    1188           \n========================================\n+ Hits         1147    1148      +1   \n+ Misses         41      40      -1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| Sources/Promise.swift | 98.5% <0%> (+1.6%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4cd8a0d...4ad5294. Read the comment docs.\n. \n",
    "moger777": "I found there were a lot of places where I had firstly{}.then where I wanted either firstly{}.done or firstly{}.map and the errors went away after that. Unfortunately swift has a hard time figuring out where to show the real error when it comes to closures.. I also recently got this error from the following code:\nswift\nfirstly {\n  aPromise()\n}.then { value -> Promise<SomethingElse>\n  return anotherPromise()\n}\nThe issue was I was missing the \"in\" in the then clause. It's too bad swift won't show you the error on the .then clause, instead it bubbles up to the firstly event though that part is fine.. Can you point out where? Read the guide but not seeing it.. Getting a similar issue with cocoapods:\n```\n[!] Error installing PromiseKit\n[!] /usr/local/bin/git -C /var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30 submodule update --init --recursive\nSubmodule path 'Extensions/AVFoundation': checked out '6e6d184768c0d383e5ca8d7a1ff9710351e17dfd'\nSubmodule path 'Extensions/Accounts': checked out '83ac281446b90a76357085e79616466cfc71a375'\nSubmodule path 'Extensions/AddressBook': checked out 'e0b3a9274560393328a7b08cec77676726b863b4'\nSubmodule 'Extensions/AVFoundation' (https://github.com/PromiseKit/AVFoundation) registered for path 'Extensions/AVFoundation'\nSubmodule 'Extensions/Accounts' (https://github.com/PromiseKit/Accounts.git) registered for path 'Extensions/Accounts'\nSubmodule 'Extensions/AddressBook' (https://github.com/PromiseKit/AddressBook.git) registered for path 'Extensions/AddressBook'\nSubmodule 'Extensions/Alamofire' (https://github.com/PromiseKit/Alamofire) registered for path 'Extensions/Alamofire'\nSubmodule 'Extensions/AssetsLibrary' (https://github.com/PromiseKit/AssetsLibrary.git) registered for path 'Extensions/AssetsLibrary'\nSubmodule 'Extensions/Bolts' (https://github.com/PromiseKit/Bolts.git) registered for path 'Extensions/Bolts'\nSubmodule 'Extensions/CloudKit' (https://github.com/PromiseKit/CloudKit.git) registered for path 'Extensions/CloudKit'\nSubmodule 'Extensions/CoreBluetooth' (https://github.com/PromiseKit/CoreBluetooth.git) registered for path 'Extensions/CoreBluetooth'\nSubmodule 'Extensions/CoreLocation' (https://github.com/PromiseKit/CoreLocation.git) registered for path 'Extensions/CoreLocation'\nSubmodule 'Extensions/EventKit' (https://github.com/PromiseKit/EventKit.git) registered for path 'Extensions/EventKit'\nSubmodule 'Extensions/Foundation' (https://github.com/PromiseKit/Foundation.git) registered for path 'Extensions/Foundation'\nSubmodule 'Extensions/HealthKit' (https://github.com/PromiseKit/PMKHealthKit) registered for path 'Extensions/HealthKit'\nSubmodule 'Extensions/HomeKit' (https://github.com/PromiseKit/HomeKit.git) registered for path 'Extensions/HomeKit'\nSubmodule 'Extensions/MapKit' (https://github.com/PromiseKit/MapKit.git) registered for path 'Extensions/MapKit'\nSubmodule 'Extensions/MessagesUI' (https://github.com/PromiseKit/MessagesUI.git) registered for path 'Extensions/MessagesUI'\nSubmodule 'Extensions/OMGHTTPURLRQ' (https://github.com/PromiseKit/OMGHTTPURLRQ) registered for path 'Extensions/OMGHTTPURLRQ'\nSubmodule 'Extensions/Photos' (https://github.com/PromiseKit/Photos.git) registered for path 'Extensions/Photos'\nSubmodule 'Extensions/QuartzCore' (https://github.com/PromiseKit/QuartzCore.git) registered for path 'Extensions/QuartzCore'\nSubmodule 'Extensions/Social' (https://github.com/PromiseKit/Social.git) registered for path 'Extensions/Social'\nSubmodule 'Extensions/StoreKit' (https://github.com/PromiseKit/StoreKit.git) registered for path 'Extensions/StoreKit'\nSubmodule 'Extensions/SystemConfiguration' (https://github.com/PromiseKit/SystemConfiguration) registered for path 'Extensions/SystemConfiguration'\nSubmodule 'Extensions/UIKit' (https://github.com/PromiseKit/UIKit.git) registered for path 'Extensions/UIKit'\nSubmodule 'Extensions/WatchConnectivity' (https://github.com/PromiseKit/WatchConnectivity.git) registered for path 'Extensions/WatchConnectivity'\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/AVFoundation'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/Accounts'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/AddressBook'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/Alamofire'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/AssetsLibrary'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/Bolts'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/CloudKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/CoreBluetooth'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/CoreLocation'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/EventKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/Foundation'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/HealthKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/HomeKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/MapKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/MessagesUI'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/OMGHTTPURLRQ'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/Photos'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/QuartzCore'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/Social'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/StoreKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/SystemConfiguration'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/UIKit'...\nCloning into '/private/var/folders/mr/k0rdl8dd2z95gdfh1b3t542wl2831p/T/d20181119-71135-17agf30/Extensions/WatchConnectivity'...\nerror: no such remote ref cba1687ea032e1899244e401af2a7ef102a4e486\nFetched in submodule path 'Extensions/Alamofire', but it did not contain cba1687ea032e1899244e401af2a7ef102a4e486. Direct fetching of that commit failed.\n```. ",
    "samrayner": "Just includes the above code in the AppDelegate:\nhttps://github.com/samrayner/pmkerror. Excellent, thanks. On second thoughts I suppose you'd want these in addition to the Void versions rather than instead of.. The concept of Promises doesn't really determine how you should report progress. The promise will be pending until the download completes, resolving the promise.\nCheck out PromiseKit's URLSession extension:\nhttps://github.com/PromiseKit/Foundation/blob/a6b1a30ec9f326b2485f1383fadc02b158de00dd/Sources/NSURLSession%2BPromise.swift\nURLSession offers this delegate method to track progress:\nhttps://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate/1409408-urlsession\nAlternatively you could pass a Progress object into your method and update it periodically.\nhttps://developer.apple.com/documentation/foundation/progress. ",
    "chrisnguyens": "Hi mxcl,\nThanks for your response.\nfirstly{\n    UIApplication.shared.isNetworkActivityIndicatorVisible = true\n    **return getIPNumbers(withAPI: .incomingPhoneNumber)**\n}\nGot the error at the return line. . Yes, because of it could be 2 line in the firstly with the previous version and I still see in your doc, we could put 2 lines. Thanks for your help. . ",
    "Can-Sahin": "Of course. My bad late at this night. The reason is simply the 'chain' word I read many times while reading migration guide. I guess it made me believe that everything you do on a promise adds something to the chain.. And the fact that recover is still executing once ridiculously convincing :) \nIts been couple months of break to this library and now I am back. Kinda forgot how it works. \nBut 100% my bad. Thanks. Reminds me again the first rule.. never accuse the library fast ;) . ",
    "ThangaAyyanar": "cannot capture mutiple value in swift\nif objective c returns a,b,c i can only able to access a \nis there some other way to do that. ",
    "zvonicek": "Ah, I feel bad for not figuring this out myself. Thank you!. ",
    "knguyen2708": "Thanks @mxcl. It does solve my problem.\nNot sure if I understand what you asked... My use case is: I have jobs (which are basically network requests). These are initiated by users and may complete or fail. Push notifications are used in both cases to notify users. These jobs are managed by a manager so that they can be retried later if they fail. It is this manager that processes the errors further, e.g. saving error messages so that they can be displayed later, or when the app restarts.\nI guess my issue comes down to responsibility separation between components: a component may want to do something (most likely logging, or push notification in my case) when an error happens, but still want to pass it along the chain.. ",
    "lanephillips": "Okay, my problem was solved by explicitly declaring the return type of my recover block:\nfirstly {\n    // try to request from the web, which could fail\n}.recover { error -> Promise<Any> in\n    // try instead to load from disk, which also could fail\n}.done { json in\n    // process results\n}.catch {\n    // handle error\n}. ",
    "0xwangbo": "I tested it. If .podspec has s.static_framework = true and the user declares use_frameworks! in the Podfile, it will get xxx.framework. If you don't declare use_frameworks!, you will get xxx.a\nDeclaring s.static_framework = true in the .podspec does not directly determine the final output, but depends on the user. right? Looking forward to your reply @mxcl. ",
    "john1452": "Hi @mxcl thanks for responding. I am just trying to understand how it is technically possibly to use promiseKit with android. promiseKit kit is written in swift and android is a totally different echo system which uses java or kotlin. Does SwiftPM compile promiseKit to java or kotlin?. ",
    "colinta": "Oh and I was surprised that the return signature of Guarantee<T>.pending() is (Guarantee<T>, (T) -> Void), I expected (Guarantee<T>, Resolver<T>).. Oh yeah I kinda forgot to ask the question (how can I use ensure but have the order of operations as I need to have it), but finally is the method I was searching for, thanks.\nI wasn't trying to criticize, just sharing my upgrade experience.  First I switched all my let (promise, fulfill, reject) to let (promise, seal), then when I switched to using Guarantee I had to revert to let (guarantee, fulfill), and that surprised me, I expected Guarantee.pending and Promise.pending to have similar return types.  But they don't!  No worries.  Thanks as always!. Yes, actually I was thinking it would return something other than a resolver, but you would still call resolve on it, so the API would line up... now that I say it out loud it's a bit silly.\nI'm on gitter now, btw, typing another question.... \ud83d\udc4d \nI just noticed get doesn't take a queue, is that deliberate?\nswift\n    func get(_ body: @escaping (T) throws -> Void) -> Promise<T> {\n        return map(on: PromiseKit.conf.Q.return) {. \ud83d\udc4d and added documentation around setting those queues to nil.. ",
    "HarrisHao": "Hi\uff0c @mxcl \nThanks for your reply.\nOur project is using Objective-C. Now we want to use PromiseKit to do some refactoring.\nHow can I choose the version of PromiseKit to avoid this problem?. Well, thank you very much.. ",
    "Pratik-Sodha": "@theodelrieu It's work for me. Previously i'm using version 1.7.2. So, getting that error.\nThank you.. \ud83d\udc4d . ",
    "itzilisun": "When I run pod search PromiseKit,I can't find the version of 1.7.6.1.7.6 is cancelled?. ",
    "laxmorek": "It generates: \u201cCannot convert return expression of type 'Promise<_.T>' to return type 'Promise<[JSON]>'\u201d error message :/. Tnx for quick response. map method solves my problem. I updated my Stack Overflow question for future readers. . ",
    "fabcz": "same problem in 6.2.2\nbut 6.2.3 is OK. ",
    "ilyathewhite": "I am not sure if this implementation as it is now propagates the errors. If body() rejects, the error will not be returned to the caller of ensure. We need to combine the two results. But using the internal APIs is definitely faster.. I think that typically it wouldn't, and most closures could return a Guarantee. But in some rare cases there could be code that might error, and in those cases, it would be nice to get that error instead of ignoring it. The chain may completely roll back something but still recover rather than being left in an inconsistent state.\nA requirement to always return a Guarantee may be enough in most cases, but in the few cases where it won't work, the user will be stuck.. In terms of which error to propagate: ideally, there could be an inner / nested error; but short of that, I think it should be the first error, the one before calling the closure. The other one is secondary; if it can't be returned as a nested error, logging it could be the next best thing. It's definitely an edge case, but this would give the user more tools to deal with errors.. The nested error would be more for debugging than handling the error, but logging it and returning the original error would also work.\nExamples: \nAny cleanup action that may be asynchronous. Animation is the first generic example that comes to mind. More specifically: animated dismissal of a view controller / hiding the UI that stared the chain.\nAnother example could be showing additional UI at the end fo the chain (no matter successful or not) before completing the chain.. I thought more about this. The semantics does become crystal clear if it's a Guarantee while making it a Promise introduces ambiguity, so maybe a Guarantee is a better choice. I also cannot think of any real use cases for Promise and was more thinking about making it as generic as possible.. Great, thank you!. Thank you! Also, very impressive how quickly this was added.. this is a typo -- should be ensureThen after the rename. ",
    "gilbox": "Thanks, that's very helpful! I wasn't sure if the chain held up and I didn't know I could chain multiple done()s... I have another place where I'd like to do something similar earlier in the chain...\nThis is currently what I have:\nfunc displayImagesAsync(_ images: [UIImage]) -> Guarantee<Void> {\n    return\n      firstly { self.clearImagesAsync() }\n      .then { ImageStore.createAsync(images: images) }\n      .done { store in\n        self.frameImageStore = store\n        self.animatedImageView.image = store.frameImage()\n      }\n  }\nbut it seems a bit silly since clearImagesAsync() is just doing this:\nfunc clearImagesAsync() -> Guarantee<Void> {\n    return Guarantee { resolver in\n      DispatchQueue.main.async {\n        self.animatedImageView.image = nil\n        self.frameImageStore = nil\n        resolver(())\n      }\n    }\n  }\nI was wondering if I could do something more like this:\nfunc displayImagesAsync(_ images: [UIImage]) -> Guarantee<Void> {\n    return\n      firstly (on: DispatchQueue.global(qos: .userInteractive)) {\n        self.animatedImageView.image = nil\n        self.frameImageStore = nil\n        return Guarantee.resolve()\n      }\n      .then { ImageStore.createAsync(images: images) }\n      .done { store in\n        self.frameImageStore = store\n        self.animatedImageView.image = store.frameImage()\n      }\n  }. @mxcl I don't think that works because displayImagesAsync is called from a background thread and since  self.animatedImageView.image = nil effects the UI it needs to be called from the main thread.. wow, thank you! that never would have occurred to me.. ",
    "garyhooper": "Resolved. Turns out my first \"then\" should now be a \"map\", returning data (TripPageData) and not a Promise of the data.. ",
    "superandrew": "sorry then. In my defense I only can say that I searched for this, but probably wasn't good enough. Maybe adding it in the readme would help other people, what do you think?\nThanks a lot. ",
    "pimnijman": "@nathanhosselton service.registerUser returns Promise<String>.\nWhen I omit return Promise { seal in and return firstly I get the following error:\nCannot convert return expression of type 'PMKFinalizer' to return type 'Promise<Void>'\nTo me this indicates that I cannot use catchwhen I return firstly. . Thank you @nathanhosselton. I personally prefer the first solution. I love that I no longer need the double promises.. ",
    "SwiftHackr": "@mxcl Thanks for sample! I updated to PromiseKit 6 and PromiseKit/Alamofire 6. Here is what I have. It seems to be working, but could you please take a look to see if I did something wrong?\nFor this specific API, I am using Alamofire directly since I need to call cancel() on the task. I read the documentation you provided and I think this is correct. Although, not sure.\n```swift\n// MARK: - APIClient\nimport Alamofire\nimport PromiseKit\nfinal class APIClient {\nstatic let shared = APIClient()\n\npublic func fetchInfo(of video: Video) -> (Promise<VideoInfo>, cancel: () -> Void) {\n    let endpoint = API.videoInfo(url: video.url)\n    let task = Alamofire.request(endpoint.url,\n                                 method: endpoint.method,\n                     parameters: endpoint.parameters,\n                     encoding: endpoint.parameterEncoding,\n                     headers: endpoint.headers).validate()\n    var cancelme = false\n\n    let promise = Promise<VideoInfo> { seal in\n        task.responseJSON { response in\n            guard !cancelme else {\n                seal.reject(PMKError.cancelled)\n                return\n            }\n\n            guard let json = response.result.value as? [String: Any] else {\n                seal.reject(JSONError.unexpectedRootNode(value: response.result.value))\n                return\n            }\n\n            do {\n                let jsonData = try JSONSerialization.data(withJSONObject: json, options: .prettyPrinted)\n                let jsonDecoder = JSONDecoder()\n                let videoInfo = try jsonDecoder.decode(VideoInfo.self, from: jsonData)\n                seal.fulfill(videoInfo)\n            } catch {\n                seal.reject(error)\n            }\n        }\n    }\n\n    let cancel = {\n        cancelme = true\n        task.cancel()\n    }\n\n    return (promise, cancel)\n}\n\n}\n// MARK: - VideoPlaybackManager\nimport PromiseKit\nfinal class VideoPlaybackManager {\nprivate let player = AVPlayer()\nprivate var cancel = {}\n\npublic var video: Video? {\n    didSet {\n        // Cancel previous request!\n        cancel()\n\n        NotificationCenter.default.post(name: .videoChangedNotification, object: nil)\n\n        guard let video = video else {\n            player.replaceCurrentItem(with: nil)\n            return\n        }\n        guard isAllowedToWatchVideo(video: video) else {\n            player.replaceCurrentItem(with: nil)\n            postErrorNotification(error: .noAccess)\n            return\n        }\n\n        let promise: Promise<VideoInfo>\n        (promise, cancel) = APIClient.shared.fetchInfo(of: video)\n\n        promise.done { videoInfo in\n            guard let url = URL(string: videoInfo.url) else {\n                self.player.replaceCurrentItem(with: nil)\n                self.postErrorNotification(error: .urlError)\n                return\n            }\n\n            // Play video!\n            self.playerItem = AVPlayerItem(url: url)\n            self.player.replaceCurrentItem(with: self.playerItem)\n        }.catch { error in\n            self.player.replaceCurrentItem(with: nil)\n            self.postErrorNotification(error: error)\n        }\n    }\n}\n\n}\n```. Sorry for so much code - but needed it to demonstrate example. The code above for cancellation seems to work great! Thanks a lot for taking time to help out! Awesome library and I recommend it to everyone : ). @mxcl It works! I just wanted to do lots of testing and took a while to respond due to this. Thanks so much! : ) . ",
    "Banck": "I can do nothing with photos in then, there is error then:\n\n. Ok, thanks!\nBut I thought, that there is something like when(fullfiled) when I can get each promises .\nThought that in .done I can get all of previous completed results \nAnd that .catch will return promise which failed.\nOr that I can write something like that:\nfirstly {\n            ProfileManager.uploadImages(photos)\n        }\n        .catch { (error) in\n                print() // error for photos\n        }\n        .then { (photos)  in\n            ProfileManager.updateProfile(name, bio: bio ?? \"\", birthdayDate: birthdayDate ?? \"\")\n        }\n        .done { (result) in\n                self.view?.showAlert(title: nil, message: \"\u0414\u0430\u043d\u043d\u044b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u044b\")\n        }\n        .catch { (error) in\n                print() // error for profile\n        }\n        .finally {\n                        self.view?.stopLoading()\n                }\nSo thanks for your help, I think all is fine now... I meant, that it\u2019s cool that in .when i can get each promises, but i need to do one by one\nNevermind) anyway than you so much). Thanks a lot, guys!. ",
    "johannesd": "You're making a good point \u2013\u00a0maintaining the class while chaining might be essential for my needs... or not. I have to think about it.. I've implemented my CancelablePromise now as an independent class that conforms to Thenable and adds a cancel function. Calling then on an instance returns an ordinary Promise, which is fine because this promise does not support cancelation. I could overload then to return a CancelablePromise. When calling cancel on that instance, it would have to propate to the preceeding promise(s) to cancel that one / those as well. \nlet a = CancelablePromise(...)\nlet b = CancelablePromise(...)\nlet c = a.then(b)\nc.cancel() // Should call cancel on a and b\nIs there already a mechanism in PromiseKit that I could use for that? I think it's similar to rejecting a promise which somehow finds the catch handler in the chain. However, this would have to run in the opposite direction.\nFurthermore, I'm thinking about calling cancel automatically when using CancelablePromises in a race. After one promise has resolved, the other ones would then be cancelled. \nlet a = CancelablePromise(...)\nlet b = CancelablePromise(...)\nlet c = race([a, b])\n// when a fulfills, b should be cancelled\nFor that, I would overload race(cancelablePromises: [CancelablePromise]), call the original race(thenables: [Thenables]) in it,  analyse which promise has fulfilled and call  cancel on the other ones. Is that correct? Or is there any function already called on the loosing promises in the race call, that I could overwrite?\nThank you for your help!. I have put a little lib together, maybe it is useful to somebody: https://github.com/johannesd/CancellablePromiseKit\nIt provides a CancellablePromise that has a cancel() function. It also adds overloads for when and race that can automatically cancel the promises that did not finish in time.\nWould be nice to hear what you think about it. And thanks for PromiseKit!. That would be an honor ;-) . ",
    "ephemer": "Hi @mxcl we are working on a solution for a CI for Android, it's pretty specific to our use case for now but could be interesting to generalise it in the future. I'll keep you in mind for future updates. ",
    "muratyasarr": "Does v4 support Swift 2.3?. Ok removing the UIKit resolves the issue for now. Thanks a lot for the help! \ud83d\udc4d . ",
    "tealshift": "Okay, I may have actually misunderstood something. Is there not a way to acquire the array of Result \"values\" from the array of Promises/Guarantees?\nI read this section https://github.com/mxcl/PromiseKit/blob/master/Documentation/CommonPatterns.md#waiting-on-multiple-promises-whatever-their-result\nbut it confuses me.\nIt says \" Result is an enum of .fulfilled or .rejected\" but what about accessing the values that the results that were fulfilled with? \nEDIT: I think I got it... You have to keep a reference to the Promises/Guarantees and acquire the fulfilled values from them with promise.value. Is that right?\nIn any case, that still doesn't explain why when supports [Guarantee<Void>] but not [Guarantee<T>].. Oh, I see. Thanks for the suggestion. :). ",
    "amedakedo": "Thanks a lot for the quick reply!\nWill be updating the documents regarding this issue later today/tomorrow.\nAlso just to confirm, is the workaround I've added valid? (where instead of throwing I would return a Promise with value Error) It seems to be working just fine, but just in case would love to get your feedback.\nobjectivec\nmyPromise.then(^(task, result){\n    //...\n    if (somethingWentWrong) {\n        // @throw [NSError cancelledError];\n        return [AnyPromise promiseWithValue:[NSError cancelledError]];\n    }\n    //...\n}).then(^(task, result){\n    // in case of something went wrong I don't want to enter here\n    //...\n}).catch(^(NSError *error){\n    if ([error isEqual:NSError.cancelledError]) {\n            return;\n    }\n    //...\n});. Thanks a lot!\nWill be updating the docs regarding this soon.. PR sent.. Reference: #866. Sure, no problem. And thank you for the help!. ",
    "Igor-Palaguta": "This test is not passed. If it is lazy isResolved should remain false. But really it becomes true. Am I doing something wrong?\nswift\n    func testPromiseLaziness() {\n        var isResolved = false\n        let lazyPromise: Promise<Int> = Promise { resolver in\n            isResolved = true\n            resolver.fulfill(5)\n        }\n        expect(isResolved).toEventuallyNot(equal(true))\n    }. I see. Thank you for clarification!. @mxcl let me check. Yes, it works, issue can be closed. Thank you for PromiseKit!. @mxcl Can't find this commit in master anymore. thanks. Is it fine we will have side effects inside recover?. We have good places for side effects (like updating UI) done / catch / tap / get / ensure\nOther functions like map/ then / recover should just modify promise, without any side effect. Just checked tap and ensure handlers are called for cancelled errors. But recover and catch handles properly it. Please check https://github.com/mxcl/PromiseKit/pull/949. Also one of recovers that returns Guarantee does not check cancellation. In case if it is needed catchPolicy can be passed the same like in catch and recover\nWe are using tap not just for debug. We added:\nextension Thenable {\n    public func takeWhileAlive(_ object: AnyObject) -> Promise<T> {\n        return map { [weak object] result in\n            guard let object = object else {\n                throw PMKError.cancelled\n            }\n            _ = object\n            return result\n        }\n    }\n}\nAnd then we can use unowned references, without writing guard let everytime\n```\npromise\n   .takeWhileAlive(self)\n   .tap { [unowned self] _ in // }\n   .ensure { [unowned self] // }\n   .catch {[unowned self] _ in /**/}\n```. Also not clear why for one recover cancelation is handler, but for second - not. https://github.com/mxcl/PromiseKit/blob/master/Sources/Catchable.swift#L109. But if we throw cancel error above, why do we need recover anything?. Currently there is no way stop to chain. Cancel looked like the one way to do it. But strategy for handling is not shared among all handlers. It would be great if we have common. ",
    "guidupas": "Solved using this code\ngnEndpoints?.paymentToken(for: gnCreditCard).then({ token -> () in\n            if let token = token as? GNPaymentToken {\n                print(token)\n            }\n        }, { (error) -> () in\n            // catch your error\n        }). ",
    "FSMaxB-divae": "I forgot to mention: This is with Xcode 9.4\ncarthage-xcodebuild.log\n. ",
    "FSMaxB": "Thanks for the quick fix.\nSorry for not providing the build log right away.. ",
    "GarthSnyder": "Great! I'll see what I can do.. Looking at it now.... In the latest Linux library, DispatchQueue.main is evidently no longer a static object. You get a new instance each time, or perhaps it's a value type now. Odd, because you can still access the same queue-specific data through any of the instances...\nThe library code doesn't depend on this, just the testing code. PR incoming.\n. It's fine either way and style guides vary on what they recommend, but it should be consistent throughout. \nI standardized them to sentence case largely on the general principle that extra formatting that doesn't aid readability can be removed. Markdown renders the headings pretty unmistakably, so there's no need for additional \"specialness\" to call attention to the fact that they're headings. In addition, many of the titles mention capitalized class names, and sentence case helps those stand out more (e.g., is the heading talking about a Promise-class object specifically or just a generic English \"promise\"?). \nObviously, these are minor considerations. I'm happy to resubmit with any convention you prefer if you feel strongly about it.\nThere are a few other things in this category, too. I added Oxford commas, for example. There's nothing wrong with not having them; I just wanted to be sure they were consistent and that's the convention I'm more used to.\n. Moving this to a separate git branch just for my own sanity, will resubmit.. I believe this is fixed in master already with Igor's PR.. Oops, I meant to separate this out but didn't push my local copy of the branch. I will resubmit.. OK, great, I'll proceed on this. Work list:\n\nUpdate documentation\nInvestigate Linux build issue\nUpdate Dispatcher chain starter functions not to use PMKNamespacer\n\nI'm leaving for vacation soon and won't get to this until I return; that will be around July 18. \nI'm looking forward to the results of your spot checks. . I'm ready to start working on this again.\nMax, did you have a chance to run this version against any existing codebases?. Sounds good. I'll get back with an updated branch to replace this PR in a week or two.. Sounds like you're up to date on this, but just to be explicit: the issue with Linux testing related to an oddity of older Linux Swift compilers in Swift 3 compatibility mode.\nAs outlined above, this whole approach depends on Swift enforcing a fewest-defaulted-arguments rule for disambiguating overloaded functions. This always worked fine for both Swift 3 and Swift 4 in all versions of Xcode. But for some reason, there was a recent span of versions of the Linux Swift codebase that were not applying this rule in Swift 3 mode. That appears to be fixed in more recent builds.\nTL;DR: Unless you care strongly about 1) Swift 3 compatibility 2) on Linux 3) consistently across every historical Linux compiler version, the Travis errors are essentially spurious and can be ignored/reconfigured out.. Sure, I can work on this tomorrow.. Sorry it's taken me a while longer to get to this - I spent some time wrestling with Travis CI. I will be more available over the next couple of months.\nI have a branch that rebases onto the current v7, but I didn't realize this PR was an active reference into my clone and I moved the head pointer in a way that github didn't like, so it closed the PR. I'm reopening now and I'm going to see if I can get that original \"dispatch\" branch rehabilitated, but if it doesn't work I'll submit a separate PR for \"dispatch-v7\".\nThis is just a baseline. I haven't added docs or addressed any of the issues above yet. \nAs mentioned above, this code depends on the fact that the compiler prefers overloads that default fewer arguments. Looking more into the multiple test builds, I've discovered that this really has nothing to do with the version of Swift and everything to do with the compiler. Evidently it's not part of the language specification but part of the compiler's implementation latitude.\nThe result is that this branch is compatible with both Swift 3 and Swift 4, but you must use a relatively current compiler. That seems to be true across all platforms. Older compilers will complain about ambiguous method calls in client code and even in the internal implementation of PromiseKit. I'm not sure how much of a barrier this really presents, but if someone runs into the problem in the wild, it's going to be hard for them to figure it out unless it's a FAQ.\nI'm also seeing sporadic hangs in the Travis testing phases, usually in WrapTests or WhenTests. These seem to occur on the current master, too, so my working hypothesis is that it's not related to these updates. . I think this original PR is now good again, but the dispatch-v7 branch referenced below is cleaner.. I'm not sure why Travis failed here. When I merge 68763cf into 02e84ce in my clone, it builds fine.. Yes, I guess that's the right thing, although there's a lot of useful context above. There's no way to convert a PR to an Issue, is there? . I can address this since I'm touching this stuff anyway. However, I'm afraid I don't understand the issue. Can you clarify?. I understand the mechanics of what you're proposing; I'm just unclear on the motivation. Why is it a problem that every defaulted operation might go to the same queue/dispatcher?. I took a look at Doug's clone just to see how much the V7 Dispatcher stuff was muddying the waters for this kind of change. I didn't run any code, but the integration looks correct and complete. Nice work!\nIt's a shame to have to write these \"backward compatibility\" wrappers for new code, but it seems to be the only plausible way to continue to support nice forms like on: .main. So thanks for slogging through the boilerplate.\nAn unrelated comment: as someone new to the cancellation API, it seems a bit strange to me that cancellize() is a free function that takes a Thenable parameter rather than just being a method on Thenable. The rest of the PromiseKit API is largely chaining-oriented. Is cancellization represented this way to intentionally mark it as something extra and separate from the normal API, or...?\nI wonder about cancellize, too. It's snappy, but since it's a coinage, you can't really intuit the meaning, although you can probably make a good guess. To the extent that it does have an English meaning, it's kind of misleading. If someone said they were going to \"cancellize my auto insurance\", you'd probably assume it was a fancy way of saying they were cancelling it.\nMaybe it's worth biting the bullet and going with something clunky but clear like makeCancellable(). I thought it might be a bit nonstandard, but it turns out that make is in fact the Swift API design guide's recommendation for factory methods (e.g., makeIterator()).\nWhy is the user-facing cancellation protocol CancellableTask and not just Cancellable?. > I tried to be thorough thinking we can easily delete boilerplate/wrappers later if they aren't really needed. Should the backwards compatible wrappers be marked as deprecated?\nWhat you have looks just right as it is. I can do a more detailed pass through once this is integrated, but it's probably not going to turn up much.\nI put \"backward compatibility\" in quotes because the wrappers are really just there to allow the existing API to continue forward into the future -- not (only) because that API is already being used, but because it's clearer and more concise than a Dispatcher-only API would be. Dispatcher is a protocol, and protocols can't have static members, so there's no way to allow on: .main or on: .global() if the argument is typed as a Dispatcher. You could spell out DispatchQueue.main, but that's not nearly as nice. That's the motivation for having DispatchQueue-typed wrappers even for new API.\nRegarding cancellize, I was really just wondering why it's \nswift\ncancellize(Promise.value(2 + x))\nrather than\nswift\nPromise.value(2 + x).cancellize()\nOf course, the distinction is largely stylistic. But aside from not arousing the attention of the Free Function Police, a method on Thenable would allow you use cancellize smoothly as a regular chain element, e.g.\nswift\nPromise.value(2 + x).cancellize().then { ... }\nIs it wrong of me to think of cancellization this way? \nI guess I'm thinking more broadly that if head-to-toe-cancellable chains are the recommended happy path, shouldn't CancellablePromise's then method automatically wrap the returned promise if it's not already cancellable? In other words, instead of\nswift\nfirstly {\n    cancellize(Promise.value(1))\n).then { x in\n    cancellize(Promise.value(2 + x))\n).then { x in\n    cancellize(Promise.value(3 + x))\n}\nas shown above, why not\nswift\nfirstly {\n    Promise.value(1)\n).cancellize().then { x in\n    Promise.value(2 + x)\n).then { x in\n    Promise.value(3 + x)\n}\n. Great! I'm glad the comments were helpful. I'm looking forward to trying this out!. I have some code that will use this once it gets into the v7 beta. The design looks good to me.. Yes. See comments here in the thread for #888. A relatively recent compiler is required, even for Swift 3, so the test configuration has to change.\nThis .travis.yml also has some support for harvesting build artifacts (for Travis debugging) and auto-building arbitrary branches. Those features have no effect if you don't define Travis environment variables to enable/configure them. But if you don't want to accept those changes, you can just reverse commits 0b936fd, f78eaf1, and 0da820a. (Or I can prepare a branch with those changes.)\n. Don't I know it! It was something of a project to get the Travis configuration updated.\nI put the order back to mirror the trunk version, but it still doesn't diff very cleanly because a lot of sections are self-similar. So here's a guide. General comments: \n1) in some of the existing configurations, an xcode10.1 image was used but the name identified it as Xcode 10.0. I updated the names to match the actual image version.\n2) I updated some of the names to make them more detailed/explicit so that it was easier to tell exactly what was failing in the Travis dashboard.\n3) The main reason to touch this file at all is that you need a current compiler for Swift 3, so some cases that addressed Swift 3 in combination with Xcode < 10 or tools < 4.2 were removed. Swift 4 works back to Xcode 9 and 4.0.3, so those configurations stayed.\n4) The original Linux schedule seems to have compiled for Swift 3 under 4.0.3, 4.1.2, and 4.2.1, but only 4.1.2 for Swift 4. And it tested only 4.0.3/Swift 4 and 4.2.1/Swift 4. This seemed a bit odd. It now builds for Swift 3 on 4.2.1 and for Swift 4 on 4.0.3, 4.1.2, and 4.2.1, with testing being done on these same combinations. I can put this all back if I've messed something up. \n5) Should there be Swift 4 tests for iOS and tvOS? These seem to be built for Swift 3 only.\nDetailed list of changes:\n```\ncarthage/compile rm xcode8.3\ncarthage/compile rm xcode9.2\ncarthage/compile rm xcode9.4\ncarthage/compile add xcode10.1 and Swift 3.4 combination\ncarthage/compile make xcode10.1 and Swift 4 request explicit SWIFT_VERSION=4.2\npod/lint make baseline xcode10.1, SWIFT=3.4 instead of xcode8.3/Swift 3.1\npod/lint rm xcode8.3 for Swift 3\npod/lint rm xcode9.2 for Swift 3\npod/lint rm xcode9.4 for Swift 3\nlinux/compile make baseline tools 4.2.1 instead of tools 4.0.3 (Swift 3)\nOther changes as outlined above\nmac/test make baseline xcode10.1/3 instead of xcode8.3/3\nmac/test rm xcode9.2/4\nmac/test rm xcode9.4/4\nmac/test fix name of xcode10.1/4 scenario to reflect Xcode 10.1\nios/test fix name of xcode10.1/3 scenario to reflect Xcode 10.1 \ntvos/test fix name of xcode10.1/3 scenario to reflect Xcode 10.1\n```. Doesn't look too bad - let me take a stab at it. It'll be a good orientation to your updates.. There doesn\u2019t seem to be an Xcode project at the current V7 tip. Is this the intended state? . Yes, OK to merge if you're ready for it.\nThere are a couple of issues (that we already talked about) yet to address, so I want to be sure you're aware that this is still WIP code from my perspective. (Though it should be 100% working and near-final API.) If you'd rather defer until I have something that looks completely done to me, that would be fine too. I mostly just wanted to get synced with the v7 line and get a sense of the v7 changes before finalizing.. Ah, yes, that makes sense. I'll poke around a bit.. After considering this a bit more, I'm thinking that the larger problem here is that relatively few callback-invoking functions have no arguments other than the callback, so the utility of this specific form is probably pretty limited. More typical would be something like\nfunc fetchThing(thingName: String, _ callback: (Thing?, Error?) -> Void)\nI would imagine the closest you could come to handling these cases would be something like\nPromise(fetchThing, \"thing name\").done { ... }\nbut that would seem to require a lot of different templates to implement (# of non-callback arguments X various callback signatures). It doesn't preserve argument names, and it's also kind of mysterious for readers who don't understand exactly what's going on.\nJust passing seal.resolve as the callback is nearly as concise, and it handles most cases without any additional PromiseKit code.. Yes, that seems like a real issue and a potential concern. I agree that the docs should advise strongly against returning promises that have a default dispatcher unless there's a specific reason to do that. \nI suspect that a predominant source of problems is likely to be that people set a default dispatcher for notational convenience and then send their promises elsewhere without consciously realizing that they're imposing a dispatcher on the recipient. It's obvious if you even think about it, but it's the kind of cleanup that's easy to overlook.\nI was thinking about what the various failure modes might be and trying to pick out the ones that are most worth worrying about. They're not all equally bad. \nFor example, if you use the default dispatchers and someone puts you on a different thread, and then you try to do main-thread UI stuff, that's usually self-evident pretty quickly because of warning messages or crashes. That seems fine. And similarly, if you're using a nonstandard global default queue, that's probably a pretty good sign that you understand the dispatching system and can be left alone.\nThe really bad failure mode, I think, is when you believe your own code is all main-threaded, but parts actually end up running on two or more threads. So it almost always works, but every so often there's a completely unexplained crash. \ud83d\ude23\nA few possible ways to be safer:\n\n\nRequire chain-specific dispatchers to be unset by the end of the chain. I guess the specifics would be something like: if 1) you reach the transition from map-type elements to return-type elements, and 2) there's a chain-specific default for map, and 3) there is no chain-specific default for return, then print a warning message. Optionally, add the additional requirement that 4) both conf.Q values are DispatchQueue.main (to cut down on warnings). Disadvantage: requires an additional, useless dispatchOn(nil) just to suppress the warning.\n\n\nPropagate defaults up the chain instead of down. When you set a chain-specific default, it does not affect future blocks. Instead, it traverses up the chain, setting the dispatcher for each block whose dispatcher was previously determined by the global default. When you reach a block that already has an explicit dispatcher (including one set by a chain-specific default), stop. Disadvantages: 1) It's really weird. 2) Now you have the reverse problem of potentially inadvertently setting a dispatcher on blocks that were created by other code. (But they must have just been using the defaults, so maybe it's ok...) 3) You lose the ability to return promises with default dispatchers. 4) Touches a lot of code - currently all the dispatchers are tucked away in closures. You'd have to pull them into a Promise instance variable and reference them from there. Also, I don't think there's existing infrastructure to go back in the chain.\n\n\nExplicit scoping with brackets. This is essentially a formalization of the way conf.Q actually works now, so it's easy to implement. For example:\n\n\nswift\ndispatchOn(.global()) {\n    firstly {\n        doTimeConsumingThing()\n    }. then { a in\n        doOtherTimeConsumingThing().map { (a, $0) }\n    }\n}.done { ab in ... }\nDisadvantages: 1) You lose the ability to return promises with default dispatchers. 2) Ugly code with another layer of nesting to track. 3) firstly would probably have to run on the stated dispatcher, different from now. . ",
    "elimence": "This is super helpful, I've tested this in my code and it works as expected.\nThanks for the quick response :). Great thanks \ud83d\udc4d . ",
    "huyvoduc": "Thanks so much ! You saved my day. ",
    "dermaaarkus": "Example Project: \nPromiseKitExample.zip\n. ",
    "dougzilla32": "I've create the pull requests for packaging options 1 and 2.  I see that some of the Travis builds are failing for the pull requests, and am working on fixes now.\n. Awesome!  Yes, I totally understand about keeping PromiseKit concise and high quality.  I'm really up for any of the 3 options or anything else you have in mind.  And yes, it is a lot so no need to rush anything -- better to take the time and make great decisions.\nMy preference above is based purely on how easy it is for people to use the new cancellation feature, and putting myself in your shoes I see that stability and maintaining high quality are high priority concerns.  A nice upside with this delegate approach is it can be integrated or decoupled as desired!\nThe Travis builds for all the cancellation pull requests are passing, with the exception of some Swift Package Manager related issues in the Foundation extension build.  Will see if I can get those green as well.  I would say it is ready for review!. Responding to Zden\u011bk's excellent questions --\nCC suffix\nI agree, I don't much like the 'CC' suffix.  But I failed to come up with something better.  I discovered that there needs to be something different about the signature for all methods that create a cancellable promise or cancellable guarantee, otherwise you run into many ambiguous situations that would both break existing code and make writing new cancellable code tedious.\nFor example without the 'CC' suffix or some equivalent, code like the following gives 'ambiguous' compilation errors:\n```\nfirstly {\n  urlSession.dataTask(\u2026)\n}.done { data in\n  \u2026\n}\nafter(seconds: 0.3).done {\n  \u2026\n}\n```\nTo make it work you'd need to explicitly specify the types.  For regular promises this is not an option because it would break existing code --\n```\nfirstly { () -> Promise<(data: Data, response: URLResponse)>\n  urlSession.dataTask(\u2026)\n}.done { data in\n  \u2026\n}\nlet a: Gurantee = after(seconds: 0.3)\na.done {\n  \u2026\n}\n```\nAnd for cancellable promises it would be quite tedious --\n```\nfirstly { () -> CancellablePromise<(data: Data, response: URLResponse)>\n  urlSession.dataTask(\u2026)\n}.done { data in\n  \u2026\n}\nlet a: CancellablePromise = after(seconds: 0.3)\na.done {\n  \u2026\n}\n```\nOriginally I went with 'cancellable' as a prefix rather than the 'CC' suffix, but 'cancellable' just felt too long to put everywhere.  I also tried using a new required paramter but that looked ugly as well.\nSo I settled on 'CC', which I supposed could be considered a very abbreviated version of 'Cancellable'.  Therefore 'dataTaskCC' is an abbreviation for 'dataTaskCancellable', meaning the cancellable varient of dataTask.\nWould 'WithCancel' abbreviated 'WCL' or 'WCC' be better?  For example 'dataTaskWithCancel' abbreviated to 'dataTaskWCL'?  Or a longer abbreviation for cancellable like 'CNBL'?  Well, that last one sounds more like cannibal.  Hmmmm.\nI'm open to ideas on this one!!  The problem could be completely avoided by baking cancellation directly into Promise and Guarantee (i.e. a new 'cancel' method on those classes), but this would make everything cancellable which has its own drawbacks.\nBtw, one of the risks of the new cancellation code is breaking existing code with 'ambiguous' compilation errors.  I wrote a bunch of tests to alleviate this risk and hopefully caught all the cases.  I got some of these errors where I really thought it should be unambiguous, but the current compiler seems rather tempermental in this particular area.\nWhy touch all promises?\nI'm understanding this question as, why have cancellable versions for Thenable, Guaratee, after, firstly, hang, race and when?  The reason is simply, I want to provide cancellation abilities for the entire PromiseKit API.  Done this way, you can add cancellation abilities to any existing code simply by adding the 'CC' suffix (or some alternative) to the methods that are actually creating the promises.\nThe above example --\n```\nfirstly {\n  urlSession.dataTask(\u2026)\n}.done { data in\n  \u2026\n}\nafter(seconds: 0.3).done {\n  \u2026\n}\n```\nbecomes cancellable with minor changes:\n```\nfirstly {\n  urlSession.dataTaskCC(\u2026)\n}.done { data in\n  \u2026\n}\nafterCC(seconds: 0.3).done {\n  \u2026\n}\n```\nThank you for the feedback!!. Yes, agreed -- this proposal is for cancelling promises externally.  And, the idea is that this can be done with very minimal code changes.\nI agree with Zden\u011bk's image loading example where you just want to cancel the whole operation.  Another example is a user typing with search completions -- with each keystroke, you want to cancel the previous search (of course you'd introduce a small delay to reduce the number of search operations which you can conveniently do with 'after', but I digress).\nIn fact, the only code change necessary is to specify that you want the 'cancellable' option.  This is what all the 'CC' methods are for, they are saying that you want the chain to be cancellable.  A different approach would be to use a flag or parameter instead of the 'CC' suffix.  You just need something there to say you want cancellation ability.\nThe 'cancelIf' could work well, but I'm trying to avoid requiring the developer to add new code for handling cancellation.  I think it is quite nice to just call 'cancel', and it just stops executing without executing any more code blocks.  If you need to add some cancellation handling code you can do it in the 'catch' with the '.allErrors' policy.\nOR, it is possible to simply default to having everything be 'cancellable'.  Then there would be no need to specify a 'cancellable' option and the 'CC' methods would go away.  The 'cancel()' method would be defined right inside 'Promise' rather than 'CancellablePromise'.\nPerhaps for completeness it would be good exercise to create a pull request for 'Option Zero', where everything defaults to be cancellable.  There would be no 'CC' methods and 'cancel()' would be defined directly inside 'Promise'.  I've been proceeding on the assumption that cancellation should be optional, but perhaps this comes at the cost of a less intuitive API.  I realize there are some big downsides to having cancellation as a default.  But 'Option Zero' could be useful for comparison at least.  I'll give it a go.\nThe to summarize the options (as defined in the Packaging section above):\n0) the opposite of option 3, no new extensions and no 'CancellablePromise, everything is done in the existing classes\n1)  'CancellablePromise' is part of the core PromiseKit and cancellation is built into the extensions that can support it\n2) 'CancellablePromise' is a PromiseKit extension and cancellation is built into the extensions that can support it\n3) the opposite of option zero,  the PromiseKit code base is unchanged and everything is done with 'CancellablePromise' and all new extensions\n. Regarding cancelIf -- got it!  In fact, part of what CancellablePromise does is just like cancelIf: it checks if the promise has been cancelled before executing the next code block.  If it has been cancelled then it calls reject on the resolver for the promise.\nThe builtin cancel method actually keeps track of all pending promises in a chain, and for each of these calls cancel on the underlying task and calls reject on the promise's resolver.  It does this by using the CancelContext class to track pending promises along with their underlying tasks and reject methods.  The behavior of calling cancel on the underlying task depends on the type of task. \n. This is great!  I really like your suggestion for a cancelable wrapper, and I agree that afterCC and CancellableGuarantee can be dropped by using the wrapper (along with valueCC, firstlyCC, hangCC, raceCC, whenCC, etc.).  I am trying it out in the code.\nHaving cancelation as an opt-in feature sounds great to me!\nA couple questions:\nWhat is the best way to eliminate the CC methods for the inherently cancelable extensions?\n\n\nAll 'CC' methods could be replaced with the wrapper. To make this work I am thinking Thenable would need a new package private optional property where you could stash the cancelable task, if there is one.  This property would be used if the Promise/Guarantee is subsequently wrapped with cancelable.  What are the potential drawbacks with having a strong reference to the underlying task for all Promises/Guarantees that could be canceled?\n\n\nOR it could be done with a flag parameter that defaults to non-cancelable.  No need for a new property in Thenable for this case.\n\n\nBtw I've been spelling 'cancellable' with two Ls to match the existing CancellableError.  I googled and on grammarly.com it says that in the US we like to use 'cancelable' whereas with British english it is 'cancellable'.  The exception is that 'cancellation' always has two Ls.  cancelable would be a bit shorter \u2014 any preference?\n. This is pretty much ready to go, pending additional review.  Docs and code are all in shape to be reviewed now.   The 'Documentation/Cancel.md' doc is much clearer now. \n'CC' methods are gone and 'CancellableGuarantee' is gone.  Everything is passing in the CI reports.\nMore details are available in the pull request:  https://github.com/mxcl/PromiseKit/pull/899. ## I've updated the 'Cancel' doc to match the latest code, please feel free to provide feedback!!  Here is the latest (nearly finalized?) version:\nCancelling Promises\nPromiseKit 7 adds clear and concise cancellation abilities to promises and to the PromiseKit extensions.  Cancelling promises and their associated tasks is now simple and straightforward.  Promises and promise chains can safely and efficiently be cancelled from any thread at any time.\n```swift\nUIApplication.shared.isNetworkActivityIndicatorVisible = true\nlet fetchImage = cancellable(URLSession.shared.dataTask(.promise, with: url)).compactMap{ UIImage(data: $0.data) }\nlet fetchLocation = cancellable(CLLocationManager.requestLocation()).lastValue\nlet promise = firstly {\n    when(fulfilled: fetchImage, fetchLocation)\n}.done { image, location in\n    self.imageView.image = image\n    self.label.text = \"(location)\"\n}.ensure {\n    UIApplication.shared.isNetworkActivityIndicatorVisible = false\n}.catch(policy: .allErrors) { error in\n    / 'catch' will be invoked with 'PMKError.cancelled' when cancel is called on the context.\n       Use the default policy of '.allErrorsExceptCancellation' to ignore cancellation errors. /\n    self.show(UIAlertController(for: error), sender: self)\n}\n//\u2026\n// Cancel currently active tasks and reject all cancellable promises with 'PMKError.cancelled'.\n// 'cancel()' can be called from any thread at any time.\npromise.cancel()\n/ 'promise' here refers to the last promise in the chain.  Calling 'cancel' on\n   any promise in the chain cancels the entire chain.  Therefore cancelling the\n   last promise in the chain cancels everything. /\n```\nCancel Chains\nPromises can be cancelled using a CancellablePromise.  The global cancellable(_:) function is used to convert a standard Promise into a CancellablePromise.  If a promise chain is initiazed with a CancellablePromise, then the entire chain is cancellable.  Calling cancel() on any promise in the chain cancels the entire chain.  \nCreating a chain where the entire chain can be cancelleed is the recommended usage for cancellable promises.\nThe CancellablePromise contains a CancelContext that keeps track of the tasks and promises for the chain.  Promise chains can be cancelled either by calling the cancel() method on any CancellablePromise in the chainm, or by calling cancel() on the CancelContext for the chain. It may be desirable to hold on to the CancelContext directly rather than a promise so that the promise can be deallocated by ARC when it is resolved.\nFor example:\n```swift\nlet context = firstly {\n    / The 'cancellable' function initiates a cancellable promise chain by\n       returning a 'CancellablePromise'. /\n    cancellable(login())\n}.then { creds in\n    cancellable(fetch(avatar: creds.user))\n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}.cancelContext\n// \u2026\n/ Note: Promises can be cancelled using the 'cancel()' method on the 'CancellablePromise'.\n   However, it may be desirable to hold on to the 'CancelContext' directly rather than a\n   promise so that the promise can be deallocated by ARC when it is resolved. /\ncontext.cancel()\n```\nCreating a partially cancellable chain\nA CancellablePromise can be placed at the start of a chain, but it cannot be embedded directly in the middle of a standard (non-cancellable) promise chain.  Instead, a partially cancellable promise chain can be used.  A partially cancellable chain is not the recommended way to use cancellable promises, although there may be cases where this is useful.\nConvert a cancellable chain to a standard chain\nCancellablePromise wraps a delegate Promise, which can be accessed with the promise property.  The above example can be modified as follows so that once login() completes, the chain can no longer be cancelled:\n```swift\n/ Here, by calling 'promise.then' rather than 'then' the chain is converted from a cancellable\n   promise chain to a standard promise chain. In this example, calling 'cancel()' during 'login'\n   will cancel the chain but calling 'cancel()' during the 'fetch' operation will have no effect: /\nlet cancellablePromise = firstly {\n    promise = cancellable(login())\n}\ncancellablePromise.promise.then {\n    fetch(avatar: creds.user)    \n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n// \u2026\n/ This will cancel the 'login' but will not cancel the 'fetch'.  So whether or not the\n   chain is cancelled depends on how far the chain has progressed. /\ncancellablePromise.cancel()\n```\nConvert a standard chain to a cancellable chain\nA non-cancellable chain can be converted to a cancellable chain in the middle of the chain as follows:\n```swift\n/ In this example, calling 'cancel()' during 'login' will not cancel the login.  However,\n   the chain will be cancelled immediately, and the 'fetch' will not be executed.  If 'cancel()'\n   is called during the 'fetch' then both the 'fetch' itself and the promise chain will be\n   cancelled immediately. /\nlet promise = cancellable(firstly {\n    login()\n}).then {\n    cancellable(fetch(avatar: creds.user))   \n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n// \u2026\npromise.cancel()\n```\nTroubleshooting\nAt the time of this writing, the swift compiler error messages are usually misleading if there is a compile-time error in a cancellable promise chain.  Here are a few examples where the compiler error is not helpful.\nCancellable promise embedded in the middle of a standard promise chain\nError: Ambiguous reference to member firstly(execute:).  Fixed by adding cancellable to login().\n```swift\nlet promise = firstly {  /// <-- ERROR: Ambiguous reference to member 'firstly(execute:)'\n    / The 'cancellable' function initiates a cancellable promise chain by\n       returning a 'CancellablePromise'. /\n    login() /// SHOULD BE: \"cancellable(login())\"\n}.then { creds in\n    cancellable(fetch(avatar: creds.user))\n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n// ...\npromise.cancel()\n```\nThe return type for a multi-line closure returning CancellablePromise is not explicitly stated\nThe Swift compiler cannot (yet) determine the return type of a multi-line closure.  \nThe following example gives the unhelpful error: Enum element allErrors cannot be referenced as an instance member.  This is fixed by explicitly declaring the return type as a CancellablePromise.\n```swift\nlet promise = firstly {\n    cancellable(login())\n}.then { creds in /// SHOULD BE: \"}.then { creds -> CancellablePromise in\"\n    let f = fetch(avatar: creds.user)\n    return cancellable(f)\n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in  /// <-- ERROR: Enum element 'allErrors' cannot be referenced as an instance member\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n// ...\npromise.cancel()\n```\nDeclaring a Promise return type instead of CancellablePromise\nYou'll get a very misleading error message if you declare a return type of Promise where it should be CancellablePromise.  This example yields the obtuse error: Ambiguous reference to member firstly(execute:).  This is fixed by declaring the return type as a CancellablePromise rather than a Promise.\n```swift\nlet promise = firstly {  /// <-- ERROR: Ambiguous reference to member 'firstly(execute:)'\n    / The 'cancellable' function initiates a cancellable promise chain by\n       returning a 'CancellablePromise'. /\n    cancellable(login())\n}.then { creds -> Promise in /// SHOULD BE: \"}.then { creds -> CancellablePromise in\"\n    let f = fetch(avatar: creds.user)\n    return cancellable(f)\n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n// ...\npromise.cancel()\n```\nTrying to cancel a standard promise chain\nError: Value of type PMKFinalizer has no member cancel.  Fixed by adding cancellable to both login() and fetch().\n```swift\nlet promise = firstly {\n    login() /// SHOULD BE: \"cancellable(login())\"\n}.then { creds in\n    fetch(avatar: creds.user) /// SHOULD BE: cancellable(fetch(avatar: creds.user))\n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n// ...\npromise.cancel()  /// <-- ERROR: Value of type 'PMKFinalizer' has no member 'cancel'\n```\nCore Cancellable PromiseKit API\nThe following classes, methods and functions have been added to PromiseKit to support cancellation. Existing functions or methods with underlying tasks that can be cancelled are indicated by being wrapped with 'cancellable()'.\nGlobal functions\n    cancellable(_:)                 - Accepts a Promise or Guarantee and returns a CancellablePromise,\n                                      which is a cancellable variant of the given Promise or Guarantee\n\n    cancellable(after(seconds:))    - 'after' with seconds can be cancelled\n    cancellable(after(_:))          - 'after' with interval can be cancelled\n\n    firstly(execute:)               - Accepts body returning CancellablePromise\n    hang(_:)                        - Accepts CancellablePromise\n    race(_:)                        - Accepts [CancellablePromise]\n    when(fulfilled:)                - Accepts [CancellablePromise]\n    when(fulfilled:concurrently:)   - Accepts iterator of type CancellablePromise\n    when(resolved:)                 - Accepts [CancellablePromise]\n\nCancellablePromise properties and methods\n    promise                         - Delegate Promise for this CancellablePromise\n    result                          - The current Result\n\n    init(_ bridge:cancelContext:)   - Initialize a new cancellable promise bound to the provided Thenable\n    init(task:resolver body:).      - Initialize a new cancellable promise that can be resolved with\n                                       the provided '(Resolver) throws -> Void' body\n    init(task:promise:resolver:)    - Initialize a new cancellable promise using the given Promise\n                                       and its Resolver\n    init(task:error:)               - Initialize a new rejected cancellable promise\n    init(task:)                     - Initializes a new cancellable promise fulfilled with Void\n\n    pending() -> (promise:resolver:)  - Returns a tuple of a new cancellable pending promise and its\n                                        Resolver\n\nCancellableThenable properties and methods\n    thenable                        - Delegate Thenable for this CancellableThenable\n\n    cancel(error:)                  - Cancels all members of the promise chain\n    cancelContext                   - The CancelContext associated with this CancellableThenable\n    cancelItemList                  - Tracks the cancel items for this CancellableThenable\n    isCancelled                     - True if all members of the promise chain have been successfully\n                                      cancelled, false otherwise\n    cancelAttempted                 - True if 'cancel' has been called on the promise chain associated\n                                      with this CancellableThenable, false otherwise\n    cancelledError                  - The error generated when the promise is cancelled\n    appendCancellableTask(_ task:reject:)  - Append the CancellableTask to our cancel context\n    appendCancelContext(from:)      - Append the cancel context associated with 'from' to our\n                                      CancelContext\n\n    then(on:flags:_ body:)           - Accepts body returning CancellableThenable\n    cancellableThen(on:flags:_ body:)  - Accepts body returning Thenable\n    map(on:flags:_ transform:)\n    compactMap(on:flags:_ transform:)\n    done(on:flags:_ body:)\n    get(on:flags:_ body:)\n    tap(on:flags:_ body:)\n    asVoid()\n\n    error\n    isPending\n    isResolved\n    isFulfilled\n    isRejected\n    value\n\n    mapValues(on:flags:_ transform:)\n    flatMapValues(on:flags:_ transform:)\n    compactMapValues(on:flags:_ transform:)\n    thenMap(on:flags:_ transform:)                 - Accepts transform returning CancellableThenable\n    cancellableThenMap(on:flags:_ transform:)      - Accepts transform returning Thenable\n    thenFlatMap(on:flags:_ transform:)             - Accepts transform returning CancellableThenable\n    cancellableThenFlatMap(on:flags:_ transform:)  - Accepts transform returning Thenable\n    filterValues(on:flags:_ isIncluded:)\n    firstValue\n    lastValue\n    sortedValues(on:flags:)\n\nCancellableCatchable properties and methods\n    catchable                                      - Delegate Catchable for this CancellableCatchable\n    catch(on:flags:policy::_ body:)                - Accepts body returning Void\n    recover(on:flags:policy::_ body:)              - Accepts body returning CancellableThenable\n    cancellableRecover(on:flags:policy::_ body:)   - Accepts body returning Thenable\n    ensure(on:flags:_ body:)                       - Accepts body returning Void\n    ensureThen(on:flags:_ body:)                   - Accepts body returning CancellablePromise\n    finally(_ body:)\n    cauterize()\n\n Extensions\nCancellation support has been added to the PromiseKit extensions, but only where the underlying asynchronous tasks can be cancelled. This example Podfile lists the PromiseKit extensions that support cancellation along with a usage example:\npod \"PromiseKit/Alamofire\"\n# cancellable(Alamofire.request(\"http://example.com\", method: .get).responseDecodable(DecodableObject.self))\n\npod \"PromiseKit/Bolts\"\n# CancellablePromise(\u2026).then() { _ -> BFTask in /*\u2026*/ }  // Returns CancellablePromise\n\npod \"PromiseKit/CoreLocation\"\n# cancellable(CLLocationManager.requestLocation()).then { /*\u2026*/ }\n\npod \"PromiseKit/Foundation\"\n# cancellable(URLSession.shared.dataTask())(.promise, with: request).then { /*\u2026*/ }\n\npod \"PromiseKit/MapKit\"\n# cancellable(MKDirections(\u2026).calculate()).then { /*\u2026*/ }\n\npod \"PromiseKit/OMGHTTPURLRQ\"\n# cancellable(URLSession.shared.GET(\"http://example.com\")).then { /*\u2026*/ }\n\npod \"PromiseKit/StoreKit\"\n# cancellable(SKProductsRequest(\u2026).start(.promise)).then { /*\u2026*/ }\n\npod \"PromiseKit/SystemConfiguration\"\n# cancellable(SCNetworkReachability.promise()).then { /*\u2026*/ }\n\npod \"PromiseKit/UIKit\"\n# cancellable(UIViewPropertyAnimator(\u2026).startAnimation(.promise)).then { /*\u2026*/ }\n\nHere is a complete list of PromiseKit extension methods that support cancellation:\nAlamofire\nAlamofire.DataRequest\n    cancellable(response(_:queue:))\n    cancellable(responseData(queue:))\n    cancellable(responseString(queue:))\n    cancellable(responseJSON(queue:options:))\n    cancellable(responsePropertyList(queue:options:))\n    cancellable(responseDecodable(queue::decoder:))\n    cancellable(responseDecodable(_ type:queue:decoder:))\n\nAlamofire.DownloadRequest\n    cancellable(response(_:queue:))\n    cancellable(responseData(queue:))\n\nBolts\nCancellablePromise<T>\n    then<U>(on: DispatchQueue?, body: (T) -> BFTask<U>) -> CancellablePromise \n\nCoreLocation\nCLLocationManager\n    cancellable(requestLocation(authorizationType:satisfying:))\n    cancellable(requestAuthorization(type requestedAuthorizationType:))\n\nFoundation\nNotificationCenter:\n    cancellable(observe(once:object:))\n\nNSObject\n    cancellable(observe(_:keyPath:))\n\nProcess\n    cancellable(launch(_:))\n\nURLSession\n    cancellable(dataTask(_:with:))\n    cancellable(uploadTask(_:with:from:))\n    cancellable(uploadTask(_:with:fromFile:))\n    cancellable(downloadTask(_:with:to:))\n\nCancellablePromise\n    validate()\n\nHomeKit \nHMPromiseAccessoryBrowser\n    cancellable(start(scanInterval:))\n\nHMHomeManager\n    cancellable(homes())\n\nMapKit \nMKDirections\n    cancellable(calculate())\n    cancellable(calculateETA())\n\nMKMapSnapshotter\n    cancellable(start())\n\nStoreKit \nSKProductsRequest\n    cancellable(start(_:))\n\nSKReceiptRefreshRequest\n    cancellable(promise())\n\nSystemConfiguration\nSCNetworkReachability\n    cancellable(promise())\n\nUIKit \nUIViewPropertyAnimator\n    cancellable(startAnimation(_:))\n\nChoose Your Networking Library\nAll the networking library extensions supported by PromiseKit are now simple to cancel!\nAlamofire\n```swift\n// pod 'PromiseKit/Alamofire'\n// # https://github.com/PromiseKit/Alamofire\nlet context = firstly {\n    cancellable(Alamofire\n        .request(\"http://example.com\", method: .post, parameters: params)\n        .responseDecodable(Foo.self))\n}.done { foo in\n    //\u2026\n}.catch { error in\n    //\u2026\n}.cancelContext\n//\u2026\ncontext.cancel()\n```\nAnd (of course) plain URLSession from Foundation:\n```swift\n// pod 'PromiseKit/Foundation'\n// # https://github.com/PromiseKit/Foundation\nlet context = firstly {\n    cancellable(URLSession.shared.dataTask(.promise, with: try makeUrlRequest()))\n}.map {\n    try JSONDecoder().decode(Foo.self, with: $0.data)\n}.done { foo in\n    //\u2026\n}.catch { error in\n    //\u2026\n}.cancelContext\n//\u2026\ncontext.cancel()\nfunc makeUrlRequest() throws -> URLRequest {\n    var rq = URLRequest(url: url)\n    rq.httpMethod = \"POST\"\n    rq.addValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    rq.addValue(\"application/json\", forHTTPHeaderField: \"Accept\")\n    rq.httpBody = try JSONSerialization.jsonData(with: obj)\n    return rq\n}\n```\nCancellability Goals\n\nProvide a streamlined way to cancel a promise chain, which rejects all associated promises and cancels all associated tasks. For example:\n\nswift\nlet promise = firstly {\n    cancellable(login()) // Use the 'cancellable' function to initiate a cancellable promise chain\n}.then { creds in\n    fetch(avatar: creds.user)\n}.done { image in\n    self.imageView = image\n}.catch(policy: .allErrors) { error in\n    if error.isCancelled {\n        // the chain has been cancelled!\n    }\n}\n//\u2026\npromise.cancel()\n\n\nEnsure that subsequent code blocks in a promise chain are never called after the chain has been cancelled\n\n\nFully support concurrecy, where all code is thead-safe.  Cancellable promises and promise chains can safely and efficiently be cancelled from any thread at any time.\n\n\nProvide cancellable support for all PromiseKit extensions whose native tasks can be cancelled (e.g. Alamofire, Bolts, CoreLocation, Foundation, HealthKit, HomeKit, MapKit, StoreKit, SystemConfiguration, UIKit)\n\n\nSupport cancellation for all PromiseKit primitives such as 'after', 'firstly', 'when', 'race'\n\n\nProvide a simple way to make new types of cancellable promises\n\n\nEnsure promise branches are properly cancelled.  For example:\n\n\n```swift\nimport Alamofire\nimport PromiseKit\nfunc updateWeather(forCity searchName: String) {\n    refreshButton.startAnimating()\n    let context = firstly {\n        cancellable(getForecast(forCity: searchName))\n    }.done { response in\n        updateUI(forecast: response)\n    }.ensure {\n        refreshButton.stopAnimating()\n    }.catch { error in\n        // Cancellation errors are ignored by default\n        showAlert(error: error) \n    }.cancelContext\n//\u2026\n\n/* **** Cancels EVERYTHING (except... the 'ensure' block always executes regardless)    \n   Note: non-cancellable tasks cannot be interrupted.  For example: if 'cancel()' is\n   called in the middle of 'updateUI()' then the chain will immediately be rejected,\n   however the 'updateUI' call will complete normally because it is not cancellable.\n   Its return value (if any) will be discarded. */\ncontext.cancel()\n\n}\nfunc getForecast(forCity name: String) -> CancellablePromise {\n    return firstly {\n        cancellable(Alamofire.request(\"https://autocomplete.weather.com/(name)\")\n            .responseDecodable(AutoCompleteCity.self))\n    }.then { city in\n        cancellable(Alamofire.request(\"https://forecast.weather.com/(city.name)\")\n            .responseDecodable(WeatherResponse.self)) \n    }.map { response in\n        format(response)\n    }\n}\n``\n. Agreed, I like your idea to wrap the Guarantee withcancelableif you want the ability to cancel/abandon the guarantee (after` is a great example).. I've deleted CancellableGuarantee and put in a 'cancellable' global function that takes a Promise/Guarantee.  This enabled me to delete a bunch of 'CC' functions.\nIn the extensions I renamed methods with the 'CC' suffix to use a 'cancellable' prefix instead.\nA few questions --\n\nThe cancellable function bridges to the underlying Promise/Guarantee (Thenable) as follows.  I'm not entirely sure this is the best way to do it, as the underlying Promise will not be rejected.  Only the wrapper Promise is rejected.  Can this be improved?\n/// Initialize a new cancellable promise bound to the provided `Thenable`.\n    public convenience init<U: Thenable>(task: CancellableTask? = nil, _ bridge: U) where U.T == T {\n        var reject: ((Error) -> Void)!\n        self.init(Promise { seal in\n            reject = seal.reject\n            bridge.done(on: nil) {\n                seal.fulfill($0)\n            }.catch {\n                seal.reject($0)\n            }\n        })\n        self.appendCancellableTask(task: task, reject: reject)\n    }\nI could change all the cancellable extensions to use the cancellable global function instead of defining cancellable variants.  For example: cancellable(Alamofire.request(\"http://example.com\", method: .get).responseJSON()) rather than Alamofire.request(\"http://example.com\", method: .get).cancellableResponseJSON().  This would require adding a property with type CancellableTask to Promise/Guarantee to keep track of the task to cancel.  Comments?\nHow many Ls should be in cancelable/cancellable?  I have it as two Ls right now, matching the existing PromiseKit code.  If we decide on one L then a few existing properties and the CancellableError protocol would need to be marked as deprecated.. Ok cool -- I've been squashing, but after merging from the master repo and then some further changes on my part the commits got interleaved between mine and others.. Ok!  This is ready for another review.  The file diffs were temporarily messed up because I pulled in the latest changes from master using git merge instead of git rebase (oops).  I was able to fix it after reading up on git rebase -- quite interesting!\n\nThe following are some questions, concerns, and feedback that has been incorporated.\nHolding a reference to a CancellableTask inside Promise/Guarantee\nOf particular interest to review are the changes I made to Promise.swift and Guarantee.swift.  I am stashing away the CancellableTask (if there is one) in the Promise/Guarantee, so that the 'cancellable' function can later figure out what needs to be cancelled.\nhttps://github.com/mxcl/PromiseKit/pull/899/files#diff-b9553d21255e0e41a9f3dfe3fd942d94\nhttps://github.com/mxcl/PromiseKit/pull/899/files#diff-17cb84b70ac8d8ad79f2fa8942787098\nThe CancellableTask is always stored regardless of whether 'cancellable' is later used. The concern is if holding a reference to the CancellableTask inside the Promise/Guarantee will cause any problems.  I'd rather not hold on to this reference, but I couldn't think of another way to accomplish this.\nMy reasoning is that the 'cancellable' function should always provide the ability to properly cancel the Promise or Guarantee passed to it.  For example, cancelling a Promise from URLSession should always cancel the URLSessionTask in addition to rejecting the Promise with a CancellableError.  You cannot prevent passing a given Promise or Guarantee to 'cancellable', therefore it must always work properly.\nCancellable 'wrappers' for all Promises that have an underlying CancellableTask\nI went ahead and created 'wrapper' methods for all Promises that have an underlying CancellableTask.  For example, for the URLSession extension the following are equivalent:\nUsing the 'wrapper' method:\nURLSession.shared.cancellableDataTask(.promise, with: rq)\n\nUsing the cancellable function without the 'wrapper':\ncancellable(URLSession.shared.dataTask(.promise, with: rq))\n\nhttps://github.com/PromiseKit/Foundation/pull/9/files#diff-dc78425f8ca5fd7c8de9bec6171994c4\nThe question is, should we provide these 'wrapper' methods?  They are only useful for indicating which \nPromises have an underlying CancellableTask.  Otherwise they are unnecessary.\n'CC' methods and functions are gone\nI have remove all 'CC' methods and functions, and rely on the global cancellable function instead\nlazy is gone\nI figured out how to get rid of all usages of lazy in CancelContext, because as Max pointed out lazy is not thread safe.\nHow many Ls should be in cancelable/cancellable and canceled/cancelled?\nI have it as two Ls right now, matching the existing PromiseKit code. If we decide on one L then a few existing properties with two Ls and the CancellableError protocol would need to be marked as deprecated.\n'Option 2' pull request is gone\nI dropped the 'Option 2' pull request as we are not going in that direction.\nRemaining ToDo\nI am still updating the docs and also adding some tests so that it passes code coverage.\n. Just noticed that Package@swift-4.2.swift is included in 'Files changed', but shouldn't be there.  Everything else is correct.. I've switched to the v7 branch.  Let's merge in Garth Snyder's dispatch queue stuff first, then I'll merge his changes into my pull request (rebase!).  I'll need to change the cancellable method signatures to match his new way of doing dispatch queues.  I will deal with all this so the merge for you guys should be easy peasy.\nAfter merging the cancel stuff into the v7 branch, I will change all the cancellable extension Cartfiles to point at the v7 branch for CI testing.  And when v7 gets merged into master, I'll change them again to point at PromiseKit 7.   We can merge each extension when it is passing CI against PMK 7.\nAll assuming cancellables get the nod for inclusion in PromiseKit 7 -- please let me know if you have any further feedback!. The docs are pretty much complete and are ready for review!\nLooks like the Travis and Codecov are not running for pull requests on the v7 branch.  Can CI be turned on for v7?  Both Travis and Codecov should pass now.\nTravis is green for all the cancellable extensions!\n. \nMy remaining questions and concerns are:\nHolding a reference to a CancellableTask inside Promise/Guarantee\nOf particular interest to review are the changes I made to Promise.swift and Guarantee.swift.  I am stashing away the CancellableTask (if there is one) in the Promise/Guarantee, so that the 'cancellable' function can later figure out what needs to be cancelled.\nhttps://github.com/mxcl/PromiseKit/pull/899/files#diff-b9553d21255e0e41a9f3dfe3fd942d94\nhttps://github.com/mxcl/PromiseKit/pull/899/files#diff-17cb84b70ac8d8ad79f2fa8942787098\nThe CancellableTask is always stored regardless of whether 'cancellable' is later used. The concern is that holding a reference to the CancellableTask inside the Promise/Guarantee will cause some kind of problem.  I'd rather not hold on to this reference, but I couldn't think of another way to accomplish this.\nMy reasoning is that the 'cancellable' function should always provide the ability to properly cancel the Promise or Guarantee passed to it.  For example, cancelling a Promise from URLSession should always cancel the URLSessionTask in addition to rejecting the Promise with a CancellableError.  You cannot prevent passing a given Promise or Guarantee to 'cancellable', therefore it must always work properly.\nCancellable 'wrappers' for all Promises that have an underlying CancellableTask\nI went ahead and created 'wrapper' methods for all Promises that have an underlying CancellableTask.  For example, for the URLSession extension the following are equivalent:\nUsing the 'wrapper' method:\nURLSession.shared.cancellableDataTask(.promise, with: rq)\n\nUsing the cancellable function without the 'wrapper':\ncancellable(URLSession.shared.dataTask(.promise, with: rq))\n\nhttps://github.com/PromiseKit/Foundation/pull/9/files#diff-dc78425f8ca5fd7c8de9bec6171994c4\nThe question is, should we provide these 'wrapper' methods?  They are only useful for indicating which \nPromises have an underlying CancellableTask.  Otherwise they are unnecessary.\nHow many Ls should be in cancelable/cancellable and canceled/cancelled?\nI have it as two Ls right now, matching the existing PromiseKit code. If we decide on one L then a few existing properties with two Ls and the CancellableError protocol would need to be marked as deprecated.\n. I've removed the cancellable wrappers.  After thinking about it, it is confusing to have two ways to do the same thing.  Plus it adds maintenance work for the extensions.\nMy remaining questions are:\n Holding a reference to a CancellableTask inside Promise/Guarantee   <= needs review\n How many L's in cancellable/cancelable <= currently using two L's\nSorry, the git log for the pull request is a bit of a mess.  Will try to fix this up when integrating the dispatch queue changes.\nThe file diffs are good so it is all ready for review.. Excellent!  I\u2019m happy to merge this after #975 is merged.  I\u2019ll change all the \u2018cancellable\u2019 signatures to match #975 and ensure all tests are passing. . Excellent!!  I'm working on the merge now!!\nThe git history got a bit twisted due to various merges and some rebasing.  Once I've merged in the dispatcher changes, I'll open a new PR so that the git history can remain clean.. Ok got it, I'll proceed using this PR.. Agreed that the level of duplication and intrusiveness is unfortunate.  I'm happy to pare down in any areas that make sense and also a 'grand refactor' could help a lot!!\nI'm glad this can be of use and no worries about timing!\nI'll attempt to address all your points and am planning to add some tests to improve code coverage.. Feedback is incorporated and code coverage is improved.\nOne outstanding item: what name should be used for the 'cancellable' function?\nI'm done pending further feedback!. I merged in the latest 'v7' changes and renamed the 'cancellable' function to 'cancellize'.. Thanks!!  I tried to be thorough thinking we can easily delete boilerplate/wrappers later if they aren't really needed.  Should the backwards compatible wrappers be marked as deprecated?  I don't know enough about the trade-off to have an opinion here, just lmk what makes the most sense and I can update the code.\nGreat point about CancellableTask vs Cancellable.  As far as I know it can simply be Cancellable.  I'll go ahead and rename it unless there are objections.\nFor cancellize vs cancellable I don't have a strong opinion.  But makeCancellable seems a bit long to me for how often it needs to appear in a chain of promises.\nIf cancellation were a method on Thenable I believe it would look something like:\n```swift\ncancellizeFirstly {\n    Promise.value(1)\n}.then { x in\n    Promise.value(2 + x)\n}.then { x in\n    Promise.value(3 + x)\n}\nfirstly {\n    Promise.value(1)  // <-- not cancellable\n}.cancellizeThen { x in\n    Promise.value(2 + x)\n}.then { x in\n    Promise.value(3 + x)\n}\n```\nor\n```swift\ncancellizeFirstly {\n    Promise.value(1)\n}.cancellizeThen { x in\n    Promise.value(2 + x)\n}.cancellizeThen { x in\n    Promise.value(3 + x)\n}\nfirstly {\n    Promise.value(1)  // <-- not cancellable\n}.cancellizeThen { x in\n    Promise.value(2 + x)\n}.cancellizeThen { x in\n    Promise.value(3 + x)\n}\n```\nvs how it currently is:\n```swift\nfirstly {\n    cancellize(Promise.value(1))\n).then { x in\n    cancellize(Promise.value(2 + x))\n).then { x in\n    cancellize(Promise.value(3 + x))\n}\nfirstly {\n    Promise.value(1)  // <-- not cancellable\n).then { x in\n    cancellize(Promise.value(2 + x))\n).then { x in\n    cancellize(Promise.value(3 + x))\n}\n```\nor\n```swift\n// Could be changed to something like this\nfirstly {\n    cancellize(Promise.value(1))\n).then { x in\n    Promise.value(2 + x)\n).then { x in\n    Promise.value(3 + x)\n}\nfirstly {\n    Promise.value(1)  // <-- not cancellable\n).then { x in\n    cancellize(Promise.value(2 + x))\n).then { x in\n    Promise.value(3 + x)\n}\n```\nI don't have a strong opinion on this one.\nThank you for taking the time to give this insightful feedback!!\n. Garth, your suggestion is excellent!!\nJust as you suggested I tried moving the global function cancellize to a method on Thenable.  At first I was just going to see if the compiler is happy with it and see if any other issues cropped up, and then report back here.  But after making the code changes, in my opinion it looks and works decidedly better than the global function so I went ahead and pushed it!\nIt now works exactly as you suggest above. As a bonus I eliminated all the cancellableThen, cancellableRecover, etc. methods. Previously I was having ambiguity problems with compiler but it seems the Swift 5 compiler has addressed these.\nMax, if there's a good reason to have it as a global function I can back it out.  Just lmk.. Wow, awesome!!. Closing this pull request as it appears we are going with a variant of option #1 -- 'Cancel' for PromiseKit #899 . Wow, great catch!  The CancelContext instance's hashValue could indeed be accessed by multiple threads at the same time.\nI fixed CancelContext by making a Hashable wrapper class, where the wrapper instance will only be accessed by a single thread.  Other threads make their own wrapper instances so this solves the thread safety issue with CancelContext.\nCancelItem also has a lazy hashValue, but all dictionary operations involving CancelItem are protected by the barrier lock.\nAdmittedly this is a slightly convoluted.  But I want to use ObjectIdentifier.hashValue for the CancelContext and CancelItem hash values, which then forces you to use lazy.\nI'm very open to ideas for simplifying this, lmk if you think of anything!!\n. All of the 'Cancellation' code in Dispatcher can be removed if we decide we don't want/need strict compatibility with the non-cancellable classes (these are all wrappers for the Dispatcher change).. Agreed, how about 'C' for catchable?. Exactly when works just fine here.  But it doesn't work for the 'U,V,W,X,Y' mixed-type methods below, those are required to have a different name.\nI decided to name everything cancellableWhen for consistency.  But I'm perfectly happy to use when in all the places it works!. This works!  I'll change it to race and update the docs (and remove the timeout on CancelContext).. Will do!. Yeah I couldn't come up with anything better, open to all suggestions.  cancellize is slightly shorter!. Great idea!  Will do.. I changed cancellableWhen to when wherever possible.\nChecked in!. Changed timeout to timedOut.\nChecked in!. Changed 'M' to 'C'.\nChecked in!. Checked in!\n\n\nUpdated race to cancel all its cancellable promises if any of them reject.\n\n\nDefined timeout as follows:\n\n\nswift\npublic func timeout(seconds: TimeInterval) -> Promise<Void> {\n    return after(seconds: seconds).done { throw PMKError.timedOut }\n}\n\nRemoved timeout method from CancelContext\n. Updated the docs to refer to this as a finalizer.\n\nChecked in!. Checked in!. Removed this paragraph.\nChecked in!. Moved this to Troubleshooting.md\nChecked in!. Left as cancellable for now, open to all ideas.  Lmk if we should go with cancellize.. Changed signature to cancel(with error: Error).\nChecked in!. Lmk if I should delete this code.  Not sure what compatibility is desired here.. ",
    "cs4alhaider": "When finished try to squash all of the commits .. git squash. ",
    "LarsStegman": "Is this PR still active? If so, is it almost ready?. Any reason the solution mentioned in #227 could not be used?. What is a freeform function?. ",
    "tpoche": "My team is considering incorporating these cancel features into one or more of our apps.  Is there anyway we can pull this version into our app using Cocoapods to start playing around with it and giving you guys some feedback?. ",
    "ChrisChares": "Awesome sounds good.  Will get back to you when I'm ready for next steps.  . Wow you weren\u2019t kidding about testing this stuff. \nMocking went okay until I hit HMHome, which was kind enough to mark init() NS_UNAVAILABLE.  Interesting behavior after that. Apparently without any available superclass initializers, a subclass will still compile, yet vend uninitialized objects from it\u2019s own initializers.   \nI tried a few different things to make the code more testable, but the results weren\u2019t great and I wasn\u2019t comfortable with the corresponding loss in readability.  At the end of the day I felt I was just writing tests for either HomeKit or Swift\u2019s own type system and scrapped most of it.  Your swizzle method from the core location tests proved useful for testing a delegate wrapper.\nIt built as a dependency via Carthage, not sure how to test it as a Pod subspec.  Anything else that should be tested or done?. @mxcl Thanks for creating the repo.  Just pushed to it.  I'll keep adding things here and there, please let me know if you need anything else in the meantime.  \nEdit:  In particular should I tag the initial release and if so does the version have to be anything specific?. Thanks!. ",
    "avjiang": "okay @mxcl  thanks for your fast reply. I really would like to implement this library onto my current project that using ObjectMapper. But it seems I couldn't apply it for now. \nThank you so much. ",
    "spearway": "I will do a pull request if you like the idea. The idea is that we have now an API with when(fulfilled: tenables) that return a guarantee I would like a when(resolved: guarantees) that return a guarantee. as you the problem is that we return a Promise and that force us to write a recover clause that is absolutely worthless at it will never be called.\nMy code is littered with that.. Yes but that only works with void. This is a very narrow case I typically return some value from the calls.. ",
    "ArifADS": "I think there should be a way to use the .wait() in a faster, more readable way than inside a DispatchQueue.global(qos: qos.qosClass).async(.promise) { } and conserving intuitiveness.\nWhat do you think?\nThank you for this project.. ",
    "arthabus": "Thanks a lot @mxcl. Following your suggestion fixed it as below:\nreturn itemCreateInternal(item)\n            .then { item -> Promise<Item?> in\nThough I'm a bit confused about your generic promises statement - checked this common misusage guide, but can't find any alternatives to the generic approach. Could you please suggest what is the intended usage in this case?. Sorry, misread your message - you were talking about optional, not generic. Please disregard my message.\nThanks again for the quick help and great library!. ",
    "alexpersian": "@mxcl I think you are right. This was causing enormous issues yesterday, and I even tested within a Playground to ensure I wasn't using incorrect syntax. Sure enough though this morning I went back to it and the compiler started behaving and no longer flagging the line as an error.\nI'll close this issue as resolved then. Thanks.. ",
    "hani-ibrahim": "I would love to have this addition as well. recover would make the chain success however we want to do something if error occurred but couldn't use catch as catch terminate the whole chain.. @mxcl yeah true, but it's not so readable as recover is meant to recover from an error and return a valid value, so when I read recover I would expect that. But throwing an error again in recover means that we are not really recovering and it's a bit confusing.\nI think something like this would be more readable. no?\nswift\n.grab { error in\n    print(\"Do something\")\n}\ncould be grab, check, grasp. ",
    "Jarvey": "OK thank you for you're answer. yesterday Xcode was telling me that Promisekit and foundation where outdated so I updated Promisekit and foundation to the latest version via Carthage.\nI use two targets watchOS and iOS, when my watch app is making a network request in the watch simulator I now receive the following error in NSURLSession+Promise.swift\n\ndyld: lazy symbol binding failed: Symbol not found: $S10PromiseKit8ThenablePAAE3map2on5flags_AA0A0Cyqd__GSo17OS_dispatch_queueCSg_8Dispatch0J13WorkItemFlagsVSgqd__1TQzKctlFfA\n  Referenced from: /Users/maikel/Library/Developer/CoreSimulator/Devices/ABCDFG/data/Containers/Bundle/Application/ABCD/Treingids WatchKit App.app/PlugIns/Treingids WatchKit Extension.appex/Frameworks/PMKFoundation.framework/PMKFoundation\n  Expected in: /Users/maikel/Library/Developer/CoreSimulator/Devices/ABCD/data/Containers/Bundle/Application/1FDABCD/Treingids WatchKit App.app/PlugIns/Treingids WatchKit Extension.appex/Frameworks/PromiseKit.framework/PromiseKit\ndyld: Symbol not found: $S10PromiseKit8ThenablePAAE3map2on5flags_AA0A0Cyqd__GSo17OS_dispatch_queueCSg_8Dispatch0J13WorkItemFlagsVSgqd__1TQzKctlFfA\n  Referenced from: /Users/username/Library/Developer/CoreSimulator/Devices/ABCD/data/Containers/Bundle/Application/ABCD/testApp WatchKit App.app/PlugIns/testApp WatchKit Extension.appex/Frameworks/PMKFoundation.framework/PMKFoundation\n  Expected in: /Users/username/Library/Developer/CoreSimulator/Devices/ABCD/data/Containers/Bundle/Application/ABCD/testApp WatchKit App.app/PlugIns/testApp WatchKit Extension.appex/Frameworks/PromiseKit.framework/PromiseKit\n. If you mean 'Clean Build Folder' in Xcode I already tried with no succes. Any other ideas?. That did it, thanks for the quick reply!. ",
    "heyzooi": "@mxcl it seems possible... https://github.com/apple/swift-protobuf/blob/master/Package%40swift-4.2.swift\nI will try that soon and push new commits to this PR. @mxcl I'm not sure how this could be done. One way maybe would be replace the swiftLanguageVersions to the old format [3, 4] and check if it fails. Do you have any suggestion how to do it?. ",
    "HardikDG": "Got it. Thanks for the suggestion. I had already checked when(resolved:) before this question. but based on its initial description I thought it will not give reject state as it doesn't go for catch state.\nAfter your comment, I re-read it and check it again and I got the answer. ",
    "chrisscholly": "Thank you :)\nThe other PR is better as it isn't bloated with a second (useless) commit \ud83d\udc4d . @mxcl Could you please send v6.4.1 to the CocoaPods Specs repo as well?. No problem, thank you \ud83d\udc4d . ",
    "ghowen": "@mxcl I just updated a project to the latest pods, and Xcode 10 still claims that there is a conversion to Swift 4.2 available for the PromiseKit.framework. It's just a warning that Swift code in the framework has not been converted to Swift 4.2 yet, but the library runs without a problem. Maybe this is what @techmehra meant.. Not sure what you mean with this exactly. But starting the suggested conversion shows some Swift code changes:\nBasically \nUIViewAnimationOptions\nneeds to change to \nUIView.AnimationOptions\nand \nUISystemAnimation\nto\nUIView.SystemAnimation\nin \nUIView+Promise.swift\n\n. That is indeed weird. I am on PromiseKit 6.4.0 and if I open the pod and look at the source I can see the #if swift(>=4.2) directive. But Xcode 10 GM still wants to convert the part after the #else to Swift 4.2 which does not make any sense really. TBH I'm a bit at a loss now.. Looks like this was resolved with the latest update to 6.5.0. Out of curiosity and the learn from it: What was the culprit at the end and how did you fix it? Thanks.. The Xcode upgrade warning. I did update the gem xcodeproj today as Cocoapods suddenly started to throw an error. . ",
    "techmehra": "\n. ",
    "110100110101": "That's really messed up. I'll close this issue for now and monitor the status of Cocoapods. Thanks. ",
    "ivan-konov": "I am unable to paste actual code here because of company trade secrets.\nThe 2 occurrences of this problem I had were connected to indirect dispatches to another thread like network calls or the Core Location geocoding API. I have promises written in Swift doing network calls on background threads and no problem.\nThere is definitely something fishy when it comes to Objective-C usage.. (facepalm) thanks so much!. ",
    "dmesparza": "Thank you, that is exactly the direction I was looking for. Very helpful to me.. ",
    "pmusolino": "Thanks @mxcl for clarifying the situation.. ",
    "volkanbicer": "Thanks it's worked.. ",
    "JamesSawley": "Ah! Thank you \ud83d\udc4d . ",
    "Guardiannw": "I would, but I really don't like CocoaPods.  I would prefer to use manual installation if at all possible.. That's ok Max, thank you for directing me.  I am now supporting you on Patreon.  Would you be able to provide further help with this issue please?. Thanks!  PromiseKit framework does build against the watch simulator, but the error still shows when building for the app extension for the physical device.  I had not previously specified any framework search paths, so I went ahead and filled that in, but that didn't solve it.  The framework had been placed automatically in the Target Dependencies slot when I added it to the Embedded Binaries, so that was good.\nNote, it has worked fine for the iPhone build and run, no error ever.  I didn't even need to build for the iOS simulator first I don't believe.  But it simply won't run in in the build scheme for the watch target.. Also, this might be of some value: I am able to replicate the issue by:\n\ncreating a new Watchkit project.\nputting the PromiseKit repo folder in the $(SRCROOT) of the project folder\nthen dragging the PromiseKit xcodeproj file into the Xcode File browser above the project folder\nand then adding the embedded binary to all targets.\n\nWhen I try to run the extension to the simulator or the physical watch, I receive the No such module \"PromiseKit\" error. Thanks Max,\nI believe I followed the instructions correctly, however, I am still having a couple of problems even on the test-case project.\nWhen I try to build and run the PromiseKit.watchOS Target on the simulator, I now get a great many errors:\n\nAnd then, when I changed out the dependency in the extension and tried to run on the device, I still get the same error:\n\nThank you very much for your continued help with this,. Ok, for now I am only using PromiseKit in swift, so that should be ok.\nHowever, it looks like it might still be doing the same thing on the build of the project, even after those changes.  I tried to clean the build folder, but no avail.\nHere are some screenshots of the changes and the errors:\n\n\n. Ok, thank you!  I just tried it, and it built, but it still gave the same error when I imported it in my test project.  However, I then changed the Target, both in the import and in the Target list for PromiseKit (instead of just in the import statement), to PromiseKit_watchOS instead of PromiseKit.watchOS and then it worked from there.\nThis is an interesting issue, do you know why this was happening?. Hey @mxcl, I am about to upgrade to the latest code from PromiseKit.  Have you been able to implement these fixes out of the box?  Or will I need to go through and adjust?\nThanks!. ",
    "djmixroman": "\nSeems like we should make the queue concurrent instead, the only other use is a \u201cread\u201d operation.\n\nAre u want to use concurrent queue.sync with barrier?. Great, but I have a chain of promises. And I don\u2019t want to chain tuples.. Okay! Thank you so much! . ",
    "bennnjamin": "@mxcl That's correct, which is why in my code snippet above I changed all instances of BFTask to AWSTask, and AWSTask still has no then. Perhaps I'm missing something else.\nThe first code snippet does compile, however, it's the second snippet where I am adding an extension to AWSTask directly. You do not add an extension to BFTask directly but to Promise instead which should be enough. That's why I'm having trouble figuring out why just copying the BFTask and changing it to use AWSTask does not work\nNo, I'm pretty new to the framework and certainly would want a typical then but can't get it to work by simply modifying the BFTask extension.\n. I see so can I use Promise() like a Void, always fulfilled promise to start a chain of AWSTasks? That would work pretty well. What do you think of third example as far as an approach? I really wish I could add a then to AWSTask as that would be the most syntactically clear, and a pretty useful extension.. Thanks for all of your help, I'm closing this issue. If you think this would be a useful extension to PromiseKit I'd be happy to assist with that.. Agreed on it being a snippet seeing as it\u2019s so similar to BFTask. \n\nOn Oct 25, 2018, at 1:42 PM, Max Howell notifications@github.com wrote:\nIf you think this would be a useful extension to PromiseKit I'd be happy to assist with that.\nYou can add a PMKAWSKit to https://github.com/PromiseKit if you want. Though we may be better off just adding it as a snippet to this repo and linking there.\nGlad to have helped, if you found my work helpful, please consider supporting its development.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "zhuxiaohan": "\nPlease provide the example code that fails.\n\ni use the old version promisekit (version 4), this is example code( js patch code):\n```\nSKPromise.promiseWithResolver(block('NSBlock*', function(resolve) {\n            var strongSelf = __strong(weakSelf);\n            AppDelegate.printLog(\"TRIPSessionSendUserInfoProcessor send start\");\n            var task = SKModuleTask.alloc().initWithScheme_module_processor_params(\"native\", \"mtop\", \"mtop_normal_sign\", paramas);\n            strongSelf.sendModuleTask_parentTask_resolver(task, parentTask, resolve);\n            AppDelegate.printLog(\"TRIPSessionSendUserInfoProcessor send end\");\n    })).then()(block('id,SKModuleTask*', function(result, task) {\n        AppDelegate.printLog(\"TRIPSessionSendUserInfoProcessor then\");\n        alert(\"then\");\n        parentTask.taskResolve_task(null, task);\n\n    })).catch()(block('SKPromiseError*', function(error) {\n        alert(\"catch\");\n        AppDelegate.printLog(\"TRIPSessionSendUserInfoProcessor catch\");\n        parentTask.taskResolve(error);\n\n    }));\n\n```. > I'm sorry I have no experience with JSPatch, I don\u2019t know how it works or have heard of it and cannot help you.\nthanks again. ",
    "rehatkathuria": "First of all, thank you to everyone for their hard work on PromiseKit. It's become an invaluable asset to asynchronous architecture that I write. Secondly, this pull-request might be moot but my understanding between then and when made me think this was a typo. Please correct me if I'm wrong! . ",
    "caffeineflo": "Verified Carthage works again!. ",
    "neallester": "Sure, should I close this pull request and resubmit when that's done?. One other thing I didn't do is add the new Logging test to AllTests (I wasn't sure exactly how to do it or if that was even the right place) so the new test may not run on Linux.. @mxcl, you're now a collaborator on the fork. Are you suggesting I move the file Logging.swift to the directory Sources.swift?. It looks like the pull request is already set to allow you to edit (I didn't check the box, maybe this happened when I added you as a collaborator to the fork).\n\n. I originally thought I would write at least two tests, but when I finished\nthe first set of assertions I realized they left things in a convenient\n(and non-default) configuration for the second set of tests (those after\nthe comment \"\nVerify waiting on main thread in Promise is logged\". The existing tests\ncould be broken into two tests or even four. There would just be some\nduplicate set up between three of the tests (I suppose these could be\nbroken into a separate test class to refactor out the common setup but that\nseems like overkill for the simple setup and adds some state between the\ntests).\nOn Sat, Nov 24, 2018 at 2:27 PM Max Howell notifications@github.com wrote:\n\nIs there a technical reason all the tests are within a single function?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/pull/961#issuecomment-441399913, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AA1YgUeRtdVm7J384ZMeqC2vaYfZDi9-ks5uycftgaJpZM4YukuI\n.\n. > And we can drop waitOnLogging() and the loggingQueue.\n\nReally? Isn't there a risk of a race between one thread changing the logging closure and another thread firing that closure? . Would you object to addressing these four failing assertions with\nif swift(>=4.2). I think the problem is that using an enum with an associated value within a string interpolation gave a different output in previous versions.. This change should work and avoids ifdef by using a switch. To Clarify: it was the test not the library code which relied on string interpolation behavior which was different in older versions of swift. I just changed the test to avoid doing a string interpolation on an enum with associated value which was not critical to the functionality under test.. > How do you feel about this just being a closure on PMKConfiguration without the rest, I believe in keeping APIs minimal.\nThere is a very minor drawback I've detailed below. I'm ok with:\n\nRemove LoggingPolicy enum\nRemove PMKConfiguration.loggingPolicy\nRemove PMKConfiguration.logConsoleClosure\nRename activeLoggingClosure to loggingClosure and making it public. What is now the implementation of logConsoleClosure will become the default value for loggingClosure.\nRemove Logging.log\nKeep public LogEvent enum\n\nOne purpose of LoggingPolicy was to make it easier to turn logging back on after turning it off. Since that isn't a supported use case I agree it doesn't make things significantly easier than just assigning a closure to conf.activeLoggingClosure (renamed conf.loggingClosure).\nThe only disadvantage of doing this is it would enable code from outside of PromiseKit to send LoggingEvents to the closure. While that isn't an intended use case, I don't see how adding the capability (as a side effect of the simplification you are proposing) is so terrible.\nI agree that the log feature is a useless indirection and should be removed. I created it as part of the public API and then made it internal when I realized it was dumb to allow code outside of PromiseKit to trigger log events without stopping to think that switching it to internal eliminated the reason I had it there in the first place.\nI think we want to keep LogEvent as a public enum for the parameter of the logging closure. If you discover some other event which needs logging adding it as an enum case will force anyone with a custom logging closure to address that new case in their closure (which might be different than for the existing events)\nIs this what you had in mind?.. It looks like one of the Linux tests stalled in\nTest Case 'WrapTests.testInvertedCallingConvention' started at 2018-11-29 00:43:19.791\nAll Travis CI tests passed on my fork; I don't know how to trigger another build in the pull request without sending a dummy commit.\n. Of course that's fine, but would you please update the name at the bottom\nof FAQ.md\nNeal\nOn Tue, Dec 4, 2018 at 5:15 PM Max Howell notifications@github.com wrote:\n\nWill be live when this finishes:\nhttps://travis-ci.org/mxcl/PromiseKit/builds/463580751\nI changed the function name, hope that's cool. See the recent commits to\nmaster for changes.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/pull/961#issuecomment-444296196, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AA1Ygc1DacNCveDvnCXSHCq9rCs4QEDGks5u1wHvgaJpZM4YukuI\n.\n. When chaining promises, the closure in the .ensure block may or may not\nfire before the closure in the .catch block. This is not the behavior I was\nexpecting. I expected them to fire in a deterministic order: ensure last. I\nwanted to confirm that the observed behavior is consistent with your design\nintention. If not, the test is there to demonstrate the issue.\n\nOn Thu, Nov 29, 2018 at 2:21 PM Max Howell notifications@github.com wrote:\n\nThis is hard to understand, can you succinctly explain your question?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/962#issuecomment-442979463,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AA1YgfWg-h7d55Kekqr2NvwpHfBFHdELks5u0EG_gaJpZM4Y43PL\n.\n. Yes, I see and that makes sense. I need to use PMKFinalizer.finally() not .ensure. \n\nIt was the function name \"cleanup()\" in the CommonPatterns.Chaining section of the documentation which gave me the clearly incorrect impression that ensure would run after catch (because in my mind cleaning up is something you do last).\nI think adding a .finally block to that example would make it less likely for a reader to confuse the functionality of .ensure with .finally. . Travis CI build 1731 failed at step 7, but Travis CI build 1729 succeeded at step 7 even though there was no code change between the two builds (only an empty commit to kick off another CI build).\nThe CI failure appears to be a Travis issue.. Sorry I missed the implication of the Box indirection although it's hard to feel too guilty about it. Since unfulfilled promises already emit console output/log on deallocation doing so for Guarantees looks to me more like completing an existing feature than adding a new feature. At the moment I don't expect to use Guarantees so I submitted the PR for the sake of completeness when I happened to notice unfulfilled Guarantees went to their doom silently.\nIs there anything you would like from me?\n. ",
    "SolorzanoJose": "@mxcl I'm getting SIGABRT without crash info, this is the last call in thread 1:\n`\ndyld__abort_with_payload:\n    0x1057062f0 <+0>:  mov    x16, #0x209\n    0x1057062f4 <+4>:  svc    #0x80\n->  0x1057062f8 <+8>:  b.lo   0x105706310               ; <+32>\n    0x1057062fc <+12>: stp    x29, x30, [sp, #-0x10]!\n    0x105706300 <+16>: mov    x29, sp\n    0x105706304 <+20>: bl     0x105705990               ; cerror_nocancel\n    0x105706308 <+24>: mov    sp, x29\n    0x10570630c <+28>: ldp    x29, x30, [sp], #0x10\n    0x105706310 <+32>: ret    \n``. @mxcl \n\nThis is just one example, it happens for all couple hundred promises in my codebase. @mxcl I've uninstalled the app from the device, cleaned build folder and removed derived data, should I do something else? I'm using PK6 through cocoapods. @mxcl using the cocoapods-deintegrate tool? I will give it a shot\nthanks man, you are really helpful. Thanks, it worked @mxcl . @mxcl just out of curiosity, the pod reintegrate tool doesn't exist, you mean't regular por install? cheers. ",
    "YiYiZheng": "Ambiguous reference to member 'firstly(execute:)'. \nWhen I just replace\nif isOnWifi {\n        return Promise.value(true)\n    } else {\n        return viewController.showAlertView(content: \"Are you sure?\", cancelTitle: \"exit\", confirmTitle: \"confirm\")\n    }\nwith \nreturn Promise.value(true)\nWhich means only return one promise, It was all right... Yes, it works. Thanks. . Thanks.. ",
    "Empiezan": "Thank you! This helped a lot.. ",
    "brynjar": "ah yes thanks. Hadn't noticed the part about multi-line closures.. ok, thanks for the info.. ",
    "b13h": "completeness cycle approximately:\ncount.fontXYPolimerStratch(iops.msPower).mdl { response GeoDecemberCityTrail(\"ElectroCar:\")\nfrintf (beginDB.reportCount[F,a,b,c,X]) }.catch { code design drawdown calculation (CRTXsysSQL)} //answer wait until Dec 12. ",
    "jfahrenkrug": "@mxcl Thank you so much! It makes sense that a force-downcast is required. Thanks for your hard work on this fantastic library!. ",
    "tunds": "@mxcl So am I wrong in assuming that reject will call the catch block? And instead it should be an cancellation, since all the other examples i\u2019ve saw use the same sort of pattern that i\u2019ve provided in the question. @mxcl Ahhh ok thanks for clearing that up, closing this now.. ",
    "NigamAnkit": "Xcode gives warnings that version 3.2 swift is deprecated and would be\nremoved in next xcode update hence convert PMK to swift 4.2\nOn Thu, 27 Dec 2018 at 3:40 PM, Max Howell notifications@github.com wrote:\n\nSo to prove this, I added Xcode 10.1 to the v4 test matrix:\nhttps://travis-ci.org/mxcl/PromiseKit/builds/472596784\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/mxcl/PromiseKit/issues/977#issuecomment-450121226,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/Ae0_gclKTeQ96ZnInfLRrAK57TmXDfmlks5u9JyWgaJpZM4ZibT3\n.\n-- \n\n. ",
    "martin-one": "With that code I will just do the request for one 'id', right?, not every [id] on the list?. ",
    "rhlsthrm": "@mxcl, I updated my issue with the PromiseKit version number. I also looked over the troubleshooting guide. Can you please re-open?. I installed with CocoaPods and I am using the generated workspace.. I took your suggestion and did the following:\n\npod deintegrate\npod install\nClean\nRebuild\n\nBut I am getting the same error. I have looked all over the internet and tried various things I've seen in threads in terms of changing build settings, etc. but nothing has helped this particular issue.\nIs there a more reliable way to install than from CocoaPods where I won't introduce these additional points of failure?. Build target PromiseKit_2019-01-06T14-44-48.txt\nHere is the full log output.\nThank you, I will try Carthage as an alternative. This is a great package by the way, and I am happy to use it and will definitely be donating to support your work!\nI'll close this issue once I manage to get it working.. Can you elaborate on exactly how I would go about doing that? Sorry still learning my way around the tooling.. @mxcl would you be able to refer me to some docs or another way to debug this issue on my own? I tried both using Carthage as well as manually dropping the package in but I still am not able to get past this issue.\nI believe these are the settings you were referring to for embedding and linking to the Swift runtime:\n\nCould you please point me in the right direction?\n. Thanks, I was able to get it working somehow by some combo of cleaning and building.. ",
    "vade": "Thats some response time ;) Thank you.. ",
    "shi-rudo": "ah, thanks!\nis this the right way?\n```swift\nfunc attempt(maximumRetryCount: Int = 3, delayBeforeRetry: DispatchTimeInterval = .seconds(1), _ body: @escaping () -> Promise) -> Promise {\n    var attempts = 0\n    func attempt() -> Promise {\n        attempts += 1\n        return body().recover { error -> Promise in\n            guard attempts < maximumRetryCount else { throw error }\n            return after(delayBeforeRetry).then(on: thread, attempt)\n        }\n    }\n    return attempt()\n}\nfunc repeatIfNeeded() -> Promise {\n    return Promise {seal in\n        firstly{\n            generateRandomID()\n            }.then { ID in\n                checkIfIdIsValid(ID)\n            }.then { ID in\n                loadDocument(ID)\n            }.then { document in\n                validateDocument(document)\n            }.done { doument in\n                displayDocument(document)\n                seal.fullfill()\n            }.catch { error in\n                seal.reject(error)\n            }\n        }\n}\nattempt(maximumRetryCount: 3) {\n    repeatIfNeeded()\n    }.catch { error in\n        log.error(error)\n}\n```\nIt runs :-) But how can I handle that it only retries on case Error.IDInvalid and Error.documentInvalid, without breaking the maximumRetry cycle?. thanks for pointing out! I just started working with PromiseKit. Therefore I am grateful for the help! \nIs this the right approach? \n```swift\nfunc attempt(maximumRetryCount: Int = 3, delayBeforeRetry: DispatchTimeInterval = .seconds(1), _ body: @escaping () -> Promise) -> Promise {\n            var attempts = 0\n            func attempt() -> Promise {\n                attempts += 1\n                log.debug(attempts)\n                return body().recover { error -> Promise in\n                //Handle to many attempts with retries\n                guard attempts < maximumRetryCount else {\n                    log.error(\"to many attempts\")\n                    throw error\n                }\n\n                //Handle specified errors with retries\n                if error ==  Error.IDInvalid: {\n                    log.error(\"ID does not comply with rules\")\n                    return after(delayBeforeRetry).then(on: nil, attempt)\n                }\n\n                if error ==  Error.documentInvalid: {\n                    log.error(\"document does not comply with rules\")\n                    return after(delayBeforeRetry).then(on: nil, attempt)\n                }\n\n                //Throw error if error is unspecified -> does not retry\n                throw error\n            }\n        }\n        return attempt()\n    }\n\n//chain\nfunc repeatIfNeeded() -> Promise  {\n            return firstly{\n                generateRandomID()\n            }.then { ID in\n                checkIfIdIsValid(ID)\n            }.then { ID in\n                loadDocument(ID)\n            }.then { document in\n                validateDocument(document)\n            }.done { doument in\n                displayDocument(document)\n            }\n}\n//run\nattempt(maximumRetryCount: 20) {\n    return repeatIfNeeded()\n        }.catch { error in\n            log.error(error)\n}\n```\nThanks!. Sorry, I don't understand how I can chain the subroutines (promise chains) into one main routine as promise chain without sealing the subroutines? \nOr did I misunderstand the principle of doubling up promises? Because the subroutine has to make its own promise (so no doubling up here?) to run sequentially in the main routine. If I don't seal the fullfill/rejection in the subroutines, promises maybe are going to be deallocated.\nThis is how I do it at the moment, have I gotten used to something bad here?\nTHANK YOU!!\n```swift\nfunc subChainOne() -> Promise {\n    return Promise { seal in\n        firstly {\n        ...\n        }.then { _ in\n        ...\n        }.done { _ in\n        seal.fullfill(())\n        }. catch { error in\n        seal.reject(error)\n    //error handling for this subroutines happens here\n    ..\n    } \n}\n\n}\nfunc subChainTwo() -> Promise {\n    return Promise { seal in\n        firstly {\n        ...\n        }.then { _ in\n        ...\n        }.done { _ in\n        seal.fullfill(())\n        }. catch { error in\n        seal.reject(error)\n    //error handling for this subroutines happens here\n    ..\n    } \n}\n\n}\nfunc mainChain() {\nfirstly {\nsubChainOne() \n}.then { _ in\nsubChainTwo()\n}.catch { error in\nprint(error)\n}\n\n}\n```. ",
    "bradwbradw": "Thanks for the info / advice.  i'll do some research and follow up if i have any more Q's.. ",
    "michaelkirk-signal": "Thanks for the prompt response!. > Happy to help! Though it\u2019s only possible to be this prompt because I'm full-time.\n\nDonate if you can! https://patreon.com/mxcl\n\nI'm already on it. =)\nThanks for your work!. Sure!\n\nOn Jan 23, 2019, at 12:18, Max Howell notifications@github.com wrote:\nOh indeed! Sorry, I need to be better at recognizing that. Thanks so much for your contribution, it\u2019s much appreciated. You qualify for me tweeting out thanks actually, you want me to do that for Signal app?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "dev-xdyang": "Is there anything I can do to make code like this format\nswift \nfirstly {\n    Promise.value(1)\n}.map { _ in\n        2\n}\nwhen I press enter key, the code will become like this:\nswift\nfirstly {\n    Promise.value(1)\n    }.map { _ in\n        2\n}\nI am not use re-indent, only input by manually. Any solutions? Thanks a lot.. There is a talk about this. Perhaps no solution now. Sadly.. ",
    "dfed": "Got it! Welp. I'm shooting from the hip here, but maybe the right approach is to have each subspec add a compiler flag that we can use to conditionally import those files in the umbrella? I'd hate for subspecs to prevent us from having a proper umbrella header.. Dumping the umbrella header might work. I know CocoaPods generates its own, and Buck will generate one if none exists. My issue right now is that Buck isn't generating one because we already have one. That said, removing the umbrella header will cause the build to break for anyone consuming PromiseKit with submodules.\nThat said, I'm curious what @dnkoutso thinks re the right approach for subspecs + umbrella headers, so, pinging him here :). Seems reasonable. I'm happy to wait for v7 on this one. Will close this out.. ",
    "interstateone": ":+1: That makes sense, thank you. I agree about removing the initial EKEventStore.authorizationStatus call. I can submit a PR with this change when the repo is unarchived.. ",
    "andreaslindahl": "Duplicate of https://github.com/mxcl/PromiseKit/issues/1001. ",
    "aaronbarsky": "Thanks for the super fast response.  It was the API Reference link from the Readme.md.  Glad to see the docs back.. ",
    "edillinger": "Check out the migration guide if you haven't already -> Guide\nUpdate methods as mentioned in the link above, you may still see some type errors - if so try to use single line closures, or be explicit about the type.\n. ",
    "farllight": "Solved in project. Completion don't return Error.. ",
    "mklbtz": "Should this be return firstValue? You have last implemented as return lastValue.. ",
    "kingslay": "I think that swift has special handling of Error that can cause problems with reference counting.. ",
    "houndci-bot": "Trailing Comma Violation: Collection literals should not have trailing commas. (trailing_comma). Trailing Comma Violation: Collection literals should not have trailing commas. (trailing_comma). ",
    "mmatoszko": "Shouldn't the test name also change to testIsSuccess()?. rejected -> failed. Got it, thanks :). "
}