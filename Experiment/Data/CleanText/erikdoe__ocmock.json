{
    "erikdoe": "Thank you. These changes were made to the codebase without a direct merge.\n. Like the idea, not sure about the use of an array to store the arguments. The unit test highlights that this creates a dependency on the sequence, i.e. somehow you have to know at which index in the array to look. \nWouldn't it make more sense to pass the address of a suitably sized pointer? This seems the approach taken by the GoogleMock framework, too. I'm thinking of something like this:\nid appendedString = nil;\n[[mock stub] stringByAppendingString:[OCMArg saveTo:&appendedString]\n/* do stuff */\nSTAssert(expectedValue, appendedString, @\"...\")\n. I have made both changes. Couldn't merge this automatically given the other changes that occurred in the meantime.\n. Thanks for the code. Very helpful. I used some of it in the implementation that's now in OCMock. Key difference is that you can simply start stubbing class methods on a \"normal\" mock object, you don't have to create a special mock object to mock class methods.\n. The proposed test checks whether the mock's class conforms to the protocol. I think that the mock itself should conform to the protocol. There's a test for that (testConformsToMockedProtocol) and it passes.\n. Thanks for the code. Very helpful. I used some of it in the implementation that's now in OCMock. Key difference is that you can simply start stubbing class methods on a \"normal\" mock object, you don't have to create a special mock object to mock class methods.\n. Thanks for exploring this. I must say, though, that I am not too keen on changing OCMock in this way. The reason is that I am already spending a lot (too much) time on keeping OCMock up to date with the changes Apple introduces to the build system and with supporting developers getting OCMock integrated in their projects. Moving to an approach that is neither documented by Apple nor well-known in the community seems counterproductive in this regard. \nI have also noticed that the instructions referenced above are quite long and only cover iOS 2.0, which is obviously many versions behind. If we were to switch to this approach we'd would have to write up simple and clear documentation on how this works on the current version of iOS and make sure this gets updated for new versions in the coming years.\n. Finally solved, years later, with Apple officially introducing frameworks in iOS 8. See #194.\n. I liked the idea. Have implemented it with less code now. And added a unit test.\n. Agreed, the error message was terrible, but the behaviour was incorrect, too. Both have been fixed in master a while ago.\n. Duplicate of https://github.com/erikdoe/ocmock/pull/17, which I have merged.\n. I saw that, the update check in the other pull request bumped it from 420 to 430. Will check in 440 once I have that on my machine, too.\ncheers\nerik\nOn 15/08/2012, at 23:53, Tristan O'Tierney notifications@github.com wrote:\n\nAwesome, thanks! \nYou may want to double check mine isn't 100% a dupe. Mine also fixes an issue that warns that the ocmock build target needs to update to the latest settings. \nUnder the hood it just switches the LastCheckUpgrade version from 430 to 440 I believe. \nTristan O'Tierney \n- http://otierney.net \n- http://twitter.com/tristan \n- iMessage: tristan@otierney.net \nOn Wednesday, August 15, 2012 at 2:43 PM, Erik Doernenburg wrote: \n\nDuplicate of https://github.com/erikdoe/ocmock/pull/17, which I have merged. \n\u2014 \nReply to this email directly or view it on GitHub (https://github.com/erikdoe/ocmock/pull/18#issuecomment-7770107). \n\u2014\nReply to this email directly or view it on GitHub.\n. Only two years later... Finally included (via cherry-pick) that fix for the constraint tests.\n. Thanks. These changes made it into the updated build script.\n. Interesting. Two questions:\n- I'll readily admit that I have very little experience with GCD, but I wonder why this implementation uses a concurrent queue and barriers. Wouldn't it be simpler to use a serial queue?\n- Would it be possible to have some unit tests that verify the code?\n. Ok. Thanks for clarifying. I think I'll close the pull request now, but it's good to have the idea around when, at a later stage, someone looks into this in more detail. Thank you for sharing your concept.\n. When you copy the block, don't you essential own the copy? In that case, wouldn't you have to release it in the dealloc method?\n. This pull request does not only update project settings to Xcode 4.6, it introduces other settings, too.\n. Apologies. I now see that Xcode actually suggests the added compiler checks.\n. Documentation will be on the ocmock.org site, not in the readme file. I have added simple build instructions on the downloads page now.\n\n\nI have made the other change in this pull request (update to 6.1 SDK).\n. Documentation will be on the ocmock.org site, not in the readme file. I have added simple build instructions on the downloads page now.\nI have made the other change in this pull request (update to 6.1 SDK).\n. Thanks! For some reason this can't be merged automatically. I'll add the test manually.\n. Mocks should really only be used in unit tests and these should really avoid using multiple threads. So, I am somewhat sceptical about the need for this patch, however, I am going to accept it because it's small and it's very unlikely to cause issue elsewhere.\n. Fixed the issue in a way so that it does the right thing for methods that create objects, e.g. mutableCopy, without causing memory leaks for other methods. See commit https://github.com/erikdoe/ocmock/commit/00c0fe362de2b11625d348ae50379a108a3abf0b.\n. Sorry, I overlooked this. Now that I think about it, I'm surprised that there aren't more instances of this problem in the codebase. Either way, maybe it would have been better to keep \"%d\" and just cast to unsigned int?\n. So, if I understand correctly, this fix makes sure than equality of the strings is determined by calling isEqualToString:. I can see that in the test you have to use mutableCopy to provoke a case where pointer equality isn't sufficient. Does this make sense? Aren't notification names meant to be constant strings?\n. No good reason. I fixed some other things first, now the pull request can't be merged automatically anymore, and I haven't gotten round to doing it manually yet.\n. I'm hesitating because my impression is that Apple wants us to move away from primitive C types such as unsigned long and use their NSInteger et al; but those cause issues when switching between 32 and 64 bit...\n. Okay, just realised that pull request 38 (https://github.com/erikdoe/ocmock/pull/38) has a solution that fixes the warnings and addresses my concerns above. So I've merged that one instead.\n. Oh, I wasn't even aware of this syntax. When was it introduced? Either way, I like this way of solving the warning problems with the format strings.\n. There was another pull request that did exactly that, casting to unsigned long, but while Xcode suggests that, everything Apple does seems to point at avoiding primitive C types and using NSInteger et al instead.\n. Took me a while to understand this. I was confused why your approach worked for your (completely valid) test case because the documentation for class_replaceMethod() says:\n\nThis function behaves in two different ways:\nIf the method identified by name does not yet exist, it is added as if class_addMethod were called. The type encoding specified by types is used as given.\nIf the method identified by name does exist, its IMP is replaced as if method_setImplementation were called. The type encoding specified by types is ignored.\n\nSo, why would the change you proposed be different than just calling class_replaceMethod() in the first place?\nTurns out the real problem is in removeForwarderForClassMethodSelector:. In the case discussed here, where the implementation to be replaced is in a superclass, calling replaceMethod() on the subclass will add the method to the subclass and then return NULL because in the subclass the method didn't exist. So, replacedClassMethods will hold a NULL pointer for the selector. Later, when removing the forwarder, the code retrieves the NULL implementation from replacedClassMethods and because it's NULL, which means there was no method replaced, it points the selector to the forwarder.\nWhen the method gets then called again, the execution path ends up in the forwarder for the class, ie. forwardInvocationForClassObject:, which figures out that the mock is not interested anymore. In that case it tries to remove the forwarder and restore the original method, but as discussed above that'll only make the selector point to the forwarder. So, when the code then invokes the method we get a nice infinite loop.\nSo, the real solution would be to remove the method from the subclass in removeForwarderForClassMethodSelector:, so that the superclass implementation can take over again but, alas, this doesn't seem to be possible any longer; see http://stackoverflow.com/questions/1315169/how-do-i-remove-instance-methods-at-runtime-in-objective-c-2-0.\nThe solution you propose works because trying to add the method first effectively copies the method from the superclass into the subclass. After that both A and B have an implementation of the foo method, pointing to the same code. In this case class_replaceMethod() returns that newly created copy and when the method is restored the forwarder loop isn't created because it doesn't return NULL but the copy of the method in the subclass. This means the system is not restored to the original state because now the subclass has an implementation of the method.\nNot sure what to do, but this bug should be fixed. We could either go along the route you propose, which has the issue of leaving the system in a different state. Or we could walk up the class chain and replace the method where it's implemented, which has the issue that mocking a method in one class could affect other classes in the same hierarchy.\n. After some experiments with both approaches I ended up implementing the one that can leave a \"shadow\" method in the subclass. Used a different implementation than proposed in this request, though.\n. Not sure I understand the issue. The following test compiles and passes for me:\n```\n- (void)testReturnsStrubbedStructReturnValue\n{\n    NSString* string = @\"This is a test string\";\nNSRange range = NSMakeRange(3, 1);\nOCMockObject* mockString = [OCMockObject partialMockForObject:string];\n[[[mockString stub] andReturnValue:OCMOCK_VALUE(range)] rangeOfString:OCMOCK_ANY];\n\nNSRange fakeRange = [string rangeOfString:@\"Not here\"];\n\nSTAssertEquals(fakeRange, range, @\"Should have returned overriding range\");\n\n}\n```\nIs writing andReturnValue:OCMOCK_VALUE(range) so much worse than writing andReturnStruct:&range objCType:@encode(NSRange)? \n. There is a bug somewhere. I get reproducible crashes with the code described in this question: \nhttp://stackoverflow.com/questions/16559191/returning-cgrect-from-mocked-method-crashes\nStill trying to figure it out.\n. Thanks! This is super helpful. I had briefly stepped through the assembler code but couldn't understand why things were the way they were. It didn't occur to me that the wrong forward function was being used... Out of curiosity, where is the ABI description that we'd have to follow to support x86_64 properly?\nBy the way, I checked the GNUstep source code but that wasn't helpful. I'll also check whether NSMethodSignature has a non-public method that might help us. I'd be happy to call that (with a test guarding it). After all I can't see how anyone would need OCMock code in the App Store.\n. Ok, so, there is a method named _frameDescriptor, and its return type is ^{?=^{NSMethodFrameArgInfo}^{NSMethodFrameArgInfo}II}. Of course, NSMethodFrameArgInfo is not in the public headers and after searching for it on the web I'm anything but excited about the prospect of using it...\n. In the long-term we should have a \"real\" implementation. Something based on the libffi Code. For now, to get the bug fixed soon, it looks like we have to base it off the debug output of NSMethodSignature as you suggest, Carl.\n. I've just merged Carl's pull request #44, which contains the required changes for arm64.\n. Thanks. Good timing. Just created the release. Tag should be pushed up to Github. Will update download page on ocmock.org now.\n. I've just merged Carl's pull request #44, which contains the required changes.\n. Not sure whether you noticed, the unit test added in this pull request fails on the continuous integration server. Having a green build is absolutely necessary.\n. Just kicked the build and now it passes. I have no idea why it timed out when it run after your last commit.\n. The changes obviously do what's intended and I like how they are done. That said, I'm not sure this functionality is what we want. The idea of the build script is to do a \"clean\" build, completely from scratch. Using SYMROOT during the build means that the build products are shared with builds happening inside Xcode. Or, asked the other way round, why is this desirable?\n. Is there a reason why the mainline source should default to IOS7 64bit instead of a more conservative IOS5? The binary releases are fat, and OCMock doesn't use features that are only present in IOS7. Is there an issue with linking it into apps that target IOS7?\n. Sorry, I should have looked at the diff more closely. Thought you had replaced the default target. Now I understand.\n. Thanks for picking this up. Could you check why this commit breaks the build on Travis?\n. While looking into this to answer Carl's question I realised that there might be another issue. The buffer allocated with malloc is sized according the the declared return type. What happens when the recorded value is bigger? Would that write over the end of the buffer?\n. Given that #115 addresses this issue and it has been merged, I'm going to close this PR.\n. Still curious about LowAmmo's comment. Do you really mean to flush the events in the run loop? Or is the code above just waiting the minimum amount of time after all the events have been processed?\n. Thank you for sharing; adding more flexibility around the number of expected calls is something that should be added to OCMock. That said, there are some questions/remarks I have regarding this pull request:\n- The continuous integration build on Travis shows a few tests failing.  Are they failing in your environment, too? Can you find out why they are failing?\n- I don't understand what the purpose of \"zero or more\" is. Isn't that the same as stubbing the method?\n- Something like \"at least once\" or \"between 3 and 5 times\" makes sense. However, I don't think overloading the expect method is the best design. Using a new set of methods that use the trampoline pattern would be more in line with the design of OCMock, e.g.\n[[[aMockObject expect] atLeastOnce] foo]\n  [[[aMockObject expect] exactly:3] bar]\nHope this makes sense.\n. A later version of OCMock will include the [[aMockObject expect] atLeastOnce] syntax. Given some of the changes I'm planning it's unlikely that this pull request will work, so I'm closing it. As I said, the idea is good, and it will make it into OCMock.\n. I like the idea, briefly looked at the request when it was posted, but didn't immediately understand why it worked. Having had the time to look more closely I now get it. \nWhat threw me was the name of the method proxyClass. The method doesn't (obviously) return the class of a proxy, it uses the implementation of the class method in the proxy base class.\nWhat do you think about renaming that method to so that it describes better what it actually returns? What do you think about mockObjectClass?\n. I think option 2 makes more sense. Having to call classMethod in some cases but not others would just be too confusing.\n. To understand why the class method can't be stubbed we have to look at how OCMock works internally. \nThe stub method returns an instance of OCMockRecorder. This means that the method classMethod is sent to the recorder. The recorder does some setup of the class to be mocked and returns self. Therefore the andReturn: method is also sent to the recorder. The method remembers what to return, nil in this case, and, again, returns self.\nNow, because of that the invocation of the class class method  in the code above goes to the recorder, too. The recorder, being a relatively normal Objective-C object, implements the NSObject protocol by inheriting from NSProxy. Unfortunately for your case, NSProxy implements the class class method, and therefore the recorder never gets to record it. \nIt would be theoretically possible to override the class instance method in the recorder so that it does the normal recording. However, that would mean that each call to the class method, by the runtime or the debugger, would also end up being recorded. The recorders are designed to only make one recording. So for this to work more logic would be needed to allow overriding of recordings etc. All in all, to be honest, it didn't seem worth the hassle and I'm not sure whether this would actually work with the Objective-C runtime.\nIf anyone wants to try and send a pull request...\n. I'm not aware of any issues. Are you saying everything compiles cleanly, the test gets invoked, the calls above do not throw any exceptions and still the cacheFolder message doesn't get stubbed? That would be really odd.\n. I see your point. In the case you describe it's clearly inconvenient to have to write these two lines instead of just one:\n[[[object1 stub] andReturn:@\"B\"] name];\n[[[object1 stub] andReturn:@\"B\"] valueForKey:@\"name\"];\nUnfortunately, it's not straight-forward from a mock object implementation perspective. Do you implement/stub all methods, including, for example, valueForKeyPath: and dictionaryWithValuesForKeys:? Do you merge all the stubs? \nThen there is the problem that Carl mentioned, anything that OCMock could do would be the standard (naive) KV implementation. What is the expectation if the class that gets mocked overrides some of the KV methods?\nTo be honest, I'm not a big fan of partial mocks but this seems like a good situation to use them.\n. Thinking about it more, I could see a middle ground that would still require an extra call, though:\n[[[[object1 stub] includingKeyValueCoding] andReturn:@\"B\"] name];\nThis is something to consider for a later version of OCMock.\n. Looks like Apple is making primitive types messier and messier. What you propose would work, I'm just a bit worried about treating all the numeric types as equivalent. Does the following work?\nNSInteger expected = 100;\n[[[hogeMock stub] andReturnValue:OCMOCK_VALUE(expected)] fuga];\nMore cumbersome, I know...\n. Looking at #58 just now I realised that there really could be a problem with treating the different value types as equal. This needs more investigation.\n. Your concern is valid and we should do something to make OCMock more intuitive to use. That said, this issue is a subset of #58, so you should probably close this issue and watch that pull request.\n. Not sure I understand. Partial mocks do behave like the real object for all methods that aren't stubbed. Line 217 in the current implementation of OCPartialMockObject: if the invocation is not \"recorded\", which is OCMock's internal lingo for saying it's not stubbed, then it is forwarded to the real object. My assumption is that you mean something different, especially because you reference an issue with key-value lookups. Can you clarify?\n. Closing this due to inactivity. Please shout if you have further information.\n. Closing this due to inactivity. Please shout if you have further information.\n. This should work. In fact, I've tried but I can't reproduce the problem. The following code passes for me. And it's the scenario you mean, right?\n```\n@interface TestClassWithSimpleMethod : NSObject\n+ (NSString )bar;\n- (NSString )foo;\n@end\n@implementation TestClassWithSimpleMethod\n\n\n(NSString *)bar\n{\n    return @\"Bar\";\n}\n\n\n(NSString *)foo\n{\n    return @\"Foo\";\n}\n\n\n@end\n@implementation PartialAndClassTests\n\n\n(void)testCanStubClassMethodOnPartialMock\n{\n    id realObject = [[TestClassWithSimpleMethod alloc] init];\n    id mockObject = [OCMockObject partialMockForObject:realObject];\n    [[[mockObject stub] andReturn:@\"mocked\"] bar];\nid actual1 = [TestClassWithSimpleMethod bar];\nXCTAssertEqualObjects(actual1, @\"mocked\", @\"Should have stubbed class method\");\n[mockObject stopMocking];\nid actual2 = [TestClassWithSimpleMethod bar];\nXCTAssertEqualObjects(actual2, @\"Bar\", @\"Should have un-stubbed class method\");\n}\n\n\n@end\n``\n. Closing this due to inactivity. Please shout if you have further information.\n. It _shouldn't_ be neccessary to callstopMockingexplicitly, because the mock does call it internally during its deallocation. If it doesn't get called automatically, then this is a sign that (for some reason) the mock isn't getting deallocated. Tha said, there are some issues related to retain cycles between the mock and invocation arguments that can result in the mock hanging around. If callingstopMocking` fixes the issue for you, there's no reason not to call it.\n. This is an interesting idea. You could probably extend it to add a method that creates a partial mock for an existing object. \nThat said, I'm slightly worried that adding this new method of creating mocks alongside the changes in OCMock 3 could be confusing. I will add this PR after the release of OCMock 3. Can I ask you to update it once OCMock 3 is out?\n. One more question. I could change the macro API from\n    OCMClassMock([NSString class])\nto\n    OCMClassMock(NSString)\nWould that be an even better solution? I do realise that the alternative is not as flexible, but I guess that 99% of the cases people will just pass the return value of the class method anyway.\n. What @carllindberg said. I just forgot to close this one earlier. Apologies.. Actually, it works as expected, but it's a bit hard to see what's going on. Look at the line in question:\nNSString * myNewString = [[NSString alloc] init];\nIn the test you have stubbed +[NSString alloc] to return the mock. In that line you call alloc, which returns the mock. On the return value (the mock) you then call init. So, basically you are calling init on the mock. Now, the mock does have an implementation of the init method, an implementation that intialises it...\nRegarding your underlying problem: I assume you have a piece of code that creates a string and you want to verify that your code calls certain methods on the string. You are stubbing the alloc method to make sure that the code under test uses the mock and not a real string. Unfortunately, this will not work because certain methods  like init simply cannot be stubbed because the mock needs to implement them. One solution for your case would be to add a factory method to your class under test, e.g.\n- (NSString *)makeString\n{\n    return [[NSString alloc] init];\n}\nand in the test have a partial mock on the class under test in which you stub out the factory method, e.g.\nid partialMock = [OCMockObject partialMockForObject: /* your object */];\n[[[partialMock stub] andReturn:stringClassMock] makeString];\nHope this makes sense.\n. As far as I understand it is good practice to set ONLY_ACTIVE_ARCH to YES because it speeds up the build. What I'm unclear about is how this setting in OCMock can affect your build. Are you building OCMock from source as part of your build process?\n. In the meantime I've changed OCMock so that its test suite still has ONLY_ACTIVE_ARCH=YES while the library and framework should be built for all architectures. Hope this makes sense.\n. The wording of the license and the text in the file banners is intended to make OCMock available as an open source library with minimal restrictions. Based on feedback over the years it has become obvious that the current situation is not ideal. This is why OCMock 3, due to be released this spring, will be released under a standard Apache 2 license. This has been announced on the website, too: http://ocmock.org/ocmock3\n. This is a known limitation not only for tagged pointers but also for toll-free bridged classes like NSString. The website has had this note basically since the introduction of partial mocks:\n\nNote that currently partial mocks cannot be created for instances of toll-free bridged classes, e.g. NSString.\n\nThere are also tests that show the limitation. They are commented out so the build doesn't fail. See line 104 and 118 in https://github.com/erikdoe/ocmock/blob/master/Source/OCMockTests/OCMockObjectPartialMocksTests.m\nWhat shall I do with this bug? Shall I add a word about tagged pointers to the features page?\n. Just merged it.\n. Actually, there is an issue with the PR. Will comment over there (#86).\n. While looking at the PR I realised that I wasn't completely happy with the tests; they were creating classes with synthetic names, rather than working with concrete scenarios. I tried to improve them by re-writing the tests like this:\n```\n- (void)testRefusesToCreatePartialMockForTollFreeBridgedClasses\n{\n    id tollFreeObject = CFStringCreateWithCString(kCFAllocatorDefault, \"foo\", kCFStringEncodingASCII);\n    XCTAssertThrowsSpecificNamed([OCMockObject partialMockForObject:tollFreeObject],\n                                 NSException,\n                                 NSInvalidArgumentException,\n                                 @\"should throw NSInvalidArgumentException exception\");\n}\n\n(void)testRefusesToCreatePartialMockForTaggedPointers\n{\n    int value = 3;\n    id taggedObject = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &value);\n    XCTAssertThrowsSpecificNamed([OCMockObject partialMockForObject:taggedObject],\n                                 NSException,\n                                 NSInvalidArgumentException,\n                                 @\"should throw NSInvalidArgumentException exception\");\n}\n```\n\nInterestingly, the second test doesn't do what I expected; the tagged object's class name doesn't start with \"__NSTagged\" but with \"__NSCF\". This test, I believe, proves the issue:\n- (void) testPointerValue\n{\n    NSNumber *object = [NSNumber numberWithInt:42];\n    XCTAssertEqualObjects(@\"__NSCFNumber\", NSStringFromClass([object class]));\n    // shifting the last byte reveals the value, proving a tagged pointer\n    XCTAssertEqual(42, (int)((long)object>>8));\n}\nDo you know under which circumstances \"__NSTagged\" is used?\n. Thanks! I went with a date in the tagged pointer test, and made sure it only runs on 64 bit systems. https://github.com/erikdoe/ocmock/commit/634b733ee334e6175baa85156b1c0824626fa085\n. Thank you for providing the up-to-date CocoaPod Spec. I have a couple of questions, though. \nI thought the specs need to go into the CocoaPod repo, not into the projects' repositories. There are specs for OCMock in the repo (https://github.com/CocoaPods/Specs/tree/master/Specs/OCMock). Shouldn't the 3.0 M2 spec go there, too?\nIt looks like CocoaPods have changed the format to JSON recently. Is that optional or do all specs now have to be in the new format?\n. To be honest, I haven't used Cocoapods myself, and in the past someone else has provided the pods for OCMock. The process seems to have changed. Also, I still don't know whether this PR should be changed so that it uses JSON syntax for the podspec. Can someone do a pull request with the correct format etc?\nOnce I have the podspec in the repo, I understand that I need to install the Cocoapod tool (ruby gem). Then I just do a pod trunk push and that's all, right?\n. Thank you for taking the time to research this. Much appreciated. Before I dive into the analysis, can I ask you which version of OCMock you have used? If it was M2, can you retry with M3 (which I released just now)? I'm asking because the approach to cleaning up stubbed class methods was changed significantly between M2 and M3.\n. Finally found some time to look into this in more detail. It seems that this was not related to partial mocks. I can reproduce the problem with two class mocks. (That said, partial mocks are class mocks, too, they inherit from class mock.) The following unit test shows the problem:\n```\n- (void)testCanHandleMultipleClassMocksOnSameClassWithReverseDeallocation\n{\n    NSLog(@\"class = %p; meta = %p\", [TestClassWithClassMethods class], OCMGetIsa([TestClassWithClassMethods class]));\nid mock1 = [[OCClassMockObject alloc] initWithClass:[TestClassWithClassMethods class]];\n[[[mock1 stub] andReturn:@\"mocked-foo-1\"] foo];\nNSLog(@\"class = %p; meta = %p\", [TestClassWithClassMethods class], OCMGetIsa([TestClassWithClassMethods class]));\n\nid mock2 = [[OCClassMockObject alloc] initWithClass:[TestClassWithClassMethods class]];\n\n//    [[[mock2 stub] andReturn:@\"mocked-foo-2\"] foo];\n    NSLog(@\"class = %p; meta = %p\", [TestClassWithClassMethods class], OCMGetIsa([TestClassWithClassMethods class]));\n[mock2 stopMocking];\nNSLog(@\"class = %p; meta = %p\", [TestClassWithClassMethods class], OCMGetIsa([TestClassWithClassMethods class]));\n\nXCTAssertNoThrow([TestClassWithClassMethods foo]);\n\n}\n```\nRunning this test gives me \"No mock for class (null)\" in the assert line. I believe the scenario is somewhat like this:\n- create mock for a class\n- create another mock for that class\n- stop/dealloc the second mock\n- call a class method on the class\nOf course, the call to foo should not raise an exception. What I'm unsure about at this point is what I'd expect that return value to be. And to be honest, implementing \"stacking\" behaviour for the mocks, i.e. foo returning \"mocked-foo-1\" even after commenting in the stub statement for mock2, seems very hard. \nI guess, creating a new class mock should immediately invalidate all previous class mocks, and when any class mock is stopped/dealloced, all class method mocks should disappear. Does this make sense?\n. Okay, I should have phrased that more carefully. It should absolutely be possible to have two mocks for the same class in existence at the same time. What I was proposing is that only the last mock created for a given class can be used to mock class methods on that class. I have pushed a change now that implements this behaviour. It should fix your problem. \nThe rationale for creating the forwarders eagerly is verify-after-running. With this style the mock object doesn't know which methods the developer is interested in until the verify, at which point the method has been called. The only way to intercept it is to install the forwarder for all class methods before any methods are called. With the expect-run-verify approach it is possible to install the forwarders during the set up of stubs and expects, which is what OCMock 2 did.\nIt's surprising to hear that setting up a mock for any class would take several seconds. If this becomes a major problem, maybe I should add a way to create a class mock object that cannot be used to verify class methods. Then it wouldn't have to create all the forwarders eagerly.\n. Yes, in all versions of OCMock so far class methods are mocked on the real class itself. This is done to enable stubbing of factory methods, which is think is one of the core use cases for mocking class methods. You've given me an interesting idea, though. Maybe for a later version of OCMock...\n. Before I release OCMock 3, which I'm planning to do tomorrow, can you confirm that the fix works for you? Thanks.\n. Short of an explicit way to achieve this it's a neat trick. Will add it to the documentation, too. \nIf I were to add an explicit way to \"blank out\" methods on partial mocks, any idea what the API could be like?\n. As with the selector-based syntax, class methods are set up on the mock, ie.\nOCMStub([bulkOperations bulkOperationsOnManagedObjectClass:OCMOCK_ANY withCoreData:OCMOCK_ANY]).andReturn(@\"FOOBAR\");\nWhat is the compiler error you're getting for this?\nUPDATE: There is a bug with using class methods and the macro syntax. Working on it.\n. I've just pushed some changes that fix the problem. It was a clear oversight on my part.\nThank you again for trying out the OCMock 3 pre-releases and for providing very useful bug reports. The release (which is imminent now) is a better release thanks to your reports.\n. What you see is the expected behaviour. There are unit test in OCMock that test this scenario, with the outcome you see. Check out testStubsMethodOnRealObjectReference and testCallsToSelfInRealObjectAreShadowedByPartialMock in https://github.com/erikdoe/ocmock/blob/master/Source/OCMockTests/OCMockObjectPartialMocksTests.m\nIn fact, this was one of the harder features to implement, but OCMock is definitely designed so that stubs/expects/verifies on partial mocks do affect the underlying real object.\n. Closing this because the issue is assumed fixed.\n. Interesting case. My concern about this pull request is that it contains a fair bit of complicated code without any tests. (I guess this is because the problem can't be created in the context of the normal OCMock unit test suite.) In addition, it is introducing all that complexity for a use case that can arguably be considered very uncommon.\nWould it be possible to make a change in OCMock that allows you guys to add a special class or handler into your test suite that modifies the OCMock behaviour so that it works for this scenario?\n. I have now merged #115 into master. Could you verify whether this fixes your problem?\n. Assumed fixed by #115.\n. Okay, I think I've done everything that was necessary. Please let me know whether I missed something.\n. Thanks for reporting this issue. Unfortunately, there isn't quite enough detail for me to reproduce the problem. Would it be possible to share a small but complete test with which the loop is triggered? Also, can you find out with the debugger what method call is causing the loop? The first argument to forwardInvocation: is an invocation object that should be able to provide the selector. Thank you!\n. Closed due to inactivity. Assumed fixed.\n. Okay, this is a complex topic but I'll try to make it short. I am a great fan of test-driven development. I totally understand the value of unit tests (and other types of tests). In fact, part of my day job at ThoughtWorks is to coach development teams with the adoption of good development practices such as test-driven development.\nIn my experience, measuring test coverage can be useful when retrofitting unit tests to a large existing codebase. It can help a team see a trend and whether that trend is going into the right direction. However, on mature codebases that were developed test-driven, code coverage is, again in my experience, relatively meaningless. Coverage tools give you a percentage value but is it possible to  say what the right value is? Is it 80%, 90%, 100%? Why? Do we test getters and setters? And, which value do we even look at, line coverage or branch coverage? Is line coverage even relevant for complicated logic, which arguably needs testing the most?\nRegarding the effect on the team, I understand the Hawthorne effect, but in the end it's always \"you get what you measure\". With coverage this can promote bad behaviour such as adding a few meaningless tests just to raise coverage. (And, yes, having too many tests is bad, too, because it \"strangles\" the codebase and makes refactoring harder.) Also, coverage doesn't mean that functionality is actually tested. I remember seeing a codebase with 200 units tests that didn't have a single assertion. Good coverage, but the value of the tests...?\nSo, you see, I'm not a great fan of code coverage tools, which is why I won't accept this PR. Hope you understand.\n. At the moment the behaviour is as follows:\n- Any stub that is created remains in place for the lifetime of the mock object. \n- A stub matches any number of matching invocations.\n- When looking up a stub the mock object goes through its list of stubs in the order they were added.\nMaking a new stub supersede or override a previous one seems obvious in this case but it's not possible to do this in a generic way. Think of methods with multiple arguments and different constraints; OCMock would not be able to determine when to add a new stub and when to replace an existing one.\nSo, rather than adding an indeterministic override mechanism my preference is to add quantifiers, i.e. it should be possible to say how often a stub or an expectation should be active for. This is something I'm planning to add in the coming weeks. \nHope this helps. \n. With a reverse order I'm sure that sooner or later people would start asking the reverse question, ie. why is the stub I defined not working? Then the answer would be \"because a later one overwrote it\".\nThat said, with the benefit of hindsight, having later stubs overwriting earlier ones does seem preferable. However, making this change now would be very disruptive, it would break lots of tests that people have written. For that reason I am shying away from switching the behaviour now.\n. Thanks. It annoyed me, too. I fixed it in https://github.com/erikdoe/ocmock/commit/90bc0bdb2621ea49b82cf693f879e5cd0139c0c9 by simply throwing an exception that looks like the one that NSObject throws in its implementation of -doesNotRecognizeSelector:.\n. This is strange. Even in OCMock 2.0, which was released over two years ago, that header was not in the list of public headers.\nEither way, the reason why not all headers are public is simply that I want to keep the published API of OCMock small. The fewer methods in the API, the fewer methods I have to worry about when it comes to backwards compatibility.\nIf you find the NSInvocation category useful, you can simply copy the header from the source of OCMock and include it in your project. There is no guarantee that these methods will be in future versions of OCMock.\n. Agreed, this should work. It shouldn't be too hard to fix either. Will look into this in the next couple of days.\n. Should be fixed now.\n. This is odd. I've added the following test to a fresh iOS app, and the test passes, proving that you can create a mock for a UIView.\n- (void)testCanMockUIView\n{\n    id mockView = OCMClassMock([UIView class]);\n    XCTAssertNotNil(mockView, @\"Should have created mock\");\n}\nSomething must be different in your setup. What is the exception you are seeing?\n. The reason why all methods are stubbed is the verify-after-running approach. This approach is more intuitive and much more popular with developers. It requires stubbing all methods, though, because OCMock doesn't know in advance which methods the test will verify afterwards. \nOf course, I am aware that several recent problems have been caused by this approach. Let's see whether we can cover most edge cases in the coming weeks. If not, it may be necessary to allow creating of a mock that doesn't allow verify-after-running, and in turn doesn't need to stub everything. If at all possible I'd like to avoid adding yet another mock type, though.\n. This is interesting. Any chance you can find out which selector is causing the problem? When the exception breakpoint is hit, can you select instanceMethodForwarderForSelector: on the stack and print the selector, using NSStringFromSelector()?\nAlso, could you retest with the current master, which includes Carl's fixes? I, too, think there's a good chance that that solves the problem.\n. I still can't reproduce the problem. I've pasted the following test into OCMock's iOS7 example project and it passes without problems:\n- (void)testCanMockUIView\n{\n    id mockView = OCMClassMock([UITableView class]);\n    XCTAssertNotNil(mockView, @\"Should have created mock\");\n}\nWhat could be different? I'm testing with the following:\n- OS X 10.9.4\n- Xcode 5.1.1\n- iOS SDK 7.1\nAlso, what frameworks is your project linked against? I have found a mention of the method in a different class, which seems to be in the QuartzCore framework.\nhttps://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/QuartzCore.framework/CAAnimation.h\nHowever, when I add the QuartzCore framework to the OCMock iOS7 example project, it still creates the mock just fine.\n. I've now managed to reproduce the problem. The breakpoint is hit and I can see that the selector is CA_setterForProperty:. Interestingly, the types are similar to the ones reported in #112. \nIf we implement the idea discussed in #124, namely to exclude most \"Apple-internal\" selectors from being stubbed, then this problem would go away.\nI should be able to get this done later this week.\n. I have just pushed several changes that address the problems reported in #112, #122, and #124. They seem to fix this issue, too. Turning on the all exceptions breakpoint no longer seems to cause the debugger to stop. Can you verify, please?\n. This is not expected behaviour. It's caused by one of the implementation changes that make verify-after-running possible. However, by some coincidence, somebody else has emailed me about this problem yesterday, and he did include a fix. Should make it into master in the next few days.\n. Fixed in commit https://github.com/erikdoe/ocmock/commit/fb4fec74814425c811100218f07c119f6774f7a0. Let me know if it works for you.\n. This was a slightly embarrassing bug that crept in when I did some refactorings after the 3.0 release. Should be fixed now.\nThere is no new syntax yet. In fact, the refactoring that caused this bug is part of the preparation for a few changes that will include a modern syntax for \"rejecting\" method invocations. The new syntax is  likely going to be one of the following\nOCMExpect(Never([mock someMethod]));\nOCMExpect(never(), [mock someMethod]);\nOCMExpect([mock someMethod).never();\n. First sub-section in http://ocmock.org/reference/#advanced-topics\n. Actually, this works as expected but I agree that the documentation should be clearer about it. Only  verify calls work after the fact. Reject is a variant of expect, and it needs to be set up before the relevant calls occur. It part of the expect-run-verify pattern (see 7.1 in the docs).\nIf you change your code as follows, the test will fail:\n- (void)test_faillureOfReject {\n    UIView *viewMock = OCMClassMock([UIView class]);\n    OCMReject([viewMock setBackgroundColor:OCMOCK_ANY]);\n    viewMock.backgroundColor = [UIColor blueColor];\n}\nThe result is an exception when you are trying to set the colour. \nAssertions: failed: caught \"NSInternalInconsistencyException\", \"setBackgroundColor:<OCMAnyConstraint: 0x7fe1c8e900e0>: explicitly disallowed method invoked: setBackgroundColor:UIDeviceRGBColorSpace 0 0 1 1\"\nWhat is missing today is a way to verify that a method has not been called. This is planned, but it's not in OCMock right now.\n. Sorry. I'm new to maintaining the podspec myself. Made a mistake. It should be fixed in the new 3.0.2 release.\n. Like it. Was on holidays/vacation. Will add it soon.\n. It seems that the class you are trying to mock has a class method that is problematic. When the method's types are passed to the factory method in NSMethodSignature, that factory method complains that it cannot create an NSMethodSignature instance for these types. To be honest, I have no idea how that can happen. It's in Apple's code.\nThat said, could you look through the class you are trying to mock and see whether there are any \"suspicious\" class methods? Can you share the list of class methods of the class you are trying to mock? \n. @carllindberg This means we could wrap the call to instanceMethodForwarderForSelector: in an exception handler and, if signatureWithObjCTypes throws, not add the forwarder in the setup phase, right?\nJust wondering what we should do when later stub is called with this method. With the change described about, the mock wouldn't complain, but the stub wouldn't work either. Should we then throw an exception saying that the method cannot be stubbed?\n. In 1df026d I have now added an exception handler to the code that sets up the stubs during the creation of the mock. It silently ignores such exceptions. The result is that you can't verify such a method, the mock will always complain that it hasn't been called, even if it was.\nWhen setting up a stub manually the exception is not caught by any OCMock code. This, I believe provides clearer feedback to the developer who's trying to stub that specific method.\n. Just to confirm: the current behaviour is that stub and expect will throw for these methods. The exceptions are only suppressed when the mock is created.\n. There is no new syntax yet. If you need this you have to use the selector-based syntax:\n[[[mock stub] ignoringNonObjectArgs] someMethodWithIntArgument:0]\nShould work with verify, too:\n[[[mock verify] ignoringNonObjectArgs] someMethodWithIntArgument:0]\nModern syntax should be in the next major release.\n. Nothing has been checked in, no concrete plans for the next release have been announced yet.\n. Observer mocks are meant to be strict (as mentioned in http://ocmock.org/reference/#observer-mocks). Is that not the case? Does the observer receive an unexpected notification and not complain? That would be a bug.\n. Partly my fault, too. The design isn't very symmetric. In the new syntax class mocks, partial mocks, and protocol mocks are all created \"nice\" by default while observer mocks are strict by default. In hindsight I don't know how I end up there.\n. Haven't forgotten about this. It'll be in 3.1, which isn't too far off.\n. With some of the recent changes (I'm looking at you #115) this is probably resolved. Could you double-check?\n. I have merged most of this now, i.e. the casts as discussed above. I have not included the additions of CoreGraphics. I'd really like to understand how that's necessary when the framework/lib build without it in most environments.\n. First off, there is no need to call stopMocking explicitly. The mock objects call it automatically during their deallocation. That said, there are guard statements in the code and calling stopMocking shouldn't cause any issues as long as the mock is not used after that call.\nThe stack trace actually doesn't contain any OCMock code. Maybe this is an issue with memory management in another framework. (I assume you use ARC.) What happens when you replace the call to stopMocking with something innocent like description? Does it still crash?\n. The mocks themselves are normal instances. When the mock (the instance) gets deallocated, it calls stopMocking on self. The class, which does stay around, is then restored to its original state. Does that make sense?\n. Yes, it looks like after all the rewriting the reference doc ended up not mentioning this. It should probably be mentioned in the Matching arguments subsection of http://ocmock.org/reference/#argument-constraints\n. On balance, I think I can see some value in adding an isEqual: method. However, the implementation doesn't need to be complex. Given that equality is the default the following should do the trick, right?\n+ (id)isEqual:(id)value\n{\n    return value;\n}\nI have updated the reference doc by the way.\n. To be honest, using an OCMIsEqualConstraint might slightly improve the code in OCMInvocationMatcher but at this time I'm not sure it's worth the effort. With the equal constraint not needed it looks like this pull request can be closed.\n. On the one hand I like it. It's a useful constraint and it has been requested before, even implemented a long time ago (see http://blog.carbonfive.com/2009/02/17/custom-constraints-for-ocmock/).\nOn the other hand, though, OCMock supports Hamcrest matchers, and Hamcrest provides the instanceOf matcher that implements this constraint (see https://github.com/hamcrest/OCHamcrest#predefined-matchers).\nI'm wondering, is it worth re-implementing a matcher that is available via Hamcrest already, just to have it directly in OCMock? Do you find the barrier to using Hamcrest matchers to high? \n. Finally got a chance to look into this. It turns out that this is expected behaviour. It is the result of two things:\n1. Partial mocks actually are class mock objects. In the implementation OCPartialMockObject inherits from OCClassMockObject. This could be made clearer in the documentation\n2. The behaviour when attempting to stub class methods on the same class using different mock objects is undefined. This is mentioned in the limitations section in the documentation (http://ocmock.org/reference/#mocking-class-methods). The current implementation specifically deactivates the previous mock for class method mocking when a new mock for a class is created (see line 84 in https://github.com/erikdoe/ocmock/blob/0adc6532fec56992b5f792cd692df445bb4bafea/Source/OCMock/OCClassMockObject.m#L77).\nIn your example, you can simply stub the class method on the partial mock; like this:\nid mockController = [OCMockObject partialMockForObject:standinObject];\nOCMExpect([mockController new]).andReturn(standinObject);\nHope this makes sense.\n. On a related note: is this too confusing? Do you think it would make more sense if partial mocks did not allow mocking of class methods at all? Not sure I'd make this API change, because it would be breaking existing code, but it is worth considering, I guess.\n. To be honest I can't think of any reason that would make OCMock 3 noticeably slower. What kind of slowness are we talking about? A few milliseconds per test? Or are there specific tests that have added several seconds each?\n. Thank you for investigating this further. This is really curious. The OCMock test suite itself, which when built for OS X comprises 216 tests, runs in little over 1 second on my laptop. And it obviously uses OCMock quite heavily. So, it seems that there's nothing inherently slow about OCMock.\nWhat could be different in your environment? Of the 24 tests you ran, are there particular tests that have become slow? Or does using OCMock 3 seem to add a little overhead to each of the 24 tests? \n. The new syntax is implemented on top of the selector-based syntax. So that shouldn't be a problem.\nA major implementation change in OCMock 3 was the introduction of verify-after-running. To make this work the mocks now basically stub each and every method when they are created. (They have to so that they can record all invocations before they know what will be verified.) My suspicion at this point is that maybe the mere use of some runtime introspection triggers some code in the story board or view controller, which takes a bit of time to run. Unfortunately, I can't think of a good way to debug this.\nOne thing that may be worth trying, given that it seems you're building OCMock from source anyway, would be to make a small change in OCPartialMockObject. Could you change lines 134-135 from\nif(types == NULL)\n    types = ([[mockedClass instanceMethodSignatureForSelector:selector] fullObjCTypes]);\nto\nif(types == NULL)\n    return;\nand see whether that makes any difference?\n. I've looked into this and added the following test to the iOS7 example project:\n- (void)testCreationOfPartialMocks\n{\n    for(int i=0; i<100; i++)\n    {\n        MasterViewController *controller = [[MasterViewController alloc] init];\n        id controllerMock = OCMPartialMock(controller);\n        [controller tableView:nil commitEditingStyle:UITableViewCellEditingStyleInsert forRowAtIndexPath:nil];\n        [controllerMock description];\n    }\n}\nWhen I run the iOS version in the simulator, Instruments says that it takes about 7s. Inverting the call tree shows that the biggest chunk is about 2.7s spent in search_method_list():\n\nDrilling into this I can see how that's called from different places during the setup of the stubs when creating the mock:\n\nI've tried a few things to reduce the number of calls but I haven't come up with anything that makes a major difference.\n. Could you share an order of magnitude? How many tests per second did you see with OCMock 2 and how many tests per second do you see with OCMock 3? From my experiments it seems that currently with OCMock 3 it can take about 0.1s to create a partial mock. Is this what you are seeing?\n. I've just pushed a change that should improve things somewhat. If you have a chance, could you check whether it makes things better for you, too? Not saying we're there yet.\n. This is odd. The changes I made involve string comparisons and regex matches on class and method names. I'm curious how this can cause crashes. Could you post a stack trace?\n. On second thought. I've also merged #115 since the release of 3.0.2, and this does have potential to introduce crashes. Even more interested in the stacktrace. @carllindberg are you watching this?\n. As an intermediate progress report; in 3c79446 I have added code that creates a +intialize method in the special subclass created by the mock.\n. @johnbland-wf Just to confirm, are you still seeing your test suite crash with the latest version of OCMock? And the crashes are in class_isMetaClass() as shown in the screenshot?\n. Now that we are already ignoring all class methods in NSObject would it still make sense to put +load and +initialize on the black list? This would only apply to implementations in subclasses.\nInteresting. I, too, thought that the partial mock subclass should have an empty initialize method. However, with the current implementation this doesn't seem necessary. I've added a test to document this.\nTo be honest, I haven't benchmarked whether an NSSet would really be faster than an NSArray for such small number of objects. In either case the calls to containsObject: are quite far down on the overall cost, so I'm inclined to go with the simpler code.\n. @johnbland-wf With the latest commits (0adc653) I think we are at a point where further performance improvements would require major changes, e.g. an API to disable verify after running. I'm a bit reluctant to do this. How comfortable are you with the performance of OCMock after the changes made now?\n. @carllindberg Not sure I understand your last suggestion. You're saying that we could put the cache into the NSMethodSignature method because it only depends on the objcType. It's true that the type string is a sufficient cache key, but getting the type key requires looking up the NSMethodSignature instance and that is the most expensive part of the operation... Caching on the selector name only isn't sufficient because a method with the same name could have different return types. This is why I settled on the class/selector cache key. Doesn't that make sense? \n. @johnbland-wf Couldn't spend much time on OCMock recently. A release should be out soon very soon, though.\n. Could you set a breakpoint on the malloc error and post the result here? In case you haven't done this before: http://stackoverflow.com/questions/14045208/how-to-set-a-breakpoint-in-malloc-error-break-to-debug\n. You are creating a partial mock for [UIApplication sharedApplication], right? Somehow like:\nid partialMock = OCMPartialMock([UIApplication sharedApplication]);\n/* do stuff */\nOCMVerify([partialMock openURL:[OCMArg any]]);\nWhen exactly does the error occur? Which method do you call? Could you post a stack trace?\n. I'm thinking we should put all methods that meet the following two criteria on the whitelist:\n- the method is declared in a class that has an Apple prefix, e.g. NS, UI, CL\n- the name of the method starts with underscore\nThe only reason that OCMock stubs the methods is that their invocation can be verified in a test. It's reasonable not to support verification of private methods in Apple's classes, right?\n. It is \"swizzling\" all methods because of verify-after-running. The flow of control is:\n1. Test creates mock\n2. Test invokes some methods on the object\n3. Test asks the mock to check that certain methods have been invoked\nThe only way for the mock to be able to check in step 3 whether a method has been invoked in step 2 is to stub out all methods in step 1 so that they run through the mock. Does this make more sense?\n. I have just pushed a few changes:\n- Instance methods on NSObject and NSProxy are no longer stubbed automatically\n- Class methods on NSObject and NSProxy are no longer stubbed automatically\n- Methods in classes with an NS or UI prefix that start and/or end with an underscore are no longer stubbed automatically\nCan you verify that this fixes the problem for you?\n. Please see discussion on Stackoverflow.\n. With the recent changes made in response to some of the other issues reported this problem seems to have been fixed, too. Could you retry whether it works for you now?\n. With the recent changes made in response to some of the other issues reported this problem seems to have been fixed, too. Could you retry whether it works for you now?\n. Could you check whether @carllindberg's comment on issue #123 helps with your issue. It seems likely.\n. Closed due to inactivity. Assumed fixed.\n. I can see value in using the literals because it marginally simplifies the code. However, I've never been a fan of the subscripting. Call me old-fashioned but I find using square brackets in yet another way confusing. \nWould it be possible to change the pull request so that it only contains a change to literals?\n. Thanks. Fixed in https://github.com/erikdoe/ocmock-site/commit/76690f98ce5ca841ce6de390e299cabbeaf07602. By the way, you can do a pull request against the site repository. ;-) \n. Just to confirm: your tests all pass and when you comment out the line [fileManagerMock stopMocking] you get the test failure about the story board not being there? And the tests that are failing are they in the same or a different class/suite from the one which has the file manager mock? And, although I should probably know this by now, which test tool are you using? The afterEach suggests it's not plain Xcode Test...\n. Interesting. It's definitely an issue with the lifecycle of the mock. It looks like the mock instance stays around for too long, to a point in the execution where the NSFileManager is needed for work not directly related to the functionality that's tested. Either way, if stopMocking solves your problem, by all means, do use it. Just don't use the mock afterwards. \nAn alternative would be to clear the reference to the mock, which should trigger a deallocation under ARC. Or, in other words, does fileManagerMock = nil also work instead of stopMocking?\n. It really looks like a lifecycle issue with the mock object. Maybe time to file a bug against Specta? ;-)\n. This was independently reported in issue #138. I have added a fix. Kept this PR open to cherry-pick the test. The problem should be gone, though.\n. The stub variable is set by the loop:\nfor(stub in stubs)\nThis is fast enumeration, which works with variables that are declared beforehand, too. If the loop runs to the end of the enumeration the variable is set to nil again. Does this make sense?\n. Sorry, saw your PR too late. Turns out I implemented exactly the same solution. I'll probably cherry-pick the test to make sure we've got this covered. Thanks.\n. As mentioned in the documentation there is overlap with a planned future extension (http://ocmock.org/reference/#advanced-topics). In a nutshell, many mock framework allow quantifiers on expectations, something like \"expect this method to be called three times\". What is called reject now can also be considered a never quantifier, and that's how it's implemented in several other mock frameworks. See my comment on #109, too.\n. Thanks. That was a quick catch. I've just released 3.1.1 to include this important fix.\n. Couple of things: the class check was a significant problem introduced recently. It is also addressed by #140 which I have just merged. I like that this pull request has a test. However, I haven't merged it because I don't understand the Travis script change. It is better to make specific pull requests that address one issue per pull request. That makes it easier for me to incorporate them quickly.\n. This should be fixed on OCMock 3.1.2 which no longer declares a dependency on XCTest.\n. Closed due to inactivity.\n. It's possible to do this as follows\n[[sut reject] someMethod];\nIf you prefer you can also write\n[[[sut expect] never] someMethod];\nMore information at: http://ocmock.org/reference/#advanced-topics\n. The way it's written above it should definitely work. I assume you've simplified your actual test and left out something relevant. There are two reasons I can think of that would make the stub \"disappear\":\n1) After the stub is created with a mock object, another mock object for the same class is created. This is case is described in the reference documentation (http://ocmock.org/reference/#limitations).\n2) The mock object with which the stub was created ends up being deallocated before someMethod is invoked. \nCould either of these be the case? \n. These are two separate issues. You must include ClassMethod when you want to stub a class method that has the same name as an instance method on the same class. This is documented and there are several tests in OCMock's test suite. Are you saying that you require ClassMethod in any other circumstance? In that case I'd be interested in more details.\nRegarding the original question, like I said, it should work and it's known to work. Can you create a toy project to reproduce and check that into Github?\n. Thanks for posting the solution. I'm glad you solved it and hopefully this will help others in the same situation.\nDoes this mean we can close this issue?\n. Finally found time to look into this. It seems that despite appearances these are separate issues.\n@foulkesjohn Unfortunately, I can't diagnose this from the code you provided. I can only speculate that there is a memory problem somewhere around the return value of [ArrangeInvocation successfulInvocation] but at a minimum I'd have to see the code for that. Also, I'm not a Specta user but it seems that the code wouldn't even compile, particularly the following two lines:\nOCMStub([mockObject anotherMethod]);\n.andDo(successfulInvocation);\nWhat is this test trying to show? That stubbing one method but calling another makes the verification of the other method fail?\n@HiveHicks Only realised now that you probably just made a simple mistake. As far as I am aware you have to add __block to variables that will be accessed from a block. You're just \"lucky\" that in the first test the omission doesn't cause a problem.\n@iosdev-republicofapps OCMock already retains the arguments on the recorded exception in almost all cases. For complicated reasons it can't retain the arguments when the method has at least one char* argument, but the methods discussed in this issue don't seem to have such arguments.\n. Looking at this code I think you're running into a know problem with ARC and NSInvocation that isn't specific to OCMock. Have a look at this comment, maybe this helps: https://github.com/erikdoe/ocmock/issues/123#issuecomment-49896556\n. It looks like the build is failing. Could you look into this?\n. Merging with master should fix the build for this PR.\n. The build failed due a change Apple made. Has been fixed. I've just added the typeof changes manually.\n. Closing due to inactivity. The changes proposed should be in master.\n. This does look suspicious. I'm not sure I completely understand. Could you provide a failing test?\n. So, I keep coming back to this issue but I can't seem to find a good answer. My thoughts so far:\n- For this to work in a nice way the mock would have to provide implementations of valueForKey: and valueForKeyPath:.\n- It doesn't seem like a good idea to put these methods into OCClassMockObject because this would make it impossible to mock these methods.\n- A solution would be to create a new subclass, maybe OCClassMockObjectWithKVSupport, but that makes the API unwieldy, and it doesn't solve the questions for partial mocks. Remember, they are a subclass of normal class mocks.\n- We could have a addKeyValueCodingImplementation method that creates a dynamic subclass of the mock and adds the methods at runtime. This would address the previous two concerns. However, if we do this, what is the correct implementation of valueForKeyPath: and, especially, valueForKey:?\n- We could steal the implementation of those methods from NSObject. In fact, I've tried this (see below) and it works for valueForKeyPath: but unfortunately the implementation of valueForKey: on NSObject does depend on other private methods, e.g. +_createValueGetterWithContainerClassID:key:. Adding those methods feels too much like a cat an mouse game to me.\nFor reference, my implementation that \"steals\" the KV methods from NSObject:\n```\n- (void)addKeyValueCodingImplementation\n{\n    / dynamically create a subclass and set it as the class of this mock object /\n    Class subclass = OCMCreateSubclass([self mockObjectClass], self);\n    object_setClass(self, subclass);\n/* add NSObject's implementation of valueForKey: and valueForKeyPath: to new subclass */\nMethod vfkMethod = class_getInstanceMethod([NSObject class], @selector(valueForKey:));\nconst char *vfkTypes = method_getTypeEncoding(vfkMethod);\nIMP vfkImp = method_getImplementation(vfkMethod);\nclass_addMethod(subclass, @selector(valueForKey:), vfkImp, vfkTypes);\n\nMethod vfkpMethod = class_getInstanceMethod([NSObject class], @selector(valueForKeyPath:));\nconst char *vfkpTypes = method_getTypeEncoding(vfkpMethod);\nIMP vfkpImp = method_getImplementation(vfkpMethod);\nclass_addMethod(subclass, @selector(valueForKeyPath:), vfkpImp, vfkpTypes);\n\n}\n```\nAt this point I feel I'm running out of ideas beyond what we discussed in #68. I'm going to close this issue but feel free to re-open it if you have a new idea.\n. This looks like a bug. Once I have a little bit of time I'll add a fix. If you have a chance, a pull request with corresponding tests would be appreciated.\n. It looks like this change broke the build. Could you look into it?\n. Sorry. I was a bit too quick with my comment. Now I see what was going on. Thanks for your effort and resubmitting.\n. Thanks. This is a bug and I believe your diagnosis is correct. I also saw the PR but I agree with the commenter on the PR that it goes beyond fixing the bug by introducing other changes; changes that are not in line with the overall coding style of the framework.\n. Thanks, this looks reasonable. That said, I have now merged #156 and this doesn't merge anymore. Would you mind merging in changes from master? Thank you.\n. Had merged it while offline and then forgot to push... Done now. Let me know what you think.\n. Thanks! Finally got round to merging this.\n. First off, would it not be easier to just make the access to the arrays thread-safe? I haven't looked into this in detail, but I suspect that there aren't too many places that would need a change, and the performance overhead should be negligible.\nThat said, OCMock 3 is not thread-safe at all. All the new syntax macros use OCMMacroState and that is not thread-safe because it stores the currently active state instance in a global variable. This could be moved into the thread dictionary because the state object is only required from within the macro.\n. To be honest, I don't think there's a good way to make the verify-after-running functionality optional, for the reasons you outline above. Arguably OCMock should be thread-safe and there is an issue that cover this (#171). So, I'm going to close this one.\n. It is currently not possible to create a mock that mocks both a class and a protocol. That said, even if it was possible, stubbing core runtime methods such as respondsToSelector: is not a good idea and may cause subtle issues in many places. \n. Duplicate of #161.\n. Interesting idea. When I make the proposed change, though, there are problems in at least one test in OCMock's test suite, namely https://github.com/erikdoe/ocmock/blob/master/Source/OCMockTests/OCMockObjectPartialMocksTests.m#L305-339\nWhen I comment out line 318, which is obviously not right anymore, but not so obvious to fix, I get an EXC_BAD_ACCESS in line 324. Haven't had a chance to look at that in detail yet.\n. Closing the issue to keep the discussion on PR #181.\n. To be honest, I consider this expected behaviour. What happens when you reverse the andForwardToRealObject and andCall:onObject: calls on the stub?\n. And that is a bug. Will look into it next week.\n. Finally got round to fixing this problem.\n. I have just released OCMock 3.1.2, which should fix this problem.\n. I've merged it on the command-line. This doesn't show automatically in this case because the forked repo seems to be gone. The changes are in master, though.\n. Maybe this should be even clearer in the documentation. Reject uses the old syntax and works with the old expect-run-verify approach. You have to tell the mock that a certain method should not be invoked. It is not possible (yet) to verify that has not been invoked.\nIn your case test 2 should work, and it is expected behaviour that test 1 does pass. The mock you are creating is not strict (ie. nice) and therefore accepts the hash method. Afterwards you tell it to reject all invocations of hash from that point onwards, but you never call hash afterwards.\n. The installation instructions on http://ocmock.org/ios are known to work, and the released binary contains the required symbols for all architectures. \nTo make totally sure no subtle issue has crept in with recent updates from Apple (because I have seen several reports of people struggling with the link stage) I just downloaded OCMock from its site, created a new iOS project, and followed the instructions to the letter. It links and works.\nNow, in this fresh project, when I remove libOCMock.a from the \"link binary with libraries\" build phase and then rebuild the project I get the following error, which looks quite similar to yours.\n```\nLd /Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Products/Debug-iphonesimulator/FooPhoneAppTests.xctest/FooPhoneAppTests normal i386\n    cd /Users/erik/Workspace/FooPhoneApp\n    export IPHONEOS_DEPLOYMENT_TARGET=8.1\n    export PATH=\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch i386 -bundle -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk -L/Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Products/Debug-iphonesimulator -L/Users/erik/Workspace/FooPhoneApp/usr/lib -F/Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Products/Debug-iphonesimulator -F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk/Developer/Library/Frameworks -F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Frameworks -F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk/Developer/Library/Frameworks -filelist /Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Intermediates/FooPhoneApp.build/Debug-iphonesimulator/FooPhoneAppTests.build/Objects-normal/i386/FooPhoneAppTests.LinkFileList -Xlinker -rpath -Xlinker @executable_path/Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -bundle_loader /Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Products/Debug-iphonesimulator/FooPhoneApp.app/FooPhoneApp -Xlinker -objc_abi_version -Xlinker 2 -framework XCTest -framework XCTest -fobjc-arc -fobjc-link-runtime -Xlinker -no_implicit_dylibs -mios-simulator-version-min=8.1 -Xlinker -dependency_info -Xlinker /Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Intermediates/FooPhoneApp.build/Debug-iphonesimulator/FooPhoneAppTests.build/Objects-normal/i386/FooPhoneAppTests_dependency_info.dat -o /Users/erik/Library/Developer/Xcode/DerivedData/FooPhoneApp-gbyhfsyaicqlorgkdtklsifckdvv/Build/Products/Debug-iphonesimulator/FooPhoneAppTests.xctest/FooPhoneAppTests\nUndefined symbols for architecture i386:\n  \"OBJC_CLASS$OCMMacroState\", referenced from:\n      objc-class-ref in FooPhoneAppTests.o\n  \"_OBJC_CLASS$_OCMockObject\", referenced from:\n      objc-class-ref in FooPhoneAppTests.o\n  \"_OCMMakeLocation\", referenced from:\n      -[FooPhoneAppTests testExample] in FooPhoneAppTests.o\nld: symbol(s) not found for architecture i386\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\nAre you sure you have added the library to the right target?\n. I'm not an expert in CocoaPods. It looks like the library is not linked to the test bundle. It might be worthwhile looking at the CocoaPods documentation to find out how exactly a static library can be linked to a test bundle.\n. Please see #103.\n. The problem is that reject implements the fail fast approach. The exception is thrown when the method in question is called, and not when verifyAll or a variant of it is called. This means the mock object doesn't have a location to report. In these cases the current implementation throws an exception.\nGoing forward, what I really want is to add qualifiers to verify. Then you could say something like \"verify that this method has never been called\" and OCMock could report the failure on verify. This is something I've wanted to add for a while and it's now pretty much on the top of the list of new features to add.\n. Closed due to inactivity.\n. This is a tricky case. On the one hand your test suite obviously relies on unspecified behaviour of the OCMock framework. The block you're passing into checkWithBlock: not only has side effects but it also is not idempotent, i.e. multiple invocations change the side effect. This is anything but ideal, but you know this. On the other hand, the documentation says nothing at all about side effects or limitations on the blocks passed to checkWithBlock:. So, I'm inclined to agree that this is a bug. I'll see how difficult it would be to restore the original behaviour. If I can achieve that I will add a test to document the behaviour.\n. To be more precise, I'll try to make this new test pass:\n```\n- (void)testArgumentConstraintsAreOnlyCalledAsOftenAsTheMethodIsCalled\n{\n    __block int count = 0;\n[[mock stub] hasSuffix:[OCMArg checkWithBlock:^(id value) { count++; return YES; }]];\n\n[mock hasSuffix:@\"foo\"];\n[mock hasSuffix:@\"bar\"];\n\nXCTAssertEqual(2, count, @\"Should have evaluated constraint only twice\");\n\n}\n```\nAt the moment this fails, count is 4.\n. It's an interesting challenge. The current implementation is justifiable but it does in some way violate the principle of least surprise. Give me a week or so... ;-)\n. Well it was a bit more than a week, but it should be fixed now, back to the old \"invoke the block once\" behaviour.\n. This is expected behaviour. Partial mocks are class mocks and OCPartialMockObject inherits from OCClassMockObject. The documentation clearly says that only one mock object should mock class methods on a given class. I know this is awkward but the alternatives seem worse. \nOn the bright side, there is a simple solution in your case: simply use the partial mock to stub the class method:\n```\n- (void)testClassAndPartialMock {\n  TestClassWithClassMethods *mockObject = [[TestClassWithClassMethods alloc] init];\n  mockObject.identifier = @\"mock object\";\nid mock = OCMPartialMock(mockObject)\n  [[[[mock stub] classMethod] andReturn:mockObject] sharedObject];\n  [[[mock stub] andReturn:@\"mocked method\"] identifier];\nNSString *identifier = [TestClassWithClassMethods sharedObject].identifier;\n  XCTAssertEqualObjects(identifier, @\"mocked method\", @\"expected \\\"mocked method\\\", got \\\"%@\\\"\", identifier);\n}\n```\n. There is an obvious place in the code where to do this: https://github.com/erikdoe/ocmock/blob/master/Source/OCMock/OCClassMockObject.m#L85-88\nHowever, there is a reason why the code is as it is. It is basically the consequence of another design decision. In OCMock you use the same kind of mock object to mock class methods and instance methods. And because it is often necessary to have two mock objects for the same class, when mocking instance methods, not allowing two mocks for the same class is just not practical.\nThe ideal solution would be to allow two mock objects to mock class methods on the same class. That's not so straight forward. Have a look at the code and see if you can think of a solution for that case.\n. Thanks for the outline of a solution. It does look like it can be made to work along these lines. That said, have you had a chance to look into this further and address the known problems? I'm asking because I have been super busy otherwise, and I'm not sure I can take this over from where it is at right now, at least not for a while.\n. In the meantime it occurred to me that it is possible to copy the stubs from the previous mock for the class to the new one. Somehow like this:\n```\n- (void)prepareClassForClassMethodMocking\n{\n    ...\n/* copy class method stubs from other mock */\nif(otherMock != nil)\n{\n    for(OCMInvocationStub *s in [otherMock stubs])\n    {\n        if([s recordedAsClassMethod])\n            [self addStub:s];\n    }\n}\n\n}\n```\nOf course, this is not entirely correct because now the lifetime of these stubs would be determined by the new mock and not the one that they were added with. However, it would solve this common problem and we're \"safe\" because the documentation simply says the effect of using two mocks to manipulate the same class is undefined. We'd just change the undefined behaviour Any opinions? Anything that I'm missing?\n. As explained above, I would also like to improve it but I don't know how. The alternatives seem worse at this stage.. How is self.delegate initialised? In which order are the tests actually executed? Is there any tear down code?\n. The only thing I can think of is that for some reason the MovePlayerObserver instance created for a test does not get deallocated at the end of the test and therefore receives further notifications later on. In this case it would not be the instance created for the second and third test (in run order) that complain, it would be the observer's delegate from the first test, which has the explicit reject, that somehow is still around and receives the notification. Could you try to explicitly unregister the observer in the tearDown method?\n. Closing due to inactivity. This doesn't seem to be an issue directly related to OCMock. Please re-open if you disagree.\n. Thanks for looking into this. I have a couple of comments regarding this pull request.\nWhile putting the @synchronised in as is may work it would be good to apply them with more precision. For example, it would seem that the @synchronised is not needed in _nextExptectedInvocation because this method is only called from handleInvocation which is already wrapped in an @synchronised. I'm also unsure about wrapping the entire body of handleInvocation: into one large block. Maybe it would be better to extract access to the arrays in question and only guard that access.\nThen there is the issue of OCMMacroState. This class is clearly not thread-safe due to the use of a global variable. I would shy away from calling OCMock thread-safe without also addressing this issue.\nAnd with something as complex as this, I really think we would need at least some test coverage.\n. Closing this as #235 looks more promising.\n. Maybe I'm missing the point, but why not just create a new mock object?\n. Please see the discussion on #103 for more detail on why overwriting stubs isn't something we're likely to see soon.\nRegarding the scenario you describe, having a setup method that creates some default stubs which are overwritten by tests, I'd say that on the one hand my goal for OCMock is to create a general tool that allows different approaches, and not \"opinionated software\" (http://stackoverflow.com/questions/802050/what-is-opinionated-software). On the other hand, though, the pattern of creating default stubs and then overwriting them doesn't sound like a particularly good idea to me.\nPersonally, and that is based on more than 10 years of experience with test-driven development and mock objects, I've moved away more and more from using setup methods at all. Saving a couple of lines in each test might look attractive at first but in the end it does create coupling between the individual tests, making the suite more brittle. In the example with the default stubs, imagine what happens when you change a default stub; you have to go through all tests to assess the impact. Also imagine someone works in another part of the system and breaks a seemingly unrelated unit test that uses this pattern; what's the cognitive overhead to understand a unit test if you have to understand that interplay between setup and individual tests. I'm clearly a DAMP not DRY guy (http://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests).\n. A common approach to avoid duplication when setting up instances with slightly different configurations is to implement the Builder pattern. I've written about an Objective-C approach here: http://erik.doernenburg.com/2011/11/builder-pattern-in-objective-c/\nRegarding the question about the hypothetical PR, I still stand by what I wrote in issue #103: \"That said, with the benefit of hindsight, having later stubs overwriting earlier ones does seem preferable. However, making this change now would be very disruptive, it would break lots of tests that people have written. For that reason I am shying away from switching the behaviour now.\"\n. Agreed. Now I need to find the time to implement it...\n. Which version of OS X are you working against? I'm asking because looking at the documentation it looks like init, which is called by new, is not an acceptable initialiser. I can only see initWithDevice:error: in the documentation and the following works for me:\nAVCaptureDevice *device = [[AVCaptureDevice devices] objectAtIndex:0];\nAVCaptureDeviceInput *deviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:device error:NULL];\nid foo = [OCMockObject partialMockForObject:deviceInput];\nNSLog(@\"%@\", foo);\nTo confirm I tried to run the following code:\nAVCaptureDeviceInput *deviceInput = [AVCaptureDeviceInput new];\nid foo = [OCMockObject partialMockForObject:deviceInput];\nThis crashes on the first line, before we go anywhere near OCMock:\n* thread #1: tid = 0x197529, 0x00007fff84feb4c6 AVFoundation`-[AVCaptureDeviceInput _setDevice:] + 38, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x8)\n  frame #0: 0x00007fff84feb4c6 AVFoundation`-[AVCaptureDeviceInput _setDevice:] + 38\n  frame #1: 0x00007fff84ffe993 AVFoundation`-[AVCaptureDeviceInput dealloc] + 31\n  frame #2: 0x00007fff8507405d AVFoundation`-[AVCaptureDeviceInput init] + 17\nCan you confirm that [AVCaptureDeviceInput new] actually creates a working instance on your system? If so, what kind of device is it?\n. This PR is still in the queue. The change itself is small, namely using the object_getClass  function rather than the class method to get the class of objects that are instances of subclasses of NSManagedObject. @carllindberg asked why this wouldn't be done for all cases, and this does sound logical. However, doing it for all cases makes a unit test break (see #163). To be honest, I don't really understand why this is the case and I haven't had a chance to look into it yet. If someone has a good explanation...\n. Okay, that clarifies a bit. I understand the need for using object_getClass to get the real class in the NSManagedClass case. In fact, I agree with Carl that from a purely theoretical point of view I don't see a reason why we should actually ever use the class method instead of object_getClass. That, however, brings us to the issue with KVO.\nObviously I agree that using object_getClass would make OCMock create its dynamic subclass as a subclass of the KVO dynamic subclass. So far so good. What I still don't understand is why this is bad. You say that \"OCMock would end up replacing the methods on the dynamic KVO subclass\". What do you mean by this? OCMock doesn't really remove functionality. \nFor example, let's take a method foo in a class Bar. When creating a partial mock for an instance of Bar, OCMock creates a dynamic subclass of Bar in which it creates a method named ocmock_replaced_foo, pointing it to the original implementation of foo. OCMock also makes foo point to the forwarder mechanism. After that, when foo is invoked, the call ends in the following code: https://github.com/erikdoe/ocmock/blob/17dd24e338a07b7a38852c1896ac902131498b1a/Source/OCMock/OCPartialMockObject.m#L203-L215\nUnless the mock is instructed (via stub/expect/reject) to do something handleInvocation: will return NO and the original implementation of foo is called. So, unless we specifically stub a KVO method, they should be called. Where's the point that breaks KVO?\n. Please see the discussion on issue #103. A bit of time has passed since, but I'm still planning to add quantifiers to OCMock. This has the advantage that it wouldn't be a breaking change and it would sidestep the thorny issue of overriding stubs.\n. Sort of. I created a proposal in #302 last year and asked for feedback. There wasn't much so this hasn't been my highest priority. Might look into it again when I have some time over the summer.. The code you have posted should work. Are you sure that there isn't an issue in the setup code you haven't posted? If you fail to set _defaults in your subject under test, then the mock isn't used, which would result in the first test passing and the second failing. Either way, it is so unlikely that this is a bug in OCMock that I'm going to close the issue. If you need help with using the test frameworks, please ask a question on StackOverflow. You might want to include more information, too, e.g. which test frameworks you use.\n. This is a know issue that's discussed in #171 and #175. Closing this one as duplicate.\n. Thanks for the suggestion. In fact, I think this should be the default. I just had to add an exception for methods with char* arguments. The issue was previously explained in OCMInvocationMatcher but I've now extracted that to a category method on NSInvocation.\n. I understand the intent and I can image situations in which this may be useful. At the same time I find this addition a little bit too arbitrary. Why provide a string description of the invocations? Why not also provide a description of the stubs? Why not a full debug description of the entire state of the mock?\n. Closing due to inactivity.\n. To be honest, I'm not sure what the point is. Why would the mock not raise an exception when it has been told that the expectation order matters?\n. Closing due to inactivity.\n. Is this an OCMock issue or a Cocoapods issue? Should this issue be closed?\n. Closed due to inactivity.\n. Unfortunately this does not work yet. Will keep this issue open as an enhancement request. \n. Please double check and re-open if it doesn't work for you.\n. Can you confirm that creating a category on NSDistributedNotificationCenter that contains the following code would work in the way you expect it? https://github.com/erikdoe/ocmock/blob/master/Source/OCMock/NSNotificationCenter%2BOCMAdditions.m#L23-27\n. Sounds interesting and I will admit that I haven't spend much time looking into iOS framework yet. So, I'd need some help with the following questions:\n- How does adding this new target affect CocoaPods? /cc @orta \n- What is the expectation for the releases? Would people expect a binary framework for iOS instead of the static lib? \n- Do you need static libs if you want to build anything that runs on iOS 7 or lower?\n. Over the past weeks I had very little time for OCMock. Will look into this, and some of the other issues, next week.\n. As you can see I (finally) merged this PR now. To be honest, I was hoping to do some more cleaning up of the targets because the project now has five targets and they aren't named in the most consistent way. Didn't find the time but I felt I should really merge this. So, here you go. I guess when I stop supporting libraries, and thus iOS7, it'll be a better time to do that anyway. \nOnce thing I noticed, though, is that when I select the OCMock iOS framework target, I cannot chose a simulator, only iOS device. When I choose the OCMockLib target I can. Is there something you or I missed?\n. Okay. I'll leave it as is then. \n. This is expected behaviour. The documentation clearly states:\n\nWhen the class is returned to its original state, its meta class will be switched back to the original meta class. This effectively removes all the stubs. However, this also makes it impossible for the mock to add new stubs or to verify interactions. You should really not use a mock after having called stopMocking. \n\nWhat you want is the same as requested in #176. Closing this as duplicate.\n. Yes, at some point I'd like to add this feature. Sending a pull request could speed this up. ;-)\nRegarding the documentation: I admit that the documentation is not as clear as it could be. The stopMocking method is only mentioned in the context of class method mocking and partial mocks. For these it does remove the stubs. For instance methods on normal mocks it doesn't do anything, which is the behaviour you have observed. That said, the method isn't mentioned in the section on stubs for these methods... Now where do I put some text into the documentation saying that stopMocking has no effect on normal method stubs? Maybe in the limitations section? \n. Merged #198.\n. Please ask this on StackOverflow. This is not an issue with OCMock.\n. To be honest, I'm not sure how I would implement it in the general case. That said, given that this is a class method in your case, does the following work for you?\nMyModality *mockModality = OCMClassMock([MyModality class]);\nOCMStub(ClassMethod([mockModality reject])).andReturn(0);\n. Okay, my bad, I misread your initial issue. For instance methods there isn't much that I can do, as you've seen. \nIn specific cases, it is possible to hide method implementation from the mock object and, thus, make them mockable. The code would be similar to the code here: https://github.com/erikdoe/ocmock/blob/master/Source/OCMock/OCPartialMockObject.m#L151-169\n. As far as I can tell this is a duplicate of #198 which I just merged. If not, please re-open.\n. Please see section 10.2 in the reference documentation: http://ocmock.org/reference/#limitations\nI think this is what you're running into. If not, please re-open the issue.\n. Closing as duplicate of #194.\n. Thanks for the compliment. Regarding the change. I wish I could just change the docs. Unfortunately, I first have to implement the feature using the new syntax, which is something I haven't gotten round to. Once I do, I will update the docs, too.\n. To be honest I had a quick look at this when you first opened the PR but I didn't understand it right away. I've now spend more time with it and it looks pretty good. I just have one question: What is the reason to use the value object as the association key? Couldn't you just use a dummy C-String as key?\n. I've merged this now, making the change with the constant for the association key and I renamed the variables a little bit to make the code slightly more understandable. Github doesn't seem to see that it's merged so closing this manually.\n. Having looked at the code I think I understand what you're doing. You basically want to tell the mock to invoke the callback that is passed as a parameter to the stubbed method. The integer argument tells the macro at which position the callback can be found.\nTo be honest, I don't do enough iOS development to judge the utility of this, but if we can make it a bit cleaner I'd include it as a feature. What's needed?\n1) I'm not sure why the main macro is called `andReturnCallback. Wouldn't it be more descriptive to call it andInvokeCompletionBlock?\n2) Wouldn't it be possible to find the argument without specifying its argument index? Are there really methods that take multiple blocks?\n3) What is the purpose of the andResolveCallback and andCompleteCallback macros? Even if the block returns a BOOL, the return value is not used. What's the harm of always declaring the return type as void in any case? (Booleans are returned in registers on all architectures, right?)\n. Thanks for the detailed comments. I really like the idea with [OCMArg invokeBlock]. That's a great solution. Will have take a stab at implementing this in the next few days.\n. Yes, that commit is a complete hack. It passes parameters according to the signature of the method that is used in the test. I only put it in to verify what the issue was, and to make the build green.\nAt a minimum it seems necessary to provide the default value for each argument of the block, nil for objects, NULL for pointers, 0 for numerical types. The resources you mention should help us, but we need to be careful deciding how \"deep\" we want to go. At some point the type system gets anything but pretty; have a look at the type management functions already in OCMock to get an idea: https://github.com/erikdoe/ocmock/blob/e50f4f9bb20de8c828271f07e2d58b2a2d3088ba/Source/OCMock/OCMFunctions.m#L36-L162\nIn your experience, is passing the default value sufficient? I see that the AFNetworking blocks do take arguments. Did you ever feel you'd like to specify what to pass to the block? As long as the arguments are objects and pointers it would be possible to specify them at setup, maybe somehow like this: [OCMArg invokeBlockWithArguments: arg1, arg2, NULL]. Is that even worth looking at at this stage? Or is this the point where you simple write a custom block and use andDo() to invoke the block with test-specific code?\n. You might want to rebase against current master. I made a few refactorings to make the new code easier to add. I've also pulled in some code to determine the block's signature.\n. First working implementation is now in released version. Closing this.\n. Thanks. I never noticed the need for the round brackets because the unit tests we used to implement this feature use the non-macro syntax. Have updated the documentation.\n. This is a known and documented limitation, please see section 10.5 here: http://ocmock.org/reference/#limitations\n. Is it at least always the same test or test class in which the crash occurs? Or is it totally random?\n. When you compile this code, do you get a warning from the compiler? I see: \nwarning: incompatible pointer to integer conversion sending 'NSValue *' to parameter of type 'BOOL' (aka 'signed char') [-Wint-conversion]\nWhen I change the code to the following, the warning disappears and the test passes on all platforms I tried:\n[[mock expect] takeBoolean:YES];\n. Assuming this can be closed now that #223 is merged.\n. Thanks for providing these updates. Currently, I'm planning to do a release of OCMock while Xcode 7 is still in beta. So, I'll \"park\" this PR until after that release.\n. Have merged this but somehow Github doesn't see it. So, closing it manually.\n. So, if the class cannot provide a method signature, it's somewhat tricky for OCMock to mock the method. What happens when you mock the valueForKey: method instead? The discussion on #68 could also be helpful.\n. I have just merged #223 which makes it possible to stub dynamic properties as if they were regular methods. Can you verify that this fixes your problem?\n. Yes, I see. The change in #223 only provides the getters while you need the setter. \n. Assuming fixed.\n. This was done in #194. Haven't made a release since. Expect one soon.\n. Can you provide a stacktrace?\n. Okay, this definitely sounds like the issue that #206 addresses. Are you seeing this problem with the recently released OCMock 3.1.3, which includes that change? If not, could you retry with that version of OCMock?\n. To be honest, I am not in favour of making this change. \nThe tests do know that it's a mock object, the variable is known to point to a mock object. If strict static typing was the goal then the type of the mock variable in the example above would have to reflect that it is both, an instance of OCProtocolMockObject (or the super class OCMockObject) and an implementation of the NSLocking protocol. Now, Objective-C can actually do this in the case of protocols, however, it is not possible to do this for class or partial mocks.\n. Okay, the failing build had nothing to do with your PR, it was a flaky test that I have since removed. Will close the PR; until Objective-C supports multiple inheritance. ;-)\n. @imhuntingwabbits Thanks. By the way, did you see #218? \n. Okay, to be honest, when I did the release pod creation failed and I haven't found time to look into it since. If anyone can help me, we can speed this up. This is what I'm seeing:\n```\n\npod spec lint\n\n-> OCMock (3.1.3)\n    - ERROR | [watchOS] Returned an unsuccessful exit code. You can use --verbose for more information.\n    - NOTE  |  [BEROR]error: There is no SDK with the name or path 'watchos'\n    - NOTE  | [watchOS]  error: There is no SDK with the name or path 'watchos'\nAnalyzed 1 podspec.\n[!] The spec did not pass validation, due to 1 error.\n```\nAny idea what I need to do to fix this?\n. Can you confirm this still occurs with OCMock 3.1.3? I'm asking because an issue that sounds very similar was addressed in #206, and that has been released only recently.\n. OCMock 3.1.3 should be in the pod repo later today; see #224/#226.\nAs far as I am aware the changes from #206 are merged into the master branch. What makes you think they aren't?\n. No worries. I should really provide a new example at some point...\n. Thanks. I've merged this PR and pushed a new podspec. Please re-open if there are any issues.\nUpdate: I had previously written that I had a problem with pod lint complaining about the license. I figured out what the problem was and will ignore it for now. It'll fix itself with the next release.\n. Observer mocks are not supported by the (now not so) new syntax with macros. The documentation deliberately shows only the selector-based syntax: http://ocmock.org/reference/#observer-mocks\nI'll leave this issue open as a reminder that I should add something for observer mocks to make them work with the new syntax.\nThe underlying issue is that the macro always creates a recorder for normal methods (https://github.com/erikdoe/ocmock/blob/e50f4f9bb20de8c828271f07e2d58b2a2d3088ba/Source/OCMock/OCMMacroState.m#L47) but the expect method on the observer mock returns a special notification recorder (https://github.com/erikdoe/ocmock/blob/e50f4f9bb20de8c828271f07e2d58b2a2d3088ba/Source/OCMock/OCObserverMockObject.m#L72-L74). \nWhen I got to the release of OCMock 3, I couldn't think of a good way to resolve this, short of merging the observer recorder functionality into the other recorder, which I didn't like. Any ideas?\n. Apologies. This was not the intention. There was an issue with publishing the pod (#224), and what you are seeing seems to be a side effect of the fix (#226). Looks like we have to solve it in a different way.\nFor the next few days I won't have access to a computer, but if anyone has an idea how to solve #224 in a better way please share it so that I can get a new release out quickly. Please DO NOT send a PR against master. That has moved on adding new features that shouldn't be in a small fix release.\n. Okay. I've just pushed OCMock 3.1.4 to the spec repo. There was a bit of guesswork involved because the documentation for CocoaPods wasn't all too clear on how to support multiple platforms (https://guides.cocoapods.org/syntax/podspec.html#platform). It should work, though. Please comment on THIS issue if it doesn't.\n. So, looking at the published pod this didn't work either. I've now tried the original workaround with a different deployment target, pushed this as OCMock 3.1.5, and I've filed an issue with CocoaPods (CocoaPods/CocoaPods#4075).\n. Can you confirm that you are using the latest version of OCMock, ie. version 3.1.5?\n. Could you do this PR against master? I'm not planning to do another release from the v3.1.x-fixes branch. Unless something dramatic happens the next release will be 3.2, from master.\n. The reason is not that the current behaviour is more logical or generally preferable. In fact, the behaviour used to be different. However, the introduction of verify-after-running in OCMock 3 required the introduction of dynamic subclassing on a larger scale and I found it impossible to untangle the setting and resetting of classes taking inheritance into account. So, I switched to the current behaviour.\n. As I wrote above, this is a complicated problem, and to be honest, I still don't know how to implement this. So, unless a pull request appears from somewhere, I wouldn't hold my breath...\n. There isn't a single commit to revert. This is the consequence of a significant change across the codebase. If you need the method stubbed in subclasses, you have to find the subclasses and stub the method in each class.\n. I understand the problem and it is important that OCMock compiles with C++ code. Before accepting this PR, though, I'd like to get a better understanding of how \n__builtin_types_compatible_p(__typeof__(aValue), id)\nand\nstrcmp(@encode(__typeof(_val)), \"@\") == 0\nbehave in non-trivial cases, e.g. blocks, classes, typedefs. When do they produce the same answer and in which cases do they produce a different answer?\nI'm asking the question because the runtime type system is complex and full of pitfalls. Just look at the code for OCMIsObjectType here: https://github.com/erikdoe/ocmock/blob/e50f4f9bb20de8c828271f07e2d58b2a2d3088ba/Source/OCMock/OCMFunctions.m#L38-L58 \nIn fact, would it make sense to use OCMIsObjectType or something similar for this? \n. Turns out that the following test fails, meaning that OCMIsObjectType is not a like for like replacement for __builtin_types_compatible_p:\nBOOL a = __builtin_types_compatible_p(id, void (^)());\nBOOL b = OCMIsObjectType(@encode(void (^)()));\nXCTAssertEqual(a, b);\nHowever, I think this is not an issue, and probably even the correct behaviour. I've tried a couple of other edge cases and everything looks good.\n. In case you are wondering, this PR is good and could be merged. However, the performance issues with iOS 9 are now confirmed (see #253), and the only workaround I can think of would impact threading. So, I think I'll postpone merging this one until we have a bit more clarity about the runtime issue.\n. It just occurred to me that there are other places in OCMock that aren't thread-safe. Consider this code from OCClassMockObject.m:\n```\n- (void)stopMocking\n{\n    if(originalMetaClass != nil)\n        [self restoreMetaClass];\n    [super stopMocking];\n}\n\n(void)restoreMetaClass\n{\n    OCMSetAssociatedMockForClass(nil, mockedClass);\n    object_setClass(mockedClass, originalMetaClass);\n    originalMetaClass = nil;\n}\n```\n\nWhen two threads hit this at the same time, it's possible that one thread sets originalMetaClass to nil when the second thread just enters restoreMetaClass. In that case object_setClass could be called with nil as the second argument, and this would be bad, right?\nJust wondering whether we really want to make OCMock completely thread safe. Or could we describe a \"level\" of thread-safety we're aiming for?\n. Just a quick heads up. I'm not ignoring this thread and I do want this functionality to end up in OCMock. Unfortunately, though, I simply haven't found the time to look into something as complex as this. I'm expecting to spend time on OCMock over the holiday season.\n. So, I finally had some time to look into this and, unfortunately, this is not a straight merge at the moment. In detail:\n1) There are a number of style issues. These are not big problems and I'm happy to fix them at a later stage myself.\n2) The use of a \"shadow\" invocation to retain the arguments. On this topic I'm with Carl and I think this should be handled inside the invocation itself. It feels like better design and I think the current code even supports this feeling. Pushing the responsibility to manage a second invocation to the outside code makes it neccessary to handle the copy in different places in different ways. The mock has to keep the copies in a map and the invocation matcher has to have a separate instance variable. In addition, looking at @benasher44's comment, it seems that using invocations this way creates a performance issue.\n3) When merging this PR into the current master a number of tests crash badly. Commenting out the newly introduced disposing of the dynamically created subclasses (#272) fixes the crashes, but of course, that means the subclasses keep lingering around, which the change was meant to fix. I wasn't able to get reasonable stack traces in Xcode but in AppCode I see traces like this one:\n* thread #1: tid = 0x294b0c, 0x00007fff8b2614dd libobjc.A.dylib`objc_msgSend + 29, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x7fb743b0790)\n    frame #0: 0x00007fff8b2614dd libobjc.A.dylib`objc_msgSend + 29\n    frame #1: 0x00007fff9b5198ad CoreFoundation`-[__NSArrayM dealloc] + 205\n    frame #2: 0x00007fff9b55cbb6 CoreFoundation`-[NSInvocation dealloc] + 118\n    frame #3: 0x00007fff8b266b3b libobjc.A.dylib`(anonymous namespace)::AutoreleasePoolPage::pop(void*) + 477\n    frame #4: 0x0000000107e315a0 XCTest`__24-[XCTestCase invokeTest]_block_invoke_2 + 167\n    frame #5: 0x0000000107e6502e XCTest`-[XCTestContext performInScope:] + 184\n    frame #6: 0x0000000107e314e8 XCTest`-[XCTestCase invokeTest] + 169\n    frame #7: 0x0000000107e31983 XCTest`-[XCTestCase performTest:] + 443\n    frame #8: 0x0000000107e2f654 XCTest`-[XCTestSuite performTest:] + 377\n    frame #9: 0x0000000107e2f654 XCTest`-[XCTestSuite performTest:] + 377\n    frame #10: 0x0000000107e2f654 XCTest`-[XCTestSuite performTest:] + 377\n    frame #11: 0x0000000107e42a1b XCTest`-[XCTestObservationCenter _observeTestExecutionForBlock:] + 611\n    frame #12: 0x0000000107e66447 XCTest`_XCTestMain + 1052\nNotice frame 2. An NSInvocation is involved. Obviously I don't have the source code for it so I have no idea what array could be causing the problem. My hope is that not using these \"shadow\" invocations, and retaining the arguments like Carl suggested could avoid this issue.\n. So, I finally, finally merged this. Many apologies. I've had a few crazy months... The changes I made on top of the PR are:\n1) Smaller stylistic changes. By the way, the idea is that the framework itself uses the OCMFunctionsPrivate header while users of the framework use OCMFunctions. The private header is not meant for private functions only. It may be a bit weird but I wasn't totally sure about the use of extern when using the functions from the same binary.\n2) Given that we decided in this thread to make OCMock only thread-safe as far as use of the mocks is concerned I have removed (hopefully all) code that dealt with making operations relation to setup and verify thread-safe. This includes, for example, the use of the thread dictionary in OCMMacroState. I know I mentioned that this wasn't thread safe earlier, but that was before the decision not to go for full thread-safety. Please tell me if you feel strongly about the try/finally in OCMock.h.\n. Not sure I understand. As far as I can tell the use of the thread dictionary makes the actual use of the macro thread-safe, it ensures that when two threads in parallel use the stub/expect/verify macros, the macros still work. If we use these macros only from one thread, then there should be no problem, not?\n. Hmm. Let's assume we do this:\nOCMStub([someMock foo]);\nOCMStub([someMock bar]);\nThese two calls should result in two invocations of forwardingTargetForSelector:, one for the foo method and another for the bar method. The implementation of forwardingTargetForSelector: needs to check whether it's invoked as a real stub (use of the mock) or whether it's during setup. For that it checks the global state. If there is global state then it's a setup, otherwise the stub needs to be used.\n. Okay, thinking about it again, do you have the following scenario in mind?\nOCMStub([someMock foo]);\n[anotherObject doStuff];\nOCMStub([someMock bar]);\nIf doStuff triggers another thread and that thread then uses someMock while we're trying to set up the stub for bar, then I could see how that thread, if it's unlucky, would see the global state and erroneously assume it's in setup mode.\nIf that's the case then the other @synchronised I removed in the addStub: method etc. would also be needed, right?\nCould you test whether the version as is does work in your scenarios? I'm asking because the code for OCMock is quite complex already and I only want to add stuff that's absolutely necessary to implement the features. I'm not asking for a unit test. Just a quick heads up whether current master would work for you.\n. Yes, #234 forces OCMFunctions.h to be public, which I don't like, because now these functions, which are doing some really low level stuff, show up in the autocompletion when you use OCMock. Also, the file needs to be added to the podspec. Let me think about how to resolve it. I'll merge this PR when I have an idea, hopefully in the next few days.\n. Thanks. I'll look into getting this merged. However, the following would make my life easier, and get this merged more quickly:\n- Respecting the coding style (placement of curly brackets, naming of instance variable). I know some people disagree with the style used in OCMock. In fact, I might do it differently today. However, the code base is what it is after 10+ years and I'd rather have it consistent.\n- Separate PR for the changes to the example project.\n. So, I've looked into some of the implementation and I must say I don't understand how testInvokesBlockWithAllDefaultArgs passes. As far as I can see calling [OCMArg invokeBlock] leaves the _params array in the caller unset, ie. nil. In buildInvocationFromBlock: there's a test in line 48-50, which tests for this condition and if _params are nil it simply leaves the invocation as is, ie. without setting any paramters. Is this okay? Does NSInvocation create default arguments reliably?\n. Thank you! This was super helpful.\nI believe there may be one small issue left. In buildInvocationFromBlock:, in the case for number types, the code now looks like this: (I inlined the setArgument: call because the variable allocated in the scope of the if statement disappears at the end of the scope, making a pointer to it unreliable.)\nelse if(OCMNumberTypeForObjCType(typeEncoding))\n{\n    NSUInteger zero = 0;\n    [inv setArgument:&zero atIndex:j];\n}\nWhat happens when the size of the argument is larger than sizeof(NSUInteger)?\n. Interesting idea. I think we can \"cheat\" a little bit, though. For all the numerical types the default value is 0 and that value is, as far as I know, always represented by a sequence of zero bytes. So we could just create a zero'd out buffer of the correct size.\n```\nNSUInteger charSize;\nNSGetSizeAndAlignment(@encode(char), NULL, &charSize);\nint charPtr = calloc(1, charSize);\nint charVal = charPtr;\nXCTAssertEqual(charVal, 0, @\"Should have nulled value.\");\nNSUInteger intSize;\nNSGetSizeAndAlignment(@encode(int), NULL, &intSize);\nint intPtr = calloc(1, intSize);\nint intVal = intPtr;\nXCTAssertEqual(intVal, 0, @\"Should have nulled value.\");\nNSUInteger doubleSize;\nNSGetSizeAndAlignment(@encode(double), NULL, &doubleSize);\nfloat doublePtr = calloc(1, doubleSize);\nint doubleVal = doublePtr;\nXCTAssertEqual(doubleVal, 0.0, @\"Should have nulled value.\");\n```\nI'll put that into the code, assuming this is an improvement of the current code, and will cover all numerical types.\n. As far as I can tell this won't be an issue for number types. In a3e15808dbeeb7223e1ad39bb55f8a2ae60230c5 I have made the changes exactly as you suggested. I've also moved the code out of the loop into its own method.\n. Merged #239 now and refactored to using macro as suggested here.\n. To clarify: The exception handling works as expected. In that forwardInvocation: implementation the mock does catch and remember the exception bit it also still raises it. The test you have catches the exception. When you later call verify the mock raises the exception again. \nThis is done because under certain circumstances (methods called via notifications) fail fast doesn't work immediately because the exception gets swallowed. For such cases the mock raises all fail fast exceptions again in verify. \nThe documentation explains this in http://ocmock.org/reference/#advanced-topics (Re-throwing fail fast exceptions in verify all), too.\nI agree, though, that the error message should be better. Not sure about that architectural issue and the recorders. Could you elaborate?\n. I see and agree. The following test should not pass, but it does.\n```\n- (void)testReRaisesStubbedExceptions\n{\n    [[[mock expect] andThrow:[NSException exceptionWithName:@\"ExceptionForTest\" reason:@\"test\" userInfo:nil]] lowercaseString];\n    @try\n    {\n        [mock lowercaseString];\n    }\n    @catch(NSException *exception)\n    {\n        // expected\n    }\n    XCTAssertThrows([mock verify], @\"Oops! Re-raises stubbed exception, too!\");\n}\n``\n. Went for your option 1. I'm a little bit suspicious wrapping the test-provided exception but I do think that it will always go through the try/catch block where it is unwrapped. Fingers crossed.\n. For partial mocks it should work, too. Since OCMock 3 all methods are aliased and routed through the mock, mostly to make verify-after-running possible. So even methods that have no stubs go through the mock code and thatforwardInvocation:part.\n. To be honest, I'm not sure I understand the issue. To me it seems you are saying that the memory location (address) ofresignTapRecognizerintestAnythingends up being the same asrecogniserMockintestControllerAddResignTapRecognizerOnViewDidAppear. Why is this a problem? \n. As Carl mentions, and supported by the fact the callingstopMocking` helps, the mock seems to linger around, leaving the class method stubs active. I'm wondering whether there's a retain cycle in there somewhere because the object that the partial mock is created over is used in a stub. This needs investigation.\nDespite trying I have not managed to recreate that pointer equality. The surprising thing (for me) is that the address of the mock object in the first test is the same as the address of the actual instance in the second.\nIf we assume the mock stays around the two stubs remain active. In testAnything, when you call alloc the first stub responds and returns the partial mock from the previous test. However, when you then call initWithTarget:action: on that partial mock, the arguments are passed are different, which means that the second stub does not respond. So the original implementation of initWithTarget:action: in the recognizer from the first test is invoked. I have no idea how that would return the mock without knowing the implementation of that init method.\nOne thing you could try is changing this line in the first test\nOCMStub([recognizerMock initWithTarget:self.controller\n                                action:@selector(recognizeTap:)]).andReturn(recognizer);\nto\nOCMStub([recognizerMock initWithTarget:[OCMArg any]\n                                action:@selector(recognizeTap:)]).andReturn(recognizer);\nDo you still see the pointer equality when you don't add stopMocking?\n. Closing due to inactivity.\n. The invocation happens in line 435 of the test. Which line is that in above code snippet?\nAlso, which version of OCMock is this written against? For me the line numbers inside OCMock don't match up and I (given the stack frames provided) I can't see a code path to that place that explicitly tells the invocation to retain its arguments. Master also doesn't have any @synchronised yet. Could you retry this against master?\n. So, it seems that the lines telling the invocation to retain its arguments were added in #235, which has not been merged into master yet. I've left a question over there.\n. Have added the proposed fix. @carllindberg, would you mind doing quick sanity check?\n. Thanks for double-checking.\n. Thanks for this! The reason why I resorted to direct isa pointer manipulation was that I couldn't get this to work with object_setClass() when I implemented it last year. I can't remember the sequence right now, but believe the dummy initialiser method was added later, and I don't think I tried the calls in the order you have them now.\nI'll try to merge a couple of other open pull requests first and will then merge this one; just in case we have to roll this back because it has unexpected consequences.\n. Fixed. See eb1916f719bc39b184624e75dd119691c025b406.\n. This does really seem to be caused by a change in the new iOS runtime. I've created two very similar projects, one for iOS and one for OS X, that demonstrate that the OS X version is still fast: https://github.com/erikdoe/ocmock-profiling\nIt might be possible to create a workaround, maybe caching the dynamic subclasses, but I'm hoping that the issue will get fixed in the runtime. The engineering team at Apple is already aware of the problem: https://twitter.com/joar_at_work/status/649330511177912320 \n. To be honest, I was hoping that this might get fixed in the runtime. With iOS 9.2 the profile looks a bit different, which makes me think that some work is being done. Unfortunately, the slowness is still there. Maybe this is the time to consider work-arounds.\n. I would very much prefer a PR that implements the workaround I suggested above.\n. @JKuzimski Yes, when running the profiling projects I see performance of the iOS version is now very similar to the OS X version. So, I'm going to close this as resolved.\n. I'm at a bit of a loss myself. Just to make sure this is not a change in the runtime / compiler: can you confirm that OCMock 2.2.4 built with the current SDK does not exhibit the issue?\n. You can validate the arguments as described in the documentation: http://ocmock.org/reference/#argument-constraints\nAs mentioned in the contribution notes, please ask question related to the usage of OCMock on Stackoverflow. \n. @nlutsenko Correct, I'm not looking into this right now, mostly because I just can't find the time.\n. Closing as the PR is merged now. I'm planning to do a release shortly.\n. Not sure what the feature request is. If you want to test the implementation of actionForControlEvent: you don't need a mock at all. Just call the method in your test and make an assertion with your test framework that the returned value is the one you're expecting.\nIf another class is using actionForControlEvent: then you can stub the method to return the selector value you want.\nWhat am I missing?\n. Finally got round to looking into this. It is possible to create an expectation from a selector. To do so you'd have to follow these steps:\n- create an NSInvocation from the selector\n- create an OCMInvocationExpectation and call -setInvocation:\n- optionally call -setRecordedAsClassMethod: and -addInvocationAction:\n- add the expectation to the mock by calling -addStub: and -addExpectation:, both with the expectation isntance as an argument\nUnfortunately, this requires several methods that are not in OCMock's public headers.\n. This could be added to OCMock, maybe by adding a new method to OCClassMockObject such as expectSelector:withArguments:. Then we could define a macro on top of it, maybe something like \nOCMExpect(mockObject, selector, arg, ...)\nI'll leave this issue open as a feature request.\n. This seems irrelevant at this stage. Please let me know if you don't think so. Otherwise I'm going to close this in a few days.. Not sure about this one. If I understand this right, the issue occurs only when using CocoaPods, and it's caused by something Apple changed in Xcode. Is there a middle ground where we only disable debug symbols in some configurations? And what does the setting actually do? Does it really disable all symbols when debugging OCMock?\n. I see. Will look into this, and figure out how big the impact is for anyone who's working on the development of OCMock. I do understand that it's quite annoying for everyone who's using OCMock.\n. Can anyone comfirm that this has been fixed with newer versions of Xcode?. I agree that option 1 is less appealing. In option 2 couldn't we just return nil instead of the notification created inside the recorder? There's really no need to expose that, right?\n. If I understand you correctly, you want to verify that the method is called with YES as the argument. This would be done as follows:\nOCMVerify([mockPopoverVC setDefaultImage:YES]);\nThe setTo: methods are used for pass-by-reference arguments like the NSError** arguments. \n. This script is used to make the public releases for OCMock and I do want the predictability in there, knowing which SDK this release was built for. Maybe I should remove the note on the website suggesting to use this script for other purposes.\n. Yes, that's really odd. I'm pretty sure that the last release was built with a newer SDK. I did this from another machine so I can't check at the moment whether I forgot to commit that change after building. It's a mistake in either case, though, because the tag in Github should show exactly what was done.\n. I hear what you say and I agree that this would be a nice feature. Unfortunately, I have no idea how to implement it. At the moment OCMVerify is a macro that just wraps the expression passed to it with a couple of other calls; see: https://github.com/erikdoe/ocmock/blob/ff961bd19e835d1b867deda8adaa421341027f46/Source/OCMock/OCMock.h#L70-L77\nTo do what you suggest the code in the macro would have to get to the object reference somehow, e.g. the argument passed to the macro is [someObject doStuff] and the code needs to invoke a function with someObject as the argument so that that function could check whether someObject is a mock or not. Is this even possible with C macros?\n. Maybe I misunderstand this issue. As far as I can tell, the suggestion was to handle a case like this:\nNSString *actualString = @\"foo\";\nNSString *mockString = OCMClassMock([NSString class]);\nOCMVerify([actualString lowercaseString);\nSo, by mistake we use a real object in the verify, not the mock. In that case there's no code from an OCMock class in the execution path. The OCMVerify macro gets expanded and [actualString lowercaseString] is evaluated. The only way to get code from OCMock involved is in the macro.\n. Agreed. The classes should be disposed. Let's continue the discussion on #272.\n. Agree with disposing the subclasses. However, why do we need to record them in instance variables? For both cases it should be possible to get a reference to the class in the stopMocking implementations.\nI must admit that I was also confused by the naming. Why add a Name suffix to a variable that reference a class itself, and not the name of a class? \n. No worries. Thank you for the PR and clever idea to find the dynamically created subclass via the name. Took me a bit to understand. Have added unit test and merged the PR.\n. I haven't seen it personally and I have not heard other reports. Have you been able to resolve the issue by now?\n. Closing due to inactivity.\n. Another slightly more correct quick fix would be to replace the strcmp call with a call to OCMIsObjectType.\nThat said, as you already point out, there's another issue with the logic in the matchesInvocation: method that affects all invocation actions, currently blocks and pass-by-ref setters. If an invocation doesn't match but the non-matching argument follows an action then the action is carried out anyway. I'll open a separate issue for that.\n. The change is small and local enough that I think we can do without a test.\n. I like this. And thank you for also updating the documention. That said, I'm going to park this one for a short while until we've sorted out #235 because that's been in the queue for a long time and I am pretty certain that there will be conflicts between #235 and this one.\n. You saw that the build on the CI server failed? https://travis-ci.org/erikdoe/ocmock/builds/108548460\n. Can you describe the use case for this? Why would you want to invoke the block asynchronously? As far as I can tell when there's a need to invoke the block it is because the block does something that the test depends on it. If the test depends on the block being invoked, and it's invoked asynchronously, then the test would have to wait for the block to have been called, right?\n. Sorry, I understand that this must make sense for you but I don't think that the use case is broad enough to include it in OCMock.. Let's see what happens with #285. If we end up using a cache in all cases, then this problem would disappear, because we'd never dispose the subclasses.\n. With iOS 9.3 the slowness problems reported in #253 have disappeared. Therefore, the workaround for these issues proposed in #285 isn't necessary anymore. That in turn means that we should look at this issue again, even though it seems mostly cosmetic. \nCould you provide more details, or maybe even a self-contained example that shows the behaviour you are describing. Personally, I have not seen it. Are you using other libraries/frameworks that may impact retention of objects?\n. Thanks for looking into this. I get the idea of the implementation. Nice spot, by the way, that the random number is not needed in the class name any more; that is as long as we use the cache.\nThat said, this is a huge PR and making the subclass behaviour configurable is responsible for most of the actual changes. Is there a specific reason why we'd want this to be configurable on a per-mock level? Wouldn't it be more reasonable to always use the cache? In that case, I suppose, the change would be pretty small.\n. Forgot to close this when the underlying problem was fixed by Apple and #253 was closed.. It should also be called on stubs. Could you provide a failing test that shows when the block is not called?\n. Please ask questions about the use of OCMock on StackOverflow: http://stackoverflow.com/questions/tagged/ocmock You might also want to include more information about what exactly you're trying to achieve. Code always helps.\nIf you suspect you've found a bug, please include code that demonstrates the issue.\n. Interesting. I wonder why this works now. Did OCHamcrest change so that Objective-C++ is no longer needed?\n. Given that this problem occurs with other frameworks, too, wouldn't it be more likely be an issue with Cocoapods? I also note that you are using a beta version of Cocoapods.\nIn either case, I looked at the demo project. It seems like Cocoapods tries to use a dynamic framework for OCMock (and not an older-style static library). The binary that contains the tests is located in\nDebug-iphoneos/LibraryNotFoundDemo.app/PlugIns/LibraryNotFoundDemoTests.xctest/LibraryNotFoundDemoTests\nand the OCMock binary ends up in\nDebug-iphoneos/OCMock/OCMock.framework/OCMock\nTo be honest, I don't know why Cocoapods puts the OCMock framework into this location, but given that OCMock is built as a a run-path dependent library (see https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html) it is definitely possible for this work. If Cocoapods sets up a runpath, e.g. @loader_path/../../../OCMock in this case, then it would be possible to find the binary. Obviosuly, this is not the case, but I'm not enough of a Cocoapods expert to debug it.\nI'll leave this issue open for a while, in the hope that someone with more Cocoapods experience has a suggestions. It is definitely not a bug in OCMock, though.\n. Could you provide a failing test? Or does this only occur in a complex scenario?\n. Okay, this is an unintended and unexpected consequence of #235. In order to make OCMock somewhat thread-safe it was necessary to retain invocation arguments. The arguments that need to be retained are kept in an array. So, when the array class itself is mocked, any method send to the class goes through the new code that retains the arguments. That code tries to create an array to retain the arguments, which of course causes a class method on array to be invoked, which then goes to the retain arguments code... and we have an endless loop.\nThe only way out I can see is to stop OCMock from even trying to intercept class methods on NSArray, much like it aready does for NSString (see section 10.5 in the documentation). I've just pushed a workaround. Will wait for a few days if other issues come to light, and then release 3.3.1.\n. Fixed and released by now.\n. This seems to have been superseded by #309. That does have some issues, but this PR also seems to be incomplete at this stage. So, I'm going to close it assuming that we'll get #309 working.. Only now found time to look at this. Sorry.\nI like the idea. However, I don't understand why an object is passed to andCallBlock. In the andCall case we must pass an object so that the mock has an instance to invoke the selector. But blocks can be invoked directly. \nIn fact, in the example above, the self argument to the block would be the instance of the test case, which seems a bit strange.\nSo, what I'm proposing is to change the implementation to allow for the following:\n    [[[mock stub] andCallBlock:theBlock] stringByAppendingString:[OCMArg any]];\n\nAs a super special extra bonus one could, for partial mocks only, make the instance of the partial mock available as self to the block. I'd suggest to do that in a separate PR, though.\n. Haven\u2019t had a chance to look into it yet. I spent the time I had for OCMock on preparing #302. \n. Merged this now. (I did change the test so that it fails when the new logic does't work.) Regarding your other test mentioned in the comment: this is a common misunderstanding; reject has nothing to do with verify. Interestingly, the changes proposed in #302 are hopefully going to make things clearer.\n. So, what happens when you write it as follows?\nid mock = OCMPartialMock([MyClass sharedInstance]);\nOCMStub([mock myProperty]).andReturn(@1234);\nIf this also fails, then you'll have to provide the implementation of myProperty, and whatever is called from it. Otherwise it's impossible to see how the recorder gets called twice.\n. It could be. Without a failing example (in code), or at least some code and more information I can only guess, which I don't like doing. ;-)\n. Closing this due to inactivity.. The use of any is not possible. Please see section 4.1 and 4.2 in the documentation for details and a possible workaround: http://ocmock.org/reference/#argument-constraints\n. Please ask questions about the use of OCMock on Stackoverflow using the ocmock tag.\n. Thank you for the link. I had seen that the pre-processor itself can do variadic macros but I don't see a way how to use those for our purposes. The trick described in the answer you linked to may work. I just need to check how often the arguments to the top-level macro are evaluated.\nPutting the quantifier second makes sense in case of variadic macros. For the statement-based approach it's not possible.\nOnce it's clear what path to take, I'd add more quantifiers, including the \"exact\" one you mentioned. I've only used a few so far to show how it would look.\n. Apologies, I could have sworn that I had replied to this issue. That said, you are correct that OCMVerify verifies the invocation of bar on foo. There's only so much you can do with macros and runtime trickery. As soon as code is executed inside the OCMVerify macro, OCMock has to assume you want to verify those invocations. How else would it know not to verify the first invocation (of bar) but to verify the second one (of baz)? Even a convention that would say that only the last invocation is meant to be verified seems impossible to implement, because how would OCMock know at the point when bar is invoked that there will be another invocation in the future?\n. To be honest, I'm am not convinced by the use case and I am worried about many subtle edge cases. So, I'm afraid, I'm not going to merge this one.. Yes, mock objects will retain the arguments of invocations. They have to, because otherwise the arguments won't be around for later verification with OCMVerify. For details see: https://github.com/erikdoe/ocmock/blob/1f0f56c91a3e20917efbbb81c91be22f5b0f43a5/Source/OCMock/OCMockObject.m#L323-L331\n. As you write, there are just too many cases where there is no guarantee that somebody else will retain the arguments. So, OCMock has to do it. \nThat said, there shouldn't be memory leaks. When the mock object itself is released then the arguments of recorded invocations should be released, too. Is this not happening in your case? I'm asking because that is something that should happen but was/is hard to achieve; witness the complicated retainObjectArgumentsExcludingObject: method called from the code  I referred to above.\n. I believe you, but the code sampe doesn't show where a cycle is created. It's not possible to see what A is doing with the instance of B / the mock. And it's not clear how the instance of A winds up as an argument to the mock. \nUPDATE: Sorry, I should probably look at the test project you referred to. ;-)\n. @fareal Regarding your first comment, yes, of course, a mock object can receive an invocation in which it is the target or an argument, hence the special retain... method. If you add another object into the mix it is possible to create retain cycles. I'm not sure there's anything that can be done about it.\nRegarding your last comment, I'm not sure what you are proposing. Can you clarify?. The documentation has the hint. In section 2.6 it is stated that \"Using invokeBlockWithArgs: it is possible to specify which arguments to invoke the block with; non-object arguments must be wrapped in value objects and the expression must be wrapped in round brackets.\" The code example in that section shows the round brackets, too.\n. I like the general idea. And thank you for putting the effort into including unit tests. That said, the way the change is written now it is way too invasive. My main concern is that existing init methods were changed, which results in a large number of changes. I've commented on some of them. Was there a reason why you didn't keep the old methods (without protocols / with single protocol) and have them forward to the new ones (with protocol / with multiple protocols)?. My main issue is compatibility. If this was application code, owned by a single team, I would also make the changes as you suggested. However, OCMock is a framework that is used by lots of different people. In that case, I believe keeping the API backwards compatible is the more important concern.. Can you post a full stack trace and a self-contained test that has this problem? I need to get as much detail as possible because I don't have access to the required hardware.\n. I'm not sure I understand. Can you please provide the code you use to set up your own swizzling and the implementation of the method that does the logging? Also, you write \"Is there any way by which we could prevent OCMock from stubbing certain objects such as sendEvent:?\". But sendEvent is a method not an object...\n. Please see section 10.4 in the documentation. Certain core runtime methods can't be mocked. respondsToSelector: is one of them even though it's not explicitly listed.\n. No worries. It's easy to overlook. I've tried to clarify the documentation now.\n. Should be fixed now.. This doesn't look like a problem with OCMock. Please check how you link all your other code with your tests.\n. Like I said, from the information you provided, there is no reason to believe this has anything to do with OCMock. Regarding issues, please review the contribution guidelines: https://github.com/erikdoe/ocmock/blob/master/CONTRIBUTING.md\n. It feels like there are a lot of moving parts and I'm not sure I fully understand yet what you're doing. \nIt's clear that you are using the Nimble framework. From looking at its page on Github it looks like it's written in Swift but can be used from Objective-C, right? Based on the code snippet in your second comment I assume your tests are written in Objective-C, right?\nNow, it sounds like you've updated the version of Nimble and kept the same version of OCMock. After the update of Nimble, some of your tests are breaking with this error you mention. If I understand you correctly the error occurs in the function you included in the issue. Where exactly? What are the arguments?\nCould you provide a small self-contained tests that always fails?\n. Closing due to inactivity. Hopefully this has been fixed by the Nimble team. @modocache?. This seems like you are continuing the issue from #318. Please respect the contribution guidelines I linked to in that issue. Nothing you have written indicates that your problem has anything to do with the OCMock framework.\n. OCMock can definitely stub methods that return structs. However, there seems to have been a change in the runtime that confuses OCMock's matching code. The code to match struct names is already quite involved (see OCMEqualTypesAllowingOpaqueStructs() in OCMFunctions.m), but it looks like we need to add even more special cases here. /cc @carllindberg\nIt would help me if you could provide a failing test.\n. Thanks for the comments and additional information. I've just pushed a change that should fix the issue. Can you confirm it works for you?. Can you provide more information? Are you using the released binary distributions or are you building OCMock yourself? Does this only happen with partial mocks and not with regular mocks? Could you provide a failing test case and a stack trace?. Will close this issue as the PR has been merged.. The only thing I can think of is the definition of equality. You write that \"the object is the same in both points\". How do you determine that they are the same? And is that the same way that OCMock determines whether two objects are the same? The code for the latter is here: https://github.com/erikdoe/ocmock/blob/a60730142ea67229ac08e96fb8005f7eb3600760/Source/OCMock/OCMInvocationMatcher.m#L102-L142\nIt's likely (but you should double-check) that in your case the code in line 139 is excuted. It would call the isEqual: method of the device object passed when the code is run, and use the device object passed in the verify, as an argument to the isEqual: method. Can you emulate that and see what happens?. In general, please ask questions related to the usage of OCMock on StackOverflow using the ocmock tag. \nIn particular, there is not enough information to diagnose the issue. Where does the test fail? What is the error message? How is  thecontroller instance variable initialised? How would that controller even know about the mock controller to call a message on it?. Sorry. I should have responded earlier. My concern is that the failing test provided in the issue tests a scenario that, as far as I can tell, cannot be supported by OCMock. It has always been clear that OCMock is only thread-safe to a certain degree. Repeatedly calling a method while setting up and removing a mock would, as far as I am aware, require most of the operations on the class to be atomic, and I don't see a way how to achieve this.\nThe fix provided by @kballard looks benign, but it doesn't fix the issue reported. In fact, there is no test that I can think of that would fail without the change but pass with it. That said, the change is small and it feels like it brings the two operations into a \"more correct\" sequence. So I have accepted it now.\n. I have no idea. Did this work with previous versions of OCMock? Does your setup work with the old-style imports?. Assuming this is still an issue, could you provide that Xcode project that reproduces the problem?. While I'm trying not to make OCMock too much of an opinionated framework, this change, in my humble opinion, seems to go too far. Could you spend a couple of sentences explaining the use case for this change?. Closed due to inactivity.. Sorry for the long wait, this area of the codebase is really tricky and I didn't find the time to delve into it. That said, I have just merged #343. Does this help in your case?. Fixed in OCMock 3.4.1.. Thank you. I am aware of the problem. Haven't had a chance to look into it in detail. Please do not add more \"me too\" comments.. So, I have looked into this but haven't really understood why this happens with the updated runtime in iOS 11. \nThat said, I did find a workaround. A way to stop the crashes is to avoid installing the method hooks on class methods of NSManagedObject. This means, though, that verification of these methods becomes impossible.  For those of you who use OCMock with NSManagedObject, is this reasonable?\nIn any case, in a moment I will push a commit that implements this workaround. Please let me know what you think of it.. Can you please confirm whether this fix works for you? If it does it'd do a small release.. @murthyveda2000 When you say you're still getting a crash, do you mean the code sample from the opening post crashes? Or do you have a different test that crashes? If so, could you provide more detail?. In the meantime I released OCMock 3.4.1 which contains the workaround.. @Applitom Thanks for looking into it. Do you have a test case that fails without your change but passes with it? I'm asking because as far as I can tell, your change only affects class methods added by subclasses of NSManagedObject. \nIt might not be totally obvious but the change I made does already affect subclasses of NSManagedObjects. This is because enumerateMethodsInClass:usingBlock: walks up the superclass chain, and the cls argument passed to the block is the class in the hierarchy that actually implements the method.\nExample: assume you have a class Foo that has a class method bar. The block will be called with class Foo and method bar and in that case your change prevents a forwarder to be implemented. As far as class methods implemented by NSManagedObject go, the block will be called with NSManagedObject (and not the subclass that is being mocked), and therefore those class methods will be skipped even without your change.. @murthyveda2000, @FlorianMielke, @givip, do all of you encounter the crash only when you try to use a partial mock with a managed object?. @rt-bink Thanks for providing another data point. I think, at this stage, it's pretty clear that the change included in OCMock 3.4.1 fixes most of the crashes with NSManagedObject that were caused by the changes in the new runtime, leaving the crash with partial mocks for NSManagedObject the only open part of this issue.\nTo be honest, at the moment I don't know how to change OCMock so that it can still create partial mocks for NSManagedObject with Apple's changes in the new runtime. Not saying it won't happen, but it will probably take some time. If you have any ideas please post them here.. As I wrote in my comment on 11 Nov, I don't understand what the proposed change does. The fix I added should cover subclasses. As I wrote back then: Do you have a test case that fails without your change but passes with it? Did I miss a comment somewhere?. I hear what you say. Would it be possible, though, please, to provide a unit test that fails without that change and passes with that change? I would really like to understand the problem. . Thank you for providing the example; very helpful. I now had time and a machine with Xcode 9.3 (don't ask) to look into this. Finally, it's clear to me what the underlying problem is. \nThe change I just made fixes the problem and it should have less of a performance impact than the original proposal. A known downside of the way I addressed it is that you cannot stub/mock class methods on NSObject for subclasses of NSManagedObject.\nCould you let me know whether that works for you?. Thanks for confirming. I'll get a release out when I have a moment, hopefully on Monday.. Release is out on Github, Carthage, and Cocoapods. Website will be a bit delayed.. Yes, if you have any comments, please add them to #302. I couldn't make up my mind and there was very little feedback so I still haven't merged it. Maybe I should add a note to the ocmock.org site... In any case, I'm closing this as a duplicate.. Yeah, I had noticed that, too. And I'm glad that you've provided a fix. It would have taken me a while to get into this. Thanks.\n. Thanks! Have merged the PR now.. Thanks! Have merged the PR now.. I think I understand what is going on, but I don't know what to do. On the one hand there are good reasons to retain the arguments. On the other hand it can, under the conditions you describe, cause a crash. \nThat said, the case you describe is a real edge case that, arguably, violates an implicit contract in Objective-C. It is normally a fair assumption for a method that it can retain an object argument it receives, but here you're basically creating a situation where that is not true and the receiver is not allowed to hold onto an argument it receives. Somehow the receiver must know that, unlike all \"normal\" object arguments, it must not hold onto (retain) that argument. \nWhen this tacit \"side-contract\" is coded into a class, as it is in your example and as it seems with UIView, then it's not a problem, because the class doesn't do what it shouldn't do. However, that special contract is not explicit and OCMock can't know about it.\nInterestingly, #347 is also about a problem with mocks retaining arguments of invocations. Maybe we really need some extra API on OCMock to deal with these edge cases, allowing the test case more control over how a mock manages invocations. I'm not sure exactly how such an API would look like. Ideas?\n. I'm super busy at work right now. Will look into #347 in a couple of weeks, hopefully adding the feature. If you have any specific suggestions on the API, please leave a comment in #347.. I understand the issue. However, this seems to be quite a niche use case and, at the same time, this would make some already complex logic inside OCMock even more complex and it would require changes to the API. \nFor your cases could you not just send a release to the objects in question from your test code? I know it feels \"asymmetric\" but it's also pragmatic.. Assuming that I merge #360, would that work for you, too?. To be honest, from the information you provided I can't diagnose the issue. That said, the OCMock releases contain a static library. Is there any reason why you can't use that?. I had planned to wait for the outcome of #339 to include in the next minor release. It's been taken a while, I know.. Could you check whether the fix I just committed works for you? The new tests introduced in this PR still pass, but the class pair is disposed a little later; not when the second mock takes over but when stopMocking is called on the first mock.. Did you see that making the suggested changes makes the build fail? According to the Travis CI log \"clang: error: -fobjc-weak is not supported on the current deployment target\".. Thanks to this I realised that the Travis build was still using Xcode 7... I've updated this now and will recheck your PR once that change is through.. I have updated master so that I build with Xcode 9.3 on Travis CI. Can you update your PR and try again? The Travis build (in case Github doesn't show you the info) is here: https://travis-ci.org/erikdoe/ocmock/pull_requests. Either way, really. If this PR is modified so that the changes do not break the build on the CI server I'll merge it. Alternatively, if another PR is opened that upates the Xcode version without breaking the CI server, I'll merge that.. As far as I can tell this PR based on the proposal you made in November. At the time I had posted a comment explaining that I don't understand this change. As far as I read it the change you propose would only affect class methods on subclasses of NSManagedObject. The fix I added a should already cover handling of subclasses of NSManagedObject, just not class methods on those. That's the theory. Hence I had asked whether you could add a test case that fails without your change but passes with it. Or am I missing something?. I've added a slightly different fix for this. Please see #339. It would be great of you could confirm that my fix works for you in the thread over there.. At a minimum I'd need a unit test to show and test this new feature. I'm not promising that I'll definitely merge it then, but it will help me make that decision.. Closing due to inactivity.. Thanks for confirming and isolating the change. I will look into this as soon as I can, hopefully early next week.. As a progress report: I can reproduce the problem, and I understand what's going on, but it's not clear to me how to resolve it.\nFirst off, though, I noticed that you are looking at the return values from the mock, not the real object. That's a use case I'm not sure I understand. The idea is to use the mock only to control (set up expectations, verify, etc.) and use the real object for everything else.\nTo verify, I added the following test to OCMock's test suite. (The foo method on the test class is hardcoded to return the String @\"Foo\".) Note that assertion 1 passes, only 3 fails.\n```\n- (void)testSettingUpSecondPartialMockForSameClassDoesNotAffectInstanceMethods\n{\n    TestClassWithSimpleMethod object1 = [[TestClassWithSimpleMethod alloc] init];\n    TestClassWithSimpleMethod object2 = [[TestClassWithSimpleMethod alloc] init];\nTestClassWithSimpleMethod *mock1 = OCMPartialMock(object1);\nXCTAssertEqualObjects(@\"Foo\", [object1 foo]);\n\nTestClassWithSimpleMethod *mock2 = OCMPartialMock(object2);\nXCTAssertEqualObjects(@\"Foo\", [object1 foo]);   // 1) passes\nXCTAssertEqualObjects(@\"Foo\", [object2 foo]);   // 2) passes\n\nXCTAssertEqualObjects(@\"Foo\", [mock1 foo]);     // 3) FAILS (value is NULL)\nXCTAssertEqualObjects(@\"Foo\", [mock2 foo]);     // 4) passes\n\n}\n```\nSo, if I were to convince you all to only use the real object, not the mock, everything would be allright? Unfortunately not. Have a look at this test:\n```\n- (void)testSettingUpSecondPartialMockForSameClassDoesNotAffectStubs\n{\n    TestClassWithSimpleMethod object1 = [[TestClassWithSimpleMethod alloc] init];\n    TestClassWithSimpleMethod object2 = [[TestClassWithSimpleMethod alloc] init];\nTestClassWithSimpleMethod *mock1 = OCMPartialMock(object1);\nXCTAssertEqualObjects(@\"Foo\", [object1 foo]);\nOCMStub([mock1 foo]).andReturn(@\"Bar\");\nXCTAssertEqualObjects(@\"Bar\", [object1 foo]);\n\nTestClassWithSimpleMethod *mock2 = OCMPartialMock(object2);\nXCTAssertEqualObjects(@\"Bar\", [object1 foo]);   // 5) FAILS (value is Foo)\nXCTAssertEqualObjects(@\"Foo\", [object2 foo]);   // 6) passes\n\nXCTAssertEqualObjects(@\"Bar\", [mock1 foo]);     // 7) passes\nXCTAssertEqualObjects(@\"Foo\", [mock2 foo]);     // 8) passes\n\n}\n```\nIt feels like assertion 5 is the real issue here. I'm open to be convinced that assertion 3 is also a problem, even though I almost expect that fixing 5 will also fix 3.\n. Apologies for the delay; this was a tough one. I had been going around in circles trying to dispose the subclass created for mocking class methods at the point when another mock \"takes over\" mocking class methods. This is problematic because partial mocks create another subclass that depends on the subclass generated for class method mocking. In fact, they don't have to conceptually, but I couldn't find a way to break that dependency given the current runtime implementation.\nA couple of days ago I had a new idea, namely to delay the disposing of the subclass created for mocking class methods until the partial mock stops mocking instance methods, ie. when stopMocking is called.\nThis seems to work and all tests pass, but some confirmations would be nice, given how intricate this change is.\n. The change has been released in OCMock 3.4.3.. Like #353 this results in a broken build; see: https://travis-ci.org/erikdoe/ocmock/builds/397119873\n. Yes, defintely open to this. Developer experience is important, especially for something like a testing framework.. It looks like the build on TravisCI is failing. I only had a cursory look at the output and couldn't immediately see what's wrong, but this needs fixing.\nI'm also not sure about mixing a number of different concerns in this single PR, but I will comment on them individually.. Good news, I re-ran the build manually and it passed now. . This should be org.ocmock...\n. Is there an issue using this syntax? Why replace it with a more verbose version?\n. Does this really work? A quick test with a method that takes no arguments and returns an object reveals:\n- method_getTypeEncoding() returns \"@16@0:8\"\n- fullObjCTypes returns \"@@:\"\nAre the numbers interspersed with the types relevant for our purposes?\n. Why does OCMock itself have to link against CoreGraphics?\n. Which platform do these tests fail on? I've run the test suite locally on several platforms and they pass as is. The Travis CI build is green, too.\n. Please do not modify the version numbers in pull requests. This is very confusing for me because I have a little process that I go through before making a release, which includes changing the version number in several places.\n. Are you sure this should be deleted? Would it make sense to keep both?\n. What does this have to look like if we want to build the pod for OS X and for iOS development?\n. Why introduce an assert here? And shouldn't the object for OCMGlobalStateKey be removed from the thread dictionaory at this point?\n. Why is this now wrapped in a try/finally? Can we not emulate the previous version which took care of the deallocation more elegantly?\n. I think these lines are the reason for the problem reported in #245. Why do you believe this code should be copied here?\n. Please don't change the code more than necessary. The declaration was perfectly fine further down.\n. Why does this not return the invocation? Why store it in an instance variable?\n. This change is way too invasive. At an absolute minimum we'd have to keep the original initWithClass: method, and make it forward to the proposed new initWithClass:protocols: method. That way, the number of changes in the PR would be greatly reduced.. See above. This change is way too invasive. At an absolute minimum we'd have to keep the original mockForProtocol: method, and make it forward to the proposed new mockForProtocols: method. That way, the number of changes in the PR would be greatly reduced.. See above.. Please do not move classes that are for tests only to their own files. This just increases clutter.. Why use the macro version here?. Do we really need another variable or could we check whether, say, stubs is not nil as a sign that the mock has been initialised already?. I will admit that I haven't followed news about Apple's build system closely, and I assume it's the right thing to drop the -sdk flag in favour of platform key in the destination flag, but I am unsure why the OS is set to 10.3.1.. What is the reason for changing from iPhone 5s to iPhone X here?. What is the motivation for this change (and the two below)?. I realise that this is one of the changes described in #362. Personally, I feel that converting the C String to an NSString and back purely for the side-effect of copying it, obscures the intent. I'd much prefer to copy the C String, even if it needs a little more code.. I saw what you did ;-) and I understand why it was tempting to use the conversion for its side-effect. I've now pushed a change that stays with C strings.. Makes sense.. I see. Makes sense.. Of course! Totally forgot about that.. ",
    "skrul": "I think this was my original approach but had trouble getting it to work properly.  IIRC, it had something to do with getting the reference counting right.  But you'd think that the implementation would be able to retain and autorelease the object before setting it as the out parameter?  I had very little obj-c experience when I first wrote this :)  Perhaps I could take another swing at it.\n. ",
    "sgleadow": "To get those header paths and build dependencies right when using xcodebuild from the command line, I also needed to modify ONLY_ACTIVE_ARCH build setting.\n. ",
    "KushalP": "Closing this pull request while I go through your comments/nits.\n. Updated the patch to not add the UTF8String bit.\n. @erikdoe Is this okay to merge now?\n. Through some helpful prodding from @nico I now have a better understanding of what's going on here.\n-name was disallowed with the 10.6 SDK. Adding this include #import <objc/Protocol.h> exposes the following line to the compiler:\n- (const char *)name OBJC2_UNAVAILABLE;\nAs a result, this breaks OCMock if the 10.5 SDK is not present. I'm going to send in an update to this pull request which should hopefully fix things.\n. I've now updated the commit range. This should now make a lot more sense and run as expected. As always @erikdoe, please let me know if there are any issues.\n. ",
    "pjk25": "Hi Erik, \nThanks for the reply.  I hadn't actually seen an iOS framework before, until I installed GHUnit, which is distributed as such.  I've also had trouble using system style import statements, like \"#import <OCMock/OCMock.h\" with static libraries, however I noticed they worked properly with the GHUnit framework and decided to give it a try.  I didn't think to examine how GHUnit builds the framework until after following the guide I referenced (I didn't realize the guide was so old).  I would image GHUnit is a better reference.  They use a script which can be found here https://github.com/gabriel/gh-unit/blob/master/Scripts/iOSFramework.sh.\nI've struggled with the Xcode build system enough myself however, so I certainly don't blame you for wanting to stick with the current static library approach if it's working for you and the other users. Hopefully Apple provides some better methods for sharing libraries soon.\nThanks for OCMock, I'm excited to start using it!\nBest Regards,\nPhil\n\nPhilip Kuryloski\nSent with Sparrow (http://www.sparrowmailapp.com)\nOn Tuesday, June 5, 2012 at 12:04 PM, Erik Doernenburg wrote:\n\nThanks for exploring this. I must say, though, that I am not too keen on changing OCMock in this way. The reason is that I am already spending a lot (too much) time on keeping OCMock up to date with the changes Apple introduces to the build system and with supporting developers getting OCMock integrated in their projects. Moving to an approach that is neither documented by Apple nor well-known in the community seems counterproductive in this regard. \nI have also noticed that the instructions referenced above are quite long and only cover iOS 2.0, which is obviously many versions behind. If we were to switch to this approach we'd would have to write up simple and clear documentation on how this works on the current version of iOS and make sure this gets updated for new versions in the coming years.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/erikdoe/ocmock/pull/14#issuecomment-6121785\n. Hi Erik,\n\nI reworked things based on GHUnit's example.  The framework is now build with the Makefile, so it doesn't involve any changes to the xcode project files.  This limits the changes considerably and I think provides a better solution.\nBest,\nPhil\n. ",
    "theyonibomber": "+1\nEDIT:\noops, I see this code completely changed in commit https://github.com/erikdoe/ocmock/commit/e03d4fe74465b4fe3fa33552e036de8986f8dec2 so never mind...\n. If I already gave the mock as a dependency to an object in the setUp for instance.\nI agree it's not very common, but we had a use case for it.\nOn Tue, Jan 27, 2015 at 7:26 PM, Erik Doernenburg\nnotifications@github.com wrote:\n\nMaybe I'm missing the point, but why not just create a new mock object?\nReply to this email directly or view it on GitHub:\nhttps://github.com/erikdoe/ocmock/issues/176#issuecomment-71688980\n. \n",
    "omnivector": "Awesome, thanks!  \nYou may want to double check mine isn't 100% a dupe. Mine also fixes an issue that warns that the ocmock build target needs to update to the latest settings.\n Under the hood it just switches the LastCheckUpgrade version from 430 to 440 I believe.\nTristan O'Tierney\n- http://otierney.net\n- http://twitter.com/tristan\n- iMessage: tristan@otierney.net\nOn Wednesday, August 15, 2012 at 2:43 PM, Erik Doernenburg wrote:\n\nDuplicate of https://github.com/erikdoe/ocmock/pull/17, which I have merged.\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/erikdoe/ocmock/pull/18#issuecomment-7770107).\n. \n",
    "GWStuartClift": "\nI'll readily admit that I have very little experience with GCD, but I wonder why this implementation uses a concurrent queue and barriers. Wouldn't it be simpler to use a serial queue?\n\nA serial queue is easier but using a concurrent queue with barriers allows for concurrent reads.\n\nWould it be possible to have some unit tests that verify the code?\n\nWhen I began this issue I intended to fix the problem, however I only posted a simplified solution in the end to highlight the issue. I don't think this should be the solution to the problem as it has some downfalls; off the top of my head:\n- dispatch_get_current_queue() is now being deprecated and can't be trusted.\n- Possible deadlocks if future code changes current call graph or thread.\nIf I was posting this now it would just be an issue with a gist patch, I think the actual solution may take a bit more time and thought in order to solve it.\nThis could additionally be solved by the user by synchronising their calls to expect and verify on the same thread, I am highlighting the issue as many people using async test cases in frameworks like GHUnit may not realise that the implementation relies on access to mutable containers that are listed as not thread safe. \n. ",
    "percysnoodle": "Indeed you do.  Sorry - too used to ARC nowadays!\n. ",
    "nwg": "Ok. Although it's not the original reason i added this, i guess this would also be a problem for ghunit test runners set to run in parallel.\n. ",
    "Infiniverse": "Great. Thanks :).\nJoe\n\nDr Joe Karthauser\nOn 14 Mar 2013, at 03:35 PM, Erik Doernenburg notifications@github.com wrote:\n\nFixed the issue in a way so that it does the right thing for methods that create objects, e.g. mutableCopy, without causing memory leaks for other methods. See commit 00c0fe3.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "avidrissman": "I don't particularly mind either way; this happens to be the way that I've done it. But unless you're deliberately targeting 64 bits as a minimum (like you deliberately target \u2265 10.7) you might want to fix it.\n. ",
    "sotk": "Nie ma mnie w pracy do 2013-04-08.\nHello,\nCurrently I'm out of office and have no access to email or phone.\nMy substitution regarding:\nVitotrol project - Tomasz Wierzbik (WieT)\nViessmann Toolbox project - Mateusz Figlewicz (FiwM)\nBest regards,\nKarol Sotomski\nUwaga: To jest odpowied\u017a automatyczna na wiadomo\u015b\u0107 od u\u017cytkownika\n\"[ocmock] Fixed a bug for mock observer. (#35)\" wys\u0142ano 30.03.2013 00:48:50\n.\nTo jest jedyne powiadomienie, kt\u00f3re nadawca wiadomo\u015bci otrzyma od tej osoby\nw czasie jej nieobecno\u015bci.\n. ",
    "abuinitski": "Yeah, you're completely right about notification names being constant strings in most production cases. \nThe thing is, I've been writing a component which relies on NSNotificationCenter, and when testing that component, it was reasonable to compose notification names with stringWithFormat: to include a couple of parameters to create my synthetic testing conditions. \nI've just re-checked, and the following code works as expected:\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification) name:[NSString stringWithFormat:@\"MyNotification12%@\", @\"3\"] object:nil];\n[[NSNotificationCenter defaultCenter] postNotificationName:[NSString stringWithFormat:@\"MyNotification%@\", @\"123\"] object:self];\nSo it would anyway be a good thing to match to standard behavior.\n. ",
    "thalmicMark": "This issue is causing my tests to fail. Is there any reason why this pull request hasn't been merged?\n. ",
    "ghost": "It would be useful to have this merged in. When included in an iOS project, OCMock compiles with 2 warnings.\n. @erikdoe This syntax was introduced with XCode 4.4 (Apple LLVM 4.0). I agree it's one way to fix this but that involves creating an NSNumber and an NSString. Xcode suggested instead casting to 'unsigned long' as a way to resolve the warning.\n. I find andReturnValue: to be cleaner to use.\n. Here is what we use when any block is acceptable:\ndefine OCMOCK_ANY_BLOCK [OCMArg checkWithBlock:^BOOL(id blockAsId) { return YES; }]\n. No, it looks like the devs are still running 2.2.2.\n. The only way I've been able to get stub to work in OCMock 3 (as opposed to expect) for class mocks is to do this:\n[[[classMock stub] classMethod] andReturn...]\nor with new syntax\nOMCStub(ClassMethod([someClassMock someClassMethod]))\n. Actually, this is still the same build failure that has been happening with pull requests, which is fixed here #157. I'll merge master and resubmit this pull request.\n. No worries. Merged in master. Should be ready to go as soon as the build finishes.\n. Looks like the build passed after the merge!\n. I've reviewed this code a few times now, and then only thing that threw me was how rejects work internally. Now that I understand that, I think your fix should work just fine.\n. Done!\n. Should be all set to go here. @erikdoe can you have another look?\n. Looks great! Thanks!\n. Adding more thread-safety to OCMock would be awesome. It's true that OCMock is not thread safe, but there are many cases where you wouldn't notice. However since upgrading to OCMock 3, we've had to take extra care around thread-safety in related tests, since now every invocation is recorded in an NSMutableArray, which was not the case before.\n. @michaelmelanson, I'll have a look at the issue here and see what I can do about fixing it. However, I don't think calling methods of your mockOne object via the argument verification feature of OCMock is how this feature was meant to be used. Method verification blocks like your [OCMArg checkWithBlock:] should only have the job of verifying that the arguments passed in are what you expect them to be (and maybe the \"what you expect them to be\" part is the gray area here). In my opinion, a better test would use the andForwardToRealObject (e.g. [[[mockTwo stub] andForwardToRealObject] ...]) feature and rely on that to ensure your mockTwo object calls the block as you expect it to.\nYou could even use the NSInvocation object via the andDo: feature to intercept the block and further verify that your block is doing what you expecting it to do like this:\n```\ndispatch_block_t block = NULL:\n[invocation getArgument:&block atIndex:2];\ndispatch_block_t mockBlock = ^{\n  [[mockOne expect] methodCalledInBlock];\n  block();\n  [mockOne verify];\n};\n[invocation setArgument:&mockBlock atIndex:2];\n```\n. Behavior-wise, this actually isn't different than how method verification already behaves. For example, a situation like this would check the arguments of the method in question multiple times (regardless of OCMock version):\n```\n[[someObjectMock expect] foo:@1]\n[someObject foo:@2]\n[someObject foo:@1]\n[someObjectMock verify]\n```\nHere, we're saying that we expect that foo: is called with an object that matches @1. Since foo: is called twice with different objects, you would expect the method verification parts of OCMock to happen twice as well. I realize that in the case that foo: is only called once, you would only expect method verification to happen once. However, method verification should already be resilient to multiple calls, which is why this behavior change should not publicly have an effect on anyone's tests.\n. ",
    "JeffGilbert-MM": "Thanks. I should clarify that I am using the code in my project, like you, (via CocoaPods) and not the library so I get the warnings every time I build my app.\n. ",
    "LowAmmo": "@erikdoe - you are correct.  At some point in time a month or so ago, I swear I had a problem using structs with 'andReturnValue'.  But, I seem to be unable to recreate that problem.  So, either I accidentally had a bad version of OCMock, or I just had some special issue.  But, it does seem that doing:\nandReturnValue:OCMOCK_VALUE(struct)\nworks just fine.\nClosing this pull request.\n. Looks like it is just something related to CGRect.  Guessing there might be something off due to the embedded structs, but, the memory bytes should be lined up correctly, so, not sure why it would be failing...\nIt does appear to work as long as the OCMockObject is used when calling the overridden method:\n[mockTest returnRect];\nWorks successfully without crash.  So, the issue seems to be in how the method is overridden.\n. Might be worth it to extend this logic to just flush everything on the queue (if you don't want to be hampered by a time delay):\n```\n@implementation NSRunLoop (TestUtilities)\n\n\n(void)flushQueue:(NSTimeInterval)maxSecondsToWait\n{\n    __block dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n__block BOOL queueCleared = FALSE;\ndispatch_async(dispatch_get_main_queue(), ^(void){\n    queueCleared = TRUE;\n    dispatch_semaphore_signal(semaphore);\n});\nwhile(dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW))\n{\n    @try\n    {\n        [self runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:MAX_RUNLOOP_WAIT_SECONDS]];\n    }\n    @catch (NSException *exception)\n    {\n        NSLog(@\"Exception While Flushing Run Loop: %@\", exception.description);\n    }\n}\n[self runUntilDate:[NSDate dateWithTimeIntervalSinceNow:maxSecondsToWait]];\n}\n\n\n@end\n```\n. @erikdoe - yes, the intent is to flush everything currently queued up on the current run queue. The extra 'runUntilDate', is just to ensure it doesn't take more than the maximum amount of time... Ideally...would lean towards not having that.. But I debate back and forth on that.\n. +1, this would help clean up some of the mocking that I've done...\n. +1.  The change makes sense.\n. +1\n. +1\n. @erikdoe - That's a pretty good compromise...  And easily allows for an opt-in so that only consumers that want it need to account for the side effects...\n+1\n. The problem is that you are stubbing the method and then expecting on it...  Change your code to:\n[[[mockUser expect] andReturn:nil] username];\nThen I believe that will work...\n. I'm just glad it worked, and I didn't sound like a total noob! :)\n. +1\n. +1\n. +1\n. +1\n. +1\n. +1\n. ",
    "carllindberg": "I found the bug; indeed it is in how the method is overridden in the target class.  I posted a new pull request with the details and a potential (but ugly) solution (#41).\n. In looking, OCClassMockObject has a similar issue in its setupForwarderForClassMethodSelector method.\n. For documentation links, there are:\nA good overview of the situation:\nhttp://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html\nApple's low-level ABI documentation (has details for ppc, i386, and ppc64, with an external reference for x86-64):\nhttp://developer.apple.com/documentation/DeveloperTools/Conceptual/LowLevelABI\nThe document for x86_64 (archive.org link since I can't get to main site at the moment):\nhttp://web.archive.org/web/20120417163521/http://www.x86-64.org/documentation/abi.pdf\nARM information:\nhttp://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf\nIt's possible that libffi might have the code to determine this stuff, but I don't know enough about it.\n. Yeah, I looked at class-dump to see if I could find any useful private methods, but nothing was evident.  Class-dump does show that method, and the structure it returns (and also expands NSMethodFrameArgInfo, which is several more fields plus about 10-15 bitfield flags, and there are two of those in whatever is returned from _frameDescriptor).\nReading the GNUStep NSMethodSignature.m, there may be an extra '+' character in the type string for the return type to indicate a needed struct return, not sure.  But that may be a GNU runtime thing only.  It would be very nice to find better API to figure it out, to be sure.  The current hack is technically not private API, but... it might be fragile.  Not sure how often Apple changes the output of that method.\n. Does look like libffi has the logic...\nhttps://github.com/atgreen/libffi/blob/master/src/x86/ffi64.c\n(the classify_argument and merge_classes functions)\nAlso, in theory, all the above would hold true for unions as well, but it appears that NSMethodSignature throws an exception if you try to initialize with a type string that uses them.  Thus, nothing that uses NSInvocation would appear to be able to support union returns.  It works if you just implement forwardingTargetForSelector:, which apparently avoids NSMethodSignature/NSInvocation creation, but once you need NSInvocation it's a problem.\n. I updated this branch to have some arm64 fixes (same as ones in other pull requests, but also some fixes around changes in BOOL handling), and fixed a few more undeclared selector warnings.  Builds and passes test using Xcode5 on 10.9 and iOS6/7 simulators.\nAdded a second commit with an iOS test target.\n. Erik merged the essential parts of this back in August.\n. Is this much different than something like:\n__block id var;\n[[mock expect] someMethodWithArg:[OCMArg checkWithBlock:BOOL^(id param){ var = param; return YES; }];\n?\nAlso, not sure how the \"void *\" will work with ARC.  NSInvocations are dangerous that way... you have to declare the local variables __unsafe_unretained when pulling values out.  This might be a similar situation (though the checkWithBlock: approach does not have that issue).\n. You might need the changes to build.rb and/or Build-Fat-Library.sh, not sure.\n. I would guess the first two header-declared instance variables of \"OriginClass\" happen to be objects -- if they were integers, you would see \"i\" instead of \"@\", etc.  For example, I tried the TestClassThatCallsSelf class in the test cases and got \"^{TestClassThatCallsSelf=#i}\". The current code is a bug (it would work only when no instance variables beyond the \"isa\" in NSObject are declared in the headers, which is common these days but not guaranteed), but the proposed fix would only solve a few additional problems.  The proper fix should probably look for any type which starts with \"^{OriginClass=#\" and then check to see if the \"OriginClass\" portion is an ObjC runtime class.\nBut, a quick fix would be to change the regex to @\"^\\^{(.)=#.}\"  (i.e. change @* to .*).  That would only fail if it was truly a structure which had a Class value as the first element in the structure.\n. Yep, this looks like a good patch now.\n. Does this work with BOOLs encoded like OCMOCK_VALUE(YES) or OCMOCK_VALUE(boolVariable)?  Those will typically be NSValue instances, not NSNumber.  And there will be lots of those in existing code, which could be an issue on the 64-bit runtimes which use 'B' in method signatures.  We may need to retain that explicit check.\n. I think Erik's concern is also valid.  If someone creates an integer value, but the method in question returns a short, the getValue: call will overwrite the buffer.  After playing around a little, I think using CFNumberRef to convert the values (they have a function which returns TRUE if the values can be losslessly converted) would work.\nHow about this:\n```\nstatic CFIndex NumberTypeForObjCType(const char *objcType)\n{\n    switch (objcType[0])\n    {\n        case 'c': return kCFNumberCharType;\n        case 'C': return kCFNumberCharType;\n        case 'B': return kCFNumberCharType;\n        case 's': return kCFNumberShortType;\n        case 'S': return kCFNumberShortType;\n        case 'i': return kCFNumberIntType;\n        case 'I': return kCFNumberIntType;\n        case 'l': return kCFNumberLongType;\n        case 'L': return kCFNumberLongType;\n        case 'q': return kCFNumberLongLongType;\n        case 'Q': return kCFNumberLongLongType;\n        case 'f': return kCFNumberFloatType;\n        case 'd': return kCFNumberDoubleType;\n    }\nreturn 0;\n\n}\nstatic BOOL GetOutputValue(NSValue inputValue, const char targetType, void outputBuf)\n{\n    / If the types match exactly, use it */\n    if (strcmp(targetType, [inputValue objCType]) == 0)\n    {\n        [inputValue getValue:outputBuf];\n        return YES;\n    }\n/* See if they are similar number types, and if we can convert losslessly between them */\nCFIndex inputType = NumberTypeForObjCType([inputValue objCType]);\nCFIndex outputType = NumberTypeForObjCType(targetType);\n\nif (inputType == 0 || outputType == 0) // one or both are non-number types\n    return NO;\n\nCFNumberRef testNumber;\nif ([inputValue isKindOfClass:[NSNumber class]])\n{\n    testNumber = CFRetain((__bridge CFNumberRef)inputValue);\n}\nelse\n{\n    /* Convert the NSValue into a CFNumberRef */\n    NSUInteger size;\n    NSGetSizeAndAlignment([inputValue objCType], &size, NULL);\n    char buf[size];\n    [inputValue getValue:buf];\n    testNumber = CFNumberCreate(NULL, inputType, buf);\n}\n\nBoolean canConvert = CFNumberGetValue(testNumber, outputType, outputBuf);\nCFRelease(testNumber);\nreturn canConvert;\n\n}\n\n\n(void)handleInvocation:(NSInvocation )anInvocation\n{\n    const char returnType = [[anInvocation methodSignature] methodReturnType];\n    NSUInteger returnTypeSize = [[anInvocation methodSignature] methodReturnLength];\n    char valueBuffer[returnTypeSize];\n    NSValue value = (NSValue )returnValue;\nif (GetOutputValue(value, returnType, valueBuffer))\n{\n    [anInvocation setReturnValue:valueBuffer];\n}\nelse\n{\n    @throw [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@\"Return value does not match method signature; signature declares '%s' but value is '%s'.\", returnType, [value objCType]] userInfo:nil];\n}\n}\n```\n\n\nThat lets test like these pass:\n```\n- (void)testReturnsStubbedUnsignedLongReturnValue\n{\n    mock = [OCMockObject mockForClass:[NSNumber class]];\n    [[[mock expect] andReturnValue:@42LU] unsignedLongValue];\n    unsigned long returnValue = [mock unsignedLongValue];\n    STAssertEquals(42LU, returnValue, @\"Should have returned stubbed value.\");\n[[[mock expect] andReturnValue:@42] unsignedLongValue];\nreturnValue = [mock unsignedLongValue];\nSTAssertEquals(42LU, returnValue, @\"Should have returned stubbed value.\");\n\n[[[mock expect] andReturnValue:OCMOCK_VALUE((char)42)] unsignedLongValue];\nreturnValue = [mock unsignedLongValue];\nSTAssertEquals(42LU, returnValue, @\"Should have returned stubbed value.\");\n\n[[[mock expect] andReturnValue:OCMOCK_VALUE((float)42)] unsignedLongValue];\nreturnValue = [mock unsignedLongValue];\nSTAssertEquals(42LU, returnValue, @\"Should have returned stubbed value.\");\n\n[[[mock expect] andReturnValue:OCMOCK_VALUE((float)42.5)] unsignedLongValue];\nSTAssertThrows([mock unsignedLongValue], @\"Should not be able to convert non-integer float to int\");\n\n}\n\n\n(void)testReturnsStubbedBoolReturnValue\n{\n    [[[mock expect] andReturnValue:@YES] boolValue];\n    BOOL returnValue = [mock boolValue];\n    STAssertEquals(YES, returnValue, @\"Should have returned stubbed value.\");\n[[[mock expect] andReturnValue:OCMOCK_VALUE(YES)] boolValue];\nreturnValue = [mock boolValue];\nSTAssertEquals(YES, returnValue, @\"Should have returned stubbed value.\");\n[[[mock expect] andReturnValue:OCMOCK_VALUE(1)] boolValue];\nreturnValue = [mock boolValue];\nSTAssertEquals(YES, returnValue, @\"Should have returned stubbed value.\");\n}\n```\n. Unfortunately it does look like the CFNumber function will return YES when truncating values -- so if you put in a value of 300 for a BOOL it looks like it will truncate the value to 44 (300 - 256) and still return YES, which seems like it should not.  And I'm not sure how well it will handle unsigned/signed differences.  But it seems like it handles most common-sense conversions, and seems a bit better approach as it handles equivalent NSValue instances.\n. Any new set of methods would only apply to -expect though, right?  I could see having a version which takes a range like this, instead of combining with a call to -expect.  You wouldn't apply them to stub... though I guess you could do a rejectAfter X calls.  That would probably have its own type of method though.\n\n\nAgreed that expectZeroOrMoreTimes sounds exactly like stub though; not sure there is a need for that.\n. One option is that we could implement respondsToSelector: to be something more like:\nreturn [super respondsToSelector:aSel] || [mockedClass instancesRespondToSelector:aSel] to make calling actual proxy methods easier, instead of resorting to runtime functions.  Could also do the same with isKindOfClass: I guess, to enable our own code to check isKindOfClass: on the mock instances (would return YES to either one).  Might be helpful even if a less pure proxy, and it would reflect actual runtime behavior better ;-)\n. Sure, if you like that better.   The -proxyClass method returns the isa of the mock (same as if you did object_getClass(mock) )  and since the mock objects are proxies (subclasses of NSProxy), it does return the proxy class.  But mockObjectClass is more specific to the situation.\n. I do have option 2 implemented in a separate branch if that is preferred, which it might be.  That allows andForwardToRealObject even if -classMethod is not explicitly specified (i.e. follows the current usage); it's just that the error notification if used on a protocol mock etc. does not get flagged at mock setup time but rather during regular code runtime if the method is called.\n. I suspect you have include the AFNetworking classes twice in your binary.  I think both your library includes libPods.a, meaning it will have a copy of all of those classes.  Your test bundle also includes libPods.a, meaning it will have another copy of all those classes.  In Xcode 5, it appears that in this situation (rather than duplicate symbol errors), that two versions of each Class get added to the ObjC runtime with the same name.   NSClassFromString (which OCMock uses) will only find the first one, probably, and only mock that class.  Hard class references in one or the other product will refer to the version of the Class linked with that product -- so your library version will point to the Class linked into your library, whilst your test class code will refer to the one compiled into the test bundle.  OCMock will only modify one or the other.\nSo... try removing libPods.a from the \"link binary with libraries\" build phase from either your library or the test bundle.  They should either be provided bundled inside your library (in which case remove from the test case), or users should be expected to include them along with your library if they are using it, in which case remove libPods from your library target (and the test case, as a consumer of the library, would then need to include it).\n. Normally, -valueForKey: calls your accessor method.  What kind of object is it, such that it has a special implementation of valueForKey: which avoids calling the method?  I don't think OCMockObject does anything special there... but since you are a mock for a protocol, and -valueForKey: is probably not a method in the protocol, the mock object may not have any idea of what to do.\n. From one perspective... when you have an object which conforms to a protocol, normally that means you should be restricting calls to those methods only.  The fact you are calling methods outside the protocol (even indirectly via sortedArrayUsingDescriptors:) can be considered an error in itself.  So, the behavior does make sense.  When you are using a mock object for a protocol or a class, you normally have to provide stub implementations for every method you use...  that would include methods you indirectly use.  Obviously, since most objects inherit from NSObject, you can get away with calling those methods at runtime (even if they are not even part of the NSObject protocol).\nIs it possible for you to use a partial mock object?  That should use the normal implementation while being able to stub out only certain methods.\nIt might be possible though to have a special method on OCMockObject to add all the NSKeyValueCoding implementations to the mock object, as a special case to aid with this sort of thing, so that the mock objects have the same implementation as NSObject.  That will not help if the target class has special overridden versions of valueForKey: (such as NSManagedObject) but it might work out.  That would probably make it impossible to stub or expect those methods though.\n. I don't think this is a correct change.  An id * type is not an object, and requires use of the andReturnValue: method, since it is just a pointer.  This check is to see if something is an object pointer; an object pointer pointer does not qualify.\nYour test case is returning a TypedInterface * when the method signature calls for a TypedInterface **.  They are not the same thing, and the return value in the unit test is incorrect, and should not pass.\nTo qualify for andReturn:, it really needs to be a pointer to an objc_object structure, with no indirection.\n. Hmm\u2026 that is tough.  Basically the compiler does not know the structure/ivar content of the object in question, so it's encoded as a pointer to an \"OriginalClass\" structure with unknown contents.  The check we have at least looks to see if the first ivar is a Class value (the #), but that is not present in your case.  I think OCMock does need to distinguish these from pointers to regular structures.\nI wonder what happens if the compiler only has an @class OriginalClass; statement without importing the actual header to know it's an NSObject (or whatever) subclass?  Or perhaps you have a class which forgot to declare a superclass?  I'd expect at least an equals sign in the latter case though.\nIt might be possible to parse out the \"OriginalClass\" portion of the structure and do NSClassFromString with it to see if it's a class; that would be possible.\nDo note that #52 fixes the situation when classes publicly declare more instance variables than just \"isa\"; that is currently broken.\n. Ah, interesting.  When a class has types that NSMethodSignature can't handle -- which would be bitfields (NSImage) or unions -- it looks like the type encoding in there gets truncated to just \"^{ClassName}\".   We can match that, but that might get a few places where there are pointers to anonymous structures.  We could parse out the class name and check the runtime I guess as well.\n. You didn't need to change the isKindOfClass NSString case -- that -description will never be nil, and even if it is, +stringWithFormat: handles it find.  The only real needed change was to change the last line\nreturn [object description];\nto\nreturn [object description] ?: @\"\";\n-description should never return nil, but... it's always possible it can happen, so good to guard against it.\n. Ah\u2026 been there, done that.  \"class\" is bad too ;-)\nMaybe instead of a blank string it should return \"\" instead so people might see it more...\n. I'm not as sure it should be a method -- it could be a nice convenience, certainly, but I don't think it's at all bad to have the mock create exist completely outside the code it's mocking.  The class method to create a partial mock I think should be avoided -- that should be an instance method.  And lastly, you can't mock protocols that way, so you need something external there.  Having a consistent way to create mocks seems better to me than having an instance method (partial mocks), class method (class mocks), and external function/macro/OCMockObject class method (protocols).   Doesn't mean the convenience methods are a bad thing, but I do like the class methods on OCMockObject as the base with the functions/macros as conveniences.  The functionality, to me, is more closely related to the OCMockObject class and it's better scoped there.\n. Also, the methods should probably be -ocmock or something namespaced a little bit.  There are other mock frameworks out there, as well.\n. Closing in favor of #115\n. I added an updated version of the NSNumber type PR which also solves this problem (#115), by using a different (regular C) implementation which is shorter and avoids usage of C++ (since it's not a C++ specific issue).  It can happen when a method return type knows a full structure type, but outside API only knows opaque pointer types, I think.  We might also solve the issue by allowing any two pointer types to be OK, regardless of what they point to, even if that is encoded in the type.\n. I think #116 might fix this.  Looks pretty familiar.\n. I have this issue on Mountain Lion running OSX tests.  It is fine when running iOS tests in the simulator, so Mountain Lion may have an older ObjC runtime which doesn't handle what OCMock 3 is trying to do (meaning the current approach might be very fragile).  This particular issue for me was fixable by replacing \"self\" with \"[NSObject class]\" in the class_getMethodImplementation[_stret] calls, since it doesn't matter which class we call that on, and best to avoid a class which might have all its class methods mocked out.\nUnfortunately that was just the type of the iceberg, as I get all sorts of infinite recursion on other methods.  I tried adding a bunch of methods to the whiteList in OCClassMockObject and OCPartialMockObject (whichever ones caused infinite recursion), and eventually got by those, but then ended up with an invalid method cache segfault.  Do we really need to stub out every single instance and class method?  Seems waaay safer if we only do the ones with explicit expect, stub, or reject calls to them.\n. I can understand the approach, but\u2026 it just feels fragile to me, and it almost guarantees that when any other system does something a little \"interesting\" (KVO, dynamic properties, proxies, bridged classes) that it will be difficult or impossible to ever mock, and will likely fail in bizarre ways. \n. NSMethodSignature does not support bitfields.  That can be quite aggravating when the type is actually just a pointer to a struct that has bitfields, and the method frames don't care about the contents, because the bitfield aspect really doesn't matter.  But for methods which return structures which have bitfields, it does matter, and while it works in code those methods do not work with NSMethodSignature/NSInvocation.  That does mean that things like NSDecimal can't be mocked.  However, it seems as though in OCMock 3 every single method is silently wrapped by the partial mock subclass, meaning the mock will find any problematic method and throw an exception like this, even if the method is private and the test case code doesn't care about it at all.  Which class were you trying to mock?  Was it a subclass of an Apple class, and if so, which one?\n. @erikdoe We may as well let stub or expect throw, to indicate that those methods are not stubbable.  There is nothing you can do since you rely on NSInvocations, and those will not work with either bitfields or unions unless Apple adds support.  That has always been true, even with OCMock 2.x. \n. Doesn't OCMock do an isEqual: check by default when you supply a bare object instead of wrapping it in OCMArg?\n. But then people might think it should be used, which it really shouldn't.  Maybe an added comment to mention to just pass the object directly if isEqual: is desired.\n. I would vote to add it.  Not everyone has Hamcrest installed (raising hand here, at a client site).\n. You could be mocking a very core NSObject / UIApplication / other method which gets called a lot, but which OCMock turns into an NSInvocation-forwarded version every time (which is much slower than a normal method call, though fast enough to not be a problem unless it is called a lot).  Or maybe a class method on say NSString, or some other commonly-used class, or there is some bad interaction with other frameworks you are using. Trick would be finding which one.   That is another problem with wrapping every single method on a class; if you mock core framework classes you might hit a very sensitive method at some point.\n. Partial mocks do mock all instance methods.  Class mocks mock all class methods on a class.  You might try finding the handleUnRecordedInvocation:(NSInvocation *)anInvocation method in OCMPartialMockObject class, and putting an NSLog of which selector it is forwarding along, then run a small test suite to see if there is an inordinate number of calls to a particular method.  Then do the same with the forwardInvocationForClassObject: method in OCMClassMockObject.\n. Ooh.  Are we checking that we are not re-wrapping class methods that have already been wrapped by previous mocks? Or are we wrapping them all thus doubling the number of methods every time we mock a class?\n. I have not had time to try and really look at this problem.   #115 should not cause any slowdowns, as the new code in there should only be invoked when @encode(val) does not equal the NSValue objCType, which was always an error in OCMock 2.x.  If there are coding errors in there, it of course could cause crashes, but again that would only happen in situations which were errors with 2.x but we are now a bit more lenient with.  I'd think any crashes caused by it would pretty obviously point to that code.\nAvoiding Apple private methods should help a lot, though that is error prone -- that will also probably skip any category methods people add to Apple classes which use the \"prefix_methodName\" convention, and who may expect to be able to call/stub/expect.\nStill, it does mean that an awful lot of methods which were once simple method calls are now going to be a pair of NSInvocation calls -- one to forward from the real object back to the mock to record the call, then the mock back to the method on the real object.  And for some NSObject protocol methods like respondsToSelector and many others, it won't forward back to the real objects, since the mock (via the NSProxy class or overrides) implement the methods already, so hopefully those implementations work OK as substitutes.\nAnother thing is that we are continually modifying classes in the runtime, which flush any of the method lookup caches on that class and all subclasses, such that the caches have to be rebuilt on subsequent calls -- but then the mock tear downs or next unit test probably flushes them again.  That was happening to an extent before but it may be much more noticeable now.  If search_method_list is a big percentage of the time, that indicates that the method caches are missing a lot, I'm pretty sure.\nThere is some caching that we could do possibly -- maybe keep an NSArray (or NSHashTable) of the found selectors for a given class so we don't have to figure them out again for the same class.  And maybe the NSMethodSignature instances too.  The new NSRegularExpression should possibly be cached as a global variable.   Although with its current implementation a pair of hasPrefix calls on the NSString may be faster.\nIt's also possible that by not forwarding some methods now, we are actually exposing ourselves to some other methods which should be blacklisted but currently are not.  The above crash screenshot is obviously during the forwarding games played by the swizzling, but I'm not sure of the exact cause -- the backtrace is not all the way expanded.  Looks like it dies in class_isMetaClass though which is a bit scary, as a bad pointer was passed in there it looks like.  Actually I just upgraded to 10.9 and ran the tests and am getting a similar crash when I do some stuff with UITableView -- it looks like it's crashing when forwarding on some of the internal UIAppearance calls.  That stuff is a certain amount of voodoo and I'm not sure how we are affecting it, but we apparently are.  Hmm... I think your magic meta-subclasses are not initialized right away, which can get +initialize called again on your sub-metaclass, which seems to be causing trouble (UITableView +initialize sets up some UIAppearance stuff and I think that is a bad idea with your custom meta classes).  I added \"[subclass self]\" right after \"id newMetaClass = object_getClass(subclass);\" to get initialize called before we play any further runtime games with it, and it seemed to avoid the immediate UITableView problem.  You probably want to add an empty implementation of the +initialize method to those magic subclasses so that the superclass version isn't called again -- not all implementations guard against being called more than once when subclasses exist. \nI also worry if using mocks on proxy-type objects which forward to other objects won't be handled very well (since they won't have actual implementations to stub out, though method calls do flow through them).\n. You probably want to add +load and +initialize to the blacklist, just to be safe.  You might also want to add the empty +initialize to the OCPartialMockObject subclasses, to be safe there as well.  The blacklists should also probably be NSSets, and created only once.\n. Interesting that stubbing +initialize is not necessary.  We are creating a legitimate subclass, and I would have thought called methods on it, which should initialize the subclass first (potentially calling the superclass version again if not overridden).  As for the blacklist, might as well.  It's not the NSObject versions of those methods we would worry about.  +load should honestly be called before OCMock has a chance to do anything so it shouldn't matter.\nAs for NSSet vs NSArray, yeah, shouldn't matter much.  Creating them only once inside a dispatch_once block would seem to be an easy enhancement though.\nIf you are trying to speed up the stret checks, you could probably put the cache right inside the NSMethodSignature method.  The class doesn't matter; you could cache directly on the objcType string, which would be a simpler key creation and result in way more cache hits.  The class of the receiver doesn't really matter, it's the return type only.  If you wanted to go hardcore, you could create a CFDictionary with custom callbacks which take c-string arguments (making copies if need be) and integer values, which wouldn't need to do any allocation at all for cache hits.\n. NSInvocation and ARC don't play together very well.  It's causing a double-release.\nYou declared MyObjectWithAction as a local strong variable.  However, the value gets assigned by NSInvocation, which takes a \"void *\" argument, so ARC has no way to know an object came into scope and does not add a retain.  However, it will add a release when it goes out of scope.  Boom, that's a crash.\nDeclare the variable as __unsafe_unretained so ARC doesn't touch it.  If you want, declare one variable as __unsafe_unretained, use getArgument:atIndex: on that, and then immediately assign to a local (normally declared) variable, which will then have a local strong reference, if you want to guard against deallocation during the block.\n. I wonder if that (real) method implementation directly uses the \"cmd\" argument, and we are passing in the ocmock_replaced* version of the selector (common when using method_exchangeImplementations but can run into issues like this).\nLooks like it is forwarding a method along the responder chain, which will eventually end up at the application or app delegate.  Not sure why it would call a method which is not actually responded to though, especially on the app delegate.\n. The only thing that comes immediately to mind is to add \"_controlTouchBegan:withEvent:\" to the white list of methods not to wrap around in OCPartialMockObject.\n. It's not swizzling the delegate.  It is however changing the _cmd parameter when calling the original method on UIApplication, which just so happens to be a method which makes use of the responder chain probably with that parameter, which will forward along the chain until it finds a class which implements it, and the app delegate is the responder checked after the application.  So we are probably skipping past the intended responder and going to the end of the chain.  Not sure why it actually tries to call the method on the app delegate though.\nIt would absolutely be best to avoid swizzling any of Apple's private methods.  Even some of their core methods aren't a great idea either (sendEvent: maybe).  They may be hard to determine algorithmically (people might add their own categories which have internal methods which start with underscore), and so might cause some inconsistent behavior, but the above is a good start.   I don't think we can truly fix methods which make use of the _cmd parameter... that is an intractable situation I think if we are using NSInvocation.\n. Yeah that is almost certainly the issue.  In some of my code, I've actually added an -objectForArgumentAtIndex: convenience method which avoids the problem.  (Same for -objectReturnValue, though that is less helpful with OCMock).\n. More of a cosmetic issue; things work either way. Using the newest syntax and APIs can freeze out people wanting to use OCMock on older code bases, or who wish to maintain compatibility with older OS releases by testing on older devices etc., so it's often best to lag behind the state-of-the-art.  But, OCMock 3 may have already started using some of this stuff so it may not really matter.  Whatever Erik prefers, really.\n. Some of those warnings look more annoying than useful, and probably aren't turned on by most projects.  But, mostly a stylistic question for Erik.  Personally I like the change to use static variables, and fixing the formats, but not many of the others.  It would let people drop in the source to their own projects if they use those warnings and not add additional warnings for them, though.\n. May as well.  The current code was fine but I'm sure lint tools will start complaining about strcpy now that there are preferred alternatives.\n. Yeah, this matches up better with the types used in NSInvocation.h, so may as well do this.\n. Oops.  +1\n. If I remember, the issue with partial mocking a KVO class is that there is some global state keyed by the object's isa (since that is a per-instance class just like partial mocks) and when you change it, the KVO mechanism can crash when you call any of the modified methods since all of the associated state is no longer found with the new isa pointer.  The way it works now, the partial mocking will blow away the KVO class completely so that notifications won't work while mocked, as all of the altered methods are in a class which is no longer referenced by the object. The KVO class gets restored at -stopMocking, so KVO cleanup can work afterwards.  If you partial mock first and then KVO, I think it works, provided you remove all KVO observers (thus restoring the partial mock isa) before -stopMocking is called.  There is probably a unit test to make sure that things at least don't crash if you partial mock a KVO object.\nI guess the question is what we want to do when faced with dynamic-subclass-replace-isa-override-stubsclassmethod situations (i.e. where [object class] != object_getClass(object) ).  We want to go one way with NSManagedObject and the other with KVO.  The current change only alters the behavior for NSManagedObject, but doesn't change the default.  Maybe though we want to check for KVO explicity and use [object class] in that case, and object_getClass() in all others (thus changing the default).  Checking for [object observationInfo] != NULL should do it.  The question is what happens with other such situations -- not sure there are any others used by Apple, but who knows about third party code.  It's arguable though that using the dynamic subclass is usually better (as it is with NSManagedObject).\n. I forgot that -retainArguments makes copies of c-strings as well -- that is the reason for avoiding retainArguments on methods which have char pointers, since the pointer address will change, breaking pointer comparisons needed by -anyPointer etc. (and it would crash if it tried dereferencing those pointers).\nI think we may be best off writing our own NSInvocation category method \"retainObjectArguments\".  That can go through the arguments (avoiding the target and return value), and for each one which is an object, add it to an NSArray.  (If the argument is a block, make sure to call -copy first.)  Then, add that array as an associated object to the NSInvocation.  This approach should avoid the char * and target problem, but still make sure that object arguments are retained.\n. If you just add the set or array as an associated object on the invocation instance, then the arguments are retained and they will be released naturally whenever the invocation gets dealloced.  In other words, it's just a better version of -retainArguments for our purposes (which just adds objects to an internal NSArray).  It would also fix the other place which currently needs to avoid -retainArguments.\nYour version should work most of the time, though it will fail matching if \"self\" happens to be an argument other than the target (since it won't be copied over).\n. Ah, OK.  Associated objects aren't bad at all; they are best used by category methods which give a better API but they are far far better than other mechanisms (like an external map table, the older approach). So, what you have is basically a more complicated version using an NSInvocation to retain the arguments instead of an NSArray, and additional storage on the copied invocations, but the effect would be the same.  Adding it as an associated object would be pretty clean and requires no cleanup code anywhere else, and that method would also be appropriate to use in the other place which avoids retaining arguments, but whatever Erik prefers really.\n. I think they are reasonably obvious when self-contained in a category method. It'd be funky API to add to a general-purpose category, of course, but for an OCMock-specific category it is what is needed ;-)\nOh... might be a good idea to copy block objects instead of just retaining them, in case they are a stack block.\n. OK, that is interesting.  You could also just store the copied invocation as an associated object on the original invocation then, and it will be cleaned up at the appropriate time without need to store them separately.  Hopefully we would not run into a situation where a stack block was left on the original NSInvocation.\nIf you make the other place which is avoiding char * retainArguments use your method, that could also fix problems with method which have both char * and object arguments.\nDetermining a block isn't too hard though...\n```\nBOOL IsBlockObject(id anObject)\n{\n    static Class blockSuperclass = Nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        id block = ^{};\n        Class blockClass = [block class];\n        while ([blockClass superclass] != [NSObject class] && [blockClass superclass] != Nil)\n            blockClass = [blockClass superclass];\n        blockSuperclass = blockClass;\n    });\nif (blockSuperclass != Nil)\n    return [anObject isKindOfClass:blockSuperclass]);\nreturn NO;\n\n}\n. When mocking class methods it is often best to explicitly call -stopMocking to avoid problems like this.  The -dealloc methods of the mock object should call -stopMocking, and since tests should be wrapped in an autorelease pool, that should get free the mock and clean up the mocked state.  However, if your code leaks the mock object or keeps a strong reference around past the test (i.e. as a global variable somewhere), then -stopMocking will not be called automatically.  I would either find the memory leak, or make sure you have -stopMocking at the end of the test, or (probably best) do both.\n. Adding the check for '?' makes a lot of sense, if that solves the issue.  Certainly wouldn't hurt anything.  Blocks are often encoded as \"@?\" or \"^?\" as well.  I'm just using NSGetSizeAndAlignment to walk through the type string, not getting any size information, but it doesn't surprise me that function can't deal with '?'.  It barfs on unions too, but not much can be done about that.\n. One thing you might try is to add all the methods you know you need before calling objc_registerClassPair().  That may (in theory) avoid all of the cache flushes and locking etc. associated with adding those methods, because the class is not fully in the runtime system yet.\n. You should be able to add a OCMStub call after the OCMExpect (or N calls to expect), so that additional calls won't throw exceptions.\n. I believe any method on a UI* class which starts with underscore will not be mocked.  So you could change your swizzle method to __my_swizzled_sendEvent:.. That looks like a failure in OCMEqualTypesAllowingOpaqueStructsInternal() .  Those two objcType strings should compare as compatible -- though in the past it is usually \"{=dd}\" for unnamed structs.  I thought that \"?\" was dealt with, but obviously not.  A quick test would see if those two strings pass that function, and if not, just fix that.. Yeah, that should do it.  We can't compare on name if one of them is \"?\", basically.. I wonder ifNSGetSizeAndAlignment``` no longer parses unions or arrays.  That would be aggravating.  Is it hitting the catch block in OCMEqualTypesAllowingOpaqueStructs() ?  If so, you could put a breakpoint there and look at the exception and see if it gives any further information.. Yes, passing a reference to self in a method call from -dealloc is dangerous.  You have to be sure that the value is not autoreleased in the calling code (or any other delayed release like these captured NSInvocations) -- even a normal retain/release added by ARC can be a bad idea.  I think it's even too late to obtain a weak reference to such an object.\nThere is a private NSObject _isDeallocating method I believe.  It may be possible to use that to avoid capturing the NSInvocation in the first place, or at least don't retain such arguments in the NSInvocation (better would be to invoke the original method with the value but store nil in the NSInvocation).\nAnother option would be to add the ability to specify that -removedFrom: or movedFromSuperview: (or similar specific methods on a particular class) should not have its NSInvocation recorded.\nOr a way to turn off the implicit capturing of all methods completely for a particular test, such that you need to specify all your expects before the code is invoked, and only those specific methods will be mocked (the old OCMock behavior, which is waaaay less invasive runtime-wise for edge cases like these).. Nope, no issue.  There was another place using @YES; I just wanted to add a test for using a constant in an OCMOCK_VALUE usage and this was the only other place using \"andReturnValue\" which was easy to change to test the new macro.  It may be better to make a separate test case using an NSRect (maybe just use the new test with the other pull request, which does use NSZeroRect) and abort this change.\n. Interesting... I thought I saw in the ABI that arm64 structs over 8 bytes would need the stret (for regular arm it was 4 bytes), but maybe Apple is doing something different.  I don't see how it's avoidable for large structs at some point, but maybe there is information in registers which one function can determine the difference at runtime, or something like that.  Although, if class_getMethodImplementation_stret() returned a non-NULL function which was different, that means the objc_msgForward_stret function (or something like it) exists in the arm64 runtime, so it might be necessary at some point.  Anyways, it would be best to put the #ifdef check in the implementation of the usesSpecialStructureReturn method to just return NO (if that is indeed the correct implementation).\n. My bad, it does appear that all the *stret() functions do not exist in the arm64 runtime.  So, you can't even reference them, and you need to conditionally compile them.\nI updated my pull request #44 to have this basic fix (since it already re-organized the code which called it).\n. On Nov 13, 2013, at 12:08 PM, Erik Doernenburg wrote:\n\n\n\nconst char *types = method_getTypeEncoding(originalMethod);\n/* Might be NULL if the selector is forwarded to another class */\nif (types == NULL) types = [[[self mockedClass] instanceMethodSignatureForSelector:selector] fullObjCTypes];\n  Does this really work? A quick test with a method that takes no arguments and returns an object reveals:\n\n\nmethod_getTypeEncoding() returns \"@16@0:8\"\nfullObjCTypes returns \"@@:\"\nAre the numbers interspersed with the types relevant for our purposes?\nI'm pretty sure they are not.  The offsets in the types are (or were originally) based on the m68k architecture and have not really been useful ever since.  They still produce the numbers since some parsers expect them to be there, but the numbers themselves are meaningless.  We could change the method to inject some random values I guess but the runtime does not use them, I'm fairly sure.   There is some grumbling in the clang source code about still having to generate the numbers for back-compatibility purposes (though they probably do try to adjust them for the architecture some).   The numberless types seemed to work fine, though I guess it's hard to predict what code out there might read them.\n\n-Carl\n. You don't actually need the @interface section.\nUsing class-dump on CoreFoundation, I see NSObject implements all of these:\n- (BOOL)isNSArray__;\n- (BOOL)isNSData__;\n- (BOOL)isNSDate__;\n- (BOOL)isNSDictionary__;\n- (BOOL)isNSNumber__;\n- (BOOL)isNSOrderedSet__;\n- (BOOL)isNSSet__;\n- (BOOL)isNSString__;\n- (BOOL)isNSTimeZone__;\n- (BOOL)isNSValue__;\nMay want to implement all of them if going this route.\n. self already is the class object; [self class] would return the same pointer and would have the same problem.  It might be safer to have a separate, private root class to use in case someone tries to mock out the NSObject class, or maybe use NSProxy.\n. May as well just type this as NSInteger and avoid the cast below.\n. This is actually incorrect; you are passing sizeof(buffer) but it does not have that much space to write into.  You can misuse the new APIs just as much as the old ones, really ;-)  It won't matter in this case but sizeof(buffer) - 100 is more correct.\n. is there a reason why object_getClass() should not be used always?  If we are mocking something, seems like we should be invoking methods on the actual class no matter what.\n. Keep in mind that -retainArguments will also retain the target, plus any future target (if this invocation is used with -invoke or -invokeWithTarget:).  So, if the target is self (unsure if that is possible in this context) then this is creating a retain loop and the mock won't ever dealloc.\nIf the target is never used, it might be worthwhile setting the target to nil before calling -retainArguments on any stored NSInvocation.\n. Another option would be to clear the target before calling -retainArguments, and when actually needing to use the invocation, make a copy of the invocation and call invokeWithTarget: on that.  If we can assume the target is always \"self\".  If not, maybe make the original target an \"assign\" associated object (original target) so we can get a reference back out later (without having it retained), and hope that argument is not dealloced (targets probably should be naturally retained elsewhere I'd guess during the test).\nI did something like this in https://github.com/Collect3/CTAppearance/pull/4 .\nAnd really, arguments need to be retained if any of them are objects, not just if one of them happens to be a char * -- that seems a little odd.\nRequiring calls to -stopMocking when there are untold thousands of existing lines of test case code out there written over many years which would suddenly turn into memory leaks without -stopMocking is probably not the best idea.\n. OCMInvocationMatcher's matchesInvocation: method does not compare the target to determine a matching invocation.  Is the target used somewhere else?\n. I gave an implementation to check whether an object is a block in the comments to this pull request... it's probably safer to test the object directly rather than rely on the types, I'd guess.\nMight be able to make a helper function / macro to reduce some of the repetitive code, but looks good.\n. I think if you have code compiled with non-ARC blocks can be very different encoded types.  Even with ARC I have seen some differences, I think.  Maybe they have become more consistent on newer compilers but I have seen inconsistencies in the past (and OCMock could be running on lots of setups).  I think dispatch_block_t may be encoded very differently, and it's also easily possible to pass a block into a method argument which is typed to accept any object.  The common non-NSObject block superclass, while an implementation detail, is highly unlikely to change, and is a runtime check of the actual instance -- it should be much safer.\n. What about older versions of Xcode?  OCMock gets used in lots of development environments.\nAnd also, the type check will fail if an argument is typed as \"id\", but a block happens to be passed into it (say addObject: on an NSArray, if code creates an array of blocks, say).\nBut yes, it's up to Erik ;-)\n. ",
    "kaishin": ":+1:\n. ",
    "phatmann": ":+1: \n. ",
    "ryanwmarsh": "When do you think cocoapods will be updated with this change?\n. ",
    "foulkesjohn": "Could do with this getting released too\n. The ArrangeInvocation is a helper class for creating the invocation to stub as in my codebase there are a lot of the same stubs happening. The implementation looks something like this:\ntypedef void (^Invocation)(NSInvocation *);\n+ (Invocation)successfulInvocationWithParameter:(id)parameter atIndex:(NSInteger)index\n{\n  return ^(NSInvocation *invocation) {\n    void (^completionHandler)(id, NSError *);\n    [invocation getArgument:&completionHandler atIndex:index];\n    completionHandler(param, nil);\n  };\n}\nI also couldn't replicate the issue away from my main code base, which is frustrating. The code I provided probably doesn't compile as I put it as more of an example of how I was using it incase I was doing something wrong.\nI've taken to just using OCMExpect and OCMVerifyAll which works around the issue, if I get time to look at it again soon I will.\n. I did try the suggestions in that comment but they didn't seem to help. I think my issue is something with Specta, but it needs more investigation. Thanks for taking time to look into it\n. ",
    "twobitlabs": "@erikdoe if you could create a release tag, I'd be happy to push it to CocoaPods\n. Done. https://github.com/CocoaPods/Specs/commit/6bd088fba1586032db14c2364c4ed228dc323c98\n. ",
    "zacwest": "Thank you, this is an amazing addition that really helps make writing tests easier. This should be part of the regular distribution.\n. ",
    "bgerstle": "No, I didn't notice.  Unfortunately, the only way I could seem to reproduce the failure is by asking a friend to run the tests on their machine which has OSX 10.8 installed.  Before that, I tried cleaning and running the tests after setting the base SDK to 10.8 (on my machine running 10.9), but the test passed.\nI don't have a 10.8 machine handy, so I'll try setting up a virtual install to debug this later.\n. Should be good to go now:\nhttps://travis-ci.org/erikdoe/ocmock/builds/14176846\nI gave up on my mock inception (a mock of a mock), and removed my modifications to NSObject+OCMAddtions since NSProxy doesn't respond to +instanceMethodForSelector.\n. tests are passing locally and I'm not sure why the travis build timed out.\n. @carllindberg @erikdoe sorry, but could you take a second to help me figure out why the build is failing? sorry this PR has been open so long.\n. ",
    "parallaxe": "Sorry answering that late! To your comment of my first commit with the typedefs - thank you for your investigation. I will try to reproduce it as you said and adjust my implementation.\nTo my second commit - it was more like a try-out and i didn't know that any further commits on my fork will be appended to my current pull request - sorry, I'm going to revert it, as I have to do further investigations what implications these changes will have (I have a case where the changes made my tests run correct, but maybe it was just a side-effect)\n. I invested some further time to reproduce the behavior carllindberg described in his comment and applied his approach and enhanced the unit-test. \nAlso, i reverted the change from d9d5a22 that was a workaround of a bug that occurred as my unit-test-target of my app linked twice to the dropbox-sdk (one time the app itself, second time the unit-test-target), so that i got two different class-instances for DBSession while running the test (phu, that was tricky to track down).\nIt should be save now to merge it into the master-branch.\n. ",
    "rpranata": "Sorry, I put the pull request to the wrong repository.\n. ",
    "imhuntingwabbits": "Hmm, let me address desirability first. I made this change to resolve this issue:\n```\n$ git clone ... ocmock\n$ cd ocmok\n$ ruby Tools/build.rb\nbuild runs ...\nlipo -create -output build/Release/libOCMock.a build/Release-*/libOCMock.a\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file: build/Release-*/libOCMock.a (No such file or directory)\nmkdir -p /tmp/ocmock.3957/Products/iOS\ncp -R build/Release/libOCMock.a /tmp/ocmock.3957/Products/iOS\ncp: build/Release/libOCMock.a: No such file or directory\ncp -R build/Release-iphoneos/OCMock /tmp/ocmock.3957/Products/iOS\ncp: build/Release-iphoneos/OCMock: No such file or directory\nopen /tmp/ocmock.3957\n$ \n```\nSo the build ends up with no products, but the real issue is that lipo fails to combine the various flavors of the iOS build so you can't actually use any of the generated libraries (unless you specify the correct one for different hardware).\nRe: Xcode build collision issues\nThis fix isn't enough to create a truly isolated build. I think swizzling xcodebuild directly would be a better fix for that, i.e. you could encapsulate the entire build inside the tmp directory you create:\n$ xcodebuild OBJROOT=/tmp/ocmock/Build/Intermediates SYMROOT=/tmp/ocmock/Build -showBuildSettings\nI'll give that a go and see what happens.\n. This commit overrides OBJROOT / SYMROOT through Xcode build and works on my system. I haven't tested it on anything that uses more recent build settings though.\nhttps://github.com/imhuntingwabbits/ocmock/commit/4668ba8f6a693a02f132a5132b11451812806f68\n. It looks like we could fake the signature with some appropriate sleuthing:\n```\n- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector\n{\n  NSMethodSignature signature = [mockedClass instanceMethodSignatureForSelector:aSelector];\n  if (signature == nil) {\n    objc_property_t property = class_getProperty(mockedClass, [NSStringFromSelector(aSelector) cStringUsingEncoding:NSASCIIStringEncoding]);\n    if (property) {\n      const char attrsStr = property_getAttributes(property);\n      if (attrsStr) {\n        NSArray components = [[NSString stringWithCString:attrsStr\n                                                  encoding:NSASCIIStringEncoding] componentsSeparatedByString:@\",\"];\n        BOOL isDynamic = NO;\n        for (NSString *component in components) {\n          if ([component isEqualToString:@\"D\"]) {\n            //property is @dynamic, but we can synthesize the signature\n            isDynamic = YES;\n          }\n        }\n    if (isDynamic) {\n      NSString *fullStr = [NSString stringWithCString:attrsStr\n                                             encoding:NSASCIIStringEncoding];\n      char typeChar = [fullStr characterAtIndex:1];\n      signature = [NSMethodSignature signatureWithObjCTypes:[[NSString stringWithFormat:@\"%c\", typeChar] UTF8String]];\n    }\n  }\n}\n\n}\n  return signature;\n}\n```\nThat signature isn't actually correct, it should look something like this:\ndownloadTaskWithURL: - @24@0:8@16\n. Sorry for the delay, got busy at work but I'll take a look at this tonight. Mocking the setter should just require synthesizing the method signature in the same way as the getter.\n. https://github.com/erikdoe/ocmock/pull/240\n. I think so given you merged my PRs.\n. Will do, I'll keep things separated in the future.\n. It seems simple enough to remove the exceptions tracking entirely, I'm not sure I understand the value of this since the error message it prints out is rather obtuse (why does it matter if exceptions were thrown during the test run?).\nI see two options, but believe I misunderstand the intent of this code:\n1. Wrap expected exceptions in a known wrapper (perhaps a specific exception name) such that they may be filtered and ignored by this catch.\n2. Remove the exception tracking entirely.\n. Upon further investigation it appears this is caused by the implementation for methodSignatureForSelector:.\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n    NSMethodSignature *signature = [mockedClass instanceMethodSignatureForSelector:aSelector];\n    if(signature == nil)\n    {\n        signature = [NSMethodSignature signatureForDynamicPropertyMatchingSelector:aSelector inClass:mockedClass]; \n    }\n    return signature;\n}\nThis returns nil for all class methods that make it past forwardingTargetForSelector: because mocks no longer have direct access to their recorders when using the old style syntax. Maybe this works with the macros because of the macro state?\nEDIT: This doesn't work with the new style syntax either\nThis feels like an architectural flaw, it seems like subclasses / instances of OCMockObject need direct access to the recorders they create to do matching for fowardingTargetForSelector: and methodSignatureForSelector:. At least OCClassMockObject seems to need this to be able to locate methods that were mocked as class methods.\n. Wow... I realized this is the bug:\n[classMock foo];\nshould be\n[TestClassWithClassMethods foo];\nAnd the tests pass! Sigh...\n. The architectural issue I have is that this approach eliminates the ability to validate the exception and treats all exceptions as failures, which feels weird for explicitly expected exceptions. -verifyAtLocation: serializes the exception (and only the first exception even if there are many) to a string message which is then reported (usually not thrown) through recordFailureWithDescription:inFile:atLine:expected: in OCMReportFailure.\nThe intent of the test that I wrote is to ensure that exactly the expected exception is returned inline from the method invocation. Swallowing it allows control to continue past the point of the invocation making it impossible to validate any recovery logic in the code under test.\nI believe an example test that would take advantage of that approach would look something like this:\n``` objective-c\n- (void)testExceptionRecovery {\n  id mock = [OCMockObject partialMockForObject:objectUnderTest];\n  XCTAssertNoThrow([objectUnderTest doSomethingThatHandlesExceptions]);\n  XCTAssertNotNil(objectUnderTest.somethingThatShouldHaveBeenSetIfAnExceptionWasThrown);\n  [mock verify];\n}\n//OR\n- (void)testExceptionPropogatesOut {\n  id mock = [OCMockObject partialMockForObject:objectUnderTest];\n  XCTAssertThrowsSpecificNamed([objectUnderTest doSomethingThatDoesntHandleExceptions], [MyCustomException class], @\"CustomExceptionName\")\n  [mock verify];\n}\n```\n. In my tests thats what I observed as well, I think the one case I probably forgot to evaluate was instances of OCMPartialMockObject, I'm not sure if those follow a different code path.\n. Interesting, I cut the branch this happens on from issue #218 and merged up #235 in to it. I think the right way to proceed about this then is in that PR. Feel free to close this out and I'll make a note over there.\n. I have these changes stashed in a branch here: https://github.com/imhuntingwabbits/ocmock/tree/issue-246\n. Track through https://github.com/erikdoe/ocmock/issues/241\n. Don't mock NSManagedObject. It will never work.. @Applitom am I reading your change correctly? It looks like you're attempting to mock methods on your classes before CoreData has scribbled them in to the runtime?. @givip why do you need a partial mock of a managed object?\nSwizzling the metaClass won't help races on selectors that don't exist in the runtime yet.. @erikdoe FWIW I'm not sure what OCMock is going to do here. As far as I can tell these issues are based on races with the initialization of the CoreData stack, which is a private implementation detail to the framework.\nIn fact some classes / selectors aren't written in to the runtime until the objects are used by an instance of NSManagedObjectContext. Without materializing a full stack in memory \"this will never work\".\nThe fact that this changed across major OS releases isn't surprising, and any test code that functions today given a certain initialization loop is inherently subject to failure in future releases as they permutations of loop change for future optimizations.. I think this proposal is fine on the face of it. -stopMocking IMO is essentially -tearDown for the mock. But using it afterwards should fail aggressively with appropriate warnings / messages.\nWould you consider amending your diff to add a fault, maybe NSException, or if we want to be really aggressive a hard coded call to abort() if -expect is called on a mock after -stopMocking?\nAlso if I read this right -stopMocking is now a required call for all types of mocks, not just class or partials?. > Same thing as #364?\nA slightly more discrete subset, although I do think 364 makes some valuable additions.. ",
    "philippec": "That's exactly what I had in mind, which is why it only goes to iOS 7 if you are building for 64 bit.\nWe encountered this issue while building for 64 bits ourselves.\n. ",
    "StatusReport": "Sorry for that, I didn't play nice with OSX :bug: \n. We use Specta+Expecta as well, so :+1:.\n. The problem stems from the fact that -[OCMockObject handleInvocation] doesn't call [anInvocation retainArguments], and the invocation is stored for later use. This is usually not an issue since the object that is being passed to OCMVerify is still alive, but in some cases (for example, when passing literals to the verify macro directly) this is not the case. However, just adding retainArguments won't solve the problem, and there's an active discussion in #235 on how to try and make it work correctly.\n. ",
    "eskerber": "Is there a known workaround for this? It seems now I simply can't mock out value types when running against 64-bit.\n. ",
    "dblock": "cc: @CharlesHarley, had wrong name in there ...\n. Bump. LMK if you want me to do any of these things to get this merged. It's probably a good idea, but I'd want to make it a separate PR.\n. ",
    "JoshuaGross": "Thanks for the feedback!  I fixed the build; I had screwed up some of the conditional logic. More specific unit tests should be added to this anyway.\nI think all I really needed was stubbing but got carried away with trying to make OCMock \"more flexible\". I definitely prefer something like [[aMockObject expect] atLeastOnce]. If I have a chance this week I'll clean up the PR to stop overloading expect, add some number-of-expectations methods and add unit tests.\n. ",
    "madsolar8582": "+1, I like this change.\n. :+1: \n. :+1: \n. :+1: \n. :+1: \n. :+1: \n. Yup, removed the subscripting.\n. @carllindberg fixed the incorrect sizeof\n. I'm encountering the same issue. The test is as follows:\n```objective-c\nMyController controller = [[MyController alloc] init];\nOCMockObject mockNotificationCenter = [OCMockObject partialMockForObject:NSNotificationCenter.defaultCenter];\n[[mockNotificationCenter expect] postNotificationName:MyControllerViewDidLoadNotification object:controller];\n[controller viewDidLoad];\n[mockNotificationCenter verify];\nXCTAssertEqual(controller.edgesForExtendedLayout, UIRectEdgeNone);\nXCTAssertFalse(controller.webView.translatesAutoresizingMaskIntoConstraints);\nXCTAssertNotNil(controller.activityIndicator);\n[mockNotificationCenter stopMocking];\n```\nGranted, I can switch this particular test to leverage a XCTestExpectation via expectationForNotification:object:handler:, but other tests are experiencing this issue.\nI was able to confirm what @sdefresne reported and that it is crashing during the dealloc of the mock object when the release is sent to the mock's array of NSInvocations.\nhttps://github.com/erikdoe/ocmock/blob/812b5db86a46db8a4a5d45464fe3229532fd9f29/Source/OCMock/OCMockObject.m#L108-L115\nEnvironment:\nOCMock 3.4.1 (static library)\nXcode 9.2 on macOS 10.13.3\niOS 11.2 SDK\n\n . I believe that this is a side effect of https://github.com/erikdoe/ocmock/commit/ae40cea3bb4c8bef739022fa96690467f3e6348d since partial mocks also mock their class.. Turning on Guard Malloc also found some issues. In the OCMockObjectClassMethodMockingTests, the testStopMockingDisposesMetaClass and testSecondClassMockDisposesFirstMetaClass throw memory access errors after the stopMocking calls since the backing const char* storage for the sublcass name(s) were deallocated. I was able to fix this by copying the subclass name(s):\n```obj-c\n- (void)testStopMockingDisposesMetaClass\n{\n    id mock = [[OCClassMockObject alloc] initWithClass:[TestClassWithClassMethods class]];\nNSString *createdSubclassName = @(object_getClassName([TestClassWithClassMethods class]));\nXCTAssertNotNil(objc_lookUpClass(createdSubclassName.UTF8String));\n\n[mock stopMocking];\nXCTAssertNil(objc_lookUpClass(createdSubclassName.UTF8String));\n\n}\n```\n```obj-c\n- (void)testSecondClassMockDisposesFirstMetaClass\n{\n    id mock1 = [[OCClassMockObject alloc] initWithClass:[TestClassWithClassMethods class]];\n    NSString *createdSubclassName1 = @(object_getClassName([TestClassWithClassMethods class]));\n    XCTAssertNotNil(objc_lookUpClass(createdSubclassName1.UTF8String));\nid mock2 = [[OCClassMockObject alloc] initWithClass:[TestClassWithClassMethods class]];\nNSString *createdSubclassName2 = @(object_getClassName([TestClassWithClassMethods class]));\nXCTAssertNotNil(objc_lookUpClass(createdSubclassName2.UTF8String));\n\n[mock1 stopMocking];\n[mock2 stopMocking];\n\nXCTAssertNil(objc_lookUpClass(createdSubclassName1.UTF8String));\nXCTAssertNil(objc_lookUpClass(createdSubclassName2.UTF8String));\n\n}\n```. Unfortunately, I think I've hit my debugging with LLDB knowledge limit as I can't figure out what object the retain is crashing on:\n``\n(lldb) down\nframe #0: 0x00000001042c5fa7 libobjc.A.dylibobjc_retain + 7\nlibobjc.A.dylib`objc_retain:\n->  0x1042c5fa7 <+7>:  movq   (%rdi), %rax              ; Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\n    0x1042c5faa <+10>: testb  $0x4, 0x20(%rax)\n    0x1042c5fae <+14>: jne    0x1042c6ac2               ; objc_object::sidetable_retain()\n    0x1042c5fb4 <+20>: leaq   0x8f5eb5(%rip), %rax      ; SEL_retain\n(lldb) di -f\nlibobjc.A.dylib`objc_retain:\n    0x1042c5fa0 <+0>:  testq  %rdi, %rdi\n    0x1042c5fa3 <+3>:  je     0x1042c5fc3               ; <+35>\n    0x1042c5fa5 <+5>:  js     0x1042c5fc5               ; <+37>\n->  0x1042c5fa7 <+7>:  movq   (%rdi), %rax\n    0x1042c5faa <+10>: testb  $0x4, 0x20(%rax)\n    0x1042c5fae <+14>: jne    0x1042c6ac2               ; objc_object::sidetable_retain()\n    0x1042c5fb4 <+20>: leaq   0x8f5eb5(%rip), %rax      ; SEL_retain\n    0x1042c5fbb <+27>: movq   (%rax), %rsi\n    0x1042c5fbe <+30>: jmp    0x1042c8d80               ; objc_msgSend\n    0x1042c5fc3 <+35>: xorl   %edi, %edi\n    0x1042c5fc5 <+37>: movq   %rdi, %rax\n    0x1042c5fc8 <+40>: retq  \n(lldb) register read --all\nGeneral Purpose Registers:\n       rax = 0x0000000000000000\n       rbx = 0x00007b540000c6c0\n       rcx = 0x000000000000010c\n       rdx = 0x0000000107261380  libsystem_pthread.dylib_thread\n       rdi = 0x4000000000000000\n       rsi = 0x0000000000000000\n       rbp = 0x00007ffeed6c63b0\n       rsp = 0x00007ffeed6c61c8\n        r8 = 0x0000000000000001\n        r9 = 0x0000000000000001\n       r10 = 0x0000000000000000\n       r11 = 0x0000000000000000\n       r12 = 0x00007b1000051d80\n       r13 = 0x00007b540000c580\n       r14 = 0x00007b1000051d88\n       r15 = 0x00007b080001dea0\n       rip = 0x00000001042c5fa7  libobjc.A.dylibobjc_retain + 7\n    rflags = 0x0000000000000206\n        cs = 0x000000000000002b\n        fs = 0x0000000000000000\n        gs = 0x0000000000000000\n       eax = 0x00000000\n       ebx = 0x0000c6c0\n       ecx = 0x0000010c\n       edx = 0x07261380\n       edi = 0x00000000\n       esi = 0x00000000\n       ebp = 0xed6c63b0\n       esp = 0xed6c61c8\n       r8d = 0x00000001\n       r9d = 0x00000001\n      r10d = 0x00000000\n      r11d = 0x00000000\n      r12d = 0x00051d80\n      r13d = 0x0000c580\n      r14d = 0x00051d88\n      r15d = 0x0001dea0\n        ax = 0x0000\n        bx = 0xc6c0\n        cx = 0x010c\n        dx = 0x1380\n        di = 0x0000\n        si = 0x0000\n        bp = 0x63b0\n        sp = 0x61c8\n       r8w = 0x0001\n       r9w = 0x0001\n      r10w = 0x0000\n      r11w = 0x0000\n      r12w = 0x1d80\n      r13w = 0xc580\n      r14w = 0x1d88\n      r15w = 0xdea0\n        ah = 0x00\n        bh = 0xc6\n        ch = 0x01\n        dh = 0x13\n        al = 0x00\n        bl = 0xc0\n        cl = 0x0c\n        dl = 0x80\n       dil = 0x00\n       sil = 0x00\n       bpl = 0xb0\n       spl = 0xc8\n       r8l = 0x01\n       r9l = 0x01\n      r10l = 0x00\n      r11l = 0x00\n      r12l = 0x80\n      r13l = 0x80\n      r14l = 0x88\n      r15l = 0xa0\nFloating Point Registers:\n     fctrl = 0x037f\n     fstat = 0x0000\n      ftag = 0x0000\n       fop = 0x0000\n     fioff = 0x00000000\n     fiseg = 0x0000\n     fooff = 0x00000000\n     foseg = 0x0000\n     mxcsr = 0x00001fa0\n  mxcsrmask = 0x0000ffff\n     stmm0 = {0x37 0xcd 0x02 0x00 0x00 0x00 0x00 0x00 0xff 0xff}\n     stmm1 = {0xef 0x1b 0x35 0xed 0xff 0xff 0x01 0x00 0xff 0xff}\n     stmm2 = {0xff 0xff 0x01 0x00 0x00 0x00 0x00 0x00 0xff 0xff}\n     stmm3 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     stmm4 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     stmm5 = {0x94 0xff 0x73 0xff 0x00 0x00 0x00 0x00 0xff 0xff}\n     stmm6 = {0x18 0xf8 0x8e 0x01 0x00 0x00 0x00 0x00 0xff 0xff}\n     stmm7 = {0x00 0x00 0x70 0xff 0x00 0x00 0x00 0x00 0xff 0xff}\n      ymm0 = {0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm1 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm2 = {0xe0 0x7a 0x17 0x00 0xe0 0x7a 0x17 0x00 0xe0 0x7a 0x17 0x00 0xe0 0x7a 0x17 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm3 = {0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm4 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm5 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm6 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm7 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm8 = {0x31 0xba 0x00 0x68 0x47 0xe2 0xa6 0x49 0xcc 0xfa 0xdd 0x46 0x02 0xa8 0x39 0xf4 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      ymm9 = {0xe8 0xa8 0xbf 0x1f 0xaf 0x4a 0x19 0x56 0x63 0xb0 0xc4 0x10 0x61 0x18 0xfd 0xe4 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     ymm10 = {0xa7 0x84 0xc5 0x98 0x88 0x28 0x0e 0x5c 0x5a 0xef 0xdd 0x0d 0x58 0x89 0x9e 0xdc 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     ymm11 = {0x08 0x8f 0x43 0xf2 0x80 0xa7 0x4d 0xae 0xda 0x48 0x90 0xa3 0x82 0xc1 0x0e 0x7f 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     ymm12 = {0x60 0x24 0x91 0xe1 0xe0 0x83 0xdc 0x4f 0x3a 0xcb 0x4c 0xec 0xb8 0x0a 0x42 0x93 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     ymm13 = {0x27 0x08 0x4d 0x8d 0xc7 0x8b 0x91 0xc2 0xfd 0x40 0xdd 0x2e 0x45 0x4a 0x9f 0xbd 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     ymm14 = {0xb1 0xd3 0x37 0xe3 0x76 0x58 0xa6 0x21 0x8b 0x18 0x7b 0x0f 0xce 0x52 0xe4 0xb2 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n     ymm15 = {0xde 0xa4 0xbc 0x66 0xa9 0xac 0x68 0x20 0xa1 0xee 0x26 0x60 0xa6 0x02 0xdb 0xbd 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm0 = {0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm1 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm2 = {0xe0 0x7a 0x17 0x00 0xe0 0x7a 0x17 0x00 0xe0 0x7a 0x17 0x00 0xe0 0x7a 0x17 0x00}\n      xmm3 = {0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff}\n      xmm4 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm5 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm6 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm7 = {0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}\n      xmm8 = {0x31 0xba 0x00 0x68 0x47 0xe2 0xa6 0x49 0xcc 0xfa 0xdd 0x46 0x02 0xa8 0x39 0xf4}\n      xmm9 = {0xe8 0xa8 0xbf 0x1f 0xaf 0x4a 0x19 0x56 0x63 0xb0 0xc4 0x10 0x61 0x18 0xfd 0xe4}\n     xmm10 = {0xa7 0x84 0xc5 0x98 0x88 0x28 0x0e 0x5c 0x5a 0xef 0xdd 0x0d 0x58 0x89 0x9e 0xdc}\n     xmm11 = {0x08 0x8f 0x43 0xf2 0x80 0xa7 0x4d 0xae 0xda 0x48 0x90 0xa3 0x82 0xc1 0x0e 0x7f}\n     xmm12 = {0x60 0x24 0x91 0xe1 0xe0 0x83 0xdc 0x4f 0x3a 0xcb 0x4c 0xec 0xb8 0x0a 0x42 0x93}\n     xmm13 = {0x27 0x08 0x4d 0x8d 0xc7 0x8b 0x91 0xc2 0xfd 0x40 0xdd 0x2e 0x45 0x4a 0x9f 0xbd}\n     xmm14 = {0xb1 0xd3 0x37 0xe3 0x76 0x58 0xa6 0x21 0x8b 0x18 0x7b 0x0f 0xce 0x52 0xe4 0xb2}\n     xmm15 = {0xde 0xa4 0xbc 0x66 0xa9 0xac 0x68 0x20 0xa1 0xee 0x26 0x60 0xa6 0x02 0xdb 0xbd}\nException State Registers:\n    trapno = 0x00000003\n       err = 0x00000000\n  faultvaddr = 0x0000000101ba8000\n(lldb) x/16x $rax\nerror: memory read failed for 0x0\n(lldb) register read rax\n     rax = 0x0000000000000000\n```\nI'm attaching the .xcresult file for the test run as it contains the crashes: TestResults.xcresult.zip\nTo look at the crashes, unzip and then right-click the TestResults.xcresults file and select Show Package Contents. The crashes are in the Attachments folder.\n. @carllindberg Sorry for summoning you out of the blue, but you are one of the few people that I know that might be able to help me figure this out.. The issue identified by guard malloc was resolved in 662bbeb0fa408d3d6eaeba7b9721caef8be4de9e. The issue identified by UBSan was partially addressed by d00d8f37a97e415c65617edf8521568dc41cb263. Since class_addMethod still uses the originalIMP, it must not be null:\n\nTo ignore this, the test causing this can be annotated with __attribute__((no_sanitize(\"nullability-arg\"))) to skip the check.. Looks like the Travis build failed for this particular run due to an issue in Apple's simulator control. My build of the same commit succeeded: https://travis-ci.com/madsolar8582/ocmock/builds/90191297. Thanks Erik. I merged your current changes onto this branch.. @carllindberg, why not [self class]? \n. Like this?\nobjective-c\nstrlcpy(buffer, cStringPtr, sizeof(buffer));\nstrlcpy(buffer + 100, \"...\", sizeof(buffer) - 100);\n. Because iOS 11 dropped the 32-bit architectures (armv7 & armv7s), you have to specify the OS so that the iPhone 5 can run. The latest simulator OS that can run 32-bit architectures happens to be 10.3.1 included in Xcode 10+.. A little bit of future proofing. Judging by the age of the device, it may get dropped by Apple soon, so when migrating Xcode versions in the future, it'll be one less thing to worry about. Also, when Apple finally adds arm64e to the default build toolchain, a parallel destination can be added such as the Xs or Xr with very little code change.. The CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF now warns if an iVar is included in a scope that requires self. By explicitly using self, the warning is silenced.  . I can remove this one if you want and save it for when I fully figure out all of the issues with #362. I used the autoboxing to avoid needing to use the C API since that requires string length.. ",
    "bcharp": "I have a problem related to this, I'm using cocoapods with ocmock in version 2.2.3, can you give a date of release for a version including this fix ?\n. ",
    "iluuu1994": "Thank you Erik for the explanation. I don't think that this little test is worth spending hours on trying to implement something that might not even be achieved. I was just wondering if there was a reason, or if it's a bug.\nThanks for your help.\n. ",
    "badeleux": "Ok, I've created example project to visualise this problem. Please clone this repo: https://github.com/badeleux/OCMockPodTest\nMy output for test method:\n2014-02-14 08:27:01.406 OCMockPodTest[2820:70b] TEST STUB: /Volumes/test5M /Volumes/test5M\n2014-02-14 08:27:11.008 OCMockPodTest[2820:70b] TEST STUB: /Volumes/test5M ~/Library/Application Support/iPhone Simulator/7.0.3/Applications/7E89CD46-D81B-45E0-96CA-B89C8F1B0383/tmp/Incomplete\n2014-02-14 08:27:21.919 OCMockPodTest[2820:70b] TEST STUB: /Volumes/test5M /Volumes/test5M\nThis demo presents my problem. Stubbing mechanism works for ViewController which is in app target. Moreover stubbed method cacheFolder works in test file (OCMockPodTestTests.m:39 and 41) but no longer works in ViewController.m which is shown in line 40\n. Right. Thanks!\n. ",
    "iamleeg": "@carllindberg \"since you are a mock for a protocol, and -valueForKey: is probably not a method in the protocol, the mock object may not have any idea of what to do\" is exactly the issue. I -stub my key's accessor, but then -[NSProxy valueForKey:] gets called in the test. I don't particularly want to have to stub that too, I want a single action that says \"whatever route the SUT uses to grab the value for this key, give it this value\".\n. :+1:\n. ",
    "ibsh": "+1\n. ",
    "JD-": "You're right.\nFor the record if anyone else deals with the same issue I'm having : in my app I've got a return type having the form ^{OriginalClass}  (as opposed to ^{OriginalClass=#} ), even though it's a regular typedef to UIImage or NSImage. \nI haven't been able to reproduce my issue in a test case, the closest case I had found from the Type Encodings documentation was to add another level of indirection to make the \"=#\" disappear.\nI think my issue might somehow be related to the fact that  [NSMethodSignature returnType] encoding is implementation-specific, as stated in NSMethodSignature's documentation.\n. If the compiler only has the forward declaration without header, you will get \"^{MyUndefinedClass=}\nI've tried replacing \nobjective-c\n@interface InterfaceForTypedef : NSObject\nwith  \nobjective-c\n@interface InterfaceForTypedef : NSImage\nand it produces the same bug as the one in my app ==> (testWithTypedefReturnType fails because the returned type is \"^{InterfaceForTypedef} \"\n. ",
    "x2on": ":exclusive => true for OCMock in the test target fixes that issue,\n. But I need a nil value - I could use the old syntax, with that it works.\nBut would be nice to get this fixed :)\nAm Dienstag, 1. Juli 2014 schrieb Oxy-AnthonyM :\n\n.andReturn takes an id argument, but defaults to an NSValue. It looks when\nyou pass nil, it is still reading it as an NSValue signature, even though\nthe value is nil. So your return value is of the wrong type.\nYou need to be passing it an NSString instead of an NSValue here. Try this:\nOCMStub([mock objectForKeyPath:@\"some.keyPath\"]).andReturn(@\"\");\nIt might not give you a \"nil\" value, but it's the next best thing.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/erikdoe/ocmock/issues/106#issuecomment-47688599.\n. Found the reason.\n\nYou need to use \nobjective-c\nOCMStub(ClassMethod([dateMock timeIntervalSinceReferenceDate])).andReturn(NSTimeIntervalSince1970);\nbecause timeIntervalSinceReferenceDate is a property and a class method...\n. ",
    "wessmith": "@x2on Thanks. This just made my day!\n. ",
    "davebcn87": "I have the same problem but :exclusive => true does not fix it... Any idea?\n. Just found the problem. the class method was named:\n+ (void)setDelegate:(id)delegate;\nand there was an instance property called delegate and this was ambigous...\n. I have the same problem. The tests results are ok, but when I have the exception breakpoint activated it stops in the same line as @Panajev's code:\n\n\nThis is the result of the test after I have disabled the breakpoint:\n\n. What I get using NSStringFromSelector is CA_setterForProperty:\nThis is the mock that I'm trying to create:\nOCMClassMock([UITableView class]);\nI'm going to try master version and I tell you if it's fixed.\n. I still have the same problem using last master commit...\n. I've tried to use it on OCMock's iOS7 example and when I activate exception breakpoint it only shows assembler code, but is the same class:\niOS7ExampleTests`+[NSObject(OCMAdditions) instanceMethodForwarderForSelector:] at NSObject+OCMAdditions.m:23:\nI've also created a new project to isolate from libraries and frameworks that I use in my code and I get the same problem. \nThe testing environment is the same as yours:\nOS X 10.9.4\nXcode 5.1.1\niOS SDK 7.1\nHave you activated all exceptions breakpoint? Compiling without breakpoints works ok for me...\n. Great, thank you @erikdoe. \n. Now it's fixed! Thank you very much!\n. ",
    "rojasvictor91": "I just tried it and still getting the error\nare you using the 2.2.3 version of OCMock?\n. ",
    "mono0926": "I fixed as below.\nIs this okay?\nobjective-c\n// OCMBoxedReturnValueProvider.m\n-   if((strcmp(returnType, valueType) != 0) && !(returnType[0] == 'B' && valueType[0] == 'c'))\n+   if((strcmp(returnType, valueType) != 0) && !(returnType[0] == 'B' && valueType[0] == 'c') &&  !(returnType[0] == 'Q' && valueType[0] == 'q') &&  !(returnType[0] == 'q' && valueType[0] == 'i') && !(returnType[0] == 'Q' && valueType[0] == 'i'))\n. Okay, thanks a lot for your replies.\nShould I close this issue?\n. Okay, thank you again!\n. ",
    "grantjk": "Just noticed that today as well. We ended up going with @erikdoe 's solution for a CGFloat. Seemed to work.\n. The tests were executed with the third one first, followed by the false failure.\nHere's the setup and teardown methods:\n```\n- (void)setUp\n{\n    [super setUp];\n    self.video = OCMClassMock([Video class]);\n    self.delegate = OCMProtocolMock(@protocol(MoviePlayerObserverDelegate));\n    self.videoService = OCMClassMock([VideoNetworkService class]);\n    self.player = OCMClassMock([MPMoviePlayerController class]);\nself.observer = [[MoviePlayerObserver alloc] initWithController:self.player\n                                                             video:self.video\n                                                    networkService:self.videoService\n                                                          delegate:self.delegate];\n\n}\n\n(void)tearDown\n{\n    [self.delegate stopMocking];\n    self.videoService = nil;\n    self.video = nil;\n    self.delegate = nil;\n    self.observer = nil;\n    [super tearDown];\n}\n``\n. I should note I've tried all 3 different syntaxes for the first test, usingOCMVerifyas well as the old syntax\n. @erikdoe That does appear to be what's happening - the observer from the first test (the third one in the list) run is leaking into the other tests. It's not being properly dealloc'ed at the end of the test. However, when I remove therejectandverify` calls from that test, the object gets properly dealloc'ed. Here's the logs:\n\nLeaking\n```\nTest Suite 'Selected tests' started at 2015-01-30 14:55:48 +0000\nTest Suite 'Tests.xctest' started at 2015-01-30 14:55:48 +0000\nTest Suite 'MoviePlayerObserverTests' started at 2015-01-30 14:55:48 +0000\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenNotificationPostedFromADifferentPlayer]' started.\n2015-01-30 09:55:48.986[30456:782196] testing: \n2015-01-30 09:55:48.986[30456:782196] notif recieved: \nMoviePlayerObserverTests.m:81: error: -[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenNotificationPostedFromADifferentPlayer] : failed: caught \"NSInternalInconsistencyException\", \"movieObserverDidFailToLoadVideo:: explicitly disallowed method invoked: movieObserverDidFailToLoadVideo:\"\n(\n)\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenNotificationPostedFromADifferentPlayer]' failed (0.266 seconds).\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenVideoStopsWithoutError]' started.\n2015-01-30 09:55:49.252[30456:782196] notif recieved: \n2015-01-30 09:55:49.252[30456:782196] notif recieved: \n2015-01-30 09:55:49.252[30456:782196] dealloc: \nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenVideoStopsWithoutError]' passed (0.001 seconds).\nTest Case '-[MoviePlayerObserverTests testThatItNotifiesDelegateWhenVideoFailsToPlay]' started.\n2015-01-30 09:55:49.254[30456:782196] testing: \n2015-01-30 09:55:49.254[30456:782196] notif recieved: \n2015-01-30 09:55:49.254[30456:782196] dealloc: \nMoviePlayerObserverTests.m:58: error: -[MoviePlayerObserverTests testThatItNotifiesDelegateWhenVideoFailsToPlay] : failed: caught \"NSInternalInconsistencyException\", \"movieObserverDidFailToLoadVideo:: explicitly disallowed method invoked: movieObserverDidFailToLoadVideo:\"\n(\n)\nTest Case '-[MoviePlayerObserverTests testThatItNotifiesDelegateWhenVideoFailsToPlay]' failed (0.080 seconds).\nTest Suite MoviePlayerObserverTests' failed at 2015-01-30 14:55:49 +0000.\n     Executed 3 tests, with 2 failures (2 unexpected) in 0.347 (0.348) seconds\nTest Suite 'Tests.xctest' failed at 2015-01-30 14:55:49 +0000.\n     Executed 3 tests, with 2 failures (2 unexpected) in 0.347 (0.349) seconds\nTest Suite 'Selected tests' failed at 2015-01-30 14:55:49 +0000.\n     Executed 3 tests, with 2 failures (2 unexpected) in 0.347 (0.350) seconds\n```\nWithout reject line\n```\n- (void)testThatItDoesNotNotifyTheDelegateWhenNotificationPostedFromADifferentPlayer\n{\n    NSLog(@\"testing: %@\", self.observer);\n//    [[self.delegate reject] movieObserverDidFailToLoadVideo:OCMOCK_ANY];\nNSDictionary *info = @{ MPMoviePlayerPlaybackDidFinishReasonUserInfoKey : @(MPMovieFinishReasonPlaybackError) };\n[[NSNotificationCenter defaultCenter] postNotificationName:MPMoviePlayerPlaybackDidFinishNotification\n                                                    object:OCMClassMock([MPMoviePlayerController class])\n                                                  userInfo:info];\n\n//    [self.delegate verify];\n}\n```\nTest Suite 'Selected tests' started at 2015-01-30 14:52:00 +0000\nTest Suite 'Tests.xctest' started at 2015-01-30 14:52:00 +0000\nTest Suite 'MoviePlayerObserverTests' started at 2015-01-30 14:52:00 +0000\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenNotificationPostedFromADifferentPlayer]' started.\n2015-01-30 09:52:00.811[30377:778013] testing: <MoviePlayerObserver: 0x7fd1ba344fa0>\n2015-01-30 09:52:00.811[30377:778013] notif recieved: <MoviePlayerObserver: 0x7fd1ba344fa0>\n2015-01-30 09:52:00.811[30377:778013] dealloc: <MoviePlayerObserver: 0x7fd1ba344fa0>\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenNotificationPostedFromADifferentPlayer]' passed (0.002 seconds).\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenVideoStopsWithoutError]' started.\n2015-01-30 09:52:00.812[30377:778013] notif recieved: <MoviePlayerObserver: 0x7fd1ba34b430>\n2015-01-30 09:52:00.812[30377:778013] dealloc: <MoviePlayerObserver: 0x7fd1ba34b430>\nTest Case '-[MoviePlayerObserverTests testThatItDoesNotNotifyTheDelegateWhenVideoStopsWithoutError]' passed (0.001 seconds).\nTest Case '-[MoviePlayerObserverTests testThatItNotifiesDelegateWhenVideoFailsToPlay]' started.\n2015-01-30 09:52:00.814[30377:778013] testing: <MoviePlayerObserver: 0x7fd1ba3506f0>\n2015-01-30 09:52:00.814[30377:778013] notif recieved: <MoviePlayerObserver: 0x7fd1ba3506f0>\n2015-01-30 09:52:00.814[30377:778013] dealloc: <MoviePlayerObserver: 0x7fd1ba3506f0>\nTest Case '-[MoviePlayerObserverTests testThatItNotifiesDelegateWhenVideoFailsToPlay]' passed (0.001 seconds).\nTest Suite 'MoviePlayerObserverTests' passed at 2015-01-30 14:52:00 +0000.\n     Executed 3 tests, with 0 failures (0 unexpected) in 0.004 (0.005) seconds\nTest Suite 'Tests.xctest' passed at 2015-01-30 14:52:00 +0000.\n     Executed 3 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\nTest Suite 'Selected tests' passed at 2015-01-30 14:52:00 +0000.\n     Executed 3 tests, with 0 failures (0 unexpected) in 0.004 (0.007) seconds\n. ",
    "nrbrook": "Ok thanks. \nI had defined a description property on a class (forgetting the existing one) and OCMock was breaking which made it hard to figure out what was wrong. Although I guess with this change I might not have noticed and corrected it. \nNick\n\nOn 24 Mar 2014, at 02:21, carllindberg notifications@github.com wrote:\nYou didn't need to change the isKindOfClass NSString case -- that -description will never be nil, and even if it is, +stringWithFormat: handles it find. The only real needed change was to change the last line\nreturn [object description];\nto\nreturn [object description] ?: @\"\";\n-description should never return nil, but... it's always possible it can happen, so good to guard against it.\n\u2014\nReply to this email directly or view it on GitHub.\n. Or @\"<nil description>\"?\nAlso, just seen [object description] ?: @\"\";, wow, ?: you learn something new every day!\n. Sorry no I didn't actually test the build, I assumed it wouldn't break anything.. Still fails.... \n",
    "zaygraveyard": "Hi @escoz,\nI noticed that you might have a typo:\n[[mock expect] viewModel:self.viewModel didReceiveSearchError:[OCMArg any]];\nshould be\n[[mock expect] viewModel:self.viewModel didReceiveError:[OCMArg any]];\nCheers\n. @escoz can you do a \"Find in Workspace\" on \"ECSearchResultsViewModelDelegate\", maybe its defined somewhere else.\nCheers\n. ",
    "escoz": "Thanks @zaygraveyard, that was my mistake when typing the bug though. \nI've been looking into this more, and thing don't make much sense, unfortunately. When I declare the interface in the same .m file as the test, everything seems to run correctly. When I move it to a different .h that is imported, though, the test fails with the error above. \nI have over tests in the same file that use other methods on that interface, and they all run correctly. Any ideas? I'm trying to create a proper repro.\n. Actually, changing the name of the interface solves the issue. With the name \"ECSearchResultsViewModelDelegate\" it fails, but with anything else it works.\n. No, there's just one definition, in a .h with the same name. Making a project to repro this is quite hard, because the moment things change it starts working.. I'll need to do some more debugging.. \n. ",
    "OrangeDog": "Hmm, that's all in the same test method, but mine is in two separate test classes.\nThe only change I made to fix it was to move the class stub to a non-partial mock.\nI'll see if I can make a simpler reproduction.\n. ",
    "sryze": "Similar issue here, although with class mocks not partial ones. I've written a couple of helper methods like this to test alert actions:\n``` objective-c\n- (void)stubAndInvokeAlertActionWithTitle:title {\n    id alertControllerMock = OCMClassMock([UIAlertController class]);\n    OCMStub([[alertControllerMock ignoringNonObjectArgs] alertControllerWithTitle:[OCMArg any] message:[OCMArg any] preferredStyle:0]).andReturn(alertControllerMock);\nid alertActionMock = OCMClassMock([UIAlertAction class]);\nOCMStub([[alertActionMock ignoringNonObjectArgs] actionWithTitle:title style:0 handler:[OCMArg any]]).andDo(^(NSInvocation *invocation) {\n    void (^handler)(UIAlertAction *action);\n    [invocation getArgument:&handler atIndex:4];\n    if (handler != nil) {\n        handler(nil);\n    }\n}).andReturn(alertActionMock);\n\n}\n```\nand the weird thing is that [UIAlertController alertControllerWithTitle:message:preferredStyle] remains mocked after the tests in the containing XCTestCase are finished, i.e. this method returns the mock alert controller I created when running another test case.\nI haven't had any problems with mocking other classes' methods yet, perhaps they suffer from the same issue as well, I'll check it.\nAlso, after reading some documentation (should have done this earlier!) I'm not so sure it's a good idea to create class method mocks like this because it seems they stopMocking automatically when they go out of scope.... but if that's the case and alertControllerMock dies early how come my tests still work?\nEdit:\nAfter adding explicit calls to stopMocking my tests are working again, I guess I was doing it wrong, sorry!\n. I'm having a similar problem with OCMVerify and checkWithBlock, the test always crashes with EXC_BAD_ACCESS. I managed to reduce my test code to the following:\n``` objective-c\nimport \nimport \nimport \n@interface ExampleTests : XCTestCase\n@end\n@implementation ExampleTests\n\n\n(void)sendRequesUsingSessionManager:(AFHTTPSessionManager )sessionManager {\n    NSDictionary parameters = @{@\"param\": @\"value\"};\n    [sessionManager POST:@\"test\" parameters:parameters success:nil failure:nil];\n}\n\n\n(void)testExample {\n    id sessionManagerMock = OCMClassMock([AFHTTPSessionManager class]);\n    [self sendRequesUsingSessionManager:sessionManagerMock];\n    OCMVerify([sessionManagerMock POST:@\"test\" parameters:[OCMArg checkWithBlock:^BOOL(NSDictionary *parameters) {\n        return YES;\n    }] success:[OCMArg any] failure:[OCMArg any]]);\n}\n\n\n@end\n```\nWhen I turn on Enable Zombie Objects in Xcode, test execution breaks with the following message:\n*** -[__NSDictionaryI retain]: message sent to deallocated instance 0x7fbd8306f280\nIt seems that the parameters dictionary is released before it gets passed to the checkWithBlock block.\n. Can anybody please give an example of using invokeBlockWithArgs?\nI was getting a EXC_BAD_ACCESS when using it, so I figured I had to terminate the argument list somehow, however, appending nil or NSNull didn't help - now it's a compile error:\nToo many arguments provided to function-like macro invocation\nUse of undeclared identifier 'OCMStub'\nI'm using invokeBlockWithArgs like this:\nobjective-c\nOCMStub([readerMock loadTable:@\"store\" usingBlock:[OCMArg invokeBlockWithArgs:store, nil]]);\n. Nevermind, removing libPods.a actually worked after doing a clean. \n. @erikdoe Yes, that is what I'm saying (sorry if it wasn't clear).\nIndeed, it seems impossible to achieve this without changing the macros. Here's the nicest one I could come up with: \n``` objective-c\ndefine OCMSafeVerify(object, method) \\\n({ \\\n    _OCMSilenceWarnings( \\\n        if (![object isKindOfClass:[OCMockObject class]]) { \\\n            [NSException raise:NSInvalidArgumentException format:@\"OCMVerify argument is not a mock\"]; \\\n        } \\\n        [OCMMacroState beginVerifyMacroAtLocation:OCMMakeLocation(self, FILE, LINE)]; \\\n        [object method]; \\\n        [OCMMacroState endVerifyMacro]; \\\n    ); \\\n})\n```\nUsage is as follows:\nobjective-c\nOCMSafeVerify(object, someMethod:someArgument);\n(It doesn't work though, the type check seems to always return NOeven for mocks, I don't know why.)\n. ",
    "benzguo": ":+1: :smile:  :+1: \n. ",
    "marklarr": "Yea, something for partial mocks would be cool.\nobjective-c\n- (id)partialMock\n{\n    return [OCMockObject partialMockForObject:self];\n}\nAs for the macro, I see it as violating the Tell, Don't Ask principle. The logic to create a mock from a class should exist as a method on the class itself, not as a global function operating on the class from the outside. \nI'd love to help put this into OCMock 3. \n. Sometimes (a lot of the time, honestly), people just want a partial mock from a fresh object. [MyClass partialMock] looks super clean in this case, compared to [OCMockObject partialMockForObject:[[MyClass alloc] init]], or breaking it out into multiple lines.\nProtocols do present a bit of a problem. They are a unique case, and they should be treated as such. But just because protocols need to be handled in an unorthodox manner (eg, global methods, or macros) doesn't mean everything else should suffer from the same treatment.\nNamespacing seems reasonable. I can't really think of a legitimate situation where somebody would be using more than one mocking framework in a project, but I guess it can't hurt.\n. bump\n. Interesting. Maybe it'd be nice to detect when someone is trying to partial mock a toll-free bridged class or tagged pointer, and throw a descriptive exception? When I got the exception, it wasn't entirely clear. Since it was an EXC_BAD_ACCESS, I immediately assumed that I had done something bad with memory in my code\n. Posted a PR. How's that look?\n. :smile: \n. Great call on the concrete tests -- I wasn't aware of the CF...Create methods.\n__NSTagged is only used on 64-bit systems. I'm not entirely sure how it decides when to use it -- for example, [NSDate date] returns just an __NSDate, while [NSDate dateWithTimeIntervalSince1970:50]; will return an __NSTaggedDate\n. Thanks for the detailed response. While we're on the topic, I'll just say a few things.\nI definitely agree that test coverage can be misleading and is not something to follow blindly. I do think, however, that it's useful to see which code isn't tested at all, because you certainly won't be catching any regressions there. \nAs for the code that is tested, test coverage does make the assumption that the tests were written well. As long as you're comfortable with the quality of your tests, and that people won't be just adding silly tests to shoot up the coverage, test coverage can be a meaningful metric.\nIt's sort of like having sharp knives in the kitchen. Great for preparing food, but if you don't trust yourself and others with them, you probably shouldn't have them around :)\n. ",
    "rsaunders100": "Aw rats  - ok, thank you for the explanation and suggestion.\n. ",
    "zhangyu528": "So good!\n. ",
    "amarcadet": "Amazing quick reply and it worked!\nI think I need more practice and read documentation again :smile: \n. ",
    "silviapfeiffer": "Thanks - sorry for missing that.\n. ",
    "orta": "You should maintain your own Podspec in the repo, and use pod trunk push to submit a new version. Might make sense to merge this and clean it up.\n. I'll make a separate clean podspec and send you a PR.\n@erikdoe you'll need to run through the trunk getting started guide ( mainly registering, nothing complex ) .\n. #98 \n. poke\n. I've fixed this on trunk ( abusing admin powers :star2: ) and I'd recommend my PR over this as there's a fix around the private/public state too. Quick fingers @jstubenrauch :beers: \n. ",
    "liamnichols": "Is there any news on when v3.0 can get a podspec? I was going to make a new pull request but this one could just be updated for v3.0 if it is alright?\n. ",
    "jstubenrauch": "+1 for the v3.0 podspec\n. All right :)\n. ",
    "lawrencelomax": "I've tracked down the problem a little more and it looks like it boils down to a Class mock that does not have  stopMocking called in the teardown before the next test. This means that the next test that is run, still has the swizzled invocation interception behaviour but without any of the associated mocks.\nThis code executes in a beforeEach:\noperation = OCMClassMock(TABAPIPollingRequestOperation.class);\nfeedManager = OCMPartialMock(feedManager);\nOCMStub([feedManager createRequestOperationForFeed:OCMOCK_ANY withObserver:OCMOCK_ANY pollingInterval:1 events:OCMOCK_ANY]).andReturn(operation);\nI've verified that the operation object does not have stopMocking called automatically during teardown, possibly related to the creation of a reference cycle. The issue occurs in the next test to use TABAPIPollingRequestOperation directly:\nrequest = [TABAPIPollingRequestOperation requestForFeed:feed requestPerformer:performer responseHandler:^(id<TABAPIRequest> _, id value, NSError *error) {}];\nResulting in the \"No mock for class (null)\" message, with the backtrace:\n* thread #1: tid = 0x9ae20, 0x0be42ab2 SunTabletTests`OCMGetAssociatedMockForClass(aClass=0x00000000) + 226 at OCMFunctions.m:139, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n  * frame #0: 0x0be42ab2 SunTabletTests`OCMGetAssociatedMockForClass(aClass=0x00000000) + 226 at OCMFunctions.m:139\n    frame #1: 0x0be40fbd SunTabletTests`-[OCClassMockObject forwardInvocationForClassObject:](self=0x0be8129c, _cmd=0x019e471b, anInvocation=0x0babcac0) + 45 at OCClassMockObject.m:113\n    frame #2: 0x01db32da CoreFoundation`___forwarding___ + 458\n    frame #3: 0x01db30ee CoreFoundation`__forwarding_prep_0___ + 14\n    frame #4: 0x0be0e81b SunTabletTests`__51-[TABAPIPollingRequestOperationSpec spt_defineSpec]_block_invoke2(.block_descriptor=0x0bd6e750) + 299 at TABAPIPollingRequestSpec.m:35\nIf I explictly call stopMocking in the afterEach for the previous test that uses a Class Mock of TABAPIPollingRequestOperation, the problem goes away and everything runs as expected.\nI can also replicate if Class and Partials are alive at the same time:\n```\nrequest = [TABAPIPollingRequestOperation requestForFeed:feed requestPerformer:performer responseHandler:^(id _, id value, NSError *error) {}];\nOCMClassMock(TABAPIPollingRequestOperation.class);\n```\nThe same Exception will be thrown when the Class mock is created. This can be worked around by resolving the issues with my tests & implementation, but I was wondering if there is anything that can be done to fail-fast with better messages, or fix the problems when working when Class and Partial mocks of the same Class exist at the same time.\n. A little more info. It appears that the ordering of stopMocking getting called has an effect. This will result in the exception:\n```\nrequest = [TABAPIPollingRequestOperation requestForFeed:feed requestPerformer:performer responseHandler:^(id _, id value, NSError *error) {}];\nTABAPIPollingRequestOperation *requestClassMock = OCMClassMock(TABAPIPollingRequestOperation.class);\nNSLog(@\"%@\",requestClassMock);\napiRequestOperation = OCMClassMock(TABAPIRequestOperation.class);\nrequest = OCMPartialMock(request);\n```\nI have confirmed that stopMocking is called on requestClassMock after the test has executed and will therefore still be alive when the Partial Mock is created. The backtrace indicates that the deallocation of requestClassMock will happens when moving to the next test:\n* thread #1: tid = 0xa766c, 0x0bc23cf9 SunTabletTests`-[OCClassMockObject stopMocking](self=0x0d3f3010, _cmd=0x0b98b1e0) + 25 at OCClassMockObject.m:55, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n    frame #0: 0x0bc23cf9 SunTabletTests`-[OCClassMockObject stopMocking](self=0x0d3f3010, _cmd=0x0b98b1e0) + 25 at OCClassMockObject.m:55\n    frame #1: 0x0bc23c07 SunTabletTests`-[OCClassMockObject dealloc](self=0x0d3f3010, _cmd=0x019e4701) + 55 at OCClassMockObject.m:37\n  * frame #2: 0x019df692 libobjc.A.dylib`objc_object::sidetable_release(bool) + 268\n    frame #3: 0x019df7b6 libobjc.A.dylib`_objc_rootRelease + 25\n    frame #4: 0x019dee97 libobjc.A.dylib`objc_release + 71\n    frame #5: 0x019dfce7 libobjc.A.dylib`(anonymous namespace)::AutoreleasePoolPage::pop(void*) + 537\n    frame #6: 0x20103c74 XCTest`-[XCTestCase invokeTest] + 229\n    frame #7: 0x20103d7b XCTest`-[XCTestCase performTest:] + 111\n    frame #8: 0x0bc3cfb8 SunTabletTests`-[SPTXCTestCase performTest:](self=0x13076b00, _cmd=0x20107ed4, run=0x0d3947c0) + 152 at SPTXCTestCase.m:147\nI can stop the exception by calling stopMocking before the Partial Mock is made:\n```\nrequest = [TABAPIPollingRequestOperation requestForFeed:feed requestPerformer:performer responseHandler:^(id _, id value, NSError *error) {}];\nTABAPIPollingRequestOperation *requestClassMock = OCMClassMock(TABAPIPollingRequestOperation.class);\nNSLog(@\"%@\",requestClassMock);\n[(id)requestClassMock stopMocking];\napiRequestOperation = OCMClassMock(TABAPIRequestOperation.class);\nrequest = OCMPartialMock(request);\n```\nOr by artificially making the lifecycle of the Class Mock shorter, causing the stopMocking to be called on requestClassMock when it deallocates at the end of the autoreleasepool:\n```\nrequest = [TABAPIPollingRequestOperation requestForFeed:feed requestPerformer:performer responseHandler:^(id _, id value, NSError *error) {}];\n@autoreleasepool {\n  TABAPIPollingRequestOperation *requestClassMock attribute((objc_precise_lifetime)) = OCMClassMock(TABAPIPollingRequestOperation.class);\n  NSLog(@\"%@\",requestClassMock);\n}\napiRequestOperation = OCMClassMock(TABAPIRequestOperation.class);\nrequest = OCMPartialMock(request);\n```\nThis highlights that the issue appears to occur when there are live Class Mocks when Partial Mocks of the same Class are created.\n. No problem, thanks for this fantastic framework!\nI've been using HEAD which looks like M3, based on diffing the M2 & M3 dmgs. So it looks like this issue exists within M3. When I replace the source I have locally with the M3 dmg source there are no changes and re-verified the issue still exists.\nAs I'm developing more Specs I'm finding the general solution for me is to ensure that I call stopMocking in an afterEach. It looks like the lifetime for the Mock Object will be extended until it is fully over-written in the next test:\n```\n__block AnObject classMock;\n__block AnObject partialMock;\nbeforeEach(^{\n    classMock = OCMClassMock(AnObject.class);\n// This is the point at which the previous partial mock\n// will be dealloated and therefore stopMocking called\n// The partialMock object will stay around until all test\n// in this spec complete, or the next test runs, dereferencing\n// the previous test's object referenced in partialMock\npartialMock = [AnObject new];\npartialMock = OCMPartialMock(partialMock);\n\n});\nit(@\"should do something\", ^{\n    ...\n});\nit(@\"should do something else\", ^{\n    ...\n});\n```\nCould this be a matter of the ordering of when stopMocking is called? stopMocking will be called on partialMock on 1..n runs of each test and this effects the behaviour of classMock on those (1..n) runs? The fact that the first run of any test will not have the exception thrown, but every sucessive test will.\n. Yeah that code sample seems to confirm it. I think this comes up in BDD style frameworks because the second mock will deallocate immediately after the new class mock comes along in the second iteration. You are showing this with the code sample above by just creating two objects of the same class.\nThe stacking behaviour does sound like a lot of work, but invalidating previous class mocks when a new one is created sounds like surprising behaviour. Its reasonable for users of the library to assume that they can create two mocks of the same class because a class that co-ordinates them needs to be tested. I guess refcounting live mocks could be part of a possible solution but that seems like it is full of pain.\nWhat's the rationale for requiring that all Class mocks have all their forwarder methods created eagerly in prepareClassForClassMethodMocking? Is it just not possible/feasable to handle all method invocations when they are called rather than setting up forwarding at mock instantiation? I was mocking NSManagedObjectContext just yesterday and it took upwards of 2 seconds setup the class mock!\n. @erikdoe Thanks, I'll give it a go! I see what you mean about class mocks now. Just to confirm that mocking a class method will result in the Class being mocked globally rather than just the Mocked Object's isa.\nSomeThing *thing = OCMClassMock(SomeThing.class);\nOCMStub(ClassMethod([thing someClassMethod])).andReturn(NSNull.null);\n[thing.class someClassMethod]; //NSNull.null;\n[SomeThing someClassMethod]; //Should this result in the same stubbed return value, or directly call the original SomeThing method?\nThe eager forwarding certainly make sense now. I'll reconfirm the performance issue (if there is one) and follow up with a separate issue if I have some hard figures on it!\n. I'm not getting the \"No mock for class (null)\" exceptions in usual development of tests (which I was progressively working around) which means it looks like it has been fixed! Thanks :star2: \n. Awesome, I can confirm that this is now working and with such a quick turnaround. It's easy for me to file bugs, but not so easy to fix them!\nAs for why the syntax would result in a compiler error, its down to typing. I typically assign my mocks to variables that are the type of the type they are mocking, so it is treated as an instance method of the mock. I can bypass the compiler test by casting to id:\nOCMStub([(id)bulkOperations bulkOperationsOnManagedObjectClass:OCMOCK_ANY withCoreData:OCMOCK_ANY]).andReturn(@\"FOOBAR\");\n. @erikdoe Been watching this thread to see if these changes fix the (caught) exceptions for stubbing methods in UIView and NSManagedObject and can confirm the changes on master are fixing them!\n. ",
    "sstigler": "Thanks :) . What about just -andDoNothing instead of -andDo? Let me check with some fellow OCMock aficionados at work tomorrow and see if they have any ideas.\n. ",
    "zats": "Got it, thanks\n. Thanks!\n. ",
    "sdefresne": "This has been found as part of Chromium project. Original issue is https://code.google.com/p/chromium/issues/detail?id=377691 (sorry, restricted to Google).\n. Sorry for never replying. Yes #115 fixed the issue, thank you. However when testing it today I found another issue with #115 and I'll send a pull request to fix it.\n. See https://github.com/erikdoe/ocmock/pull/180\n. Forgot to mention that this happens with HEAD version of ocmock fetched from github.. The Swift runtime has a re-implementation of object_isClass function to allow compilation with a deployment target of 10.9. Given that Swift is mostly developed by Apple, I guess the re-implementation can be lifted to allow compilation of OCMock for the same deployment target.\nFix is https://github.com/apple/swift/pull/11467/commits/0475307c08.. I've debugged this some more and was able to create a smaller test that reproduce this crash reliably without using UIView (like the previous example, this assumes the code is compiled with ARC but the same error can be reproduced without ARC):\n````objc\n@interface MyObject : NSObject\n@end\n@implementation MyObject {\n  MyObject _contained;\n}\n- (void)setContained:(MyObject)contained {\n  if (_contained) {\n    [_contained removedFrom:self];\n    _contained = nil;\n  }\n  _contained = contained;\n}\n- (void)removedFrom:(MyObject)container {\n  NSLog(@\"-removedFrom:%@ invoked on @%\", container, self);\n}\n- (void)dealloc {\n  [setContained:nil;\n}\n@end\n- (void)testDealloc {\n  MyObject object1 = [[MyObject alloc] init];\n  MyObject object2 = [[MyObject alloc] init];\n  [object1 setContained:object2];\n  id objectMock = OCMPartialMock(object2);\n  NSLog(@\"silence warning: Unused variable 'objectMock', %p\", (__bridge void)objectMock);\n}\n````\nThe crash happens when the current autorelease pool is drained because the following succession of events happen:\n1. object1 reference count reach zero and its -dealloc method is called,\n2. object1 invokes -removedFrom: method of object2 passing self as argument,\n3. since object2 is a partial mock, -handleInvocation: is called,\n4. the method -retainObjectArgumentsExcluding: is invoked on the NSInvocation,\n5. while iterating over the argument, object1 is added to retainedArguments as it is the sole argument to -removedFrom:,\n6. the control eventually returns to object1 -dealloc method and the method returns, at this point the object is dead, any pointer to it, including the one stored in the NSInvocation referenced from the partial mock, is a dangling pointer,\n7. eventually object2 reference count reaches zero, and its -dealloc method is called, causing the destruction of the captured NSInvocation that tries to send -release message to object1 (via NSMutableArray -dealloc method), since this pointer is dangling, the test crash (well undefined behaviour happens).\nWith the original test case, the same thing happens, view1 -dealloc method invokes -movedFromSuperview: passing self as parameter, it is captured by the NSInvocation (but too late) and the same double release happens when the NSInvocation is deallocated. It is just a bit more complex because many other methods are invoked on view2 than in the reduced test case.\nTL;DR: I think capturing the NSInvocation arguments is unsafe because they could potentially be in the middle of a call to -dealloc when the invocation is handled but the mock. I would recommend not retaining any arguments of NSInvocation.. Here is the call stack when the method -retainObjectArgumentsExcluding: is invoked in that last test case:\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1\n  * frame #0: 0x000000011a5df34c OCMock`-[NSInvocation(self=0x000062400006f2c0, _cmd=\"retainObjectArgumentsExcludingObject:\", objectToExclude=0x000060000009c160) retainObjectArgumentsExcludingObject:] at NSInvocation+OCMAdditions.m:88\n    frame #1: 0x000000011a5e6e43 OCMock`-[OCMockObject handleInvocation:](self=0x000060000009c160, _cmd=\"handleInvocation:\", anInvocation=0x000062400006f2c0) at OCMockObject.m:329\n    frame #2: 0x000000011a5de1d9 OCMock`-[OCPartialMockObject forwardInvocationForRealObject:](self=0x0000600000019c20, _cmd=\"forwardInvocation:\", anInvocation=0x000062400006f2c0) at OCPartialMockObject.m:228\n    frame #3: 0x00000001015beed8 CoreFoundation`___forwarding___ + 760\n    frame #4: 0x00000001015beb58 CoreFoundation`__forwarding_prep_0___ + 120\n    frame #5: 0x000000011a5c395f OCMockDebugUITests`-[MyObject setContained:](self=0x0000600000019b60, _cmd=\"setContained:\", contained=0x0000000000000000) at OCMockDebugUITests.m:25\n    frame #6: 0x000000011a5c3a3f OCMockDebugUITests`-[MyObject dealloc](self=0x0000600000019b60, _cmd=\"dealloc\") at OCMockDebugUITests.m:37\n    frame #7: 0x0000000100fb3a2e libobjc.A.dylib`objc_object::sidetable_release(bool) + 202\n    frame #8: 0x000000011a5c3c79 OCMockDebugUITests`-[OCMockDebugUITests testExample](self=0x00006080000394e0, _cmd=\"testExample\") at OCMockDebugUITests.m:74\n    frame #9: 0x00000001015c056c CoreFoundation`__invoking___ + 140\n    frame #10: 0x00000001015c0440 CoreFoundation`-[NSInvocation invoke] + 320\n    frame #11: 0x0000000100856949 XCTest`__24-[XCTestCase invokeTest]_block_invoke + 591\n    frame #12: 0x000000010089ef45 XCTest`-[XCUITestContext performInScope:] + 183\n    frame #13: 0x00000001008566ef XCTest`-[XCTestCase invokeTest] + 141\n    frame #14: 0x00000001008576b0 XCTest`__26-[XCTestCase performTest:]_block_invoke.369 + 42\n    frame #15: 0x00000001008a3c4b XCTest`+[XCTContext runInContextForTestCase:block:] + 163\n    frame #16: 0x000000010085704c XCTest`-[XCTestCase performTest:] + 608\n    frame #17: 0x0000000100853052 XCTest`__27-[XCTestSuite performTest:]_block_invoke + 363\n    frame #18: 0x00000001008529b9 XCTest`-[XCTestSuite _performProtectedSectionForTest:testSection:] + 26\n    frame #19: 0x0000000100852bb6 XCTest`-[XCTestSuite performTest:] + 239\n    frame #20: 0x0000000100853052 XCTest`__27-[XCTestSuite performTest:]_block_invoke + 363\n    frame #21: 0x00000001008529b9 XCTest`-[XCTestSuite _performProtectedSectionForTest:testSection:] + 26\n    frame #22: 0x0000000100852bb6 XCTest`-[XCTestSuite performTest:] + 239\n    frame #23: 0x0000000100853052 XCTest`__27-[XCTestSuite performTest:]_block_invoke + 363\n    frame #24: 0x00000001008529b9 XCTest`-[XCTestSuite _performProtectedSectionForTest:testSection:] + 26\n    frame #25: 0x0000000100852bb6 XCTest`-[XCTestSuite performTest:] + 239\n    frame #26: 0x00000001008ab16d XCTest`__44-[XCTTestRunSession runTestsAndReturnError:]_block_invoke + 40\n    frame #27: 0x0000000100866232 XCTest`-[XCTestObservationCenter _observeTestExecutionForBlock:] + 475\n    frame #28: 0x00000001008ab00c XCTest`-[XCTTestRunSession runTestsAndReturnError:] + 281\n    frame #29: 0x00000001008426ab XCTest`-[XCTestDriver runTestsAndReturnError:] + 314\n    frame #30: 0x00000001008a2eb6 XCTest`_XCTestMain + 619\nAs you can see, we capture an invocation of -setContained: with as part of -dealloc of a MyObject instance. In that case, the argument of -setContained: is the object currently deallocated and the reference count cannot be increased.. I think an API as described in #347 to disable retaining of the arguments of the captured NSInvocation would work in my case.\nI found this \"side-contract\" in UIView while trying to understand why the some of the Chromium tests where crashing with the latest version of OCMock. Since there are only a few tests that try to mock a class from Apple frameworks, and we do not have such side-contract, it is a sustainable solution for us.\nThank you for looking into this issue.. ",
    "JRG-Developer": ":+1:\nPlease merge this pull request.\nIt would be awesome to if you could also push this to trunk, so it will be available on the master specs repo too.\nIf you're not familiar with trunk, it's super simple to use. See this guide for quick setup.\nYou may first need to claim this repo, if you haven't already.\nBoth are really easy to do: Orta and the rest of the CocoaPods team did an excellent job.\n. @erikdoe \nSorry about bumping the version number; we have several teams that love and rely on OCMock; and we wanted to get this fix onto CocoaPods.\nDid the version bump cause Travis CI to fail?\n. ",
    "qwandor-google": "Why not just match stubs in the reverse order rather than the order they were added? That way adding a new stub would take precedence over a previously-added stub.\n. ",
    "karpelcev": "It wasn't in the <OCMock/OCMock.h>, but the podspec never separated private from public and they could easily be imported manually.\nThanks for the fast response, I'll figure some local solution out.\n. ",
    "AnthonyMDev": ".andReturn takes an id argument, but defaults to an NSValue. It looks when you pass nil, it is still reading it as an NSValue signature, even though the value is nil. So your return value is of the wrong type.\nYou need to be passing it an NSString instead of an NSValue here. Try this:\nOCMStub([mock objectForKeyPath:@\"some.keyPath\"]).andReturn(@\"\");\nIt might not give you a \"nil\" value, but it's the next best thing.\n. I'm having the same issue. Is this expected behavior?\n. I'm still having issues using reject. What is the correct current syntax?\n. +1\n. ",
    "Panajev": "Hello, I will try to reproduce it later on in the day... I need some time to play around with that branch. Reverting to the last OCMock 2.0 release fixed it... weirdly enough.\n. Thank you for solving this issue. I can confirm our project works nicely with OCMock's latest :head.\n. ",
    "yuryshubin": "Weird stuff. if I switch on 'all exceptions' breakpoint then everything works fine, otherwise I get exception\n. ",
    "woolie": "Indeed thank you, also hitting this issue\n. ",
    "keviekev23": "yes!  Thanks Erik!\nOn Thu, Jul 31, 2014 at 9:17 AM, Steven Woolgar notifications@github.com\nwrote:\n\nIndeed thank you, also hitting this issue\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/erikdoe/ocmock/issues/107#issuecomment-50781745.\n. \n",
    "nickhart": "I've been having this problem as well, switched my Podfile to pull from :head and it solved it.  Thanks!\n. ",
    "patrickhartling": "That's fantastic news. I am really enjoying using OCMock 3, and I look forward to getting all my tests moved over to it.\n. Yes, that works like a charm. Many thanks.\n. I'm happy with the alternative implementation you proposed. It requires less code, and I have to admit that I generally hesitate to use class mocks, even to the point of redesigning the code under test. I admit that I would not have thought of this technique, but now that I know it, I will put it to use. Thank you for looking into it.\n. I will give it a try and get back to you as soon as I can. Thanks for the update.\n. The problem still occurs with the referenced example test case.\n. This issue still happens as of 8d323b34b173f1f02e5772c6f4f3b4d4c1466dfd.\n. ",
    "iosdev-republicofapps": "I still can't get reject to work in OCMock 3, see: https://github.com/erikdoe/ocmock/issues/167 .\n. I am also seeing the same EXC_BAD_ACCESS when I use [OCMArg checkWithBlock:] in OCMVerify().  This happens even if I keep strong references around to the things used in the block.\nSomething is going on .... Not sure what.  Maybe the NSInvocation in OCM should retain is arguments?\n. It looks like it's there now:\npod search ocmock\n-> OCMock (3.1.1)\n   Mock objects for Objective-C\n   pod 'OCMock', '~> 3.1.1'\n   - Homepage: http://ocmock.org\n   - Source:   https://github.com/erikdoe/ocmock.git\n   - Versions: 3.1.1, 3.1, 3.0.2, 3.0.1, 3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2, 2.1.1, 2.0.1, 1.77.1 [master repo]\nSometimes you need to do the following to update your pod search:\npod repo update\nDoes that help?\n. Sorry, but that's not what your title says.  Your title says: \"OCMock 3.1.1 podspec not pushed to CocoaPods specs repo\" as in \"the 3.1.1 podspec is not in the specs repo\" when it is.\nI could have read your entire post more carefully, sorry, but I was in a hurry and I was just trying to help.\nI don't know if GitHub allows you to edit the title of an issue, or it just got truncated, but that might avoid confusion in future.\nGood luck.\n. Thanks!  :-)\nSent from my iPhone\n\nOn Jan 7, 2015, at 12:41 AM, Denys Telezhkin notifications@github.com wrote:\n@iosdev-republicofapps Yep, sorry, it's really misleading. I renamed the issue for more clarity.\n\u2014\nReply to this email directly or view it on GitHub.\n. Also, the never syntax doesn't work either as described in https://github.com/erikdoe/ocmock/issues/145 .\n. It also doesn't work on classes that are descendants of NSObject:\n\nid obj = OCMClassMock([NSString class]);\n[obj length];\n[[obj reject] length];\nAny hints?  :-)  I'd be happy to help however I can ...\n. I got this to work, thanks @erikdoe \n. ",
    "terminatorover": "I'm currently experiencing this exact issue. \n. ",
    "VinceBurn": "I'm having that same issue in OCMock (3.3.1).\n- (void)test_faillureOfReject {\n    UIView *viewMock = OCMClassMock([UIView class]);\n    viewMock.backgroundColor = [UIColor blueColor];\n    OCMReject([viewMock setBackgroundColor:OCMOCK_ANY]);\n}\nThe reject should make it fail.\n. ",
    "itsthejb": "Fixed, indeed. Thanks!\n. Sure, that's reasonable. My reading of a13a464b8d1c42b6526abfd968fba77f0687c8ac is that it stores the original value (if object) as an associated object inside the NSValue instance. In that case, it sounds like OCMIsObjectType would be correct to use if it does the job of val == objcObject?. If so I can make that change.\n. Ok, updated to use OCMIsObjectType\n. Hmmm... I had to import OCMFunctions.h in order to avoid a compiler warning, but then had to rename a couple of parameters to also avoid:\nIn file included from /Users/jc/dev/OpenSource/ocmock/Source/OCMockTests/OCMockObjectHamcrestTests.mm:18:\nIn file included from /Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMock.h:19:\nIn file included from /Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMStubRecorder.h:18:\n/Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMFunctions.h:28:31: error: declaration of anonymous class must be a definition\nClass OCMCreateSubclass(Class class, void *ref);\n                              ^\n/Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMFunctions.h:28:38: error: cannot combine with previous 'type-name' declaration specifier\nClass OCMCreateSubclass(Class class, void *ref);\n                                     ^\n/Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMFunctions.h:30:33: error: declaration of anonymous class must be a definition\nvoid OCMSetIsa(id object, Class class);\n                                ^\n/Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMFunctions.h:30:39: error: expected ')'\nvoid OCMSetIsa(id object, Class class);\n                                      ^\n/Users/jc/dev/OpenSource/ocmock/Source/OCMock/OCMFunctions.h:30:15: note: to match this '('\nvoid OCMSetIsa(id object, Class class);\n              ^\n4 errors generated.\n. Cool\n. ",
    "gfontenot": "@erikdoe any thoughts on this?\n. ",
    "tadeegan": "Okay thanks!\n. ",
    "fatuhoku": "Any updates?\n. Okay, I'm just so confused. I've rearranged the test and it's working onwl. Hmmm.\n. ",
    "PabloRueda": "Still no plan to include this?. ",
    "pilky": "Ah, I missed that. Guess I need to have more caffeine before reading documentation.\n. ",
    "Buju77": "sry for re-using this issue, but how do I implement rejecting a specific notification I don't want to receive?\n. ",
    "sgl0v": "Checked for the version 3.1. Got the same errors while running unit tests.\n. I need CoreGraphics framework to run the tests in OCMockLib scheme. The OCMockObjectPartialMocksTests test case uses CoreGraphics methods like CGRectEqualToRect and CGRectZero. That is why I get the build error for OCMockLibTest target:\nUndefined symbols for architecture i386:\n  \"_CGRectEqualToRect\", referenced from:\n      -[OCMockObjectPartialMocksTests testCallsToSelfInRealObjectStructReturnAreShadowedByPartialMock] in OCMockObjectPartialMocksTests.o\n  \"_CGRectZero\", referenced from:\n      -[OCMockObjectPartialMocksTests testCallsToSelfInRealObjectStructReturnAreShadowedByPartialMock] in OCMockObjectPartialMocksTests.o\n. I've rolled back the changes in the travis build script. Now the pull request has the changes in OCMFunctions(seems to be the same as following: https://github.com/erikdoe/ocmock/pull/140) plus unit tests.\n. Yep, looks strange. Fails on OS X 10.9.1 with:\nTest Case '-[OCMockObjectMacroTests testSetsUpStubsWithStructureReturnValues]' started.\nOCMockObjectMacroTests.m:159: error: -[OCMockObjectMacroTests testSetsUpStubsWithStructureReturnValues] : ((123) equal to (actual.location)) failed: (\"123\") is not equal to (\"123\") - Should have returned stubbed value\nOCMockObjectMacroTests.m:160: error: -[OCMockObjectMacroTests testSetsUpStubsWithStructureReturnValues] : ((456) equal to (actual.length)) failed: (\"456\") is not equal to (\"456\") - Should have returned stubbed value\nXCTAssertEqual macro creates two NSValue objects via value:withObjCType: convenience constructor and compares them. I assume that unit tests fail because of different argument types.\n. I got the liker errors while building the OCMockLibTests target:\nUndefined symbols for architecture i386:\n  \"_CGRectEqualToRect\", referenced from:\n      -[OCMockObjectPartialMocksTests testCallsToSelfInRealObjectStructReturnAreShadowedByPartialMock] in OCMockObjectPartialMocksTests.o\n  \"_CGRectZero\", referenced from:\n      -[OCMockObjectPartialMocksTests testCallsToSelfInRealObjectStructReturnAreShadowedByPartialMock] in OCMockObjectPartialMocksTests.o\n. ",
    "johnbland-wf": "Yep, using ARC.\nSo stopMocking isn't needed for static classes either? They wouldn't dealloc, would they?\n. Makes perfect sense @erikdoe. Thx for that clarity.\n. @tommeier, feel free to keep commenting here. I'm just closing this sense Erik made it clear we don't need to call stopMocking.\n. Executed 457 tests, with 0 failures (0 unexpected) in 47.889 (47.953) seconds\n-vs-\nExecuted 455 tests, with 0 failures (0 unexpected) in 2.226 (2.544) seconds\nThis is going from my OCMock 3 branch to my OCMock 2 branch. I was quite generous w/ 2-3x slower. As you can imagine, this is a massive impact on our productivity.\nWe upgraded a few other pods but they were dot releases so nothing major. I will verify it isn't one of those pods in a sec just to make sure I'm not barking up the wrong tree.\n. Executed 457 tests, with 0 failures (0 unexpected) in 162.916 (162.994) seconds\n^ A slower computer than mine just reported this. #fyi\n. Nope, reverted all other pods (other than OCMock) to the older versions and it is still crazy slow.\nI'll dig in and see if something isn't mocked for our data requests or something. That could obviously cause some slowness if it is hitting the server.\nI've noticed basic mocks fail on 3 that worked in 2. It has caused some headache but it could be the issue we're seeing.\n\nUpdate: I went through one of our easier suites and played w/ them as much as possible to make them faster and it still takes ~2.9s for the suite of 24 tests. It is wayyy longer compared to ~0.4s for 53 tests in master.\nOur setup is Specta, Expecta and OCMock.\n. No prob.\nThe only thing I've noticed is the majority of our slower tests [roughly 22-25 of the 47 seconds noted above] were around testing view controllers. \nThis is the way we grab our view in a beforeEach:\n``` objective-c\n    beforeEach(^{\n        UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\"Board\" bundle:nil];\n    subject = [storyboard instantiateViewControllerWithIdentifier:@\"tutorial\"];\n\n    subjectMock = [OCMockObject partialMockForObject:subject];\n});\n\n```\nThis is from the suite that takes 2.9s from above. Obviously this is the old syntax but that wouldn't cause a lot of problems, would it?\n. I changed it and it had no effect. That line is never hit. I stepped through the code and I see it is traversing the entire class signature plus the parent.\n. So would it be better to use partial mocks to avoid having to mock \"all the things\"?\n. That seems like it could be the case @greglittlefield-wf, great find.\nI have no problem doing more testing @carllindberg. Let us know if you found anything specific in the library.\n. Any progress on this guys? 3 is killing our productivity.\n. We attempted to run it here but :head kept crashing on tests so we couldn't confirm. I'll try in a few once I get to a stopping point.\n. Here is what I see:\n\nIt also consistently chews up memory and cpu when running tests.\n. Class traversing should definitely get cached. At a quick look, 2 seemed to cache but 3 doesn't.\n. Not only did it not crash, the suite finished in 34 seconds. That's an improvement seeing as we went from 457 tests to 489 tests. So more tests and faster speeds.\nIt's getting there! :-D\n. Before last commit:\nExecuted 531 tests, with 0 failures (0 unexpected) in 67.579 (67.705) seconds\nAfter:\nExecuted 531 tests, with 0 failures (0 unexpected) in 9.258 (10.207) seconds\n\n. Any chance this is releasing soon?\n. All good. We're just targeting that commit at the moment. :)\n. Agreed. I just noticed the new release. This puppy is good to go.\nGreat work!\n. I wondered if one existed. Thx...I'll do that if I find anything else.\n. No, they fail without stopMocking. I have to stop mocking or any test (regardless of the suite) after attempting to read the file system will break.\nUsing Specta for the syntactic sugar.\n. No, it still fails if set to nil BUT...it seems like the only time it is an issue is when the mock is created in a beforeEach. If it is within one test, it works as expected except for one test.\nIn other words, I found we could get away with not calling stopMocking every time and only call it on one test and within one context block of 4 other tests. I looked to see if we were retaining or something but I'm not so sure exactly why it is failing here.\n. Spread the love, eh? :-)\nIt could be Specta, sure. It works for now but, as time allows, I'll try to dig a bit more.\n. I did see that section but just read the code.\nI see it is a pending feature to add the quantifiers. That'll be a great addition. It's one of the things we missed having jumped out of Jasmine [for js] into Ocmock.\n. Oh and apologies for the noise.\n. ",
    "tommeier": "Also getting this, downgrading to 2.2.4, works immediately, upgrading to 3.0.2 first run hangs on a UIViewController load, second and all subsequent runs hang in the way described above. Precisely on the CLTilesManagerClient: reconnecting part.\nDowngrading again to 2.2.4 specs run every time. The core lines (similar to above):\n```\n      controller = [MapViewController new];\n      controllerMock = [OCMockObject partialMockForObject:controller];\n  [controllerMock view]; // crashes here\n\n```\nCommenting out the partialMockForObject and everything works as planned (no expectations pass, but no crashes).\n. We're not using stopMocking anywhere, so I'm not sure where ours is being blocked in the same way :/\n. ",
    "ashfurrow": "Does it? I was not aware of that. Even if that is the case, I'd still vote for this inclusion of this so we have parity in the operators. \n. Yeah, I think that updating the documentation would be sufficient, but I still think that for the sake of parity, having isEqual: in addition to the existing isNotEqual: would make sense, especially to someone who hasn't read the docs (oh what a world we live in). \n. Cool. I've merged in from master \u2013 still worth considering this PR for the tests and inclusion of OCMIsEqualConstraint, but the need for that class might be obviated now with the simpler implementation. Let me know. \n. Yeah, we use Specta+Expecta, with OCMock filling in the gap on those frameworks, so adding Hamcrest would be an unnecessary dependency. \n. ",
    "greglittlefield-wf": "@johnbland-wf Just did some profiling and it looks like the bulk of the time is spent in partial mock setup, mostly this line: https://github.com/erikdoe/ocmock/blob/ac23ed9fd6e97aa565b4ea79fd2b431c82724912/Source/OCMock/OCClassMockObject.m#L99.\nIs it possible that the earlier versions of OCMock took a more \"lazy swizzling\" approach in setting up method forwarding, and this slowdown we're seeing is related to the overhead of setting up forwarding for all methods up front?\n. ",
    "tylermann": "Also seeing this issue on our test suite. Takes around 50x more time on OCMock v3. However I don't think that we actually have any UIViewController mocks. Mostly just mocking custom NSObject subclasses.\n. We had around 299 tests total that were running at around 1.1 seconds, now takes around 50 seconds on average.  Tried pulling the latest but it seemed to be crashing when running the tests, can test again later.\n. Thanks for the speed improvements. Things seem back to the fast OCMock 2 speed on 3.1 :)\n. ",
    "maciejtrybilo": "We have 899 tests and our run time jumped from 37-40s on 2.2.4 to 257-273s on 3.0.2. I've tried the latest commit (999b843) and got 121-125s, so you're definitely onto something here!\n. ",
    "joeydong": "++ the latest 3.1.1 speed improvement is unbelievable\nBefore\nExecuted 62 tests, with 0 failures (0 unexpected) in 4.346 (4.367) seconds\nExecuted 148 tests, with 0 failures (0 unexpected) in 13.734 (13.792) seconds\nAfter\nExecuted 62 tests, with 0 failures (0 unexpected) in 0.286 (0.312) seconds\nExecuted 148 tests, with 0 failures (0 unexpected) in 0.338 (0.393) seconds\n. What I usually do for now is set up an OCMStub(...).andThrow(testFailedException) since the test will fail if there's an uncaught exception.\n. today, I end up using OCMStrictClassMock more often than the usual OCMClassMock to have a tighter test spec\n. ",
    "albsala": "I have tried this with the same result:\n```\nid mock = OCMPartialMock([[MyClass alloc] init]);\nvoid (^theBlock)(NSInvocation ) = ^(NSInvocation invocation) {\n    MyObjectWithAction *owa = nil;\n    [invocation getArgument:&owa atIndex:3];\n    if (owa && owa.action) {\n        dispatch_async(dispatch_get_main_queue(), ^(void) {\n            owa.action();\n        });\n    }\n};\nOCMStub([mock myMethodWithParam:[OCMArg any]]).andDo(theBlock);\n```\n. I did it, but all I see is assembly, maybe I'm doing something wrong.\nlibsystem_malloc.dylib`malloc_error_break:\n0x4b3a7f9:  pushl  %ebp\n0x4b3a7fa:  movl   %esp, %ebp\n0x4b3a7fc:  subl   $0x8, %esp\n0x4b3a7ff:  nop    \n0x4b3a800:  nopl   (%eax)\n0x4b3a804:  addl   $0x8, %esp\n0x4b3a807:  popl   %ebp\n0x4b3a808:  ret\nI'm starting to think that I am doing something wrong with the mock too. I am mocking a method of \"MyClass\" and I am testing another one of the same class, using the mock for the call, i mean:\n[mock methodIWantToTest];\n. I get it. So it could not be an OCMock problem.\nI had to change the way I was testing this class, avoiding the chained calls refactoring it and adding a dependency, so I can not test it now. I guess that was the problem.\nThank you for your time.\n. +1\nUsing OCMExpect() and OCMVerifyAll()solved the problem, but I don't know why.\n. ",
    "jesseditson": "Yup, here's the test in question (being used in a KIF suite):\n``` objective-c\n- (void)testLoginViaFacebookSafari\n{\n    Mocktail *mock = [self mockLoginSuccess];\n    [tester mockReturnToApplicationWithURLString:@\"fb200368456664008://authorize/#access_token=&\" sourceBundle:@\"com.apple.mobilesafari\" afterPerforming:^{\n        [tester tapViewWithAccessibilityLabel:@\"Facebook\"];\n    }];\n// Verify that we're at the home screen\n[tester waitForTappableViewWithAccessibilityLabel:@\"Feeds\"];\n[tester confirmCurrentUserName:@\"Justin Beiber\"];\n[mock stop];\n\n}\n```\nThat in turn calls the meat of the problem, here:\n``` objective-c\n- (void)mockReturnToApplicationWithURLString:(NSString )urlString sourceBundle:(NSString )bundleID afterPerforming:(void (^)(void))performBlock\n{\n    UIApplication *sharedApplication = [UIApplication sharedApplication];\n    id mock = OCMPartialMock(sharedApplication);\nOCMStub([mock openURL:[OCMArg any]]).andDo(^(NSInvocation *inv){\n    WHILogTrace(@\"Return Mock open URL triggered\");\n}).andPost([NSNotification notificationWithName:UIApplicationDidEnterBackgroundNotification object:[UIApplication sharedApplication]]).andReturn(YES);\n\nperformBlock();\n\n[mock stopMocking];\n\n[[UIApplication sharedApplication].delegate application:[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString] sourceApplication:bundleID annotation:nil];\n\n}\n```\nWhich errors with the stack trace:\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[AppDelegate ocmock_replaced__controlTouchBegan:withEvent:]: unrecognized selector sent to instance 0xc10e760'\n*** First throw call stack:\n(\n    0   CoreFoundation                      0x041681e4 __exceptionPreprocess + 180\n    1   libobjc.A.dylib                     0x03ee78e5 objc_exception_throw + 44\n    2   CoreFoundation                      0x04205243 -[NSObject(NSObject) doesNotRecognizeSelector:] + 275\n    3   CoreFoundation                      0x0415850b ___forwarding___ + 1019\n    4   CoreFoundation                      0x041580ee _CF_forwarding_prep_0 + 14\n    5   libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    6   UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    7   CoreFoundation                      0x0415c91d __invoking___ + 29\n    8   CoreFoundation                      0x0415c82a -[NSInvocation invoke] + 362\n    9   Acceptance Tests          0x0e17250f -[OCPartialMockObject forwardInvocationForRealObject:] + 255\n    10  CoreFoundation                      0x041582da ___forwarding___ + 458\n    11  CoreFoundation                      0x041580ee _CF_forwarding_prep_0 + 14\n    12  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    13  CoreFoundation                      0x0415c91d __invoking___ + 29\n    14  CoreFoundation                      0x0415c82a -[NSInvocation invoke] + 362\n    15  Acceptance Tests          0x0e17250f -[OCPartialMockObject forwardInvocationForRealObject:] + 255\n    16  CoreFoundation                      0x041582da ___forwarding___ + 458\n    17  CoreFoundation                      0x041580ee _CF_forwarding_prep_0 + 14\n    18  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    19  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    20  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    21  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    22  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    23  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    24  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    25  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    26  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    27  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    28  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    29  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    30  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    31  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    32  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    33  libobjc.A.dylib                     0x03ef9880 -[NSObject performSelector:withObject:withObject:] + 77\n    34  UIKit                               0x030e1acc -[UIResponder(Internal) _controlTouchBegan:withEvent:] + 82\n    35  UIKit                               0x0307dd5f -[UIControl touchesBegan:withEvent:] + 336\n    36  UIKit                               0x02fbcc0b -[UIWindow _sendTouchesForEvent:] + 386\n    37  UIKit                               0x02fbd9d1 -[UIWindow sendEvent:] + 1117\n    38  UIKit                               0x02f8f5f2 -[UIApplication sendEvent:] + 242\n    39  CoreFoundation                      0x0415c91d __invoking___ + 29\n    40  CoreFoundation                      0x0415c82a -[NSInvocation invoke] + 362\n    41  Acceptance Tests          0x0e17250f -[OCPartialMockObject forwardInvocationForRealObject:] + 255\n    42  CoreFoundation                      0x041582da ___forwarding___ + 458\n    43  CoreFoundation                      0x041580ee _CF_forwarding_prep_0 + 14\n    44  Acceptance Tests          0x0e15e8c9 -[UIView(KIFAdditions) tapAtPoint:] + 681\n    45  Acceptance Tests          0x0e14c0b1 __49-[KIFUITestActor tapAccessibilityElement:inView:]_block_invoke + 1809\n    46  Acceptance Tests          0x0e146070 -[KIFTestActor runBlock:complete:timeout:] + 192\n    47  Acceptance Tests          0x0e146402 -[KIFTestActor runBlock:complete:] + 194\n    48  Acceptance Tests          0x0e14655c -[KIFTestActor runBlock:] + 108\n    49  Acceptance Tests          0x0e14b90f -[KIFUITestActor tapAccessibilityElement:inView:] + 239\n    50  Acceptance Tests          0x0e14b7ac -[KIFUITestActor tapViewWithAccessibilityLabel:value:traits:] + 332\n    51  Acceptance Tests          0x0e14b58b -[KIFUITestActor tapViewWithAccessibilityLabel:] + 123\n    52  Acceptance Tests          0x0e018ce8 __40-[LoginTests testLoginViaFacebookSafari]_block_invoke + 184\n    53  Acceptance Tests          0x0e092bac -[KIFUITestActor(Additions) mockReturnToApplicationWithURLString:sourceBundle:afterPerforming:] + 876\n    54  Acceptance Tests          0x0e018a4e -[LoginTests testLoginViaFacebookSafari] + 302\n    55  CoreFoundation                      0x0415c91d __invoking___ + 29\n    56  CoreFoundation                      0x0415c82a -[NSInvocation invoke] + 362\n    57  XCTest                              0x20103c6c -[XCTestCase invokeTest] + 221\n    58  XCTest                              0x20103d7b -[XCTestCase performTest:] + 111\n    59  XCTest                              0x20104c48 -[XCTest run] + 82\n    60  XCTest                              0x201033e8 -[XCTestSuite performTest:] + 139\n    61  XCTest                              0x20104c48 -[XCTest run] + 82\n    62  XCTest                              0x201033e8 -[XCTestSuite performTest:] + 139\n    63  XCTest                              0x20104c48 -[XCTest run] + 82\n    64  XCTest                              0x201033e8 -[XCTestSuite performTest:] + 139\n    65  XCTest                              0x20104c48 -[XCTest run] + 82\n    66  XCTest                              0x201066ba +[XCTestProbe runTests:] + 183\n    67  Foundation                          0x01f8b5ec __NSFireDelayedPerform + 372\n    68  CoreFoundation                      0x04126ac6 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 22\n    69  CoreFoundation                      0x041264ad __CFRunLoopDoTimer + 1181\n    70  CoreFoundation                      0x0410e538 __CFRunLoopRun + 1816\n    71  CoreFoundation                      0x0410d9d3 CFRunLoopRunSpecific + 467\n    72  CoreFoundation                      0x0410d7eb CFRunLoopRunInMode + 123\n    73  GraphicsServices                    0x04be05ee GSEventRunModal + 192\n    74  GraphicsServices                    0x04be042b GSEventRun + 104\n    75  UIKit                               0x02f7bf9b UIApplicationMain + 1225\n    76                            0x0006960d main + 141\n    77  libdyld.dylib                       0x0479b701 start + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\nOne odd thing is that the selector is sent to a class that is not mocked (sent to app delegate, we're only mocking UIApplication). I set a breakpoint to verify that the only class being set up in OCPartialMockObject is UIApplication - still stumped.\n. Just pulled out all the before actions and the mocktail stuff to try to isolate any bizarre edge case, but I repro the exact same issue.\n. That sounds reasonable to me, although to clarify, I'm attempting to stub a method from UIApplication, wouldn't whitelisting it cause problems with that?\nI'm not sure I completely understand why the partial mock is swizzling methods other than the one I specified, but I'm sure I'm just not familiar enough with the partial mock code.\n. I guess I'm also confused as to why it's swizzling the delegate instead of UIApplication, nowhere did I tell it to mock the delegate.\n. Ah, that makes a little more sense. It still seems a little confusing that it's swizzling methods other than the ones specified, I thought that was the point of a partial mock? I'm sure I'm missing some complexity that makes it necessary.\nI'm down to fire up a PR that avoids underscore prefixed methods, NS/UI/CL seem a little more dubious to me, as it seems like some of these are necessary. But maybe avoiding them unless explicitly specified is possible.\n. ",
    "cutz": "Any update here?  I've just recently upgraded some projects to OCMock 3 and am seeing the same issue partial mocking objects with classes that use selector forwarding.\n. ",
    "rex-remind101": "+1 \n. ",
    "realf": "+1\n. ",
    "jakunico": "+1\n. ",
    "PatrickNLT": "It may be an issue with UITextField not being KVC-compliant. See http://stackoverflow.com/questions/6617472/why-does-valueforkey-on-a-uitextfield-throws-an-exception-for-uitextinputtraits for more details.\n. ",
    "shalinisah-dev": "This seems to still occur in opt compiler mode.. ",
    "plivesey": "Bump. Can someone take a look at this? The actual code change is very minimal and causes no change in functionality. It just fixes a crash.\n. Thanks. Sounds good. I took at look at your commit though, and I'm not sure its fully correct? Maybe you've added some more code since, but it doesn't look like you're ever setting the stub variable so it'll always be nil?\nhttps://github.com/erikdoe/ocmock/commit/8e064c5b4eb8e5a2f057bb14ff915bf08778aa29\n. Haha...yep. Totally, definitely read it too fast, and don't use that pattern much.\nThanks for clarifying.\n. ",
    "kettch": "The PR wasn't mine, but that's cool if it fixed! Thanks!\n. Sorry about that guys, I had other stuff running and that pull request handed up hanging around...\nI'll handle Erik's remarks in the coming days on the first points, but I don't know anything about the part of the code related to OCMMacroState, so I'll probably have to leave this one to someone who knows more!\n. Indeed, I can look into adding a bit more precision to this. This was just based so far on a quick fix I had done in my specific use cases, so I could verify this was working.\nI must admit that I'm not that familiar with the internals of OCMock, so the title of the issue was merely a shortcut to what I was seeing in my integration of it throughout my tests.\nI'll certainly try fine-tuning the @synchronize that I added, and adding a few tests to check the behaviour. However, I'm not sure I'd be very confident digging into OCMMacroState (I hadn't even heard of that one before today...). That could be left for another pull request if someone feels up to it and maybe knows that part better than me?\n. ",
    "LunaCodeGirl": "I think this is really a cocoa pods issue more so than an OCMock issue: http://stackoverflow.com/questions/24275470/xctest-xctest-h-not-found-on-old-projects-built-in-xcode-6\nI could be wrong, I was just looking for other OCMock issue help and noticed this. I fixed this myself yesterday after a long search.\n. ",
    "tafax": "@erikdoe thanks for the quick answer.\nI don't think so. I create only one mock for the MyClass and I checked the allocation of object. It is still alive after returning from the sameMethod.\nI can't figure out what the problem is. Anyway, I'll try to reproduce the same workflow using some \"ad hoc\" classes. If I will, probably I'll have more information to track down the issue.\nIf you want, I'll inform you about news :)\n. ",
    "joshuafeldman": "I am also seeing this issue with the latest release. Inside the test calls to the stubbed class method go correctly to the mocked object, but outside of the test calls seem to go to the original class (not stubbed). I have verified that I do not fall into either situation @erikdoe mentioned. I am continuing to try and investigate.\n. So after much research I have figured out a solution. The problem was duplicate symbols getting compiled in from cocoa pods.\nTo fix this I needed to remove the \"common\" cocoa pod and ensure my libraries were only added to the application target. Also I needed to ensure OCMock was only in the test target, but that was already the case.\nNow I seem to be able to mock correctly since only one symbol with that isa exists in the binary\n. @erikdoe I think it is acceptable to close this issue. I don't think anyone's issues come from the library but rather their own build processes.\nPlease close it\n. ",
    "phamquy": "@joshuafeldman i encounter the same problem, how to you that your symbol is duplicated?\n. ",
    "darkFunction": "Thanks, I had the same issue. Removed offending pod from test target :)\n. ",
    "HiveHicks": "I'm having the same issue when using [OCMArg checkWithBlock:] in OCMVerify(). It doesn't throw though if I first use OCMExpect() and then OCMVerifyAll()\n``` objective-c\n- (void)testThatDoesntThrow\n{\n    [self.mainContext performBlockAndWait:^{\n    GRDocumentVariant *documentVariant = [GRDocumentVariant insertInManagedObjectContext:self.mainContext];\n\n    id documentVC = [OCMArg checkWithBlock:^BOOL(id obj) {\n        return [obj isKindOfClass:[GRDocumentVC class]] && [(GRDocumentVC *) obj documentVariant] == documentVariant;\n    }];\n\n    OCMExpect([_navigationController pushViewController:documentVC animated:YES]);\n\n    [_mockedVC showDocumentVariant:documentVariant];\n\n    OCMVerifyAll((id)_navigationController);\n\n}];\n\n}\n\n\n(void)testThatThrows_EXC_BAD_ACCESS\n{\n    [self.mainContext performBlockAndWait:^{\nGRDocumentVariant *documentVariant = [GRDocumentVariant insertInManagedObjectContext:self.mainContext];\n[_mockedVC showDocumentVariant:documentVariant];\n\nid documentVC = [OCMArg checkWithBlock:^BOOL(id obj) {\n    return [obj isKindOfClass:[GRDocumentVC class]] && [(GRDocumentVC *) obj documentVariant] == documentVariant;\n}];\n\nOCMVerify([_navigationController pushViewController:documentVC animated:YES]);\n\n}];\n}\n```\n\n\n\n. ",
    "leszarna": "I have similar problem  in OCMock code line: \nif(([recordedArg isEqual:passedArg] == NO) &&\nfor : \nOCMVerify([_api getObjectWithId:@16]);\nMethod is stubbed before:\n [OCMStub([_api getObjectWithId:[OCMArg any]]) andReturn:someObject];\nOCMVerify with [OCMArg any] doesn't cause problem.\n. ",
    "seaburg": "Hi!\n@leszarna, perhaps it not a bug\nTry this:\n```\nOCMStub([_api getObjectWithId:@16]).andDo(^(NSInvocation *inv) {\n    [inv retainArguments];\n[inv setReturnValue:&someObject];\n\n});\n<...>\nOCMVerify([_api getObjectWithId:@16]);\n```\n@foulkesjohn, you can add to beforeAll:\nOCMStub([mockObject methodCalledWithParam:OCMOCK_ANY completionHandler:OCMOCK_ANY]).andDo(^(NSInvocation *inv) {\n    [inv retainArguments];\n});\n. ",
    "aspyct": "Just had the same issue (OCMock 3.1.2):\n```\nNSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"mailto:me@email.org\"]];\nOCMStub([self.delegate secureWebviewShouldOpenMailSheetWithAdress:OCMOCK_ANY]).andDo(^(NSInvocation *invocation) {\n    [invocation retainArguments];\n});\n[self.secureWebView webView:self.webView\n                shouldStartLoadWithRequest:request\n                            navigationType:UIWebViewNavigationTypeLinkClicked];\nOCMVerify([self.delegate secureWebviewShouldOpenMailSheetWithAdress:@\"me@email.org\"]);\n```\nIf I remove that [invocation retainArguments], the test randomly succeeds, fails or crashes with EXC_BAD_ACCESS.\n. ",
    "drekka": "Came across this with 3.1.2 and found the solution. \nIn my code I was calling another class and passing it a mock. \nThat class create an object and set it on the mock via a setValue: setter.\nThe class did not keep a reference to the object it just set on the mock so when the thread of execution returned to the test, the created object was released. As OCMock's internal NSInvocation of the setVale: method was not retaining the object, it realloced. \nWhen I then executed a OCMVerify I got an EXEC_BAD_ACCESS.\nI found that when I created an internal variable in the class that created the object and set it with the new object so that it was retained independently of the mock object. That everything worked.\nTherefore I think that the problem is that OCMock's internal NSInvocations are running with retainArguments as NO (default). \nSo I'd like a way to be able to turn this on for cases where an argument value passed to a mock is not retained anywhere else in the code.\n. ",
    "hirad": "I believe I'm seeing something similar. This is my code:\n```\nid delegateMock = OCMProtocolMock(@protocol(DBFetchedObjectsControllerDelegate));\ncontroller.delegate = delegateMock;\n[controller loadObjects];\nOCMVerify([delegateMock controller:[OCMArg any] didDetectAdditions:[OCMArg checkWithBlock:^BOOL(NSSet* addedObjects) {\n    NSLog(@\"Block arg is %@\", addedObjects);\n    return [addedObjects count] == 5;\n}]]);\n[controller loadObjects];\n```\nThe test prints \"Block arg is __NSBlockVariable__ ...\" before throwing an exception (__NSBlockVariable__ doesn't respond to count). It gets fixed with OCMExpect and OCMVerifyAll.\n. ",
    "skunkworks": "Just to throw my hat into the ring, I believe I'm seeing the same issue in 3.2. The argument for the invocation, which is an NSString, is not retained by the object being partially mocked. This causes a crash most of the time.\nWhen I retain the argument in a contrived way -- by adding the argument to a mutable array that's retained by the object -- it no longer crashes.\n. ",
    "davertay": "Like @erikdoe mentioned, I think this is an ARC + NSInvocation issue, but I'm trying to find a workaround and having no luck. This example is contrived but representative of some real world cases we have that are causing the same crash. There is a nested block that needs to be invoked, but invoking it causes EXC_BAD_ACCESS.\n```\n@interface SomeTestClient: NSObject\n- (void)processTheResponse:(void (^)())responseBlock;\n- (void)checkWithCompletion:(void (^)())completion;\n@end\n@implementation SomeTestClient\n\n\n(void)processTheResponse:(void (^)())responseBlock {\n    NSLog(@\"THIS SHOULD NEVER GET CALLED\");\n}\n\n\n(void)checkWithCompletion:(void (^)())completion {\n    [self processTheResponse:^() {\n        completion();\n    }];\n}\n\n\n@end\n@interface MockCrashTestTests : XCTestCase\n@end\n@implementation MockCrashTestTests\n\n\n(void)testNestedBlockCallback {\n    SomeTestClient *testClient = OCMPartialMock([SomeTestClient new]);\nOCMExpect([testClient processTheResponse:[OCMArg checkWithBlock:^BOOL (id (^completionBlock)()) {\n    completionBlock();  // CRASHES HERE WITH EXC_BAD_ACCESS\n    return YES;\n}]]);\n[testClient checkWithCompletion:^() {\n    NSLog(@\"Actual completionBlock invoked\");\n}];\nOCMVerifyAll((id)testClient);\n}\n\n\n@end\n```\n. ",
    "michaelochs": "Please see the referenced commit! Internally NSPredicate uses valueForKeyPath: to fetch the desired properties, but this does not work.\n. ",
    "benf1977": "Awesome! Sorry I missed your initial message asking for test cases.\nSent from my iPhone\n\nOn Nov 19, 2014, at 13:31, Erik Doernenburg notifications@github.com wrote:\nClosed #153.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "mglidden": "Sure \u2013 I'll update the style and resubmit the pull request.\n. @erikdoe bump\n. I get the following exception:\nTest Suite 'OCMockObjectPartialMocksTests' started at 2015-01-09 17:58:42 +0000\nTest Case '-[OCMockObjectPartialMocksTests testForwardingAndCall]' started.\n2015-01-09 09:58:42.373 xctest[2407:303] -[OCMockObjectPartialMocksTests ocmock_replaced__andCalledMethod]: unrecognized selector sent to instance 0x1007669c0\n(lldb) po 0x1007669c0\n-[OCMockObjectPartialMocksTests testForwardingAndCall]\n. What would you think about adding an assert when two class mocks are added to the same class? This issue caused a really subtle and hard to track bug in our test suite. I'd be happy to provide the patch.\n. Here's a work-in-progress branch for getting two class mocks working at once: https://github.com/mglidden/ocmock/commits/mglidden-double-the-mocks\nThere are still a few things to fix (expectations don't work yet, and releasing the original class mock won't stop its stubs from firing) but I think the basic approach will work.\n. That would work, but I feel that the new behavior might be more confusing that the current one, since stopMocking wouldn't work on the first one anymore (and calling it on the second would would disable the first one). We ran into this issue when a global mock (setup at the start of our test suite) conflicted with a local mock for a single test. This new behavior would have still given us a bug.\nI'm close to a solution \u2013 just a couple more bugs to squash. \n. ",
    "SteveFortune": "No worries! I wasn't entirely sure whether the method was already covered by existing tests - this comment seems to suggest that its only used privately. Glad you were able to merge it anyway.\nSteve.\n. Even better... [inv getArgument:&complete atIndex:(2 + at)];\n. Update:\n``` Objective-C\ndefine andReturnCallback(at, returnType, argTypes, ...) \\\nandDo(^(NSInvocation *inv){ \\\n    returnType (^complete)argTypes; \\\n    [inv getArgument:&complete atIndex:(2 + at)]; \\\n    if (complete) { \\\n        complete(##__VA_ARGS__); \\\n    }  \\\n})\n\ndefine andResolveCallback(at) andReturnCallback(at, void, (void))\ndefine andCompleteCallback(at) andReturnCallback(at, BOOL, (void))\n```\nAdvanced usage:\n``` Objective-C\n// Chaining\nOCMStub([controller transitionFromViewController:[OCMArg any] toViewController:[OCMArg any] duration:0.3 options:UIViewAnimationOptionCurveEaseIn animations:[OCMArg any] completion:[OCMArg any]]).andResolveCallback(4).andCompleteCallback(5);\n// Absurd types\nOCMStub([businessObject doSomethingWithComplexCallback:[OCMArg any]]).andReturnCallback(0, MyResult , (MyInput , NSString *), [[MyInput alloc] init], @\"example\");\n```\n. @erikdoe thanks for the feedback. My comments are inline:\n\nYou basically want to tell the mock to invoke the callback that is passed as a parameter to the stubbed method. The integer argument tells the macro at which position the callback can be found.\n\nYes, that's correct.\n\n1) I'm not sure why the main macro is called `andReturnCallback. Wouldn't it be more descriptive to call it andInvokeCompletionBlock?\n\nI agree. andInvokeCompletionBlock is probably a more appropriate name.\n\n2) Wouldn't it be possible to find the argument without specifying its argument index?\n\nI don't think so unfortunately. I'm using NSInvocation's getArgument:atIndex: to retrieve the block inside of andDo. The only way that I can think of specifying the block argument's position in the invocation is by passing its index to the macro.\nOne alternative might be to add this feature to OCMArg as a constraining argument instead, like one of these. That way, you wouldn't have to specify the arg index. E.g.\n``` Objective-C\n/// [OCMArg invokeBlock] would auto-invoke the block in the same way as andInvokeCompletionBlock\n/// completion:.. is auto-invoked\nOCMStub([modalViewController dismissViewControllerAnimated:YES completion:[OCMArg invokeBlock]]);\n/// animations:.. and completion:.. are auto-invoked\nOCMStub([controller transitionFromViewController:[OCMArg any] toViewController:[OCMArg any] duration:0.3 options:UIViewAnimationOptionCurveEaseIn animations:[OCMArg invokeBlock] completion:[OCMArg invokeBlock]]);\n```\nThis seems a bit cleaner; what do you think?\n\nAre there really methods that take multiple blocks?\n\nYes, here are some that I have encountered:\n- - (void)transitionFromViewController:toViewController:duration:options:animations:completion:\n- UIView animation methods\n- - (void)setCompletionBlockWithSuccess:(void(^)(AFHTTPRequestOperation *operation, id responseObject))success failure:(void(^)(AFHTTPRequestOperation *operation, NSError *error))failure in AFNetworking\n\n3) What is the purpose of the andResolveCallback and andCompleteCallback macros? Even if the block returns a BOOL, the return value is not used. What's the harm of always declaring the return type as void in any case? (Booleans are returned in registers on all architectures, right?)\n\nTo be honest, I'm not sure. I'm in favour of scrapping the return metadata though if possible - I'll do a bit more research into it.\nThanks,\nSteve.\n. No worries - happy to help! Thanks, Steve.\n. I saw a55df97491fb08bb8ed09213b0405b567c9df3e2, perhaps we could use the runtime to retrieve metadata about the block and perform its invocation? I found this question which points to:\n- This blog post, which seems to explain the underlying implementation of blocks.\n- This library, which seems to provide helper methods for retrieving block metadata.\nI'll have a go at it on my fork over the next week.\n. I agree; looking at those type management functions, its probably more practical to keep it simple for now. I've found that my most common use cases are:\n- invoking simple callbacks ^{...}, and \n- invoking completion blocks ^BOOL{...}. \nProviding default values for params should be sufficient; maybe once we have confidence that its stable (and useful), we can look at implementing something like [OCMArg invokeBlockWithArguments: arg1, arg2, NULL]? \nIt would be great if we could cater for scenarios in which params affect the execution of the testable block code (e.g. with the AFNetworking callbacks), but there's nothing stopping users from reverting to andDo in these more complicated cases until we get around to them.\nI'll probably need to do some prototyping to confirm my thoughts, too - it might be just as easy to allow custom params as it is to pass default params.\n. Thanks, looks good. I have some time on Wednesday afternoon (GMT) to get cracking on my fork. I'm also looking at BlocksKit/DynamicDelegate, which seems to do something similar with its A2BlockInvocation class. Looks like we can create an NSInvocation using the NSMethodSignature and invoke it with the block, like this.\n. @erikdoe we have some progress. Its very much prototyping at the moment, but I think we can get something similar to the [OCMArg invokeBlockWithArguments: arg1, arg2, NULL] impl you suggested:\n- First pass at OCMBlockArgCaller: \n  - Builds an NSInvocation using your NSMethodSignature methods.\n  - Calls it on the block, similar to this.\n- First pass at [OCMArg invokeBlockWithArguments:...]:\n  - Takes a va_list of params.\n  - Primitive params must be boxed in NSValue.\n    - Use OCMOCK_VALUE in most cases.\n    - I get a bad access when using OCMOCK_VALUE with type BOOL *, so I created this to help users box their pointers.\n    - OCMBlockArgCaller checks if the param is an NSValue while building the NSInvocation to decide whether or not to unbox it. Not sure how to handle NSNumber yet (its a subclass of NSValue).\n  - Pass NSNull for NULL, nil, 0 - the implementation actually just skips over NSNull args; I assume NSInvocation passes the default value for an argument if one is not specified.\n- Basic test\nIts just a prototype - I've only run the tests on my local machine. Break testing the design and code in other environments, architectures and OS-es will be my next port of call.\nAn [OCMArg invokeBlock] method that just passes default values might be convenient as well, and not too difficult if my earlier assumption about NSInvocation is correct.\nAny thoughts on this so far?\n. @erikdoe, almost finished this off. Just writing a few high level tests in this repo. Should have a PR ready for Monday. \n. Great. FYI, I also found a few SO questions relating to this functionality:\n- http://stackoverflow.com/questions/16530194/can-ocmock-run-a-block-parameter\n- http://stackoverflow.com/questions/17644772/ocmock-and-block-testing-executing\n- http://stackoverflow.com/questions/17694137/how-to-test-if-a-method-of-an-object-is-called-inside-completion-handler-block-u?lq=1\n. @sryze the argument list should indeed be nil-terminated. If you use it alongside the OCMStub macro then you have to wrap it in an additional set of parentheses so that the comma in the varg list isn't interpreted as being part of the macro function: \nObjective-C\n// This\nOCMStub([readerMock loadTable:@\"store\" usingBlock:([OCMArg invokeBlockWithArgs:store, nil])]);\n// Not this\nOCMStub([readerMock loadTable:@\"store\" usingBlock:[OCMArg invokeBlockWithArgs:store, nil]]);\nThat should fix the compile error that you're getting. The best place to look for examples is the tests. Let me know if you run into anymore issues! Happy to help.\nThanks,\nSteve.\n. Thanks for your feedback. I'll have a chance to tackle these issues over next week.\nRe [OCMArg invokeBlock]: yes I have assumed that not setting the NSInvocation arguments creates defaults. I also skip over any of the arguments that are NSNull here, leaving them unset. \nThe documentation for the invoke and invokeWithTarget methods says that:\n\nYou must set the receiver\u2019s target, selector, and argument values before calling this method.\n\nso leaving them unset like I have done is probably not a good idea. I'll move to creating a default based on the type encoding.\nI also agree that there is no reason to store the NSInvocation as an ivar, and that buildInvocationFromBlock:.. should just return it directly.\nSummary of things I'll fix before this can be merged:\n- Inconsistent with OCMock coding style: curly braces and ivar naming\n- Move changes to the example application to a separate PR\n- Create default values for NSInvocation arguments rather than leave them unset\n- Don't store the NSInvocation as an ivar - its redundant, just return it\n. @erikdoe \n- Rebased my fork against master.\n- Conformed to OCMock coding style.\n- Stripped the commit that modifies the iOS7Example application.\n- buildInvocationFromBlock returns an NSInvocation directly.\n- Default argument values are given where feasible. The behaviour is as follows:\n  - For objects, pointers and numerical types (i.e. anything NSNumber compatible), nil, NULL and 0 are passed.\n  - Where infeasible to construct a default (e.g. for structs) the constraint throws an NSInvalidArgumentException, prompting the user to provide their own.\n- New tests for the default arg behaviours.\n- Re-ran my further tests successfully on an iPhone 6 (iOS 8.3).\n. No worries: I'm glad it was more or less up to scratch. To be honest, I'm not entirely sure how NSInvocation handles this case; I perhaps assumed that it used its method signature to safeguard against misaligned types internally. I'd be happy to include an additional commit to deal with this if you like? Perhaps something something along the lines of this function NSValue+OCMAdditions to create a default?\n. @erikdoe I was considering your comments about converting between numerical types and experimented a bit on my fork:\n- Assigned a default value on a case-by-case basis, similar to this function.\n- Allow only valid numerical conversions using the NSValue additions.\nLet me know if you think this is of any use!\nThanks,\nSteve.\n. I did consider using calloc but I wasn't sure whether 0 was represented as a sequence of zero bytes for all data types. If that is the case, could we do something like this in the block arg caller?\nObjective-C\nNSUInteger argSize;\nNSGetSizeAndAlignment(typeEncoding, NULL, &argSize); // Using `typeEncoding` from the method sig\nvoid *ptr = calloc(1, argSize);\n[inv setArgument:ptr atIndex:j];\nfree(ptr)\nAlthough I think that I read in a couple of places there is no guarantee that all 0 bits means 0, here for example. In the end I played it safe and = 0-ed each data type individually.\n. +1 I've also had this problem. I think it exists for andReturn and the like, too. E.g.\n. Thanks for the feedback. I haven't looked at OCMock in a while, but I think the issue is that you're stubbing the instance method -(void)processOrder:onCompletion: as if it were a class method.\nBecause coVCmock is never passed to aTestOrder, [helperPointer finishWithCompletionBlock:aCallback] calls the method on its own  TRSCheckoutViewController instance (checkoutVC), rather than on your mock.\nI cloned your repo and added some logs to confirm the issue; see this commit. Executing the test on my machine yields:\n...\nTest Case '-[TRSOrderSpec test_TRSOrder__validation_and_API_calls_with_a_valid_and_new_order__finishWithCompletionBlock__after_webView_was_dismissed__it_has_correct_states_afterwards_when_the_checkout_went_wrong]' started.\n2016-05-01 19:24:46.423 Trustbadge_Example[38674:1141681] --- Mock controller OCMockObject(TRSCheckoutViewController)\n2016-05-01 19:24:46.424 Trustbadge_Example[38674:1141681] --- Checkout controller, <TRSCheckoutViewController: 0x7fec49c51670>\n2016-05-01 19:24:46.424 Trustbadge_Example[38674:1141681] --- Controller implementation called, <__NSStackBlock__: 0x7fff52ce5700>\nTest Case '-[TRSOrderSpec test_TRSOrder__validation_and_API_calls_with_a_valid_and_new_order__finishWithCompletionBlock__after_webView_was_dismissed__it_has_correct_states_afterwards_when_the_checkout_went_wrong]' passed (0.007 seconds).\n...\nSo from what I can tell, the controller instance used in -(void)finishWithCompletionBlock: is not the mock and the actual -(void)processOrder:onCompletion: implementation is called. To fix this, you could:\n- Inject the TRSCheckoutViewController into the TRSOrder somehow.\n- Use a class method such as +(instancetype)new to create the controller in TRSOrder and stub it to return your mock object. See Advanced Topics > Stubbing methods that create objects.\nI've implemented an example fix in this commit, which yields:\n...\n2016-05-01 19:54:01.090 Trustbadge_Example[40452:1170987] --- Mock controller OCMockObject(TRSCheckoutViewController)\n2016-05-01 19:54:01.090 Trustbadge_Example[40452:1170987] --- Checkout controller, OCMockObject(TRSCheckoutViewController)\n2016-05-01 19:54:01.091 Trustbadge_Example[40452:1170987] --- Order processed: 0, Error Domain=nomatter Code=9 \"(null)\"\nTest Case '-[TRSOrderSpec test_TRSOrder__validation_and_API_calls_with_a_valid_and_new_order__finishWithCompletionBlock__after_webView_was_dismissed__it_has_correct_states_afterwards_when_the_checkout_went_wrong]' passed (0.018 seconds).\n...\nThe block is successfully invoked: Order processed: 0, Error Domain=nomatter Code=9 \"(null)\".\n. ",
    "kyleve": "Ah yeah, I see the problem with KVO now, didn't even think about that.\nHow do you feel about special casing NSManagedObject to get the \"real\" class, and keeping non-managed object subclasses as they exist today?\n. PR for discussion: https://github.com/erikdoe/ocmock/pull/181\n. To expand on my earlier comment: We can't do objc_getClass for all cases, because KVO works by:\n- Changing the class at runtime, so if you have FooClass, KVO replaces that to FooClass_NSKVONotifying.\n- It also stubs out class to return the original class (FooClass).\n- objc_getClass returns the \"real\" class (e.g., as someInstance->isa used to), so that means the OCMock subclass would end up replacing the methods on the dynamic KVO subclass, so we lose KVO notifications.\nHowever, for Core Data, it works by:\n- Taking your original class (let's say ManagedClass), and dynamically subclassing it to ManagedClass_EntityName. It then sets the class of the object to ManagedClass_EntityName. This dynamic subclass handles, among other things: dynamic properties and methods for your model, and KVO.\n- Core Data also overrides class to return the original ManagedClass class.\n- This means that OCMock would end up previously replacing the dynamic class with a class that's a subclass of your original ManagedClass class, which breaks Core Data. Instead, we now subclass Core Data's underlying class. This keeps Core Data & KVO working for managed objects.\nDoes that help?\n. I'm going to close this out, @alanf has a new PR that incorporates feedback.\n. I'm not sure how I feel about hardcoding in support for NSManagedObject. On one hand, it's very one-off. On the other hand, it's the least \"clever' way to figure out when to reach for the class via the runtime.\n. Ran the upgrade check, did not apply any changes.\n. Missing autorelease (assuming the tests aren't ARC either).\n. (Nvm, tests do indeed use ARC.)\n. It's been a while, but I recall not doing this was messing with KVO notifications + the associated tests. KVO dynamically subclasses your class to provide automatic notifications, and something about then re-subclassing that class wasn't working.\n. ",
    "DenTelezhkin": "I'm not saying 3.1.1 is not there, i'm saying that 3.1.1 that is there requires XCTest, which you can verify by going to the podspec link above.\n. @iosdev-republicofapps Yep, sorry, it's really misleading. I renamed the issue for more clarity.\n. Thanks!\n. ",
    "dwabyick": "I definitely got caught by this as a newcomer. I wanted a 'does not call' type of assert.  @joeydong 's approach worked great.\n. Is this by any chance related to the following error?  We've had some periodic failures during unit tests on OSX.  I thought that unit tests are run on the main thread, so I'm not sure what the issue is. \n```\n2015-10-19 11:23:58.219 Project[63509:912285] An uncaught exception was raised\n2015-10-19 11:23:58.219 Project[63509:912285] *** Collection <__NSArrayM: 0x628000245640> was mutated while being enumerated.\n2015-10-19 11:23:58.219 Project[63509:912285] (\n    0   CoreFoundation                      0x00007fff8c3e366c __exceptionPreprocess + 172\n    1   libobjc.A.dylib                     0x00007fff9215076e objc_exception_throw + 43\n    2   CoreFoundation                      0x00007fff8c3e2f05 __NSFastEnumerationMutationHandler + 309\n    3   OCMock                              0x000000010227cec7 -[OCMockObject verifyInvocation:atLocation:] + 149\n    4   OCMock                              0x000000010227b03d -[OCMVerifier forwardInvocation:] + 116\n```\n. @iangithubusername, thanks for the answer. Just for clarification, I was curious if your PR would address these types of issues. It sounds like this is a separate issue.\n. ",
    "kjanowiecki": "@erikdoe Thanks for getting back to me so quickly. I confirmed the steps you completed (doing a fresh project and following the instructions to the letter) and that worked for me.\nOn my current project however, I did a little more investigating and the problem only arises when trying to call OCMStub(). \nid userDefaultsMock = OCMClassMock([NSUserDefaults class]);  //Compiles and links\nOCMStub([userDefaultsMock stringForKey:@\"MyAppURLKey\"]).andReturn(@\"http://testurl\");  //Linking fails\nTrying these two lines out, the linker has no problem with the _OBJC_CLASS_$_OCMockObject symbol, but when trying to OCMStub() something, the linker error arises. Any ideas?\n. Update:\nGot it working. I ended up deleting the contents of /Users/kjanowiecki/Library/Developer/Xcode/DerivedData and rebuilding the project. Thanks for your time @erikdoe \n. ",
    "aryaxt": "I started getting this error as well, I was using 3.1.1\nUpdated pod to 3.2 and didn't resolve the issue.\nTried clearing derived data with no luck\nAny suggestions?\nld: warning: directory not found for option '-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.2.sdk/Developer/Library/Frameworks'\nUndefined symbols for architecture x86_64:\n  \"_OBJC_CLASS_$_OCMMacroState\", referenced from:\n      objc-class-ref in CSBaseControllerTest.o\n      objc-class-ref in CSApplicationVersionManagerTest.o\n      objc-class-ref in CSAppDelegateTest.o\n  \"_OBJC_CLASS_$_OCMockObject\", referenced from:\n      objc-class-ref in CSBaseControllerTest.o\n      objc-class-ref in CSApplicationVersionManagerTest.o\n      objc-class-ref in CSAppDelegateTest.o\n  \"_OCMIsObjectType\", referenced from:\n      -[CSBaseControllerTest mockCSAnalytics] in CSBaseControllerTest.o\n      -[CSApplicationVersionManagerTest setUp] in CSApplicationVersionManagerTest.o\n      -[CSAppDelegateTest testShouldLogPushRegistrationErrorToAnalytics] in CSAppDelegateTest.o\n  \"_OCMMakeLocation\", referenced from:\n      -[CSBaseControllerTest executeBlock:andExpectAnalyticsPageToBeTracked:] in CSBaseControllerTest.o\n      -[CSAppDelegateTest testShouldLogPushRegistrationErrorToAnalytics] in CSAppDelegateTest.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. ",
    "jcampbell05": "We had the same issue, we managed to test NSOperations with OCMock using the following guidelines.\nNSOperations need to be added to a queue, as for some reason starting them on their own\n causes an exception (Even if the operation's properties indicate it is ready to execute.)\nThe queue needs to be the main queue ([NSOperationQueue mainQueue]) due to OCMock not being\n thread safe, this ensures the operation and OCMock are on the same thread.\nThe maxConcurrentOperationCount property on this queue needs to be set to 1 to ensure a fair test.\nYou need to use a XCTestExpectation to wait for the operation to finish otherwise\n you may get incorrect results from your tests.\nThis expectation should fulfill when the thing you wish to test happens or the operation has\n got to a point of execution where you are ready to assert it's results.\nAll stubs for an operation should be done through a partial mock and all stubs calls should be done\n on the mock object.\nFinally in the handler for the waitForExpectationsWithTimeout function you need to tell the operation\n to finish to prevent hanging of the main thread or any other issues during testing\n caused by incomplete operation clean-up.\n. Hopefully though OCMock will solve it one day though :) \n. ",
    "mdales": "Any reason the fix from @kettch hasn't been merged into OCMock yet to solve this issue? Hitting this issue periodically too, and want to find a solution.\n. ",
    "modocache": "Looks like the pull request has some unaddressed comments on it: https://github.com/erikdoe/ocmock/pull/175\nSeems like the fastest way to get a fix in is to either ping @kettch or, if they don't have the time to work on it, fork their branch, make additional commits addressing the comments, then submit a pull request of your own. Would love to see this issue addressed!! :+1: \n. @joeljfischer I think this error should be fixed within Nimble itself. Could you close this issue and create one on the Nimble repository instead?\nAs the error message indicates, OCClassMockObject cannot be converted to Swift's CustomDebugStringConvertible protocol -- meaning, as far as I can tell, it doesn't implement -debugDescription. Nimble's stringify function attempts to handle cases in which the subject of an expectation doesn't conform to CustomDebugStringConvertible, so I'm not sure why it's failing here. But I think we can fix the problem in Nimble, rather than forcing OCMock code to change.\n. Thanks, @erikdoe, I created an issue on the Nimble repository to track this.. ",
    "iangithubusername": "I threw up a new pull request that I think addresses all of the comments from the previous pull request.\n. Tested by building all schemes in the Xcode project, running the static analyzer on all of them, and running the unit tests on all of them.\nUsed a built copy of OCMock in my OS X project and verified that all of my project's unit tests completed successfully against the built copy of OCMock.\n. Closing because I can't figure out how to change this to be based on master.\n. Sure.\n. Actually I can't figure out how to change the pull request to say master, I'll just make a new one.\n. Could this be kept open for consideration then if the current behavior was more a necessity than something desired?\n. Thanks for the update, would love to see this in a release soon so I can stop building my own version of OCMock.  ;-)\n. I would say that it's reasonable to say that you're only allowed to call -stopMocking once, kind of like -[NSTimer invalidate] and similar methods, in which case I don't think you need to worry about the threading.  Although -restoreMetaClass is called from more than just -stopMocking, so yeah maybe mockedClass and originalMetaClass need similar guards.  I admit that I didn't really do an exhaustive check over all the classes in OCMock, just the ones that were involved when I hit crashes mocking user defaults in a multithreaded app.\nI suppose we could say that OCMock is thread safe enough such that the mocks can be used on multiple threads, but their creation and destruction is generally intended to be done on a single thread in +setUp, +tearDown, -setUp, -tearDown, and the various -testXXX methods?  Or I can try and find more time to check all the other classes if you prefer?\n. Unit test methods are always invoked on the main thread, but they can spawn threads like anything else.  (XCTestExpectation supports this).  That said, the implication here is that -[OCMInvocationMatcher matchesInvocation:] is somehow modifying the the OCMockObject's invocations array on the same thread.  (Since the access is locked, it's impossible for another thread to be doing the modification.)  That should be an existing bug as far as I can tell.\nAlso this hasn't even been merged in to master yet, I'm still waiting for input from Erik on that.\n. It depends, I'd have to see the full crash log.  If you have another thread in some OCMock methods, then this change has a good chance of addressing your issue.  In my case I was seeing crashes like this too, mostly from a partial mock I'd made on +[NSUserDefaults standardUserDefaults] which gets accessed from pretty much every thread in my project.  After this change all my crashes went away, however if you're seeing this in strictly single threaded code then this change shouldn't make a difference.\n. @erikdoe What do you think about this one?  Do you think it's good enough to say that tear down has to happen from only one thread, and only after everything is done using the mock?  Other than that caveat I think this change does make the mock objects thread safe.\n. Good point, updated the PR.  Although there's another problem with a retain cycle, I'm awaiting feedback from Erik as to how he wants that handled.\n. @carllindberg I tried just nil'ing out the invocation targets but those are used by a couple different things like partial mocks to find their original object.  What I ended up doing instead was hanging onto a copy of the invocation with self removed and arguments retained.  That seems to work out alright and lets me remove the blacklist for reference counting methods too.\n. I considered doing that too, just grabbing all the objects out of the invocation and adding them to a counted set.  I thought it would be good to keep each invocation distinct and having them line up with the original invocation, just in case something ever removes things out of the invocation list then it would be easy to also remove from the retained invocations.  Since the retained invocation copy isn't used for anything but to retain the arguments, the char * thing doesn't really matter.  I suppose I could've dropped all of the non-object things out of the invocation too.\nI don't know, there didn't really seem to be an obvious way to solve the problem.  This one seems to work pretty well but if anyone really wants something else that's fine too, I just want to get this change integrated.\n. My version isn't affecting the matching at all.  The original invocation is untouched, and the new sidecar invocation is used solely for retaining the target, arguments, and return value while not retaining self to avoid the retain cycle.\nPersonally I'm not a fan of associated objects, they're too non-obvious to me and I only really use them in a last resort situation.  What I could do is change invocations to be a map table whose keys are the invocations and whose values are a retained collection of just the object target/arguments/return value that aren't self.\n. They're not bad, I just find them to be kind of non-obvious.  It's a little clearer to me to use a map table since there's an obvious place to keep it (OCMockObject).  Also \"-retainObjectArgumentsExcludingObject:\" seems like a kind of funky API to add onto NSInvocation.  But let me look at the other place, maybe it's not as clean there.\n. Oh yeah, that's why I was manually setting up a copy of the invocation in the first place; I didn't want to mess around figuring out what all needed to be copied or retained.  In the interest of second guessing NSInvocation behavior as little as possible and letting -retainArguments just do its thing, I think I prefer the way it is right now and leaving OCMInvocationMatcher alone.  We'll see what Erik says though.\n. Merged up to master and updated.\n. Thanks for checking in, did you get a chance to have a look at this?\n. 1) Sorry, I really tried to follow the existing style in OCMock!  If you want to point them out I'll fix them.\n2) OK, I used an associated array on the invocation instead (and since arrays don't check for equality on insertion that should take care of the performance issue as well).\n3) Ah I see what's going on.  Invocations are being made for class methods, and this change calls -retainArguments on the invocations.  It looks like -retainArguments eventually causes +release to be called on the class objects when the invocation deallocates.  #272 made it so that -stopMocking disposes the Class object that's getting captured in the invocation.  If the invocation outlives the OCPartialMockObject (which seems quite common due to autorelease pools, though interestingly it's not 100%), then when the invocation deallocates and calls +release on the dynamically created subclass that's already been disposed, you get a crash since the Class object is effectively a zombie.  I fixed it by making the retain arguments thing not retain Class objects.  They don't appear to actually be reference counted anyway (as far as I can tell from playing with +retainCount, +retain, and +release in the debugger), so it's not doing anyone any good to try to retain them.\n. Hi @erikdoe what's the next step for this one?\n. Thanks for merging this.  However without the OCMMacroState thread dictionary changes and try/finally cleanup, anything that uses the OCMock 3 macros to create mocks that get used in multiple threads will very quickly crash.\n. I don't remember the exact details, just that things accessing +[OCMMacroState globalState] were getting the wrong state object which was causing messages to go to the wrong mock.\n. From -[OCMockObject forwardingTargetForSelector:] as I recall.  I think there was a background thread in that method, and the main thread was in the middle of setting up a different mock object.\n. That does appear to be the case.  60c7b46 works fine, but 729c99b crashes.\n. We have a working solution in #235 now, it's just down to a matter of style and what @erikdoe prefers.\n. I'm pretty sure once you stub a class method you have to manually stop mocking.. Although, I don't really know why you have to manually call -stopMocking the more I look at it. Even if you do, the mock object still doesn't appear to deallocate, maybe there's a leak hiding here somewhere? The trigger appears to be stubbing a class method.. This is based on the suggestion in the issue by @fareal that -stopMocking be used to release arguments to mock objects, and potentially break retain cycles that can result as described by @alexito4.\nThe gotcha here is that mocks can no longer be verified after -stopMocking has been called. In practice I don't see how that could be an issue, but it is a behavior change that I want to point out up front.\nI don't see any great alternatives though.\n1. Add a way to opt-out of the autorelease-safe and thread-safe behavior introduced in #171 a la #348. For people who really know what they're doing and can guarantee that nothing in the invocation will get released for the lifetime of the mock, then ok, but that seems sketchy.\n2. Take @fareal's solution verbatim. The problem with his solution is that -stopMocking would then restore the original problem where the invocations can hold zombies, which can cause crashes. If you don't use the mock after -stopMocking (and it seems to me like you really shouldn't) then it's not a problem. But if you do keep using the mock, probably to verify, it seems better to me to fail the verifies rather than sporadically crash.\n3. Add an explicit method to empty out all of the captured invocations. This would allow verification after -stopMocking, but I don't know if anyone actually wants to do that so I don't know if it's really worth adding another method.\n4. Do nothing. I think the retain cycle problem at least is worth fixing. And even though I'm not a big fan, dealloc tests are a thing that people do in real life. There are several related issues/complaints here that would seem to prove that. So I think it's worth making those possible too.\nSo I think the behavior change is worth it on principle, and I think it will make more people happy than it makes angry?. No, this proposal doesn't make -stopMocking a required call for any mocks where it wasn't already. It just makes it so that -stopMocking can be used to manually release the captured invocations on the mock, rather than relying on the mock's own object lifecycle. This is particularly important when the mock retains objects that the real object normally wouldn't, and the objects it's retaining in turn hold a strong reference to the mock. Prior to this proposal there was no way out of that situation, but with this proposal you can now manually call -stopMocking to break the retain cycle. So I wouldn't say this adds a requirement, but rather it adds an option to fix a previously un-fixable situation.\nI'm not opposed to installing a land mine after -stopMocking is called, but I think that should be a separate diff/proposal.. Hi @erikdoe what do you think of this one? I still think it's the best compromise between all the proposed solutions, code snippets, and pull requests for the issue. But I'm also happy to make changes as you prefer.. Same thing as https://github.com/erikdoe/ocmock/pull/364?. Yes the object for OCMGlobalStateKey should always be removed from the thread dictionary at this point, the assert was a \"just in case\" thing.  I don't mind removing it.\n. Because invocation can throw an exception which would cause +endStubMacro to not get called.  Now that the previously-global->now-per-thread macro state is held strongly by the thread dictionary, we can no longer count on the autorelease scope magically causing -dealloc to happen, and thus -dealloc can't do the same cleanup that +endStubMacro did.\n. Yes this change definitely caused #245. -[OCPartialMockObject prepareObjectForInstanceMethodMocking] sets up a \"forwarder\" for -retain (and every other method on the class). I didn't notice it because -retain isn't usually called in ARC (there's an Obj-C primitive that gets called instead), but if you have a class that implements -retain itself (which apparently NSManagedObjectContext does if you grub around in the IMP) then -retain does get called. Then the \"forwarder\" causes -[OCMockObject handleInvocation:] to get called with an invocation for -retain, it retains the arguments of the invocation which includes the target (aka the receiver of the original -retain message), -retain gets called again, hits the forwarder again, etc.\nIt's definitely necessary to retain the invocation arguments though, otherwise they won't be valid from thread-to-thread.  Really depending on how the autorelease scope goes they won't even be valid on the same thread in a lot of cases.  Something like this was already exploding.\n@autoreleasepool {\n    [mock stubbedMethodWithArgument:argument];\n    // argument deallocates now\n}\nOCMVerifyAll(mock); // This crashes because the mock has an invocation that has an\n// unsafe unretained reference to argument and touching the invocation blows up.\nI first just did a plain old -retainArguments, but that caused the unit tests to fail, and copying the char pointer special case made them succeed again.\nAs for fixing #245 I didn't see much point in capturing the reference counting methods at all, so I added them to the black list in OCPartialMockObject.  I could see argument for special casing -retain similar to char pointer arguments though.\n. Yes...  Yuck.  The target is very likely to be self, and it's used too so there's no clearing it.  Beargh.  The logical place to clear it would be in -stopMocking, but people don't currently call that method typically.  It would seem the options are these.\n1. Release note it and change the documentation to say that -stopMocking always has to be called manually, and the object won't deallocate until you do, a la NSPort and NSTimer.\n2. Have people set something in their unit test bundle's Info.plist that says they want some thread safety with OCMock.\n3. Use a global or something like that and make people manually enable thread safe behavior on OCMock as a whole.\nPersonally I prefer the first option; I don't really want to manually enable thread safety, it should just be there.  I also kind of feel like 2 and 3 are jumping through a lot of hoops just to save on a few -stopMocking calls.\n. The arguments are retained as long as none of them happen to be a char *.  Which as the comment I copied says, doesn't really work.  But there's too much matching code elsewhere that breaks if you do retain them.  So in the interest of consistency I went with the same system of not retaining char * arguments.\nI don't think the invocation is ever actually invoked, it's just kept for matching, mostly in the name of OCMVerify.  But that's an interesting idea, a nil target could be considered matching for self.  I'll see how tricky that is to implement, it seems like the best of both worlds there.\n. Just nil'ing the target doesn't work, it breaks andForwardToRealObject on partial mocks (among other things).  I'm going to see if anything terrible happens if I make a copy of of the invocation to retain arguments on.\n. I thought I'd wrote this last week...  But if I were to guess I'd say that the different block types are more likely to share an encoding type than they are to share a common non-NSObject superclass.  Though I'm sure either way it's relying on implementation detail.  I'll see what @erikdoe  says, hopefully we can close this out soon once and for all.\n. I tried in ARC and non-ARC, all block types encode as @? even dispatch_block_t.  So as far as I can tell the code as written is solid.\nI actually pulled the identifying code from OCMIsObjectType, I just added another check for a case I saw where block arguments were included as part of the type.  So I think this is stylistically the right thing to do, it positively identifies the argument type even if the actual passed argument is nil, and it seems to work in all cases.  Of course I'll defer to @erikdoe but I think what's in the pull request is good.\n. ",
    "fareal": "How about now? \n. An invocation can very well have the mock object itself as an argument though, right? \nOr, more likely, another mock object that will also have invocations with arguments that eventually could be the initial mock object.\nHow can we break those cycles?. Also, this seems to be new, introduced by \nhttps://github.com/erikdoe/ocmock/issues/171\n?. It would seem reasonable to me to update stopMocking to proactively release all resources (and document it officially). We do need someone to retain all arguments.\n. I meant something along those lines in OCMockObject.m:\n- (void)stopMocking\n{\n@synchronized(invocations)\n    {\n      for (NSInvocation *anInvocation in invocations) {\n        [anInvocation releaseObjectArguments];\n    }\n}\nThen implement releaseObjectArguments to basically do...\n- (void)releaseObjectArguments\n{\n    objc_setAssociatedObject(self, OCMRetainedObjectArgumentsKey, nil, OBJC_ASSOCIATION_RETAIN);\n}\n-> this manually breaks any reference cycle introduced during the test.\nThe test would explicitly call \"stopMocking\" at the end (or in tearDown) to break the cycles.\nDoes this make sense?. ",
    "michaelmelanson": "cc @bashery\n. Oh, I agree we're definitely abusing +[OCMArg checkWithBlock:] and should probably find a better way of doing this. Thanks for the suggestion there.\nBut this is a behaviour change that shouldn't be introduced in a point release -- for 3.1.x this change is a bug; for 3.2.x it could be the documented behaviour.\n. Thanks, @erikdoe. If you find this is too much effort to fix I can fix our test suite.\n. That's great. Thanks, Erik!\nShould I close the issue now that it's fixed?\n. ",
    "judos": "I am confused. This doesn't work:\nTMLoginManager *loginManager = [TMLoginManager new];\n// paste here\nid classMock = OCMClassMock([TMLoginManager class]);\nOCMStub([classMock sharedInstance]).andReturn(loginManager);\nid loginManagerMock = OCMPartialMock(loginManager); // cut\nXCTAssertEqual([TMLoginManager sharedInstance], loginManager);\nBut if you move the line (see comments) then it works just fine.\n\nThis is expected behaviour.\n\nI find this very unintuitiv. If it can be improved I would love to have it different than now.. ",
    "ncarroll-mdsol": "Would love to see this implemented. Even better, it'd be nice if a second call to stub overwrote the first. This is useful for setting defaults in a test setUp block and then overriding in the specific tests as needed.\n. Thanks for the detailed response! I agree that it does create coupling between the tests. On the other hand, there are instances where I am testing a number of slightly different configurations. If we decide to change a method, or the manner in which an object is initialized, not having a setup method requires a change in every test. Perhaps this is preferable to the coupling between tests, but I've never seen any real issues with using a setup method.\nI think the idea of later stubs overriding earlier stubs is very intuitive, especially since other popular mocking frameworks (e.g. RSpec) do support this behavior.\nTheoretically, if someone were to create a PR with this functionality, would it have a chance of being merged?\n. ",
    "tinsukE": "For the time being you can use this workaround: in your test file, you can create a new protocol that implements the multiple ones you need:\nobj-c\n@protocol MyTestProtocol <MyProtocolA, MyProtocolB>\n@end\nand then mock it:\nobj-c\nid protocolMock = OCMProtocolMock(@protocol(MyTestProtocol));\n. ",
    "otusweb": "I'm working on iOS device (specifically against the simulator). Seems like AVCaptureDeviceInput really hates the new method.\nClosing as i don't think this is OCMock related\n. ",
    "Antondomashnev": "Is anybody going to merge this PR?\n. ",
    "mickeyreiss": "Thanks for the quick response :cactus: \nCan you go into a bit more depth on what quantifier syntax will look like?\nAt first blush, this solution goes against my expectations about which implementation details are relevant to my test. I might stub a method in my shared setup code that is invoked once in one test case but twice in another.\nWhat is your opinion on the backwards compatible solution of adding a new method overrideStub, which adds a new stub on the beginning of the list of recorders?\nobjectivec\n[id mock = [OCMockObject mockForClass:[MyObject class]];\n[[[mock stub] andReturnValue:@YES] enabled];\n[[[mock overrideStub] andReturnValue:@NO] enabled];\nXCTAssertTrue(mock.enabled, @\"It changes to disabled\"); // --> Fails because list of recorders is consulted in first-in-first-out order, and the for loop breaks on the first stub\nAs discussed in #103, stub matching gets a bit hairy, but this would ignore those details and work as if the overrideStub were added to the mock prior to the other call to stub.\n. ",
    "danielphillips": "\nPlease see the discussion on issue #103. A bit of time has passed since, but I'm still planning to add quantifiers to OCMock. \n\nAre there still plans to do this?. ",
    "jonah-neugass-ck": "Never mind. Fixed it.\n. ",
    "zixun": "my ocmock version is 3.1.2\n. ",
    "jamieforrest": "@Spilly Are you using Cocoapods 0.36 by any chance?\n. I was seeing something similar after upgrading to 0.36 and I had to delete all the xcconfig files from my project and re-run pod install. If you were seeing this before 0.36 though, it could be something else.\n. ",
    "Spilly": "I'm using 0.36.3 right now but I updated after i entered this issue. Should\nI try again?\nOn Fri, May 1, 2015 at 1:51 PM Jamie Forrest notifications@github.com\nwrote:\n\n@Spilly https://github.com/Spilly Are you using Cocoapods 0.36 by any\nchance?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/erikdoe/ocmock/issues/190#issuecomment-98233943.\n. \n",
    "jjconti": "I think it would.\n. ",
    "pietbrauer": "Hey Erik, thanks for your questions. I think I can clarify most of them:\n1. Adding the target is not affecting CocoaPods at all. CocoaPods still looks in your .podspec and uses only the source not the Xcode project.\n2. People would expect a prebuilt dynamic framework for iOS and Mac which you can build for each release using carthage build --no-skip-current and carthage archive OCMock. This will result in a OCMock.framework.zip which you will upload to the releases then.\nbash\n$ carthage build --no-skip-current\n*** xcodebuild output can be found in /var/folders/9v/9z2qkhhx57zbdn9876mq__497d7w_y/T/carthage-xcodebuild.QxZHcD.log\n*** Building scheme \"OCMock\" in OCMock.xcodeproj\n*** Building scheme \"OCMock iOS\" in OCMock.xcodeproj\n$ carthage archive OCMock\n*** Found Carthage/Build/Mac/OCMock.framework\n*** Found Carthage/Build/iOS/OCMock.framework\n*** Created OCMock.framework.zip\n1. Dynamic frameworks on iOS are only supported in iOS 8 and above. Carthage also only supports iOS 8 and above as it relies on dynamic frameworks. I don't think people will expect downloads of static libraries.\nI hope this clarifies most of the questions. :cat2: \n. Ping?\n. @erikdoe For me everything is normal. It also builds normally for all simulators and devices.\n\n. ",
    "sync": ":+1: \n. ",
    "shortstuffsushi": "This probably relates to #176.\n. For what it's worth, the documentation is actually incorrect. From my experience, it doesn't \"effectively remove stubs,\" they are still in place, and are still triggered just the same. Not sure if that's something you care about, but thought I'd point it out, at least.\nAs far as merging, that's fine, but that issue hasn't had any feedback for a few months. Is that something you're considering doing?\n. What you point out is the same I had figured -- this would work fine for a class because it's undoing swizzling (replacing the implementation), but since this isn't actually a class object, it doesn't really do anything.\nSo, yeah, the limitations could be an appropriate point for this. At least for the time being, though maybe just leave it off for now since it'll need to be rewritten if the other reset method is added. I think I will attempt to do so shortly. Thanks for the feedback.\n. ",
    "JamieREvans": "I've realized that I need to call OCMVerifyAll(objectMock) instead of OCMVerify(objectMock).\n. ",
    "clausjoergensen": "It's a instance method (method in a class, not a class method, heh), so that wouldn't work. I took a look at the code, and the only way I could see a way to prevent this name collision is for OCMock to follow Apple's guidelines around using a prefix. But that would break everything, so probably not a very good idea :(\n. ",
    "nlutsenko": ":octocat: \n. @erikdoe Ping?\n. Volunteer to start making it happen, just wanted to hear what @erikdoe and everyone here thinks.\n. @erikdoe I guess you guys are not actively working on this, right?\nJust want to have some sort of confirmation before I go down the rabbit hole of building it.\n. @erikdoe #259 Has most of it, let's either discuss it there or here...\n. @erikdoe Ping? Can we get your eyes on this, pretty please?\nThere is a PR attached to this issue (#259)\n. Surewhynot. Let me know if it doesn't work. \n. Whee!\n. @erikdoe Ping?\n. Whee!\n. Few things that are somewhat missing, but I am not 100% sure yet they are required to be added:\n- Tests\n  - Blocked by tvOS support in OCHamcrest\n  - Not sure how relevant important it is at this point, since it is used in a single test suite and could be simply disabled when testing for tvOS\n- CI\n  - Blocked by Travis-CI support for Xcode 7.1\n  - I am continuing to ping guys there and they have it on the roadmap\n- Deployment\n  - Not yet packaged and built for deployment, simply due to the fact that it would require compilation with xcodebuild from Xcode 7.1, which is probably not the best idea since it is still in beta.\nSince OCMock is used primarily for testing (right? no one is using this in prod?) - we can add all of these later, since the basic project works, compiles and based on me running our unit tests for Parse SDK - works great.\n. cc @richardjrossiii \n. This needs rebasing... let me get right on that.\nIn the meantime, @erikdoe what do you think about the points raised above in regards to  tests/CI/Deployment?\n. And done with conflicts...\nGoing to address the deployment now with a commit on top of this.\n. Updated the build.rb with the latest commit attached here to package tvOS framework as well.\n. Sure, that sounds good. Maybe extract it into a variable then, so it's easier to change?\nFwiw, it's failing for everyone for probably a looooong time now, since 8.2 SDK is not available any more :grin: \n. ",
    "richardjrossiii": "It would appear that __builtin_choose_expr is not doing as I had initially tested. I'll work on fixing it and get back.\n. Remove __builtin_choose_expr, now using a pointer typecast to prevent build errors.\n. @erikdoe Yep, we definitely could do that. I used the address as the key as it's unlikely to be recycled for the object, and we never need to read from it again. If you'd prefer a dummy string that's no issue at all.\n. :+1:  +1.\nThis should decrease overall memory usage without many downsides, certainly a good thing when profiling memory usage inside unit tests.\n. You can update your PR by force pushing to the source branch, FYI.\n. ",
    "thomasdeniau": "I'm hitting the same issue regularly. This makes tests unpredictable because they fail when run as part of a test suite but succeed individually. Making it easier to track down the cause of the leak would be super helpful.\n. ",
    "pellet": "+1 \nA static stopMockingAll method would be nice to chuck into the teardown method of a test suite.\n. ",
    "Wenzhi": "I cannot found out which test or test class caused it as it seems happened bwteen unit tests, the debugger stops and shows assemble code, instead of inside any unit test. The iOS version and device of the simulator is random. I had it happen in iOS 7.1, 8.1, 8.2, 8.3, both iPhone simulator and iPad simulator.\nI later removed OCMock in my Podfile, downloaded the latest version of OCMock from github and manual integrated it. The error seems stop, so I guess it's stale issue? Not sure if it relates to the way of integration at all.\nP.S. the podspec of OCMock doesn't reflect the most updated version of OCMock, it would be great if the Cocoapods users can also use the latest version of OCMock :)\nThank you~\n. ",
    "dshirley": "Interesting.\nThis is only happening with the 7.1 simulator running on Xcode 6.\nI do get a compile warning with this configuration.  When I change the code to pass a straight boolean rather than a NSValue the test passes.\nOddly, when I use Xcode 6 with an 8.4 simulator, I don't get the compile warning AND the test passes when passing an NSValue.\nI do recall that when I filed this issue I was trying to fix an issue on the iOS 7 simulator that Travis-CI uncovered.\nOn Xcode 7 I get the warning and it works either way (NSValue or BOOL)\nBottom line:  IMO it isn't worth investigating unless you want to support old simulators.\nI'm going to close this.\n. ",
    "d-ronnqvist": "The same problem seem to happen with other properties (I'm stubbing taskDescription of NSURLSessionDataTask). \nIt looks like it has something to do with the instance method signature being nil:\n[NSURLSessionDataTask instanceMethodSignatureForSelector:@selector(setTaskDescription:)]\nreturns nil for me (in Xcode 7)\n. It does not resolve the issue I was facing (on Xcode 7). That issue can very concisely be verified with this test:\n- (void)testCanStubTaskDescriptionOnNSRULSessionTask\n{\n    id mock = [OCMockObject mockForClass:[NSURLSessionDataTask class]];\n    [[mock stub] setTaskDescription:OCMOCK_ANY]; // stubbing setTaskDescription: fails\n    [mock setTaskDescription:@\"test-value\"];\n}\nShould I file a separate issue for that?\n. ",
    "jhoughjr": "I'll update my pod and check later today. seems i found some workaround.\nNever mind this previous comment. Xcode completed the wrong method it seems.\n. ",
    "CognitiveDisson": "0 objc_msgSend // line returnValue = [aValue retain];\n1 [OCMReturnValueProvider initWithValue:]\n2 [OCMStubRecorder andReturn:]\n3 [OCMStubRecorder(Properties) _andReturn]_block_invoke\n4 [ErrorHandlerBaseTests testThatErrorHandlerCreateAlert]\n. Yes, it is this issue. Thank you for your help and for a great pod.\n. Yes, you heard me right. This means that the object lives all the time of the test. This is a problem, because if I want to test UITapGestureRecognizer in another test, I can't do it. Also if test code includes work with UITapGestureRecognizer this can lead to problems. (failed test or crash)\n. ",
    "ole": "I'm not sure why the Travis build failed as I haven't changed anything in the file with the failing test. On my machine all tests succeed.\n. That's fine.\n. ",
    "packatino": "yes, that would be great :-)\n. You have to define the platform in your podspec file. I have created a pull request which fixes this issue: https://github.com/erikdoe/ocmock/pull/226\nWith that fix pod spec lint passes the validation :)\n. Thanks for pushing the new pod spec :)\n. ",
    "dbarden": "I guess its because of this, so for now, it would be necessary to add s.platform to the spec, to validate with Xcode < 7. From the documentation, I didn't get to disable only watchOS.\nI'm happy to take a look, but it's gonna be only by the end of next week. Unfortunately I'm on vacations and didn't bring my computer with me :)\n. ",
    "vincentisambart": "I suspect it's due to how the andReturn macro works.\nobjc\nrecorder.andReturn(infoDictionary);\nis equivalent to:\nobjc\nNSValue *value = [NSValue value:&infoDictionary withObjCType:\"@\"];\nrecorder._andReturn(value);\nIt seems that when optimizing, the compiler thinks it does not need to keep infoDictionary after creating the NSValue. value:withObjCType: does not seem to retain the object, so the dictionary ends up being deallocated before OCMock can retain it in _andReturn.\n. I was using the most recent version on CocoaPods, so 3.1.2.\nI tried my test in your iOS7Example I got from your git repo and it works fine, sorry for the trouble.\nIt would be really great if you could also push the last version to the CocoaPods servers though :)\nThanks for the great work.\n. Correction: It works with the DMG from the download page, but not with the git repo as the git repo's master doesn't seem to include the change from #206...\n. Thank you!\nI had a better look and in fact the reason is simple: I was testing with iOS7Example and the OCMStubRecorder.h it uses (Examples/iOS7Example/usr/include/OCMock/OCMStubRecorder.h) is still the old one.\n. ",
    "ashavit": "I can give it a shot. What is the minimum versions you would like to support?\n. Thanks. I think this should work(as far as I understood cocoa pods syntax).\nI'll give it a try in a few days. I don't have access to my computer.\n. @erikdoe it works know. Thanx.\n. ",
    "AndreyZarembo": "No it was 3.1.2. I'we updated project to 3.1.5 and it works. Sorry for panic )\n. ",
    "sarat-velumuri": "Hi,\nIs there any plan to address this enhancement?\n. Thank you Erik for the update.\nCan you please help me if there is any other way to achieve this? I am in real need of it.\nIf there is no other way, is it possible for me to revert that commit in my local repo and use the feature?\nPlease let me know.\n. Thank you Erik for the update\n. ",
    "benasher44": "+1 A lot of objects that we mock are themselves thread-safe, which other code takes advantage of, but then the thread-safety guarantees of those objects fall apart when being mocked. Really looking forward to this PR being merged.\n. @iangithubusername I noticed in testing that OCObserverMockObject does not have any @synchronized blocks guarding the recorders or centers arrays. To make OCMock thread safe, I think this type of mock object should be considered as well.\n. @iangithubusername @erikdoe so, I've spent some time investigating the performance issues with OCMock, which this branch somehow exacerbates. The tests run fine when run from Xcode, but they slow down significantly when run using xctool (which many of us use, including travis-ci by default). It turns out that the issue is that xctool's otest-shim is injected to the test bundle by xctool, when you use it to run the tests. For its own purposes, it defines hash and isEqual: for NSInvocation in a category. Their implementation appears to be much slower, and the trace ending with isEqual: bubbles straight to the top in instruments when you profile the tests running with xctool. OCMock implicitly uses isEqual: in -[OCMockObject handleInvocation:] on the line that does [invocations setObject:selflessInvocation forKey:anInvocation];. This call subsequently calls into the isEqual: method defined in the NSInvocation category in otest-shim in xctool. If you run the tests just using xcodebuild, the performance issue seems to disappear. I could find out more, as I'm still in the early stages of re-implementing our test-runner to use xcodebuild without xctool, but I thought I'd report these early findings here. If there's another way to implement the currently functionality without using NSInvocation's isEqual, then that should be an easy win.\n. @erikdoe sg2m\n. ",
    "danyowdee": "Thanks for pulling, even after you went the more exhausted route!\nI considered the macro wasn't worth it because I only saw this one public function, but it sure does read nicer that way. Sorry for the inconvenience this caused!\n. ",
    "jasonhotsauce": "Just verified that it also happens on iOS 8.4\n. I found the reason why it crashes. If you are using Xcode 7, do not enable Address Senitizer in test. \n. ",
    "FlorianMielke": "I've only discovered this issue when the array literal contains at least two objects. When there is just one object I've never had an issue.\n. 3.4.1 does not fix it for me. Still getting crash.. Yes.. ",
    "blackivory86": "+1\nI have the same problem with andReturn(). Even with just one object in the array.\nassigning to a local variable solves the issue for me as well.\n. Sorry for beeing unclear:\nI don't want to test my ControlEventObserver class at all. That's just a helper to verify the behaviour if my custom UIControl.\nWhat I'm trying to do is to verify that my UIControl delivers the expected UIControlEvents to the object that has registered through the [UIControl addTarget:action:forControlEvent:] when it receives Touch-Events. Because we have serveral custom UIControls I want to get rid of a lot of boilerplate code just to set up the expectations. My current idea was to create expectations from a selector which is created by that actionForControlEvent: \nMy current solution is a huge macro including a switch over the different UIControlEvent types that creates the expectations.\nTLDR:\nIf it's possible to create an expectation or stub from a selector that would be great. If nobody else needs that stuff it's nothing of high priority.\n. ",
    "BohdanOrlov": "@erikdoe could you please consider my PR? I would appreciate this very much since OCMock 3 performance prevents me from upgrading from OCMock 2. \n. @erikdoe please have a look on the workaround I implemented as you suggested #285 \n. Dynamic subclass cache as workaround to #253 \n. ",
    "JKuzimski": "@erikdoe it looks like with 9.3 OCMock again run fast\n. ",
    "awalter": "2.2.4 downloaded today from http://ocmock.org/download/ does not have the issue, nor does 2.2.4 built on my own machine for iphoneos9.0 & iphonesimulator9.0.  Neither does 2.2.3 or 2.2.1 downloaded in the past (~2014 & ~2013).\n3.0 from https://github.com/erikdoe/ocmock/releases/download/v3.0/ocmock-3.0.dmg has the problem as does 3.1.2, 3.1.5 & 3.2.\n. ",
    "psla": "What about verifying arguments like int?\nid foo = OCMStrictClassMock(...)\nOCMStub([foo bar:4])\n[foo bar:5];\nOCMVerifyAll(foo);\nsuch a test passes, unless I did something wrong.. ",
    "devValley": "Badly need support for tvOS! Love OCMock.\n. @nlutsenko Do you think this is a good idea to add your repo as a submodule to my repo, until you tvOS support is added to the original repo? Thanks!\n. ",
    "bkbeachlabs": "This seems like all it is doing is removing symbols that could be, if anything, helpful some day. I'm not sure that its a good idea to merge.\nFrom the comments in the PR you linked, it seems that there was consensus that this issue is actually an Xcode 7 bug. So this is also only fixing the issue on outdated versions.. ",
    "yakovsh": "This happens for us when using the pre-built OCMock library without CocoaPods.\n. Maybe it is possible only to enable this option in the release builds and not debug builds, which would allow developers of OCMock to debug.\n. ",
    "johnm03": "I am using Xcode 9.4 and seems to be getting this warning \nwarning: /var/folders/g9/mxr37xcs33g38q39zkf76xb00000gp/C/com.apple.DeveloperTools/7.2-7C68/Xcode/SharedPrecompiledHeaders/OCMockLib-Prefix-cvyjwfoqmezcktanihzrttyjxdnk/OCMockLib-Prefix.pch.pch: No such file or directory\nManaged to fix it by recompiling the OCMock Static lib with Precompile Prefix Header set to NO . Another solution is to set the Debug Information Format to DWARF. ",
    "mciuba": "It seems OCMVerify uses OCMVerifier under the hood. Is it possible that OCMVerifier checks if its mockObject is actually a mock in its forwardInvocation: method?\n. ",
    "manan19": "This exact issue was also reported last month \nhttps://github.com/erikdoe/ocmock/pull/235#issuecomment-151277590\n@dwabyick This might be the fix you're looking for\n. ",
    "davidstites": "Sorry about that \u2014\u00a0first commit to this project, so I am learning the codebase.  I have updated my PR by updating the branch.\n. ",
    "manuyavuz": "Hmm, accuracy check in the test case works on my local machine, but fails in travis. It seems like runUntilDate does not return at precise date, but I'm not sure. Suggestions on how to change the test case?\n. Nice, thanks for the great library!\n. ",
    "piotr-tobolski": "Hi @erikdoe I forgot that on 32-bit iOS I need to initialize non-pointer local variables with correct values. I have fixed it some time ago. Can this be merged now?\n. ",
    "manicaesar": "@erikdoe - exactly, the test has to wait, but we can make use of XCTestExpectation and -[XCTestCase waitForExpectationsWithTimeout:handler:]\n. ",
    "sevenblue": "Has this issue resolved \uff1f\n. ",
    "mattrobmattrob": "I've briefly investigated this but it appears that the latest commit of OCMock (afb7bc846f043d5dcea64a698d95da35b8597f07) fixes this issue. At least with the failing tests replicated in the OCMock project.\nVerified that dropping the new library (v3.3) into your sample project fixes the problem as well.\n. > Executed 119 tests, with 0 failures (0 unexpected) in 1.884 (2.437) seconds\nNot sure what's causing the Travis CI failure.\n. Investigating test failures in what seems to be the OCMockLib tests.\n. Test failures seem to be caused by va_arg(...) behaving badly when compiled originally for a 64-bit system and then used on a 32-bit system. Not sure if this is a show stopper or not or would be fixed when you ship a new version of the library.\n. ",
    "stepheng": "Great - I'm not able to reproduce anymore. Thanks.\n. ",
    "NickyWeber": "My bad, I eventually forgot to call stub on the mock object. Working as expected.\n. ",
    "jack2gs": "Thanks for the reply. I'v sovled it by using [OCMArg anyPointer]. :)\n. ",
    "alanf": "@carllindberg would you mind looking please?\n. ",
    "pdillon3": "I'm not sure why it was an mm. I noticed it while searching through my project to remove all unnecessary mm files.\n. ",
    "Nomad00": "Upon some further experimentation, it does appear this issue is with CocoaPods. It is occurring whenever a Pod is within a Test target and not in the main target. Opened an issue there.\nThank you for your comment & leaving this open for a bit - may be helpful if other users are experiencing the same issue.\nWhat is specifically interesting about this issue is if I include OCMock within the main target of the Podfile, then it works as it did before Xcode 7.3. Not a great workaround, but is something.\n. Closing this as it is apparent it is either a CocoaPods issue or potentially Xcode.\n. ",
    "vovkasm": "I'am experienced this issue without CocoaPods, so it is unrelated. With OCMock.framework added to \"UnitTests\" target I got this errors:\n2016-06-28 10:56:31.740 MyApp[84918:2895619] Failed to load test bundle from file:///Users/vovkasm/Library/Developer/Xcode/DerivedData/MyApp-amomkiuqjqonxyeytxdxigurvlbx/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/UnitTests.xctest/../UnitTests.xctest/: Error Domain=NSCocoaErrorDomain Code=3587 \"dlopen_preflight(/Users/vovkasm/Library/Developer/Xcode/DerivedData/MyApp-amomkiuqjqonxyeytxdxigurvlbx/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/UnitTests.xctest/UnitTests): Library not loaded: @rpath/OCMock.framework/OCMock\n  Referenced from: /Users/vovkasm/Library/Developer/Xcode/DerivedData/MyApp-amomkiuqjqonxyeytxdxigurvlbx/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/UnitTests.xctest/UnitTests\n  Reason: image not found\" UserInfo={NSLocalizedFailureReason=The bundle is damaged or missing necessary resources., NSLocalizedRecoverySuggestion=Try reinstalling the bundle., NSFilePath=/Users/vovkasm/Library/Developer/Xcode/DerivedData/MyApp-amomkiuqjqonxyeytxdxigurvlbx/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/UnitTests.xctest/UnitTests, NSDebugDescription=dlopen_preflight(/Users/vovkasm/Library/Developer/Xcode/DerivedData/MyApp-amomkiuqjqonxyeytxdxigurvlbx/Build/Products/Debug-iphonesimulator/MyApp.app/PlugIns/UnitTests.xctest/UnitTests): Library not loaded: @rpath/OCMock.framework/OCMock\nI'am resolve this by adding static library instead of \"iOS Framework\" from ocmock-3.3.dmg.\n. ",
    "pwillsey": "Here's an example of a test that reproduces the problem, it has a really long stack trace but it crashes in NSInvocation+OCMAdditions.m:55 on this line:\nObjective-C\nNSMutableArray *retainedArguments = [[NSMutableArray alloc] init];\n``` Objective-C\n@implementation TestOCMock\n\n\n(void)setUp {\n    [super setUp];\n    id arrayClassMock = [OCMockObject niceMockForClass:[NSMutableArray class]];\n}\n\n\n(void)tearDown {\n    [super tearDown];\n}\n\n\n(void)testExample {\n}\n\n\n(void)testPerformanceExample {\n    [self measureBlock:^{\n    }];\n}\n\n\n@end\n```\n. Thanks for your help!\n. ",
    "GeroHerkenrath": "Thanks a lot, this explains everything. It actually explained to me how OCMock stubs methods. Until now I thought it stubs every instance's method, my bad. \nI am busy with some other stuff for the SDK for now, but will probably include your draft in the next patch.  I was hesitant at first to change my implementation just because I can't get a test for it to work, but the idea with a creating method such as new (or another class convenience creator) is a good solution.\nSince this is not really an issue with OCMock I'll close the issue.\n. ",
    "nikolaykasyanov": "I'm really sorry for bothering you (I've read the contribution guidelines), but is there any chance to get this merged?\n. @erikdoe thanks for the update! #302 looks great.\n. @erikdoe thank you!\n. Looks like this: https://github.com/erikdoe/ocmock/pull/302. ",
    "valeriomazzeo": "My class implements initWithCoder could it be related?\n. sorry @erikdoe, your first suggestion fixed the issue, then I forgot to reply \ud83d\udc4d. ",
    "hanjt": "@erikdoe My code is OCMStub([class method:mockArgument]).andReturn(YES). It crashed when run. The exception message is [NSException raise:NSInternalInconsistencyException format:@\"** Method init invoked twice on stub recorder. Are you trying to mock the init method? This is currently not supported.\"];. ",
    "LinkRober": "Thx,I got it\n. I hava a enmu:\ntypedef NS_ENUM(NSUInteger, MSImageCollectionViewType) {\n    MSImageCollectionViewFoodType = 0,\n    MSImageCollectionViewNormalType = 1,\n};\nand  I want to  return a enum value when stub\n[[[mock stub] andReturnValue:MSImageCollectionViewNormalType] collectionType];\nbut, I can't get a correct value.why?\n@erikdoe \n. ",
    "tarbayev": "Actually variadic macros is still possible, see this link, but it's a bit bulky.\nAlso, I'd prefer quantifier at second place, especially with universal OCMVerify version. \nBTW, why do you omit \"exact\" version of quantifier (e.g. [OCMQnt exactly:2])?\n. > Was there a reason why you didn't keep the old methods (without protocols / with single protocol) and have them forward to the new ones (with protocol / with multiple protocols)?\nWell, it's just better to have single entry point for unit testing instead of multiple ones, the latter increase the amount of paths to be covered. Verification of forwarding methods is tricky (we cannot use OCMock partial mocking for testing OCMock itself) and I always try to avoid that.\nBut I respect your concern, so I'll put old methods back.. ",
    "bilby91": "I'm getting OCMock/OCMVerifier.h file not found :(. @erikdoe my bad! I didn't realize that isEquals was overwritten.\nClosing the issue. Thanks again @erikdoe .. ",
    "soranoba": "@carllindberg \nI have questioned the exception that is thrown observerMock.\nIf we don't use observerMock and multiple calls to the stub and expect, exception won't throw.\nHowever, in the way we need to do to alternately the OCMExpect and the method call.\nThis is a difficult when it use async.\n. @erikdoe \n\nYes, mock objects will retain the arguments of invocations. They have to, because otherwise the arguments won't be around for later verification with OCMVerify. For details see: https://github.com/erikdoe/ocmock/blob/1f0f56c91a3e20917efbbb81c91be22f5b0f43a5/Source/OCMock/OCMockObject.m#L323-L331\n\nWhen I was investigating my problem, I noticed that caused the instance not to be freed until stopMocking, because this location save the invocatation.\nI understood to save for verify, but I did not understand if it should do it all.\nIs this necessary with stub?\n. https://github.com/erikdoe/ocmock/compare/v3.4...v3.4.2#diff-7d78571eb78d6c8da84c75e938c87137R98\nThis change part seems to be affecting, but it crash when revert to restoreMetaClass.. ",
    "marcuswu0814": "Sorry, I think I do it in wrong way.\nI read the doc write: _Class methods on NSString and NSArray cannot be stubbed or verified_\nPlease help me to close this issue, thanks.\n. ",
    "alexito4": "Aha, what I was expecting \ud83d\ude3f  So there is nothing we can do with OCMock to fix this right? I would have to use the real object or make a specific mock object that has the weak property in order to avoid this retain cycles.\nBTW, the fact that the objects in the invocations won\u2019t be around when OCMVerify runs is related to some async operations? Because couldn\u2019t be assumed that the local declaration of the variable (in my example B *...) will keep the objects around during the executions of the tests? Although I guess that there are other cases when that is not true \ud83d\ude1e \nThanks for the reply btw \ud83d\ude09 \n. Thanks, it makes sense to make OCMock be prepared for those cases \ud83d\ude09 \nAs you can see in the test project A is leaked, you can check that you never see the log for deallocation. As the cycle is created between A and B both strongly retaining each other.\n. Iep sorry for not being clear.\nAs I understand is here https://github.com/alexito4/OCMock_TestLeaks/blob/master/TestLeaks/A.m#L25 where A is passed as an argument to setDelegate: of the mock and is where the cycle is created.\n. ",
    "jtoce": "Just saw this issue in 3.4.2 in my code. I was getting a crash after retaining a mocked object argument. After seeing this SO answer I modified my code using __unsafe_unretained which resolved the crash.\nvoid (^proxyBlock)(NSInvocation *) = ^(NSInvocation *invocation) {\n    __unsafe_unretained SomeMockedClass *mockedObject;\n    [invocation getArgument:&mockedObject atIndex:2];\n    XCTAssertNotNil(mockedObject)\n    [expectation fulfill];\n};\nOCMStub([partialMockedOtherObject methodToBeMocked:[OCMArg any]]).andDo(proxyBlock);. My developers have hit this if they get in the habit of creating mocks in the -[XCTestCase setUp] method. Here is my example code that repros:\n```\nimport \nimport \n@interface OCMockTestClass : NSObject\n\n(void)methodA;\n(void)methodB;\n(void)doNotCall;\n\n@end\n@implementation OCMockTestClass\n\n\n(void)methodA {\n    [self doNotCall];\n}\n\n\n(void)methodB {\n    [self doNotCall];\n}\n\n\n(void)doNotCall {\n    NSAssert(NO, @\"Do not call!\");\n}\n\n\n@end\n@interface OCMockTestCase : XCTestCase\n@property (nonatomic, strong) OCMockTestClass obj1;\n@property (nonatomic, strong) id partialMockObj1;\n@property (nonatomic, strong) OCMockTestClass obj2;\n@property (nonatomic, strong) id partialMockObj2;\n@end\n@implementation OCMockTestCase\n\n\n(void)setUp {\n    [super setUp];\n    self.obj1 = [OCMockTestClass new];\n    self.partialMockObj1 = OCMPartialMock(self.obj1);\n    self.obj2 = [OCMockTestClass new];\n    self.partialMockObj2 = OCMPartialMock(self.obj2);\n}\n\n\n(void)testExample1 {\n    // Will fail with error: -[OCMockTestCase testExample1] : failed: caught \"NSInternalInconsistencyException\", \"Do not call!\"\n    OCMStub([self.partialMockObj1 doNotCall]);\n    [self.obj1 methodA];\n}\n\n\n(void)testExample2 {\n    OCMStub([self.partialMockObj2 doNotCall]);\n    [self.obj2 methodB];\n}\n\n\n@end\n```. ",
    "shorbenko": "On iPod Touch 5th gen (armv7 arch) app crashes with EXC_BAD_ACCCESS if I try to run observer mock tests from the standart test suite:\nhttps://raw.githubusercontent.com/erikdoe/ocmock/master/Source/OCMockTests/OCObserverMockObjectTests.m\n. ",
    "tirodkar": "Apologies, I meant the UIApplication::sendEvent: method. I get the issue whenever I run code similar to this:\nid mock = [OCMockObject partialMockForObject:[UIApplication sharedApplication]];\n  [[mock stub] openURL:[OCMArg any]];\n  [[UIApplication sharedApplication] sendEvent:[[UIEvent alloc] init]]; // Causes the recursion.\n  [mock stopMocking];\nI understand this isn't completely clear without my swizzling code for sendEvent:, I'll send it across asap. Thanks.\n. +1 to this. Any update?. ",
    "khandpur": "when OCMock calls original implementation, does it preserve the _cmd?\nfor example if I have something like:\n- (void)foo {\n  NSLog(@\"Original foo\");\n}\n\n(void)swizzle_foo {\n  NSLog(@\"Swizzled implementation\");\n  [self swizzle_foo];\n}\n\nand then I swizzle foo with swizzle_foo, the call to [self swizzle_foo] will call the original IMP with _cmd set to @selector(swizzle_foo) not @selector(foo). Is that what OCMock does?. Hi Eric, any progress on this? As a workaround we're pinning ocmock to 3.4.1 until this is fixed.. ",
    "dogo": "@erikdoe Thanks\n. ",
    "umut-genlik": "I get the same error too, exc_bad_access, everything works perfect when test target is ios 8 or 9,  but ios 10 simulator in xcode 8 throws an error.\nwhen I put breakpoints I see that this line causes it\nid mockSharedInstance = OCMPartialMock([AVAudioSession sharedInstance]);\n\nLooks like an infinite loop to me.\nwhole function is \n```\n- (void)testPresentFromRootPermissionReportResult {\nid deviceUtilMock = OCMClassMock([XMDeviceUtil class]);\nOCMStub([deviceUtilMock isSimulator]).andReturn(NO);\n\nid strategyMock = OCMClassMock([XAPermissionStrategy class]);\nid viewControllerMock = OCMClassMock([UIViewController class]);\n\nXAStrategyResult *result = [XAStrategyResult resultForStrategy:strategyMock];\nresult = [result requestRecordPermissionResult:YES];\n\nNSError *error = [[NSError alloc] init];\n\n//Setup the mock for AVAudioSession, //They have to not have permission\nid mockSharedInstance = OCMPartialMock([AVAudioSession sharedInstance]);\nOCMStub([mockSharedInstance recordPermission]).andReturn(AVAudioSessionRecordPermissionUndetermined);\n\nXAPermissionStrategyService *service = [XAPermissionStrategyService serviceWithDevServer:YES];\nid servicePartialMock = OCMPartialMock(service);\nOCMExpect([servicePartialMock reportPermissionStrategyResult:result success:[OCMArg any] failure:[OCMArg any]]);\n\nid settingsMock = OCMClassMock([XASettings class]);\n\nid permissionServiceMock = OCMClassMock([XAPermissionStrategyService class]);\nOCMStub([permissionServiceMock service]).andReturn(servicePartialMock);\n\n//Expect this to be called and pass the args through\nOCMExpect([strategyMock fromViewController:viewControllerMock requestRecordPermission:([OCMArg invokeBlockWithArgs:result, error, nil])]);\n\n //the test\nXARecordPermissionCompanionViewController *companion = [[XARecordPermissionCompanionViewController alloc] initWithStrategy:strategyMock settings:settingsMock];\n[companion presentFromViewController:viewControllerMock];\n\nOCMVerifyAllWithDelay(strategyMock, 1);\nOCMVerifyAllWithDelay(servicePartialMock, 1);\n\n}\n```\n. This solved it but I am not sure if it is the correct way to do it?\nhttps://blog.uship.com/shippingcode/unit-testing-around-singletons-with-ocmock/\n```\nid mockSharedInstance = [OCMockObject niceMockForClass:[AVAudioSession class]];\n    [[[mockSharedInstance stub] andReturn:mockSharedInstance] sharedInstance];\n    OCMStub([mockSharedInstance recordPermission]).andReturn(AVAudioSessionRecordPermissionDenied);\n....test then\n[mockSharedInstance stopMocking];\n```\n. ",
    "amitfluke": "I see random crashes while using OCMock for iOS 10 simulator. Is there any plan to release a new version for iOS 10\n. I have seen similar issues in iOS 10 for iOS 9 it works fine\n. ",
    "khaire1111": "thanks for replies,\n I create custom frameword and implement into my project it's working all flow on debug mode but when I create same as release mode it gives error like above mentioned.\n. ",
    "joeljfischer": "Also seeing this error elsewhere:\nCould not cast value of type 'OCClassMockObject' (0x111f31518) to 'Swift.CustomDebugStringConvertible' (0x111e590e8).\nfor this code:\nobjc\n__block id fileManagerMock = OCMClassMock([SDLFileManager class]);\n// ...\nexpect(testManager.fileManager).toNot(beNil());\n. ",
    "julia-godoy": "Hello,\nThank you for the answers.\n@carllindberg  I observed that when the test fails (iOS < 10.0), on OCMEqualTypesAllowingOpaqueStructsInternal(), the strings received are \"{?=dd}\" and \"{CLLocationCoordinate2D=dd}\", and the method returns NO, on this part:\n/* If the names are not equal, return NO */\n if (type1NameLen != type2NameLen || strncmp(type1, type2, type1NameLen))\n        return NO;\nWhen the test passes (iOS  >= 10.0), on  OCMEqualTypesAllowingOpaqueStructsInternal() the strings received are \"d\" and \"q\", and the method returns YES.\n@erikdoe , About tha failing test, there's the code, where visitMock is an OCMClassMock of CLVisit:\n```\n- (void)testVisited\n{\n    [self backgroundTest: ^{\n        CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(19, 19);\n        NSInteger acc = 20;\n        NSDate *date = NSDate.date;\n        OCMStub([self.visitMock coordinate]).andReturn(coordinate);\n        OCMStub([self.visitMock horizontalAccuracy]).andReturn(acc);\n        OCMStub([self.visitMock arrivalDate]).andReturn(date);\n    //here there was some code that was't relevant for the crash\n\n    [self.dataCollector visited:self.visitMock];\n}];\n\n}\nThe test crashes on the first line of the \"visited\" method, that receives the CLVisit mocked object as a parameter:\nCLCircularRegion *region = [[CLCircularRegion alloc] initWithCenter:visited.coordinate\n                                                                 radius:visited.horizontalAccuracy\n                                                             identifier:@\"clVisit\"];\n```\nThe program crashes when visited.coordinate is invoked, and the exception (** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Return value cannot be used for method; method signature declares '{?=dd}' but value is '{CLLocationCoordinate2D=dd}'.') is raised.. Hello,\nThank you for the fix, it worked for me!. ",
    "werner77": "I created a pull request to fix this bug here\n. ",
    "lilyball": "I just hit this same issue, with OCMock 3.3 (which the release notes claims makes mocking thread-safe).\nI believe the root issue here is OCMock's class mocking isa-swizzles the metaclass prior to installing methods. This means that background threads may start interacting with the metaclass while it's in the process of installing methods, which is pretty bad.. Since I'm not sure if moving the metaclass swizzle to the end is safe (I don't know if any of the intervening code relies on it already being installed), I believe a safe fix is to reorder two lines in -setupForwarderForClassMethodSelector::\n```diff\ndiff --git a/Pods/OCMock/Source/OCMock/OCClassMockObject.m b/Pods/OCMock/Source/OCMock/OCClassMockObject.m\nindex f8a8180..39b5f22 100644\n--- a/Pods/OCMock/Source/OCMock/OCClassMockObject.m\n+++ b/Pods/OCMock/Source/OCMock/OCClassMockObject.m\n@@ -148,8 +148,8 @@ - (void)setupForwarderForClassMethodSelector:(SEL)selector\n Class metaClass = object_getClass(mockedClass);\n IMP forwarderIMP = [originalMetaClass instanceMethodForwarderForSelector:selector];\n\n\nclass_replaceMethod(metaClass, selector, forwarderIMP, types);\n     class_addMethod(metaClass, aliasSelector, originalIMP, types);\nclass_replaceMethod(metaClass, selector, forwarderIMP, types);\n }\n```. @erikdoe I assume you're getting notifications for issue updates anyway, but just in case, I'm mentioning you as this is a nasty issue that has been causing spurious test failures for us for a long time and I'm surprised that this ticket never got a response.. @erikdoe Can you please take a look at this? It's a real issue with a trivial fix.\n\nFWIW, it turns out that uninstalling class mocks isn't thread safe either, which doesn't seem to be a solvable short of simply never destroying the dynamically-created class pairs, but in my experience the uninstall issue crops up a lot less frequently than the install issue did.. ",
    "lkuczborski": "Yeah, the problem occurs when you switch from old import format to module import format. Probably this should be checked on a fresh Xcode project with only this one pod added as this may as well be a CocoaPods configuration problem.... ",
    "njx": "@erikdoe Sorry, it doesn't look like I got the notification for your previous request for confirmation. I will try to take a look this week and let you know if the problem is fixed.. @erikdoe Verified that it fixes the test case. Unfortunately I'm not in a good position to test the original issue in our codebase since we ended up implementing a workaround long ago and it would be some work to unwind, but I'm pretty confident that if the test case is fixed then we're good. Thanks!. ",
    "maxfriedrich": "Mocking managed objects is actually a feature since OCMock v3.4. It seems fine with Xcode 9 when a iOS 10 or any macOS SDK is selected, it only breaks on iOS 11. I ran the OCMockTests on an iOS 11 simulator and they crash as well (-[OCMockObjectPartialMocksTests testMockingManagedObject]) with the same stack trace.\nAny ideas on this? We use mogenerator and have custom logic in our NSManagedObject subclasses so there aren't any protocols that we can mock instead of the managed objects.. ",
    "DanieleMoonPig": "I have some old test that are using PartialMock on a NSManagedObject, on iOS 11 I have the same problem. Exactly like @koke described. We have used the ManagedObject Generator too and no protocols, this migration will cost me a lot of time! \nMy solution for now is remove the OCMPartialMock on ManagedObjects and create real mocks.. ",
    "Kieran2k15": "Same problem, suddenly started crashing on XCode 9 on iOS 11.. ",
    "YuriSolodkin": "I have the same issue. ",
    "sergiobaro": "I have the same problem. Xcode 9 on iOS 11.. ",
    "adavalli123": "Same problem :(. ",
    "givip": "It's seems that bug not depend on Xcode 9. Problem is in iOS 11, on iOS 10 simulator in Xcode 9 all works.. I'll check only on Monday. Thanks.\n\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0441 iPhone\n\n21 \u043e\u043a\u0442. 2017 \u0433., \u0432 22:15, Erik Doernenburg notifications@github.com \u043d\u0430\u043f\u0438\u0441\u0430\u043b(\u0430):\nCan you please confirm whether this fix works for you? If it does it'd do a small release.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @erikdoe Not working for PartialMock, in case of following initialisation\nOCMPartialMock([[ManagedObject alloc] initWithEntity:entity insertIntoManagedObjectContext:context]);\nI think that better workaround will be replacement NSManagedObject metaClass to NSObject metaClass.. \n",
    "murthyveda2000": "It did not work for me. I am still getting a crash.\n35207  0x00000001372f7ce2 in -[OCClassMockObject setupForwarderForClassMethodSelector:] at OCClassMockObject.m:151\n35208  0x00000001372f7c19 in __54-[OCClassMockObject prepareClassForClassMethodMocking]_block_invoke at OCClassMockObject.m:139\n35209  0x00000001372f71d3 in +[NSObject(OCMAdditions) enumerateMethodsInClass:usingBlock:] at /OCMock/NSObject+OCMAdditions.m:69\n35210  0x00000001372f7ac4 in -[OCClassMockObject prepareClassForClassMethodMocking] at OCClassMockObject.m:125\n35211  0x00000001372f7662 in -[OCClassMockObject initWithClass:] at OCClassMockObject.m:33\n35212  0x00000001372fe0f2 in -[OCPartialMockObject initWithObject:] at OCPartialMockObject.m:35\n35213  0x00000001372fb0d4 in +[OCMockObject partialMockForObject:] at OCMockObject.m:59.",
    "seanhenry": "This workaround fixed the issue for me. ",
    "Applitom": "Hi @erikdoe, I think the other crashes happens when we try to mock an object that inherits from NSManagedObject. \nPlease see how I implemented your workaround to support this scenario:\nhttps://github.com/erikdoe/ocmock/compare/master...applitom:master\nThanks,\nTomer. Hello,\nI'm sorry about the late response (better late than never \ud83d\ude04). \nI made a little example of the crash, I hope it explains our problem better.\nYou can find it here:\nhttps://github.com/Applitom/ocmock-issue339-fix\nThanks!. Hi @erikdoe,\nThanks, I can confirm that now it's working for me when I point to master branch.\ncould you please release new version with this fix?\nThanks,\nTomer.. Hello,\nI'm sorry about the late response (better late than never \ud83d\ude04). \nI made a little example of the crash, I hope it explains our problem better.\nYou can find it here:\nhttps://github.com/Applitom/ocmock-issue339-fix\nThanks!. ",
    "rt-bink": "@erikdoe I've been updating our companies project to iOS 11 and Xcode 9. As a result, I've also come into contact with this issue. I've updated the pod spec to use 3.4.1 and the above issue presents when using a partial mock on a managed object.. ",
    "PierreEc": "@erikdoe OCMock 3.4.1 doesn't fix the crash with NSManagedObject for me. However, the implementation of your workaround suggest by @Applitom correct it\n. @erikdoe, as I told you on 22 Feb, the workaround suggest by @Applitom correct the problem for me, but not your workaround. To reproduce it, just use partialMock for a NSManagedObject.. ",
    "reni99": "Hi there\nSo do you plan to merge the workaround suggest by @Applitomthis into master too?\nThx!\n. ",
    "xlbs-rm": "Hi, i had the same problem with a crash for partialMockForObject with OCMock 3.4.1.\nAdding the changes from https://github.com/erikdoe/ocmock/pull/354/commits/9d2a803dedfe625983684fa7b2b78a2d241f62b8\nfixed the crash and the (old) test seem also to work.\nPlease add this to a new Release. ",
    "alanterranova": "Regarding the API, what about the suggestions atop #347?. In some cases I can nil the mocks in question, but not mocks that need to be verified. Explicitly releasing the objects under test is disallowed in ARC. That's where having the ability to release (or simply not retain) arguments would be useful.. Done.. ",
    "nchavez324": "I also agree that there needs to be a way to specify this behavior for testing deallocations, as described in #347 -- there isn't another way to do so outside of making the tests non-ARC, which is pretty unreasonable in 2017. +1. ",
    "bErKut": "Hi. Any chances this pull request will be merged? . ",
    "kos9kus": "I clone repo and build a static library on my own, I do that in ordinary way, XCode builds under deferent archs then I make a fat lib via lipo . Frankly, I didn't find yours release library. Is everything fine there?!. ",
    "PierreGagelin": "This symbol is used to make source-based code coverage. You probably have a library compiled with \"-fprofile-instr-generate -fcoverage-mapping\" flags.. ",
    "pletoss": "Hey. So I had an issue and noticed this as well. When will this PR get into a new version on cocoapods ?. ",
    "swhitty": "This PR created a regression, If 2 partial mocks are created with the same underlying Class type, then the first mock stops forwarding @selectors to the real object.\nobjc\np1.name = @\"Person 1\";\np2.name = @\"Person 2\";\nPerson *mock1 = OCMPartialMock(p1);\nmock1.name == @\"Person 1\"\nPerson *mock2 = OCMPartialMock(p2);\nmock2.name == @\"Person 2\"\nmock1.name == nil //\ud83d\ude31. Yes I have noticed this also.\nobjc\np1.name = @\"Person 1\";\np2.name = @\"Person 2\";\nPerson *mock1 = OCMPartialMock(p1);\nmock1.name == @\"Person 1\"\nPerson *mock2 = OCMPartialMock(p2);\nmock2.name == @\"Person 2\"\nmock1.name == nil //\ud83d\ude31. ",
    "SFrost007": "We use OCMock as a child project of our main (iOS) project. When I perform the suggested changes on our parent project, the only resultant diffs to OCMock are identical to the *.xcscheme changes in this PR, with no changes to project.pbxproj.\nLooking at the diff, these changes seem reasonably harmless and allow a project with a setup similar to ours to build without warnings/prompts.\nWould it be possible to reduce the scope of this PR by removing the project file changes? Or would you be happy if I open a \"competing\" PR which just performs the xcscheme changes, to test this on Travis CI?. ",
    "jduquennoy": "Same analysis for me, it is a side effect of 63aa2bbde90091bfe3c00441673b712e4e541081 part of branche \"davidsansome-dispose-first-dymanic-subclass\", merged by ae40cea3bb4c8bef739022fa96690467f3e6348d.. ",
    "jaredgrubb": "Are you open to patches to add comments to most/all of the public methods/macros?. ",
    "erikdtw": "This does look like a bug, and at the moment I have no explanation as to where the ocmock_replaced_ocmock_replaced___new comes from. It tries to invoke this selector but that could easily be a side effect from (erroneously) having redirected the new method twice.\nOne thing I wonder, if I read the stack trace correctly, the problem occurs during the logging of a message. Is it fair to assume that this is not part of the actual test? Do the crashes stop if you comment out the logging? . ",
    "jasongregori": "I'm not 100% sure why I have to do this but I believe it is because the arm64 version of objc can use the same functions for struct returning functions. Here is a little evidence: https://twitter.com/gparker/status/378082112684843008\nNot sure if there is a better #ifdef that I could do instead of __arm64__\n. ",
    "benadida": "NSManagedObject seems like such a special snowflake of iOS, it probably makes sense to special-case it.\n. ",
    "pawel-sekara": "Actually it would make sense to keep this line just for backward compatibility.\n. ",
    "Drewsmits": "On Xcode 6.2 I'm seeing  \"Unknown warning group '-Wunused-getter-return-value', ignored.\" with this addition. Do you silence this warning in your setup?\n. "
}