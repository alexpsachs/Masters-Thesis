{
    "nikic": "My original reasoning was that normally people use semicolon style namespaces instead of the braced onces and thus it should be put as a seperate statement. But you are probably right that it makes more sense to regard the statements as subnodes of the namespace. I changed the behavior towards that in fb45e8a3.\n. The parser did support this, but the pretty printer failed to print it. Fixed in fb45e8a.\n. I collect the last encountered doccomment as of 78f15cd5. It can be fetched using NodeAbstract->getDocComment().\nI'm not entirely sure that the implementation is correct (because the parser code is undocumented and hard to understand), but in my tests it worked. Any further bug reports appreciated.\n. Hi Johannes! I don't think that type inference should be part of a parser library: Type inference is a very broad topic. It can go anywhere from simple inference using doccomments to most complex control flow analysis. Thus I think that it would be better suited in a separate library (if you already wrote some code for type inference I would love to see that, because it would be quite useful for me, too).\nConcerning the performance problem: Can't you just register the type inferring visitor as the first one and do type inference in enterNode? That way all other visitors should have the inferred data available.\n. I just added a visitor PHPParser_NodeVisitor_NameResolver (ab72f98570ff745b92aa75ea7981be8bd0d151ff).\nIt'll try to resolve all names to fully qualified ones. It won't resolve dynamic names (obviously) and it also won't resolve unqualified function and constant names. Unqualified functions can either map to the function in the current namespace or to the global function. This is determined at run-time. I could make a guess at what it is (e.g. assume it's a global function if it is defined globally), but it wouldn't be always right.\nSo after that NodeVisitor has run most names should be instance of PHPParser_Node_Name_FullyQualified. To get a string representation from them (without leading backslash) either do (string) $name or $name->toString().\n. Sounds good per se, but I'm not quite sure how I should add that. The NameResolver could add a public property like ->namespacedName to the node, but I don't know whether this is the right way to do it. Alternatively I could replace ->name altogether. The short name could be accessed using ->name->getLast().\n. I added the full namespaced name under ->namespacedName now. Replacing the ->name would only cause problems with other code, like the pretty printer.\nI'm closing this now, thanks for your help :)\n. All the new 5.4 syntax was added.\n. Thanks for reporting this. I just fixed it in d9452e611ab8dcd09417b6e10b3334d93d171927 together with some other minor changes to the NameResolver :)\n. Thanks for fixing this :)\n. Hi! Thanks for adding this. What kind of tag should I create after merging this? A version tag?\n. I added the tag and submitted it: http://packagist.org/packages/nikic/php-parser. Hope that everything is right now :)\n. From a quick glance this seems to be targeted at PHP 5.2. It's hard to say much more without looking deeper into it, but some more differences I can spot:\nThe Drupal parser uses a manually written parser, instead of a grammar based one. In PHP's case this probably means that the parser will fail on PHP code that's a little bit extravagant. PHP has lot's of crazy syntax (that's also being used in the wild...), which is hard to account for in a manual parser. My parser is based on the zend_language_parser.y yacc grammar file that PHP itself uses, so it matches well with PHP.\nApart from that it also has a significantly different AST structure (e.g. it uses one node class for everything), though I couldn't say what is better (without sounding too biased ^^).\nIn any case, I'm closing this as it isn't really a code \"Issue\" :)\n. Hey @heinep, thanks for your PR.\nIt would be nice if you could describe the use case for having the filename available on every node. I can vaguely see what this is for, but I'm not entirely sure. I mean, you are always parsing one file at the time, so the filename should be readily available somewhere (i.e. the code invoking the parser), shouldn't it? In that case I don't see much use in replicating the filename in all nodes. Or is this for cases where you keep the AST around between several files (like keeping class definitions in memory, because you need info from them later)?\n. @heinep This sounds like a reasonable usecase, so this should go in in some way.\nI'm not yet exactly sure how, though, will have to give it a bit more thought. I don't like the idea of adding more and more optional arguments to the nodes. One probably should have some additional NodeContext object, which can store different context information like filename, start/end line and whatever else one may need.\n. I did some changes about how Lexer and Parser interface and now it is easily possible to create a file lexer without modifying the parser or any nodes. An example code is provided at the end of https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown :)\n. Hey @mneuhaus! I'm definitely all in favor of adding some more user friendly APIs.\nBut I don't yet fully understand some things about your particular proposal:\nI think many of the getter examples are already implemented as properties. E.g. you can do $method->args or $method->name instead of $method->getArguments() or $method->getName(). (You generally can access all subnodes this way.)\nI also didn't quite get what the getByType(Class|Method|Property|...) methods are supposed to do? Where should they go and what do they do?\nBut I really like the idea of adding simple builder classes for common structures like classes etc. Something like\nphp\n<?php\n$class = $builder->class('SomeLogger')\n    ->extend('BaseLogger')\n    ->implement('Logger', 'Some\\\\OtherInterface')\n    ->addMethod($builder->method('log')\n        ->addParam($builder->param('msg')\n        ->addParam($builder->param('type')->optional()->defaultTo('info')\n        ->stmts($stmts)\n    )\n    ->build();\n. Sorry for my late response, I kindof forgot about this completely :(\n\nThe getByType is basically a shortcut to filter the SubStatements based on a specific type. I've Put this into the NodeAbstract Class:\n\nAh, okay, now I get it. This seems like a reasonable thing to do.\n\ni've even toyed with the idea of a rudimentary way to replace placeholders inside statements. Basically i thought about serializing. That way you could create \"Template\" classes which contain the needed logic statements inside the functions which you could reuse to add to newly created functions. \n\nHaving stuff like templates is a very interesting idea that could also make a lot of stuff easier. Building the AST up by hand is quite a hassle and leads to ugly code. It would definitely be nice to just define it in terms of real PHP code that just gets some placeholders replaced.\nBut I think that the implementation of this is much harder than it sounds. At least I doubt that simple serialization will work. PHP's serialization format is not really suitable for search&replace like changes (e.g. strings are saved with a length, which would then be out of sync and unserialize would fail.) This'll need a bit more thought, but I'm sure that there is some elegant solution to this.\n. That looks like a pretty good start for a powerful code generation tool. I'll try to get these ideas into the projects as soon as possible (which should be on this weekend :)\n. I started adding code generation features in a separate branch: https://github.com/nikic/PHP-Parser/tree/codeGeneration. Currently it only adds builders. Templating will come next.\nThanks for all your suggestions :)\n. What I'm thinking about right now is how to make the whole template stuff as general-purpose as possible.\nIn your above examples the placeholders are just plain text. But there are also uses, where the placeholders are syntax trees themselves. Consider this example (closure emulation):\nphp\n<?php\nclass _Closure_%id% extends _Closure {\n    public function call(%params%) {\n        extract($this->uses, EXTR_REFS);\n        %stmts%\n    }\n}\nHere %id% is a plain text placeholder, %params% is a parameter array and %stmts% is a statement array.\nI don't think that there is any way to automatically figure out how the the different placeholders should be inserted. Instead, my idea would be to leave the correct insertion up to the template writer:\nphp\n<?php\nclass _Closure_{{ $id }} extends _Closure {\n    public function call({{ $prettyPrinter->pCommaSeparated($params) }}) {\n        extract($this->uses, EXTR_REFS);\n        {{ $prettyPrinter->prettyPrint($stmts) }}\n    }\n}\nThe whole thing would basically work by compiling the template to PHP (similar to how Twig does it, but with a more trivial approach) and then execute that.\nThis obviously could work very similarly in your example:\n``` php\n<?php\nclass GetterSetterTemplate {\n    /*\n     * @var {{ $type }}\n     /\n    protected ${{ $name }};\n/**\n * Get {{ $name }}.\n *\n * @return {{ $type }}\n */\npublic function get{{ ucfirst($name) }}() {\n    return $this->{{ $name }};\n}\n\n/**\n * Sets {{ $name }}.\n *\n * @param {{ $type }} ${{ $name }}\n */\npublic function set{{ ucfirst($name) }}(${{ $name }}) {\n    $this->{{ $name }} = ${{ $name }};\n}\n\n}\n```\nBut as you see in this case this is getting ugly quite quickly. What one could do is provide shortcuts, like the one used in your proposal:\n``` php\n<?php\nclass GetterSetterTemplate {\n    /*\n     * @var __type\n     /\n    protected $__name;\n/**\n * Get __name.\n *\n * @return __type\n */\npublic function get__Name() {\n    return $this->__name;\n}\n\n/**\n * Sets __name.\n *\n * @param __type $__name\n */\npublic function set__Name($__name) {\n    $this->__name = $__name;\n}\n\n}\n```\nHere __name would be same as {{ $name }} and __Name same as {{ ucfirst($name) }}.\nBut I'm not really sure about all that. Maybe I'm just thinking too complicated. What do you think about this?\n. The main question here is probably what these templates will be used for. Depending on that they have to be more or less powerful. It would be interesting to see what kind of code currently is being generated by frameworks etc to evaluate what the requirements are.\nBut in any case, I don't really like the idea of using special characters for placeholders. I'm not sure why one would want to directly unit test the code generation templates. They are only templates after all.\n. Theoretically yes ^^ Practically I'm currently right before my final exams in school, so I don't have as much time as I'd like :(\nYour examples convinced me that there is little necessity for more advanced templateing mechanisms, so I would go with your original syntax proposal of using ___name placeholders (one can always add more complex mechanisms later). Additionally I'd add ___Name, ___names, ___Names and ___NAME. That should cover the most common cases I think and result in quite easily readable templates :)\nWhat I'm not sure about yet is whether we really need three underscores ___ or whether we could live with two __. Using two underscores can in theory clash with magic constants and magic methods. I'm not sure how big of a problem that is. What do you think about this?\nI'll try to get this in as quickly as possible. In any case, thanks for your great work on this :)\n. Sorry for the long silence, I only now found time to work on the project again :(\nSo, I added a simple template implementation in 19c1f80589e14a310e16f9a1014181276a96cc4a. I decided to\n- use __name__ placeholders.\nI started out with ___name, but that looked very strange if there is something following the placeholder, like in get___NameValues. Is ___NameValues the placeholder, or is it just ___Name and Values is a normal string again?\nThat's why I had to have some delimiter on both sides. I chose using just two underscores as writing ___name___ seems like overkill. I don't think there will be collisions with magic constants, as those are used all uppercase.\n- Only provide a ucfirst __Name__ (or lcfirst __name__) variant. Pluralization would probably be nice, but I figured that there is way too much that can go wrong there. Just sticking an s after the value is not viable, but using a fully-fledged inflection library seemed inappropriate too. So I chose to drop that.\nThere also is a template loader, to load templates from the filesystem (a048112e2c563c4b841aa85716c672b90f452c08).\nThe APIs are as follows:\n``` php\n<?php\n$template = new PHPParser_Template($parser, $templateString);\n$stmts = $template->getStmts($placeholders);\n// using a loader\n$templateLoader = new PHPParser_TemplateLoader($parser, './templates', '.php');\n// loads ./templates/FooBar.php\n$template = $templateLoader->load('FooBar');\n```\nHope that the API doesn't suck too much.\n. Regarding the conflict resolution:\nThe problem with just adding a conflict resolution behavior to the ->add() method (in the current API that would be ->addStmts()) is that you probably want different conflict resolution for different methods.\nE.g. in your example you want to merge the __construct methods, but you probably don't want to merge any of the others. In a simple case where you are just using one template to construct the class this is not much of a problem, because you know for sure that the other methods won't clash. But if you are using several templates it could easily happen that you have duplicate methods and you probably don't want to merge those (instead you'd like to have an Exception or so).\nI'm really not sure how one can tackle conflict resolution, as there are so many different behaviors you'd want in different situations. In the context of your original motivation of changing files that the developer might have already modified it gets particularly complicated.\n. @beberlei has also been creating code generation APIs: https://github.com/beberlei/DoctrineCodeGenerator/tree/master/lib/Doctrine/CodeGenerator (see https://github.com/nikic/PHP-Parser/pull/14#issuecomment-4952407). Many interesting ideas.\n. Closing this issue as it is resolved to most parts (I think).\n. The parser will now also collect non-doc comments. They'll be stored in the comments attribute, so it's possible to retrieve them using $node->getAttribute('comments', array()). The comments are instances of PHPParser_Comment (or PHPParser_Comment_Doc for doc comments).\n. Sounds good, merged :)\n. @beberlei With help of @mneuhaus I've been adding a few code generation features in a separate branch (https://github.com/nikic/PHP-Parser/tree/codeGeneration). If you have suggestions on how one could simplify code generation, it would be nice if you could drop a comment in issue #12 (or a new one). :)\n. @beberlei That looks really interesting. Your builder APIs are a good bit nicer than the stuff I've been doing. Will have to look into that a bit more :)\n. @schmittjoh I'm not really sure one has to implement this. I tried to return aRecursiveArrayIteratorinstead of anArrayIteratoringetIterator, but that didn't help. I also tried to manually implement theRecursiveIteratorinterface, but that didn't work out either. I must be doing something wrong.\n. I just tried again and it seems like just returningRecursiveArrayIteratorallows recursive iteration with your example code (i.e. recursively iterating a single node). But what does not work for me is recursively iterating the whole$stmts` array using this:\n``` php\n<?php\nforeach (\n    new RecursiveIteratorIterator(\n        new RecursiveArrayIterator($stmts),\n        RecursiveIteratorIterator::SELF_FIRST\n    ) as $node\n) {\n    var_dump($node);\n}\n```\nThis only iterates the array itself, but does not recurse. I don't really understand why that is.\n. Thanks, merged.\n. The need for traversing arrays stays in any case, as arrays are used for a few more things than just statements. Simple example is the FuncCall node, which has an array of ->args. Another example is Echo which accepts several ->exprs. Etc.\nBut I do agree that adding a dedicated node for statements could be reasonable. It would allow to add a helper methods for handling statements. One such method for example could be ->getByType('Stmt_Method'). Do have ideas what else could be useful?\n. Ah, okay, I have misunderstood your point at first, now I see it. I'll see whether I can add a node for statements without breaking too much stuff.\n. By the way, the reason that some names are Node_Name and others are just strings is that some names can be namespaced and others can't. For example when calling a function the function name can be namespaced, so it's a Node_Name. But when calling a method, the method name cannot be namespaced, so it's just a string.\n. @felixfbecker Can you please open a separate issue for this?. This looks great!\nOne question though: What sense do the previous and next attributes make in the case of non-array subnodes? E.g. in your provided testcase $cond is the previous of $case. In my eyes this doesn't really make much sense, as the subnodes aren't ordered in any way and their ordering may change (it could well be that $case were the previous of $cond).\nInstead I'd assign previous and next only for array subnodes. The code would look something like this:\n``` php\n<?php\npublic function enterNode(PHPParser_Node $node)\n{\n    $subNodes = array();\n    foreach ($node as $subNode) {\n        if ($subNode instanceof PHPParser_Node) {\n            $subNode->setAttribute('parent', $node);\n        } else if (is_array($subNode)) {\n            for ($i = 0, $c = count($subNode), $i < $c; ++$i) {\n                $subNode[$i]->setAttribute('parent', $node);\n\n                if ($i > 0) {\n                    $subNode[$i]->setAttribute('previous', $subNode[$i - 1]);\n                }\n                if ($i + 1 < $c) {\n                    $subNode[$i]->setAttribute('next', $subNode[$i + 1]);\n                }\n            }\n        }\n    }\n}\n\n``\n. @schmittjoh Sure it's worth :) I'm just not yet entirely convinced about thenext/prevthing :) In my eyes they only really make sense on array elements. As I already said, the subnodes aren't necessarily in the same order as they were defined in the source. E.g. the->namesubnode often comes last, even though it is the first in the source (the reason is simply that the nodes are easier to instantiate that way).\nMaybe I'm just misunderstanding whatnextandprevare supposed to be used for.\n. @schmittjoh THANKS!!! for open-sourcing the analyzer. That will be incredibly useful for so many things!\n. I'm not exactly sure what this would be useful for. Why would you want to run the analyzers one after another, instead of running all together?\n. Thanks, I just fixed this in 5b27fb40ce53d22bb649faf4c3425c8088881fa9 :)\n. Well, if that isn't embarrassing. The problem is the parenthesis around the new statement. Normally they are matched by the'(' expr ')'rule (and simply ignored), but in this case they cause a shift/reduce conflict with the(new Foo)->bar()` syntax. I can't yet find a clean way to solve that conflict, but I'll keep trying :)\n. Sorry it took so long, I completely forgot about this. I fixed the issue in https://github.com/nikic/PHP-Parser/commit/e16513a0ebc781c06ddf0cecc18fa52274704713. Turned out to be easier than I expected :)\n. Thanks, merged :)\n. Good catch, thanks :)\n. Really, I'd love to make this available via PEAR, but my past experiences with PEAR were so terrible that I don't think that I can do it :( I'm glad that after several hours of hard work I actually have a running pear command on my computer ^^ I don't want to know what a hassle it has to be to publish a package...\n. @sebastianbergmann Thanks to the articles posted by @leth setting up the PEAR channel was surprisingly easy. But I can't figure out how one can now generate a package.xml. Do you use some kind of tool for that? All blog posts I found on the topic were using some old, deprecated and not even installing cli tool.\n@runekaagaard I actually tried that, but it didn't work out. Just says \"Building\" (for a week already ^^)\n. Thanks to all the help I was able to create a PEAR channel and publish the package: http://nikic.github.com/pear/ I hope everything worked out fine :)\n. namespacedName isn't really part of the node, it's only added by the NameResolver visitor. Now that we have attributes, maybe namespacedName should be one?\n. But should it be?\n. Closing this old PR as the property is only added by a visitor, not really part of the node itself.\n. In PHP there are two ways to define constants: One is using const FOO = 'bar'; and the other is define('FOO', 'bar'); (for more info see http://stackoverflow.com/a/3193704/385378).\nThe former is a special syntax and as such generates a Stmt_Const node. The latter is just a function call, so a Expr_FuncCall node is created.\nThe define function call doesn't necessary have to actually define a constant. E.g. the function could be overwritten in a namespace. Even if you assume that it is indeed the global function, the const construct is still more restrictive, as it does not allow expressions for the name and the value. Also define can be used for namespaced constants. So a define function call cannot - in the general case - be converted to a const definition.\nSo if you need constant handling the simplest way is to just check for both ways.\nHope that helps :)\n. Here is some (untested) sample code:\n``` php\n<?php\nclass ConstNodeVisitor extends PHPParser_NodeVisitorAbstract {\n    protected $consts;\nprotected function registerConstant($name, PHPParser_Node $value) {\n    $this->consts[$name] = $value;\n}\n\npublic function enterNode(PHPParser_Node $node) {\n    if ($node instanceof PHPParser_Node_Stmt_Const) {\n        // There can be multiple consts in a const declaration, so have to iterate the array\n        foreach ($node->consts as $const) {\n            $this->registerConstant($const->name, $const->value);\n        }\n    } elseif ($node instanceof PHPParser_Node_Expr_FuncCall\n              && $node->name instanceof PHPParser_Node_Name // We can't handle dynamic function calls\n              && $node->name == 'define' // We just assume that define is not overridden in a namespace\n              && count($node->args) >= 2 // At least two arguments are required\n              && $node->args[0]->value instanceof PHPParser_Node_Scalar_String // We can only resolve if name is a string and not an expression\n    ) {\n        $this->registerConstant($node->args[0]->value->value, $node->args[1]->value);\n    }\n}\n\n}\n```\n. Yup, the parser currently tries to present the AST \"as seen by PHP\", so it also parses strings and numbers.\nOne way to retain the original value would be by defining a custom lexer which adds the originalValue as an attribute:\n``` php\n<?php\nclass KeepOriginalValueLexer extends PHPParser_Lexer // or PHPParser_Lexer_Emulative\n{\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n    if ($tokenId == PHPParser_Parser::T_CONSTANT_ENCAPSED_STRING\n        || $tokenId == PHPParser_Parser::T_LNUMBER\n        || $tokenId == PHPParser_Parser::T_DNUMBER\n    ) {\n        // could also use $startAttributes, doesn't really matter here\n        $endAttributes['originalValue'] = $value;\n    }\n\n    return $tokenId;\n}\n\n}\n```\nThis should make the original value available through $node->getAttribute('originalValue').\nWould that solution work for you?\n. I doubt that the escape sequence parsing really takes much time (at least compared to all the other stuff), but I think that it wouldn't be much of a problem to outsource the scalar value parsing into another class (which is injected into the parser). If you would prefer it that way I'll gladly implement it :)\n. Thanks, I merged this with two small modifications: a) The $line argument is optional, defaulting to -1, and b) there is a setLine() method.\n. I can't reproduce this. If I do $stmts[0]->getDocComment() I get the doc comment. Maybe you are trying to fetch the doc comment from the inner node, i.e. $stmts[0]->consts[0]->getDocComment()?\n. This was already fixed in https://github.com/nikic/PHP-Parser/commit/e16513a0ebc781c06ddf0cecc18fa52274704713. So updating your PHP-Parser version should fix the problem :)\n. The parser itself does not use recursion (it keeps track of state in a stack). What is the issue here is the node traverser, which is indeed implemented recursively.\nThe error message doesn't come from PHP itself (PHP does not have a recursion limit), but from XDebug. The recursion limit can be specified with the xdebug.max_nesting_level ini option. So the problem should be fixed by running ini_set('xdebug.max_nesting_level', ???); in your bootstrap. What exactly ??? should be I can't really say. A value like 10000 should probably account for all common cases. You probably can also disable it altogether by setting the option to 0 or maybe -1, but I'm not sure about that.\n. Oh, seems like you figured that out yourself while I was writing my response ^^\n. Yes, I will add a note about this in the docs.\n. No problem :)\n. Thanks, this is fixed now.\n. I can't reproduce this. I parsed if ($foo) $bar; and then did this:\nphp\n<?php\nforeach ($stmts[0] as $name => $subNode) {\n    var_dump($name, $subNode);\n}\nAnd got this output\n```\nstring 'stmts' (length=5)\narray\n  0 => \n    object(PHPParser_Node_Expr_Variable)[10]\n      protected 'subNodes' => \n        array\n          'name' => string 'bar' (length=3)\n      protected 'attributes' => \n        array\n          'startLine' => int 3\n          'endLine' => int 3\nstring 'elseifs' (length=7)\narray\n  empty\nstring 'else' (length=4)\nnull\nstring 'cond' (length=4)\nobject(PHPParser_Node_Expr_Variable)[9]\n  protected 'subNodes' => \n    array\n      'name' => string 'foo' (length=3)\n  protected 'attributes' => \n    array\n      'startLine' => int 3\n      'endLine' => int 3\n``\n. Good :) If I may ask, what kind of optimization were you trying out?\n. Closing this for now, as all currently available features are implemented.\n. The issue here is that?>in PHP comes with an implicit semicolon, so from the parsers perspective there is a semicolon-statement (;`) after the docblock. As those are no-ops the parser doesn't generate nodes for them, so the doc block is dropped.\nThere are several ways this could be solved:\n1. Fetching the file doc block using the tokenizer. Code would look similar to this:\n``` php\n   <?php\n   function getFileDocComment($sourceCode) {\n       foreach (token_get_all($sourceCode) as $token) {\n           if ($token[0] === T_DOC_COMMENT) {\n               return $token[1];\n           } elseif ($token[0] !== T_OPEN_TAG && $token[0] !== T_WHITESPACE) {\n               // only allow an opening tag and whitespace before file doc comment\n               return false;\n           }\n       }\n   return false;\n\n}\n   ```\nThis has the advantage that it'll work even if there is nothing after the doc comment at all (i.e. the file contains only a doc comment and nothing else).\n2. Instead of just dropping semicolon-statements I could return a node for them. Those would capture the doc comment. (This wouldn't work if the doc comment it the only thing in the file and there isn't even a closing ?> php tag.)\n3. I could probably add the doc comment to the node following the semicolon (not yet sure how this would be done, but there probably is a way). (This wouldn't work if there is only a closing ?> tag and no inline HTML after it.)\nAll variants seem somewhat ugly, so I'm not really sure what to do about this :/\n. Hey @mvriel. I must have missed the notification for your comment, sorry :/\nRegarding the comments, no, this is not the intended behavior and I didn't notice that this happens until now. Though thinking about it again, it's quite logical that it happens: Just like all (also nested) nodes get assigned a line number, nested nodes also get assigned the comments.\nFixing this will be rather hard though, as it can't really be done in a generic way, at least I don't see one. Rather I'd have to assign comments only to statements (and expressions in statement use). But it's probably still worth to do it for the memory savings.\n. Commit https://github.com/nikic/PHP-Parser/commit/7eac2cfd8bf9b06387a824ebcae9133364f37896 adds a Nop statement if there any trailing comments in a statement list. This should also include the case of the original report.\nI've create a separate issue for the duplicate comment assignment (https://github.com/nikic/PHP-Parser/issues/253), so we can close this issue at last :)\n. @mvriel You didn't miss anything, I've only added them yesterday ;) The date info on that commit is off, because I rebased it off an older branch.\n. Yes, comments are assigned to the node after them, so if there is nothing following the comment it won't be collected anywhere. There isn't really anything I can do against this, short of switching to a completely different model (where you get a parse tree instead of an abstract syntax tree). If you need to preserve all comments the PHP parser isn't a suitable tool, you'll need to work on the tokens directly.\n. Yep, those also have the same issue. The comment is assigned to the next node that follows, so for the if it is just dropped and for your second example it's assigned to the next assignment. I do agree that this is wrong, but I don't see an easy way to change this (with the current approach). Also it's often not really clear what statement a comment \"belongs\" to. E.g. consider the following code:\n``` php\n<?php\n$someCodeIs;         // Here is a big block\n$writtenInHere;      // of documentary text\n$otherMultipleLines; // that isn't really related\n                     // to the particular statements\n                     // on the left. It's just a multiline\n                     // comment formatted like that.\n```\nHere you can't really say that a comment on the right belongs to the statement left to it.\nIn any case, I'll try out whether there is some easy way to generate a parse trace which retains all information from the source code. I'm not sure whether this is possible with the data I have available right now.\n. Closing this in favor of #41.\n. Heh, this issue seems to crop up in every project trying to serialize to XML. Seen it a few times in various unit testing frameworks, but didn't realize that it applies here too.\nJust disabling parsing of escape sequences won't really help here, as one could still have issues with malformed UTF-8 in strings (or not UTF-8 at all). PHP's strings are raw binary data after all.\nThe only real way to solve this is what you did. Or rather one could only selectively encode strings containing invalid UTF-8.\nBy the way, what are you using the XML serialization for?\n. @theseer Do you think it would make sense to move the static Scalar_*::parse() methods into the parser (as normal methods), so they can be overridden by extending it?\n. @theseer The parser provides an abstract syntax tree, meaning that a lot of information is (intentionally) discarded, only retaining the parts that are relevant to the programs interpretation. String formatting is one of those things that are discarded. From PHP's point of view it does not make a difference whether a string is \"Hello, World!\" or whether it is \"\\x48\\x65\\x6C\\x6C\\x6F\\x2C\\x20\\x77\\x6F\\x72\\x6C\\x64\\x21\". Interpreting the literal values allows to directly work with these values, e.g. use them as lookups, compare them, etc. This is not possible with encoded values because the same literal can have multiple representations (simplest example is single vs double quotes).\nI see that this behavior is not appropriate for some use cases, these use cases simple weren't the ones I originally had in mind. My main motivation was a) static analysis and b) automated code changes where nobody ever has to read the generated code.\nBut in any case, ways to fully retain the file file formatting are being discussed in issue #41, so this might soon be possible. Though it probably doesn't really apply to this particular problem, because here the solution is rather simple anyway :)\n. Sorry for the long response time. I fixed the closure issue as part of implementing associativity handling (which will make the printing of operator chains prettier) and also committed the switch formatting changes you did.\nI didn't do much testing of the pretty printer output yet, so there are probably a few more ugly places.\n. Thanks for the fixes!\n. I think having whitespace information available would be awesome for a lot of applications.. But I can't add whitespaces nodes into the current AST structure. To preserve all whitespace, comments and formatting one would need a concrete syntax tree that would basically a tree that tags stuff on the token stream. For \"<?php\\n     echo 1 + 2;\" it would something like this:\nPHP[\n    T_OPEN_TAG(<?php\\n)\n    T_WHITESPACE(     )\n    Echo[\n        T_ECHO(echo)\n        T_WHITESPACE( )\n        Plus[\n            LNumber[\n                T_LNUMBER(1)\n            ]\n            T_WHITESPACE( )\n            char(+)\n            T_WHITESPACE( )\n            LNumber[\n                T_LNUMBER(2)\n            ]\n        ]\n        char(;)\n    ]\n]\nThis is a completely different structure and would probably require a lot of work to create. (I wanted to look into this far a while already, but never got around to doing it :/ )\nAnother interesting idea is what @schmittjoh implemented in https://github.com/schmittjoh/php-manipulator: It has the token stream and the AST as separate structures with links between them. I'll look a bit more closer at that and see if it can be integrated with the parser.\n. @pscheit @schmittjoh Storing whitespace in the node attributes would come with the same problems that currently exist for comments, just worse. For comments I currently simply store all comments that occur before the node. That works in most cases, but not always (e.g. issue #36 and #37).\nFor whitespace it's a lot more problematic, because unlike comments whitespace usually also occurs within the node and not just before it. So for echo 1 + 2;, where does the whitespace go? It isn't really helpful if I add a whitespace = [' ', ' ', ' '] attribute to the node.\n. @schmittjoh @pscheit Having a custom format for every node would cause a lot of work both in the implementation and the use lateron, because every node would require special handling.\nThat's why I currently lean towards the approach where just the offset into the token stream is saved in the nodes. So every node would have a startOffset and endOffset attribute, which could be used to look up the tokens it is composed off in the token stream. This is something that can be done automatically and the mechanisms for it are already in place. I quickly tried this out and it basically seems to work, though it looks like I sometimes get an off-by-one error for the end token (probably some bug in the handling for the end attributes).\nI think this approach is very nice because it cleanly separates the abstract syntax tree and it's concrete formatting.\nWhat will be a bit tricky about this is to figure out how to properly pretty print a partially changed AST. One somehow has to figure out which parts were changed and pretty print only those. And there too one would probably try to keep as much of their content in the original form.\n. @schmittjoh I just fixed a small bug that was getting in the way of properly doing the mapping (https://github.com/nikic/PHP-Parser/commit/cdbad02fb2f884c66092212a88b1625e47043b92), but it should be as easy as using a custom lexer that specifies the necessary attributes:\n``` php\n<?php\nclass LexerWithTokenOffsets extends PHPParser_Lexer {\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n        $startAttributes['startOffset'] = $endAttributes['endOffset'] = $this->pos;\n        return $tokenId;\n    }\n}\n```\nFrom a few quick tests this works fairly well, though there will be some rare cases where this will be off (those can be fixed without much effort).\n. My initial attempt at a pretty printer that tries to preserve the formatting: https://gist.github.com/4365484 It turned out really hard to do this (the main issue being indentation) and the current version still doesn't do a particularly good job.\n@lstrojny What is Generation Gap?\n. @lisachenko What I'm doing nowadays is use the AST to do analysis and figure out where things are, but do modifications on the source code (or the tokens) directly. You need some way to queue modifications (e.g. https://github.com/nikic/TypeUtil/blob/master/src/MutableString.php) and then this works pretty well for doing smaller changes based on startFilePos and endFilePos. Obviously this becomes a bit more tricky for larger changes.\nAs to making use of file/token offsets in the pretty printer, I gave that a try some time ago (https://gist.github.com/anonymous/4365484 linked above). I remember that the implementation was nowhere near robust enough. With enough effort one can probably get it to work (but I won't be working on it).\n. @jails Nope, no changes here.\n. So, I've given this problem (format-preserving pretty prints) another shot and I have a viable prototype now: https://github.com/nikic/PHP-Parser/compare/formatPreservingPrint (based on #322)\nThe implementation does not add whitespace nodes in the AST, instead we try to reconstruct the original formatting based on token offset information.\nHere is a usage example:\n```php\n$lexer = new Lexer\\Emulative([\n    'usedAttributes' => [\n        'comments',\n        'startLine', 'endLine',\n        'startTokenPos', 'endTokenPos',\n    ],\n]);\n$parser = new Parser\\Php7($lexer, [\n    'useIdentifierNodes' => true,\n    'useConsistentVariableNodes' => true,\n    'useExpressionStatements' => true,\n    'useNopStatements' => false,\n]);\n$traverser = new NodeTraverser();\n$traverser->addVisitor(new NodeVisitor\\CloningVisitor());\n$printer = new PrettyPrinter\\Standard();\n$oldStmts = $parser->parse($code);\n$oldTokens = $lexer->getTokens();\n$newStmts = $traverser->traverse($oldStmts);\n// MODIFY $newStmts HERE\n$newCode = $printer->printFormatPreserving($newStmts, $oldStmts, $oldTokens);\n```\nThe important bits here are a) that you need to specify a bunch of non-standard options to avoid BC breaks until PHP-Parser 4.0, b) a CloningVisitor is run before any changes, so we retain the original AST as a reference and c) we also need the old tokens from the lexer.\nThe whole thing isn't well tested yet, so likely going to be many issues depending on which part of the AST you try to modify. There's a couple of limitations as to where we can preserve formatting and where we can't:\n\nChanges to non-Node subnodes results in formatting being lost. The reason is that we don't have offset information for non-Node subnodes. Some of the parser options specified above (e.g. useIdentifierNodes) make use of Nodes where previously strings were used. For example, this allows changing the name of a function while preserving formatting. On the other hand changing a function to return by ref (this is a boolean subnode) will drop formatting.\nWe can preserve formatting if an item in an array subnode is replaced, but not if an item is removed or added. We can do better here, but this will require a good bit of work (would probably need something like an array differ).\nFormatting for anon classes is lost, because the attribute assignment in this case is too weird right now.. Here a complete example: https://gist.github.com/nikic/3229644ada5576622d7d538f6bff2098\nThis is basically https://github.com/Roave/FunctionFQNReplacer, but preserving formatting.. Closing this in favor of #344, which contains remaining TODOs for this.. Sorry for the late response everybody.\n\n@schmittjoh Do you think it's a good idea to couple the PrettyPrinter and the name resolver in such a way? What I'd prefer is if the resolver had a mode to not replace the node, but rather put the resolved name into ->resolvedName or something (just like it has ->namespacedName now). Or do you think this would be impractical?\n. Thanks, merged :)\n. Sorry for the late reply, I have no excuse for not answering earlier.\nPHP sandboxing was one of my first motivations behind this project, but it is a rather complicated problem if you want to do it by static code analysis / preprocessing. If you are going to evaluate user-submitted code then the only really safe way is to evaluate it in a separate jail (or whever the operating system provides).\nSandboxing through preprocessing is really hard in PHP, because of its dynamic nature. You can easily check that exec(...) is disallowed, but it already is harder to make sure $func() is safe. But that's just the beginning. There are many, many subtle ways in PHP to run something, which are often little-known or easy to overlook. E.g. you could easily miss some particular function taking a callback or some indirect way of executing a call, like with (new ReflectionFunction('exec'))->invoke(...).\nSo I'm not really sure whether this kind of security checking makes any practical sense as there are just too many points of failure. I find this mostly intriguing from the theoretical point of view. So after I saw this issue I took some old tokenizer-based sandbox code and ported it to use the PHP-Parser. While doing that I found a lot of issues, which I'm trying to resolve. If I manage to figure everything out I'll publish the library. Though as I said, I don't think that it makes sense to use this in practice.\nSo, to answer the question: Yes, it's possible. But whether it makes sense depends on the specific case. (The narrower the case the easier it should be to properly handle it.)\nAgain, sorry for the late reply.\n. From a quick look at the code you seem to be using PHP's internal disable_functions and disable_classes features. There should be no way around those short of exploiting PHP itself. Though I obviously don't know how complete the blacklists you are using are.\n. Thanks, I didn't even know that iterator existed. I put it in an extra line though, as that foreach started to get a bit full :) https://github.com/nikic/PHP-Parser/commit/222c9612ab9c65551b7febd38cbb0fa685b0e0db#diff-1\n. Thanks!\n. The parser always makes the statements subnodes of the Namespace node (this was requested in issue #1). So the pretty printer does not know which kind of namespace it is (but this could be tracked with a flag).\nThe choice to use brackets there was because the semicolon namespaces don't work for the global NS and because both styles can't be mixed. One could scan the statements beforehand to check whether there is a global NS and if there isn't use the semicolon-style namespaces.\nAs semicolon-namespaces are the de-facto standard it probably makes sense to do this.\n. Resolved by https://github.com/nikic/PHP-Parser/commit/81d20bf10e33b9fca0ddf082322a74df1f71c9f8. The pretty printer will now use the semicolon-style whenever possible.\nAlso the pretty printer is now called PHPParser_PrettyPrinter_Default as it really isn't the Zend CS.\n. That's a good idea, thanks! I added the expected tokens in https://github.com/nikic/PHP-Parser/commit/fbaa1e5fc313f533b8e98bb86fc9ddbb4ee8beff.\nWhy do you want to force yacc to use the same token constants as internal php?\n. @danyaPostfactum zend_language_scanner.l uses re2c, but afaik with a flex compatible syntax. But I don't think using that in JS is a good idea for the reasons you already mentioned. A handwritten lexer is the way to go here.\nYou can find a sample definition for a PHP lexer here: https://github.com/nikic/Phlexy/blob/master/examples/phpLexerDefinition.php This definition works (and is tested against token_get_all) for everything apart from heredoc/nowdoc strings. Sample implementations of the (stateful) lexer that is needed to process those definitions can be found here: https://github.com/nikic/Phlexy/tree/master/lib/Phlexy/Lexer/Stateful Both implementations do the same thing, the second one is just faster (but needs some more support code).\nHope this helps! Oh, and that's a cool project ;)\n. @danyaPostfactum For PHP there is this PEAR LexerGenerator: http://pear.php.net/package/PHP_LexerGenerator I tried to use it some time ago and if I remember correctly it didn't work particularly well. But maybe it'll fit your use case ;)\nRe the tokens: Bison and kmyacc are sufficiently different software, so it's no wonder that they produce different tokens. But I can't tell you where exactly the token numbers come from. I never looked closer at their codes.\n. @harikt The builders can't modify stuff, but you can still use them to amend new things to existing ASTs. E.g. if you have a class node $class and want to add a method:\n``` php\n<?php\n$factory = new PHPParser_BuilderFactory;\n$class->stmts[] = $factor->method('someCoolMethod')\n    ->makeProtected()\n    ->addParam($factory->param('something')->setDefault(42))\n    ->addStmts(...)\n    ->getNode()\n;\n```\nBut apart from that it's mostly manually assembling nodes ^^\nOr is that not what you mean?\n. @harikt Isn't that exactly what the above code does? It takes the $class node and adds (->stmt[]) a method to it (the method is the only thing created through the builder here).\n. No problem :) If you have any further questions ask ahead ;)\n. Just tried out this snippet:\n``` php\n$code = <<<'CODE'\n<?php\nclass A {\n    function foo(){\n    }\n}\nCODE;\n$parser = new PHPParser_Parser(new PHPParser_Lexer);\n$stmts = $parser->parse($code);\nvar_dump($stmts[0]->stmts[0]->isPublic());\n```\nAnd it gave me bool(true). So it seems to already do what you are suggesting?\n. Thanks, merged :)\n. Is there some issue with them pointing to 404? Quite honestly, I know little and less about the monstrosities of XML, but I thought that the namespace is more or less just some unique string, but is not actually used in any way after that (so it doesn't matter if it is a 404).\n. I could easily get rid of the ?> and <?php at start and end by adding a new prettyPrintFile method, but making it print <?php echo $var; ?> without the newlines would be a bit more problematic, because it requires knowing the context during printing (because one probably only wants to omit the newlines if it is a single statement).\n. Sorry for the delay. I now added a prettyPrintFile() method, see https://github.com/nikic/PHP-Parser/commit/08f0cde6f9c0fcb75af5611ebfcf8fb7e3dac55d. For your case it will return:\n<h1><?php\necho $var;\n?>\n</h1>\n. @hinikato That's intentional. The closing PHP tag is not necessary and discouraged per most coding conventions.\n. Quite a lot here, I'll start with this:\nphp\n<?php\n$class->addMethod('someMethod')\n    ->makeAbstract()\n    ->addRequiredParam('someParam', 'SomeClass')\n;\nIf I got it right, there are two things here:\na) This uses a $class->addMethod('foo')->... pattern, rather than the existing $class->addStmt($factor->method('foo')->...) one. Why do you want to make this change? Some of the thoughts behind the current design are:\n1. You can add the statements from any source, you are not forced to create them inline using the fluid interface. In particular you also have the possibility to create a method once using $factory->method() and then use the same method in multiple classes.\n2. If you want to stay in the fluid interface after the method you have something like the END_METHOD() calls you already introduces above. Imho that's not particularly nice.\n3. You do not need to explicitly add a method for every kind of node one can add. In a class body you can have methods, you can have properties, you can have constants and you can have trait uses. addStmts covers all these cases, without requiring individual methods for the different types. It also allows the reuse of generation methods e.g. a class constant and methods can be used both by classes and interfaces (note: there are currently builders neither for interfaces nor for class constants ^^).\nIf the main concern here is keeping things short, then I have two suggestions:\n1. To make it a bit shorter one could rename addStmt to add. So the code would be ->add($factory->method()), which I guess reads a bit nicer.\n2. Apart from ->addStmt() the builders also have ->addStmts() methods. If you are adding multiple \"things\", you can avoid the boilerplate:\nphp\n<?php\n$class = $factory->class('SomeClass')->addStmts([\n    $factory->method('method1')->...,\n    $factory->method('method2')->...,\n    $factory->method('method3')->...,\n    $factory->property('prop1')->...,\n    $factory->property('prop2')->...,\n])->getNode();\nb) The code uses ->addRequiredParam('someParam', 'SomeClass') which creates a parameter in a single method call, rather than the multiple calls on $factory->param(). Apart from the comments from a) [regarding reusability and stuff] the issue here is order of optional bits of information (as you already point out in your second comment). You basically have to decide on some arbitrary order, which I personally don't like much (because it usually leads to the , null, null, null, 'foo' pattern and because the meaning of a certain parameter often becomes unclear.)\nRegarding this:\n$classBlueprint->addMethod('foo')\n  ->addOptionalArgument('arg0', NULL)\n  ->addArgument('arg1')\n;\nI don't think that this need to throw an exception as PHP itself accepts optional arguments before required arguments. This can be used to create (required) parameters with nullable object type hints.\nThoughts? I'm leaving the rest for later. In any case, thanks for bringing up the topic again. Long time since I looked at the code generation APIs.\n. Maybe I should create a wiki page with a list of projects using PHP-Parser? So one can look at various sample code.\n. I added a Wiki page here: https://github.com/nikic/PHP-Parser/wiki/Projects-using-the-PHP-Parser Just a few stubs right now. If you find some project using PHP-Parser, feel free to add it in there :)\n. Thanks!\n. Do you already have the code for the extended traverser? Would be nice to have a look at it, so I know the context :)\n. Sorry for the delay, PR is merged now :) Thanks!\n. It's possible to make the parser reentrant, but it's not particularly simple (would require some changes to the parsing algorithm and the inclusion of error-recovery information in the grammar). I'll look into this, but can't guarantee it'll be anytime soon.\n. Yes, sure :) Just went through the commit history to find the old code for error recovery: https://github.com/nikic/PHP-Parser/commit/b153bfa3a803243568b934924255540780a2d349 By now some of the surrounding code may have changed, but it should still work with some small modifications.\nThe docs for bison error recovery tokens can be found here: http://dinosaur.compilertools.net/bison/bison_9.html I guess one would have to add error rules in some key places like statements (error ';') and blocks (error '}').\nThe most complicated part is probably figuring out how to best report the errors that occur, e.g. one could introduce Error nodes, though not sure if that's a good idea. Alternatively just put all the errors in some array.\n. I just added an initial implementation in the errorRecovery branch: https://github.com/nikic/PHP-Parser/tree/errorRecovery\nA test script:\n``` php\n$parser = new PHPParser_Parser(new PHPParser_Lexer, ['errorCallback' => function() {\n    var_dump(func_get_args());\n}]);\n$nodeDumper = new PHPParser_NodeDumper;\n$code = <<<'CODE'\n<?php\nwhile (true) {\n    doSomething()\n    echo 'Hello world';\n}\nCODE;\necho $nodeDumper->dump($parser->parse($code));\n```\nThis will output:\narray(2) {\n  [0]=>\n  string(31) \"Syntax error, unexpected T_ECHO\"\n  [1]=>\n  array(1) {\n    [\"startLine\"]=>\n    int(5)\n  }\n}\narray(\n    0: Stmt_While(\n        cond: Expr_ConstFetch(\n            name: Name(\n                parts: array(\n                    0: true\n                )\n            )\n        )\n        stmts: array(\n            0: Stmt_Echo(\n                exprs: array(\n                    0: Scalar_String(\n                        value: Hello world\n                    )\n                )\n            )\n        )\n    )\n)\nSo you get an error because of the missing semicolon after the call, but the next statement is parsed correctly.\nWill need some additional tinkering though, some things that have to be figured out:\n- How to report the errors. Right now it's using an error callback with the error message and the attributes of the token. That's probably not the most convenient way to do it.\n- What to do when the error can not be recovered. Right now I throw an exception, but in the recovery-mode it might make more sense to just return false.\n- How to handle errors that are creates by exceptions thrown during parsing (e.g. invalid modifiers). Right now this will still throw the exception and not be recovered.\n. Closing this in favor of #170 which links to a more up-to-date implementation.\n. Thanks, committed in https://github.com/nikic/PHP-Parser/commit/12faad529e32d5052298e16b9e36b88757e2540f :)\n. Agree, though I think having separate builder classes for things like uses excessive (it just has the getNode method and nothing else). Maybe in these cases we can directly return the constructed node from the method in the factory? Or would that not be so good design-wise (not all values that are returned will have a getNode() method)?\n@Trismegiste What do you think about this?\n. Trait builder has been added: https://github.com/nikic/PHP-Parser/commit/4387454fe02c5d0ca72a8c65bba3dfa68cb91929\n. Namespace builder has also been added: https://github.com/nikic/PHP-Parser/commit/01643e06d3a3721ef6cd04fdaad2a3c3eae9ed5a\n. @sh-dude Done: https://github.com/nikic/PHP-Parser/commit/f9fc2fc9ee3b3672aba185d609483484e8cae34b\n. \"Use\" builder added as well in https://github.com/nikic/PHP-Parser/commit/0c34706799d298864a8e0cd4b1cb3eff710540bc, so closing this FR.\n. I don't really know much about how all this Composer config works, but if I got it right the composer.json file of the using project can include a @dev suffix after the package version, so that a dev version can be used without lowering minimum-stability.\n. Just read this issue again and only now noticed that this is about PEAR and not Composer. Sorry about missing that earlier.\nI modified my build script to use release-stability=stable in the future. I won't change the old releases though (I'm not sure that's even possible?)\n. @jdespatis You can always install non-stable version directly via pear install PHPParser-0.9.3 (just needs to specify a specific version number).\nAnyway, I just tried to do a PEAR release with stable stability, but it complains that versions lower than 1.0.0 cannot be stable :/ I guess I'll have to leave this at beta.\n. Thanks for the report! I always use a single PP instance for everything and as such never noticed this issue.\nI just did some testing and the results are quite interesting (for 1M runs each):\nOn Windows:\n    uniqid: 3.4s\n    uniqid with more_entropy: 4.2s\n    microtime: 3.8s\n    mt_rand: 0.1s\nOn Ubuntu:\n    uniqid: 110s\n    uniqid with more_entropy: 5.4s\n    microtime: 5.0s\n    mt_rand: 0.07s\nSo, on Windows the uniqid call is actually slightly faster, whereas on Unix the uniqid call is pathologically slow.\nThe reason is that unix systems uniqid with more_entropy=false will do a usleep(1) call (see http://lxr.php.net/xref/PHP_5_5/ext/standard/uniqid.c#67), which can - depending on the system - of course take a lot longer than 1usec.\nAs there are no strong randomness or uniqueness requirements here, it seems like using mt_rand() is the best choice :)\n. The code now uses mt_rand(). Thanks again for the report!\n. Unless there is some specific reason to rename them (apart from being consistent throughout the project), I'd rather keep the names as is to avoid breaking external links. I know that I linked some of these docs from various places on the internet and changing the extension would break those links.\n. The project officially supports PHP 5.2, so it should also continue testing against it. I don't see a reason to drop the support.\nI have added 5.5 to .travis.yml though: https://github.com/nikic/PHP-Parser/commit/3d467ca18ec08c5df2d5cad5c51442be148a7f21\n. To add to that: Dropping 5.2 support would only make sense to me if I ported this project to use namespaces. Apart from breaking all the existing code, namespaces have the problem that some classes would need to use a reversed keyword as the last part of the NS (e.g. PHPParser\\Node\\Stmt\\Class), which is not valid. I can of course define a reserved-keyword classname via class_alias, but it still wouldn't be directly usable. So in the end one would have to use names like PHPParser\\Node\\Stmt\\_Class instead (which might be okay, actually).\nBut as said, moving to namespaces breaks all BC. A better alternative might be to introduce namespaces aliases (class_alias). This would allow using both the old and the new names (which do benefit quite a bit from the ability to use PHPParse\\Node\\Stmt and then writing just Stmt\\_Class). Though likely class_alias doesn't have good IDE support ^^\n. I won't be adding a PSR-2 printer to the main project (yet), because I don't think that it would work well enough right now. The current pretty printer is only supposed to output executable and human-readable/debuggable code, but doesn't really care about the formatting.\nPrinting code in PSR-2 would require a bit of a different approach to be able to enforce line limits (as @kelfink mentioned). Right now the indentation of the current line is not known by the printing methods as it's only added after they have already finished (so you don't know how long the line actually is).\nAlso I think that it wouldn't be particularly useful without the ability to retain some of the original formatting (issue #41).\n. The parser provides strings \"as seen by PHP\", i.e. in already parsed form. It does not retain the formatting of the string. Pretty printing with support for retaining formatting is discussed in #41.\nIn #26 you can find a solution for your particular issue with strings. The custom lexer will provide an originalValue attribute for constant encapsed strings, which you can then use in the pretty printer via:\npublic function pScalar_String(PHPParser_Node_Scalar_String $node) {\n    return $this->pNoIndent($node->getAttribute('originalValue'));\n}\nThis approach will not work for non-constant (interpolated) strings though.\n. @cameronjacobson In the visitor you're currently replacing a FuncCall with a lone ArrayItem, which is not part of an Array. To get the array( ) around it the ArrayItem needs to be part of an Array node.\n. I can't reproduce this:\n``` php\n<?php\n$code = <<<'CODE'\n<?php\nnamespace MySpace;\nclass A {\n    use myTrait;\n}\nCODE;\n$parser = new PHPParser_Parser(new PHPParser_Lexer);\n$traverser = new PHPParser_NodeTraverser;\n$traverser->addVisitor(new PHPParser_NodeVisitor_NameResolver);\n$dumper = new PHPParser_NodeDumper;\necho $dumper->dump($traverser->traverse($parser->parse($code)));\n```\noutputs:\narray(\n    0: Stmt_Namespace(\n        name: Name(\n            parts: array(\n                0: MySpace\n            )\n        )\n        stmts: array(\n            0: Stmt_Class(\n                type: 0\n                extends: null\n                implements: array(\n                )\n                stmts: array(\n                    0: Stmt_TraitUse(\n                        traits: array(\n                            0: Name_FullyQualified(\n                                parts: array(\n                                    0: MySpace\n                                    1: myTrait\n                                )\n                            )\n                        )\n                        adaptations: array(\n                        )\n                    )\n                )\n                name: A\n                namespacedName: Name(\n                    parts: array(\n                        0: MySpace\n                        1: A\n                    )\n                )\n            )\n        )\n    )\n)\nAre you sure you registered the NameResolver visitor?\n. Any particular use case you have in mind for this? Or is this just about completeness of the API?\n. Merged in https://github.com/nikic/PHP-Parser/commit/700847e2951942200b479c413aa2984b5364799b (with the break). Thanks for the contribution!\n. I probably should add ext/tokenizer to the requirements in composer.json.\n. Added the requirement in composer.json: https://github.com/nikic/PHP-Parser/commit/52aa17fa6807144ac1404c01a822c1b3825da70a\n. PHP-Parser supports PHP 5.5 syntax, but the JMSTranslation bundle uses version 0.9.1, which was released before the 5.5 release cycle started (and as such couldn't know what new syntax there will be ^^)\n. I wanted to submit a PR to update the version in composer.json (it should only require one small change in the actual code), but I wasn't able to get a clean install of https://github.com/schmittjoh/JMSTranslationBundle that's able to run the test-suite. I'll have to leave this to someone who is able to install the 30-or-so dependencies it needs without errors.\n. Backporting PHP code to older version was the original motivation behind this project. I started working on this with https://github.com/nikic/PHP-Backporter, but abandoned it pretty quickly (for no particular technical reason). There is another, newer project with the same goal (https://github.com/igorw/galapagos), but that doesn't look actively developed either.\nPHPPHP could theoretically be used for this but a) it is really, really slow and b) it is rather incomplete and there currently is no intention to make it complete.\n. Why do you want to distinguish them? What's the difference between a generic compile-time fatal error and a parse error (which is also a compile-time fatal error) in particular?\n. I'm not really sure what you mean by PHP-Parser behaving differently from PHP. If you mean that the parser allows a lot of things that PHP doesn't, then yes, that's true and I won't change that.\nI'm currently checking for some errors that can be detected locally (i.e. just looking at one node, e.g. I couldn't do the static old-style constructor check because it requires knowing whether I'm in a namespace or not). Doing full compile-error checking would require more work. I think that kind of stuff can be done by an external project that just provides some ErrorCheckingVisitor. Also note that the error checking might need to have different checks for different versions.\nHowever if you mean that PHP-Parser reports something as an error that isn't actually one, please open another issue for that, it shouldn't happen.\nRegarding different errors for parse and fatal errors, I see little point in doing that. If you want to display them with different prefixes, you can easily check whether the message starts with Syntax error. PHP has only one parse error and it always starts with that string. Everything else will be compile errors.\n. Thanks for the fix! Merged via https://github.com/nikic/PHP-Parser/commit/7f4ab26732c6c0dcfeef98ee94452977ac26e82c.\nThis will still fail if someone is using a weird locale (as Zend uses locale-insensitive lowercasing for class names, but strtolower is locale-aware). But I think that's okay, as nobody sane is using locales nowadays :)\n. I think this makes sense, but only if we can come up with a suitable name for the grouping. I don't think that ObjectDefinition really cuts it (as interfaces and especially traits have rather little to do with objects...)\n. For 5.2 compatibility you need to use get_class() instead of get_called_class() (In a non-static context both are the same) and change __DIR__ to dirname(__FILE__).\n. @Trismegiste Maybe get_class($this) instead of get_class()? Don't remember the exact behavior in that area just now.\n. The builders currently don't support addition of comments, you'll have to use something like this:\n``` php\n<?php\n$method = $factory->method('foo')->...->getNode();\n$method->setAttribute('comments', [new PHPParser_Comment_Doc('/* doc comment here /')]);\n```\n. I've added PHP-Rapidgen to the list of code generators. I've also decided to deprecate (and remove for 1.0) the templating functionality provided by PHP-Parser. External projects (like this one) do a much better job at handling that issue.\n. By default this isn't supported, but you can make use of a custom lexer that saves start/end offsets for nodes:\nphp\n<?php\nclass LexerWithTokenOffsets extends PHPParser_Lexer {\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n        $startAttributes['startOffset'] = $endAttributes['endOffset'] = $this->pos;\n        return $tokenId;\n    }\n}\nThen you can get the content of a node using\n``` php\n<?php\nfunction getNodeCode($code, PHPParser_Node $node) {\n    $startOffset = $node->getAttribute('startOffset');\n    $endOffset = $node->getAttribute('endOffset');\n    if ($startOffset === null || $endOffset === null) {\n        return ''; // just to be sure\n    }\nreturn substr($code, $startOffset, $endOffset - $startOffset);\n\n}\necho getNodeCode($code, $echoNode); // echo 'Hi ', hi\\getTarget();\n```\nOr in your case, where you only want to get the \"inner\" part of the node:\n``` php\n<?php\nfunction getArrayCode($code, array $nodes) {\n    if (empty($nodes)) return '';\n    $startOffset = $nodes[0]->getAttribute('startOffset');\n    $endOffset = $nodes[count($nodes) - 1]->getAttribute('endOffset');\n    if ($startOffset === null || $endOffset === null) return '';\nreturn substr($code, $startOffset, $endOffset - $startOffset);\n\n}\necho getArrayCode($code, $echoNode->exprs); // 'Hi ', hi\\getTarget()\n```\nHope this helps. (Note: Code not tested.)\n. @scil Sorry for the delay... The code samples I posted above were wrong, I mixed up token offsets and string offsets.\nHere's the correct code:\n``` php\n<?php\nclass LexerWithTokenOffsets extends PHPParser_Lexer {\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n        $startAttributes['startOffset'] = $endAttributes['endOffset'] = $this->pos;\n        return $tokenId;\n    }\n}\nclass NodeCodeFetcher {\n    private $code;\n    private $tokenToStartOffset = array();\n    private $tokenToEndOffset = array();\npublic function __construct($code) {\n    $this->code = $code;\n\n    $tokens = token_get_all($code);\n    $offset = 0;\n    foreach ($tokens as $pos => $token) {\n        if (is_array($token)) {\n            $len = strlen($token[1]);\n        } else {\n            $len = strlen($token); // not 1 due to b\" bug\n        }\n\n        $this->tokenToStartOffset[$pos] = $offset;\n        $offset += $len;\n        $this->tokenToEndOffset[$pos] = $offset;\n    }\n}\n\npublic function getNodeCode(PHPParser_Node $node) {\n    $startPos = $node->getAttribute('startOffset');\n    $endPos = $node->getAttribute('endOffset');\n    if ($startPos === null || $endPos === null) {\n        return ''; // just to be sure\n    }\n\n    $startOffset = $this->tokenToStartOffset[$startPos];\n    $endOffset = $this->tokenToEndOffset[$endPos];\n    return substr($this->code, $startOffset, $endOffset - $startOffset);\n}\n\n}\n```\nAnd a usage example:\n``` php\n<?php\n$code = <<<'CODE'\n<?php array('author_id' => $data_id,'abc'=>array('ok'=>3,'no'=>$data_id+1));\nCODE;\n$parser = new PHPParser_Parser(new LexerWithTokenOffsets);\n$stmts = $parser->parse($code);\n$codeFetcher = new NodeCodeFetcher($code);\nvar_dump($codeFetcher->getNodeCode($stmts[0]->items[0])); // 'author_id' => $data_id\nvar_dump($codeFetcher->getNodeCode($stmts[0]->items[1])); // 'abc'=>array('ok'=>3,'no'=>$data_id+1)\nvar_dump($codeFetcher->getNodeCode($stmts[0]->items[1]->value->items[0])); // 'ok'=>3\nvar_dump($codeFetcher->getNodeCode($stmts[0]->items[1]->value->items[1])); // 'no'=>$data_id+1\nvar_dump($codeFetcher->getNodeCode($stmts[0]->items[1]->value->items[1]->value)); // $data_id+1\n```\nHope this works for you!\n. Not sure how much sense it makes to test HHVM unless someone wants to actually work on support for HHVM. The main issue seems to be lack of support for binary syntax and incorrect tokenization of callable. Both should be fixable by appropriate adjustments in the emulative lexer, so if someone who has a HHVM setup wants to give it a shot...\n. Okay, it's merged now :)\n. Merged via https://github.com/nikic/PHP-Parser/commit/6f36a88993a07d0ccd52d813ceff27de022429c3 (without create_function, as it leaks memory).\nThanks!\n. @hinikato As a notice is not a fatal error, I don't see how this could interfere with a (correctly implemented) fatal error handler?\n. I merged the synchronization of the error messages, see https://github.com/nikic/PHP-Parser/commit/118f28344daf154e47e73e79779a60bc7430a40f.\nI did not merge the additional of the separate fatal error / parse error exception types - I think that for the majority of uses the distinction is unnecessary. If you need the separation for your particular case it should be easy to check for Syntax error and adjust the prefix based on that.\n. What code causes this? And on what version of PHP?\n. As the line number is 45 this sounds like a regression from #87, though not sure how it's caused.\n. @AleksMeshkov Could you please check whether the error disappears if you remove the return false in the dummyErrorHandler method? Or if you change the 0 in the set_error_handler call to E_ALL? (Or both?)\nThat's just guessing though, I have no idea how the additional of the error handler could cause this regressions...\n. @AleksMeshkov The line is necessary to reset the error state. However, I wonder where your output is actually coming from. The array looks like a dump of error_get_last(), which indeed should provide that output when called. However your code does not indicate anything in this direction. Maybe this is a badly behaving shutdown handler?\n@BenBradley Could you check whether you have xdebug.scream enabled? That's the only way I found to reproduce the issue...\n. @BenBradleySmith xdebug.scream is an aggressive debugging option that effectively disables the @ operator and as such will break any code using it. You shouldn't enable it unless you really need it.\nI'm not really sure what I should do with this issue (at least assuming it really only occurs with xdebug.scream). The code just can't work properly with that option (the undefined variable notice might be avoidable, but the issue would still persist for the actual token_get_all errors, should they occur).\nTo avoid at least the undefined variable error I thought that something like this might be possible:\n``` php\n<?php\n$prevTrackErrors = ini_get('track_errors');\nini_set('track_errors', 1);\nset_error_handler(function() { return false; }, 0);\n$this->tokens = @token_get_all($code);\nif (isset($php_errormsg)) {\n    $this->handleErrors();\n}\nrestore_error_handler();\nini_set('track_errors', $prevTrackErrors);\n```\nHowever it turns out that a bug in earlier (but still common) versions of XDebug breaks the track_errors mode, so that doesn't seem like a suitable solution either.\n. @Jamesking56 Do you also have xdebug.scream enabled?\n. As this appears to be a common problem, I'm now disabling xdebug.scream during lexing (see https://github.com/nikic/PHP-Parser/commit/5960ecfc105011b8d1bfedf7647b4b8989dbcb4c).\n. There were pretty little changes since 0.9.4 - just one edge-case bug fix in the name resolver and additional of a removeVisitor. Not sure it's worth having a release just for that...\n. @GrahamCampbell I will tag a final 0.9.x release before 1.0, but 1.0 is still a bit off :)\n. @GrahamCampbell Thanks for the reminder, I've created a 0.9.5 release now: https://github.com/nikic/PHP-Parser/releases/tag/v0.9.5\nThis will be the last release on the 0.9.x  branch and also the last one to receive a PEAR package :)\n. I think this project uses a coding style that is to a large part consistent with PSR-2 (method braces notwithstanding). However I won't be following PSR-2 to the letter (especially as I can't actually conform to it due to the requirements it makes on autoloading.)\n. Merged with default set to false, see https://github.com/nikic/PHP-Parser/commit/2605b8319e910bd9e6f9e505002108a1483ba9aa.\n. Thanks for catching! I'm using windows, so I don't notice stuff like that ^^\n. I like the idea behind this, but I don't think the implementation is appropriate. In particular:\n- The Name node is only used for namespaced names (or rather, names that can be namespaced). E.g. it is not used for class definition names (those are always just a simple string), but is used for class lookup names (which can be namespaced).\n- I don't think this belongs in the subnodes (as it just repeats information from the node type). It should either be an attribute (eh...) or much better, a simple method like getName().\n- As it is implemented as a subnode it changes various dump outputs and as such breaks several tests (see the Travis build).\nWhat I'd do is add a abstract public function getName(); to the MagicConst node and specific implementations like public function getName() { return '__DIR__'; } to the individual classes. Would such an implementation be okay with you?\n. The getName() method is implemented now, see https://github.com/nikic/PHP-Parser/commit/70077039b49e3577a4024c86718cd8b277bc1cf7 :)\n. I provide PEAR packages for PHP-Parser here: http://nikic.github.io/pear/\nHowever, I have decided to drop PEAR support with version 1.0. Back when this library was first released PEAR was still used by some people, but nowadays I don't think it's worth the hassle anymore. The PEAR channel server I'm using (Pirum) isn't even maintained anymore...\n. @llaville I'm not a big fan of PEAR in general. Actually, that's putting it a bit lightly. A more accurate phrasing is that I have a deep loathing for PEAR and the countless hours I wasted trying to get it to work properly. And, from what I gathered, that's the opinion most people have about it ;)\nTo me PEAR is effectively a dead ecosystem, superseded by Composer for all practical purposes. Makes little sense to continue supporting it.\n. A few questions to clarify: When you say it would never resolve the class: Does it fail on PhpParser classes or on your own? Also, does it only include lib/PhpParser/Autoloader.php or does it include lib/bootstrap.php? Would be nice to get the autoloader composer generated for this.\n. @fieryprophet I see the issue now. You're using the PHPParser namespace, but the classes are declared as PhpParser (yeah, that changed). While class names are case-insensitive in PHP that usually doesn't work well with autoloading (on unix).\nThe only thing that I could do against this is to switch to classmap based autoloading. But not sure that's worth the additional maintenance overhead... I'd recommend to just do a search&replace on PHPParser->PhpParser :)\n. I've added an experimental php-parse.php script: https://github.com/nikic/PHP-Parser/blob/master/bin/php-parse.php\nThe default functionality for php php-parse.php file.php is to dump the nodes of file.php, but it also supports pretty printing, serializing XML, var_dump()ing and resolving names.\nFeedback welcome :)\nPS: I haven't added this to composer yet, because I'm unsure as to how to handle the boostrapping file path with it.\n. If you need context/relationships, you have to keep track of those themselves. For the classes in particular that should be as simple as setting a $class property in your node visitor when entering a Stmt\\Class_ node. (Classes can't be nested, so that's all you need to do.)\n. Is this issue resolved?\n. Thanks for catching! Merged via https://github.com/nikic/PHP-Parser/commit/c8c233f9005ad9e3b1984ca99cb2e157a561cabd.\n. Deep cloning isn't currently implemented - so you can either roll your own or we could add some kind of Node::deepClone() method.\n. Thinking about this again, you can do a deep clone by traversing without a visitor:\n$traverser = new PhpParser\\NodeTraverser;\n$stmts = $traverser->traverse($stmts); // this will deep-clone $stmts\nThe node traverser is explicitly not in-place, so this will clone all nodes along the way :)\n. Fixed for If and all other nodes using optional subnode arrays in https://github.com/nikic/PHP-Parser/commit/f5be0d30f78fac47a61b45ca4bb4475dbad416b2.\nThe order should now be correct even if the order in the passed subnodes array is not.\n. Pretty printer does not preserve formatting, only semantics. See https://github.com/nikic/PHP-Parser/issues/71#issuecomment-23929399 (and #26) for workarounds.\n. Which autoloader are you using? The autoloading is currently not PSR-0 conformant (though I'll likely make it in the future), so you need to use the provided autoloader (PhpParser\\Autoloader). If you're using composer that should happen automatically.\n. The file names now match the class names including the trailing _, see: https://github.com/nikic/PHP-Parser/commit/c341ab2ecfa117b265c452666f11471e152c9416\nStill not compliant with PSR-0 after another look, but maybe with PSR-4, which no longer gives special meaning to the _ character.\n. Maybe you can just skip files that are larger than some fixed size? E.g. the one you linked is 290KB. If something is larger than 100KB, chances are that it's generated.\nImplementing limits for array sizes would likely hurt performance for people not making use of the limitation, because we'd have to do a size check on every single array push...\n. @patinthehat Something like that would be possible, but is not entirely easy to implement in a way that actually avoids parsing that code section (you'd likely have to handle this in the lexer already). Furthermore this would require explicitly modifying files to include such annotations, which might not be feasible for automated processing (like it is probably the case for the OP). I'd rather prefer not to add any complicated solutions for this, if some basic filter to detect \"heavy\" files might do the job.\n. @fluxreiners Don't know if that's applicable in your case, but if you're looking only at classes, you could check whether the file contains one beforehand (i.e. see whether there is a class / iface / trait decl in there). Either with a quick substring check or by checking for T_CLASS etc in the tokens (more accurate).\n. I think prettyPrintFile (https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinterAbstract.php#L104)should already handle this: It will strip the leading?>.\n. Replacements are done by returning the node fromleaveNode. For example, to replace allfoo(...)with\\Functions::foo(...)` write:\nphp\n<?php\nclass MyNodeVisitor extends PHPParser_NodeVisitorAbstract {\n    public function leaveNode(PHPParser_Node $node) {\n        if ($node instanceof PHPParser_Node_Expr_FuncCall) {\n            return new PHPParser_Node_Expr_StaticCall(\n                new PHPParser_Node_Name_FullyQualified('Functions'),\n                $node->name, $node->args\n            );\n        }\n    }\n}\n. You should be able to get the entire function (including docblock) via $prettyPrinter->prettyPrint([$node]).\nIf you want to extract it with original formatting, then you can get the end line via $node->getAttribute('endLine'). (Or use a more precise tokenoffset based approach, see #84 for a sample implementation.)\n. @Mikulas If I may ask, what did you need this for?\n. Parsing an incomplete PHP file is possible, but not currently implemented in the main branch. There's a stub implementation of error recovery in https://github.com/nikic/PHP-Parser/tree/errorRecovery and the surrounding discussion can be found in #60. If there's interest it should be possible to port that to the current version and make it somewhat usable.\nThough that probably only makes sense if you need static analysis data from the current file (like properties and methods of a half-finished class). The autocomplete-context itself should be easier to get by looking at the tokens near the cursor (like a cursor after T_OBJECT_OPERATOR is a property or method). Parsing won't help much with that.\n. Just as a heads up, I think the patch contains many useful changes which should be included, but I currently don't have time to review it and modify it to be generic (e.g. currently it relies on things like IDs of reduction actions, which is something that changes every time the grammar is modified).\n. Right, realistically this is not landing at this point. My current stance on the issue is that for non-trivial adjustment to the formatting an existing formatting library should be used, as mentioned in https://github.com/nikic/PHP-Parser/pull/116#issuecomment-238037924.. I can't reproduce this issue. I just ran /c/php-5.6.0beta3-nts/php bin/php-parse.php t01-guzzle.php, where t01-guzzle.php is the file in question and it parsed fine. I also tested this with PHP 5.3, 5.4 and 5.5.\n. The issue is likely that you are using PhpParser\\Lexer instead of PhpParse\\Lexer\\Emulative. The latter is required if you want to parse newer PHP code on an older version. (It handles newly introduces tokens etc).\n. I can see that the current behavior may not be appropriate in some cases, but I don't think it's worthwhile to change it now. It's been around for a long time and for many practical purposes (where you work on a syntax tree with resolved names) a leading backslash would only get in the way.\n. Thanks for catching this! I'll merge the PR in about a week, when I'm back home :)\n. Merged via https://github.com/nikic/PHP-Parser/commit/39f323b5ad80df7596bca77288cc911c09ab8e5c.\n. Good catch, I'll merge this in about a week, when I'm back home.\n. Merged via https://github.com/nikic/PHP-Parser/commit/c0340053d1b95718f18cb04a43190483b8c7268d. The case of \"static\" is now also preserved, see https://github.com/nikic/PHP-Parser/commit/ef121e690c2c68d81c1a083b2f7259112bd009ef.\n. Can you please report with issue with the PHP-compat-info project? My guess is that it uses code that does not account for the possibility of method calls with dynamic names (like $this->$method()), or something similar.\n. Just checked the code, the offending line is here: https://github.com/llaville/php-reflect/blob/v2/src/Bartlett/Reflect/Builder.php#L412\nIt assumes that the name of a property is a string, whereas it is a variable in your case. So the problematic code is probably of the form $var->$prop->method(). The same problem also exists in line 419, where the possibility of variable-variables is not accounted for.\n. Yes, this sounds like xdebug cropping the output. Do you get a full var dump if you pass -dxdebug.overload_var_dump=0 to PHP?\n. I added a line to the parse script to disable xdebug var_dump overloads in https://github.com/nikic/PHP-Parser/commit/7c812292617cca9a17f9599c021a74a8d1bc918f. Can you check if you get a meaningful output now?\n. @llaville You're right, looks like the 2.2 branch of xdebug used perdir/system for this. I guess a better approach then is to set max_children, max_depth and max_data to -1 to disable any output cutoff. This will still use xdebugs own var_dump format, but display everything.\n. Because it adds another option that does the same thing as the existing one, but for xdebug users. I'd rather have one option that works for both. Also, print_r output is very verbose.\n. Next attempt to fix this in https://github.com/nikic/PHP-Parser/commit/88e2d42ba4af37a543b906317500db7e835d1c22 :)\n. I've just released a beta 2 release, which adds support for a couple last minute PHP 5.6 changes. If no issues come up I can make a 1.0.0 release in, let's say two weeks.\nI also dropped the \"experimental\" message from the readme. I don't intend to do any more overhaul in the 1.0.x series...\n. We need a custom autoloader to support legacy PHPParser_ names.\n. 1.0 is the version that introduces the new names. It keeps BC with the previous ones. The next version can then remove the BC support.\n. I think a 2.0 version will be needed around the time PHP 7 comes out - at this point I'll need two different parsers for 5.x and 7.x and do API changes necessary to account for that. So somewhere around 2015-16.\nI don't think dropping these legacy aliases is particularly urgent. Creating that list was a one-time thing and if it helps people move to the 1.0 version, I think it's good to keep them for a while :)\n. Thanks, I've added the hook and the release is on packagist now!\n. Unless there is a specific case where addcslashes does not work, I will stick with it.\n. I'm not sure what the alternative here is. References are required if you want to have code like $node->stmts[] = $stmt work. If you have some particular suggestion on how performance of traversal can be improved, I'm all ears :)\nRegarding memory cleanup, did I understand it right that you get an increase in memory usage after performing multiple traversals? That shouldn't be happening (unless visitors retain data). Would be helpful if you can provide some code to reproduce this issue.\n. Could it be that you're in a namespace and you need to write \\PhpParser\\Node\\Name (or import Node or Name?)\n. This code is already present in the 0.9 branch, see https://github.com/nikic/PHP-Parser/blob/0.9/lib/PHPParser/Lexer.php#L46. Are you sure that you're using 0.9.5 rather than 0.9.4?\n. This error will only be thrown if you're using the NameResolver visitor. A quick test:\n```\n$ /c/php-5.5.0beta3-ts/php php-parse.php --resolve-names multiple_use.php\n====> File test.php:\n==> Resolved names.\nFatal error: Uncaught exception 'PhpParser\\Error' with message 'Cannot use Noez as Bar because the name is already in use on line 4' in D:\\htdocs\\PHP-Parser\\lib\\PhpParser\\NodeVisitor\\NameResolver.php:111\nStack trace:\n0 D:\\htdocs\\PHP-Parser\\lib\\PhpParser\\NodeVisitor\\NameResolver.php(33): PhpParser\\NodeVisitor\\NameResolver->addAlias(Object(PhpParser\\Node\\Stmt\\UseUse), 1)\n1 D:\\htdocs\\PHP-Parser\\lib\\PhpParser\\NodeTraverser.php(103): PhpParser\\NodeVisitor\\NameResolver->enterNode(Object(PhpParser\\Node\\Stmt\\Use_))\n2 D:\\htdocs\\PHP-Parser\\lib\\PhpParser\\NodeTraverser.php(56): PhpParser\\NodeTraverser->traverseArray(Array)\n3 D:\\htdocs\\PHP-Parser\\bin\\php-parse.php(59): PhpParser\\NodeTraverser->traverse(Array)\n4 {main}\nthrown in D:\\htdocs\\PHP-Parser\\lib\\PhpParser\\NodeVisitor\\NameResolver.php on line 111\n``\n. The parser only checks errors that are locally detectable (i.e. by examining only a single AST node). To detect other compile-time fatal errors one would have to use a node visitor to perform the checks. I'm not opposed to including such a visitor in this project if somebody wants to write it (but it could just as well live externally as well).\n. How do you include the autoloader? Via composer or by including the bootstrap file?\n. So, I have no idea what is going on here.orchestra/testbenchrequireslaravel/framework, which in turn requires a number of packages making use ofnikic/php-parser. However these use version ~0.9 of the library, so it's unclear wherePhpParser\\Autoloader` even comes from (which only exists in ~1.0).\n. Ah, that makes sense, I was already looking at the composer.json file after your fixes. Guess that means I can close this...\n. Yes, the parser does not distinguish between explicit and implicit visibility, because both are equivalent as far as PHP is concerned. It's a formatting difference and the syntax tree does not retain formatting.\nThe only way to distinguish this currently is by inspecting the tokens. Using the token offset lexer:\n``` php\n<?php\nfunction isImplicitlyPublicProperty(array $tokens, Stmt\\Property $prop) {\n    $i = $prop->getAttribute('startOffset');\n    return isset($tokens[$i]) && $tokens[$i][0] === T_VAR;\n}\nfunction isImplicitlyPublicFunction(array $tokens, Stmt\\ClassMethod $method) {\n    $i = $method->getAttribute('startOffset');\n    for ($c = count($tokens); $i < $c; ++$i) {\n        $t = $tokens[$i];\n        if ($t[0] === T_PUBLIC || $t[0] === T_PROTECTED || $t[0] === T_PRIVATE) {\n            return false;\n        }\n        if ($t[0] === T_FUNCTION) {\n            break;\n        }\n    }\n    return true;\n}\n```\nIf you like, I can add support for getting this information directly to the parser, but that would be a temporary solution.\n. @cmb69 Yep, that pretty much matches what I had in mind. And yes, getting the tokens using a getTokens() method on the lexer sounds like a fine approach (and is even necessary if you extend the emulative lexer - which has different output than token_get_all). So something like https://gist.github.com/nikic/04fce01e69ae5b7b44f8.\n. @llaville Yeah, that was a copy&paste error. I've fixed the code in the comment.\n. @llaville Doesn't that just mean that you need to cache both the tokens and the AST?\n. Good catch, it was a typo in the grammar. How did you find this?\n. There's no direct support for this - if you want to do something like this you'll have to implement it yourself. I've just added a bit of docs on how to use a token offset lexer. This provides you with more precise location information than start/end lines, which you can then use to modify the code.\nHowever the whole process for doing modifications is somewhat involved and may not be worthwhile in your case (if you're only interested in inserting whole methods, rather than doing more \"delicate\" changes).\n. @llaville Thanks, fixed in https://github.com/nikic/PHP-Parser/commit/f41a4c9acbeeced789a0660b96a35418d3bac851.\n. The lexer docs include a token offset lexer which can be used to add the start and end token offset to the AST nodes.\nNow, you probably don't need token offsets but file offsets, but that shouldn't be much harder. You'd have to add a property with the current file offset and on each new token put the current offset into a start attribute, then add the length of the token and put the result into an end attribute. You won't be able to do this by extending getNextToken() as it already drops whitespace and comments (which you need for the offset calculation), so you probably need to copy https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Lexer.php#L90 as a whole, so you can do the offset calculations even for the dropped tokens.\n. @Fuco1 It would be nice if you could put your implementation in gist or something, for future reference. I don't think it's possible to include it in the main codebase, because I'm using a shitty inheritance-based lexer design, which means the implementation would have to inherit one of PhpParser\\Lexer or PhpParser\\Lexer\\Emulative and would not be usable with the other one.\n. Thanks!\n. Nice catch! I've merged this as https://github.com/nikic/PHP-Parser/commit/6fad8ff32a3d45d215eb094299581bd43e9502d6 with a few tests :)\n. Just tagged a release: https://github.com/nikic/PHP-Parser/releases/tag/v1.0.2\n. Directly using the parse tree (instead of manually constructing an AST) was something I considered before writing this project - it's a lot easier to implement (basically just grab the Zend grammar file and adjust the kmyacc code to create nodes when reducing) and it's great for code refactoring because you can retain the entire formatting.\nHowever it has a problem (apart from the usual differences in use case for a concrete parse tree and an AST): PHP's grammar sucks. Especially the way complex variables are implemented (like properties, methods, varvars, ...) is really weird and results in parse trees that represent syntax, but aren't semantically meaningful. Like, you can't say whether a variable is an object access or an array access without inspecting leaf nodes (and of course there's half a dozen ways that an object access could be represented, depending on the exact details).\nWhich is why I abandoned the parse tree approach originally. I think with the UVS and AST implemented in PHP 7 the grammar got a lot more reasonable and this might be a feasible approach in the future. And probably it's also okay now if you're more interested at things at the namespace/class/method level than at the variable level.\n. Closing as this isn't a real issue.\nBtw there's also https://github.com/grom358/pharborist which tries to better support preserving whitespace and formatting in general. Didn't look closely at it yet.\n. Thanks for catching this, should be fixed with https://github.com/nikic/PHP-Parser/commit/0f69f12b94900396c71754bdabef945e6907688e.\n. As @Ocramius pointed out, you have to keep track of state yourself. So in enterNode, if you encounter a Stmt\\Function_ node, save it as the current function. As functions can be nested you likely want to use a stack instead, which contains all functions you're currently in, in nesting order. Furthermore take care that Stmt\\Function_ are only actual functions, not methods or closures, so you may need to handle these as well, depending on what you want to do.\nMaybe we should provide a premade visitor that can keep track of state like this...\n. The lexer docs include an example on how you can retrieve token offset information. A similar thing can also be done for file offsets, which is discussed in more detail in #140. The issue also includes a link to a project that contains a file offset lexer, so you could take a look at that.\n. @suralc Nope, that's what I'd do as well. The lexer docs (https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown) also suggest this in the lower part (the originalValue for literals). The top part of the page has a more general approach using token offsets. This can be used in some more complicated cases where just looking at the first or last token of a node is not enough.\n. Added kind attribute for LNumber nodes in https://github.com/nikic/PHP-Parser/commit/ae30f97af6e006a26398d17de1b5c8ab933b822d.\n. And same is now also supported for array nodes: https://github.com/nikic/PHP-Parser/commit/aa199120c73d2d7a5fd1fb4d6a75025ccbaef886\nAs such closing this issue, finally :)\n. I'm wondering where endPos should be pointing - to the last character of the token or one past the last character. Your implementation currently does the latter. The token offset implementation (=> https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown#token-offset-lexer) uses the former.\n. I've merged this as https://github.com/nikic/PHP-Parser/commit/d774dbc1b72fcd28698df9a6487395d2f0947a88 with two modifications:\n- The attributes are called startFilePos and endFilePos to avoid ambiguity with token positions.\n- The attributes aren't added by default, because they aren't usually needed and incur a performance and memory usage overhead. For this purpose I've added an options array for the lexer, which can be used to specify the wanted attributes. (This also works for the three other attributes that are already provided).\nFor now I kept the \"one past the end\" position behavior, but that's subject to change.\n. I like the idea behind this, but I suspect that it has to be implemented in a different way to be useful in many situations:\nRight now the \"scope\" is just a concatenation of the namespace, class, method, etc names. This is ambiguous in many cases, e.g. foo::bar::baz could be a method baz in a class bar in a namespace foo, but it could also be just three nested functions foo, bar and baz. I think it would be better to instead provide the actual AST nodes representing the classes/functions/...\nBut of course, adding an array of scope nodes to every single node is probably not practical. The alternative would be to make this visitor not touch the AST itself and only provide methods like getCurrentClass() and getCurrentFunction(), so this visitor can be used by other visitors to access this data.\n. Closing per the previous comment. \n. I'd like to keep the ability to chain operations. Maybe it would be good to throw an error if -N is the last one, followed by nothing? That doesn't make much sense and would probably be the most likely problem.\n. @ondrejmirtes exit and die are strictly identical, both accept either a status code or a string to print.\nGenerally the way something like this can be currently distinguished is by extending the lexer and adding an attribute, e.g. as done in the code sample on https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown#attribute-handling.\nSo for this particular case you'd do something like this:\nif ($tokenId == PHPParser\\Parser::T_EXIT) {\n    $endAttributes['isDie'] = strtolower($value) === 'die';\n}\n. Now adding a kind attribute to Exit nodes in the default lexer: https://github.com/nikic/PHP-Parser/commit/47c342a3e43b31c91fd757733a42072dab66fcd4\n. I'm not sure I understand this PR. define() always accepts a FQCN, so if you pass 'FALSE' to it you will be defining the constant \\FALSE, even if you are in a namespace. Or did I misunderstand what this is about?\n. First of all: false is a bad example for this - overwriting it is illegal and PHP is free to assume that this is the normal, global false regardless of what you defined. It already does that in some contexts in PHP 5.x and always in PHP 7.x.\nBut if you consider some other constant, say M_PI, then the answer is: You can't distinguish them in the general case. A reference to M_PI in the Sandbox namespace can either refer to the global M_PI or Sandbox\\M_PI and there is (usually) no way for you to know. Just looking at const declarations or define() calls in the file doesn't really help either, because it could also be defined in a different file using the same namespace. PHP itself also doesn't resolve this until runtime.\nSo the only real option that you have (if you must resolve it to a FQN) is to use some kind of heuristic, e.g. assume that no built-in constant has been overwritten in a namespace (which is true for most code).\n. Yeah, both suggestions make sense to me. I'd go for the names startTokenPos and endTokenPos for this. At this point we should also decide what \"end\" means (whether it's end or end+1), so endTokenPos and endFilePos have consistent behavior.\n. startTokenPos and endTokenPos attributes are now optionally available: https://github.com/nikic/PHP-Parser/compare/e0f3e8a492...894c3f787d\n. Just specifying the class name won't work for lexers with constructor arguments, e.g. the options array that was recently added to the default lexers. (Also using the include path is problematic, given how little it is used nowadays. It would require you to always include a -dinclude_path=... argument as well).\nWe could solve this by making --lexer take a file that returns the lexer (<?php return new Bartlett\\PhpParser\\Lexer\\TokenOffsets;).\nAlternatively, if you're mainly interested in the token offsets, we could add an option specifically for that (now that it's directly supported).\n. Closing as duplicate of #146. See also https://github.com/nikic/PHP-Parser/issues/26#issuecomment-6150035 for a way to currently retrieve the number exactly as it was written.\n. Merged as https://github.com/nikic/PHP-Parser/commit/f5432a76b69655575b5d7cc5abf3b0ad1417a89a. I've also changed the call to prettyPrintFile so that it actually prints the <?php as well.\n. I've merged the namespace portion in https://github.com/nikic/PHP-Parser/commit/01643e06d3a3721ef6cd04fdaad2a3c3eae9ed5a. The builder now also has addStmt/addStmts methods, because statements for a namespace are supposed to be included in the namespace node (while the approach of just making it an empty namespace and adding statements after it also works if you'll only use the pretty printer afterwards).\nI've not merged the use part yet, because I don't think it makes much sense to have a separate builder class if it's going to directly create the node without additional options. I'd probably go for returning the Use node directly from $factory->use(), even if it might not be the cleanest design.\n. A \"bit\" late, but the use builder is now in as well: https://github.com/nikic/PHP-Parser/commit/0c34706799d298864a8e0cd4b1cb3eff710540bc With an as method for a custom alias.\n. I've added setDocComment() methods to the relevant builders (class, interface, function, method, property), so you don't need to manually create a doc comment array. See https://github.com/nikic/PHP-Parser/commit/2438848487bc2564c2fe472c5bf6db54153ce6f3.\n. I've added a NodeTraverser::DONT_TRAVERSE_CHILDREN return value for enterNode() in https://github.com/nikic/PHP-Parser/commit/4071c4645d22881c05fa4bac03eb6da2158f5c69. The details of what will (not) be called are described in https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeTraverserInterface.php#L7.\nDoes this look okay to you?\n. new has a higher precedence than concatenation, so PHP interprets your expression as $obj = (new $name1) . $name2 (*). See http://codepad.viper-7.com/grv7BL.\n(*) Actually this has less to do with precedence and more with the fact that new only accepts call-free base-variables. But it's easiest to think about it in terms of precedence.\n. If this is just a perf optimization, I'm not sure the added complexity is worth it. After all it's not just breaking out of a loop. We'd still have to do the leaveNode calls, but only for visitors that weren't skipped. \n. I don't think I really understand why we need a special NodeProcessor here. How does this differ from just using a two passes? I.e. first do a pass with one visitor that find conditional usages and then do your second, normal traversation pass. Or did I misunderstand something?\n. Okay, so even without changing the main code handling the analyzers to have multiple passes, aren't you essentially doing an additional pass in the beingTraverse() method of the analyzer? Just not using the NodeTraverser, but a NodeProcessor which seems to be doing about the same thing minus some replacement functionality.\nTo put the question more concretely: What's preventing you from creating a second NodeTraverser in the beginTraverse method and do a pass with it? Why do you need a separate concept of a NodeProcessor?\n. To avoid copying this into the three classes and allow simpler instanceof checks I've split this off into a ClassLike parent, see https://github.com/nikic/PHP-Parser/commit/1366e833a16c4267883187da6da7b317f0582dd7.\n. You can filter the tree by implementing a visitor, see https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#node-traversation. What exactly the visitor has to do depends on what you mean by \"classes called of this file\".\nYou can also get more compact output than var_dump using the NodeDumper, see https://github.com/nikic/PHP-Parser/blob/master/doc/3_Other_node_tree_representations.markdown#human-readable-dumping.\n. The file offsets are byte offsets yes. I won't be switching to codepoint offsets, because this would (apart from being a PITA in general) require actually knowing the encoding of the source file, which is something that is not generally known and cannot be reliably guessed.\nI would recommend you to convert the byte offsets into codepoint offsets using your knowledge of the used encoding. It doesn't look like PHP has a function to do this directly, so a combination of mb_strcut with mb_strlen should do:\n$cpOffset = mb_strlen(mb_strcut($code, 0, $byteOffset));\nIf you want to use grapheme cluster offsets instead (which may be more appropriate as the umlauts may be created using combining marks) you could use grapheme_extract with GRAPHEME_EXTR_MAXBYTES in combination with grapheme_strlen. This of course assumes that your code is in UTF-8.\n$gcOffset = grapheme_strlen(grapheme_extract($code, $byteOffset, GRAPHEME_EXTR_MAXBYTES));\n. There's already a ticket about this: #60. It has a link to a stub implementation that supports error recovery. I didn't pursue this further, because there didn't seem to be interest anymore.\nIt shouldn't be too hard to port this to the current code and add enough error recovery tokens to make it useful. But I don't think I'll have time to work on this soon.\n. Nope, I don't take consulting work on this project ^^ But I found some time to port the error recovery code to the 1.0 parser code, see https://github.com/nikic/PHP-Parser/tree/errorRecovery2. It's just a quick&dirty implementation, but it seems to already work for a number of cases, see https://github.com/nikic/PHP-Parser/commit/3c0c2380478596636f77bb5481e8322906554141#diff-6 for some examples.\nThe usage is still as described in ticket #60. What this primarily needs is a) better error annotations (this requires some feedback, we need to find cases where recovery does not yet work well) and b) handling for non-syntax errors, which currently just throw exceptions, so immediately abort everything.\n. This is in master now: https://github.com/nikic/PHP-Parser/blob/master/doc/component/Error.markdown#error-recovery\nCurrently only a single error symbol is included (I noticed that the grammar in the errorRecovery2 branch had reduce/reduce conflicts), so this is currently somewhat limited. \n. The parser doesn't analyze doc comments, it only returns them literally as they occur in the source code. Parsing doc comments is outside the scope of this project (especially such exotic things like templates - first time I heard about it).\n. It is not explicitly supported, but you should be able to do this simply by parsing <?php expr; instead. Example:\n<?php\n$parser = new PhpParser\\Parser(new PhpParser\\Lexer);\ntry {\n    $stmts = $parser->parse('<?php ' . $expr . ';');\n    $expr = $stmts[0];\n    // Do something with $expr\n} catch (PhpParser\\Error $e) {\n    // ...\n}\n. According to http://twtsurvey.com/xdebug-max-nesting you should be able to safely increase the nesting limit to something like 10000. If that's enough I'd just do that instead of trying to track recursion level during traversation.\n. I've adjusted the docs to use a 3000 nesting limit in https://github.com/nikic/PHP-Parser/commit/8f1eacdab702d94f569e1cfc00bb67543768e03a.\n. Just to clarify, the change in https://github.com/nikic/PHP-Parser/commit/b7ffdbbb929f9f07780a236659d1d1baf68ef137 targets a particular case where $r is a huge string and doing one concat instead of two (which also means one realloc instead of two) makes a large difference. In the two cases that changed here it doesn't make a practical difference.\nI've merged it anyway, if only to have consistent code in one file :)\n. Nope, the concat there happens before the concat with $r, so it is operating on a small string only.\n. Sorry for the delay, now merged as https://github.com/nikic/PHP-Parser/commit/e3bc5b564d2eaceae8ecb74ff8194efa6235a04f :)\n. Sorry for the delay, I was out of town.\nApart from the static property, these additions don't seem to be testing the builder functionality, but rather test manual creation of nodes (which builders are there to avoid). So if we want to test this, this probably isn't the right place. I'm not sure if it has to be tested as its implicitly tested by the parser tests.\nBtw, the new Expr\\Variable(\"value['sasa']\") instantiation in particular should be new Expr\\ArrayDimFetch(new Expr\\Variable('value'), new Scalar\\String('sasa')).\n. Personally I agree with @remicollet - it's not a biggie for this project due to low commit activity, but I find it rather annoying to have to clone huge git repos just to get to the test files.\nComparing the sizes of the 1.0.2 and 1.1.0 tar.gz archives, size went down from 110KB to 74KB. Is that really worth causing extra hassle?\n. I've reverted the .gitattribute changes in https://github.com/nikic/PHP-Parser/commit/c96636d19231fd0110021060fb258169b4eacdb3.\n. This is an often requested feature (see also #41), but it's pretty hard to implement format-preserving transformations in a generic way. I don't see this being implemented anytime soon :/\nThe approach I am currently using for this purpose is to make modifications based on token positions (see https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown#using-token-positions). I.e. using the AST I find what places need to be changed and then do the changes in the token array. (Alternatively you can use file positions and directly replace the code rather than replacing tokens.)\n. Current behavior was implemented in https://github.com/nikic/PHP-Parser/commit/0f69f12b94900396c71754bdabef945e6907688e. Your suggestion makes sense as it differentiates between implicit/explicit and at the same time preserves isPublic() behavior. I've merged this as https://github.com/nikic/PHP-Parser/commit/73cace360d676ce4284aa7e19a07b4e39c3d3eda with a tweak to preserve the previous behavior for the property builder - it will never generate obsolete var property declarations.\n. Sorry, I don't see any way to associate that comment with a node using the current system. The comments needs to be before the first token of a node to be recognized.\n. For the record, if you're hitting an error like Cannot use 'String' as class name as it is reserved running on PHP 7: All you need to do is update to version 1.3 and if that doesn't fix it replace your usages of String with String_.\nThis issue is only about support parsing of PHP 7, not running on PHP 7 (which should already fully work).\n. It's been a while ... I think the clone is there because conceptually the traverser is supposed to take one AST and return a new one, which is independent from the original.\nIn hindsight this was probably a bad idea, given how the traverser is normally used to replace the orginal ($stmts = $traverser->traverse($stmts)). But I don't think this can be changed at this point.\n. Maybe add a flag to the ctor that allows skipping the clone?\n. Thanks for the report - the issue is that instanceof does not invoke the autoloader, so the aliases are not registered.\n. @GrahamCampbell Not really a bug. If a class isn't loaded yet, then there's no way an object can be an instance of said class - that's the idea behind not making instanceof autoload. The premise is no longer true with the introduction of class_alias, but given that it is a rather second-class citizen I don't think it likely that this behavior will be changed.\n. Here we go: https://github.com/nikic/PHP-Parser/releases/tag/v1.2.1\n. Why not just run the name resolver before anything else (i.e. separate pass)?\nBut I don't have a problem with adjusting the code to resolve param types earlier, if it makes things simpler.\n. Here goes the release: https://github.com/nikic/PHP-Parser/releases/tag/v1.2.2\n. Not sure I get what you mean - an interface can extend multiple other interfaces, while a class can extend only one other class, thus the different representation.\n. It's not possible to print only part of a node. To print just the method $foo->bar part of the method, I'd create a new temporary node new Expr\\PropertyFetch($methodCall->var, $methodCall->name). To print just the arguments, loop over the args array and print each $arg->value individually.\n. IIRC I originally copied the autoloader over from Twig, which at the time included this ini_set call. I just checked and it looks like they dropped this about two years ago.\nSo yeah, I'd say this serves no purpose whatsoever and can be dropped.\n. Merged the second commit via https://github.com/nikic/PHP-Parser/commit/8d18848fb0e119f1a66089c75f459e3212b8dabd. I had to drop the process isolation test because, for whatever weird reasons, PhpStorm goes totally crazy when it tries to run that test (though running phpunit from cli works)...\n. You're right on all counts ... it's going to be reserved in PHP 7, you should use String_ and this is a bug. The old class name is still supposed to work. I messed up when fixing another class_alias issue :/\n. Support for array/false return is only available in leaveNode.\n. You should be able to preserve the comments by taking them off the include node and merging them with the comments of the first statement in the file. So something like this:\nphp\n$stmts = $parseFile->traverse()->getStmts();\nif (isset($stmts[0])) {\n    $stmts[0]->setAttribute('comments', array_merge(\n        $node->getAttribute('comments'),\n        $stmts[0]->getAttribute('comments')\n    ));\n}\nreturn $stmts;\n. Great :) Btw, you can also write $node->getAttribute('comments', []) for the default value ;)\n. I don't think column numbers should be added to errors by default (there are a couple of projects that wouldn't like that, at least). However we should definitely have the ability to get this info.\nI think the best way to do this would be to provide the Error object with the complete attributes of the token (or node) where the error occurred. This should allow easily computing the column numbers based on startFilePos and endFilePos (or the token position as done here, either would work). This would also allow having column information to errors not thrown directly from the parser. (And would also provide the end line).\n. Merged in https://github.com/nikic/PHP-Parser/commit/33a39fae06dec77ba262fae61b2727fe960d5215 with some more tweaks in https://github.com/nikic/PHP-Parser/compare/33a39fae06dec77ba262fae61b2727fe960d5215...62f83a0dc25e191b369b3c77415059c263009a23.\nThere are a few open issues:\n- What columns should be used for EOF errors? Right now these won't have column info.\n- Should column info be added to errors that don't have accurate position information? E.g. if the best that can be done is mark an entire class as an error?\n- Should columns be 0-based or 1-based? Currently they're 0-based, but 1-based seems to be more common for columns.\n. Column numbers switched to 1-based in https://github.com/nikic/PHP-Parser/commit/c8454271e10008d34e4fdc0b9d2e17d72834a931.\n. Added info for EOF errors in https://github.com/nikic/PHP-Parser/commit/a35c2a20671199fffcb424d9183f0a959b105065. I've put the location at one past the end of the file. Might be better to put it one past the end of the last non-whitespace, non-comment token instead - phpstorm does this for example.\nAnyway, closing this issue as the feature should be mostly complete now.\n. @felixfbecker It is documented both in phpdoc (https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Error.php#L96) and and the error documentation (https://github.com/nikic/PHP-Parser/blob/master/doc/component/Error.markdown#column-information)\n. I don't think this belongs in NodeVisitorAbstract (which only job is to provide you empty method bodies). You can easily implement a separate visitor providing the context information that is necessary for your use case.\n. Visitors are always run in the order they're registered. (I.e. they run concurrently, but for each node they are run in-order, which should be sufficient for managing context.)\n. Merged via https://github.com/nikic/PHP-Parser/commit/69c00ebbe4f29f53c6b686948f5b233b6b050eee, thanks!\n. Agree that this would be nice, I've run into this myself a couple of times as well. As you already said, the reason why this wasn't done yet is the Stmt/Expr problem. Your suggestion of using an interface with getters sounds reasonable. The alternative would be making Stmt/Expr into interfaces, but that's probably not better.\n. @suralc I'd drop the getName() method (as closures don't have one) and rename getBody() to getStmts() to mirror the property names 1-to-1. Might also want to extend from Node - so a typehint against FunctionLike also guarantees all the other usual node methods.\n. Regarding the null statement, the problem is the first ; in front of ;null; -- The comments will be associated with the ; statement, which is not represented in the AST. If you write null; instead the comments should turn up there.\nRegarding the actual problem: Yes, you're correct in saying that assigning comments as attributes of the next node is a rather inaccurate representation. The thing is that this parser constructs an AST, where the \"A\" is for \"abstract\", which means it's not supposed to include comments or whitespace information. Comments are primarily collected for the sake of doc comments, which are often important for analysis (and in the case of annotations are really part of the code).\nComments can turn up virtually anywhere, e.g. Foo /* foo */ \\ /* bar */ Bar is a valid namespace name and I wouldn't know how one would represent something like that without switching to a different (CFT) tree structure.\nWhen I'm doing source-to-source transformations that are supposed to preserve comments and whitespace, I do it by enabling file/token offsets in the lexer and directly modify the code/tokens based on the offsets stored in the ASTs. Haven't found a way to reliably to these transformations directly on the AST yet.\n. So, here is how I would go about your particular case: In the lexer, enable token end positions. Get the tokens from the current file via $lexer->getTokens(). Now you should get the trailing comment of a node using something similar to this (not tested):\n``` php\nfunction getTrailingComment(array $tokens, Node $node) / : ?string / {\n    assert($node->hasAttribute('endTokenPos'));\n$pos = $node->getAttribute('endTokenPos');\n$endLine = $node->getAttribute('endLine');\n\nfor (; $pos < count($tokens); ++$pos) {\n    if (!is_array($tokens[$pos])) continue;\n    list($type, $content, $line) = $tokens[$pos];\n    if ($line > $endLine) break;\n    if ($type === T_COMMENT || $type === T_DOC_COMMENT) {\n        return $content;\n    }\n}\n\nreturn null;\n\n}\n```\n\nPerhaps I can use the Lexer stand-alone without the Parser to implement this? At least that would be better than token_get_all().\n\nThe lexer is just token_get_all() with a few compatibility hacks for different PHP versions ;)\n\nDo you know of any other implementation of a CFT for PHP?\n\nI think https://github.com/grom358/pharborist might be doing this. I'm not really sure about this, because the project sadly doesn't have documentation.\n\nOr would it make sense to introduce an additional layer in your parser? (not asking you to do the work here of course, just asking if you think it's feasible - or would the additional intermediary CFT model cause too much CPU and memory overhead?)\n\nHaving an additional parse tree layer would indeed be problematic for perf. I can only see this as a separate mode of operation. But I've never looked into this much.\n. @mindplay-dk If formatting-preservation is enabled, then comments will be kept without modification, yes. The representation of the comments in the AST has stayed the same though.. This happens because you're using PhpParser\\Lexer\\Emulative, which will try to tokenize the code as if you were running on a more recent PHP version. If you use PhpParser\\Lexer the token_get_all output will be used directly and you should be able to parse the posted source code.\n. Yes, if you want to parse newer PHP versions, the emulative lexer is required - in which case you also cannot use the new keywords as identifiers. I don't think I can really do anything about that.\nIf you want to detect whether new keywords are used, maybe just scan token_get_all output for it?\n. @llaville This will solve the issue for your particular code - if it's really exactly that code. However, if something declares a class Trait, chances are that it's also going to be used somewhere - like new Trait or Trait::FOO. To make this work for more than reduced example code, all possible occurrences of identifiers would have to be supported. From the research into this topic done for the php-src context sensitivity patch, this is not feasible.\n. @llaville Just took a look at your code and I don't think this solution is stable enough for general use. For example this pretty \"normal\" code will not work, unless I missed something:\nphp\nif (!trait_exists('Foo')) {\n    trait Foo { ... }\n}\n. @llaville It fixes this particular issue, but the problem is more general. Especially yield can occur practically everywhere, e.g. you can write 5 * yield.\n. Closing this, as I don't plan to support it.\n. Merged via https://github.com/nikic/PHP-Parser/commit/bb2c5303ae1149dabcde9709ece6abca4850057b. Thanks for implementing this and sorry for the delay.\n. The lexer return values refer to the class constants defined in https://github.com/nikic/PHP-Parser/blob/1.x/lib/PhpParser/Parser.php#L30 (which have the same names as the corresponding PHP constants). This can't match up with PHP values because those vary between different versions anyway.\nWhy are you using the lexer by itself though? It's just a thin wrapper around the native token_get_all().\n. This issue is basically the same as #205 and/or #36: Comments are always associated with the next node and if there is next node they are lost. I don't know how this can be solved at this point.\n. Merged via https://github.com/nikic/PHP-Parser/commit/7fbbf83011fe6e2564d54b720270f963408e08e5. It's not PHP code, but the highlighting happens to work nicely ^^\n. Yeah, this is just a typo. Same issue exists in https://github.com/nikic/PHP-Parser/blob/1.x/lib/PhpParser/Node/Stmt/Function_.php#L16, https://github.com/nikic/PHP-Parser/blob/1.x/lib/PhpParser/Node/Expr/Closure.php#L19 and https://github.com/nikic/PHP-Parser/blob/1.x/lib/PhpParser/Node/FunctionLike.php#L26.\n. @GrahamCampbell string|null is not a valid return type in PHP, at least not yet. Note that this is not referring to doc comments, but to actual return types.\n. Fixed with https://github.com/nikic/PHP-Parser/commit/42e368e964e121d67d418708e2c12000a151aee6.\n. The namespace builder will always create a namespace. If you don't want to have a namespace you should simply not use the builder for it. For example:\nphp\n$stmts = [\n    $factory->use('Some\\Other\\Class')->getNode(),\n    $factory->class('MyClassName')->getNode(),\n];\necho (new PhpParser\\PrettyPrinter\\Standard)->prettyPrintFile($stmts);\n. @tleb Fixed the code in the comment and also fixed the infinite recursion issue when getNode() wasn't called there: https://github.com/nikic/PHP-Parser/commit/5ede167835fba5fe9624967654ad6eda48e3d14f\n. Nice catch, merged. The same issue also existed for static properties, so this is fixed now as well.\n. Thanks for the report, this is now fixed by https://github.com/nikic/PHP-Parser/commit/b862de1f5bdb1db0b9ce0aad97409ac5c78710c6. I forgot that traits can have properties as well.\n. 1) It would be relatively complicated to do this (especially generating the builder code), I don't think it's worth the effort.\nThe most important part when doing codegen is a) having a good IDE (= PhpStorm) and b) knowing how nodes are called (e.g. via a node dump). \n2) I've just added a ClassLike::getMethod($name) method (returning null if not found). With properties there's currently the issue that public $foo, $bar; has one node for the whole declaration and two separate ones for $foo and $bar. Just returning the inner nodes is not useful in many cases because they lack visibility information.\n. You can enable byte offsets in the lexer: https://github.com/nikic/PHP-Parser/blob/1.x/doc/component/Lexer.markdown#lexer-options\nphp\n// something like this\n$lexer = new PhpParser\\Lexer(array(\n    'usedAttributes' => array(\n        'comments', 'startLine', 'endLine', 'startFilePos', 'endFilePos'\n    )\n));\nHere's some sample code for converting the file offset into a column number: https://github.com/nikic/PHP-Parser/blob/1.x/lib/PhpParser/Error.php#L123\n. Nope, there is currently no simpler way if you're constructing directly. If you're using builders things like default values and initializers will automatically convert null values etc to constant fetches, but that's limited in scope. The implementation might serve as inspiration though: https://github.com/nikic/PHP-Parser/blob/1.x/lib/PhpParser/BuilderAbstract.php#L64\n. The BuilderFactory now has a val() method which creates the AST for literal values, including null/false/true. So a null can be created using $f->val(null).. Nothing particular (apart from one last-minute PHP 7 grammar change). I was hoping to get some more feedback, but there doesn't seem to be any...\n. Just tagged a beta: https://github.com/nikic/PHP-Parser/releases/tag/v2.0.0beta1\n. I wasn't able to reproduce this issue (put your second example in a file and ran bin/php-parse.php over it). Could you provide a sample code for how you're calling the parser?\nMy initial suspicion is that your single line comments are not followed by a correct (LF or CRLF) newline character.\n. Can you share the code you're currently using? The originalValue approach should already work for NOWDOCS and non-interpolating HEREDOCS.\n. The problem is that nowdoc is not represented by T_CONSTANT_ENCAPSED_STRING, but by the sequence T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE T_END_HEREDOC. The attributes will be collected from the start/end tokens only. A possible way to hack around this is something like this:\n``` php\nclass KeepOriginalValueLexer extends PhpParser\\Lexer\\Emulative\n{\n    protected $currentHeredoc = null;\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n    if ($tokenId == PhpParser\\Parser::T_CONSTANT_ENCAPSED_STRING\n        || $tokenId == PhpParser\\Parser::T_LNUMBER\n        || $tokenId == PhpParser\\Parser::T_DNUMBER\n    ) {\n        $endAttributes['originalValue'] = $value;\n    }\n\n    if ($tokenId == PhpParser\\Parser::T_START_HEREDOC) {\n        $this->currentHeredoc = $value;\n    } else if ($this->currentHeredoc !== null) {\n        $this->currentHeredoc .= $value;\n    }\n\n    if ($tokenId == PhpParser\\Parser::T_END_HEREDOC) {\n        $endAttributes['originalValue'] = $this->currentHeredoc;\n        $this->currentHeredoc = null;\n    }\n\n    return $tokenId;\n}\n\n}\n```\nIt's pretty ugly, but it should work :)\n. There's no specific reason for the choice of concurrent over sequential. It's faster than the alternative and handy for certain usages (e.g. can have a state collecting visitor used by other visitors), but it could have gone either way.\nHowever, in case you do need sequential runs, you can simply create another NodeTraverser and traverse again using it. Something like this might be useful to have multiple sequential passes each consisting of concurrent visitors:\n``` php\nfunction runPasses($ast, array $passes) {\n    foreach ($passes as $visitors) {\n        $traverser = new NodeTraverser;\n        foreach ($visitors as $visitor) {\n            $traverser->addVisitor($visitor);\n        }\n        $ast = $traverser->traverse($ast);\n    }\n}\nrunPasses($ast, [\n    [$visitor1, $visitor2],\n    [$visitor3],\n    [$visitor4, $visistor5],\n]);\n```\nAs such a function is easy to write and in my experience not commonly needed (what you usually need are sequential passes over all files, rather over a single AST), I don't think adding extra APIs for this is necessary.\n. The suggested usage for this method is (new ParserFactory)->create(ParserFactory::PREFER_PHP7) rather than ParserFactors::create(ParserFactory::PREFER_PHP7). The latter is a perfectly reasonable alternative in this case (as it's unlikely this class will ever have a meaningful constructor), but I try to avoid static methods unless strictly necessary.\n. @ovr Why doesn't it work without xdebug? The recursion limit only exists if xdebug is used, so if it isn't enabled there should not be a problem in the first place.\nThe traverser could be rewritten to use a stack, but for other things like the pretty printer I don't think that's feasible.\n. Merged via https://github.com/nikic/PHP-Parser/commit/40455b5c180ec3494197c72f2fd6cc28a14225fc. Also switched to containers and added nightly in https://github.com/nikic/PHP-Parser/commit/5118e21c6e43cce95369561ca078980617cd639e.\n. Switched to the PSR-4 autoloader in https://github.com/nikic/PHP-Parser/commit/e3a93561780f750489aa3a1cf99d23dcfa44520f. We may need to switch back to a custom one later if there's going to be aliases again, but I guess it's better to use the generated one for now.\n. Phpunit dep in composer is now present as well: https://github.com/nikic/PHP-Parser/commit/6f3fd7834a60e176d7734b786cfd1df6b764ed5e\n. Agree with @GrahamCampbell, coverage shouldn't be on by default. It would be nice to get travis to send coverage to scrutinizer for some version (5.6 makes most sense probably?)\n. @tleb I guess the idea here is to tell the parser to generate MyVariable objects instead of normal Variable objects for $var nodes (and similarly allow changing the object type for all other nodes as well).\nI haven't tried yet, but I suspect that doing this will adversely affect performance. The current alternative is to translate normal nodes to custom ones in a visitor -- is there any problem with doing that?\n. This rename should not be necessary, as underscores have no meaning under PSR-4.\nAs to using PSR-2 -- depends on how big the diff to the current codebase would be. If it isn't too large, lets do it.\n. I won't be changing class names to remove the underscore.\n. The project is on scrutinizer under https://scrutinizer-ci.com/g/nikic/PHP-Parser but I couldn't figure out how to add a GH service hook.\n. I've removed/added the project and now the hook is there, so should be possible to test configs now.\n. I've decided to not use Scrutinizer. It spews up a lot of notices but only very little is of interest to me (out of a couple dozen messages I looked at two were genuinely useful). I've set up coveralls for the test coverage, as that was the most interesting part of Scrutinizer.\n. I realize nightly is still on 7.0 now, but it should be switched over sometime soon, right? Is there a problem with keeping it in the list?\n. https://github.com/travis-ci/php-src-builder/commit/17395d3214936af2ac92ccecc806e99b8863c332 has been reverted by https://github.com/travis-ci/php-src-builder/commit/b147483b691cfcfe6c25ab8d297b46e043a2a04c a couple of days ago, so nightly now points to PHP 7.1 :)\n. Verified for Unix-style newlines. It looks like I fell for the PCRE $ newline trap...\n. Fixed with https://github.com/nikic/PHP-Parser/commit/950ada4cbaed40cab7ff90a45aac5682298e22ea. Thanks for catching this!\n. Also tagged v1.4.1 for this change: https://github.com/nikic/PHP-Parser/releases/tag/v1.4.1\n. We could add an option for short array syntax in particular, but something like \\Namespace\\Foo needs to be rewritten in the AST. It's not just a formatting change and the code is not semantically equivalent.\n. An option for the short array syntax is now available: https://github.com/nikic/PHP-Parser/commit/39a039fa4257d3b9209de36cc54f5d3f5d6253f5\nphp\n$pp = new PrettyPrinter\\Standard(['shortArraySyntax' => true]);\n. Heh, it looks like Scrutinizer doesn't support reopen to run another inspection :/\nI'm wondering whether using Scrutinizer is really worthwhile or we should instead use coveralls for the coverage (which is the only part of Scrutinizer I really care about).\n. Closing per #225.\n. This one is still in use. Should maybe rename it to something other than test_old...\n. There is experimental support for error recovery: https://github.com/nikic/PHP-Parser/blob/master/doc/component/Error.markdown#error-recovery\nIt's pretty limited though, probably not suitable for autocomplete. It could be extended further though.\n. Thanks for the tests! That brings pretty printer coverage to 91% :)\n. Can you provide the full parsing code you're using? I just ran bin/php-parse test.php on the code you provided. The output for the last two array elements is:\n4: Expr_ArrayItem(\n    key: Scalar_String(\n        value: bn =>\n    )\n    value: Expr_ConstFetch(\n        name: Name(\n            parts: array(\n                0: null\n            )\n        )\n    )\n    byRef: false\n)\n5: Expr_ArrayItem(\n    key: Scalar_String(\n        value: bn =>\n    )\n    value: Scalar_String(\n        value: null\n    )\n    byRef: false\n)\nWhere there is a clear difference between the null constant and the 'null' string. Similarly the keys are represented as either String or LNumber. So this is probably something specific to the invocation you're using.\n. Same question here as in #148 and #196: Why add a scope string as an attribute to nodes? Apart from debugging, I'm not sure I see why one would be interested in having a scope string in an arbitrary format.\nTo expand on what was said in the other issues/PRs, here is the usage that I had in mind:\n``` php\nclass ScopeResolver {\n    // Just an example API\n    public function getNamespace() : ?Stmt\\Namespace_;\n    public function getClass() : ?Stmt\\ClassLike;\n    public function getMethod() : ?Stmt\\ClassMethod;\n    public function getFunction() : ?Stmt\\Function_;\n    //??? public function getFunctionLike() : ?Stmt\\FunctionLike;\n    public function getScopeString() : string;\n// Maybe also getClassName() etc? Dunno.\n\n}\n$traverser = new NodeTraverser;\n$scopeResolver = new ScopeResolver;\n$traverser->addVisitor(new NameResolver);\n$traverser->addVisistor($scopeResolver);\n$traverser->addVisitor(new MyVisitor($scopeResolver));\n$traverser->addVisitor(new MyOtherVisitor($scopeResolver));\n// Where for example (resolving magic consts)\nclass MyVisitor extends NodeVisitorAbstract {\n    private $context;\n    public function __construct(ScopeResolver $context) {\n        $this->context = $context;\n    }\npublic function leaveNode(Node $node) {\n    if ($node instanceof MagicConst\\Class_) {\n        $class = $this->context->getClass();\n        return new Scalar\\String_($class ? $class->namespacedName : '');\n    } else if ($node instanceof MagicConst\\Namespace_) {\n        $ns = $this->context->getNamespace();\n        return new Scalar\\String_($ns ? $ns->toString() : '');\n    }\n    /* resolve other magic consts */\n}\n\n}\n// Or (adding the scope string as an attribute)\nclass MyOtherVisitor extends NodeVisitorAbstract {\n    private $context;\n    public function __construct(ScopeResolver $context) {\n        $this->context = $context;\n    }\n    public function enterNode(Node $node) {\n        $node->setAttribute('scope', $this->context->getScopeString());\n    }\n}\n```\nBasically the idea is to provide the context information in a way where you can access the individual parts of the context separately and completely (e.g. you could get not only the name of the function, but also check whether you're currently in a function that returns by reference etc.)\nDoes that make sense?\n. > Sure, but all you're doing is wrapping the string format into a class and giving that instead. I could write a parser for the format I've described (which would be easy) and it would be the exact same result.\nParsing the format to extract information from it doesn't make a lot of sense: If I want to know the current class in a visitor, it would be simpler to just reimplement the state management than to try parsing this scope string. Even if you do that, it only gives you back a class name, not the AST node of the class.\nI think I am currently misunderstanding what this is about. I assumed it's for providing additional commonly needed context to visitors, so you don't have to store the current class, current method etc in every visitor.\nFrom your description this seems to be about something else, you're looking for unique scope keys to use in a dictionary. I'm not sure I completely get the idea behind that, but in any case these keys are not unique for two reasons: Firstly, there can be multiple closures at one scope level, which would collide. Secondly, if you account for conditional definitions it's possible to have two classes/functions/etc in one file with the same name.\n. The idea here is to distinguish between ; (null) and {} (empty array). It applies not only to interface methods but also to abstract methods. This e.g. allows the pretty printer to emit valid code without managing state about whether it's currently in an interface or not.\nWe could change this to use an empty array and have a flag to signify that it's a body-less method, maybe.\n. I'll be leaving this as-is -- I think it makes pretty little difference whether we use null to signal no body or have a separate property for it, and changing it at this point will necessarily break downstream code.\n. Generally we do not know whether an unqualified constant fetch in a namespace refers to the constant in the namespace or to a global constant. As such they are not resolved by the NameResolver. If you want to do additional resolution based on your specific knowledge of which constants exist or not, you should resolve them manually.\n. The resolved name could be added as an attribute -- would avoid the need for an option. For now I'd suggest manually keeping track of the current namespace and using Name::concat().\n. https://github.com/nikic/PHP-Parser/commit/90834bff8eaf7b7f893253f312e73d8f532341ca Does this suit you? Note that the attribute is on the name itself, not the FuncCall/ConstFetch node.\n. Btw, don't forget that some symbols in PHP are case-insensitive. In particular class and function names always are, so you should lowercase these when inserting them into the definition table. Constants are more complicated, because they exist in both case-sensitive and case-insensitive variants.\n. Unless the mechanism is changed entirely (#312) I won't use dynamic object properties (the namespacedName property predates the introduction of attributes).\n. @felixfbecker Yeah, I expect another beta sometime soon.\n. \"Sometime soon\" turned out to be two weeks, but here we go: https://github.com/nikic/PHP-Parser/releases/tag/v3.0.0beta2\n. Hm, this looks tricky. I can't think of any way to do this that will robustly work.\nAs 2.0 hasn't been released yet, it would be possible to introduce a proper node for string parts of encapsed strings. Could either reuse Scalar_String or have something separate (as it's not really a full string).\n. If you want to keep using simple strings, but don't perform parsing of strings you can simply drop all the parseEncapsed calls from the grammar.\nIf you want to convert to String nodes, I'd do something like this:\n```\nencaps_str:\n      T_ENCAPSED_AND_WHITESPACE { $$ = Scalar\\String_[$1]; }\n;\nencaps_list:\n      encaps_list encaps_var                { push($1, $2); }\n    | encaps_list encaps_str                { push($1, $2); }\n    | encaps_var                            { init($1); }\n    | encaps_str encaps_var                 { init($1, $2); }\n;\n```\nAnother way that might work is to enable file positions in the lexer and then determining the original string content based on the file offsets of the adjacent interpolated vars and the file offsets of the whole strings. That should work without changing the parser.\n. @bpicolo Yeah, I know. Which is why I'm suggesting to use the positions of the adjacent real nodes.  So something similar to this (not tested):\nphp\n// Get original string of $encapsed->parts[$index]\nfunction getOriginalString($code, $encapsed, $index) {\n    if ($index > 0) {\n        $startOffset = $encapsed->parts[$index - 1]->getAttribute('endFileOffset');\n    } else {\n        // Here I'm assuming a \"foo\" style string. Heredoc and b\"\" would need extra handling\n        $startOffset = $encapsed->getAttribute('startOffset') + 1;\n    }\n    if ($index < count($encapsed)->parts) - 1) {\n        $endOffset = $encapsed->parts[$index + 1]->getAttribute('startFileOffset');\n    } else {\n        // Again assuming \"foo\" string\n        $endOffset = $encapsed->getAttribute('endOffset') - 1;\n    }\n    return substr($code, $startOffset, $endOffset - $startOffset);\n}\n. I've introduced a Scalar\\EncapsedStringPart node to represent string parts of encapsed strings and backtick expressions: https://github.com/nikic/PHP-Parser/commit/a9074c7444ebe4a907d331c5c0b7c2ba77a6fef2\nNow it should be possible to handle this using the \"usual\" method :)\n. @sekjun9878 It would create a cyclic graph, which by itself is not a problem (it will only degrade performance due to increased GC pressure).\nIf you need parent references, it should be relatively easy to construct them using a visitor. Something along these lines:\nphp\nclass ParentConnector extends NodeVisitorAbstract {\n    private $stack;\n    public function beginTraverse(array $nodes) {\n        $this->stack = [];\n    }\n    public function enterNode(Node $node) {\n        if (!empty($this->stack)) {\n            $node->setAttribute('parent', $this->stack[count($this->stack)-1]);\n        }\n        $this->stack[] = $node;\n    }\n    public function leaveNode(Node $node) {\n        array_pop($this->stack);\n    }\n}\n. I think these are the possibilities:\n$a = $b; // Assignment to Variable\n$a->b = $c; // Assignment to PropFetch\n$a['b'] = $c; // Assignment to DimFetch\n$a::$b = $c; // Assignment to StaticPropFetch\n. @sekjun9878 I'll be leaving the type hint here as is, listing all the possibilities makes it overly specific. The parser can actually produce more than just these (and the one @jesseschalken mentioned), e.g. something like func() = $x is okay as far as the parser is concerned (even though it's not valid PHP). Doesn't make a lot of sense to me to specify a 10-adic union type here.\n. I can't reproduce this. Using the following code:\nphp\n$parser = new PhpParser\\Parser(new PhpParser\\Lexer);\n$stmts = $parser->parse('<?php ');\n$prettyPrinter = new PhpParser\\PrettyPrinter\\Standard();\nvar_dump($prettyPrinter->prettyPrint($stmts));\nvar_dump($prettyPrinter->prettyPrintFile($stmts));\nI get:\n```\nstring(0) \"\"\nstring(7) \"<?php\n\"\n```\nIf the string is just '<?php' I get a parse error -- but that's in accordance with how PHP behaves.\n. Yep, those are leftovers from an older implementation using magic properties. Thanks!\n. I'm not a big fan of passing $nl through 300 methods. The other way of getting rid of the noIndentToken is to assemble the code left-to-right rather than inside-out. I.e. have a property holding the current code to which is appended and another property holding the current indentation. I don't know if that's better than what is currently done or not.\n. The $this->nl variant is now implemented in master with https://github.com/nikic/PHP-Parser/commit/61e624bc9d5eee1ba7a5a8e027a3d952297b20fc.. Thanks for the report, this should be fixed by https://github.com/nikic/PHP-Parser/commit/c4bbc8e236a1f21b2b17cfbf3d46aa6ece69b9f7.\n. Thanks!\n. For reference, here's the docs for the existing error recovery support: https://github.com/nikic/PHP-Parser/blob/master/doc/component/Error.markdown#error-recovery\nAs you already said yourself, creating a parser with error recovery sufficiently good for use in IDEs is hard. I'm generally open to improving the error recovery support (either by placing more error tokens or by using a smarter recovery algorithm, e.g. something that tries to insert expected but missing tokens), but I won't be working on this myself. It's not a primary target for this library.\nI don't think there's any easy way of creating a \"partial parsing mode\" -- the intermediary state of the parser is a stack of AST nodes without any clear relation to each other, there is no obvious way to assemble them into a coherent result.\n. Per the previous comment, I don't think anything is going to happen in this direction, so closing this issue.\n. It looks like Oauth is no longer necessary as GitHub dropped the rate limit: https://github.com/composer/composer/issues/4884#issuecomment-195229989 Though there's a report further down that the issue still exists...\n. Finally merged as https://github.com/nikic/PHP-Parser/commit/e7ca4b7b04e1e10e37e2e411fc8c47a5bb6c9bae :) However it does not seem like prefer-dist is working out: https://travis-ci.org/nikic/PHP-Parser/jobs/116168686#L150\n. @theofidry Yep, everything works fine after triggering a new build. Thanks for the pointer!\n. You're probably using a very old version of psysh. Can you try updating it?\n. It's by design. The output of toString() is not intended to be used in generated code (the pretty printer will produce the correct results for that purpose), but rather for things like checking it against specific classes / maintaining symbol tables etc., in which case the canonical name (which does not have a \\ prefix) is typically more useful.\n. I should probably do a release for this.\n. Fixed in https://github.com/nikic/PHP-Parser/commit/9829bf69cd4faee9c2622fb099cc2a544fa74f1e. Thanks!\n. Looks reasonable, merged :)\n. I don't think there was a specific reason why it was omitted. Do you need a proper node for something in particular, or is this only a consistency concern?\n. Thanks the explanation. I think adding an explicit Finally_ node would be good, but this is running into the usual problem that changing the AST format will break backwards compatibility, so we can't really do it until the next major version (and it doesn't look like there will be need for one soon).\nFor your particular case, maybe just scanning backwards for the finally token from the startFilePos will be \"good enough\" for now?\n. Implemented via https://github.com/nikic/PHP-Parser/commit/5f97b125762c34ffd3478a6dbcf635cf347a3809 :)\n. This is now implemented with https://github.com/nikic/PHP-Parser/commit/e7869b9f1457e4756649bd40d7d5ce67883b7f9b.\nNote that generally speaking, PHP-Parser does not makes sure that code is actually valid PHP code, it only ensures that it is syntactically valid and does only a few checks on top of that. I'm including this particular error because it's lexical in nature and it's not possible to detect it from the generated AST.\n. This definitely sounds like a good idea. Two things to consider:\n- There is some existing serialization infrastructure, which is currently only used for XML. JSON serialization could be implemented there, which would have the advantage of also supporting unserialization. However JsonSerializable is likely more convenient to use.\n- There are a number of things that JSON, unfortunately, does not support. In particular this includes non-UTF8 strings, as well as floating point Inf. Both of these can be part of the syntax tree during a normal parse. Should there be some attempt to support these (how?) or do we just say that this is \"best effort\"?\n. JsonSerializable on NodeAbstract and Comment implemented in https://github.com/nikic/PHP-Parser/commit/7dae6c7a6bde4a1447cffd7f3d0833e3a0c24ce8 (sample output in tests).\nOther issues can be resolved separately should they prove to be a problem.\n. @asgrim It's supported as a class Name, but it should now probably be represented as string 'void' instead (like all the scalar types etc)\n. Possible actions:\n- void: Only needs addition to https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/ParserAbstract.php#L484. Mild BC break.\n- iterable: Same.\n- Class constant visibility: Extra property on Stmt\\ClassConst. Requires changing the constructor, thus  BC break.\n- [] destructuring: Allow null items in array item lists, like it is done for list(). No BC break.\n- list() keys: Introduce ListItem and either use it always (BC break) or only if a key is specified (inhomogeneous). Alternatively: Represent list() as array with extra attribute, as these are now interchangeable. Or at least reuse ArrayItem instead of having a separate ListItem.\n- Multi catch: Either replace type with types array (BC break) or make it inhomogenous using a single class or an array.\n- Nullable types: Add a Nullable node. No BC break.\n. I don't think it'll be possible to fully keep BC, so I'm targeting a new major version.\n. The way to do something like this right now is to use a custom lexer, see the instructions at https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown#attribute-handling. The example there is approximately what you need. It will add the originalValue attribute to non-interpolated single/double quoted strings and you can check which is which by checking the first character. You can do something similar by looking for T_START_HEREDOC instead of T_CONSTANT_ENCAPSED_STRING and then seeing if that it's a heredoc or a nowdoc start sequence.\nI do plan to add this information directly to the node attributes (I've recently added info to distinguish number literal radixes and a few other things), but that may not happen right away, so this is the workaround I'd use.\n. Implemented: https://github.com/nikic/PHP-Parser/commit/588e6a4d4c69bf00d14ff42ddfd69507f73a4e10\n. It should be possible to implement this (not in a generic way, but handling specific cases like this one). However I'm not sure if it's worth the effort. I would generally recommend against using this library for implementing editor auto-complete (or rather, only use it for the analysis part) and detect this based on tokens instead. The current error recovery is more aimed at \"be able to analyze other methods in this file while it's being modified\" rather than \"be able to analyze the currently modified expression\". Editor-quality error recovery is a pretty hard nut and probably not in scope for this project.\n. I've just pushed a small improvement to error recovery in https://github.com/nikic/PHP-Parser/commit/96cbd48df6d1c6dae38ab2437bee71508947d5c8. This should handle the case of statements without a trailing semicolon, but will not handle the case of $foo-> (and no following label). One interesting issue with that case is\nphp\n$foo-> // cursor here\n$bar->foo();\nthis will parse as valid PHP $foo->$bar->foo(), even though it's likely not what was intended.\nIf you want to work on better error recovery, this is done by sprinking additional error rules in the grammar. Currently we have only two such rules in https://github.com/nikic/PHP-Parser/blob/master/grammar/php7.y#L182, which mean that we can handle an expression followed by an error at some point, or just an error altogether (without preceding expression).\nFor example, to support $foo-> what one would have to do is add an | error rule to property_name in https://github.com/nikic/PHP-Parser/blob/master/grammar/php7.y#L781. This rule could be | error { $$ = null; } for a null property name (as you suggest). Alternatively (and I would recommend this as \"null\" is not acceptable everywhere due to type hints) one could introduce an Expr\\Error node, in which case the rule should be | error { $$ = Expr\\Error[]; }.\nAfter modifying the grammar, you'll have to rebuild the parser, see https://github.com/nikic/PHP-Parser/tree/master/grammar#building-the-parser. (If you're on Windows, I can send you a kmyacc build.)\nError recovery tests are here: https://github.com/nikic/PHP-Parser/blob/master/test/code/parser/errorHandling/recovery.test It may be convenient to test only the php7 parser, this can be done by putting a !!php7 at the top of the expected output.\n. Added support for recovering from -> errors in https://github.com/nikic/PHP-Parser/commit/09086fbe0ae367015d224644ded240bf5a9badc3 and https://github.com/nikic/PHP-Parser/commit/977cbab8e73d69d32cf7a62c91ab932e9d778287. I'll consider this issue as resolved, for now.\n. It is now: https://github.com/nikic/PHP-Parser/commit/15a2388d75ecf882ae6fb59f385e6e5bed9ae651\nNot adding end line / end file pos (at least for now) as those are easily computable and would blow up the ctor.\n. Thanks!\n. Merged as https://github.com/nikic/PHP-Parser/commit/e7f0860d85ba80c8e858278393cd0b0b67941276 with some further tweaks. Thanks!\n. Escaping \\ is not unnecessary if you consider something like '\\\\\\''. This parses to string contents \\', and printing it as '\\\\'' would not be correct. This is the cause of the build failure @ https://travis-ci.org/nikic/PHP-Parser/jobs/122780318.\n. Escaping \\0 sounds like a good idea. However we should probably escape the entire \\0-\\37 control character range (excluding the existing \\n\\r\\t\\f\\v) and not just \\0.\n. Merged as https://github.com/nikic/PHP-Parser/commit/371c78334473dd80b6376e0f81faabecb97e4510, extended to the whole control character range.\n. Assuming you want to remove a property with a certain name, you could use a node visitor looking something like this:\n``` php\nuse PhpParser;\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Stmt;\nclass Visitor extends PhpParser\\NodeVisitorAbstract {\n    public function leaveNode(Node $node) {\n        if ($node instanceof Stmt\\Property) {\n            if (count($node->props) === 1) {\n                if ($node->props[0]->name === 'bar') {\n                    return false; // remove node\n                }\n            } else {\n                foreach ($node->props as $i => $prop) {\n                    if ($prop->name === 'bar') {\n                        unset($node->props[$i]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n```\nThe code is so complex because it tries to cover both the case of public $bar (in which case the whole property is dropped) and public $foo, $bar (in which case only one element of the property is dropped).\n. The example from the node traverser docs should probably help: https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#node-traversation\nIt shows how to wire together the different components. You just need to use a different visitor there.\n. Merged as https://github.com/nikic/PHP-Parser/commit/d1dd9f5aecbb3fa95b7a1f007572dc980a90a4e6 with an output tweak in https://github.com/nikic/PHP-Parser/commit/82bb6627c9b804e1d40d29fc9ec97a39165f0e8e. Thanks!\n. Released v2.1.0: https://github.com/nikic/PHP-Parser/releases/tag/v2.1.0\nThere won't be a v2.0.2.\n. Fixed by https://github.com/nikic/PHP-Parser/commit/e45e31c218dc224f20155b932e309438fe2eeeb2. Whether the test ran depended on filesystem iteration order, so you saw a failure, while I didn't. Now both the test and the test runner should be correct :)\n. For case (2), is there any problem implementing this in a visitor rather than the traverser itself?\n. If you need to preserve formatting this library is generally a bad pick. For your particular case you might be able to extend the pretty printer and override the formatting of arrays using something like this (untested):\nphp\npublic function pExpr_Array(Expr\\Array_ $node) {\n    if (empty($node->items)) {\n        return '[]';\n    }    \n    $result = \"[\";\n    foreach ($node->items as $item) {\n        $comments = $item->getAttribute('comments', []);\n        if ($comments) {\n            $result .= \"\\n\" . $this->pComments($comments);\n        } \n        $result .= \"\\n\" . $this->p($item) . \",\";\n    }\n    return $result . \"\\n]\";\n}\nThis will add comments and print array elements on separate lines.\n. Keeping indentation and blank lines of the original file is, at least currently, not possible. At least there are no easy ways to do it. Formatting preserving transformations using this library are typically done by using the AST only for analysis and location information, and then doing the actual changes directly on the code :/\n. Scheduling this for 3.0. In the future traits might also support implements/extends, so this will have better forward-compat as well :)\n. Changed in 3.0: https://github.com/nikic/PHP-Parser/commit/867ae5148d975821a361d2ad5058bb8207b7c96a\n. I use the node dumper method to check if ASTs are equal. Likely not the most efficient way, but at least the simplest :)\n(It would be nice to have an AST-based differ to visualize what the differences are ... but I don't think that's quite as easy to implement.)\n. The parser itself can set a couple of attributes related to formatting (primarily of literals). so this depends on whether you want to consider  AST(\"foo\") and AST('foo') to be equal (this is what the comparison of the dumps would give you) or not (this is what your suggested approach would do).\nApart from that, it sounds like that approach should work.\n. foreach ($array as $foo->key => $foo->value) {} is legal, so keyVar and valueVar are not necessarily simple variables, but may be any variable expression.\n. Sorry, I don't think this is possible. We can't perform a partial parse of the file only -- the best that can be done here is avoid the AST instantiation, though I don't see how this could be done cheaply.\n. Should be possible and I'd love to see this :) I don't think I have the time right now to implement this myself.\n. Nice work! For validation I would recommend looping over all php-src phpt tests and comparing the parser output. The test suite in this extension is rather incomplete, as it mainly tests the parts that are rewritten in some way.. I'm closing this issue as php-parser-to-php-ast now exists and seems to be mostly finished :). The additional newlines are stripped by PHP -- they will not be part of the output. This is only a question of formatting.\nWe can add an attribute to InlineHTML that tracks whether or not there was a leading newline in the original code and then reproduce it that way in the pretty printer.\n. Though from a quick look, adding this attribute is not as simple as it might be, as the newline is part of the T_CLOSE_TAG, which is no longer available when the InlineHTML is parsed, as it has been reduced as a statement terminator previously.\n. https://github.com/nikic/PHP-Parser/commit/ec614c95dd5fb840be165e4abde0d66c58299b09 adds a new attribute for InlineHTML that specifies whether a newline should/shouldn't be included. This should ensure proper formatting for both cases.\n. Resolved via https://github.com/nikic/PHP-Parser/commit/ec614c95dd5fb840be165e4abde0d66c58299b09, which will print the newline depending on whether the original code had it.\n. It's a very common request, but this library currently does not support format-preserving code changes. I usually solve this with the approach described in https://github.com/nikic/PHP-Parser/issues/41#issuecomment-168498487, i.e. enable file offsets in the lexer, then use the AST to find the places I need to modify, but actually do the changes directly on the code, using the file offsets in the AST nodes. As you only need to do relatively high-level changes (rather than expression-level modifications), it may well be easier for you to skip the AST entirely and work on the tokens.\n. There is no generic way to create an AST from the lemon grammar, you'll have to do some manual conversion for the AST construction at least. If you want to use kmyacc (as this project does) you will need to translate the grammar into yacc/bison format. It looks like there is also a lemon parser generator for PHP, but I have no idea how usable it is.\n. Do you have a reproduce code for this issue?\n. Ping?\n. Yes, ideally it shouldn't be an Expr. Under what circumstances do you end up directly printing a EncapsedStringPart?. The problem with printing an EncapsedStringPart is that it needs to know the quotation context to perform correct escaping. I could of course print something that is not strictly correct (say just return the string without escaping). Alternatively I could also explicitly throw an exception to indicate that it's not supported (like in https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinter/Standard.php#L508).. I've opened #500 to track the Expr classification issue.\nThe quotation type could theoretically be added to EncapsedStringPart's attributes, but I don't think it's a good solution. The quotation type is already fully determined by the parent structure, so this would just add a piece of duplicated state that can go out of sync with the parent (e.g. if an EncapsedStringPart is moved or duplicated).. Explicit exception added in https://github.com/nikic/PHP-Parser/commit/6526ea24974dfc83e620f8abdec22050736d7ebb.. Support for class constant visibility added in https://github.com/nikic/PHP-Parser/commit/5ea2a76d8070db1ed33e88322608e51290601931. Structure potentially not final due to #288.\n. Tracking bug for PHP 7.1 features: https://github.com/nikic/PHP-Parser/issues/260\nI will be working on this soon (next week?), just gotta finish a thesis first.\n. Support for nullable types added with https://github.com/nikic/PHP-Parser/commit/1edf72c0403c451ba9053d2b0ec7c624e16a7645.\n. Return is a statement, not an expression: https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Stmt/Return_.php\n. Implemented via https://github.com/nikic/PHP-Parser/commit/18129480aecc47fdd822ec480404ae5c7ee160ac.\n. This is what the name resolver is for, see https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#the-nameresolver-node-visitor.\nThe class/trait will have a namespacedName node after it has run, which contains the fully qualified name.\n. PHP-Parser uses PHP's own tokenizer for lexing, so if you want to support short tags, you should enable the short_open_tag ini option. Otherwise short tags will just be treated as normal text.\n. What version of php-parser do you use and what is the context?\n. You should be able to see the version in your composer.lock file. Not sure where this is coming from ... can you check if running composer dump-autoload fixes the issue?\n. Issue #294 looks similar to this. If this problem isn't resolved yet, it looks like just dropping the nikic/php-parser directory in vendor/ and running composer again should fix it.\n. Thanks, the file name changed and README wasn't update.\n. Second issue fixed in https://github.com/nikic/PHP-Parser/commit/83f34e7fa4975e9646e118b61226e17cebc5db14 -- the first comment should now be preserved on the assignment node.\n. First issue fixed by https://github.com/nikic/PHP-Parser/commit/08215e764671a52e8d20fcfc122189648a76c5fa as part of #469.. As the issue seems to have resolved itself, closing here.\n. =& new forbidden in PHP 7 mode via https://github.com/nikic/PHP-Parser/commit/13f7321defed66dbb3da9dba4aef6fed69e6d633.\n. @TomasVotruba PHP-Yacc is for generating parsers, I think this issue is more about generation of PHP code, though I'm not sure what exactly is being suggested.\nThis library used to have support for templates, see https://github.com/nikic/PHP-Parser/blob/0.9/doc/4_Code_generation.markdown#templates. However, this was dropped in version 1.0 as the functionality was pretty limited and I don't think anyone was using it at the time.. bin/php-parse \"<?php \\$countries = \\$this->country ?: ['\nUS'] + array_keys(\\CountryState::getCountries());\" works fine here. I also don't see anything special about that code that could be causing this issue.\n. Would it be possible to provide a complete file that exhibits this issue?\n. True and false are ordinary constants in PHP, so they're represented using something like new Expr\\ConstFetch(new Name('true')).\n. Good point. Also missing iterable.\n. Support for void, iterable and nullables added in https://github.com/nikic/PHP-Parser/commit/1ab24d26eeb444303e99f772710e224f0b357ff7.\n. Sounds sensible.\n- If last comment is doc comment replace it\n- Otherwise append the new doc comment\n- Maybe: If argument is null and last comment is doc comment remove it\n. Peculiarly, there used to be a setDocComment method: https://github.com/nikic/PHP-Parser/commit/a824a2aba7c39254ad98f2960af6ca121349814c It was removed while migrating to a more general comments mechanism.\n. setDocComment() added in https://github.com/nikic/PHP-Parser/commit/ea47b6e0d643b91d55167e7a212b22986406f217, for now without ability to pass null.\n. See #178. The gitattributes affect more than just composer. In particular downstream distributors do use the tests contained in the tarball.\n. The pretty printer does not preserve code formatting. In your case the difference is just those newlines, because your coding style happens to match what the pretty printer uses by default. (Though there are some things that probably should be changed, like leaving a blank line after use and between methods etc.)\n. As a workaround, you could try extending pStmts by keeping track of the ending line of the previous statement and comparing that to the start line of the current statement (or the first comment on the current statement, if it has one) and adding the difference in extra newlines. That will probably give a pretty good approximation, though there's probably some edge cases.\n. Closing this as a duplicate of #41. Per the last comments on that issue, there has recently some movement towards proper support for preserving formatting, so there's hope this will be possible soon :). Implemented by (mostly) https://github.com/nikic/PHP-Parser/commit/c79ea6d1d3f1caa75e304226faa919a9ca866c01. I've completely rewritten the lexer error handling, so that lexer errors now have precise offset information, there can be multiple lexer errors and we can continue parsing in the presence of lexer errors.\n. I don't see how this could happen. Version 2.0 uses the composer psr-4 autoloader, so there is none of the fragile class_alias magic of previous versions involved here.\nCan you check if the file for this class actually exists in your vendor directory?\n. Okay, there's a number of files missing in that directory (String_, LNumber, DNumber). Probably this is just a borked checkout. I'd suggest deleting your vendor/ directory and running composer again and see if this fixes the issue.\n. I'd like to have a more general solution to this than adding a throwOnError option and a getErrors() method everywhere. I was considering the addition of an ErrorHandler interface with variants ErrorHandler\\Throwing and ErrorHandler\\Collecting, which can be passed to parser/lexer/name resolver/etc. The mainly problem I ran into is how this interacts with the Parser\\Multiple -- in that case I wouldn't want the errors from multiple attempted parse runs to be collected. I'm not yet entirely sure how to best approach this.\n. Here is what I had in mind: https://github.com/nikic/PHP-Parser/compare/errorHandler\nI resolved the Parser\\Multiple issue by defining a \"successful\" parse as anything that doesn't throw (i.e. effectively dropping any multiple parser tries in error recovery mode).\nThe usage would be something like this:\n``` php\n// Setup\n$errorHandler = new ErrorHandler\\Collecting;\n$parser = (new ParserFactory)->create(\n    ParserFactory::ONLY_PHP7, $lexer, ['errorHandler' => $errorHandler]);\n$traverser = new NodeTraverser;\n$traverser->addVisitor(\n    new NodeVisitor\\NameResolver(['errorHandler' => $errorHandler]));\n// Per-file\n$errorHandler->clearErrors();\n$stmts = $parser->parse($code);\n$stmts = $traverser->traverse($stmts);\nif ($errorHandler->hasErrors()) {\n    registerErrors($errorHandler->getErrors());\n}\n```\nSomething I'm not quite sure about with this is that the user is responsible for clearing the errors if the ErrorHandler is reused (which it should be). The idea behind this is that this allows (as in the above example) to collect errors from a number of different operations, for example both parsing and name resolution. An alternative would be to add a resetErrors() method to the interface which is automatically called, e.g. when parsing starts / name resolution starts.  However that would prevent this kind of use.\n. > getErrors() is also very problematic with async programming. In the language server we use an event loop and if two events parse a file, and later try to get their errors, they could be overridden.\nYou're considering the case where you yield control between calling parse() and calling getErrors(), right?\n\nActually though, I think an even better pattern would be to pass an individual error handler to every call of traverse() or parse(). That is kind of in line how PSR-log interfaces work and allows you to share a parser object without sharing error state. You also don't need to \"reset\" the error handler then, you just create a new one for a new operation.\n\nGood point, I agree that this would be a better approach for the parser. However, I'm not sure how this would integrate in the NameResolver case, which is only invoked through the traverser. This would require making the traverser itself be aware of error handling and either pass the error handling along in individual calls or for example in beginTraverse. Not sure if the traverser should be coupled to error handling in this way.\n\nDoes that mean you cannot fallback to PHP5 with error recovery mode?\n\nYes (though I'd prefer keeping this somehow). PHP7 is a syntactic superset of PHP5 with two exceptions: $foo =& new Bar; and global $$foo->bar, only the former of which may be encountered in the wild. Both of these would be (recoverable) errors in PHP7. Everything else are only differences in interpretation.\nError recovery and parser fallback sometimes interact weirdly. E.g. if you parse $n = 08; (invalid octal) in the PHP7 parser this would generate a (since recently recoverable) error. This would trigger a fallback to PHP5 which would generate the same parse tree, but drop this error.\n. > We definitely need to support PHP 5, but I guess it's okay like you explained.\nTo be clear, it's still possible to replicate the exact previous behavior using code along these lines:\n``` php\n$lexer = ...;\n$parser7 = new Parser\\Php7($lexer);\n$parser5 = new Parser\\Php5($lexer);\n$errors7 = new ErrorHandler\\Collecting();\n$stmts7 = $parser7->parse($code, $errors7);\nif ($errors7->hasErrors()) {\n    $errors5 = new ErrorHandler\\Collecting();\n    $stmts5 = $parser5->parse($code, $errors5);\n    if (!$errors5->hasErrors()) {\n        // If PHP 7 parse has errors but PHP 5 parse has no errors, use PHP 5 result\n        return [$stmts5, $errors5];\n    }\n}\n// If PHP 7 succeeds or both fail use PHP 7 result\nreturn [$stmts7, $errors7];\n```\nBut it will not be possible to use the Multiple parser to do this, because it no longer has the context to distinguish a failed-but-recovered parse (let alone properly determine the errors).\n. Forgot to link, this is mostly implemented by: https://github.com/nikic/PHP-Parser/commit/f99a96e0a2d48c903877fd9089fc0f222e0b2f65\nThis commit still uses the ctor to set the ErrorHandler in the NameResolver. I'd prefer leaving it at that for now -- I don't think that integrating error handling in the traverser is solving the right problem here. This is a special case of the more general problem of passing per-traversal data to a visitor. This comes up commonly, e.g. in your own project ReferencesAdder and ColumnCalculator would need this if they were reusable. I don't think it makes much sense to add a special mechanism for error handling only, especially if there's just the one visitor that needs it right now.\n. @felixfbecker As said, the error handler is passed in the ctor for the NameResolver. As you're not reusing visitors anyway, you just need to pass ErrorHandler\\Collecting as an extra arg in https://github.com/felixfbecker/php-language-server/blob/master/src/PhpDocument.php#L149.\n. Sounds reasonable. It will probably be STOP_TRAVERSAL, as BREAK can only be used as a constant name as of PHP 7.\n. For the record, the reason why I haven't implemented this yet is that it has a large testing surface area -- this can be returned by both enter and leave, has to early-abort the recursion, but still needs to preserve all modifications that may already have happened. That's ~6 new branches in the traverser.... The last implementation I tried used a mutable internal flag in the traverser which was set when the break value is returned and checked after each recursion. It was pretty ugly. What I'd usually do for a multi-level break is throw an exception, but that does not play well with the mutability of the traversal.. STOP_TRAVERSAL added in https://github.com/nikic/PHP-Parser/commit/58e7881e987c55c957104687ecccf963d1607753.. Fixed with https://github.com/nikic/PHP-Parser/commit/f6eb341b1573a348b941b67ff0a8c7faa53ce9ac. It's a bit of a tricky case because I had to inline the namespace name productions to avoid shift/reduce conflicts.\n. Attributes date back from sometime around the start of this project. At that time nodes extended ArrayObject in property mode and everything on that ArrayObject was considered a subnode. This changed at some point, switching to explicitly declared properties and a getSubNodeNames() method specifying the structure of the node. At this point, I don't think there is anything preventing us from using overloaded properties for attributes. I agree that this is both syntactically more convenient and would allow to at least declare all the standard attributes.\nDo you know whether PhpStorm has some kind of mechanism to extend the properties of a class in a separate declaration? The override method seems to target factories exclusively.\n. Draft implementation: https://github.com/nikic/PHP-Parser/compare/attributes\nNote that this keeps the backing $attributes property and uses __get/__set to handle access, for two reasons: Firstly, we operate on the full array in some places, in particular the initial construction is always from an array (we'd have to create a dynamic property table and copy otherwise). Secondly, this declares intent for IDEs, e.g. PhpStorm downgrades the warning level for access to undefined properties. Of course, it has the disadvantage that there's no performance benefit...\n\nSorry, what do you mean by that? I'm not working with PhpStorm but I imagine something like the example I gave in the OP should work\n\nRight, of course you aren't ^^ I was hoping for some magic to make this work without having to explicitly declare the node to be of a different type.\n. > Could you link where the implementation with native properties would be problematic (\"initial construction\")?\nThe initial construction is https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeAbstract.php#L15. This would require copying all the attributes into the dynamic object properties. If you're considering this from a performance angle, this is expensive for the common case where attributes are not actually used much.\nFrom an implementation perspective another problematic part is https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeAbstract.php#L105. This would need to gather the object properties, while excluding subnodes and declared properties that are not subnodes -- this comes down to using reflection, which I'm not keen on.\n\nAn IDE should be able to read @property with or without __get(). If not that is a problem of the IDE and we certainly should not base performance decisions on this.\n\nThe IDE can read @property, but will (correctly) treat any custom attributes as undefined properties.\nOf course you are right that magic get/set is slow. This certainly does not make sense if the goal is to improve performance -- is it? Is attribute fetching a bottleneck for you?\n. @felixfbecker This happens in generated code. Something like Node\\Const_[$1, $3] in the grammar expands to new Node\\Const_(..., ..., $this->startAttributesStack[...] + $this->endAttributes). The attribute arrays come from the lexer. The generating code is in https://github.com/nikic/PHP-Parser/blob/master/grammar/rebuildParsers.php#L86.\n. Btw, another potential complication with using dynamic properties is that you can no longer have a subnode and attribute with the same name, which is currently supported. (Personally not particularly concerned about that.)\n. What percentage of the time is it though?\n. The issue is the case where slice() currently returns a name represented by an empty array (which would ordinarily be invalid. Representing this using an empty string is not quite the same, because it wouldn't concatenate correctly. I'm considering to either drop this part or represent it using a null value -- this would be consistent with the global namespace being null in namespace declarations. It would also allow writing code like this as just Name::concat($this->namespace, $node->name), as the case where $this->namespace is null would be handled implicitly.\n. Implementation: https://github.com/nikic/PHP-Parser/compare/nameString\nIn the end, not sure if this change is worthwhile, especially considering the BC this might cause.\n. E.g. psysh seems to be working directly on the parts array in a bunch of places: https://github.com/bobthecow/psysh/blob/master/src/Psy/CodeCleaner/NamespaceAwarePass.php#L48\n. Could emulate with __get, but yeah, I'll just leave this for now.\n. To allow this in the future, I am however changing the slice API to use null instead of new Name([]) (https://github.com/nikic/PHP-Parser/commit/fa7357b48398698a7463334488081318d108914a) and marking $parts as deprecated (https://github.com/nikic/PHP-Parser/commit/c0f0edf0441f0ddcff0604407b7600a40993faf2).\n. Good question. I guess a getParts() method would ensure forward compatibility here. Out of interest, where do you iterate over the parts?. To support PHP 7 you need to use the PHP 7 parser, see the first table in https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#parsing. Do you already do this?\n. Looks like this is being resolved in php-assumptions, so closing here.\nBtw, the self-executing anonymous functions are part of the uniform variable syntax RFC. Generator return expressions are something different :)\n. Support for new without class name added in https://github.com/nikic/PHP-Parser/commit/c0630f81693a8fda40cfbd120b614ad1214287c8. new T without semicolon should already work. I've also added support for $ (without following name) in https://github.com/nikic/PHP-Parser/commit/c5cdd5ad73ac20d855b84fa6d0f1f22ebff2e302 -- I'd assume you need this as well?.. Should be fixed by https://github.com/nikic/PHP-Parser/commit/27281e913026eb039237baa6b37fafc9b6819b9b. The position of the Error node should now be the position of the token that caused the error.. Implemented in https://github.com/nikic/PHP-Parser/commit/e52ffc4447e034514339a03b450aab9cd625e37c :). The parser sets the byRef flag on the Arg, based on which you can throw an error.\nCall-time pass-by-reference is supported in PHP 5.2 and 5.3, parsing of which is supported. It would be possible to remove support for this in the PHP 7 parser, but not sure if special-casing it is worthwhile.. The args subnode of the different call nodes are an array of Node\\Arg, which has a byRef subnode. Checking for this error should be as simple as:\nphp\nclass Visitor extends PhpParser\\NodeVisitorAbstract {\n    public function enterNode(PhpParser\\Node $node) {\n        if ($node instanceof PhpParser\\Node\\Arg && $node->byRef) {\n            throw new PhpParser\\Error('Call-time pass-by-reference is no longer supported', $node->getAttributes());\n        }\n    }\n}. The second case is handled as part of https://github.com/nikic/PHP-Parser/commit/62877b5d14e4d2e4b213a9cdb25413b72bb6505a. The fifth case is handled with https://github.com/nikic/PHP-Parser/commit/a8eb2fc67516a641f4699af2e92b1260af10ce10 (as well as any other uses of invalid trailing commas). I did not include an Error node, in part because this particular case is actually going to be valid syntax in PHP 7.2.. Thanks for catching this so quickly! Fixed in https://github.com/nikic/PHP-Parser/commit/3e158a2313581ccedce961b8c73ec34cc1159ce4 and released as v3.0.1.. Preliminary implementation: https://github.com/nikic/PHP-Parser/compare/identifiersAsNodes\nIf the useIdentifierNodes parser option is enabled, the parser will create Identifier nodes for non-namespaced names.\nI'm using a new node type here, because I'd like to keep a distinction between namespaced and non-namespaced names. Many of the methods on Name (like isFullyQualified) simply don't make sense in this context. An alternative to Identifier might be Label, though I'm afraid this might cause confusion with the Label statement.\nI've kept the contents of Name a simple string array. I've also kept Variable->name a simple string. One could argue that this could also use a wrapper, but in this case the actual name has no dedicated token, so we run into some attribute mapping issues.\nOne case that still uses strings are built-in type annotations like foo(array $x). This should probably also use Identifier.. > I agree, good point. What do you think about a NamePart class? Or NameName, like UseUse / PropertyProperty?\nIn most cases it is the complete name though, so something like NamePart does not seem appropriate. I'm also not a big fan of the UseUse names (even though once upon a time I came up with them for some reason), they really should have been something like UseItem or UsePart.\n\nWhat do you think about making the parts array of Name an array of NameParts/Identifiers/NameNames? So that we have distinct offset information for every part of a qualified name.\n\nNot totally sold on this yet, though not sure why... I suspect this may have weird interactions with name creation and modification. E.g. if you run the name resolver, names will have some parts \"located\" in the namespace-declaration (or a use-clause) and some parts \"located\" at the actual location of the name. That seems weird to me, but maybe it's okay. Relatedly, if you do something like Name::concat($n, 'foo') where $n is a name with Identifier parts, what do you get? Will the last part be a simple string, or will it be normalized to an (attribute-less) Identifier? Presumably methods like getFirst() will also return Identifiers instead of plain strings?. I've now changed callable, array etc. types to be represented as Identifiers as well.\nI think that while we're at it, we should also take a look at other cases where we currently represent something as plain strings without a wrapping node. In particular, we have a number of places where variable names are presented as simple strings without a wrapping Variable node. I would propose that if this mode is enabled, we should wrap the following in Variables:\n\nCatch clause variable names. catch (Foo $var)\nParameter names. function foo($var) {}\nStatic variable names. static $foo;\nLexical variable names. function() use ($var)\n\nThe following two syntactically appear as variables, but really aren't. I'm not totally sure how these should be presented. Would it be inappropriate to use Identifier for this?\n\nProperty names (in declarations). public $prop\nStatic variable names (in lookups). self::$prop. > UseUse was confusing for me too. Why do you think is NamePart not a good idea?\n\nBecause in most cases it's not going to be a part of a name. I can see the argument that for class Foo {} the Foo is a name part, because it could meaningfully concatenate it with a namespaced name. However, for something like $foo->bar (the bar part) this is not the case.\n\n\nI've now changed callable, array etc. types to be represented as Identifiers as well.\n\nWhat about self, parent, true, false? Although I'm not sure if I'm a fan of mixing class/namespace referencing names with keywords/types. I have found a bug in my code a couple of times now because I didn't handle those somewhere, and ended up inserting a definition for the literal FQSEN self into the index. Or couldn't infer the type of a boolean variable, because it couldn't find a constant named true in the index.\n\nself and parent are considered (as previously) namespaced Names. true and false are still constant lookups (where the name is again a namespaced Name). This is consistent with how PHP deals with them and in some cases this is important (e.g. on PHP 5 the value of true in a namespace is not necessarily \\true...)\n\nDefinitely! In fact, I actually need these all to do proper go-to-definition. Would you then do an Indentifier for $var, or a Variable for $var, that has the name set to Identifier var? There is no real value in separating the dollar\n\nIn these cases I would use a Variable with the name set to a string, i.e. make it consistent with how variables are referenced normally. We could also use Variable[Identifier[name]] everywhere, but I don't think this is particularly useful and it will also cause issues with attribute assignment (the $var name is a single-token, so it's unclear what token offsets we should assign for the Identifier).\n\nI would say ket's do it in every case where the offset information would be different. If the Identifier node would have the exact same offsets as the PropertyProperty, it doesn't make sense. I assume the Identifier would not include the $?\n\nPropertyProperty can also contain an initializer expression, in which case the Identifier would encompass a smaller range. As to what the Identifier would contain here: It should not include the $ in the string, but I think it would still have to include in the position information, due to the aforementioned issue with the token offset. (Though this does seem somewhat weird -- on the other hand the same happens for Variables.)\n\nYes, that will finally enable differentiating the class part and the variable part. But I guess $prop should just be a Variable node (I know it currently is only for VariableVariables).\n\nMaking this a Variable would require special-casing this in code that, for example, looks for all uses of a variable. It would have to explicitly check whether the Variable is in the property portion of a static property lookup, in which case it's not actually a variable access. Additionally, it would make something like StaticPropertyFetch[Name[...], Variable[...]] mean different things depending on which parsing mode is used (in one case it would be a simple static property reference, in the other it would be an indirect static property reference).. I've pushed a few more changes:\n\nAdded useConsistentVariableNodes option. This will use Variable for catch vars, parameter names, static variable names and use variables. (Both options might be merged, keeping this separate for now.)\nMade property declarations and static property fetches use Identifiers for the property names.\n\nI'm not really happy with point two. I don't want to use Variable here, as these are not variables semantically. I also don't like Identifier, because everywhere else this is a plain identifier, while here it has an implicit $ prefix. I'm thinking that it might be worthwhile to add an extra node kind for this. Something like VarLikeName or VarLikeIdentifier.. Probably time to move forward with this. In combination with #41, which based on the work here implements some major changes to make format-preserving code transformations possible, I will probably just fork version 4.0 now, so I have more freedom in changing the AST without adding options for all the things.. In version 4.0 Identifier nodes are now always used (no longer behind an option), so I'm considering this to be resolved.. Thanks!\nSeeing this type declaration, I'm thinking that PHP-Parser 4 should have some kind of common superclass Type with BuiltinType, ClassLikeType and NullableType as children (or similar).. Sorry for being unclear. What I had in mind is just another elseif case in enterNode: https://github.com/nikic/PHP-Parser/commit/a485ecd7ba007e4d3381471fc46c4721766bcbcc This will handle NullableType wherever it may occur.\nAlso fixed another nullable type issue: https://github.com/nikic/PHP-Parser/commit/5219f7571913f8063de224b231df19ac892645f3\nThanks!. New release tagged: https://github.com/nikic/PHP-Parser/releases/tag/v3.0.2. Testing using ArrayAccess doesn't really tell you how PHP \"originally\" interpreted it, because constant integer string indexes are normalized to integer indexes during compilation, see for example https://3v4l.org/PFZWp (this uses three strings, and yet two of them dump as integers).\nHowever, I do agree that we should be representing this as integers, consistent with how the php ast represents this: http://lxr.php.net/xref/PHP-MASTER/Zend/zend_language_scanner.l#1719. @martinsik \"Alternative syntax\" refers to the $foo{$bar} array access syntax, which was not supported in some places in PHP 5. That's what the comment is about.. Implemented in https://github.com/nikic/PHP-Parser/commit/70319e27eee312091402b075aeb5e192cdd1f5e0.. I'm having second thoughts about this change due to https://github.com/nikic/PHP-Parser/commit/c1e0bab4f8c1b82b4a936c21f2a5fcfaa695fc33. PHP 7.1 adds support for \"$a[-1]\". Interpreting the offset as a number (if possible) causes some unpleasantness in this case.\nParticularly concerning is that the offset might be PHP_INT_MIN. We will interpret it as such in this situation, because the offset is interpreted under symtable numeric string rules (as of https://github.com/php/php-src/commit/2c70581338257cba48991e313309839737c94c64), however outside of this context this would instead be interpreted as -(PHP_INT_MAX + 1), which is a double. Because the pretty printer normalizes from \"$a[-1]\" to \"{$a[-1]}\", the result is no longer semantically equivalent in this case.\nThis would require special handling at some point. If an LNumber has value PHP_INT_MIN I might emit -PHP_INT_MAX - 1 in the pretty printer. I guess this would make sense even independently of this issue, because someone could create a PHP_INT_MIN LNumber manually (even if the parser, prior to this change, would never create one by itself).. I've fixed the pretty-printing issue (along with a couple other things) in https://github.com/nikic/PHP-Parser/commit/58970e2a3704a31c882ce6ebe4a940c52c475c5c. Still not sure whether the string->number conversion here is worthwhile.. Yes, this is an intentional change, it needs to be added to UPGRADING. Previously, unqualified function calls in the global namespace were not resolved, now they are. This is consistent with the behavior for classes, and makes it easy to distinguish whether or not a name requires runtime resolution (without having to manually track the namespace).. Upgrading note added: https://github.com/nikic/PHP-Parser/commit/8a97065e300cd5d5fdc4c3c058ac9feec5c2f48b\nIf this change is causing issues for your use-case (outside of tests), please reopen.. $ /d/php/7.1.0-nts/php bin/php-parse -P \"<?php echo SOME_CONSTANT;\"\n====> Code <?php echo SOME_CONSTANT;\n==> Node dump:\narray(\n    0: Stmt_Echo[1:7 - 1:25](\n        exprs: array(\n            0: Expr_ConstFetch[1:12 - 1:24](\n                name: Name[1:12 - 1:24](\n                    parts: array(\n                        0: SOME_CONSTANT\n                    )\n                )\n            )\n        )\n    )\n)\nThe result looks expected to me. Note that all \"end\" offsets are inclusive offsets, i.e. the point to the last character in the node, not one past the last character (this applies to line numbers, token offsets and file offsets).. Sorry for the delay, now merged as https://github.com/nikic/PHP-Parser/commit/7b441d2142d34fcf499d155caea53f322e737e43. The (Expr|Stmt)[] is no longer necessary in master because expression statements are represented using a Stmt\\Expression node. I've also dropped the attribute poisoning in the parser, so adding a string type on $endAttributes is no longer necessary.\nSome typehints in master are outdated because they don't reflect Identifier nodes ... I'm holding that off until its clear in which form those will stay.. Looks to me like phpDox is using php-parser 3, but you have php-parser 2 installed. Maybe try deleting the vendor/ directory and running composer install again?. As this is a 3rd party issue, closing here.. Resolved by #331.. An alternative approach would be to add a mode where nodes are not modified in-place, and instead a resolvedName attribute is added. I vaguely remember someone requesting this in the past, because they needed resolved names, but didn't want to change the AST. Doing it this way would also cover your use-case. However, for most purposes this is probably a lot less ergonomic (as you are more often interested in resolved names than original names), as such your approach looks reasonable to me.. Merged via https://github.com/nikic/PHP-Parser/commit/3e8c8d248dcaa837bdb91b82e7883fd9cc055aa5, for now behind a preserveOriginalNames option.\nThanks!. Is this a new install or did it happen after an update? What is in your composer.json?. Closing as no further response.. Yeah, test_old is still in use. This test runner makes sure we can parse all files in the PHP testsuite. It might be good to rename it to something else, but it definitely shouldn't be dropped :). Which version of PHP-Parser are you using? JSON serialization is supported as of version 3.0. As your output is missing not only attributes but also nodeType, I'd guess that you're using an older version.. I don't really understand what you mean by \"node address\" and how it differs from the node itself.. Ah, I see. This library currently doesn't have anything like that.. Looks like something went wrong with the commit history for this PR.... No idea what would cause this (apart from maybe a modified bin-dir?)\nHowever, unless you actually plan to use the php-parse script, you can just ignore the warning.. Can you please try deleting the vendor/ directory and reinstalling dependencies? I have no idea what the issue here is, but deleting vendor/ seems to have helped with most of the previous composer issues.. Great! Thanks for the pointer about the composer cache.. FinderVisitor added in https://github.com/nikic/PHP-Parser/commit/0607450f78fb46d6b8e06cf2eee2c052ec5c24e8.. Added NodeFinder in https://github.com/nikic/PHP-Parser/commit/79afd56565f6b91cbf4d943f991d1d089f521140, which supports find, findInstanceOf, findFirst and findFirstInstanceOf.. Counting this as implemented, the API can be further extended as needed.. PHP-Parser provides the AST per file -- if you want to resolve includes, you should do so manually, for example by creating a visitor that replaces any include node by the AST of that file. Of course, includes are not usually performed on simple strings, so you will have to resolve at least basic constant expressions based on __DIR__ and will not be able to resolve some dynamic includes at all. You also need to be careful about directly or indirectly recursive includes.. @markbook2 Just to make sure, are you using PHP-Parser 3.0 or the master branch?\nIf you're on 3.0 it should be possible to replace a plain require \"foo.php\"; simply by returning an array. However, you may run into an issue for code like $foo = require \"foo.php\"; or if (require \"foo.php\"). There is no universal way you can replace this. After all, you can't simply dump the code of the file into the assignment or if condition. You would have to perform a more sophisticated merge.\nCan you provide some more context on what you're trying to do? Usually explicitly merging the AST is not necessary, and in case you want to handle not only includes but also function-calls non-opaquely it is not really feasible. There are usually better ways to make analysis passes inter-procedural and context-sensitive, but that depends on what specifically you want to do.. If you're on the master branch, the problem you're likely running into is that Expr\\Include is wrapped in a Stmt\\Expression. You need to replace not only the include expression itself, but the entire statement. The code would be something like this:\nphp\n    public function leaveNode(Node $node) {\n        if ($node instanceof Stmt\\Expression) {\n            $expr = $node->expr;\n            if ($expr instanceof Expr\\Include_) {\n                // For simplicity assume that the $expr->type == TYPE_REQUIRE.\n                $nodes = $this->evalRequire($expr->expr);\n                return $nodes;\n            }\n        }\n    }. Okay, in that case I'm closing this issue.. It should have used a vendor namespace from the start, but I'm not going to change it at this point.. Is it possible to disable generation of @return void annotations? I'm not using those anywhere, as I consider the absence of @return in a doc-block to indicate that there is no meaningful return value.. Overall, nice results. There's a few cases where the return type is too broad (e.g. NameResolver::getResolvedClassName() can't return null), but inferring that would be non-trivial (something like CPA could determine that null is only returned if both arguments are null and in this case at most one of them is).. Merged via https://github.com/nikic/PHP-Parser/commit/e3b87f40aa6d2ca65ed40ee26566299412985141, with more updates in https://github.com/nikic/PHP-Parser/commit/bfea338d36721ba91db849d0596d07a1d585bcc0, where I manually improved some of the types and added descriptions + param annotations for everything.\nI did not merge the changes to the Standard pretty printer, as there basically all methods return strings and I think adding explicit doc comments there is more noisy than helpful.\nThanks!. Right, \"int\" should be a valid return type here as well.. Doc comments updated in https://github.com/nikic/PHP-Parser/commit/70f86cb6cb59a3d63c41bd5785797ebc6f3790aa.. As a small update here: While there has been no movement on the above TODOs, all the necessary parser changes are now in 4.0, without the need to enable special options. As such, the boilerplate code to perform format-preserving transformations is now:\n```php\n$lexer = new Lexer\\Emulative([\n    'usedAttributes' => [\n        'comments',\n        'startLine', 'endLine',\n        'startTokenPos', 'endTokenPos',\n    ],\n]);\n$parser = new Parser\\Php7($lexer);\n$traverser = new NodeTraverser();\n$traverser->addVisitor(new NodeVisitor\\CloningVisitor());\n$printer = new PrettyPrinter\\Standard();\n$oldStmts = $parser->parse($code);\n$oldTokens = $lexer->getTokens();\n$newStmts = $traverser->traverse($oldStmts);\n// MODIFY $newStmts HERE\n$newCode = $printer->printFormatPreserving($newStmts, $oldStmts, $oldTokens);\n``. I don't have concrete plans for a 4.0 release yet. I did not have time to work on this further and would like to at least resolve some of the TODO items (especially the first one is a large limitation).. @Juddling It's half-supported. The formatting of the array is preserved, but the new element is added on the same line. There is currently no detection that the array is formatted in multi-line style and the new element should be added in multi-line style as well.. @Juddling I've just landed https://github.com/nikic/PHP-Parser/commit/1c7fd314d182bafd7254ca8d025a4d83a72a2d6a, so this case should now work correctly (that is, use multi-line formatting).. I've released a beta version for PHP-Parser 4.0 (https://github.com/nikic/PHP-Parser/releases/tag/v4.0.0beta1) and plan to create a stable release soonishly. I'd say that at this point, this feature is working pretty well, and it just comes down to fixing formatting issues as they come up. If I'm going to wait until this functionality is \"finished\", I'm afraid we'll never see a release.... Good question, not sure whether this should just throw or print something. I guess if we print it would just be an empty string (e.g.$this->if the prop name is Error). What is the use-case for pretty printing a syntactically invalid file?. Exception added in https://github.com/nikic/PHP-Parser/commit/fd7ac251084746a24cbcbb66bd5d9d49c9e7cee2. I went with the exception as the conservative option, but if a use-case comes up we can change this to print something.. Deprecated on the 3.x branch with https://github.com/nikic/PHP-Parser/commit/42f046ec19897a54cd72eb2f453025ea8085ab34 and removed on master with https://github.com/nikic/PHP-Parser/commit/90b6d7cb5b4d642cb7bc5160460dc7ecb33c89fc..else ifis anelsefollowed by anif`:\n```php\nif ($x) { $y; }\nelse if ($z) { $u; }\n// Equivalent to\nif ($x) { $y; }\nelse { if ($z) { $u; } }\n```\nThe parser recognizes it as such.. Merged via https://github.com/nikic/PHP-Parser/commit/329e90c239267342199dd73a72642c15d81faf05 with two omissions: I've left out the NodeTraverser changes as the Node[] annotation is not always correct (see this comment). I've also left out the Namespace node change -- this one is of course correct, but the null value only exists temporarily during parsing, the end user never sees it.. Landed two micro-optimizations https://github.com/nikic/PHP-Parser/commit/3bbf8d8f7a21397030f9729041df3cf5cb74d217 and https://github.com/nikic/PHP-Parser/commit/8f623fb2413f95cc3cefe0747c22f8abe89692cf, which together improve parser performance by about ~12%.\n~~From a quick run through massif, the memory overhead of the attribute system is huge. Attributes are using more then 3x more memory than the AST objects themselves. This is not particularly surprising, as non-empty arrays in PHP have a minimum size of 344 bytes, while objects start at 40.~~ I interpreted some profiles incorrectly, the actual overhead of the attributes is closer to 80%.\nIt would be great to improve on that... one way would be to make locations (the main use of attributes) a first-class Location object. Even in an unoptimized represention with six properties (three pairs for line, offset and token offset) this would weight in at 136 bytes, 2.5x less than the attributes array. A compact representation with three properties would weigh in at 88 bytes, which is 4x less than the attributes array.\nThe big issue this (apart from the change itself, which will at least require changes to the node constructor signatures) is that we get the full cost of the attributes array back as soon as even a single other attribute is set. In which case we'd end up in a worse situation than we started with, because we'd have to carry both the cost of the Location object and the attributes array (which starts at 344 bytes).\nIt's pretty common that one or two attributes are added to each node. For example, the CloningVisitor in this project adds an origNode attribute to each node. I've seen other projects add a parentNode attribute to each node. Any of those would reintroduce the attributes array (or, if they are added as dynamic properties, the dynamic properties table, which has the same cost).\nI'm not sure how this can be solved... One very crazy idea I had was to add a use PhpParser\\NodeExt; line in the NodeAbstract class, for which we provide an empty default implementation, but other projects can overwrite in their bootstrap process, to be something like this:\nphp\nnamespace PhpParser {\n    if (!class_exists('PhpParser\\NodeExt')) {\n        trait NodeExt {\n            /** @var Node */\n            public $parentNode;\n        }\n    }\n}\nThis would allow one using project to add additional properties to the node structure, avoiding memory increase and maybe also providing better autocomplete support. If multiple libraries define it, then only one will be chosen -- which is per-se not problematic, as it does not change behavior, only make memory usage worse.. This is one of those cases where we run afoul of PHP's inadequate GC algorithm -- the majority of time is not spent parsing, but rather scanning the object graph again and again, without ever freeing anything. For me parsing the provided file takes 12.7 seconds withe the GC enabled and 1.4 seconds if it is disabled.\nBecause the majority of the time here is spent in the GC, this is a case that will not benefit from optimizations in the parser. It may be advisable to disable the GC during parsing, but this is a somewhat dangerous proposition, especially as the parser is commonly used in longer-running code. While the AST is acyclic by-design and no cycle leaks may originate from there, the construction code is not necessarily cycle free (e.g. the parser holds onto cycles via closures, so destroying it before the GC is reenabled would cause a leak.)\nUnless this issue is fixed upstream, I can only suggest to not parse files that exceed a certain file size -- as in this case, such files tend to be data anyway.\nRegarding php-ds: It's not really possible to use this library unless you add a hard requirement on the extension. While a PHP implementation exists, it is extremely slow. For example, map lookups are O(n) in the PHP implementation, while they should be O(1). There has recently been some discussion about dropping the polyfill altogether, for this reason.. @theofidry I've added a performance section to the docs: https://github.com/nikic/PHP-Parser/blob/master/doc/component/Performance.markdown. @Gert-dev Just to make sure there is no misunderstanding here: Even if you manually invoke the cycle collector using gc_collect_cycles(), this will only perform GC on the objects in the root buffer. If the root buffer has run full, additional objects will not be added anymore. As such, manual calls to gc_collect_cycles() are going to leak cycles which are not rooted within those first 10k objects. Especially for a long-running process this might become a concern.\nRegarding the parallelization, I don't believe parallelizing the parsing of a single file is possible (though of course processing multiple files in parallel is possible). Parallelizing the traversal should be possible (as you describe) if the visitor is order-independent, though I suspect that the overhead of the parallelization will be much higher in this case than the benefit.. Just to be clear, as long as you don't disable GC, hitting the root buffer limit isn't going to cause a leak --- it \"only\" kills performance if it's happening too quickly.\nWe have recently been working on a solution to the performance problem and the final iteration of the implementation (https://github.com/php/php-src/pull/3165) has landed today. As such, the GC issue should be mostly fixed in PHP 7.3.. Implemented with https://github.com/nikic/PHP-Parser/commit/62877b5d14e4d2e4b213a9cdb25413b72bb6505a.. This issue and #366 are now resolved by https://github.com/nikic/PHP-Parser/commit/c3cbf079466fad893e576d072c1f9daebfe04f95, which is a conservative version of #355, printing on multiple lines only if it is necessary to preserve comments.\nPrinting all arrays as multiline is something we could have behind an option (or maybe a callback so one can for example decide based on number of elements?). Merged via https://github.com/nikic/PHP-Parser/commit/4e55897059b0f8dddf63ea83cf4a357e7dcc06aa, thanks!. The master branch is still a couple of months away from a stable release, so backporting minor changes like this to 3.x makes sense.. Change ported to 3.x via https://github.com/nikic/PHP-Parser/commit/d18ccfeec7bcfaa832debb6b133d673b8c6dcd7f.. Some of the pretty printer tests that check the format for arrays are failing. Looking at some of the diffs, we have things like\n-[, [[$a]], $b] = $bar;\n+[\n+    ,\n+    [\n+        [\n+            $a,\n+        ],\n+    ],\n+    $b,\n+] = $bar;\nwhich makes me think that using multiline format for all arrays is probably not appropriate.. Closing this based on https://github.com/nikic/PHP-Parser/issues/351#issuecomment-292801293. I went with a conservative variant for now, but of course having an option to print all arrays on multiple lines would be fine.. Merged via https://github.com/nikic/PHP-Parser/commit/41facc02ef098dfe5574dad03e23f3a3ea0bf8c7, thanks!. Thanks!. Do you have a reference regarding the restriction to the top-level directory? The examples in the composer docs consistently use scripts in the bin/ directory, so I have a hard time believing that this is not supported.. It's not really clear what attributes should be assigned to an Error node. Right now the end position of the Error node is the last shifted token, which is also the token at which the error initially occurred. In your example that would be the ), which is why it is part of the range. An alternative interpretation would be to make Error an empty node, so that the start position would be at ( and the end at :.\nThe ClassConstFetch case has an additional problem, because the start offset is not correct. The Error should start at 22, but it starts at 15 (the start of the ClassConstFetch).. Empty error nodes implemented with https://github.com/nikic/PHP-Parser/commit/48ec654d0c067373bea3813ea3d092b8ac60e423. Fingers crossed this doesn't regress anything else.... NullableTypes are supposed to be resolved here: https://github.com/nikic/PHP-Parser/blob/3.x/lib/PhpParser/NodeVisitor/NameResolver.php#L123 Do you have a test case for this issue?\nEdit: NullableType resolution was added by https://github.com/nikic/PHP-Parser/commit/a485ecd7ba007e4d3381471fc46c4721766bcbcc in 3.0.2, are you sure you're not using an older version?. Having a fully resolved signature in enterNode sounds like a reasonable use-case. I've moved the resolution code into resolveSignature per your suggestion in https://github.com/nikic/PHP-Parser/commit/1b59e918f7542c260088a2d3d1fa0d3e4fb31a1c.. These files are generated, so any changes to them will be discarded on the next run of grammar/rebuildParsers.php. As this code isn't intended for human consumption, it probably doesn't make a lot of sense to fix the coding style anyway.... I can confirm that this issue exists on v3.0.4. However, it is not present on HEAD of 3.x. Presumably this was fixed as part a side-effect of #359.. I've published a new release for 3.x, which includes the referenced patches: https://github.com/nikic/PHP-Parser/releases/tag/v3.0.5. Thanks! Unfortunately it doesn't look like binary string lexing was fixed in the meantime, so we still have test failures on HHVM :(. We're past feature freeze for PHP 7.2 now, so looks like this is indeed all there is.... As you already noted, I don't think this is related to this library. Though I'm also not aware of any specific PHP bugs that would cause __DIR__ to return an incorrect value (apart from one that is just outdated due to the realpath cache).. Fixed by https://github.com/nikic/PHP-Parser/commit/c3cbf079466fad893e576d072c1f9daebfe04f95.. Unqualified class names are relative to the current namespace, so Error in this context already refers to PhpParser\\Error. So I'm stumped as to where the error is coming from.. Just created a FAQ section in the docs and added this: https://github.com/nikic/PHP-Parser/blob/master/doc/5_FAQ.markdown#how-can-the-parent-of-a-node-be-obtained. Sorry, I don't understand the question.. PHP <= 5.5 had a lexer bug, which prevents this from working: https://3v4l.org/X9G17 Of course, this is something that can be emulated in Lexer\\Emulative. However, PHP-Parser 2.x (which is the last version that has PHP 5.4 support) is no longer maintained.. Yeah, copy&paste mistake. Thanks!. Fixed in https://github.com/nikic/PHP-Parser/commit/901b895c023769ab6d8a25bf35c61c1aa2e52aa7.. Ah, for the record, the reason why I didn't merge this is that during some preliminary performance testing this caused a minor regression (iirc something like 2% end to end). I was thinking it could be improved by not creating a new object every time, but never got around to testing it.. I'm fine with makeVariadic(), but what's the motivation for setAdditionalAttributes()? If we add something like this, it probably should be added for all builders.. Yeah, I'd prefer that.. Merged as https://github.com/nikic/PHP-Parser/commit/c877c1a64ff7c3dcdcd78ceed292fc4557ed6fd2 into 3.x. Thanks!. PHP-Parser uses an abstract syntax tree, which hides details of representation. <?php echo and <?= are the same to PHP, so they are represented the same.\nIt is possible to distinguish them in two ways: Either enabling the token positions in the lexer options and then checking whether the token at tokenStartPos is a T_OPEN_TAG_WITH_ECHO, or by adding a custom attribute in the lexer.. I'm fine with adding a toMagic() method. Do you plan to PR this?. Merged as https://github.com/nikic/PHP-Parser/commit/9dc93aafaab90eb885a59412237b323047c1819a. Thanks!. Not sure I get what you mean. To me it looks like you're missing Arg wrappers around call arguments, i.e. you're using something like [new Variable('a'), new Variable('b')] instead of [new Arg(new Variable('a')), new Arg(new Variable('b'))] when constructing call arguments.\nThe Arg nodes handle call-time pass-by-ref and argument unpacking.. The first one should be:\nphp\n->addStmt(\n                new Assign(\n                    new PropertyFetch(\n                        new Variable('this'),\n                        'providerInstance'\n                    ),\n                    new StaticCall( // line 142\n                        new Name(\n                            'SerialisedElementSource'\n                        ),\n                        'InstantiateElementsProviderWithDependencies',\n                        [\n                            new Arg(\n                                new Variable(\n                                    'GetSerialisedElement'\n                                )\n                            ),\n                            new Arg(\n                                new Variable(\n                                    'GetHtmlFragmentDeserialiserInterface'\n                                )\n                            ),\n                        ]\n                    )\n                )\n            )\netc. The last example should be using new Arg(new Variable('args'), false, true), which is how argument unpacking is done.\nI'm open to having more methods added to the BuilderFactory that do direct node construction (even though it is rather dirty). Things like ->methodCall($obj, $name, $args) where $args is automatically wrapped in Args and a method ->concat(...$exprs) which constructs the concat tree would seem helpful in your case.. The extra parenthesis should go away if you pass static::ConcatFromExprsRecursive($exprs) first and $argWasZero second. (Concat is a left-associative operator.)\nI'd prefer having methods like this in the builder system, because we have more freedom to do automatic conversion there. E.g. we wouldn't have to require manual wrapping in String_ nodes and could do that automatically.. Yes, here: https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/BuilderAbstract.php#L132\nHowever this is in an abstract class right now, so it will have to be moved somewhere else before it's usable in the BuilderFactory (maybe convert it into a BuilderHelpers trait?). I've moved the methods into a static class in https://github.com/nikic/PHP-Parser/commit/7419649eae50984a1242e05836f48884007a332e and added concat() in https://github.com/nikic/PHP-Parser/commit/5f7070e94f5dafb68d6f40162d0ac201795a43e9.. Also added an args() method in https://github.com/nikic/PHP-Parser/commit/3b4abbfc975754ccc6257c39328c6a48f1049b59, so closing here.. Thanks! Also added the mentioned option in https://github.com/nikic/PHP-Parser/commit/e1ab92275cefe13c8e41c0ca42679258ebecbce8.. There are three separate issues here:\n\nPreservation of comments on empty blocks. This has been fixed by https://github.com/nikic/PHP-Parser/commit/d418bf395113b6a3293bda1d08ddc9b0209d5dcf.\nDuplicate comments. This is a known bug tracked in #253.\nComments in the middle of nodes. These are indeed not represented. As usual, it's still possible to extract them using token offsets and a bit of extra work. Assuming token offsets are enabled in the lexer, something along the lines of (not tested):\n\n```php\n// $tokens from Lexer->getTokens()\nfunction getInteriorComments(Node $node, array $tokens) {\n    $comments = [];\n    $pos = $node->getStartTokenPos();\n    foreach ($node->getSubNodeNames() as $name) {\n        $subNode = $node->$name;\n        if ($subNode instanceof Node) {\n            $endPos = backwardsAdjust($tokens, $subNode->getStartTokenPos());\n            $comments = array_merge($comments, extractComments($tokens, $pos, $endPos));\n            $pos = $subNode->getEndTokenPos() + 1;\n        }\n    }\n    $endPos = $node->getEndTokenPos() + 1;\n    $comments = array_merge($comments, extractComments($tokens, $pos, $endPos));\n    return $comments;\n}\nfunction extractComments(array $tokens, int $startPos, int $endPos) {\n    $comments = [];\n    for ($pos = $startPos; $pos < $endPos; $pos++) {\n        $token = $tokens[$pos];\n        if ($token[0] === T_COMMENT) {\n            $comments[] = new Comment($token[1]);\n        } else if ($token[0] === T_DOC_COMMENT) {\n            $comments[] = new Comment\\Doc($token[1]);\n        }\n    }\n    return $comments;\n}\nfunction backwardsAdjust(array $tokens, int $pos) {\n    for (; $pos > 0; $pos--) {\n        $token = $tokens[$pos-1];\n        if (!in_array($token[0], [T_COMMENT, T_DOC_COMMENT, T_WHITESPACE])) {\n            break;\n        }\n    }\n    return $pos;\n}\n```\nWhat this code does is to fetch all the comments that are inside the node but not inside a subnode. An additional complication (the backwardsAdjust function) is that we also want to skip the comments that are directly preceding the subnodes, as there will already be associated with the subnodes. (This would have been somewhat easier if comments also stored their starting token offset -- they currently only have the file offset.). This is an unfortunate combination of two factors:\n\nIn PHP a reserved keyword directly following -> will be treated as an ordinary identifier (already at the lexer level).\nPHP has an alternative array access syntax $foo{$bar}.\n\nTogether, these mean that PHP-Parser will try to parse this as $this->if(true){$someExpr} until it reaches an error when it turns out the {} block is does not contain a well-formed expression. At this point it's no longer possible to recover in a meaningful way (the best we might do with additional error recovery rules is to keep a $this->if(true); call.)\nI think the best solution here would be a custom lexer that finds sequences T_OBJECT_OPERATOR T_WHITESPACE T_STRING, where the T_WHITESPACE contains a newline and the T_STRING is a reserved keyword, and converts the T_STRING into the appropriate keyword token. This should enable recovery to work as normal. Of course it will no longer be fully accurate, as for example\n```php\n<?php\n$this->\nif (true)\n    [123];\n```\nwould then be parsed to an incomplete property access and an if statement, rather than the call $this->if(true)[123]; it is under PHP semantics.. Or a more radical solution, insert an implicit semicolon after T_OBJECT_OPERATOR followed by T_WHITESPACE with a newline. This strays further from technical semantics, but will probably be closer to the output you want to see if you have something like\nphp\n$this->\n$this->foo();\nWhich is currently parsed as $this->$this->foo(). Technically correct, but not the most useful output.. > When parsing the above example, the Comment 2 is lost. I think it is because it would be stored against a potential third item on the array. It would be great if there was a way to recover it.\nThis is indeed the case. PHP-Parser always associates comments with the following node -- if there is no following node, they are lost.\nHowever, there is a way to manually retrieve such comments with a bit of extra work. You need to enable token positions as described in the lexer docs and obtain the tokens with a $lexer->getTokens() call.\nThen you should be able to retrieve trailing comments like these using something like the following code:\n```php\nfunction getTrailingComment(array $tokens, Node $node) {\n    assert($node->hasAttribute('endTokenPos'));\n$pos = $node->getAttribute('endTokenPos');\n$endLine = $node->getAttribute('endLine');\n\nfor (; $pos < count($tokens); ++$pos) {\n    if (!is_array($tokens[$pos])) continue;\n    list($type, $content, $line) = $tokens[$pos];\n    if ($line > $endLine) break;\n    if ($type === T_COMMENT || $type === T_DOC_COMMENT) {\n        return $content;\n    }\n}\n\nreturn null;\n\n}\n```\nThis code will return the first comment after the node that is still on the same line.. Fixed by https://github.com/nikic/PHP-Parser/commit/73dc35cbbd8dd464cedbe83b9cd9c6e1d1ebf144. Thanks for catching this!. The type annotation is incorrect -- it should be (ArrayItem|null)[], because list($a,,,,$b) is valid and will be represented by nulls.\nI'm not sure whether a trailing null should be present in this case. The background here is that in array(1, 2, ) the last comma is a trailing comma, while in list($a, $b, ) the last comma is an element-skip. However, the representation is inconsistent here, so it might be preferable to drop one trailing null.. I've fixed the type annotation in https://github.com/nikic/PHP-Parser/commit/4e162bd0eae5acd019bcb619c1328507c763bbe0.. Please either increase your maximum nesting level or, preferably, disable XDebug entirely. See: https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#bootstrapping.. Your first code looks right to me. I would assume that the issue is somewhere else, e.g. that you're not passing the modified AST to the pretty printer, or similar. The second code does not work because you can only remove nodes from arrays. In this case you're trying to remove a part of an Arg node. Instead you have to remove the surrounding Arg node.. Thanks!. Under which circumstances do you see the notice? Is it an empty file on HHVM perchance? The change makes sense in any case, just wondering how to reproduce.. Merged as https://github.com/nikic/PHP-Parser/commit/c28b8556f512cbcbcdcefa48abc8020751f997cd into 3.x. Thanks :). The result is correct: The RHS of =& must be a variable, and null-coalesce is not a variable. Same as !$foo = $bar being !($foo = $bar) instead of (!$foo) = $bar, even though it goes against precedence.. It's not possible to get this kind of information using this library alone. Determining the type of a variable requires some form of type inference, which is something that has been implemented by a number of static analyzers on top of PHP-Parser in various ways. Two that come to mind are psalm and phpstan, though there are more than that. Unfortunately I'm not aware of a library that only provides type inference.. What do you use the number of parts for?. I've dropped the deprecation. The original plan to drop this in favor of a string didn't go anywhere, so we can just keep it around for now.. As said by @krageon, the way to do this is to parse the code and add it to the AST in the place you want. There's no way to directly insert code as text.\nIf you really want to avoid the round-trip through the parser, then I think the cleanest way would be to define a custom node and implement pass-through printing for it. This should be the necessary code:\n```php\nclass PlainCode extends \\PhpParser\\Node\\Stmt {\n   public $code;\n   public function __construct($code) { $this->code = $code; }\n   public function getType() { return 'Stmt_PlainCode'; }\n   public function getSubNodeNames() { return ['code']; }\n}\nclass MyPrettyPrinter extends \\PhpParser\\PrettyPrinter\\Standard {\n    public function pStmt_PlainCode(PlainCode $node) {\n        return $node->code;\n        // OR\n        return $this->pNoIndent($node->code);\n    }\n}\n```\nThere are two variants for the implementation of the printer. If you directly return the code it will be indented (which may corrupt multi-line strings for example). If you use pNoIndent(), then the code is inserted exactly as is. (All this assuming PHP-Parser 3.x, not master).. I hope , is the only case that can happen.... Where is the CloningVisitor being applied? Unfortunately GH can only search master.. @TomasVotruba It should definitely run first. To be on the safe side (especially if enterNode visitors are used), I'd also run it as an independent pass instead of interleaving it with other visitors.. I used to support XML serialization and deserialization (in fact still supported in the current stable version 3.x), but dropped this in the current development branch, because nobody seems to be using it and I can't imagine anyone wanting to use it (XML is quite atrocious for this purpose, see the example dump...)\nThe ability to convert JSON back into a node tree should be added. It should not be particularly hard either.\nAs far as I know, there are exactly two reasons why JSON encoding may not be possible: The first is that the AST contains a string that is not well-formed UTF-8. The second is that it contains an INF value (which can happen if the code contains something like 1e1000).. A JSON decoder has been implemented in https://github.com/nikic/PHP-Parser/commit/9373a8e9f551516bc8e42aedeacd1b4f635d27fc.\nA full round-trip from PHP code to PHP code would go something like this now:\n```php\n$code = ...;\n$parser = (new PhpParser\\ParserFactory)->create(PhpParser\\ParserFactory::ONLY_PHP7);\n$stmts = $parser->parse($code);\n$json = json_encode($stmts);\n// Do stuff\n$jsonDecoder = new PhpParser\\JsonDecoder;\n$stmts = $jsonDecoder->decode($json);\n$prettyPrinter = new PhpParser\\PrettyPrinter\\Standard;\n$code = $prettyPrinter->prettyPrintFile($stmts);\n``. The value of a constant is stored inside thevalueof aConst` node, see https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Const_.php#L14. Or are you looking for something else?. This is not entirely simple, because constants can also contain constant expressions. They may also reference other constants. Essentially this requires a full constant expression evaluator. You can find an existing implementation in BetterReflection: https://github.com/Roave/BetterReflection/blob/master/src/NodeCompiler/CompileNodeToValue.php\nI do think that integrating something like this in PHP-Parser would be good though.. A constant expression evaluator has been added in https://github.com/nikic/PHP-Parser/commit/4b1d9667afdcf8a526e38955dd33def4d75c72d1. A basic usage would be something like this:\nphp\n$evaluator = new ConstExprEvaluator();\ntry {\n    $value = $evaluator->evaluate($expr);\n} catch (ConstExprEvaluationException $e) {\n    // Cannot evaluate\n}\nA more advanced usage would also have to provide a fallback evaluator to deal with constant lookup and similar, but this can't be handled generically.\nMay also be of interest for @Ocramius, though this is 4.0 so not directly usable yet.. What is the motivation behind exporting the parser generation as part of the public, stable API?. So, I'm mainly concerned about two things:\nFirst, the parser generation code is quite tightly coupled to the needs of this project, even with the additional abstraction you've introduced. The parser macros are specific to parsing PHP, the unusual splitting of token declarations is an artifact of having two parsers with a single lexer, and the parser implementation itself contains large amounts of PHP-specific code. It's certainly possible to directly reuse this code for other grammars, but it would come with quite a number of unnecessary things.\nSecond and more importantly, this exports something that was previously internal helper code as part of the public API. This means I will no longer be able to make changes to the parser generation in a stable branch, or at least such changes will have to be done a lot more carefully (for example, can I change the definition of a macro in a stable branch?) Given that there will probably be very few people interested in using this and given that parser generation is not what this library does, I don't think that this is worthwhile.\nAs such, I would go with copy&pasting the code here... Or, if this is something useful for more than one project, creating a library just for the parser generation.. @m1guelpf There is some relevant news here: We recently ported kmyacc to PHP at https://github.com/ircmaxell/PHP-Yacc, and once it's more mature, this project will switch to using that and remove the binary kmyacc dependency. PHP-Yacc should also be providing the necessary template files etc in the future to support simple parsers without additional configuration. So basically this is going down the \"separate library\" route, just that the scope turned out a bit more ambitious than a thin wrapper around kmyacc.. > Would you be interested in setting up automated coding standard in Travis?\nNope, don't care about CS enough for that.. Strict types addition merged as https://github.com/nikic/PHP-Parser/commit/e2e99f269b5b543c9196e1cf56348942165e8faf. I've handled the extra string casts a bit differently in https://github.com/nikic/PHP-Parser/commit/d97cc3d96e661e199244dc993bced393e3cd231d and https://github.com/nikic/PHP-Parser/commit/7b36ca3b6cc1b99210c6699074d6091061e73eea.. > That would be great. Just wait for @nikic to confirm, if he needs that.\nWhat I mainly care about is having some reproduce code -- it's not so important whether it comes in test form or standalone :). Can you replace just the name of the method call? $call->name = new Identifier('newMethod') should do it.. You need to create an Identifier node for the name, it's not a plain string (anymore).\nAnother way that should also work is to copy the originalNode attribute from the node you're replacing.. Yeah, looks right to me.. Yeah, it can be removed. It's a leftover from a recent refactor of indentation handling.. Attribute added in https://github.com/nikic/PHP-Parser/commit/5a9fbca54a5edba0be673b85f0bc824caddb6567. I'm using kind following a convention used by a number of other nodes.. We can't really satisfy everyone with the default behavior -- there's just too many different coding styles in active use. Even adding options is not feasible, because there are hundreds of individual items that may need configuration. My recommendation would be:\n\nIf you only want to adjust a few things, extend the respective method in the pretty printer.\nIf you want to have more precise control of the formatting, print using the default style and then run the result though one of the existing code formatting libraries, which already implement fine-grained options to control formatting.\nIf you're not generating but modifying code, #344 may be an option.. Unless I'm misunderstanding something, isn't this what Comment::getFilePos() provides? https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Comment.php#L47. The format-preserving printer currently does not detect changes to comments. This is one of the open issues. Properties probably work because it falls back to the normal pretty printer for some other reason.. As a temporary workaround, you can force a fallback on the parent of the node you're changing (e.g. by doing a $parent->removeAttribute('originalNode').. Does it work if you try it on the node itself instead of the parent?. Did you use $node->setAttribute('parentNode', null) or $node->setAttribute('originalNode', null)?. @TomasVotruba Your last Travis build has\n\n+/**\\n\n+ */\\n\nas the diff. Isn't this the expected output with your current code? After all you're not removing the comment entirely, you're setting it to an empty doc comment.. I've added a check in the pretty printer in (https://github.com/nikic/PHP-Parser/commit/f6cc85a7969795d983a758a7a20ee846406bb99a), so the workaround should no longer be necessary. This a temporary fix before a full solution can be implemented.. I don't think this will be natively supported (unless as part of something like #16), but it should not be hard to implement this manually:\nphp\nfunction getBodyStartPos(FunctionLike $node, string $code) : int {\n    $pos = $node->getStartFilePos();\n    if ($params = $node->getParams()) {\n        $pos = $params[count($params) - 1]->getEndFilePos();\n    }\n    return strpos($code, '{', $pos);\n}\nThe end position of the parameters is used to account for the unlikely case that { occurs in the parameter list, which is legal (function test($param = \"foo\"{0})).. Ah right, forgot about the comments. The way to avoid that would be to use token offsets instead and check for '{' in the tokens following the position. Unfortunately this does make the code more complicated, as one has to both track the file position and the token position...\n```php\nfunction getBodyStartPos(FunctionLike $node, array $tokens) : int {\n    $pos = $node->getStartFilePos();\n    $tokenPos = $node->getStartTokenPos();\n    if ($params = $node->getParams()) {\n        $lastParam = $params[count($params) - 1];\n        $pos = $lastParam->getEndFilePos();\n        $tokenPos = $lastParam->getEndTokenPos();\n    }\nwhile (true) {\n    $token = $tokens[$tokenPos];\n    if ($token === '{') break;\n\n    $pos += strlen(\\is_string($token) ? $token : $token[1]);\n    $tokenPos++;\n}\n\nreturn $pos;\n\n}\n```\nI don't have any better solution to offer though.. As a workaround, you can try return new Stmt\\Nop(). I think this will leave an unnecessary newline, but at least not completely kill the formatting.. The public interface of PrettyPrinterAbstract has a couple more methods:\nphp\ninterface PrettyPrinter {\n    public function prettyPrint(array $stmts) : string;\n    public function prettyPrintExpr(Expr $node) : string;\n    public function prettyPrintFile(array $stmts) : string;\n    public function printFormatPreserving(array $stmts, array $origStmts, array $origTokens) : string;\n}\nThe thing is, I think that any implementation of the PrettyPrinter interface is going to extend from PrettyPrinterAbstract (and quite likely from the Standard printer as well -- there are large parts that one likely does not want to adjust).\nWould I be mistaken in the assumption that what you're looking for here is not actually an interface, but rather the ability to write PrettyPrinter rather than PrettyPrinterAbstract in type hints?. The relevant documentation should be:\n\nhttps://github.com/nikic/PHP-Parser/blob/master/doc/component/Pretty_printing.markdown: For converting AST to code\nhttps://github.com/nikic/PHP-Parser/blob/master/doc/4_Code_generation.markdown: Some helpers for creating new AST nodes (you can also manually create them)\nhttps://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#node-traversation: If you're modifying an existing AST, you will likely handle the insertion/changes using a node visitor.. Support for this has been implemented only recently, can you try updating the commit hash in https://github.com/RectorPHP/Rector/blob/master/composer.json#L13? ed8a744c does not yet have it.. @TomasVotruba $node->setAttribute('origNode', null) is needed if you explicitly don't want to preserve formatting for a node. Normally it shouldn't be necessary unless you need to work around a bug. In what circumstances do you use it?. @TomasVotruba The problem is that the added statements use keys like before_2, while list nodes are expected to be indexed numerically. In StatementGlue::insertBefore, replacing the implementation with something like array_splice($classNode->stmts, $key, 0, [$node]) should work.. @TomasVotruba Should be fixed by https://github.com/nikic/PHP-Parser/commit/f5de7f9894527186c187084b5e41cdff87b191e0. Please check if updating php-parser resolves this problem.. What is the motivation for using this over an anonymous class?. I'm closing this, as a) you can already use an anonymous class with about the same amount of effort (First code in https://github.com/nikic/PHP-Parser/blob/master/doc/component/Walking_the_AST.markdown) and b) the specific case of finding nodes is handled by NodeFinder (https://github.com/nikic/PHP-Parser/blob/master/doc/component/Walking_the_AST.markdown#simple-node-finding).. Thanks for the report, this should be fixed with https://github.com/nikic/PHP-Parser/commit/776275361a24214507809d8502ec67473f38af7d.. There is no built-in mechanism for this, but it's easy to add with a visitor: https://github.com/nikic/PHP-Parser/blob/master/doc/5_FAQ.markdown#how-can-the-parent-of-a-node-be-obtained. I can't reproduce this issue. The following orig/change/expected test succeeds:\n\n```\n<?php\n$this->someProperty->anotherProperty[]->lastProperty;\n\n$stmts[0]->expr = new Expr\\MethodCall($stmts[0]->expr, 'getValue');\n<?php\n$this->someProperty->anotherProperty[]->lastProperty->getValue();\n```\nIf you're seeing a segmentation fault, the most likely cause is infinite recursion. Could you try running it through xdebug with a reasonable recursion limit (say 2000) and see whether (and where) it generates a recursion error?\nI suspect that you're creating a circular AST.. The new code doesn't make a lot of sense, because you're adding the method call on the entire expression (including the assignment) rather than on the property fetch.\nCan you point me to a commit where it's possible to reproduce this issue? I've checked out the php-parser-segfaults-and-extra-spaces branch, but don't get segfaults there. Only many failures related to better-reflection incompatibility.. For me this test fails with:\n\nTypeError: Argument 1 passed to Rector\\BetterReflection\\SourceLocator\\Reflection\\SourceStubber::addDocComment() must be an instance of PhpParser\\BuilderAbstract, instance of PhpParser\\Builder\\Interface_ given, called in /home/nikic/Rector/vendor/rector/better-reflection/src/SourceLocator/Reflection/SourceStubber.php on line 63. I was able to fix this by reverting https://github.com/RectorPHP/Rector/commit/0293adc2d4f7da81658f841fa7e008e8e1056543 and changing the refactor implementation to:\n\n```php\n        $parentNode = $propertyFetchNode->getAttribute(Attribute::PARENT_NODE);\n        if ($parentNode instanceof MethodCall) {\n            return $propertyFetchNode;\n        }\n    $call = new MethodCall($propertyFetchNode, 'toString');\n    $propertyFetchNode->setAttribute(Attribute::PARENT_NODE, $call);\n    $call->setAttribute(Attribute::PARENT_NODE, $parentNode);\n    return $call;\n\n```\nThis updates the parent node attribute to match the new structure.\nAs to why this happens: The segfault doesn't occur due to recursion over cyclic structure, but rather during GC traversal of a very deeply nested structure. The issue is that if a visitor returns a new node from enterNode, its children will still be visited as usual. So refactor() will again be invoked on the property fetch within the new method call. Because the parent nodes were not up to date, the check for the already existing method call did not trigger, so it ended up nesting more and more method calls.\nI never noticed this potential pitfall before, because I generally only modify nodes during leaveNode. I'm not sure what the best way to address this is, both from your and my side. I tried modifying AbstractRector both to use leaveNode and to use a split like this: https://gist.github.com/nikic/97ed25680c502751c769bbc9dcfb468e. However, both variants had test failures. So it looks like some rectors do need the behavior where the subnodes of the new node are still visited.. This should be fixed by https://github.com/nikic/PHP-Parser/commit/5900d78cc91f7b4089e83f7f673c22ce71c57d3f.. Added setDocComment() method in https://github.com/nikic/PHP-Parser/commit/0ba710affa365eeb217188d733e3e55251963b17 and released a new version https://github.com/nikic/PHP-Parser/releases/tag/v3.1.2.. @carusogabriel I'd prefer to keep 7.0 support for now.. Emulating the heredoc/nowdoc changes on old versions is going to be quite tough. I'm considering to just add a pure-php token_get_all shim to be used if the file uses flexible heredoc/nowdoc running on <7.3.. Flexible heredoc/nowdoc is now supported -- the emulation on PHP < 7.3 is not perfect, but hopefully \"good enough\". Full emulation would require a complete reimplementation of token_get_all(), which feels like overkill just for this purpose.. This is an unavoidable artifact of using closed (inclusive) ranges. The only way to represent an empty range (as the error node is in this case) is to make start greater than end. If start=end that already means that the range contains one character.. For reference, the only nodes that can have start>end are Stmt\\Nop and Expr\\Error, as they are the only nodes that can be empty (there's a test for this: https://github.com/nikic/PHP-Parser/blob/master/test/PhpParser/CodeParsingTest.php#L111).. To be honest, I don't think the inclusive ranges make a lot of sense. Originally I went with them because the startLine+endLine attributes that already existed at that time appeared to be inclusive (though really the concept doesn't apply in the same way there). I'm considering some larger changes to location handling for PHP-Parser 4.0 (in particular switching away from attributes to first-class Location objects) and if I go with it I'll probably switch to the more customary half-closed [start, end) intervals as well.. Merged https://github.com/nikic/PHP-Parser/commit/bac91b426e721cc7183208199c525d6c43ab63c6 into 3.x. For 4.0 I've generated explicit getType() methods instead: https://github.com/nikic/PHP-Parser/commit/1c11626f0a2fda566d9db9f388feb0682093955a. @theofidry Done with https://github.com/nikic/PHP-Parser/commit/94ca9a7ab9a9eff7fa15a4a173a8735755ed30f8.. Thanks for the report, this should be fixed by https://github.com/nikic/PHP-Parser/commit/336a49b428c11c3fd3b73e1018e5e1f8239ee197.. Do you have a reproduce script for this? This looks like a usage mistake to me, as the parser shouldn't ever generate a namespace for which toString() is ''.. That's the problem then. The global namespace is represented using new Namespace(null, ...), not new Namespace_(new FullyQualified(''), ...). Generally names with empty components are always invalid. I guess it would be good to add an explicit check + exception in this case.. I've added an exception on empty names in master: https://github.com/nikic/PHP-Parser/commit/b507fa43dae5b00e60f1ba9d84f48fc323ab46ae Not changing this in 3.x for BC reasons. It looks like goaop/parser-reflection already has an open PR to fix this issue: https://github.com/goaop/parser-reflection/pull/68. The file doc block will always be on the first AST node in the file. Your two examples differ by what kind of node that is. In either case, you should be able to retrieve it using $stmts[0]->getAttribute('comments')[0] (ignoring checks for all of those existing). (Or, to handle additional comments before it, by looping over $stmts[0]->getAttribute('comments') and finding the doc comment with @file in it.)\nI'm not sure how else this can be handled (at least while staying within the current model where a comment is always attached to a node).. @Gert-dev The main issue is that comments may occur in virtually any position.\nphp\n/*a*/if/*b*/(/*c*/$bar/*d*/)/*e*/{\n    /*f*/call/*g*/(/*h*/$bar/*i*/)/*j*/;\n}\nIt's not really feasible to represent all of these comments as explicit AST nodes, at least not without making the node structure significantly more complicated.\nOf course, the current approach of appending comments to the next node is also not able to preserve all the information, as only comments directly preceding a node are stored (a, c, f, h). Unfortunately this also includes the relatively common case of trailing comments with no following node (#384). Additionally, the current implementation has some technical issues, leading to comments being assigned to multiple nodes (#253).\nOverall I'm not very happy with the current situation. The current implementation is based on the lexer attribute system, which essentially restricts us to assigning comments to the next node. I have been considering to drop this in favor of a separate visitor that will assign comments based on token offset information. This would provide more flexibility in the way comments are assigned, e.g. by distinguishing leading and trailing comments, and also allowing to preserve information about interior comments that are currently lost entirely. (A downside is that it would require a separate visitor run, which is probably quite a bit slower than assigning comments on the fly.)\nRegarding the storage of comments as entirely separate nodes, at least in the cases where it is possible (e.g. statement lists), I agree that this would make more semantic sense in many cases (the direct association with nodes is only really meaningful for doc comments). However, it would also make some basic operations more complicated, e.g. adding a doc comment to a method would require obtaining a reference to the parent structure (e.g. class node), locating the method in the statement list and inserting a doc comment node before it.. The issue was the additional as the first list element. Hopefully https://github.com/nikic/PHP-Parser/commit/dc3ace55c3beaf026ebcd150659926d3c0a5a60e will resolve this.. @TomasVotruba Duh, I forgot to handle insertion of more than one element... Should be fixed with https://github.com/nikic/PHP-Parser/commit/4fcdac40d1a6a6f74ba315d7065053bbcd67d026.. I've added an explicit pSingleQuotedString method to the pretty printer in https://github.com/nikic/PHP-Parser/commit/e5453f0d460e71a493a35f0d476e5530c893793e. You can now achieve this behavior by extending the pretty printer with:\nphp\nprotected function pSingleQuotedString(string $string) {\n    return '\\'' . preg_replace(\"/'|\\\\\\\\(?=[\\\\\\\\']|$)/\", '\\\\\\\\$0', $string) . '\\'';\n}\nI'm not sure whether or not this would make for a good default behavior.. @TomasVotruba \\ has to be escaped if it is followed by \\, ' or the end of the string.. Are the rebuildParsers.php and the php7.y file you're basing this on both taken from the same branch? This macro is different between 3.x and master.. object is a builtin typehint as of PHP 7.2.. I generally like the idea of specifying a more precise PHP version (with the understanding that it only affects thing that would parse differently, but still accept newer syntax). This is something that potentially impacts both lexer and parser -- e.g. 7.3 will change heredoc lexing.. Looks like using the current master rather than the alpha2 release fixes this specific case, because it no longer triggers the fallback code. The fallback case is still broken though.. The fallback case has been fixed in https://github.com/nikic/PHP-Parser/commit/a86151f24f803886909aa89fde19497033718d5d, and I've also released another alpha version: https://github.com/nikic/PHP-Parser/releases/tag/v4.0.0alpha3. As far as I know the code generator does not automatically replace type hints.. Merged this as https://github.com/nikic/PHP-Parser/commit/67df02c844b92c40220519fe0363b863a3b09c3f tweaked to use a year range instead.. @carusogabriel Yes, this should go to the 3.x branch.. Another case is +(++$x) and -(--$x) , fixed in https://github.com/nikic/PHP-Parser/commit/d01fafcb40a5de95d3a8272947b38cb39d47c997. Wondering if there's any others...\nI've also tagged a new release with these fixes: https://github.com/nikic/PHP-Parser/releases/tag/v3.1.4. I've merged most of the changes in this PR two weeks ago, but forgot to comment here on the rest. I'm not interested in doing changes like forcing single quotes or adding trailing commas. I don't see the benefit in these changes, they will only make it hard to rebase patches.. Btw, I think the double quote -> single quote conversion pass is really not just unnecessary, but actively harmful. Looking at https://github.com/nikic/PHP-Parser/pull/462/files#diff-9805ffb46197468914fd023f16202c98R38, I find it very hard to see this as an improvement. It takes code that is self-consistent (everything uses double quotes) and converts it into a weird mix of single and double quotes depending on whether that particular string happens to need an escape sequence or not.. Unless a getter/setter is needed for specialized logic, I don't see a benefit in doing this, and a lot of disadvantages (including being less ergonomic, slower and being a BC break if their use is required.). Test case\n```\n<?php\n$this->foo = new Foo;\n$this->foo->a()\n          ->b();\n\n$outerCall = $stmts[1]->expr;\n$innerCall = $outerCall->var;\n$var = $innerCall->var;\n$stmts[1]->expr = $innerCall;\n$stmts[2] = new Stmt\\Expression(new Expr\\MethodCall($var, $outerCall->name));\n\n<?php\n$this->foo = new Foo;\n$this->foo->a();\n$this->foo->b();\n``. Sorry for the confusion, this was just a reduced reproduce case for my test suite. It's a PHP-Parser bug, not in your code. The issue is that the indentation of the insertion point is taken, while what we really want something like the indentation of the previous element.. Should be fixed now. Can you please check that this works and doesn't break indentation in other cases?. I've disabled the collection of trailing comments for case blocks, not sure why I didn't do this earlier.. I think the suggestion makes sense in general, but I'm going to punt on this for 4.0. I don't want to change types at this point.. I think this would be out of scope of this library, because there are varying degrees of equality you could be going for. E.g. if you considerpublic function foo(){}andpublic function FOO(){}` the same, then which of the following would be considered the same as well?\nphp\npublic function foo() {\n    $foo = 1; return $foo;\n}\npublic function foo() {\n    $foo = 1;\n    return $foo;\n}\npublic function foo() {\n    $f = 1;\n    return $f;\n}\npublic function foo() {\n    return 1;\n}\nThey are all functionally identical, but will probably not be considered \"equal\" in many contexts. I think there is no correct answer to this question, so from my point of view an implementation of some specific equality relation would be better suited for a 3rd party library.. I think we're pretty close to a stable 4.0 release. I don't have any more code changes planned, but want to touch up the documentation a bit more.. Aaaand here we go: https://github.com/nikic/PHP-Parser/releases/tag/v4.0.0. namespacedName is only used on declarations (class Foo {} etc). Unless you passed options to the name resolver, it should have changed the type into \\Symfony\\Component\\HttpFoundation\\Request (a Name\\FullyQualified). You don't need to access any attributes for that, the node has been replaced entirely.. The lexer options shouldn't affect this. Would you mind showing the full code you are using? I'd assume there's some issue with the way the name resolver is applied.. @mnpenner Ah, I see the issue. Both visitors are running in parallel, but the class visitor goes deep inside the tree (inspecting methods and params etc.) before the name resolver gets to them. The solution is to run the name resolver and class extractor in two independent passes:\nphp\n$nameResolver = new NodeTraverser;\n$nameResolver->addVisitor(new NameResolver);\n$classExtractor = new NodeTraverser;\n$classExtractor->addVisitor(new ClassExtractor);\n// ...\n$ast = $nameResolver->traverse($ast);\n$ast = $classExtractor->traverse($ast);\nThis should make sure that all names are resolved when the class extractor gets to them.. I think if we move those constants, it might be best to create a separate Modifiers class for it. After all, they are not specific to classes, but are also used in methods, properties and constants.. @davidmpaz The reason why I wouldn't separate visibility and other modifiers is that they are not ordered. I.e. both public static and static public are valid. It doesn't really matter in the current design where the modifiers are flags, but it would be a problem if we would also try to preserve the order in which the modifiers were declared in the future.. Thanks!. PHP-Parser 4.0 makes a distinction between an expression (new Foo) and an expression statement (new Foo;). To preserve the semicolon, the mutate method should look as follows:\npublic function mutate(Node $node)\n    {\n        return new Node\\Stmt\\Expression($node->expr);\n    }\nI probably should add some sanity checks for this, as it will probably be a common problem.. I've added some sanity checks in the traverser to help catch this kind of issue: https://github.com/nikic/PHP-Parser/commit/6aba7624ed268fc6d4caf633dd94c2a77fe03f55. There are two reasons why Param and a number of other places have been changed to use a Variable node:\n * Consistency: If something is a variable, it should always be represented by a Variable node rather than a string.\n * Attributes: We want to have accurate position information for all nodes, which is not possible with a raw string.\nThe second concern could be resolved by using a VarLikeIdentifier, the first concern is why I prefer Variable here.\nI'm not really familiar with phpstan, is it able to handle things like assert(is_string($param->var->name)) for the purposes of type analysis?. Does this section in the docs help? https://github.com/nikic/PHP-Parser/blob/master/doc/component/Walking_the_AST.markdown#modifying-the-ast Especially the very last example, where one statement is replaced by two statements. That seems pretty similar to what you want to do.. This is semi-intentional, in that nop nodes are empty and as such have a token end offset that comes before the token start offset (in terms of closed intervals). What is subject to interpretation here is whether the end is fixed to the start minus one or can go back further (as is currently the case when whitespace and comments are involved).\nIs the current behavior causing an issue in some context?. ctype_alnum accepts either a character string or an ASCII code. This is the usage with an ASCII code. I don't really understand why this would be wrong?. Ah, I guess this is because people expect ctype_alnum($i) to work as ctype_alnum((string) $i) rather than ctype_alnum(chr($i))? In that case we could change it to\n$c = chr($i);\n$this->labelCharMap[$c] = $i >= 0x7f || ctype_alnum($c);\nso the chr() call is explicit. Presumably that would appease the static analyzer?. There's no built-in way to do this, but you can extend the pretty printer to implement this manually. E.g. do a $node->setAttribute('fluentStyle', true) attribute and then extend the pretty printer with\nphp\nuse PhpParser\\Node\\Expr;\nuse PhpParser\\PrettyPrinter\\Standard;\nclass CustomPrettyPrinter extends Standard {\n    protected function pExpr_MethodCall(Expr\\MethodCall $node) {\n        if ($node->getAttribute('fluentStyle', false)) {\n            return $this->pDereferenceLhs($node->var)\n                 . $this->nl . '    ->' . $this->pObjectProperty($node->name)\n                 . '(' . $this->pMaybeMultiline($node->args) . ')';\n        } else {\n            return parent::pExpr_MethodCall($node);\n        }\n    }\n}. We should make the pMaybeMultiline method protected so this becomes easier in the future.. It looks like you're trying to change the doc comment on the variable node, rather than on the Stmt\\Expression node. The fact that the variable also has the doc comment is a bug (https://github.com/nikic/PHP-Parser/issues/253) and the pretty printer will ignore it. Generally assigning a doc comment only makes sense for statements.. Each node has the original node, which has start and end offsets in the token_get_all stream. Then what it does it print something like\nTokens[node.startPos .. subnode1.startPos]\nPrint(subnode1)\nTokens[subnode1.endPos .. subnode2.startPos]\nPrint(subnode2)\nTokens[subnode2.endPos .. node.endPos]\n\nwhere Print() does the same thing recursively and the offsets are always taken from the original nodes. If there is no original node (because it was replaced), then we fall back to the normal pretty printer.\nThe basic approach is very simple, the devil is in the detail.... We can't make the property private because it's a subnode (things like node dumping would break). We could mark it as @internal in phpdoc though.\nFor the record, the preferred way is to use toString(). The string cast is handy if you need to support PHP-Parser 3 and 4 at the same time.. As @m1guelpf said, if you want an unqualified reference, just use Name. Name\\Relative is for explicitly namespace-relative references that bypass the alias table.. The only thing I can recommend here is to delete the vendor directory, as well as the composer cache directory and try again. The forward slash should not be a problem, neither PHP nor Windows care about that.\nIn any case this is not an issue that can be resolved from the side of this library, as these calls are performed by composer itself. You could try reporting the issue there, but I think it's more likely that this is a cache corruption or configuration issue (do you maybe explicitly specify the \"bin-dir\" option?). What do you think about https://github.com/nikic/PHP-Parser/commit/7208b1c7ac915d37cac263045a5dc66f5cfa4f73? It will skip the property, but still parse the rest of the class. Is that good enough?. Thanks!. This is inside a strict_types=1 file, right?. Okay, makes sense, this was relying on an implicit __toString() cast before.. The behavior here was sort-of intentional with shortArraySyntax intended as the default if nothing was explicitly specified (in particular what would be used for newly inserted nodes that don't explicitly specify the attribute.) I would find it weird if a global setting had precedence over per-node settings.. The behavior is also documented as such: https://github.com/theofidry/PHP-Parser/blob/d3c6f670ede86d619fca2459deb0397d2c0b90e1/lib/PhpParser/PrettyPrinterAbstract.php#L141. Recovery from missing as implemented in https://github.com/nikic/PHP-Parser/commit/fa99c3fbfb5bece11198ae0bc62f4ef2313dff18. The valueVar will be an Expr\\Error in this case, as valueVar is a required property.\nIs this good enough for your purposes?. The first case is implemented in https://github.com/nikic/PHP-Parser/commit/01e85a26c663acb20472bb5cf17ae39743da338a. The variable will be an Expr\\Error in this case. Also works for ... and &, though I guess those are not important in practice.\nI don't think I can do the second one at this point though.. @Gert-dev I've pushed https://github.com/nikic/PHP-Parser/commit/7b201b63d2cef4ec795d52044a31d20e79e871fb which makes the function (Test) case work. As code editors usually insert () pairs, this will probably handle the common cases.. Also, while we're at it, Scalar\\Encapsed is not a scalar either, it should be Expr. Scalar\\MagicConst is borderline.. And it would probably be good to rename some node types to be more obvious to people not familiar with ext/tokenizer lingo. E.g. Encapsed should be InterpolatedString, DNumber should be Float and LNumber should be Int.\nWe can keep BC aliases for everything, of course.. There is no reference table, though if someone wants to create one, that would be great.\nGenerally my recommended approach would be to parse + dump the code you're interested in to see what nodes are used. Alternatively, if you want to familiarize yourself with all nodes types, go through the file names on https://github.com/nikic/PHP-Parser/tree/master/lib/PhpParser/Node.. @carusogabriel Yeah, something like that. Maybe could also list the subnodes?. Rendered. Would it make sense to also list the subnodes (and their types)? Or would that make things too unwieldy?. By subnodes I meant the properties of the node. So Class_ has flags, name, stmts etc.\n\nGonna try to list all of them this afternoon, so we can start to struct the files.\n\nI think it would be best to keep everything in one file, otherwise search is hard. E.g. you'd already have to know whether something is an expression or a statement to search for it.. 1. const FOO = 1, BAR = 2; is allowed in PHP.\n2. It can't be empty.\n3. See 1.\n4. There are no parent attributes unless you are adding them yourself. See https://github.com/nikic/PHP-Parser/blob/master/doc/component/FAQ.markdown#how-can-the-parent-of-a-node-be-obtained.. Can you please provide an example of what this means? I don't understand what \"add\" would do if the parent is not an array.. @theofidry Isn't this the same as using the array return value in leaveNode()? Is the feature request here to also allow this in enterNode(), or does NullNode provide some different/additional functionality?. I still don't understand what this is about. The ability to return arrays already exists and the example in https://github.com/nikic/PHP-Parser/issues/507#issuecomment-395967805 would already work with it for leaveNode. Is this about extending support for enterNode?. If this is about enterNode, then yeah I'm fine with that in principle. One tricky issue is how this will interact, in particular will the newly inserted nodes be visited by other visitors, or possibly even the visitor that inserted them?. This functionality is outside the scope of php-parser. Both problems are non-trivial and involve tradeoffs. For the call graph, typical issues are (multiple) dynamic definitions of a function, as well as virtual methods. For variables, there may be multiple reaching definitions. https://github.com/ircmaxell/php-cfg tries to solve that problem by using SSA form. However, that project is somewhat dated and not very well tested. For PHP in particular there's also the question of how accurate you want to be (e.g. wrt references and variable variables) and whether you want to perform inter-file analysis (following statically resolvable includes).\nMy best suggestion is to look at static analyzers such as https://github.com/vimeo/psalm and https://github.com/phpstan/phpstan. It's quite likely that they have code to perform at least some of the things you are interested in.. It might happen that this change needs to be reverted due to the BC break. I suspect some libraries will throw an exception if they encounter a Nop node inside a class, as it could not happen before.. I've implemented the recovery in way that works similar to missing semicolons -- I just assume that there is a comma at the error location, so you end up with two ArrayItems. See https://github.com/nikic/PHP-Parser/blob/master/test/code/parser/errorHandling/recovery.test#L1271 for examples. Does that seem reasonable?. Merged as https://github.com/nikic/PHP-Parser/commit/df64d86cf48599bdb4804c0361c4b49ed73b7530 together with a test. Thanks!. Done: https://github.com/nikic/PHP-Parser/releases/tag/v4.0.3 :). An alternative would be to add useFunction() and useConst() methods, which might be more ergonomic. What do you think?. The reason why I suggested useFunction() and useConst() is that this matches how it is written in PHP code, i.e. use function foo and use const BAR.. Merged as https://github.com/nikic/PHP-Parser/commit/53c732a96d5e50b5c93a5b7b8a074731b5411d1d with some tests in https://github.com/nikic/PHP-Parser/commit/b855c1ca237764702a9007b5a6646c2847a48a9c. Thanks!. Can you please add some tests for this functionality? Just adding it to the integration test in https://github.com/nikic/PHP-Parser/blob/master/test/PhpParser/BuilderFactoryTest.php#L253 would be a good start.. Thanks for the thorough tests! These changes are merged now :). Merged as https://github.com/nikic/PHP-Parser/commit/6751ac3c9d703f4c284358cb44d15cfd033c7087 with some tests in https://github.com/nikic/PHP-Parser/commit/0cd7207ca6062ee14422d9ab3a4bfe0c4856c896. Thanks!. There is no separate expression parser, but you can parse \"<?php EXPR_HERE; and take $stmts[0]->expr as the result.. I'm wondering if this is not better covered by the shortArraySyntax option in the pretty printer (https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinterAbstract.php#L141)? If you want to use short array syntax, you likely want to use them everywhere, rather than chose separately each time.. Fully qualified names use a different class, the correct construction code would be:\nphp\nnew Node\\Stmt\\TraitUse([\n    Node\\Name\\FullyQualified('PHPDataGen\\\\DataClassTrait')\n]);\nCreating a Node\\Name with a leading backslash should probably throw an exception to avoid this kind of issue.. Yes, that's right. Historically this is the case because Stmt\\Static_ is a statement and Stmt\\StaticVar is used within it. The plan is to fix this in the next major version, see #500.. You should either increase your nesting level or disable XDebug entirely. Disabling XDebug is strongly recommended, because it makes PHP much, much slower.. That would be due to https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinterAbstract.php#L874. Unfortunately not an easy fix. Though just special-casing the \"implements\" case might be possible.. It's definitely worth fixing, but may take a while :). I don't really see the point of this change.. Okay, I'm fine with the change as long as the empty ctor remains, for the mentioned BC reasons.. $name->toCodeString() returns a name like \\Foo\\Bar (for fully-qualified names), while the ctor expects Foo\\Bar. You likely just want to use $name->toString() instead (or just drop the ->toString() entirely).. To clarify, what your code currently does is create a fully-qualified name with components \"\", \"Foo\", \"Bar\". If you call toCodeString() on it, you'd get back \\\\Foo\\Bar. This is very likely not what you intended, which is what the new check is there to prevent.. No specific plans right now. Would it be preferable to downgrade the exception to just a deprecation warning or something? After all, even if the using code was not entirely correct beforehand, this change still is a BC break in the end.. I've reverted the check in https://github.com/nikic/PHP-Parser/commit/16c5d107ca9964eb7d8474ac42dd75f63233df54 and will reapply for the next major version.. The precise formatting of string literals is not preserved, only their content (with escape sequences resolved) is. To preserve original source code formatting (including string literals), https://github.com/nikic/PHP-Parser/blob/master/doc/component/Pretty_printing.markdown#formatting-preserving-pretty-printing can be used.. Just to be clear, the generated code still has exactly the same meaning -- none of the characters will be corrupted, they're just no longer written using hex escape sequences. Though it may be that the code is corrupted after being modified by a text editor which replaces broken UTF-8.. An alternative to the full formatting-preserving printer is https://github.com/nikic/PHP-Parser/blob/master/doc/component/Lexer.markdown#attribute-handling and extending the pretty printer to use the originalValue attribute. Especially if you know that none of your transformations modify string contents, this would be a quick fix.. Why is this an improvement?. I'm fine with adding the extra flag, though I'd appreciate a PR for this.. Thanks, looks great!. As this is both easy to implement outside of PHP-Parser and not commonly needed functionality, I'm skeptical about including this. If I were designing this class today I'd drop addVisitor/removeVisitor altogether and only accept an array on construction -- the job of this class is to traverse an AST, not to reimplement an array or priority queue.... Huh, this is a bug in PHP.. Reported as https://bugs.php.net/bug.php?id=76991.. Bug fixed upstream, and I have verified that it also fixes the PHP-Parser tests.. Thanks!. Also fixed in https://github.com/nikic/PHP-Parser/releases/tag/v4.1.0. Thanks!. This is expected, as the code is no longer valid PHP code since PHP 7.3. Looks like it was fixed in https://github.com/sebastianbergmann/diff/commit/227f803c33aad0c004f77ca61815ee8e76d94788.\nYou can restore the previous behavior by using the PhpParser\\Lexer class instead of PhpParser\\Lexer\\Emulative, but that will only work as long as you're running on PHP < 7.3. If you are running on 7.3 token_get_all() will interpret the code according to the new semantics.. The reflectionClass attribute is not being added by php-parser. My guess would be that https://github.com/Roave/BetterReflection adds this.. I've implemented this with the returnType set to null on error. Is that fine? Expr\\Error doesn't really fit here from a typesystem perspective.. @TomasVotruba Error recovery is a not a big focus of this project, but I try to support it where possible. It's basically just a matter of specifying in the grammar where errors are allowed to occur and what AST should be generated for them. The main larger thing that's not supported is handling of mismatched braces ({ without }). Luckily editors usually insert braces as a pair, so it's not such a big problem (at least that's what I tell myself :P). Hrm, this one looks really tricky. As you already noted, the $a->if($b) part is already valid code by itself, and by the point we reach the { it's going to be hard to change that.\nI'm wondering why this isn't getting interpreted as $a->if($b); {} though.. Ah, I think this happens because of the PHP \"feature\" to support arrays with both [] and {}. So actually $a->if($b){ is still valid syntax, because it could be terminated by something like $a->if($b){0};, so the error is only detected at the }.. I'm not sure how to fix this one. Especially when considering a case like ...\nphp\n$a->\nif ($b) {\n    $do->something->here();\n    //                    ^-- error detected here\n}\n... where the first error occurs very far away from the point that we really want to fix by inserting a semicolon.. We need to wait until Travis updates to PHP 7.3 RC4, which has a bug fix we need (https://bugs.php.net/bug.php?id=76991).. Restarted builds, Travis is still on an old PHP 7.3 version :(. Thanks!. See #178. Just to double check, @remicollet, you still feel the same way about not excluding any files via .gitattributes?. Is this the only occurrence of this issue?. Thanks!. The problem here is probably in the JSON encoding. JSON only allows valid UTF-8 in strings, and \\x7f is not a valid UTF-8 sequence.. Thanks!. I haven't looked into this issue yet, but usually \"undefined offset\" errors are a result of a bug in the generated parser or the parsing algorithm. It may be that adding these extra productions fixes this particular case, but the issue may appear through some other way. I'll try to look at some parser traces tomorrow.. You're right that comma_or_error is at fault here. I pushed a different fix at f42bbc2403ebc1178d9ae4f1029c0e8ddc6aa451 which simply removes the code generating the notice.\nIf no explicit action for a production is given, it defaults to performing $$=$1, which does not make a lot of sense for error, which will generally not have any meaningful value. This change just suppresses this default.. Does any of your code / dependencies give each anonymous class a unique name, or similar?. I've dropped the assert. It's not really important for me whether this is null, and having a name for anon classes is probably quite useful for many purposes.. You can add the method using $node->stmts[] = $method. To create the method, the easiest way should be to use the builder API: https://github.com/nikic/PHP-Parser/blob/master/doc/component/AST_builders.markdown See in particular the part starting with $factory->method('someMethod').. The issue here is that new Array_([1, 2, 3]) is not a valid node, it should be something like new Array_([new ArrayElem(new LNumber(1)), ...]), which is of course not very convenient to create. The builder automatically convert literals to the corresponding node trees, but you have to pass the actual literal, i.e. ->setDefault([1, 2, 3]) rather than ->setDefault(new Array_([1, 2, 3])).\nThis doesn't allow you to specify the array kind, but (unless you need a mix of short and long syntax) you can also handle this by constructing the pretty printer with the ['shortArraySyntax' => true] option. That should be easier than specifying the desired syntax everywhere.. Thanks!. Thanks :). These grammar productions are shared between array literals (which don't allow empty elements) and array destructuring (which does), so it's not possible to just modify the grammar here. Instead I would suggest to add a checkArray() method to the ParserAbstract class, which (recursively) checks for null elements and generates the same \"Cannot use empty array elements in arrays\" error message as PHP does. checkArray() would then be called from dereferencable_scalar.. Implemented in #565.. Merged as https://github.com/nikic/PHP-Parser/commit/0ef61b49bb787b4da846eb18cda44936e5484ce9, thanks :). Probably something like this can be made based on reflection. Constructor argument names should match subnodes names and it should be possible to generate code based on that.. @flip111 Class_::$name is a subnode. Break_::$num is a subnode. With reflection, the property Class_::$name can be associated with the $name argument of the constructor. For Class_ in particular there is also the $subNodes argument, into which everything should go for which there is no explicit constructor argument. I think with these two things combines (checking for argument with the same name as property, and handling $subNodes specially) it should be possible to cover all nodes.. @flip111 By subnodes I mean anything returned here: https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Stmt/Class_.php#L47 All subnodes are public properties of the class.. Missing a pretty-printer test (or add to an existing one).\nMissing support for adding/removing property types in formatting preserving pretty printer, but I think this is going to be quite hard to do, at least for the insert case.. Merged as https://github.com/nikic/PHP-Parser/commit/af8c729603cd972b277697d5cb3f36ef3f10ca76. Thanks!. count() inside a namespace can refer either to the global builtin function count(), or a count() function in the current namespace. Without further information (e.g. from scanning the whole project and collecting all functions), it's not possible to know which is the case.\nIt's a reasonable default assumption that this refers to the global count() though -- if you want to make this assumption, just ignore the namespacedName attribute. It's there in case you want to handle namespaced functions as well.. IMHO preserving this is the job of the formatting preserving pretty printer.. @TomasVotruba There shouldn't be any special support for it, this should work out of the box based on the list insertion/deletion handling.\nAre you hitting cases where the trailing comma is lost despite using the formatting preserving printer?. Not a fan of the yield changes, but otherwise this looks good.. Thanks!. Yes, it should use T_COALESCE_EQUAL. If we run on a PHP version that does not have it, then we need to emulate it in Lexer\\Emulative, by combining a T_COALESCE and a '=' token into a T_COALESCE_ASSIGN token.. Not sure what's up with the test failure. Token 392 on PHP 7.1 is E_ERROR, but I don't really see why it would occur in this situation.. Okay, I believe this issue here is that the token is not used in the PHP 5 parser and thus gets dropped from the translation table. It would be fine if you just add support for ??= to the PHP 5 parser as well.\nOne thing that's missing here is a parser test for ??=. If ??= is supported in the PHP 5 parser as well, you can just add it into test/code/parser/expr/assign.test.. Merged as https://github.com/nikic/PHP-Parser/commit/9de96821f72851b4972abf417e24e33936106e2a. Thanks :). Done: https://github.com/nikic/PHP-Parser/releases/tag/v4.2.1. PHP requires <?php to be followed by whitespace, so a standalone <?php is indeed a syntax error. See also https://3v4l.org/kuLmD.. The code is indeed risky, but used only by developers to generate files. It is not part of the library itself and will never be called by users of the library.. You need to use function app\\func as func;. Otherwise the alias applies to classes, not functions.. $factory->methodCall(new Node\\Expr\\Variable('p'),'onBefore') is an expression. To make it into a statement (followed by ;) it needs to be wrapped in an expression statement (Node\\Stmt\\Expression).. This should work already: https://github.com/nikic/PHP-Parser/blob/master/grammar/php7.y#L495 It's present in both the PHP 5 and PHP 7 parsers.. @TomasVotruba The error likely comes from something other than PhpParser.. Why do you include the file? Isn't the whole point of static analysis that it is, well, static?. You need to wrap the expression with <?php before and ; after to make it valid PHP. Then PHP-Parser should be able to parser it.. I think this makes sense, but would need some major (backwards incompatible) changes. Especially as properly supporting this would also require changing the structure of lots of other nodes that currently have a stmts array, but in reality on have a single stmt. E.g. if ($x) { ... } is really if ($x) stmt; with the single statement being a block.. I'm not really sure on this one. Just erasing the statements seems more convenient here, especially in combination with the method builder. On the other hand modifying the passed node may lead to odd behavior if it is reused elsewhere. I'm leaving the behavior for now.\n. I'd prefer to break here as the name removeVisitor implies that only one visitor will be removed (or not?)\n. Why does this default to true? Shouldn't it use the normal append behavior by default?\n. The check is only there to ensure that all floats are printed in such a way that PHP recognizes them as floats, rather than integers. E.g. 42.0 should be printed as 42.0 and not as 42, otherwise you could end up with a mild behavioral difference. Scientific notation doesn't have this problem, because XeY is always a float.\n. The $ here is missing a variable name -- that's probably what's causing the issue.\nThe error message in the test is really bad though, that should be done better...\n. Should be in the @return as well. A few more builder classes are also affected, e.g. FunctionLike::setReturnType and Param::setTypeHint. It would be better to handle this as a top-level case in the enterNode method (rather than handling the specific places where it can occur, which are likely to grow). Unfortunately, this (and the same change elsewhere) isn't correct, because PHP-Parser represents expression statements (expr;) as their expressions, without an additional wrapper. As such, the statements may also contain Node\\Expr nodes, which are not children of Node\\Stmt.. For the case of namespace-fallback, this will do something like:\n$name->originalName = clone $originalName;\n$name->namespacedName = FullyQualified::concat($namespace, $name);\nreturn $name;\n\nIn this case $name is still the original name with an extra attribute, so originalName is redundant. However, I guess it's still good to do this for consistency.. I'm referring to the case when https://github.com/felixfbecker/PHP-Parser/blob/1b5969cc36ae1ef98f6acfa0a78c2cc24dd5739c/lib/PhpParser/NodeVisitor/NameResolver.php#L241-L245 is hit.. Shouldn't this type infer to int|float, as strlen() returns int?. Seen above that Psalm also supports something like @psalm-return array{nodeType:string, text:mixed, line:mixed, filePos:mixed}. If this here were @psalm-return array{0:null|Node\\Stmt[], 1:null|Error} then the list() unpacking in the method above could see that Error is not a possible return type.. PHP does not distinguish between integer keys and integral string keys. So here all of [$a, $b], [0 => $a, 1 => $b] and [\"0\" => $a, \"1\" => $b] are equivalent (both in terms of array creation and unpacking). I'm fine with just stripping the return type, just wondering why Psalm makes this distinction, i.e., why are \"shapes\" only created for arrays with string keys, rather than also arrays with fixed-structure integral keys? Is this because there might be false positives where such a return value is intended as a normal array (which just happens to have the same non-uniform types on all paths) rather than a shape?. Noticed while merging: This return type is off. It should be inferred as string|Name|Node\\Identifier, as there are return $names and a return new Node\\Identifier via ternary.. Fixed this issue in a different way with https://github.com/nikic/PHP-Parser/commit/d287c167bc3cc9cc34e3e4da3a7d9282b14b6e90. As this is a genuine bug landed in 3.x. (The check implemented here is causing the build failure on Travis.). This annotation isn't correct, because the array doesn't necessarily contain nodes. For example, the Name::$parts subnode is an array of strings.\nAlso, Node[][] is not actually possible here -- I just dropped the code for handling this case and made it throw an exception instead: https://github.com/nikic/PHP-Parser/commit/2b6804aa507354e89f2cd108858fb3d74027e2e3. I've implemented a stricter version of this check in https://github.com/nikic/PHP-Parser/commit/2b72bae3d9ad3eeef4f013de584cfd28963d7c50. Now all return values from enterNode and leaveNode which are not explicitly handled in some way will throw.. Why is this cast necessary? Does it exclude a possible false return value from strpos?. This one should be just array.. Method names in PHP are case-insensitive, so this should do a strtolower call first.. Additionally, I would suggest to convert MAGIC_NAMES into a map (see for example https://github.com/DragorWW/PHP-Parser/blob/00d3ca3ccdeb14480a55af6c47d1ca9bd5e9cde7/lib/PhpParser/Node/Stmt/Class_.php#L28) and then check whether it is a magic method using isset(). This is more efficient than using in_array.. Yeah, looks like the const array currently breaks the build on 5.6 and on HHVM.. With this format I'd suggest adding the function prefix.. Can you please change this to a lowercase null, to be consistent with other type declarations?. Why this property?. Why the extra return type? I don't see a non-Expr return value.. Why this extra type? I think there is some confusion between 3.x branch and master maybe?. Yes, the type hint should be (Node|null)[]. If PhpStorm supports it correctly, I remember that there might be an issue.. In that case the strpos call here should be dropped. It was originally added to deal with the same issue. But this solution (using ::class) looks better.. Could you please also fix this one?. I believe [] = syntax uses Array_.. Looks like there's a copy&paste mistake here :). Not sure if we should have this method if the ctor already accepts a list of traits.. Class constant visibility is only available since PHP 7.1, while this library still supports 7.0. I think this did not fail the build because the class is currently not used in any test.. These should be using \\LogicException::class etc.. This one probably shouldn't change, as it this is just a dummy name, not referring to any real class. Static analyzers will probably complain about it.. Same here.. This can be simplified to Error::class.. This can be simplified to ConstExprEvaluationException::class.. Can also be simplified.. Can be simplified.. Just the ones that do not need imports, like this one.. The class is already imported in this file, so it can be used directly as well :). This should probably come after the checks below, otherwise the visitor that returned DONT_TRAVERSE_CURRENT_AND_CHILDREN  in enterNode will not be able to perform a replacement in leaveNode.. nit: Indentation is off by one.. The duplication of the sentence structure here sounds a bit awkward. I'd suggest combining with the previous paragraph into something like\n\nThe enterNode() method can additionally return the value NodeTraverser::DONT_TRAVERSE_CHILDREN, which instructs the traverser to skip all children of the current node. To furthermore prevent subsequent visitors from visiting the current node, NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN can be used instead.. Could you please also rename the variable to $jsonDecoder?. The trailing _ here is not necessary. It's only used in Array_ to avoid clashing with the reserved keyword.. This will also have to check the array recursively to catch cases like $x = [1, [2,,,,]];.. Things like (  float  ) should also be handled.. Maybe only check if it contains float/real/double, rather than exact equality?. Add !!php7 before this line.. The [] should be attributes().. More precisely, the whole thing should be new Stmt\\Property($1, $3, attributes(), $2).. This list is outdated, let's be less specific here. Also Identifier is allowed here.. Identifier is also allowed here. Instead of \"Typehint\" better just \"Type\" or \"Type declaration\".. type should come before props here. These are in the same order as in the source code.. This should use resolveType(). Tests should checks that something like public ?Foo $bar is correctly resolved.. The order here is important for pretty printing (see failing test), because it assumes that subnodes never occur out of order. Matching the order in the ctor isn't necessary (and also not done in all other cases -- often the required parts are not necessarily first in code order).. Can you please extract this into a method on ParserAbstract to avoid the code duplication? $this->getCastKind($1) or similar.. The Stmt\\Property[$x] syntax is short for new Stmt\\Property($x, attributes()). So if you manually pass attributes, you should write the new out explicitly. Otherwise it will be converted into new Stmt\\Property($1, $3, attributes(), 2, attributes()), which PHP allows but is also redundant.. This should have non-standard formatting somewhere, otherwise you can't see whether formatting is preserved or not.\n\npublic ?float $b\n    = 1.0;\nmaybe.. Stmt_Property->type needs to be added to https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinterAbstract.php#L1184 using $stripRight to make this work correctly.. Stmt_Property->type needs to be added to https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinterAbstract.php#L1224, but I don't think it's going to work out of the box. You can try adding [null, null, ' '] and see what happens.. Okay, that's about what I expected. Instead of using [null, null, ' '] we need [\\T_VARIABLE, null, ' '] plus a way to avoid the + 1 here: https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/PrettyPrinterAbstract.php#L622 That is, we want to insert before the token rather than after it.\nFor example, we could change the code to:\nlist($findToken, $beforeToken, $extraLeft, $extraRight) = $this->insertionMap[$key];\n                if (null !== $findToken) {\n                    $subStartPos = $this->origTokens->findRight($pos, $findToken)\n                                 + (int) !$beforeToken;\n                } else {\n                    $subStartPos = $pos;\n                }\nAnd change the format of the data array to [\\T_VARIABLE, true, null, ' ']. (and [x, false, x, x] for all others). It's ugly, but I don't see a much better way.. This should be merged with optional_param_type, as the implementation is the same. Could be called just optional_type then.. Can you please add public ?Foo $prop; here as well?. The way PHPUnit works, using generators for data providers unfortunately doesn't make much sense. They will end up materialized as arrays anyway.. With the autoload-dev change, possibly these requires can be dropped?. This should be added to the list on line 13 instead.. This is the precedence value, which should be the same as for all the other AssignOp's, so this is correct.. This type doesn't look useful (and is technically incorrect).. STING -> STRING. This line should probably go into the constructor instead.. The code here should check 7.4, in which case it looks for ??=, then check 7.3, in which case we additionally look for flexible heredoc. There is no point in checking heredoc if we're already running on 7.3.. Unnecessary formatting change. This project does not follow the \"bad parts\" of PSR-2 ;). It should also be added here: https://github.com/nikic/PHP-Parser/blob/716e827d7f10c8cee7760015ad76b954205e5aaa/lib/PhpParser/PrettyPrinterAbstract.php#L1156. ",
    "fabpot": "Fantastic, thanks!\n. ",
    "schmittjoh": "Unfortunately, the type inference that I'm doing is not generic, but makes some assumptions about the underlying code (https://github.com/schmittjoh/JMSTranslationBundle/blob/master/Translation/Extractor/File/FormExtractor.php).\nYou're probably right that it's better to implement something like this in a separate library, one thing however, that we could add quite easily is resolving the class aliases to the fully qualified class names. For example, right now if you have a parameter node which has a type hint, you need to gather and process the use statements yourself, I think this could already be done for you so that you can access the fully qualified name in addition to the short name as used in the code. That would already help a bit, what do you think?\n. Thanks, I've tested it with my code, and looks good.\nOne thing I ran into is that the PHPParser_Node_Stmt_Class->name only contains the short name. What do you think about making two properties (short name, and name for the fully qualified name)?\n. Hm, thinking about this, how about just replacing the name with the fully qualified name? If someone needs the short name he could still split it off easily.\n. Yes, that would be best: \"git tag some-version\"\n. Thanks.\nOn Thu, Jan 5, 2012 at 12:47 PM, nikic <\nreply@reply.github.com\n\nwrote:\nI added the tag and submitted it:\nhttp://packagist.org/packages/nikic/php-parser\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/nikic/PHP-Parser/pull/9#issuecomment-3368749\n. Do you have something like a \"Finder\" already because I have experimenting with that as well?\n. I see.\n\n@nikic, do you think we can make node traversal a bit easier? Right now, it always requires a visitor which is intended for modifying the code. I only need to traverse over the elements to do some analysis and do not want to replace any nodes.\nI'm thinking about something like:\nphp\nforeach (new RecursiveIteratorIterator($node) as $anyChildNode) {\n    // iterates over all child nodes, and child's child nodes, etc.\n}\nDo you think that is feasible?\n. I need it for example to get the next/previous/parent relation correct, see #17.\nHowever, I have discovered some other areas where I might want different nodes (names for example which are sometimes PHP_Node_Name, sometimes strings). So, I'm not sure how much we should change the AST in your library, or if the better approach is to just run a visitor over the AST which normalizes it into a format that I need in my code. Your current AST is better for performance at least.\n. I merely view the nodes in a tree, and if they are siblings, then I connect them with eachother.\nThe main problem here are arrays, which we cannot connect to. So, if you don't think it's a good idea to connect the switch condition to a specific case block, then we could introduce a wrapper for all case blocks, and connect the switch condition to that.\nRegarding the order, IMO it should always appear in the same order like it appears in the code. Therefore, I think a switch condition should always come before the case statements. Why would you change that?\n. @nikic, what's the state here? Do you think it's worth including this?\n. I use it for control-flow/data-flow analysis, and there it is paramount that the order is kept intact, otherwise you end up with a control flow that does not resemble the PHP code. \"next\" is specifically used to determine the next node in the control-flow. \nI haven't seen a problem with ->name yet. Probably mostly, because it does not change the control flow.\nAs an example, consider the following:\nphp\n$a = $c = null;\n$b = new Foo();\nif ($a = $b) {\n   $c = $a;\n}\nIf the if statement's statements are coming before it's condition, a data-flow analysis would think that $c is null while it is actually an instance of Foo.\n. Re-considering this, while previous/next make sense for some nodes, there are cases where it does not work like what @nikic pointed out. Ideally, we would only add them where it makes sense, but that would require reviewing all nodes for which I do not have time atm :/\nFor that reason, I'd propose that I keep this in my code for now, and we close this?\n. Alright, closing this.\n@sebastianbergmann, I've open-sourced the code at: https://github.com/scrutinizer-ci/php-analyzer\n. Some analyzers need to build up information that can be used by successing analyzers, and for that they most of the time need to traverse the entire AST.\nHowever, my current implementation looks already much more complex than when I made this PR. So, I'll close this as the current traverser should be sufficient for most people.\n. Thanks for the fast fix :)\n. Maybe add a comment that it is only present if the respective visitor has been added?\n. Not sure, it won't be part of the traversal anymore then.\n. My fault, I had tried an optimization in the abstract node, and was not aware that I still had these changes in there. Works fine with current master :)\n. According to xhprof, a lot of time is spent in the getIterator method. So, I replaced \\IteratorAggregate with \\Iterator, but it was not really leading to anything significant.\nI then disabled the garbage collection which resulted in performance improvements of 75-100 times (at the cost of a bit more memory consumption), and forgot to revert the changes.\n. Why not storing whitespace information in the existing nodes as attributes?\n. You would need to create a custom format per node, but a separate structure makes all code that is written for the current structure incompatible which would be a huge drawback from my pov at least.\n. This sounds very similar to the approach that I follow in php-manipulator.\nThe usage there is basically to jump to an AST node that you are interested in re-writing, at which point you would which to the token stream, re-write the node, and then switch back to the AST stream. If you can provide some mechanisms to make the mapping of AST node to tokens that would help me to simplify that code.\n. That would break BC unfortunately, so I won't be able to use it in the foreseeable future. \nHowever, if you think that is the way to go, should we close this maybe?\n. Alright, will maintain this in my fork for now, and re-visit when I've time to upgrade to newer versions.\n. ",
    "heinep": "Hi there\nWe are two students which are using your parser for detecting security vulnerabilities, and in this case we want to know each time we reach a sensitive sink. When we reach the PHPParser_Node_Expr_Include node, we return a new parsed tree of the file that was included, to get a full sized tree with all static included files.\nWe actually don't known if this is the most efficient way to do this, but it seemed to be the obvious \"hack\". Currently we keep track of all function and class definitions in all static included files, and somehow we have to determine in which file and in which line a vulnerability arise.\n. Some sort of NodeContext would definitely be a better approach. I don't think we have the time for optimizing the small changes that we already did, so we hope that a better solution is adapted somehow in a later release.\nThanks for listening.\n. It seems to be a way more elegant solution. Thanks for implementing and documenting this :)\n. ",
    "mneuhaus": "I've created a little Experiment a few days ago to try your Parser. You can take a look at the example in the readme to get a feeling for what kind of API i'm aiming for:\nhttps://github.com/mneuhaus/CodeBuilder\n. Hey @nikic \ngreat to hear you're open to such additions :) i think this could be benefitial for a lot of frameworks providing kickstarters and such :)\nYea, kind of overlooked the magic getter at first. forget those.\nThe getByType is basically a shortcut to filter the SubStatements based on a specific type. I've Put this into the NodeAbstract Class:\nPHP\n<?php\n    public function getByType($type) {\n        $results = array();\n        if(is_array($this->stmts)){\n            foreach ($this->stmts as $key => $value) {\n                if($value->getType() == \"Stmt_\" . $type){\n                    $results[] = $value;\n                }\n            }\n        }\n        return $results;\n    }\n?>\nI mainly use this function to implement the getMethod() and getProperties():\n``` PHP\n<?php\n    public function getMethods() {\n        return $this->getByType(\"ClassMethod\");\n    }\npublic function getProperties() {\n    return $this->getByType(\"Property\");\n}\n\n?>\n```\nI'm currently already working on some parts of this api. i've now chosen to put it into the statements itself instead of a separate class.  A Fluent interface would indeed by also quite desirable.\ni've even toyed with the idea of a rudimentary way to replace placeholders inside statements. Basically i thought about serializing. That way you could create \"Template\" classes which contain the needed logic statements inside the functions which you could reuse to add to newly created functions. \nExample:\nPHP\n<?php\nclass Template {\n    public function setProperty($___property) {\n        $this->___property = $___property;\n    }\n}\n?>\nThen you could load this Template and do something like this:\n``` PHP\n<?php\n$template = $builder->parse(\"Template.php\");\n$newClass = $builder->class(\"NewClass\");\n$method = $template->getMethod(\"setProperty\");\n$method->name = \"setTitle\";\n$method->replace(\"property\", \"Title\");\n$newClass->addMethod($method);\n$newClass->build();\n?>\n```\nTo get this:\nPHP\n<?php\nclass NewClass {\n    public function setTitle($title) {\n        $this->title = $title;\n    }\n}\n?>\nTo do this replacement i would just serialize the statements, str_replace(\"___\" . $from, $to) and then unserialize.\nMy head is kind of spinning because of the possibilities with this :D\n. Another quite \"simple\" way to realize templates could be:\n1. to load the contents of \"Template.php\"\n2. apply transformations with str_replace\n3. parse transformed code\n``` PHP\n<?php\nclass Template extends Builder {\npublic function __construct($file) {\n    $this->content = file_get_contents($file);\n}\n\npublic function getMethod($name, $replacements = array()) {\n    $content = $this->content;\n\n    foreach ($replacements as $key => $value) {\n        $content = str_replace(\"__\" . $key, $value, $content);\n    }\n    $ast = $this->parse($content);\n\n    return $ast->getMethod($name);\n}\n\n}\n$template = new Template(\"Template.php\");\n$newClass = $builder->class(\"NewClass\");\n$method = $template->getMethod(\"setProperty\", array(\"property\" => \"Title\") );\n$method->name = \"setTitle\";\n$newClass->addMethod($method);\n$newClass->build();\n?>\n```\nI think such a simple replacement should cover 90%+ of the usecases. \nThis could be a little performance hit in case of big Templates, but i think perfomance is for such a Builder quite unimportant, since it will probably only be used by developers.\n\nBuilding the AST up by hand is quite a hassle and leads to ugly code.\n\nI absolutly agree. I think there should only be a api to do structural things, not logic. Classes, Methods, Properties, Namespaces.\n. I've just coded some initial stuff: Commit: Added Builder, Template and some Usability Methods\n- added Builder to parse, render and create classes\n- added Template to transform existing PHP code\n- added TYPO3CGL PrettyPrinter ( Clone of Zend with a few changes. Properties first then Methods, sort by Alphabet, ...)\n- added tests/Builder/Test.php with an example\n- added some utility functions to Class, Property, Method and NodeAbstract\nTest.php:\n``` PHP\n<?php\nrequire_once dirname(FILE) . '/../bootstrap.php';\n$newClass = PHPParser_Builder::createClass(\"NewClass\");\n// Get all Statements from the Template and add them to the new Class\n$propertyTemplate = new PHPParser_Template(dirname(FILE) . \"/Templates/PropertyTemplate.php\");\n$newClass->add($propertyTemplate->getStatements(array(\"property\" => \"title\")));\n$newClass->add($propertyTemplate->getStatements(array(\"property\" => \"description\")));\n$newClass->add($propertyTemplate->getStatements(array(\"property\" => \"created\")));\n// Get a single Method from the Template\n$propertyTemplate = new PHPParser_Template(dirname(FILE) . \"/Templates/MethodsTemplate.php\");\n$newClass->add($propertyTemplate->getMethod(\"someNonesense\"));\necho \"\";\necho htmlspecialchars(PHPParser_Builder::render($newClass));\necho \"\";\n```\nResult: \n``` PHP\n<?php \nclass NewClass {\n    /\n     * My awesome Created\n     *\n     * @var string\n     /\n    protected $created;\n/**\n * My awesome Description\n *\n * @var string\n **/\nprotected $description;\n\n/**\n * My awesome Title\n *\n * @var string\n **/\nprotected $title;\n\n/**\n * Getter for created\n *\n * @return string\n **/\npublic function getCreated() {\n    return $this->created;\n}\n\n/**\n * Getter for description\n *\n * @return string\n **/\npublic function getDescription() {\n    return $this->description;\n}\n\n/**\n * Getter for title\n *\n * @return string\n **/\npublic function getTitle() {\n    return $this->title;\n}\n\n/**\n * Setter for created\n *\n * @param string $created\n **/\npublic function setCreated($created) {\n    if ($created == 'foo') {\n        throw new Exception('Foo isn\\'t allowed here...', 1);\n    }\n    $this->created = $created;\n}\n\n/**\n * Setter for description\n *\n * @param string $description\n **/\npublic function setDescription($description) {\n    if ($description == 'foo') {\n        throw new Exception('Foo isn\\'t allowed here...', 1);\n    }\n    $this->description = $description;\n}\n\n/**\n * Setter for title\n *\n * @param string $title\n **/\npublic function setTitle($title) {\n    if ($title == 'foo') {\n        throw new Exception('Foo isn\\'t allowed here...', 1);\n    }\n    $this->title = $title;\n}\n\n/**\n * Some nonesense Method\n *\n **/\npublic function someNonesense() {\n    $nonsense = array('foo', 'bar');\n    foreach ($nonsense as $key => $value) {\n        $nonsense[$key] = str_replace('foo', 'bar', $value);\n    }\n    return $nonesense;\n}\n\n}\n```\n. i've just had a idea for a more \"fluid\" interface:\n``` PHP\n<?php\n$template = new PHPParser_Template(dirname(FILE) . \"/Templates/PropertiesTemplate.php\");\n$newClass->add(\n    $propertyTemplate->from(\"StringPropertyClass\")\n                     ->with(array(\"property\" => \"title\"))\n                     ->getStatements()\n);\n$newClass->add(\n    $propertyTemplate->from(\"DatetimePropertyClass\")\n                     ->with(array(\"property\" => \"created\"))\n                     ->getStatements()\n);\n$newClass->add(\n    $propertyTemplate->from(\"StringPropertyClass\")\n                     ->with(array(\"property\" => \"created\")\n                     ->getMethod(\"get__Property\")\n);\n?>\n```\nThis way you could group several classes in one template and choose from them through \"from([classname])\".\n. I've just commited some changes to my fork: Moved most of the Logic to the Builder\nChanges:\n- Moved most of the Logic to the Builder\n- The Builder gets instanciated with a path to a folder containing template files\n- added the function \"from\" to load the appropriate template\n- added the function \"with\" to set the context\nTest.php:\n``` php\n<?php\nrequire_once dirname(FILE) . '/../bootstrap.php';\n$newClass = PHPParser_Builder::createClass(\"Party\");\n/*\n * Dir Templates:\n * Templates\n *  - Property\n *     - DateTime.php\n *     - Relation.php\n *     - String.php\n/\n$builder = new PHPParser_Builder(dirname(FILE) . \"/Templates/\");\n$newClass->add(\n    $builder->from(\"Property_String\")\n            ->with(array(\"property\" => \"title\"))\n            ->getStatements());\n$newClass->add(\n    $builder->from(\"Property_Relation\")\n            ->with(array(\n                \"property\" => \"guest\",\n                \"properties\" => \"guests\", \n                \"class\" => \"Guest\"))\n            ->getStatements());\n$newClass->add(\n    $builder->from(\"Property_DateTime\")\n            ->with(array(\"property\" => \"date\"))\n            ->getStatements());\necho \"\";\necho htmlspecialchars(PHPParser_Builder::render($newClass));\necho \"\";\n?>\n```\nHere's the result: <?php class Party {...\nSome thinks that came additionally to my mind we need to adress:\n- existing functions shouldn't replaced. this could possibly be tackled by something like $class->add($stmts, $override = true|false)\n- i haven't tested the above with namespaces yet\n- maybe it should support multiple classes in one file as well, although this isn't really done in most projects\n- more and more frameworks(Doctrine2, FLOW3, Symfony2,...) use the docblocks as configuration areas, so it would be awesome to be able to parse and render them as well. Here's an example from FLOW3: \nPHP\n<?php\n/**\n *\n * @FLOW3\\Scope(\"prototype\")\n * @Admin\\Active\n * @Admin\\Group(\"Testcases\")\n * @Admin\\Set(title=\"Default Types\", properties=\"string,integer,float,boolean,date,time,datetime,resource,tag,tags\")\n */\nclass Widgets{\n    ...\n    /**\n     * @var \\Doctrine\\Common\\Collections\\Collection<\\AdminDemo\\Domain\\Model\\Address>\n     * @ORM\\ManyToMany(inversedBy=\"widgets_manytomany\")\n     * @Admin\\Widget(\"Chosen\")\n     */\n    protected $addressesChosen;\n        ...\n}\nFLOW3 uses the Doctrine2 Parser to parse these statements, the problem is that for that Parser to Work you need appropriate AnnotationClasses like Admin\\Annotations[Group|Active|Set|...] which would be very dependend on that library. And it wouldn't provide the opposite direction to render these docblocks again. \nI Hope i'm not going overboard with all my crazy ideas :D\n. Sorry for spamming this issue, but i've just tackled the conflict management as well:\ni introduced 4 new constants to define the behavior in case of a conflict:\n- CONFLICT_IGNORE\n- CONFLICT_REPLACE\n- CONFLICT_APPEND\n- CONFLICT_PREPEND\n``` PHP\n<?php\n$party->add(\n    $builder->from(\"Property_Relation\")\n            ->with(array(\n                \"property\" => \"guest\",\n                \"properties\" => \"guests\", \n                \"class\" => \"Guest\"))\n            ->getStatements());\n// This call adds all statements problem is, that the __construct already exists\n// By Default CONFLICT_IGNORE will ignore this new _construct in favor of the existing\n// since we now this construct only has a new initiation in it we specify \n// CONFLICT_APPEND as second argument, to append the Methods logic to \n// methods that already exist\n$party->add($builder->from(\"Property_Relation\")\n            ->with(array(\n                \"property\" => \"beer\",\n                \"properties\" => \"beers\",\n                \"class\" => \"Beer\"))\n            ->getStatements(), PHPParser_Builder::CONFLICT_APPEND);\n```\n. I also thought about introducing more complex template logic, maybe simply through Twig itself ( no need to reinvent all that power :), but i think this shouldn't be necessary. In my honest opinion i would keep the Templates as simple and syntactically correct as possible. By doing this one could event UnitTest it's Templates easily. \nA compromise could be a real simple syntax to allow some filters: \n- __name|ucfirst\n- __params|toList\n- __stmts|prettyPrint\ni used the | character as an example here, since it would make the PHP code syntactically incorrect. I'm uncertain which other non Alphanumeric characters beside from \"_\" are valid in all different Cotexts (MethodNames, ClassName, PropertyNames, Statements etc. )\n:)\n. i'm just reading through this Post: Exotic names for methods, constants, variables and fields - Bug or Feature?\nThe usage of fancy special characters is strongly discouraged in general, but in our very special case this might be a valid place to use of character that stands out enough among the regular alphabet.\n. Here's an example, i've used \u00a7 to encapsulate the variables and \u00b0 to apply filters, both of these characters are accessable through most keyboard and valid to the php interpreter:\n``` PHP\n<?php\nclass PropertyString {\n    /\n     * My awesome \u00a7name\u00b0ucfirst\u00a7\n     *\n     * @var string\n     /\n    protected $\u00a7name\u00a7;\n/**\n * Getter for \u00a7name\u00a7\n *\n * @return string\n **/\npublic function get\u00a7name\u00b0ucfirst\u00a7() {\n    return $this->\u00a7name\u00a7;\n}\n\n/**\n * Setter for \u00a7name\u00b0ucfirst\u00a7\n *\n * @param string $\u00a7name\u00a7\n **/\npublic function set\u00a7name\u00b0ucfirst\u00a7($\u00a7name\u00a7) {\n    $this->\u00a7name\u00a7 = $\u00a7name\u00a7;\n}\n\n}\nnew PropertyString();\n?>\n```\n. Yea, i'm not that fond of special characters either, but putting characters of PHP's Syntax in places they don't belong at all doesn't feel that much better either. \nAs i said, i think 90%+ of the use cases will suffice with a simple replacement like in my examples above.\nSome UseCases that i know of:\nModels(FLOW3):\n``` PHP\n<?php\nclass Event {\n    /\n     * @var string\n     /\n    protected $title;\n/**\n * @var SplObjectStorage<Guest>\n **/\nprotected $guests;\n\n/**\n * @return void\n **/\npublic function __construct() {\n    $this->guests = new SplObjectStorage();\n}\n\n/**\n * @param Guest $guest\n * @return void\n */\npublic function addGuest(Guest $guest) {\n    if (!$guest instanceof Guest) {\n        throw new Exception('Only Guest allowed', 1);\n    }\n    $this->guests->attach($guest);\n}\n\n/**\n * @return DateTime\n **/\npublic function getDate() {\n    return $this->date;\n}\n\n/**\n * @return SplObjectStorage\n **/\npublic function getGuest() {\n    return $this->guests;\n}\n\n/**\n * @return string\n **/\npublic function getTitle() {\n    return $this->title;\n}\n\n/**\n * @param Guest $guest The Guest to be removed\n * @return void\n */\npublic function removeGuest(Guest $guest) {\n    $this->guests->detach($guest);\n}\n\n/**\n * @param DateTime $date\n **/\npublic function setDate($date) {\n    $this->date = $date;\n}\n\n/**\n * @param SplObjectStorage $guest\n **/\npublic function setGuest($guest) {\n    $this->guests = $guest;\n}\n\n/**\n * @param string $title\n **/\npublic function setTitle($title) {\n    $this->title = $title;\n}\n\n}\n?>\n```\nController(FLOW3):\n``` PHP\n<?php\nclass EventController {\n    public function indexAction(){\n}\n\n}\n?>\n```\nModelProxies(Doctrine2):\nDoctrine2 uses some automatic processing to create ProxyClasses for Models to be loaded by using the Models Getters and Setters\n``` PHP\n<?php\nclass EventProxy extends Event implements Proxy\n    /* @private /\n    public function load()\n    {\n        if (!$this->__isInitialized && $this->_entityPersister) {\n            $this->isInitialized = true;\n            if ($this->_entityPersister->load($this->_identifier, $this) === null) {\n                throw new \\Doctrine\\ORM\\EntityNotFoundException();\n            }\n            unset($this->_entityPersister, $this->_identifier);\n            if (is_callable(array($this, '__wakeup'))) {\n                $this->__wakeup();\n            }\n        }\n    }\n/**\n * @return string\n **/\npublic function getTitle() {\n    $this->__load();\n    return parent::getTitle();\n}\n\n/**\n * @param string $title\n **/\npublic function setTitle($title) {\n    $this->__load();\n    return parent::setTitle($title);\n}\n\n...\n\n}\n```\nAs you can see, most of these could simply be done with a simple String Replacement. The Only one that's kind of more Complex is the ModelProxy. But this Example could be created like this:\n``` PHP\n<?php\n$proxy = $builder->class(\"Proxy\")->extends(\"Event\")->implements(\"Proxy\");\n$proxy->add(\n    $builder->from(\"ProxyTemplate\")\n            ->getMethod(\"__load\"));\n$methods = $builder->from(\"Event\")->getMethods();\nforeach ($methods as $method) {\n    $newMethod = clone $method;\n    $newMethod->stmts = // Logic to load and call it's parent\n    $party->add($newMethod);\n}\n?>\n```\nAnother way could be to use double \"\" and single \"\" or tripple \"___\"\nDouble and Single:\n``` PHP\n<?php\nclass PropertyString {\n    /\n     * My awesome name_ucfirst\n     *\n     * @var string\n     /\n    protected $name;\n/**\n * Getter for __name__\n *\n * @return string\n **/\npublic function get__name_ucfirst__() {\n    return $this->__name__;\n}\n\n/**\n * Setter for __name_ucfirst__\n *\n * @param string $__name__\n **/\npublic function set__name_ucfirst__($__name__) {\n    $this->__name__ = $__name__;\n}\n\n}\nnew PropertyString();\n?>\n```\nDouble and Tripple :\n``` PHP\n<?php\nclass PropertyString {\n    /**\n     * My awesome nameucfirst_\n     \n     * @var string\n     */\n    protected $name;\n/**\n * Getter for __name__\n *\n * @return string\n **/\npublic function get__name___ucfirst__() {\n    return $this->__name__;\n}\n\n/**\n * Setter for __name___ucfirst__\n *\n * @param string $__name__\n **/\npublic function set__name___ucfirst__($__name__) {\n    $this->__name__ = $__name__;\n}\n\n}\nnew PropertyString();\n?>\n```\n. Still there? ;)\n. No problem, i know your pain. I'm drowning in work myself :D\nI think 3 underscores would be the safer and still sane way to go :)\nGood luck on your exams ;)\n. ",
    "nicodh": "Just published another wrapper API for modifying and creating PHP objects. It's implemented as a TYPO3 extension but can be used stand alone also.\nhttps://github.com/nicodh/php_parser_api\n. ",
    "pscheit": "I'm also creating a already used API (but now, just the api)\nI tried to decoupled the way the code is represented from the way its read out of files (PHP-Parser / PHP Inflection)\nI tried to be intuitive as natural. I'm currently working on method bodies\nhttps://github.com/pscheit/webforge/tree/code-generator\n. maybe a node / container / something with \"lostandfound\"-comments ? :) aka \"not assignable\" - comments?\n. is this the same issue?\nphp\nif (true) {\n  // body comment\n}\nbody comment is not stored in if? What about a fallback for comments to be attached to its parent (with line number?) when no element is coming afterwards?\nWhy are inline comments attached to the following element?\nphp\n$myVar = 8; // 0-based\n$otherVar = 9; // 1-based\n0-based is assigned to $otherVar and // 1-based is dropped. Would you agree, that this is wrong for inline comments?\nIs the parse Tree you name, the one were the comment would be an individual node?\n. correct me if i'm totally wrong here, but isn't the main problem, that the information of whitespace just don't get incorporated into the AST structure?\nThis is nearly the same problem as with the comments, isn't it?\nI think for example fabpot's usecase is to correct indentation etc. But isn't for this the only need that the whitespace information is attached to the current elements we have in the AST?\nlike:\nT_OPEN_Tag { indentation: 0, newline: true }\nEcho { indentation: 4, inline-whitespace: 0 }\n  LNumber { inline-whitespace: 1}\n  char(+) { inline-whitespace: 1}\n  LNumber { inline-whitespace: 1}\n  char(;} {}\nthe whitespace information could be attached in a way that makes \"most sense\". I admit that this is the big part of the work. I used the convention to attach the inline-whitespace to the node after before this is more consistent with identation counting), but last whitespace would be lost.\nThis additional code-identation-information would allow to write indentation fixers and code-re-compilers\n. that is what i wanted to say :)\n. if whitespace before and whitespace after and line breaks would be captured for every node, the indentation could be computed. This would store the same whitespace twice in a node.\nOtherwise just the whitespace before could be captured or the whitespace coming after every node. It just has to be consistent..\nphptag: after-whitespace: eol\necho: before-whitespace eol + 4 after-whitespace: 1\nLNumber(1): before-whitespace: 1 after-whitespace: 1\netc\nof course this is hugely verbose, but thats the point with indentation\n. sounds good, at least something i can live with :)\nbecause my current use case would really be just a partly changed AST (and i know exactly the parts, i have changed). I'm looking forward to this!\n. I attempted to write a whitespace preserving prettyPrinter as well. I did it the other way round:\nI copied the token_get_all stream from the original PHP into an array indexed by offsets.\nThe pretty printer replaces only the offsets for tokens that are changed in this array. After that the array is imploded to php code again.\nThat helps a lot while finding gaps in the token stream and is easier to debug.\n. ``` python\nclass WebforgeCreateTestForClassCommand(sublime_plugin.WindowCommand):\n    def run(self):\n        view = self.window.active_view()\n        classString = view.substr(view.find(\"^(?:abstract\\s|final\\s)(?:class|interface)\\s+(\\w+)\\s+\", 0, sublime.IGNORECASE))\n        print \"searching page\"\n        print classString\n        className = re.match(r\"(?:abstract\\s|final\\s*)?(?:class|interface)\\s+(\\w+)\\s+\", classString, re.I).group(1)\n    print \"searching ns\"\n    nsString = view.substr(view.find(\"namespace\\s+(.*?);\", 0, sublime.IGNORECASE))\n    print nsString\n    namespace = re.match(r\"namespace\\s+(.*?);\", nsString).group(1)\n\n    fqn = namespace+\"\\\\\"+className\n\n```\nif using with parser try to cut the string of php code before the syntax error appears. Or cut it before the line the syntax error appears. But for rself-made sublime plugins (with some conventions made) regexp would suffer\n. i don't know if this is against Zend Coding standard\n. I had no idea if you indent that second expression like that.\nI hope that precedence is right, because the problem was that in the body of the closure assignments were surrounded with ( and )\nWhen i Put the precendence lower than the closure itself would be bracketed.\nBut the closure cannot be used like\nphp\n$result = (function () {\n})('parameter');\ndid this change in 5.4?\n. ",
    "TomasVotruba": "In case anyone would be coming back here, there is NodeFinder class for this.. Is this issue still valid?. Thanks for your clear and fast response.\nIn that case I suggest closing it, so there is more space for active issues.. @joelwurtz That's the same conclusion I came in. Do you still use it?\nNow you can use FormatPerservingPrinter: https://github.com/nikic/PHP-Parser/issues/41#issuecomment-269230733\nI use it and it works well apart few glitches: https://github.com/nikic/PHP-Parser/issues/400\n. Great!\n. @remicollet Hi, this dues to composer optimization, IIRC. You should be able to obtain the tests via cloning the repository.\n. What exactly is ugly? Contributing to Github repository with help of git is natural. What is your goal actually? \nOT: Composer does not (and should not) restrict downloading of any file. It's up to repository maintainer, what to include.\n. Is this issue still valid in php-parser 4.0-alpha?\nOn second read, you might make use of setAttribute() method on node to get the extra work.\nI do this instead of extending nodes with extra logic in like dozens of cases.\nphp\n$node->setAttribute('metadata', '...');\nWhat exactly do you need achieve?. These is also FAQ post, where this is explained:\nhttps://github.com/nikic/PHP-Parser/blob/master/doc/5_FAQ.markdown#how-can-the-parent-of-a-node-be-obtained. Hey,  I think this is already covered by parser generation from grammar, right?. I don't now much about these things, so pardon my possibly incorrect terminology.\nThis package should be used in the future to generate \nparser https://github.com/ircmaxell/PHP-Yacc. I see. \nPersonally I prefer generating code directly by the builder. I have wrapper over it that suits more complex nodes and my personal needs. \n@mo-ba Have you any proof of concept in mind?. How did you end up solving this @mo-ba ?. What is this issue actually about?\nI've noticed one note about autocomplete of getAttribute(...). To fix that, you can use constants defined in single class: https://github.com/RectorPHP/Rector/blob/master/src/Node/Attribute.php\nAnd use like this:\nphp\n$node->getAttribute(Attributes::TYPES);\nHaving constants makes it very hard to make a typo, compared to string naming.\nAlso I prefer current state using explicit methods than hiding it behind magic. I have very bad experience with that due to assumptions that other packages don't have to make. It was good and fast idea on first site though, so I understand your need.\nI suggest either closing this or resolving it. Depending on your real current needs for this.. There is actually a class that allow you something similar:\n```php\n$nodeAddress = spl_object_hash($node);\n$nodeFinder = new PhpParser\\NodeFinder;\n$foundNode = $nodeFinder->findFirst($nodes, function (Node $node) use ($nodeAddress) {\n    return spl_object_hash($node) === $nodeAddress;\n});\n```\n. Thanks for creating this issue. I wonder about another approach to this, let me share:\nPrettyPrinter would put out code in non-namespace version. It is not nice, but it works well. What it needs to look nice? A couple of sniffs/fixers, with PSR-2, Symfony style or others.\nIf you already use coding standard, just use it after PHP-Parser run and code is both refactored and according your style needs. No need to integrate various coding standard rules to parser itself. Parser should parse and focus on printing, if there are maintained tools for that. Maybe there are other features of Parser that would be happy for attention and that cannot be handled by coding standards.\nI'm working on this approach in EasyCodingStandard combined with Rector - CLI tool to refactor legacy code to modern and clean code. Rector will do refactoring + coding standard fixes in one command. \nWhat do you think?. > As a small update here: While there has been no movement on the above TODOs, all the necessary parser changes are now in 4.0, without the need to enable special options.\nThanks for the update and sharing specific code. Is there any related PR to check? I'm curious what have you changed.\nDo you have any plans on 4.0 release? I'll use it for my stable version of package now to have this feature enabled.. I see. I'm adding a method to specific position like this.\n. @nikic Thank you!. Yep, this makes sense.. I used this as hotfix for time being: https://github.com/TomasVotruba/Rector/pull/2/commits/9ab6c8462988fefe7597808dde214ce0eb8fe4cc. I see.\nI use own ApIication for testing, because I don't know how to apply changes on dry-run (without changing actuall content):  https://github.com/TomasVotruba/Rector/blob/9ab6c8462988fefe7597808dde214ce0eb8fe4cc/src/Testing/Application/FileReconstructor.php#L54-L67\nHere's the printer: https://github.com/TomasVotruba/Rector/blob/new-rector-named-services/src/Printer/CodeStyledPrinter.php\nCloningVisitor is added to Dependecy Injection container and loaded to NodeTraverser.. Does CloningVisitor order matter? \nI tried using it fast and using it last and still there are some issues.. I tried your solution and it works like a charm :champagne: \n```php\n$cloningNodeTraverser = new PhpParser\\NodeTraverser();\n$cloningNodeTraverser->addVisitor(new PhpParser\\NodeVisitor\\CloningVisitor);\n$oldStmts = $this->parser->parse($fileContent);\n$oldTokens = $this->lexer->getTokens();\n$newStmts = $cloningNodeTraverser->traverse($oldStmts);\n$newStmts = $this->nodeTraverser->traverse($newStmts);\n$prettyPrinter->printFormatPreserving($newStmts, $oldStmts, $oldTokens);\n```\nThank you!. Thank you. :+1: . :+1: . It's ready!\nWould you be interested in setting up automated coding standard in Travis?\nSomething like? https://github.com/nette/coding-standard#travis-setup\nIf so, are you ok with classic PSR-2 or do you have some exceptions/extra requirements?. > Nope, don't care about CS enough for that.\nSure. I've added same fixes for tests.\nLet me know if you need to complete strict_types or typehints in the future, e.g. before 4.0 release. Thanks! :clap: . Thank you. Nice, I prefer your solution. Thanks for update :+1: . Shall I send strict_types to tests as well or did you skip that for some reason?. Hi, could you send failing test to be sure?. I meant send PR with test to this project, so we can see build fail. It would be easier to fix then.\nSomething like this: https://github.com/Roave/BetterReflection/pull/274. It's better to have (edge) cases covered for future references of the same issues.\nSometimes there is regression bugs and these issues are resend, if not covered with tests.\n\nSure, I can do that later this week if you want\n\nThat would be great. Just wait for @nikic to confirm, if he needs that.\n. Thanks @nikic. @nikic I really appreciate your activity around this repo. It's very rare for me to see such active maintainer :bowing_man: . That was one idea. But I need to replace $args as well and in the future maybe more.\nCan try it for now though as good enough solution. Is there any other way I could use?. Actually, when I set the name, the position is resseted:\nphp\n$node->name = 'newMethod';\nI can change args though. The position remains the same.. So this helped: https://github.com/TomasVotruba/Rector/pull/28/commits/4e95278f0ab31917b59665fad0e4aa677090c4a1?diff=unified#diff-7f70f2c8f0d3e0388b0d4b3774c8a969R78\nDo you think that's ok solution?. Allright, thanks :+1: . Thanks for fast reply, I got confused with this discrepancy with Property and Class behavior.\nDo you have any idea how to make this work?. php \n/** @var Node $parentNode */\n$parentNode = $node->getAttribute('parentNode');\n$parentNode->removeAttribute('originalNode');\nremoveAttribute() method doesn't exist, so I tried:\nphp\n$parentNode->setAttribute('originalNode', null);\nwith no effect. I've tried with no success:\nphp\n$node->setAttribute('parentNode', null);. Sorry, I used only parentNode before.\nNow I tried both, yet still remembers it: https://github.com/RectorPHP/Rector/pull/55/commits/d0786f30b4bb2318ae9374174dbacda3cfd7e3b0. You're right. I forgot to check for this empty doc block.\nThank you, it works as I need.\nThis is the final solution:\nhttps://github.com/RectorPHP/Rector/pull/55/files#diff-50bfb8728bc07dc135b0b34ad748425fR91. It works, so I removed the workaround: https://github.com/RectorPHP/Rector/commit/0a621fecf9e43582a0559ddb83caa6c96ad06087\nThank you :clap: . Works like a charm, thank you.. Any updates on this? . Yep, it works, thank you.\nI have problems to understand this node nulling.\nphp\n$node->setAttribute('origNode', null);\nSometimes it's needed to make things work. It's too random for me now. Is there any explanation that could help me?. There are 5 places at the moment: https://github.com/RectorPHP/Rector/search?utf8=%E2%9C%93&q=-%3EsetAttribute%28Attribute%3A%3AORIGINAL_NODE%2C+null%29&type=\nI get this error over and over again, if not used at those places: https://travis-ci.org/RectorPHP/Rector/builds/288741165#L622\n\n. @nikic String keys was old hack to make this work. array_splice works like a charm, thank you.\nI could remove 3 cases of nulling origNode: https://github.com/RectorPHP/Rector/pull/94/commits/cf20829bafd13e5e5488791bcc58a9cd79530d22\nOnly 2 cases related to Namespace_ node remains:\n\nhttps://github.com/RectorPHP/Rector/blob/fba26692b87800e132aa94417dec433936bd792a/src/Rector/Dynamic/NamespaceReplacerRector.php#L72\nhttps://github.com/RectorPHP/Rector/blob/0b5126c4b9496011c6e5942189eb1acb000733a4/src/Rector/Dynamic/PseudoNamespaceToNamespaceRector.php#L93\n\n. @nikic It works :clap:  Thanks man\nhttps://github.com/RectorPHP/Rector/pull/94/commits/c268b370626bbc486360241ce1a6e04476f6b529\nI wonder, will be comments for these nodes be available in printing?. @synga-nl  I've just randomly found NodeFinder class: \n\nhttps://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeFinder.php\nhttps://github.com/nikic/PHP-Parser/blob/master/test/PhpParser/NodeFinderTest.php\n\nMaybe you could find it useful\n. I suspect that too, your syntax look very nice. I want to try your approach, but don't know how to manage my current code.\nI need to match VarNode of specific type in the whole expression.\nAt the moment I do it like this: https://github.com/RectorPHP/Rector/blob/9c74e03d8c2015d00c6c426fcf27602b76524625/src/Rector/Contrib/PhpParser/IdentifierRector.php\nI might try something like this, but I'm affraid of performance:\n```php\nif (! $node instanceof Expression) {\n    return false;\n}\n$variableNode = $nodeFinder->find($node, function ($node) {\n    if ($this->isVariableOfType($node)) { // an existing service that knows that\n          return $node;\n    }\n});\nif ($variableNode === null) {\n    return $node;\n}\nreturn new Expression(new Expr\\MethodCall($node->stmts[0], 'getValue'));\n```\nWhat do you think?\n. Slowly getting there. I have tried:\nphp\nreturn new Expression(\n    new MethodCall($expressionNode->expr, 'toString')\n);\nbut output is bit weird:\n```diff\n'<?php declare(strict_types=1);\\n\n\\n\n $constNode = new \\PhpParser\\Node\\Const_;\\n\n-$name = $constNode->name->toString();\\n\n+($name = $constNode->name)->toString();\\n\n```\nHere is full code:\nhttps://github.com/RectorPHP/Rector/blob/php-parser-segfaults-and-extra-spaces/src/Rector/Contrib/PhpParser/IdentifierRector.php#L61-L97. It is this test: https://github.com/RectorPHP/Rector/blob/php-parser-segfaults-and-extra-spaces/tests/Rector/Contrib/PhpParser/IdentifierRector/Test.php\nFile 4. I see. I've tagged the forked packages and merged this PR to master.\nThe error should be clear now:\nhttps://travis-ci.org/RectorPHP/Rector#L594. Oh, now it's so obvious with the parent node update. Thanks for explaining.\nAlso thanks for the commit refernce, it was much easier to implement your suggestion with that. And it works very nicely.\nAs for leaveNode(), I've chosen it, because it was the first from the top and I didn't know a difference between them. So I'm open to any suggestions.. Yep, works like a charm. Thanks a lot. :+1: . This is ready to go. Let me know if it needs some work. It works, thank you!. This commit probably influenced adding of other elements:\ndiff\n '<?php declare (strict_types=1);\\n\n \\n\n class SomePresenter\\n\n+public function __construct(someType $someType)\\n\n {\\n\n+    $this->someType = $someType;\\n\n+}\\n\n+{\\n\n     /**\\n\n      * @var someType\\n\n      */\\n\n     private $someType;\\n\n-    public function __construct(someType $someType)\\n\n-    {\\n\n-        $this->someType = $someType;\\n\n-    }\\n\nSee 4 more cases on Travis.\nIt is probably related to this StatementGlue method: https://github.com/rectorphp/rector/blob/c3918f3a60c8f093e3272c10fe9b7b3d8e7e0107/src/Builder/StatementGlue.php#L21. All works now, thanks!. Thanks for this method, I'm trying it.\nI have no clue what exactly that regular means.\nWhat about just?\nphp\nprotected function pSingleQuotedString(string $string): string\n{\n    return '\\'' . addcslashes($string, '\\'') . '\\'';\n}\n\nnot sure whether or not this would make for a good default behavior.\n\nI understand that. What was the reason to escape \\ in the first place? Prevention?. @nikic I see, thanks.\nIn such case, I'd try making it default in alpha realeases and resolve ad hoc if found buggy.\nI think my code example should be resolved properly by default.\nOne way or another, my issue was resolved. Thank you. Nice!\nDo you use some static analysis tool for this or manually?. @carusogabriel I see.\nI made Rectors that can do it for you to save you time ;) https://github.com/rectorphp/rector/pull/190\nIf you got some ideas for more such phpunit A => B changes, feel free to create and issue there.. @carusogabriel Welcome to new level of lazy ;)\nGlad you like it. Let me know if you need help. What about adding coding standard to set this and forget?. Agreed, of course only case where it makes sense :)\n@nikic What do you think? It would make contributions and upgrading code easier . @carusogabriel Do you have ECS set of rules you have used, so I could just add it via PR?. Kk, thanks. I simplifed the code, thanks for tips. But still the space remains.\nI can't change nodes with manual $stmts[1] access, since I use NodeVisitor and I can only manipulate current node.\nI think issues might be related to adding of nodes in leaveNode() method.\nIt calls this visitor: \nhttps://github.com/rectorphp/rector/blob/4cb74969d594f60aefc2c0ab1876593849debae8/src/NodeVisitor/ExpressionAddingNodeVisitor.php#L30\nphp\nreturn array_merge([$node], $this->expressionsToAdd[$node]);. It looks like it respects indent of the outer call\nphp\n        $this->someClass->someFunction()\n        ->otherFunction();\ndiff\n-        $this->someClass->someFunction()\n+        $this->someClass->someFunction();\n+        $this->someClass->otherFunction();\nand \nphp\n        $this->someClass->someFunction()\n            ->otherFunction();\ndiff\n-        $this->someClass->someFunction()\n+        $this->someClass->someFunction();\n+            $this->someClass->otherFunction();\n. I see. Thanks do update. So there is nothing I can do right now?. Works like a charm, thanks! :bowing_man: . Do you have a use case where this is important?. Could you share PHP code? It's easier to spot and test. This looks like Coding Standard's job. You might make use of this fixer: https://github.com/FriendsOfPHP/PHP-CS-Fixer/blob/2.10/src/Fixer/Whitespace/MethodChainingIndentationFixer.php. @nterray I see, but PHP CS Fixer doesn't care about code quality. It matches only the case you describe\nHave you tried it? It has very rarely false positives from my daily experience.\n. It works as you recommend it, thanks . Thank you for your insights, I'll look into it. Why not send a PR with the code? It would be much easier to review and feedback on. Looking more and more on nodes, it would be great to correct categories so they have some added value and people can quickly understand the namespace pattern and rely on it.\nAll these changes can be easily migrated with https://github.com/rectorphp/rector/blob/master/docs/AllRectorsOverview.md#classreplacerrector\nSo BC is not really a problem.. FYI, I'm working on this in @rectorphp, so people can learn more effectively\nhttps://github.com/rectorphp/rector/issues/1100. Here is the table: https://github.com/rectorphp/rector/blob/master/docs/NodesOverview.md\nI thought about adding example of construction + kind alternatives (e.g. for array() and [])\nAny UX feedback is welcomed! \nI plan to add it to https://getrector.org static website, so we can filter them with JavaScript. Do you still need help with this? \nI now know how to replace, remove, add new nodes on many places in @rectorphp. @theofidry Sure :+1: I'm pretty busy this month myself, crazy December :)\n\nI'm also still not sure wether or not @nikic is cool with it.\n\nI don't understand. php-parser already support adding of any node you could think of.\n\nNonetheless, if you have a couple of examples they would be welcome as they may help to move forward with the discussion regarding the API and to decide if worth having here in the library or not\n\nIt's hard to tell in general. I can comment specific code though. If you want something in php-scope, just create issue there with current code and desired one. And ping me there.. Like this? https://github.com/rectorphp/rector/blob/master/docs/AllRectorsOverview.md#delegateexceptionargumentsrector. Why not just return array of nodes?. @nikic I think so. Is there a reason for different behavior in these 2 methods?. Love this!\nIs there a way to automate this?. I edit binary operations in may ways and it  works great for me in @Rectorphp\nWhat code is failing you?. Gaps/spaces/format preserving is supported since PHP-Parser 4.\n```php\n<?php\n$value = 1 + 5;\n$value = 1    +    5;\n```\nSee docs for more.. It looks like you autoload the files by include/require in composer.json  or somewhere else.\nCould you provide full code you analyze this code with? . I've encountered 50 more cases where php-parser add space here and there, or fqn name instead of short name... Turning php-parser to PHP CS Fixer and vice versa can be done, but I find it wasted energy on both sides.\nWe should use php-parser to change the code on if scale and PHP CS Fixer do the space corrections, and work on goal to both tool be the best at their job :) \n. What do you suggest then?. :D I mean what to change to not make it BC break.. I managed to foreach $visitors with null many times already. This change would prevent that.\nThere is no real need to remove constructor, but rather to add default value for public iterable variable of class that can be extened.\n@theofidry Thanks for good point!\n. Thank you :+1: . This is syntax preferred by PHPUnit: https://thephp.cc/news/2016/02/questioning-phpunit-best-practices. :+1: . I also use priorities and now do it like this:\nhttps://github.com/rectorphp/rector/blob/master/packages/NodeTypeResolver/src/NodeScopeAndMetadataDecorator.php#L83-L90\nAccepting on construction would be more clear.\nPriorities on the other hand would allow making use of DI container. It's common pattern to define priority inside the service and let DI handle that.. Architecture fo this parser works with only with valid code.\nIf you need to work with incomplete code, use https://packagist.org/packages/microsoft/tolerant-php-parser\nLike https://github.com/phpactor/phpactor does for IDE autocomplete.\nEach is suitable for their own context.\nWhat are you working on anyway?. @muglug I see, I haven't noticed that.\nCould you share some links to psalm where this is used?. Yes, I run conding standard fixer looking for these.\nIf checks 6 doc malforms: https://github.com/Symplify/Symplify/issues/1205\n. Yes, found it:\nhttps://github.com/phpstan/phpstan/blob/74636f140021984bfbd48f3821b3be59ba5ddade/src/Broker/Broker.php#L301-L303\nphp\n$classNode = $node->class;\n$classNode->name = new \\PhpParser\\Node\\Identifier($className);\neval($this->printer->prettyPrint([$classNode]));\nunset($classNode);\nPHPStan needs it probably to make type analysis working, e.g. when one anonmous class implements interfaces/extends class.\nI could probably workaround to null these in extended printer.\nWhat is that assert needed for? To verify it's anonymous class?. I tried this in custom Printer, but it breaks formatting on no change:\nhttps://github.com/rectorphp/rector/commit/0559fb91bc4009feeda74a4a731fe0cc2c85d94f#diff-560bcf8e3b306989b3cb6718d0403d0cR141\n. A bit better fix: https://github.com/rectorphp/rector/pull/806/files#diff-560bcf8e3b306989b3cb6718d0403d0c. Thanks a lot!. On class names that are set by PHPStan they always were:\nhttps://github.com/phpstan/phpstan/blob/74636f140021984bfbd48f3821b3be59ba5ddade/src/Broker/Broker.php#L301-L303\nIt's not related to PHP-Parser.. Hi, what exactly are you tring to achieve? Before/After code (diff) would be the best.\ndiff\n-A\n+B\nCould you provide simpler code that demonstrates your intention?. I use this approach to get property uses in code:\nhttps://github.com/rectorphp/rector/blob/9db613e92ee8c2f5f390937d856a25116b9b1071/packages/Php/src/Rector/Property/CompleteVarDocTypePropertyRector.php#L142-L153\nphp\n$propertyAssignNodes = $this->betterNodeFinder->find([$classNode], function (Node $node) use (\n    $propertyName\n): bool {\n    if ($node instanceof Assign) {\n        if ($node->var instanceof PropertyFetch) {\n            // is property match\n            return $this->isName($node->var, $propertyName);\n        }\n    }\n    return false;\n});\nBasically use native NodeFinder and find all variable with that name looking for assigs.\nWhat exactly is your goal? Similar analysis does PHPStan and Rector builds on top of that.\n. What is your goal actually? There might be a better solution.. I see. So your goal is to get value of echo $var2;, resp. echo $this->var2;?. I tried Rector + PHPStan to resolve the value, but unfortunatelly PHPStan is not capable to analyze the value.\nHere is code I used:\nhttps://github.com/rectorphp/rector/compare/analasis-example?expand=1#diff-3fd2b223ed0f173609588cfd28904e34\nIn that way, you'd have to write own NodeScopeResolver - https://github.com/phpstan/phpstan/blob/master/src/Analyser/NodeScopeResolver.php, or extend it.\n. What is your ultimate goal to do with the value?. I started with Documentation: https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#node-traversation\nI go through one-change example in this post: How to change PHP code with Abstract Syntax Tree. Open issue at Rector with full code, so we don't spam here. I'll squash commits to 1. Thank you for prompt mentoring :) :+1:  \nI learned a lot today . Comments resolved\n\nMissing a pretty-printer test (or add to an existing one).\n\nI'm on it. Could you point me to the place in Printer where this should be handled? Commit adding format preserving feature to single small Node would be ideal. Rebased on master and squashed to 1 commit\n. Amazing!\nDo you have any new PHP 7.4+ feature you'd like to implement? I really enjoyed this and would love to leverage my know-how to give back . It's already supported? I probably overlooked it.\nWhere can I find the case?. I didn't tried that probably. Will explore, thanks for feedback. Confirm it works, I just had to install PHP 7.3 :)\n\nSorry for bothering with this. Thanks for navigation. I dig through history and blame and tried to inspire at: https://github.com/nikic/PHP-Parser/commit/251e6892830568d536fc8eaae6eeb86ab940a0ef\nEmulative parsers seems to work, but grammer still looks broken. Any clue?. Thanks for review, I'll integrate it and see it helped with the error.. Now the parser is rebuild without error :+1: \nYet the error still remains:\nbash\n1) PhpParser\\PrettyPrinterTest::testPrettyPrint with data set \"var/www/PHP-Parser/test/code/prettyPrinter/expr/operators_php7.test#0\" ('Basic operators (/var/www/PHP....test)', '<?php\\n\\n$a ??= $c;', '$a ??= $c;', 'php7')\nRangeException: The lexer returned an invalid token (id=281, value=??=)\nTest fixture - operators_php7.test:\n```\nBasic operators\n\n<?php\n$a ??= $c;\n!!php7\n$a ??= $c;\n```. Any tips what tests should I add?. >  It would be fine if you just add support for ??= to the PHP 5 parser as well.\nWorks like a charm!\n\nOne thing that's missing here is a parser test for ??=. If ??= is supported in the PHP 5 parser as well, you can just add it into test/code/parser/expr/assign.test.\n\n:+1: I'm on it. :+1:  Thank you . Any ETA for release of this? I'd love to test in Rector and real code to demonstrace PHP 5.3 \u2192 7.4 upgrade. Wow! Thank you :heart: . Jsut curious, what did you need this for?. No troubles :) What do you you use PHP CFG for? Maybe Rector/PHPStan can help you better. > Then, I want to find all the references to a variable including their offsets.\nAnd then? :)\n\nThank you for the suggested repo, I will have a look :)\n\n:+1: . What's the goal of all this?\nCould you maybe show me some minimal code example of before/after?. I see, so it's basically diff in AST in JSON. \nLet me know when it's ready :+1: \nLooking briefly at the documentation, apart Rector (PHP), you might also like ClangMR (basically Rector for C made by Google). The syntax for refactoring recipes looks very similar.    \n. What happens if you add them before first class?. I have PHP 7.3 installed localy and it throws fatal error. Do you think that's related?. It works untill I include the file (for static analysis). But I think there is no better way to do it.. It's based on PHPStan convention.\nTo autoload function names and to allow reflection of 3rd party code from /vendor.. Long answer: https://github.com/nikic/php-ast/blob/master/README.md#differences-to-php-parser\nShort answer: https://www.tomasvotruba.cz/blog/2017/11/06/how-to-change-php-code-with-abstract-syntax-tree/. The main added value of this package I change PHP with PHP. So any PHP programmer can transform PHP in any way.\nThat's how Rector can work: https://github.com/rectorphp/rector\nWith just c extension, it would be useless to 99 % of PHP devs.\n. It still should pass even with assertions on. I'll try to investigate, what is causing this.\nProbably some attribute copying. Good point, I've added it. I think indention needs to be fixed too. I don't understand the message. Oh, maybe it's beacuase only Node is expected in $nodes.\nIf so, it should be changed above in annotation for $nodes to Node|null. I'll fix that tomorrow. Is there any tool I can use to apply this coding standard? It should be automated . Shall I import all such classes or just some? . I see.\nWhat reasons do you have for such an approach? I see it for the first time, so I'm curious. This one needs to be imported. But that's agains the other rule you've mentioned: https://github.com/nikic/PHP-Parser/pull/533#discussion_r219461027\nWhat shall I do?. But that's a mistake, right?\nI'll import it then to keep mistakes constistent :). Very elegant solution btw. I always have extra \"sortByPriority()\" method and have to call it every where. This is much better!. Sure. Any tips how? Regular expression?. Done :+1: . I think variable_modifiers also eats optional_property_type.\nI tried method_modifiers optional_property_type T_VARIABLE property_declaration_list but without success.. This test should include types, now null. Oh, so attributes have to be always set like this if not default value?. I tried to respect argument order, so it's consistent inside the code. I see :+1: . Got it! Thank you . Here the output actually is:\nphp\npublic int $b;\nIncorret. Almost there, just type and modifiers are switched:\nphp\nint public $b\n    = 1.0. I'll look into it. Cool architecture, easy to understand :+1: . > It's ugly, but I don't see a much better way.\nThank you. I believe it's the best way.\nIt's on and tests passes :+1: . Sure :+1: . Good point. Done :+1: . I accidentaly removed this test case during rebase on master.\nIs this complete enough?. These extends should be impoted with coding standrd run, either --with-style or standalone.\nJust to be consistent with rest of the imports.. :+1: . Not sure what these numbers stand for, just blind shot. Not intenational :). Some coding standard tool would be great though, there are many inconsistencies and I always have to \"tidy up\" manually.. ",
    "runekaagaard": "Yes, wondering the same. Seems odd that docblocks stay while comments go. Does it give problems having them? Could try to fix it if there is!\n. http://www.pearhub.org/ is really easy too! Highly recommended. If you want, I can register PHP-Parser there for you. Pearhub will then automatically pick up new tags and create releases for them. http://www.pearhub.org/faq\n. ",
    "beberlei": "+1 - I can really use this for my Code-Generator based on PHP-Parser for the exact same reasons.\n. @nikic ah ok - Its not like i would do it, my code looks like this: https://github.com/beberlei/DoctrineCodeGenerator/tree/master/lib/Doctrine/CodeGenerator/Builder.\nHere is an example usage: https://github.com/beberlei/DoctrineCodeGenerator/blob/master/lib/Doctrine/CodeGenerator/Listener/GetterSetterListener.php\nHowever i am not happy with the API yet, that is why i havent started contributing anything back yet.\nMy idea was to have a jQuery-like API for code-traversal/manipulation, combined with a powerful builder pattern.\n. @schmittjoh not really, i am just saving \"parents\", i.e. for methods, variables and such i remember which class node they belong to, so i can do stuff like:\n1. for this variable\n2. find the class\n3. append a method\nIt hugely benefits from this PR and isn't very nice yet in my code.\n. weird, shouldn't returning any iterator suffice for recursive iterator iterator? since it only has to iterate each element of the iterator until no leaves are returned anymore. At least that how i would expect it to work.\n. ",
    "asm89": "+1 on this.\nIt would probably also be a suitable solution for the usecase of @heinep in #11.\n. ",
    "felixfbecker": "\nBy the way, the reason that some names are Node_Name and others are just strings is that some names can be namespaced and others can't. For example when calling a function the function name can be namespaced, so it's a Node_Name. But when calling a method, the method name cannot be namespaced, so it's just a string.\n\nA string also has no offset information, which can be important in some cases. For example, when a user does go-to-definition for a method, I need to know whether he clicked on the method name or the variable the method was called on.. Sorry I noticed that seconds after I wrote my comment.\n. I would love to see camel case used\n. I would really like to have an option to enable this. Let me explain my use case:\nI need to implement \"Goto definition\". For constants and functions, I need to follow the rules of PHP: first look for the constant in the namespace, then fall back to global. That would be easy if I had the FQN, I would first search the definition index with the namespaced FQN, if not found strip the namespace and search the global scope. But the current behavior is counter-intuitive, I have only the \"global\" name, and no way to find out the namespaced name.\n. Currently using this piece of code as a workaround (I have decorated all nodes with parent references):\nphp\nif ($parent instanceof Node\\Expr\\FuncCall || $parent instanceof Node\\Expr\\ConstFetch) {\n            // Find and try with namespace\n            $n = $parent;\n            while (isset($n)) {\n                $n = $n->getAttribute('parentNode');\n                if ($n instanceof Node\\Stmt\\Namespace_) {\n                    return (string)$n->name . '\\\\' . $name;\n                }\n            }\n        }\n        return $name;\nIt is not pretty though because I do this every time a request is made, while I would rather like to save this on the node once with a NodeVisitor.\n. Sure, that would work fine! For consistency though, would be nice to have namespacedName on the node directly like for classes:\nhttps://github.com/nikic/PHP-Parser/blob/90834bff8eaf7b7f893253f312e73d8f532341ca/lib/PhpParser/NodeVisitor/NameResolver.php#L238\nAnd thanks for the tip!\n. @nikic are you planning another beta release?\n. Thanks. Had to release PHPLS 3.0 though, which simply depends on c0f0edf0441f0ddcff0604407b7600a40993faf2 directly \ud83d\ude09 \n. @nikic I also thought about using tokens only but that would mean I would have to implement a whole lot of stuff that is already so well implemented in this AST parser. It might be easy for something simple like $object->property but for something like Namespace\\Class::create()->property[0]->method() I would love to use a real AST - even if that statement is not finished with a semicolon yet. Could you maybe get me on the right track how I where I would have to implement this? Should I subclass the parser?\n. I just tried this out and this is absolutely amazing! Great work!\n. @nikic I do find myself often in the position where I would like to pass a Node object around in the application, but then need to get access to it's parent node. For (a real world) example, say I want to find out the definition of symbol at a position. I have a generic function that returns a node at a position. Now I have a node, lets say it is a variable access. To find the declaration, I need to walk the tree up to the closest function/method node and then search inside the parameters, while at each level looking for variable assignment nodes before the node. Atm you can always access the children of a node but you cannot access the parent and siblings, like you can in a DOM node for example.\nPseudo code:\nphp\nwhile ($n = $n->parentNode) {\n  if ($n instanceof Node\\FunctionLike) {\n    foreach ($n->getParams() as $param) {\n      if ($param->name === $search) {\n         return $param;\n      }\n    }\n    break;\n  }\n  while ($n = $n->previousSibling) {\n    if ($n instanceof Node\\Expr\\Assign) {\n      return $n;\n    }\n  }\n}\nthrow new Exception('Definition not found');\nReferences:\nhttps://developer.mozilla.org/en-US/docs/Web/API/Node/parentNode\nhttps://developer.mozilla.org/en-US/docs/Web/API/Node/previousSibling\nhttps://developer.mozilla.org/en-US/docs/Web/API/Node/nextSibling\n. @SundialServices The PHP garbage collector has support for cyclic references. Just don't call var_dump on it. Even serialize() works with cyclic structures.. Interesting, could you explain a bit more what your interfaces would do?\nAnd is there any short-term solution?\n. That is very nice, much better than getErrors() everywhere! getErrors() is also very problematic with async programming. In the language server we use an event loop and if two events parse a file, and later try to get their errors, they could be overridden. This is currently never the case but it could happen. So I think the user should definitely clear the errors himself.\nActually though, I think an even better pattern would be to pass an individual error handler to every call of traverse() or parse(). That is kind of in line how PSR-log interfaces work and allows you to share a parser object without sharing error state. You also don't need to \"reset\" the error handler then, you just create a new one for a new operation.\n\nI resolved the Parser\\Multiple issue by defining a \"successful\" parse as anything that doesn't throw (i.e. effectively dropping any multiple parser tries in error recovery mode).\n\nDoes that mean you cannot fallback to PHP5 with error recovery mode?\n. > You're considering the case where you yield control between calling parse() and calling getErrors(), right?\nExactly.\n\nGood point, I agree that this would be a better approach for the parser. However, I'm not sure how this would integrate in the NameResolver case, which is only invoked through the traverser. This would require making the traverser itself be aware of error handling and either pass the error handling along in individual calls or for example in beginTraverse. Not sure if the traverser should be coupled to error handling in this way.\n\nPSR-log defines an interface with a setLogger() method if I remember correctly. PHPParser could define an interface with a setErrorHandler method that takes an error handler. The NodeTraverser then checks if a visitor implements this interface with instanceof and if yes, set the error handler. Only constructor errors could not be caught by this, but stuff like an InvalidArgumentException shouldnt be caught anyway.\n\nYes (though I'd prefer keeping this somehow). PHP7 is a syntactic superset of PHP5 with two exceptions: $foo =& new Bar; and global $$foo->bar, only the former of which may be encountered in the wild. Both of these would be (recoverable) errors in PHP7. Everything else are only differences in interpretation.\nError recovery and parser fallback sometimes interact weirdly. E.g. if you parse $n = 08; (invalid octal) in the PHP7 parser this would generate a (since recently recoverable) error. This would trigger a fallback to PHP5 which would generate the same parse tree, but drop this error.\n\nWe definitely need to support PHP 5, but I guess it's okay like you explained.\n. And what about the NameResolver case? Can't have the language server crash when a document aliases the same namespace twice\n. Ah, sorry. Thanks, I will try this!\n. No, that will continue to traverse siblings and their children.. There are people who believe breaking out of a multi-level loop is a valid use-case for a goto. Wow, thanks for the quick fix!\n. Awesome, this will make code so much less verbose. The best thing is that this can totally happen in a backwards-compatible manner, getAttribute() and setAttribute() can just get/set properties on the object.\n\nDo you know whether PhpStorm has some kind of mechanism to extend the properties of a class in a separate declaration? The override method seems to target factories exclusively.\n\nSorry, what do you mean by that? I'm not working with PhpStorm but I imagine something like the example I gave in the OP should work\n. __get()/__set() are about 3.4x slower than properties, about twice as slow as a normal function call.\nCould you link where the implementation with native properties would be problematic (\"initial construction\")?\nAn IDE should be able to read @property with or without __get(). If not that is a problem of the IDE and we certainly should not base performance decisions on this. We also only need @property for interfaces - for classes we can just declare the property in the class body (just document that it will be null if you don't decide to include it in the options).\n. Hm, valid points. Cannot confirm that it is a performance bottleneck for me, but it is verbose for sure. I mostly see the benefit in cleaner code. But if the implementation is too hard of course we can leave it.\nIs it needed to pass $attributes to the ctor? Can't the callee set them directly?\n. @nikic I'm a bit lost in the source code, could you give me a link where the nodes are instantiated with attributes?\n. Ah, that explains why I couldn't fin it. Well the easy solution would be to just do\nphp\nforeach ($attributes as $attr => $val) {\n  $this->$attr = $val;\n}\nin AbstractNode. We should do that anyway for BC. \nFor better performance though, would it be possible to generate an assignment for every attribute? Like\nphp\n$node->attribute1 = value1;\n$node->attribute2 = value2;\nFor me, this makes a lot of sense. They become actual attributes of the node.\nsetAttribute / getAttribute(s) would get deprecated and provided for BC.\nFor getAttributes, would this be enough?\nphp\nreturn array_diff_key(get_object_vars($this), array_flip($this->getSubNodeNames()));\nEven if getAttributes returned more attributes in some cases than before it shouldn't be a problem because that shouldn't break anything, and it's only for BC.\nAs it is targeted for a major release people will have to do some changes to their code anyway and converting to the new style is a simple regexp search/replace.\n\nBtw, another potential complication with using dynamic properties is that you can no longer have a subnode and attribute with the same name, which is currently supported. (Personally not particularly concerned about that.)\n\nThought about that too, which is why it's safer to do in a major version. But can you really imagine having a function node with an additional property stmts? That does not contain the statements? \ud83d\ude04 \n. @nikic I profiled my language server because I need to improve performance and it turns out getAttribute() actually is a performance hit. As I iterate all ASTs and index FQNs, getAttribute() is called many many times for each Node for each AST for each file. For just parsing 100 files it was called 40,000 times and is actually the most called function in the whole project. Just being able to access the attributes directly instead would save quite some CPU (PHP function invocations have more overhead than in any other language).\n. Don't have the profile open atm but it was about 4%\n. You could just split the string inside slice(). It's a question on what to optimize for\n. I would say just leave it then. Didn't know parts was public.\n. What is the best way to iterate now over all parts of a name? There is only getFirst, getLast and slice.... When\u00a0a class is instantiated like\nphp\nnew NamespaceA\\NamespaceB\\ClassC();\nthen that should register as a reference to all of\nphp\nNamespaceA\nNamespaceA\\NamespaceB\nNamespaceA\\NamespaceB\\ClassC\nSo the line is returned when you do a\u00a0find-all-references for\u00a0either one of them.\nAfter discovering more use cases like these I'm\u00a0more -1 on this change, but I outlined that in #322 . Similarly, this should work too:\nphp\n$obj = new T\nWhere the new node is not yet terminated by a semicolon. You guessed it :)\nWorks great!. It seems like the Error node has the wrong file offsets:\n\nstartFilePos and endFilePos are switched, which prevents me from resolving the node under the cursor correctly to the error node ;). > I'm using a new node type here, because I'd like to keep a distinction between namespaced and non-namespaced names. Many of the methods on Name (like isFullyQualified) simply don't make sense in this context.\nI agree, good point. What do you think about a NamePart class? Or NameName, like UseUse / PropertyProperty?\nWhat do you think about making the parts array of Name an array of NameParts/Identifiers/NameNames? So that we have distinct offset information\u00a0for every part of a\u00a0qualified name.\n. > In most cases it is the complete name though, so something like NamePart does not seem appropriate. I'm also not a big fan of the UseUse names \nUseUse was confusing for me too.\u00a0Why do you think is NamePart not a good idea? \n\nif you run the name resolver, names will have some parts \"located\" in the namespace-declaration (or a use-clause) and some parts \"located\" at the actual location of the name\n\nIt\u00a0took a while, but I get\u00a0what you mean. But\u00a0even at the moment, the Name node\u00a0offsets are kind of weird after you ran the NameResolver, right? A Name node like \\Very\\Deep\\Nested\\ClassName can have an offset of 'startFilePos' => 50, 'endFilePos' => 59 because it used to be just ClassName. It is simply impossible to let the offset represent the exact offsets in the document after you've run NameResolver...\u00a0the only way to go would be to let the NameResolver add\u00a0a resolvedName attribute and not\u00a0replace the node, like you suggested in the other issue.\n\nRelatedly, if you do something like Name::concat($n, 'foo') where $n is a name with Identifier parts, what do you get? Will the last part be a simple string, or will it be normalized to an (attribute-less) Identifier? \n\nI would assume Name::concat() to\u00a0implicitely convert strings.\n\nPresumably methods like getFirst() will also return Identifiers instead of plain strings?\n\ngetFirst() would return a node too, yes, but it could be easily casted to a string.\n\nI've now changed callable, array etc. types to be represented as Identifiers as well.\n\nWhat about self, parent,\u00a0true,\u00a0false? Although I'm not sure if I'm a fan of mixing\u00a0class/namespace referencing names with keywords/types. I\u00a0have found a bug in my code a couple of times now because I didn't handle those somewhere, and ended up inserting a definition\u00a0for the literal FQSEN self into the index. Or\u00a0couldn't infer the type of a boolean variable, because it couldn't find a constant named true in the index.\n\nI would propose that if this mode is enabled, we should wrap the following in Variables:\nCatch clause variable\u00a0\nnames. catch (Foo $var)\nParameter names. function foo($var) {}\nStatic variable names. static $foo;\nLexical variable names. function() use ($var)\n\nDefinitely! In fact, I actually need these all to do\u00a0proper go-to-definition. Would you\u00a0then do an Indentifier for $var, or a Variable for $var, that has the name set to\u00a0Identifier var? There is no real value in separating\u00a0the dollar\n\nThe following two syntactically appear as variables, but really aren't. I'm not totally sure how these should be presented. Would it be \ninappropriate to use Identifier for this?\nProperty names (in declarations). public $prop\n\nI would say ket's do it in every case where the offset information would be different. If the Identifier node would have the exact same offsets as the PropertyProperty, it doesn't make sense. I assume the Identifier would not include the $?\nLet's definitely do it for\u00a0the names of method declarations though. Maybe you could bring the argument\u00a0for consistency then.\n\nStatic variable names (in lookups). self::$prop\n\nYes,\u00a0that will finally enable differentiating the class part and the variable part.\u00a0But I guess $prop should just be a Variable node (I know it currently is only for VariableVariables).. I agree,\u00a0it is more of a variable declaration and therefor a Stmt, not an Expr. But\u00a0you could bring that argument for\u00a0parameters, use etc. too. How about adding Stmt\\VariableDeclaration?. The resolvedName approach would have the disadvantage that pretty-printing the AST would not result in fully-qualified names, which I do... And it would be a big breaking change, because everyone would have to adapt their code. As such, I think it is better to just add the originalName. Thanks a lot!. Sorry, I don't get your code snippet?. ",
    "tostercx": "+1 for this, node navigation is very clumsy right now, ended up using modified relations from #17.. ",
    "sebastianbergmann": "Would be interested to learn about your control-flow/data-flow analysis @schmittjoh.\n. Just out of curiosity: what are you doing with PHP-Parser, @chrisblizzard?\n. Thanks to Pirum, providing a PEAR channel is a non-issue.\n. ",
    "ghost": "Bump.\n. I would love to see something that does PSR-2\n. Is there any reason for this not to be merged?\n. Okay,\nI uncommented tokenizer.ini of php.ini\nIt works.\n. My apologies, I forgot to reply. Closing this ticket is fine, I understand your stance on the subject. Thanks for taking the time to review this.\n. Thanks for your response. My reason is perhaps a bit of a strange one: I'm trying to differentiate between the ranges of the different parts of a try-catch-finally block.\nFor example, (If I recall correctly,) some nodes, such as case nodes, do not actually provide a contiguous region with their positions, for example:\n``` php\nswitch (true) {\n    case a:\n        some_statement();\n        // A comment.\ncase b:\n    some_other_statement();\n\n}\n```\nHere the endFilePos of the case a node will not run exactly up to the startFilePos of the case b node. This is not unexpected behavior, so I've found a workaround that involves using the startFilePos of the next case node instead. Sadly, it can't work in the same way for the try-catch-finally block as the finally statement isn't an actual node, so I have to resort to the first statement inside it (which isn't actually correct).\nThat and consistency is, of course, always nice ;-).\n. Thanks for the suggestion, it currently doesn't majorly impact anything so the first statement in the finally block is probably good enough. I just thought I'd let you know so I can fix it at some point in the distant future. Feel free to close this or leave it open, whichever suits you best ;-).\n. ",
    "chrisblizzard": "Awesome.  Let me know if you figure it out.\n(My apologies for not just giving you a patch but parsers aren't my strong suit.)\n. Any luck?\n. Woot - thanks so much!  I'll pull a new version and see how it fares.  Thanks!\n. OK, my testing seems to be working pretty well.  I got tripped up by the changes to the constructor syntax to the parser, but other than that it seems to be working pretty well - thanks again!\n. Doing some analysis against code bases like WordPress and other frameworks to see what functions they use in the standard(ish) PHP modules.  Mostly just looking at compatibility matrixes.\n. ",
    "leth": "It'd be great to be able to install this via PEAR.\nThis parser would be good in the PHP code coverage tool as well: currently the only way to detect php source lines in uncovered files is to include them :( \n. I found this after a bit of googling: http://blog.stuartherbert.com/php/2011/09/22/php-components-publishing-your-pear-channel-on-github/\nEdit: this one is shorter: http://saucelabs.com/blog/index.php/2011/04/how-to-serve-php-packages-with-github/\nHope that helps!\n. How about PEAR_PackageFileManager_Cli? :)\n. ",
    "sasezaki": "There is alternative http://openpear.org/ :-) , openpear supports PEAR packaging from git.\n. ",
    "avalanche123": "generating package.xml is pretty ad-hoc or at least I am not familiar with a tool that would do that. Here is how I do it in Imagine - https://github.com/avalanche123/Imagine/blob/develop/Rakefile#L110, hope this helps\n. ",
    "manuelpichler": "From my limited PHP_Depend/PHPMD point of view the $namespacedName property is essential, so that I would say that they should be separate properties that are directly accessible and not hidden values in the attributes array.\n. ",
    "mvriel": "Thanks for the elaborate answer; your example has given me the boost to create a solution quickly!\nMy solution was:\n``` php\n<?php\n    if ($node->name instanceof \\PHPParser_Node_Name\n        && $node->name == 'define'\n    ) {\n        $constant = new \\PHPParser_Node_Const(\n            $node->args[0]->value->value, $node->args[1]->value\n        );\n    // process $constant\n}\n\n```\nI needed a PHPParser_Node_Const as my own wrapper classes expect this type.\n. It will certainly help. The only downside for me is that the regular expression is still used, costing performance\n. Now that you mention it; that could be. I will test this tomorrow. Thanks for the insight\n. You were right; this is a non-issue\n. (p.s. I have XDebug installed that causes the 100 recursion break-off; I have temporarily added an ini_set command to increase the level to 500)\n. I think you are right and no real solution is really needed; though it might be handy to mention this in a FAQ or README because this was not the first project that had this issue :)\n. There is something I keep forgetting to mention: thank you for your awesome support!\n. I agree with you that the above solutions are less than optimal. Let's see if another solution is possible.\nFor me to venture there I need some additional information regarding current behaviour. I have (mostly) read the Lexer and Parser to try and get an idea how the data is used but especially the parser is too hard to comprehensively study in a short amount of time.\nAs such, is the following use case correct behaviour?\nCode\n``` php\n<?php\n// this is a test\n/\n * Short description\n /\n/ this is a common multiline comment */\n$a * $b == 1 + 2;\n```\nAccording to a var_dump of the nodes will 'Expr_Equal' node, the 'Expr_Mul' node and the 'Expr_Variable' $a ALL have the comment 'this is a test', 'Short description' and 'this is a common multiline' comment.\nI would have expected that 'this is a test' and 'this is a common multiline comment' would have belonged to the file (shouldn't the file actually be a top parent node?) and that the Short description would only have belonged to the Expr_Equal node.\nExample clarifying my last statement:\nphp\n<?php\n/** @var \\SimpleXMLElement $a */\n$a * $b == 1 + 2;\nThe above indicates that the Expr_Equal contains a variable $a which is of type SimpleXMLElement in this specific context. It may be assumed that $a is the same type in subsequent contexts but only here we know for sure.\n. Hey @nikic,\nI'd love to hear your thoughts on the above if you have time, \nThanks in advance.\n. Thanks @nikic! I had missed the addition of the NOP statement so that should enable me to introduce file-level docblocks. Thanks!\n. Isn't this the same issue as https://github.com/nikic/PHP-Parser/issues/26?\n. @nikic perhaps an idea to make a wiki or FAQ entry with this information and the workaround?\n. I have benchmarked this by running phpDocumentor on its own source code (within a Vagrant box),\nIn the old situation the run takes approx. 370 seconds (tested with 2 subsequent runs), with this patch it takes approx. 80 seconds (tested with another 2 subsequent runs)\n. (Using PHP-Parser 0.9.3)\n. Yes, I have.. I will investigate some more and see if I can reproduce the issue in a more direct way\n. To be sure I have tried to reproduce the issue with your example and was unable to reproduce it; while within phpDocumentor it seems to be reproducable. I am going to investigate more\n. Alright, I found the issue and I don't think you can or have to do anything with it. I forgot that the FileReflector is also a registered visitor and I read the trait information during the EnterNode method for a class. But at that point the NameResolver visitor for the use statement has not triggered yet.\nSo I will have to find a workaround for that in phpDocumentor :) Sorry to bother you!\n. ",
    "niklasvh": "Great! Excellent work on this library by the way :)\n. ",
    "weynhamz": "Sorry to bother here, turns out it was my fault, I cached the result in a later processing of the $stmts. \n. ",
    "mfn": "Ran into this today too.\nAll docblocks/comments get accumulated to the next node found or dropped if none.\nThis makes it really inconvenient to use the same visitor/parser concept for a mixed tree where some files have docblocks without comments, etc.\nI wish there was a mode where docblock/comments where just emmited as individual nodes like anything else, without being required to be attached somewhere.\n. Thank you very much for the insights!\n. I see; I guess it depends what your vision with the project is.\nMy thinking was that, if possible, it should have the php linter as baseline; i.e. everything fails in the linter should be at least detected out of the box so you can easily say that using the parser project, build on top of it, you can expect that nothing passes to you the linter wouldn't also declare as invalid. Obviously YMMV ;-) Nevertheless, thank you very much for your work on this great project.\n. I'm playing around with some static code analysis and wrote some tests myself and by accident reduced my case to just this sample. Thanks for so quickly fixing this!\n. ",
    "yasheena": "I tried to fix this problem by adding the file /node/Stmt/Comment.php to the parser with the following content:\n```\n<?php\n/\n * @property null|PHPParser_Node_Expr $num Number of loops to break\n */\nclass PHPParser_Node_Stmt_Comment extends PHPParser_Node_Stmt\n{\n    /\n     * Constructs a comment node (if there is no node to attach a comment to).\n     \n     * @param array                    $attributes Additional attributes\n     /\n    public function __construct(array $attributes = array()) {\n        parent::__construct(\n            $attributes\n        );\n    }\n}\n```\nI also added the folowing function to the file /PrettyPrinter/Default.php:\n// For printing comments which couldn't be assigned to another node\npublic function pStmt_Comment($node) {\n    return '';  \n}\nNow I searched for the right position in the file Parser.php to add a \"Comment-Node\", if during reducing the stack a still existing (unhandled) comment exists. Do you think this method would be useful to handle this comment problem? If yes, I need a hint: The stack handling of the parser is so complex so I have no idea where I have to insert the additional code.\n. ",
    "Ekstazi": "You shouldn't work with stack directly, think that you need to add a new rule for comments in parser.\n. ",
    "theseer": "I don't think that that problem only occurs when serializing to xml - it's just the only processor that actually complains. If you try to save the source back to a new (modified) php file, you'll end up having the same issues: The original \\xxx component is lost, making the result unreadable at best.\nRegarding the UTF-8 issue you pointed out: I'm 'iconv'ing the php source file before parsing to avoid that issue and so far didn't have any problems.\nThe XML serialization is used in phpDox ( https://github.com/theseer/phpDox ). I for now adopted your suggestion for Issue #26\n. I'm not sure how that would fix the problem as it would defer the solution to a client implementation?\nFrom a user perspective, I'd expect the Parser not to \"interfere\" by modifying or translating values when parsing.\nA serialization my add - depending on the output format - whatever is needed to escape otherwise invalid chars or translate it according to whatever makes sense, e.g. interpret x?? as binary.\nDo you really have to - by default! - translate the x??-Values from a string into their binary presentation at parse time? How would you set an x??-Value at runtime for it, expecting the same output as the source had before parsing?\nI guess the only thing that makes really sense is to keep the \"raw\" value and, on demand, translate it if requested.\n. I do see your problem and your point. But considering your very example about automagic rewriting of existing source code, I - as a user - would expect it to NOT modify my string definition when writing it back as source.\nBut at least for me, the workaround with storing the raw version as additional attribute works fine.\n. I don't think his problem is actually related to the change made here but rather the general fact that error_get_last() will return any error from the Lexer (which is an E_COMPILE_ERROR iirc) and by that mix up Lexer errors and \"actual\" PHP errors.\n. :-) Any ETA for this in a release?\n. ",
    "jakoch": "Well, extending the lexer to handle tokenization of whitespace and comments isn't too hard.\nThis information must then be passed on to the parser. If you need to avoid getting the current structure incompatible, then you might add a step between lexer and parser, something like a ParserFilter or ParserPrefilter, just to handle a seperate AST with whitespace and comment tokens next to the current AST.\nStoring them as attributes in one AST is not good for tree walking, because you would need to walk the whole tree with subtrees, to adjust the values. When you have two ASTs the next step would be merging them.\nI would add a rule to the first AST, so that every token is followed by a whitespace and then ask the other tree for the rest of the informations (this saves lots of tree merges in inline stmts, think of the 1+2 example).\n. Disabling \"xdebug.scream\" at runtime might work, too..\n(but i think it's better to enforce turning this obscure setting off at startup)\n<?php \n$screamState = ini_get('xdebug.scream');\nini_set('xdebug.scream', 0);\nset_error_handler(function() { return false; }, 0);\n@$undefinedVariable;\nrestore_error_handler();\nini_set('xdebug.scream', $screamState);\n. I like this idea, but Nikita has to decide, because this introduces some additional work for him as the maintainer of this repo. Maybe, there some room, now that PEAR is gone..\nImplementation wise, i would suggest php-box. Simply add \"require-dev\": { \"kherge/box\": \"~2.4\" } to the composer.json and add an box.json file with a basic configuration.\n. ",
    "lstrojny": "This would be indeed very helpful for all sorts of transformations that can\u2019t use Generation Gap.\n. Generation Gap (using subclasses as a means to split generated code from non-generated code): http://martinfowler.com/dslCatalog/generationGap.html\nMy point was: if I can\u2019t do that (e.g. https://github.com/InterNations/ExceptionBundle) because I need to edit existing code, I need to preserve formatting and whitespace and everything else. Otherwise we\u2019ll have unreadable changesets after applying code transformations.\n. ",
    "webmozart": "Is there any progress on this issue? I would be really interested in partially modifying ASTs and writing them back to files.\n. @nikic Maybe you should close this issue then and add some docs about how to solve this :)\n. ",
    "joshuaspence": "+1\n. ",
    "funivan": ":+1: \n. echo 1 + 1\nEchoStmNode\n  WhiteSpaceNode\n  Number\n  WhiteSpaceNode\n  Plus\n  WhiteSpaceNode\n  Number\nTo pretty print this code you need go through all nodes and join their value. \nLets go further:\nEchoStmNode  => echo\n  WhiteSpaceNode => '  '\n  Number => 1\n  WhiteSpaceNode => '\\n\\n'\n  Plus => +\n  FunctionCall => count\n    Symbol => (\n    WhiteSpaceNode => '   '\n    Variable => $items\n    Symbol => )\n  Semicolon => ;\nThis code will be represented as:\n``` php\necho  1\n+count(  $items);\n```\nWhite spaces goes inside node. \nAll modern ides use AST tree. So we can watch for their representation of Php code in AST. (Eclipse, PhpStorm, etc ..)\n. Have same issue. One of the goal is to leave the same code formatting.\nFor this task I create library https://github.com/funivan/PhpTokenizer This library is based on the core function tokens_get_all\n. ",
    "romm": "Hey, I'd also be very interested in a solution for this issue.\nI understand the actual structure is not made to support this, I just want you to know at least one more person is interested. :-)\nHave a great day, and thanks for your work!\n. ",
    "lisachenko": "Any news for this issue? I wonder, will it be possible to use column+line information from each node instead of introducing a Whitespace node? Then printer will fill empty spaces, for example, for echo  1 + 2 it can check that 1 has position 7, so instead of single whitespace, it will produce two spaces, then checks next token + and add one more space, etc...\nSo, currently available attributes startTokenPos, endTokenPos, startFilePos, endFilePos can give all information to reconstruct the original source code with formatting and spacing. Not sure about tab character...\n. @nikic thank you for sharing your thoughts, I'll give a try for your pretty printer, it may suite my needs. Actually, I don't need an exact formatting, only to preserve line numbers, otherwise IDE shows crazy break points in the docblocks, statements and empty spaces ;)\nJust combined AST, PHP stream wrapper and stream filter with node visitors to transform PHP source code on the fly. AST hook on userland side looks pretty good.\n. @nikic @YuriyNasretdinov All Java tools (for example, IDEA) has a special node-type for storing an information about whitespaces, so it would be nice to follow this. But this should be an optional feature for Parser - to capture whitespaces as an AST-nodes. This will increase the complexity of AST-walking, but will give a control over file positions for different elements. \n. +1 for adding emptyBody attribute  (or something like this) to the ClassMethod and make stmts always an array.\n. Hmm, it's interesting https://3v4l.org/BBeFX \nHHVM always tries to resolve constant name to the global namespace, but PHP resolves any constant to the current namespace, so ReflectionParameter->getDefaultValueConstantName() returns FQN, see an output:\nChecking parameter for Bar\\foo\nstring(11) \"Bar\\E_ERROR\"\nint(1)\nHowever, values are still from the global namespace, so you are right, an additional logic should check this fact to resolve this correctly (if it's possible on parse level).\n. @nikic it is definitely good point not to delay release (you will be able to release next major if needed)\nAnyway this feature is very important for many developers like me :) Current PHP-Parser implementation is cool, but if some code changes needed then developers should recombine AST with tokens in order to keep formatting like this. It's also impossible to generate custom code with required formatting from AST.\nSo will it be possible to work on this feature later? But this will require a lot of changes to switch from lexical parsing to raw nodes, because of skipping whitespace nodes :(\nPS. Therefore in Java (IDEA engine) AST implementation provides an access to whitespace nodes. But you need to use special methods getNextSibling(), getPreviousSibling(), getChildren(), getParent()to traverse such AST manually and wrap it into meaningful nodes. For example, for PHP it will be like this: search for the namespace node then if you want classes in it you should scan all non-whitespace children nodes.. ",
    "YuriyNasretdinov": "For our soft mocks project we implemented a hack for the stock pretty-printer that allowed to mostly preserve all line numbers except for all kinds of braces because there literally is no line number information about these tokens.\nThe first part of the code consists of the following and it should work with current versions without major issues:\n<?php\nclass SoftMocksPrinter extends \\PhpParser\\PrettyPrinter\\Standard\n{\n    private $cur_ln;\n    /**\n     * Pretty prints an array of nodes (statements) and indents them optionally.\n     *\n     * @param \\PhpParser\\Node[] $nodes  Array of nodes\n     * @param bool   $indent Whether to indent the printed nodes\n     *\n     * @return string Pretty printed statements\n     */\n    protected function pStmts(array $nodes, $indent = true)\n    {\n        $result = '';\n        foreach ($nodes as $node) {\n            $row = \"\";\n            $cur_ln = $this->cur_ln;\n            $comments = $this->pComments($node->getAttribute('comments', array()));\n            $this->cur_ln += substr_count($comments, \"\\n\");\n            if ($node->getLine() > $this->cur_ln) {\n                $row .= str_repeat(\"\\n\", $node->getLine() - $this->cur_ln);\n                $this->cur_ln += substr_count($row, \"\\n\");\n            }\n            $row .= $comments\n                . $this->p($node)\n                . ($node instanceof \\PhpParser\\Node\\Expr ? ';' : '');\n            $this->cur_ln = $cur_ln + substr_count($row, \"\\n\"); // get rid of cur_ln modifications in deeper context\n            $result .= $row;\n        }\n        if ($indent) {\n            return preg_replace('~\\n(?!$|' . $this->noIndentToken . ')~', \"\\n    \", $result);\n        } else {\n            return $result;\n        }\n    }\n    public function prettyPrintFile(array $stmts)\n    {\n        $this->cur_ln = 1;\n        $this->preprocessNodes($stmts);\n        return \"<?php \" . str_replace(\"\\n\" . $this->noIndentToken, \"\\n\", $this->pStmts($stmts, false));\n    }\n    protected function p(\\PhpParser\\Node $node)\n    {\n        $prefix = '';\n        if ($node->getLine() > $this->cur_ln) {\n            $prefix = str_repeat(\"\\n\", $node->getLine() - $this->cur_ln);\n            $this->cur_ln = $node->getLine();\n        }\n        return $prefix . $this->{'p' . $node->getType()}($node);\n    }\nThe other part is removing all \"\\n\" from pSmth() functions so that we manually control all whitespace characters.\nThe problem, obviously, is with this \"other part\" because it requires writing fragile code that is just a copy of all parent functions. We could not just make calls to parent methods and remove all \"\\n\"'s because functions are recursive.\nSo I would suggest adding some code into PHP-Parser that would allow some kind of line-preserving pretty-printing by adding possibility to get rid of \"\\n\"'s everywhere (e.g. move \"\\n\" to a public propertly that could be redeclared to be \"\")\n. ",
    "jails": "Just wondering if this is issue has been addressed in the 3.x version since all comments seems to be older than 6 months ?\n. ",
    "CMCDragonkai": "Hey nikic, I wrote a sandbox and have it live here http://phpbounce.aws.af.cm\nI got through linting, parsing, whitelisting, blacklisting and separate process sandbox. I've switched off whitelisting, but I'm not sure how secure it is. Can you check it out?\nBTW, this is a very impressive project for someone who is 17!\n. Indeed, in fact in my whitelist, I went through 4400 functions manually. Anyway thanks for the code it works well.\n. ",
    "danyaPostfactum": "Thanks @nikic for this commit!\nIt seems I don't need to use the same tokens. I thought these tokens never change between php versions, I was wrong.\nI'm working on improving http://phpjs.hertzen.com/ . It has poor handwritten lexer. Could you advise me to improve it?\nMaybe to use lex and modify zend_language_scanner.l (does it use lex for generation?). Or maybe it would be better to improve current lexer.js by adding states and modifying some wrong regexp's ? I think lex-based lexer will be slower and much bigger (the size is sensitive for client-side), so I should work on improving hand-written lexer. What do you think?\n. Hello @nikic , I would like to know your opinion. I think it would be great to keep lexer definitions in lex files, but adapted to specific languages (php, js).\nI found the tool named jison, that looks like what I need. jison can generate both lexer and parser, but I'm thinking about extracting rules (already represented as regexps) and states (conditions) and build my own lexer (and maybe merge regexps to avoid loop through each rule, something like in https://github.com/ajaxorg/ace/blob/master/lib/ace/tokenizer.js)\nMaybe there is a tool for PHP to generate lexers from lex-files, or to convert lex-files to data arrays (with final regexps), wich can be used to generate own lexer implementation?\n. And another question :)\nWhy I get different token constant values from kmyacc than defined in PHP? The grammar file structure is the same, but it looks like kmyacc works it's own way.\n. ",
    "harikt": "The one you mentioned is creating the class and adding methods.\nBut what I was looking for is say I have\nphp\n<?php\nclass Example \n{\n    public function helloWorld()\n    {\n    }\n}\nNow I want to add another method, in run time reading the above class to say \n``` php\n<?php\nclass Example \n{\n    public function helloWorld()\n    {\n    }\npublic function anotherMethod()\n{\n}\n\n}\n```\nIs this possible ?\n. okey. I want to explore. \nSorry for the trouble. I will get back to you regarding this if it didn't work :+1:  . Thank you once again for the support .\n. ",
    "gpgkd906": "I have read this issue, and i think addStmt can make things easier, like this:\nphp\n    public function addStmt($stmt)\n    {\n        $sort = [\n            'Stmt_TraitUse'    => 0,\n            'Stmt_ClassConst'  => 1,\n            'Stmt_Property'    => 2,\n            'Stmt_ClassMethod' => 3,\n        ];\n        if(!isset($sort[$stmt->getType()])) {\n            throw new Error('Cannot add stmt not belong ' . __CLASS__);\n        }\n        $this->stmts[] = $stmt;\n        usort($this->stmts, function($a, $b) use ($sort){\n            Return $sort[$a->getType()] > $sort[$b->getType()];\n        });\n    }\nso i can use Stmt\u00a5Class_ just like Builder\u00a5Class_\nphp\n$class->addStmt(...)\nbut, I am not sure if is there something wrong...\n. ",
    "sandysong": "sorry, seems i got a mistake\n. ",
    "lpouget": "\nI thought that the namespace is more or less just some unique string, but is not actually used in any way after\nthat (so it doesn't matter if it is a 404).\n\nNot really. Xml namespaces are useful to describe node type and structure inside your xml. Xsd files (which describe your xml namespaces) can provide in some IDE (like eclipse) auto-completion to create xml. They can be used also to validate xml or to map to objects in various languages.\nI generate them for php-parser but I want to validate them before submission.\n. ",
    "boenrobot": "But a namespace URI is not the same thing as an XSD reference.\nAs @nikic pointed out, a namespace URI is just a unique string that doesn't need to point to an existing resource. Only an XSD reference needs to point to an actual resource (that resource being the XSD file).\nAre there actually any XSD files for the XML serialization?\nIF (and only if) there were ones, and we assume they're at those same URIs, but with an \".xsd\" extension, you'd declare them like:\nxml\n<AST\nxmlns:node=\"http://nikic.github.com/PHPParser/XML/node\"\nxmlns:subNode=\"http://nikic.github.com/PHPParser/XML/subNode\"\nxmlns:attribute=\"http://nikic.github.com/PHPParser/XML/attribute\"\nxmlns:scalar=\"http://nikic.github.com/PHPParser/XML/scalar\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:namespaceSchemaLocation=\"http://nikic.github.com/PHPParser/XML/node http://nikic.github.com/PHPParser/XML/node.xsd\nhttp://nikic.github.com/PHPParser/XML/subNode http://nikic.github.com/PHPParser/XML/subNode.xsd\nhttp://nikic.github.com/PHPParser/XML/attribute http://nikic.github.com/PHPParser/XML/attribute.xsd\nhttp://nikic.github.com/PHPParser/XML/scalar http://nikic.github.com/PHPParser/XML/scalar.xsd\">\n...\n</AST>\nSome IDEs let you declare XSD files for namespaces, thus allowing you to omit the whole \"xsi\" business, but still - there needs to be an XSD file that's associated with a namespace URI - the namespace URI itself is NOT the schema.\n. ",
    "hinikato": "I have fixed the open/closed tags with the following hack:\n``` php\n// @TODO: Tmp fix.\n$phpTags = false;\nif (substr(ltrim($source), 0, 2) == '<?' && substr(rtrim($source), -2) == '?>') {\n    $phpTags = true;\n}\n$php = (new \\PHPParser_PrettyPrinter_Default())\n    ->prettyPrint(\n        (new \\PHPParser_Parser(\n            new \\PHPParser_Lexer()\n        ))->parse('<?= $var ?>')\n    );\n// @TODO: Tmp fix.\nif ($phpTags) {\n    $php = '<?php ' . $php . ' ?>';\n} else {\n    // Strip added tags.\n    if (substr($php, 0, 2) == '?>') {\n        $php = substr($php, 2);\n    }\n    if (substr($php, -6) == '<?php ') {\n        $php = substr($php, 0, -6);\n    }\n}\nreturn $php;\n```\nIt would be good to fix the opened/closed tags problem. I don't worry much about new lines for now, I don't know how to do that by myself because I need to learn in more detail PHPParser and theory of compilers to do that. I hope I will be able to do this in the future.\n. It seems like there are other not handled cases. For the following input\nphp\n<?php print '<div><span>Text</span></div>'; ?>\nthe prettyPrintFile() produces the following output:\n```\n<?php\nprint 'Text';\n```\nThe closing ?> tag is missing.\n. Oh..., it make sense, so it is not a bug, thanks.\n. @r3verser I don't know either it will be enough for you or not, but you can see one example of handling code with PHPParser here. PhpTemplateEngine is template engine that handles .phtml files that contain code in PHPTemplate language and returns processed PHP as output. The PHPTemplate language is just PHP with changed semantic of statements/expressions, a capability to call Plugins and process HTML tags.\nHere is a description how it works:\n1. The PHPTemplateEngine::process() method initializes Filters. The PhpTemplateEngine is FilterChain, each Filter in the chain gets input and returns changed output that will be processed as input by other Filter and so on. It works similar to unix pipeline:\necho 'foo' | grep 'o'.\nSo after init() we have the following Filters in the chain:\nPhpTemplateEngine\\Parser(),\nPhpTemplateEngine\\CodeGenerator()\n1. The PhpTemplateEngine\\Parser as you can see only parses code with \\PHPParser_Parser and \\PHPParser_Lexer, the result is AST and it will be processed by the next Filter - PhpTemplateEngine\\CodeGenerator.\n2. The PhpTemplateEngine\\CodeGenerator gets AST as input (that was output from PhpTemplateEngine\\Parser) and uses \\PHPParser_NodeTraverser() to traverse it. To do that it adds the PhpTemplateEngine\\Preprocessor that makes transformations of AST nodes. After all transformations the CodeGenerator generates changed PHP with:\nphp\n$prettyPrinter = new \\PHPParser_PrettyPrinter_Default();\nreturn $prettyPrinter->prettyPrintFile($ast);\nSo result of the CodeGenerator::filter() is simple string of PHP code.\n1. The PhpTemplateEngine\\Preprocessor can use any method defined in the \\PHPParser_NodeVisitor interface to change the AST nodes, but for now it uses only one: leaveNode(). What it does - it just changes semantic of the echo statement by wrapping its arguments with htmlspecialchars, for example:\necho $s;\n// will become\necho htmlspecialchars($s, ENT_QUOTES);\nThere is other thing what it does - it handles HTML with other HTML Parser - instance of the PhpTemplateEngine\\SemiParser that provides a capability for each HTML tag write respective method that will be able to change its content. For example - the PhpTemplateEngine\\HtmlParser class uses the tagA() method to change the 'a' tags, specifically the 'href' attribute, so that HTML links will be automatically prepended with base URI.\n. One note: probably uses() should be replaced with _use() and ns() with _namespace() for consistency.\n. I agree with both points:\n1. It is excessive, if Nodes can be used directly without intermediates Builders, builders can be not required.\n2. File level Builder is more logically correct in this case, because BuilderFactory is factory of Builders, not Builder itself. So if Builders will not be used for namespace and use nodes, building of Nodes can be done with File level Builder.\n. The changes above were implemented here: https://github.com/myak/framework/tree/master/lib/Myak/Code/CodeGen. I would be happy to move of them to the PhpParser, probably with some changes.\n. It seems like with this update a handler that was registered with the register_shutdown_function() will see the triggered by Lexer error. Here is a code:\n``` php\nclass ErrorHandler extends ExceptionHandler implements IErrorHandler\n//...\n    public function register()\n    {\n//...\n            register_shutdown_function(array($this, 'handleFatalError'));\n            $this->fatalErrorHandlerActive = true;\n//...\n    return $this;\n}\n\npublic function handleFatalError()\n{\n    $error = error_get_last();\n    if ($this->fatalErrorHandlerActive && $error) {\n        // The $error['message'] == 'Undefined variable: undefinedVariable'\n    }\n}\n\n//...\n```\nI think the $error should be last error from other PHP code and not from Lexer here.\n. Yes, as @theseer mentioned the error_get_last() will return the triggered error in the Lexer::resetErrors() method and as result it will be available in the handleFatalError() (which probably must be changed). If you think that this is acceptable behaviour I don't mind, I just want to point that the error will be accessible with the error_get_last(), so np.\n. ",
    "donquixote": "And for templates..\nphp\n$blueprint = $engine->classFromTemplate('MyClassTemplate');\n$blueprint->addMethod(..);\n. Arguments are tricky, because they could break the fluid chain.\nSo let's try to squeeze it all in one method \"addArgument\" (or \"addParam\" if you like).\nphp\n$classBlueprint->addMethod('foo')\n  ->makeProtected()\n  // Argument with type hint and doc block.\n  ->addArgument('arg0', 'Arg0Interface', 'This argument is required.')\n  // Argument with default value, type hint and doc block.\n  ->addOptionalArgument('arg1', NULL, 'Arg1Interface', 'This argument is optional.')\n  ->setBody(..)\n;\nThe following code would trigger an exception, because optional arguments cannot be followed by required arguments:\nphp\n$classBlueprint->addMethod('foo')\n  ->addOptionalArgument('arg0', NULL)\n  ->addArgument('arg1')\n;\n. Did some code.\nhttps://github.com/donquixote/PHP-Parser/tree/fluid\nFluidBuilderFactory:\nhttps://github.com/donquixote/PHP-Parser/blob/fluid/lib/PHPParser/FluidBuilderFactory.php\nFluidBuilder_Class, _Method and _Function:\nhttps://github.com/donquixote/PHP-Parser/tree/fluid/lib/PHPParser/FluidBuilder\nHow to use:\n(equivalent to example in https://github.com/nikic/PHP-Parser/blob/master/doc/4_Code_generation.markdown)\n``` php\nrequire_once 'PHP-Parser/vendor/autoload.php';\n$prettyPrinter = new PHPParser_PrettyPrinter_Default();\n$factory = new PHPParser_FluidBuilderFactory();\n$class = $factory->class('SomeClass')\n    ->extend('SomeOtherClass')\n    ->implement('A\\Few', 'Interfaces')\n    ->makeAbstract()\n;\n$class->addMethod('someMethod')\n    ->makeAbstract()\n    ->addRequiredParam('someParam', 'SomeClass')\n;\n$class->addMethod('anotherMethod')\n    ->makeProtected() // ->makePublic() [default], ->makePrivate()\n    ->addOptionalParam('someParam', 'test')\n    // it is possible to add manually created nodes\n    ->addStmt(new PHPParser_Node_Expr_Print(new PHPParser_Node_Expr_Variable('someParam')))\n;\n// properties will be correctly reordered above the methods\n$class->addProperty('someProperty')\n    ->makeProtected()\n;\n$class->addProperty('anotherProperty')\n    ->makePrivate()\n    ->setDefault(array(1, 2, 3))\n;\n$node = $class->getNode();\n$stmts = array($node);\necho $prettyPrinter->prettyPrint($stmts);\n```\n. Hm, to make it more fluid\nphp\n$factory->class('SomeClass')\n    ->extend('SomeOtherClass')\n    ->addMethod('someMethod')\n        ->makeAbstract()\n        ->addRequiredParam('someParam')\n            ->setTypeHint('SomeClass')\n            ->makeByRef()\n            ->END_PARAM()\n        ->END_METHOD()\n    ->addMethod(..)\n    [..]\n. Ideally, it would also wrap the actual \"saving to PHP file\" in the fluid syntax, so you don't have to juggle around with different services for that.\nE.g.\nphp\n// Specify PSR-0 root dir where classes are to be saved.\n$engine = new PSR0GeneratorEngine('/var/projects/mylib/generated');\n$instance = $engine->namespace('My\\Library')->class('MyClass')\n    ->method(..)\n    ->save()\n    ->newInstance(..)\n. Hi,\nsorry, I also was busy with other things..\nIf it is all about brevity, then I think your points makes my suggestion obsolete.\nBut I have another motivation: Passing objects around.\nE.g. you have a main component that starts with the code generation, but it passes some of the code generation work on to helper components.\nphp\n$classBlueprint = $factory->class('MyClass');\n$helper = ...\n$helper->modifyClass($classBlueprint, $factory);\nSo, the helper needs the factory.\nEither we pass the factory as an argument, or the helper needs to create one.\nIn the suggested version, the helper does not need to know the factory or how to create it. It only gets the class.\nThis would allow the helper to work with different implementations of the factory.\n. > b) The code uses ->addRequiredParam('someParam', 'SomeClass') which creates a parameter in a single method call, rather than the multiple calls on $factory->param(). Apart from the comments from a) [regarding reusability and stuff] the issue here is order of optional bits of information (as you already point out in your second comment). You basically have to decide on some arbitrary order, which I personally don't like much (because it usually leads to the , null, null, null, 'foo' pattern and because the meaning of a certain parameter often becomes unclear.)\nYes. This is the ugliest part of the proposal, I think.\n. Although you will rarely get the null, null, null, 'foo'.\nThe suggested order is the best we could get if we squeeze it in one method.\n. I currently do not have an active interest in this issue.\nI suggest to treat it as an idea, which can be considered for future development, or not.\nNo problem if you want to close it.. ",
    "r3verser": "Hi, thanks for reply, but unfortunately this is also a very simple example. It does not use a data-flow analysis :( I need to do a code analyzer, using memory / stack / etc, which analyzes the flow of execution and, based on result, producing some action. I'm not quite sure that PHP_Parser has ability to do all those things, so I wanted to look at the complex examples! But thanks for help once more!:)\n. @Baachi thanks, that's one seems exactly what i want!\n. @Trismegiste  Thanks, realy interesting tool!\n@nikic That would be great!\n. ",
    "Baachi": "@r3verser Look at this repo scrutinizer-ci/scrutinizer. It performs a deep code analysis.\n. ",
    "Trismegiste": "You can look at my static code analyser and refactoring tool https://github.com/Trismegiste/Mondrian using about 7 visitors.\nIt transforms a set of php files to a digraph and runs analysis based on the Graph Theory.\n. Currently no, sorry. But the context is simple : \nI want to make a Decorator Pattern on Traverser to add \\SplSubject capabilities. \nTherefore, I need ton inject an interface in the constructor of the decorator.\nhttp://www.oodesign.com/decorator-pattern.html\n. Thanx a lot ! :+1: \n. I agree it seems excessive to create one builder and to call 2 methods (\"ns\" & \"getNode\") instead of chaining 2 \"new\". Furthermore, I think this kind of factories must be placed at the \"file level\".\nThat's why I'm planning to create a builder for PHP files (with some PSR-0/1/2 guidances) and I've put this factories for \"namespace\" and \"use\" in that builder. It's currently unfinished and unshaped and I don't believe I must be placed in PHPParser but you can see it in : \nhttps://github.com/Trismegiste/Mondrian/blob/feature_phpfile_builder/Parser/PhpFileBuilder.php#L70\nIn the end you can make \nphp\n$fac = new BuilderFactory();\n$file = $fac->file('sample.php')\n                ->ns('Kitty')\n                ->declaring(\n                        $fac->class('Soft')\n                        ->implement('Warm')\n                        ->addStmt(\n                                $fac\n                                ->method('purr')\n                        )\n                )->getNode();\n. Ok thanks. I will continue this PR.\nYou're right about the name but I search in wikipedia and I did not find a common noun for trait, interface and class so I choose \"Object\" for \"OOP\". \nWhat about : \n- OopDefinition\n- ModelSpecification\n- TypeDeclaration (but Type is already used for node's type and node's access)\n- OoPattern\n:question: \n. I'm sill working on it but I've encountered some problem with php 5.2 compatibility\n. Unfortunatly, the context is not static and get_class() returns me the mother classname, not the subclass name.\nI think exception message could be changed to be generic to OoPattern but this is not kewl (for debug).\nPerhaps it was not a so good idea after all.\n. You're absolutely right ! I forgot this behavior of get_class() in 5.2 :smoking: :maple_leaf: \nDone ! :beers: \n. Perhaps more tests here would be nice on the constant...\n. I prefer using the setUp like the PHPUnit docs than using a concrete factory like your other tests. \nIf it doesn't suit you, I can change that.\n. A third elseif would be too messy IMO, that's why I'm using an array\n. I decide to erase the content of the method no matter what. Or we can throw an exception ?\n. I'm not sure about this but don't you think an InvalidArgumentException would be more appropriate ? \nPHP doc is not very clear about that, anyway...\n. ",
    "deweller": "Thanks.  The regex is a good idea for a workaround if I can't solve it with PHP-Parser.  I'd like to use PHP-Parser if I can.  Any ideas on how to modify or extend PHP-Parser to provide fault-tolerant parsing?\n. I'd be willing to contribute the code if you are open to a pull request.  It would be a good excuse for me to get my head around how the parsing code works.\n. Thanks for the links above.  That will help me to get started.\nI would expect that the current behavior of throwing an error on a parse failure should stay the same.  But perhaps we add an optional parser that reports errors.  Perhaps we call it PHPParser_Parser_ErrorReporter.  And maybe this version of the parser can recover from errors and report a list of all errors found.\n. I got as far as restoring the old commented-out test code.  Here is my commit: \nhttps://github.com/deweller/PHP-Parser/commit/b0816a2\nIt is not obvious to me how $yyerrflag would ever be set to anything but 0.  But maybe that is where bison's recovery tokens are required.\n. This is great.  \nI went a different route (for now) in solving the problem that required the error recovery.\nBut I suspect I might need to come back to this later.  When I do, I'll test it out.\n. ",
    "jimmyko": "I am looking for the same features. It seems more logical to separate them from other builders. Any schedule to port this feature?\n. ",
    "akiessling": "Any news on this one? I'm looking for the same features, but the repo from hinikato seems to be gone\n. ",
    "sh-dude": "Is it a possible to generate the following code using BuilderFactory and PrettyPrinter?\n``` php\n<?php\nnamespace {\n    use Foo\\BarTrait;\n    use PHPUnit_Framework_TestCase as TestCase;\nclass Test\n{\n}\n\nclass MyTest extends TestCase\n{\n}\n\n}\n```\nIf I try to use namespace with empty name I get LogicException:\n$builderFactory = new BuilderFactory();\n$builder = $builderFactory->namespace(null);// ! Exception here\n    // Add other statements here  \n$prettyPrinter->prettyPrintFile([$builder->getNode()]);\nIf no please consider ability to add support of this case.\n. ",
    "joseph-montanez": "I am having this trouble too, I am working on a coffeescript converter and else if's fail if they are spaced. I am using the current master branch.\nif (1) {\n    echo 2;\n}\nelseif (2) {\n    echo 12;\n}\nelse if (3) {\n    echo 13;\n}\nelse {\n    echo 1;\n}\nThis is the resulting code. The array elseifs only is filled when else if is used as elseif\nif 1\n    console.log(2)\nelse if (2)\n    console.log(12)\nelse\n    if 3\n        console.log(13)\n    else\n        console.log(1)\n. ",
    "jdespatis": "Yes @nikic , it's exactly the problem I encounter. Impossible to upgrade to last 0.9.3 version with pear.\nI hope you'll be able to release a new version, just in order to have a 0.9.4 stable version (even with no feature at all)\n. Indeed, I want to upgrade my phpDox 0.4.0 to 0.5.0 on a production server, so I just do pear upgrade\nBut it fails because of this error:\nFailed to download nikic/PHPParser within preferred state \"stable\", latest release is version 0.9.4, stability \"beta\", use \"channel://nikic.github.com/pear/PHPParser-0.9.4\" to install\nI could install a specific version right, but I prefer to use common pear upgrade command, in order to have the easiest upgrade process as possible.\nI hope PHPParser will reach 1.0.0 in order to show it's stable :)\nIndeed, I guess 0.9.4 is already stable... All this is just a matter of numbers\n. ",
    "Ocramius": "why would you remove 5.2? PHP-Parser is meant to work with it too!\n. Yes, but PHP-Parser is used to discover and analyze (and eventually upgrade/downgrade) php code from very different versions. I'd see such a support drop as only possible for 2.*. Also, I think this PR was already rejected before.\n. @nikic many packages rely on PHP-Parser and run on HHVM - having HHVM in the matrix (even if in allow_failures) is very useful for third party who may chip in and fix issues that depend on HHVM incompatibilities.\n. @nikic thanks!\n. @nikic if the code cannot work there, what about throwing an exception when xdebug.scream=1?\n. @harris21 if you read a couple of comments above:\n\n@BenBradleySmith xdebug.scream is an aggressive debugging option that effectively disables the @ operator and as such will break any code using it. You shouldn't enable it unless you really need it.\n. @hason this is likely not going to work given how many special keywords are handled within this library...\n. @llaville it still relies on PEAR on the client side, which is the problem (alas, nobody wants to have to do with it, really).\nThe distribution format isn't really that critical.\n. @llaville if you need to patch and redist PHP-Parser with your own software, then you should probably bundle it with the package and use a \"provide\":{\"nikic/php-parser\":\"0.9.999\"} in your composer.json so that the end-user installing it won't download the \"original\" one.\n. @patinthehat the parser would still go through that, and it would still have to look ahead to search for the \"end\" marker\n. Here's a nice RTFM Reminder\n. @abiusx what's the exact use-case?\n. @abiusx any reason for not maintaining it via composer, as it's supposed to be?\n. @abiusx if you need to modify code, then you don't use a phar in first place\n. @TimeToogo can you also provide a test case?\n. @kronusme your visitor has to keep internal state about that...\n. Please see doctrine/doctrine2#543 as a reference: this is a useless repetition of the same question.\n. LICENSE MUST be distributed, as for README, I actually agree that it's not necessary.\n. @nikic for now, we have https://github.com/Roave/BetterReflection/blob/d32bda49401cc3ba426a48f40952335aa6797da1/src/NodeCompiler/CompileNodeToValue.php, which recursively resolves constants, given a context. Unsure if this is applicable there too :-. What's the reason for this change? I don't see any other related code using it.\n. \n",
    "tcopestake": "I've just finished an early version of one, which you can find at https://github.com/tcopestake/PHP-Parser-PSR-2-pretty-printer\nThere may be non-PSR-2 code generated by the default pretty printer that I'm unaware of and therefore haven't patched. If that's the case, feel free to let me know or add it in yourself.\n. To clarify, is your issue the lack of indentation and/or the missing array prefix?\n. I'd imagine the performance of PHPPHP would be unsuitable for a production environment.\nThis is something I've considered doing myself, but I concluded that for the effort involved, people might as well just upgrade PHP. The challenge ranges from easy to unrealistically difficult, for reasons that would differ from feature to feature. Try to pick a feature at random and think about how you'd do it yourself. The 5.4 array syntax is easy, but what about generators or $this within closures with the proper protected/private scope? You'll quickly find that as you try to cover all bases, bearing in mind that you're also restricted to static analysis (or would have to program dynamic analysis into the output), it becomes very complex.\nNothing stopping you giving it a try, though - just for the experience.\n. ",
    "kelfink": "Thanks!  I have been working on one as well.  You may be further along than me, but I'll contribute back when I can.   The existing printers and your, for instance like to mash long lines onto one line.  I'm hoping to print onto a maximum of 120 chars and indent as required.  It would be nice if the legal line feeds in existing code could be retained.  That may be asking a lot.\n. ",
    "popstikle2": "@nikic I followed your steps on #41 and #26. But now if I have HEREDOC string it will exclude it from the pretty printer. Can you check it and tell me what I can do to keep the HEREDOC?\n. OK, Tested on: 5.5.24 and 5.4\nindex.php\n```\n<?php\nrequire 'lib/bootstrap.php';\nrequire 'lexer.php';\nrequire 'printer.php';\n$code = file_get_contents('foo.php');\n$parser = new PhpParser\\Parser(new KeepOriginalValueLexer);\n$prettyPrinter = new StandardNew;\ntry {\n    $stmts = $parser->parse($code);\n    $code = $prettyPrinter->prettyPrint($stmts);\necho $code;\n\n} catch (PhpParser\\Error $e) {\n    echo 'Parse Error: ', $e->getMessage();\n}\n?>\n```\nlexer.php\n```\n<?php\nclass KeepOriginalValueLexer extends PHPParser_Lexer_Emulative //PHPParser_Lexer // or PHPParser_Lexer_Emulative\n{\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n    if ($tokenId == PHPParser_Parser::T_CONSTANT_ENCAPSED_STRING\n        || $tokenId == PHPParser_Parser::T_LNUMBER\n        || $tokenId == PHPParser_Parser::T_DNUMBER\n    ) {\n        // could also use $startAttributes, doesn't really matter here\n        $endAttributes['originalValue'] = $value;\n    }\n\n    return $tokenId;\n}\n\n}\n?>\n```\nprinter.php\n```\n<?php\nuse PhpParser\\PrettyPrinterAbstract;\nuse PhpParser\\Node;\nuse PhpParser\\Node\\Scalar;\nuse PhpParser\\Node\\Scalar\\MagicConst;\nuse PhpParser\\Node\\Expr;\nuse PhpParser\\Node\\Expr\\AssignOp;\nuse PhpParser\\Node\\Expr\\BinaryOp;\nuse PhpParser\\Node\\Expr\\Cast;\nuse PhpParser\\Node\\Stmt;\nuse PhpParser\\Node\\Name;\nclass StandardNew extends PhpParser\\PrettyPrinter\\Standard\n{\n  public function pScalar_String(PHPParser_Node_Scalar_String $node) {\n    return $this->pNoIndent($node->getAttribute('originalValue'));\n  }\n}\n?>\n```\nfoo.php\n```\n<?php\n$heredoc = <<<\"HEREDOC\"\n  print_r(\"this is a test \\n?\");\nHEREDOC;\n$nowdoc = <<<'NOWDOC'\n  print_r(\"this is a test \\n?\");\nNOWDOC;\necho $heredoc;\necho $nowdoc;\n```\nExpected output:\n```\n$heredoc = <<<\"HEREDOC\"\n  print_r(\"this is a test \\n?\");\nHEREDOC;\n$nowdoc = <<<'NOWDOC'\n  print_r(\"this is a test \\n?\");\nNOWDOC;\necho $heredoc;\necho $nowdoc;\n```\nThe output (view-source):\n$heredoc = ;\n$nowdoc = ;\necho $heredoc;\necho $nowdoc;\nDo you have any idea why this happens? and how I can achieve the expected output?\n. Thank you very much. This worked just fine!\n. ",
    "cameronjacobson": "Thanks for the advice.  I continue to find plenty of edge cases.  This experiment (obviously my first real deep diving into parser-level behaviors) has evolved to the following.  So far with the small amount of experimentation I've done with this library I'm optimistic this approach will get this project off on the right foot:\n\n/**\n *  SAMPLE:  a('b',2,g(d(e('g'))),b(c(d('h'))));\n *  CONVERTS TO:  \n  array('a' => \n    array('b', 2, \n        array('g' => \n          array('d' => \n            array('e' => \n              array('g')\n            )\n          )\n        ),\n        array('b' => \n          array('c' => \n            array('d' => \n              array('h')\n            )\n          )\n        )\n      )\n    );\n */\nclass MyNodeVisitor extends PHPParser_NodeVisitorAbstract\n{\n    public static $first = true;\n    public function enterNode(PHPParser_Node $node){\n        if (self::$first && $node instanceof PHPParser_Node_Expr_FuncCall) {\n            self::$first = false;\n            return new PHPParser_Node_Expr_Array(array(\n                new PHPParser_Node_Expr_ArrayItem(\n                    self::parseArgs($node),\n                    new PHPParser_Node_Scalar_String($node->name)\n                )\n            ));\n        }\n        if (!self::$first && $node instanceof PHPParser_Node_Expr_FuncCall) {\n            return new PHPParser_Node_Expr_ArrayItem(\n                self::parseArgs($node),\n                new PHPParser_Node_Scalar_String($node->name)\n            );\n        }\n    }\n    public static function parseArgs(&$node){\n        if(count($node->args) > 1){\n            foreach($node->args as $k2=>&$arg){\n                if($arg->value instanceof PHPParser_Node_Expr_FuncCall){\n                    $arg = new PHPParser_Node_Expr_Array(array($arg));\n                }\n            }\n        }\n        return new PHPParser_Node_Expr_Array($node->args);\n    }\n}\n\n. ",
    "hason": "In the project PsySH are classes for cleaning an user input so as to avoid fatal errors. PHPParser is trying to prevent some compile-time fatal errors (unfortunately incomplete), causing considerable difficulties because PHPParser behaves differently than PHP - see\nhttps://github.com/bobthecow/psysh/blob/master/test/Psy/Test/CodeCleaner/StaticConstructorPassTest.php#L37\n. ",
    "koriym": "That's enough for me. thank you !\n. ",
    "daviddeutsch": ":bow:\n. ",
    "scil": "thank you very much , i'm not familiar with PHP-Parser, i use your code without changes, and could not  get right results.\nmy situation is:\nphp code\n<?php array('author_id' => $data_id,'abc'=>array('ok'=>3,'no'=>$data_id+1));\nthen how could I get \n'$data_id' using $stmts[0]->items[0] , \n'3' using $stmts[0]->items[1]->items[0], and\n'$data_id+1' using $stmts[0]->items[1] ?\n. Thank you very much.  It works very well.\n. ",
    "GrahamCampbell": "So I should close this then?\n. I'll make another pull then...\n. Check #86.\n. I'd say 23 changed files with 155 additions and 60 deletions warrants a final 0.9.x release before 1.0.\n. Sounds great.\n. How close is the 0.9.5 release at the moment?\n. Cool. Thanks!\n. I agree @nikic. Composer all the way. :P\n. It would probably be a good idea to rebase against the master too.\n. Any news on this?\n. If you need to modify the code, why not fork it, and still use composer? You can use composer's \"replace\" functionality to get it compatible with the original if you change the package name.\n. Maybe we should raise this issue with hhvm as a php5 compliance issue?\n. @nikic Are you following semantic versioning? Is it safe to require 1.x and be sure things won't break in the future?\n. Awesome!\n. Why don't we drop support for those legacy names so we can move forward?\n. 1.0 is coming up. This is an opportunity to ditch the legacy stuff. If we used that argument for everything, where would be we @staabm?\n. Sure. Have you got a date in mind for 2.0? Will it be 2015, or later than that?\n. It might be nice to change some of the class names in 2.0. The classes I have in mind are all those classes that have to end in a _.\nMaybe PhpParser\\Node\\Const_  should become PhpParser\\Node\\ConstNode for example?\n. Yey. :)\n. My bad. Sorry...\n. I didn't notice PHP changed to Php. Maybe that could be made more prominent in the changelog?\n. For reference: http://php.net/manual/en/function.var-export.php.\n. Using laravel, you MUST install php parser 0.9.* otherwise everything will not work. Laravel depends on super closure that has a bug in the version constraint for php parser in 1.0.0 which will cause laravel to install the wrong version of php parser because composer will select super closure 1.0.0 over 1.0.1 because it appears comparable with a newer version of php parser that class preloader 1.1 requires.\nThis was fixed here: https://github.com/laravel/framework/commit/9b915f5e0cfc415af63a147de3ccb23c8c8230a2. But composer can still install an older version of laravel, thus causing issues...\n. nvm\n. Is that a php bug, or a php behaviour?\n. @nikic Right, I see. :)\n. That's not a multiple return type. That's telling you it returns an array of name nodes...\n. Because it's an array...\n. It returns an array.\n. > This doesn't make sense for return typing.\nYes it does. I can set a return type as string|null if I want. What's wrong with that?\n. Oh, right. So you're meaning the actual thing returned at a given instant rather than all things that could be returned separately?\n. Nice. Do you have a stable release date in mind? I was hoping we could get this into Laravel 5.2, scheduled for the start of December.\n. This can be closed now. :)\n. > Omg, schoolchild, go away with this spaming atack\nNo need to be rude. The way I see it, I'm preventing bad changes being made to a project I care about.\n. Why not just use --coverage-text on travis?\n. > This will works for all envs\nYeh, I know. I'm questioning why we actually want that.\n. I don't really like it turned on by default, and it's not, for good reason.\n. Scrutinizer should add it for you. Maybe disable and re-enable the project on scrutinizer, or contact support to get it added again.\n. Shame they don't support repairing the webhook. The service I work on supports that.\n. > Did you try to remove and add it again?\nI literally just said that:\n\nMaybe disable and re-enable the project on scrutinizer\n. I was just saying that it's possible, and easy to implement, since I've implemented it before. ;)\n. >  but it should be switched over sometime soon, right?\n\nNo, they intentionally made nightly 7.0., but you'd have to ask them what they plan on doing once php 7.0  is actually stable, because I'm not sure.\n. :+1:\n. Indeed. Those docs are only useful document properties that exist through php's magic methods.\n. Made some comments. I'm :-1: on the entire PR actually.\n. > Yes, on composer.lick file founded:\nThat's not the right part. The exact version number will be listed. Also you can run composer show -i to show the versions of all installed packages.\n. Looks like you need to install ext-tokenizer.\n. :D\n. Are you parsing as PHP 5 code, or PHP 7 please? This is only permitted in PHP 7 since list became semi-reserved.\n. On further inspection, it seems the break lies in \"PhpParser\\NodeVisitor\\NameResolver\", where on 2.x, this doesn't resolve functions calls, but on 3.x, it does.. Ah right, I see the commit now: https://github.com/nikic/PHP-Parser/commit/90834bff8eaf7b7f893253f312e73d8f532341ca.\nThis change is breaking, though, I can work around it without a massive fuss. I'll just now need to check the type of the node with getType instead of just assuming it was what I wanted.. Thanks. :). Oh, dear, but getType just returns Name_FullyQualified of course. I guess I really need to look for the actual nodes instead of just their fully qualified child that gets appended.. Doesn't this use now introduce a conflict with itself, if the error class is already autoloaded?. This bug should be fixed in HHVM, and no change should be made here IMO.. Actually, it doesn't look like PHP complains if something of the same name gets imported again, so this change doesn't break anything, but it's still not needed IMO.. Isn't this a breaking change? Calls to the parent construction will now throw an error after this change?\n\n. Not merging this PR, because it's a breaking change.. @ondrejmirtes You can only call it if it exists.. Travis is on RC5 now.. cs\n. cs\n. cs\n. :-1:\n. composer install --prefer-source\n. why add it?\n. just wastes time\n. too many newlines\n. it is pretty standard for symfony, which is what composer uses\n. It's not needed though. If you removed it, everything would still work.\n. you've added 2 newline characters instead of 1\n. meh, can we at least move it to \"before-install\" then\n. you should only generate coverage on 5.6, not every version\n. no need to move this\n. self-update is unneeded\n. ?\n. this is a major breaking change\n. this change doesn't make sense\n. these alignment changes don't make sense?\n. the code style of indenting by 4 spaces for each level is enforced here, but your changes break that\n. \ud83d\udc4e . ",
    "staabm": ":+1: for hhvm with allow failures. hhvm progresses very fast and consumers of this lib would immediately see when it actually works.\n. maybe the lib should ini_get check for xdebug.scream and throw a exception in case it is not 0?\n. nadermann recently blogged about this topic, http://blog.naderman.de/2014/02/17/replace-conflict-forks-explained/\n. you should add this binary also to composer.json\n. > you should add this binary also to composer.json\nsee https://getcomposer.org/doc/articles/vendor-binaries.md#how-is-it-defined-\n. less generic sounds like a good idea. not sure about phparse though.\n. lets see what @nikic likes best ;-)\n. relying on toString() instead of an explicit method call is considered a bad practice.\n. just for reference: since php 5.5. self::,parent:: and static::  are case insensitive\nphp.net/manual/en/migration55.incompatible.php#migration55.incompatible.self-parent-static\n. Why break BC when the current solution does not has obvious issues?\n. Your argument also counts for https://github.com/nikic/PHP-Parser/pull/175/files#diff-195da172622beb6ed449385e53e1f145L24 doesnt it? Its the same $r and now 1 alloc instead of 2...\nThe other line isnt that important, I agree. \n. Break after unset?\n. first line (before the php open tag) should be #!/usr/bin/env php\n. Should this also handle scientific notations?\n. is it really a typo? the next 2 lines also have this _?\n. I see. the class-name contains this underscore also, https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Builder/Class_.php\nso this PR seems to be invalid?\n. argh. I read it as the _ was removed with this PR :-).\neverything fine then. thanks for clarification.\n. ",
    "BnSmth": "PHP version 5.5.8. I got this whilst doing a composer update on a laravel site. The full stack trace was:\nPHP Stack trace:\nPHP   1. {main}() /var/www/sitename.com\u00a7/artisan:0\nPHP   2. Symfony\\Component\\Console\\Application->run() /var/www/sitename.com/artisan:59\nPHP   3. Symfony\\Component\\Console\\Application->doRun() /var/www/sitename.com/vendor/symfony/console/Symfony/Component/Console/Application.php:121\nPHP   4. Symfony\\Component\\Console\\Application->doRunCommand() /var/www/sitename.com/vendor/symfony/console/Symfony/Component/Console/Application.php:191\nPHP   5. Illuminate\\Console\\Command->run() /var/www/sitename.com/vendor/symfony/console/Symfony/Component/Console/Application.php:892\nPHP   6. Symfony\\Component\\Console\\Command\\Command->run() /var/www/sitename.com/vendor/laravel/framework/src/Illuminate/Console/Command.php:96\nPHP   7. Illuminate\\Console\\Command->execute() /var/www/sitename.com/vendor/symfony/console/Symfony/Component/Console/Command/Command.php:241\nPHP   8. Illuminate\\Foundation\\Console\\OptimizeCommand->fire() /var/www/sitename.com/vendor/laravel/framework/src/Illuminate/Console/Command.php:108\nPHP   9. Illuminate\\Foundation\\Console\\OptimizeCommand->compileClasses() /var/www/sitename.com/vendor/laravel/framework/src/Illuminate/Foundation/Console/OptimizeCommand.php:59\nPHP  10. Illuminate\\Console\\Command->callSilent() /var/www/sitename.com/vendor/laravel/framework/src/Illuminate/Foundation/Console/OptimizeCommand.php:82\nPHP  11. Symfony\\Component\\Console\\Command\\Command->run() /var/www/sitename.com/vendor/laravel/framework/src/Illuminate/Console/Command.php:140\nPHP  12. ClassPreloader\\Command\\PreCompileCommand->execute() /var/www/sitename.com/vendor/symfony/console/Symfony/Component/Console/Command/Command.php:241\nPHP  13. ClassPreloader\\Command\\PreCompileCommand->getCode() /var/www/sitename.com/vendor/classpreloader/classpreloader/src/ClassPreloader/Command/PreCompileCommand.php:206\nPHP  14. PHPParser_Parser->parse() /var/www/sitename.com/vendor/classpreloader/classpreloader/src/ClassPreloader/Command/PreCompileCommand.php:93\nPHP  15. PHPParser_Lexer->startLexing() /var/www/sitename.com/vendor/nikic/php-parser/lib/PHPParser/Parser.php:945\nPHP  16. PHPParser_Lexer->resetErrors() /var/www/sitename.com/vendor/nikic/php-parser/lib/PHPParser/Lexer.php:33\nPHP Notice:  Undefined variable: undefinedVariable in /var/www/sitename.com/vendor/nikic/php-parser/lib/PHPParser/Lexer.php on line 45 \n. It was whilst composer was generating optimized class loader.\n. I'm really at a loss as to what caused it. I just did composer dump-autoload -o and didn't get any errors + my site is working as normal.\n. @nikic I did indeed have xdebug.scream enabled, the provisioning script that I use with vagrant enables it. Should i disable this or not?\n(sorry for the slow response.)\n. ",
    "nick-jones": "@BenBradley: inspecting the backtrace, the error didn't originate from composer, but from Laravel's artisan command (which is run post composer update/install, see composer.json:24). So, running php artisan clear-compiled && php artisan optimize (or just php artisan optimize --force) may reproduce it?\n. ",
    "AleksMeshkov": "Don't know what to do with this error... Help me guys...\n``` php\nMail::queue('emails.welcome', $data, function($message)\n{\n    $message->to('foo@example.com', 'John Smith')->subject('Welcome!');\n});\nreturn 'ok';\n```\nWill produce\nok \nArray ( [type] => 8 [message] => Undefined variable: undefinedVariable [file] => /Users/malex/Devel/prj/vendor/nikic/php-parser/lib/PHPParser/Lexer.php [line] => 45 )\nBut if I comment this line it becomes ok.\n\n. @nikic thanks for reply! I'v done steps you asked me above, but nothing helps.\n. @nikic, why not remove this line?\n@$undefinedVariable;\n. ",
    "dvcrn": "Hello,\nI am having the same problem right now. Using a laravel application. When debug is set to false, artisan optimize fails with the error above. This is currently blocking my deploy process. \nAny work around for the time being? \n/edit: All right, just removed the line from composer.json for the time being\n. ",
    "Jamesking56": "I'm having the same issue, any update on this?\n. Yeah I can verify that changing xdebug.scream to 0 resolves the issue. Just tried it on a blank Laravel installation and Vaprobash.\n. ",
    "harris21": "``` php\nMail::queue('emails.welcome', $data, function($message)\n{\n    $message->to('foo@example.com', 'John Smith')->subject('Welcome!');\n});\nreturn 'ok';\n```\nThe problem lies on the Mail::queue function. When I am trying to use the Mail::send, it works fine, no errors. But with the Mail::queue, I do get the undefinedvariable error as well. \nI use xdebug.screm = '1' for both of them.\n. @Ocramius Yes, I did. Just wanted to point out that you can change the Mail::queue to Mail::send if queuing is not a necessity. Cheers!\n. ",
    "mrgodhani": "I am getting \"Undefined variable: undefinedVariable\" error too any solutions. I get it when I use queue in Laravel 4.\n. ",
    "simondavies": "Yeah i had the same issue and changed the xdebug.scream to 0 then re run composer and all went ok for me. was testing on a vagrant (Vaprobash) set up using laravel 4\n. ",
    "v1ncen": "Same issue with xdebug.scream with Laravel (using vagrant) when running artisan optimize (manually or with the post-install or post-update commands). \nSetting xdebug.scream=0 (in /etc/php5/mods-available/xdebug.ini) fixed it.\n. ",
    "varas": "Same issue with no xdebug extension:\nPHP error:  Undefined variable: undefinedVariable on /root/.composer/vendor/nikic/php-parser/lib/PHPParser/Lexer.phpon line 44\nUsing last version:\n\"name\": \"nikic/php-parser\",\n        \"version\": \"v0.9.4\",\n        \"source\": {\n            \"type\": \"git\",\n            \"url\": \"https://github.com/nikic/PHP-Parser.git\",\n            \"reference\": \"1e5e280ae88a27effa2ae4aa2bd088494ed8594f\"\n        },\n. ",
    "llaville": "Of course a simple getName() function will be enough for me ! \n. Thanks :)\n. I think that lot of people should act as you, and let down theirs pear channels because Fabpot has decided to let down Pirum. But I'm sad to see that nodoby know that there is a forked version of Pirum named Pirus which is still maintained by myself.\nI've started experience because I wanted the ability to customize easily the template of channel.\nIf you're interrested, have a look at my project page https://github.com/llaville/Pirus\nIt's almost the same as Pirum 1.1.5, and I plan to make a Pirus 2.0 this year\n. OK OK I  understand positions of everybody, but I'll let you study my case.\n@nikic ( I understand that you've your reason to not merge a PR ) \nI used PHP-Parser (as I said in purpose of this ticket ) with a little patch.\nActually I distributed it as a PHAR version ( no problems here, all dependencies are bundled ), and let other users pick my source code via composer.\nIf these users forget to get the right dependcy constraint (to pick the patch of my repo), they will lose time to see whats wrong, and probably open bugs on my side.\nSo what is the good solution, have a puzzle and manage pieces; is it your concept of dependency management ? \nPlease, try to understand my position :  I've nothing against anyone ( hope my english if enough to explains what I want to say )\n. @Ocramius I don't know if it was the best solution (I'm not a pro of composer), but I used this syntax\nhttps://github.com/llaville/php-reflect/blob/v2/composer.json#L28 to pick my version ( my php parser version patched )\n. @nikic  Thanks for the Reflect code review. I'm impressed to see that you are able to find such issue without source code analysed :-)\n. OK, if you can at least provide chunk of code (in script) that raise the issue !\n. Hello,\nI reply lately because I was on hollidays since 2 weeks and was back only yesterday.\nI'm sorry but your commit @nikic  won't work.\nReason is directive xdebug.overload_var_dump cannot be changed by ini_set. See php --re xdebug output that gave something like \n```\nExtension [  extension #80 xdebug version 2.2.5 ] {\n\n\nINI {\nEntry [ xdebug.overload_var_dump  ]\n  Current = '1'\n}\n```\n\n\nAnd also http://php.net/manual/en/configuration.changes.modes.php\n. Rather than apply this approach, why not just used the print_r solution that does not depend of xdebug configuration ?\n. @nikic Yes, it's better !\n. @niki I beg your pardon, but I don't see how to use / implement it in real condition.\nCould you explain me how you'll connect these two functions ?\n. @cmb69  and @nikic Thanks to you. I understand much more now the approach, and finally I could do something on my php-reflect project that implement the php-parser.\n. As I'm currently implemented the solution, I'll noticed that there is an error in isImplicitlyPublicFunction function provided by Nikita (probably a copy/paste from isImplicitlyPublicProperty).\nSo replace line $i = $prop->getAttribute('startOffset'); by $i = $method->getAttribute('startOffset');\n. @nikic I was pretty glad of the solution after first unit test. But, there is a but, I can't solve, and I need your point of view.\nTo use the LexerWithTokenOffsets, we need tokens, that are initialized line 55 after the parser line 54. This is what I called the standard process.\nNow, the BUT.  If you don't parsed again your code, and used a cached version of the AST, like I did in php-reflect ( See lines 115 to 126 ), it does not work anymore.\nAny idea to solve a \"cache\" problem implementation ? \nHope my explain are enough. \n. If you want to see result of my implementation. Have a look on the TokenOffsets branch.\nSee changes at commit https://github.com/llaville/php-reflect/commit/4daccd5eae0d8a86cef9192a230abcf549056ce6\nBe carefull, this implementation run fine only if you don't add the cache plugin. (In my previous comment lines 115 to 126).\n. @niki Thanks for your answer. I was away this week-end, so I reply only now.\nFinally I've adopted another solution. To avoid lot of impacts and problem, with cached AST results, I read online the tokens list. \nAnd I got expected results. \nYour solution works as expected, so I'll close this issue.\n. @cmb69 Have you tested the previous solution without the commit ? \nOn first run it works, but on second run if you've the cachePlugin it fails !\nNOTE: the TokenOffesets lexer used extends the Emulative lexer \n. @nikic About the page token offset lexer :  There is a function misspell : You 've declared isDeclaredUsingVar() and used isImplicitlyPublicProperty() in MyNodeVisitor.\nBTW: Thanks to add this example in the official documentation :)\n. @suralc Very interesting project (pvra). I've just take a look, and seems really promising.\nAs, I said, in an old version of my roadmap, I'd like to implement such PHP features analyser.\nBut my priorities changed. So I'm happy to see that an alternative exist !\nPerharps, before the stable release of new major version 4.0, a similar analyser will be born.\nUntil this day come true, I've a big challenge, almost reach, detection of conditional code.\n. Unless, of course you want to keep chained options feature ( like -d -p -N -d ). It's up to you to choose !\n. Have a look on namespace Sandbox where a FALSE constant was defined.\nWhen the  var_dump( FALSE ) is executed on Sandbox, this is  \"not_true\" (and not bool(false) ) that is printed.\nBut when you read the AST you can't see a difference between the const fetch statements in two namespaces (global and sandbox)\nThe nodes dump below is a limited version of script code initially provided.\n0: Stmt_Namespace(\n    name: null\n    stmts: array(\n        0: Expr_FuncCall(\n            name: Name(\n                parts: array(\n                    0: var_dump\n                )\n            )\n            args: array(\n                0: Arg(\n                    value: Expr_ConstFetch(\n                        name: Name(\n                            parts: array(\n                                0: FALSE\n                            )\n                        )\n                    )\n                    byRef: false\n                    unpack: false\n                )\n            )\n        )\n    )\n)\n1: Stmt_Namespace(\n    name: Name(\n        parts: array(\n            0: Sandbox\n        )\n    )\n    stmts: array(\n        0: Expr_FuncCall(\n            name: Name(\n                parts: array(\n                    0: var_dump\n                )\n            )\n            args: array(\n                0: Arg(\n                    value: Expr_ConstFetch(\n                        name: Name(\n                            parts: array(\n                                0: FALSE\n                            )\n                        )\n                    )\n                    byRef: false\n                    unpack: false\n                )\n            )\n        )\n    )\n)\nMy question is then :  How can I make the difference between the two FALSE calls ?\nHope this time, my explains are bette \n. If you want to see concrete example, I've just finished to implement in my project (see detect conditional code link above)\n. In my case (my project https://github.com/llaville/php-compat-info/tree/4.0) I've features called \"analysers\" (no more no less than just node visitors) and each of these analysers are specialized.\nI can use one (default analyser) or more than one at the same time.\nBut when the analysis is run, for each file parsed, AST is traverse in major or case one times only.\n\"compatibily\" analyser is a special case that need to know first if conditional code is present to works fine.\nIt will be a nightmare to me to implement such two passes process !\nBTW, if you think it's useless for the community, I can understand. This is the reason, I've already implemented it.\n. Concept of NodeProcessor is for me, ability to initialize a shared context before to run the main process ( a NodeVisitor).\nTell me if I'm wrong, but if I follow your recommandation, using a new NodeTraverser in the beforeTraverse method.\nThe context initialized with the first instance (pass 1) is not shared with the second instance (pass 2).\nAnd there is also an Infinite loop issue. Did I missed something ?\n``` php\n<?php\nuse PhpParser\\NodeVisitorAbstract;\nclass MyNodeVisitor extends NodeVisitorAbstract\n{\n    public function beforeTraverse(array $nodes) \n    {\n        $traverser  = new PhpParser\\NodeTraverser;\n        $traverser->addVisitor(new MyNodeVisitor);\n    $stmts = $traverser->traverse($nodes);\n\n}\n``\n. Finally, I'll drop this request and my solution to find conditional code, that is not enough.\nI need to parse all files from data source to have a full context, not just the current file visited \n. Ok it's a recommandation to added to your pagedoc/2_Usage_of_basic_components.markdown`.\nI run the test with 10000 and memory_limit = -1, and I got results. \n. @nikic One more warning, and perharps tip, you should add is : \nIf you've trouble with nesting level limit, just try without xdebug extension loaded.\nThis is what I've experimented and I gave good (better) results when I try to analyse the ZF1 source code with my project (php-compatinfo). \n. FYI, I've almost solved my problem in php-compatinfo, even it's not yet perfect.\nIn my visitor, enterNode() I 've dupplicated at twice location the Node\\Param process  \n``` php\n<?php\n    } elseif ($node instanceof Node\\Stmt\\Function_\n        || $node instanceof Node\\Expr\\Closure\n        || $node instanceof Node\\Stmt\\ClassMethod\n    ) {\n          // analyse functions with their parameters\n\n    } elseif ($node instanceof Node\\Param) {\n         // parameters with type hint are here resolved\n\n``\n. With the same explain I gave you when I've proposed theNodeProcessor` concept, my implementation add the name resolver as first visitor , then additional visitor (1 to n). And Run a pre-condtion parsing process to find conditional code.\nSo it's too complex for me. But I'm +1 if you can resolve name earlier\n. FYI, my \"complex\" implementation of PHP-Parser it resume on the parse() method at https://github.com/llaville/php-reflect/blob/3.0/src/Bartlett/Reflect.php#L113\n. @nikic Thanks for the fast solution implementation !  I'll check it tomorrow \n. I've just tested the new dev-master version, and it's works like a charm. Thanks a lot !\nBefore php-compatinfo 4.0.0-RC2, when you try to analyse such snippet code (remember the type hinting about Doctrine cache), we get this kind of output \n```\nClasses Analysis\nClass                       Matches REF  EXT min/Max PHP min/Max PHP all\n\nU Console_Table               1       user             4.0.0\n    DateTime                    1       date 5.2.0       5.2.0\n  U Doctrine\\Common\\Cache\\Cache 1       user             5.3.0\n    Foo\\Bar                             user             5.3.0\n    function __construct                user             4.0.0       5.3.0\n    function foo                        user             5.3.0\n  U Foo\\Foo                     2       user             5.3.0\n    PDO                         1       PDO  5.1.0       5.1.0\n  U SebastianBergmann\\Version   1       user             5.3.0\n    Total [7]                                            5.3.0\n```\nThis is a little wrong, because Foo\\Bar\\__construct() requires PHP min 5.3.0 due to type hinting.\nAnd now with your fix, without changing a line of code on php-compatinfo, we can get \n```\nClasses Analysis\nClass                       Matches REF  EXT min/Max PHP min/Max PHP all\n\nU Console_Table               1       user             4.0.0\n    DateTime                    1       date 5.2.0       5.2.0\n  U Doctrine\\Common\\Cache\\Cache 2       user             5.3.0\n    Foo\\Bar                             user             5.3.0\n    function __construct                user             5.3.0\n    function foo                        user             5.3.0\n  U Foo\\Foo                     2       user             5.3.0\n    PDO                         1       PDO  5.1.0       5.1.0\n  U SebastianBergmann\\Version   1       user             5.3.0\n    Total [7]                                            5.3.0\n```\n. @nikic is it possible to have a new release 1.2.2 ?\n. Sorry for disturbing. I'm pretty sure if was not possible.\n. My ambiguous position is because I don't see until now a code like that \n```\ninterface PA\ninterface PB\ninterface M extends PA, PB\nclass Foo implements M\n```\nBut rather code like that \nclass Foo implements PA, PB\nSee full example and strange results not documented in PHP API Reflection \n``` php\n<?php\ninterface PA\n{\n    function fPA();\n}\ninterface PB\n{\n    function fPB();\n}\ninterface M extends PA, PB\n{\n    function fM();\n}\nclass Foo implements M\n{\n    function fPA() { echo FUNCTION, PHP_EOL; }\n    function fPB() { echo FUNCTION, PHP_EOL; }\n    function fM()  { echo FUNCTION, PHP_EOL; }\n}\nclass Bar extends Foo \n{\n}\n$foo = new Foo;\n$foo->fPA();\n$foo->fPB();\n$foo->fM();\n$rc  = new ReflectionClass('Bar');\n$obj = $rc->getParentClass();\nprint_r ($obj);\n$rc  = new ReflectionClass('PA');\n$obj = $rc->getParentClass();\nprint_r ($obj);\n$rc  = new ReflectionClass('M');\n$obj = $rc->getParentClass();\nprint_r ($obj);\n```\n. Ok, so If I've well understood, with same code (without emulative lexer), we CAN both parsed old code valid for PHP 5.3 and new code PHP 5.4 , 5.5 or 5.6.\nOr is it something I 've forgotten, or misunderstood with the emulative lexer. \n. In doc we can read \n\nUse of the emulative lexer is required if you want to parse PHP code from newer versions than the one you're running on. For example it will allow you to parse PHP 5.6 code while running on PHP 5.3. \n. My goal is to write an analyser (for php-compatinfo) that is supposed to scan source code and checks old elements found to migrate easily from an old PHP version to a new one.\n\nActually I know three projects that try to did it : \n- https://github.com/wimg/PHPCompatibility/ , but it's only for PHP_CodeSniffer that used only tokenizer extension\n- https://github.com/monque/PHP-Migration, that used PHP-Parser, but i'ts certainly impossible to do it (used also the lexer emulataive)\n- https://github.com/suralc/pvra, that used PHP-Parser and and extended version of your lexer emulative.\nMy project (php-compatinfo) is able to accept 1 to many analysers (NodeVisitor) at same time, but always used the same php-parser run-time.\nSo I don't think (now) we can have a simple solution. \nSuch migration analyser is probably a good idea, and its most popular in PHPCompatibilty project (by wimg). I'd really like a such alternative with AST and PHP-Parser.\nIf someone has an idea, feel free to share !\n. @nikic Good news. I've found a solution that will allow to detect keyword reserved with the emulative lexer and keep it working as expected.\nAs the fix must be applied on the lexer emulative, I'll propose you a diff that I'll explains now !\nWe can either use a new option to configure it, but for now, I've only set the keywords reserved detection to class (T_CLASS) and function (T_FUNCTION) context. See the $allowKeywordsReserved property.\nIf we run a build AST script (as declared in my introduction) with PHP 5.3, only new keywords (with PHP 5.4, 5.5, see $newKeywords property) will be accepted in class and function name context. \nThe token won't be replaced and keep it as T_STRING\nOtherwise the token T_STRING will be replaced by its new value configured ($newKeywords).\nWhat do you think of this proposition ?\n```\ndiff --git a/lib/PhpParser/Lexer/Emulative.php b/lib/PhpParser/Lexer/Emulative.php\nindex 837def4..4656064 100644\n--- a/lib/PhpParser/Lexer/Emulative.php\n+++ b/lib/PhpParser/Lexer/Emulative.php\n@@ -11,6 +11,8 @@ class Emulative extends \\PhpParser\\Lexer\n {\n     protected $newKeywords;\n     protected $inObjectAccess;\n+    protected $keywordsReservedContextAllowed;\n+    protected $allowKeywordsReserved;\n const T_ELLIPSIS   = 1001;\n const T_POW        = 1002;\n\n@@ -40,6 +42,11 @@ class Emulative extends \\PhpParser\\Lexer\n             ),\n         );\n\n// GH-202\nif (version_compare(PHP_VERSION, self::PHP_5_4, '<')) {\n$this->allowKeywordsReserved = array(Parser::T_CLASS, Parser::T_FUNCTION);\n\n}\n+\n         $this->newKeywords = array();\n         foreach ($newKeywordsPerVersion as $version => $newKeywords) {\n             if (version_compare(PHP_VERSION, $version, '>=')) {\n@@ -66,6 +73,7 @@ class Emulative extends \\PhpParser\\Lexer\npublic function startLexing($code) {\n     $this->inObjectAccess = false;\n+        $this->keywordsReservedContextAllowed = false;\n $preprocessedCode = $this->preprocessCode($code);\n parent::startLexing($preprocessedCode);\n\n@@ -212,16 +220,20 @@ class Emulative extends \\PhpParser\\Lexer\n }\npublic function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n+        //if ($this->pos < 0) error_log ( FUNCTION . \" tokens: \\n\" . print_r($this->tokens, true) );\n     $token = parent::getNextToken($value, $startAttributes, $endAttributes);\n+        //error_log ( FUNCTION . \" pos: \" . $this->pos . \", next:\\n\" . print_r($token, true) . PHP_EOL . print_r($value, true));\n // replace new keywords by their respective tokens. This is not done\n // if we currently are in an object access (e.g. in $obj->namespace\n // \"namespace\" stays a T_STRING tokens and isn't converted to T_NAMESPACE)\n if (Parser::T_STRING === $token && !$this->inObjectAccess) {\n\n\nif (isset($this->newKeywords[strtolower($value)])) {\nif (isset($this->newKeywords[strtolower($value)]) && !$this->keywordsReservedContextAllowed) {\n             return $this->newKeywords[strtolower($value)];\n         }\n     } else {\n$this->keywordsReservedContextAllowed = in_array($token, $this->allowKeywordsReserved);\n+\n         // keep track of whether we currently are in an object access (after ->)\n         $this->inObjectAccess = Parser::T_OBJECT_OPERATOR === $token;\n     }\n\n\n\n``\n. Of course I understand. On the concept we keep it going with something equivalent that do no check the current$allowKeywordsReservedconfiguration, but by setting only a$allowKeywordsReserved  = true` and do not replaced new keywords when we run with PHP 5.3 (keep T_STRING). That will allow all contexts (as you explained)\nHope I'm enough clear on my new comment !\n. That will give something like \n```\ndiff --git a/lib/PhpParser/Lexer/Emulative.php b/lib/PhpParser/Lexer/Emulative.php\nindex 837def4..5e79b54 100644\n--- a/lib/PhpParser/Lexer/Emulative.php\n+++ b/lib/PhpParser/Lexer/Emulative.php\n@@ -11,6 +11,7 @@ class Emulative extends \\PhpParser\\Lexer\n {\n     protected $newKeywords;\n     protected $inObjectAccess;\n+    protected $allowKeywordsReserved;\n const T_ELLIPSIS   = 1001;\n const T_POW        = 1002;\n\n@@ -40,6 +41,9 @@ class Emulative extends \\PhpParser\\Lexer\n             ),\n         );\n\n// GH-202\n\n$this->allowKeywordsReserved = version_compare(PHP_VERSION, self::PHP_5_4, '<');\n+\n         $this->newKeywords = array();\n         foreach ($newKeywordsPerVersion as $version => $newKeywords) {\n             if (version_compare(PHP_VERSION, $version, '>=')) {\n@@ -66,6 +70,7 @@ class Emulative extends \\PhpParser\\Lexer\npublic function startLexing($code) {\n     $this->inObjectAccess = false;\n+        $this->keywordsReservedContextAllowed = false;\n $preprocessedCode = $this->preprocessCode($code);\n parent::startLexing($preprocessedCode);\n\n@@ -212,13 +217,15 @@ class Emulative extends \\PhpParser\\Lexer\n }\npublic function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) {\n+        //if ($this->pos < 0) error_log ( FUNCTION . \" tokens: \\n\" . print_r($this->tokens, true) );\n     $token = parent::getNextToken($value, $startAttributes, $endAttributes);\n+        //error_log ( FUNCTION . \" pos: \" . $this->pos . \", next:\\n\" . print_r($token, true) . PHP_EOL . print_r($value, true));\n // replace new keywords by their respective tokens. This is not done\n // if we currently are in an object access (e.g. in $obj->namespace\n // \"namespace\" stays a T_STRING tokens and isn't converted to T_NAMESPACE)\n if (Parser::T_STRING === $token && !$this->inObjectAccess) {\n\n\nif (isset($this->newKeywords[strtolower($value)])) {\nif (isset($this->newKeywords[strtolower($value)]) && !$this->allowKeywordsReserved) {\n             return $this->newKeywords[strtolower($value)];\n         }\n     } else {\n```\n\n\n\nKeep keywords as T_STRING, do not replaced it by $newKeywords token values only if we run PHP 5.3 \n. In my PHP test script (previously defined at top) replaced the $code with such sample \n``` php\n<?php\n$code = '<?php\nclass Trait\n{\n    const FOO = \"foo\";\n}\nclass finally\n{\n    function __construct()\n    {\n        $trait = new Trait;\n    $foo = Trait::FOO;\n}\n\n}\n';\n```\nIt seems good\n. A concrete example and basic implementation, if you want to solve this issue, is presented (will lot of explains) in https://github.com/llaville/php-compat-info/issues/202#issuecomment-106249945\n. @nikic You'll be perharps interrested by solution (update) I found and implemented in https://github.com/llaville/php-compat-info/issues/202#issuecomment-108857062\nIn summary, here are modifications on my Emulative Lexer version\nhttps://github.com/llaville/php-reflect/commit/c8281072da0980c5e7b7bdfb72cc354d93e8144c\n. @nikic Almost one month I used my copy of modified Emulative lexer (see previous comment, commit in php-reflect project) in real condition without found a new issue.\nDid you think we could integrate it in PHP-Parser ? If not, close this issue at your disposal, I'll keep a copy in my project !\n. @nikic You right, and I fixed this issue with commit https://github.com/llaville/php-reflect/commit/4be20c38f8b11ada5b1ef7ddf549581c7ecd060a\nThanks\n. ",
    "fieryprophet": "PHPParser classes only. And it loads the bootstrap.php file which then loads the PHPParser\\Autoloader class.\n- Elijah\nOn Feb 21, 2014, at 12:29 PM, Nikita Popov notifications@github.com wrote:\n\nA few questions to clarify: When you say it would never resolve the class: Does it fail on PhpParser classes or on your own? Also, does it only include lib/PhpParser/Autoloader.php or does it include lib/bootstrap.php?\n\u2014\nReply to this email directly or view it on GitHub.\n. That fixed it, thanks.\n. \n",
    "clemens-tolboom": "Maybe we should rename the script as it now appear into vender/bin ?\nWhat about phparse to make it's name less generic?\n. What about php-parse without .php\n(btw thanks for the hint esp. composer bin)\n. @RobLoach this PR is superseded by @nikic bin/php-parse.php.\nI'll close this one for now.\n. This should be fixed by #35 but is not.\nWe are using  \"nikic/php-parser\": \"1.0.*@dev\", which is latest master.\n. ic ... I'm running on 5.4.29 using https://github.com/clemens-tolboom/uml-generator-php on a Drupal 8 code tree ... so I am unaware of its vendor/ content.\nMy guess is in https://github.com/clemens-tolboom/uml-generator-php we should skip vendor///tests to start with.\nThanks for the quick reply.\n. ",
    "muglug": "For anyone tracking, the above is no longer true - $stmts = $traverser->traverse($stmts); returns the exact same collection of objects.\nBut PhpParser\\NodeVisitor\\CloningVisitor mostly does the job (doc comments are not cloned). Thanks! Right now the class hierarchy is based on structure - all types in docblocks/typehints are handled as Union types, even if they only contain a single Atomic type. Atomic types can be simple, Generic or ObjectLike. This means support for nullable types is pretty simple - just checking whether a Union contains an Atomic type with the value 'null' - a simple isset check.\nAdding support for NullableType as a child class of Union would mean a non-trivial update to the logic when doing a null check (where a Union type is cloned, then stripped of its null value) and I'm not sure the benefits outweigh.\nBut if/when I do add NullableType, I might also add FalsableType (bc PHP stdlib loves those possiblyfalse return values), and many libraries follow suit.. Oh ok! That makes total sense.. I've removed the typehints that were necessary for the static analysis tool to understand the code, having improved the tool to compensate.. @Rivendall include statements can use any expression that PHP can evaluate for the file, so your solution would need (for all but the simplest case) to have an understanding of magic constants like __FILE__, commonly-used functions like dirname etc. This is outside the scope of PhpParser, but a number of static analysis tools are able to infer those paths with a high hit rate.. Sure! I've added a config to control whether void return types are added, and I've updated this PR's commit accordingly.. Thanks! To that last point, how about throwing an exception if both $name1 and $name2 are null in PhpParser\\Node\\Name::concat? It seems like that can never happen, at least in PhpParser's own usage of that method. Doing so would erase the null value from that return type, and solve that particular issue.. Yup, there's no reason why Psalm shouldn't be able to understand that formulation for ObjectLike types when processing ArrayDimFetch and when destructuring lists. I will ticket and add soonish. \nGenerating that type is considerably less trivial (as there are a bunch of different desired outcomes depending on the different return statements in a function), but I'll ticket that as well.. Looks like you added this possibility in https://github.com/nikic/PHP-Parser/issues/161#issue-53023834 \u2013 but it would be great if you could update the interface's return type (maybe with a note?).. I've just touched this up a wee bit. Happy to squash the commits.. Thanks!. @Gert-dev @nikic I'm working on incremental parsing for Psalm. Current activity is in https://github.com/vimeo/psalm/tree/server-temp-changes but it'll likely get merged into master soon.\nFor dealing with a change in a method in a large file (I'm using one from PHPMailer) has the following results:\n```\nPartial parsing: diffing lines:     0.0073\nPartial parsing: cloning:           0.0169\nPartial parsing: parsing traverser: 0.0250\n\nPartial parsing:                    0.0499\nFull parsing:                       0.0842\n```\nParsing an even larger file, a closed-source 10K-line behemoth, gives these results:\n```\nPartial parsing: diffing lines:     0.0182\nPartial parsing: cloning:           0.0481\nPartial parsing: parsing traverser: 0.0762\n\nPartial parsing:                    0.1438 \nFull parsing:                       0.2750\n```. @Gert-dev here's the (more mature) file that's used today: https://github.com/vimeo/psalm/blob/03ea94e087a10a69def73a1b6e38121bfe0f301f/src/Psalm/Visitor/PartialParserVisitor.php. If it's fixed in master, isn't it just fixed, period? Even though there isn't a release that includes that fix.. Thanks!. yeah, no big deal \u2013 architecture wasn't ideal. Out of interest, how are were you able to discover such a small regression with significance?. I think the functionally-equivalent code to the above line is:\nphp\nif (isset($_GET[\"name\"])) {\n    $ref =& $_GET[\"name\"];\n} else {\n    $ref = null;\n}. Ah thanks!. @spidgorny you can use a plugin with Psalm after it does type inference to extract the information you need, but you may also want to check out Psalm's source code and adapt it to your own ends.. Oh, just the inconsistency that Array_ on the LHS of an assignment may have items that are null (like List_), but an Array_ on the RHS of an assignment is guaranteed to never have null items.. @TomasVotruba \nphp\n[$a, $b,,, $c] = [1, 2, 3, 4, 5];. Makes sense \u2013 I'm about 12 months late with this. > Presumably that would appease the static analyzer?\nSorry, I'm an idiot for just relying on the documentation ;). I'll update the static analyser's idea of what ctype_alnum can expect.. Fixed here: https://github.com/vimeo/psalm/commit/123f70fc524aa930cdda455698e3783b7cda98a0. >  Is that good enough?\nIt's great!. Hey @TomasVotruba - thanks for the heads-up. I'm aware of the other parser, and have decided against using it - it still has a few bugs around handling of valid PHP syntax, and I'd rather deal with these minor parsing-of-invalid-code gripes vs parsing-of-valid-code gripes.\n@nikic has also shown a great willingness to indulge those of us who are starting to use PHP Parser for making live updates to code - some recent releases have explicit callouts to improved error recovery in certain situations to allow the rest of the AST to be parsed.\n. Example where the parser recovers from a missing semicolon, allowing Psalm to infer the return type is wrong: https://getpsalm.org/r/bffe1b1f43, . Thanks!. > Could you share some links to psalm where this is used?\nShort answer: not yet\nLonger answer: The latest releases for Psalm allow you to run a language server to show diagnostics on open and save.\nA lot of similar language servers support onChange events too, and I'm working on adding that support to Psalm in this branch.\nPart of that effort involves incremental scanning - that is, scanning only the part of the AST that the user has changed, and readjusting file offsets in the resultant AST to match the expected one.\nIf that partial parsing fails, a hacky fix is applied and parsing re-attempted, and if that fails the whole AST is re-scanned. Whole-file parsing can be expensive for large files, especially as that same failure will occur, resulting in a null AST for the entire file.\nCompounding that, while in Language Server mode I also perform AST diffing to ensure that no method gets re-analysed as long as none of its dependents have changed (analysis is much more costly than parsing). Without the above fix that AST diffing would mark every node as having changed, forcing them all to be re-analysed. That's not a problem in a small file, but can be annoying when editing a 5-thousand line file as it means that the illusion of checking-as-you-type is lost.\n. Background here is > triggers a completion provider - so long as the LHS of that is a node, I can send off the appropriate data.\nEdit: My extremely hacky workaround when partial parsing fails is to try parsing again, but with \"->\\n\" replaced with \"~;\\n\" (which produces a recoverable error).. > because of the PHP \"feature\" to support arrays with both [] and {}\n\ud83e\udd26\u200d\u2642\ufe0f\nThe only other option I can think of is having a version of the parser designed just for possible autocompletion of PHP7 code that dropped support for {} access on expressions.\nPsalm's LSP mode already uses a separate cache from its regular command-line-invoked analysis, so the soundness of its results (e.g. in CI) wouldn't be affected.\nIf I opened a PR that created a PhpParser\\ParserFactory::PHP7_AUTOCOMPLETE parser, might you be willing to accept that? It would apply a couple of patches to php7.y and build a separate Php7Autocomplete.php parser.\nIf not, I can close this as there's not much of a way forward.. A different alternative fix means that error recovery is diminished for\nphp\n[$foo $bar]; // only $foo is in parsed results. I think the culprit is\ncomma_or_error:\n      ','\n    | error\n;\nRemoving | error prevents the problem (but also breaks more recovery tests than my fix). Awesome, thanks!. Thanks! Added those (and a few others). oh ok \u2013 fixed!. Unfortunately 0 and 1 as keys imply that they are strings, so argument unpacking wouldn't work there. A solution is either to add string array offsets (and change what the method returns, and how it's used above) or just strip out the return types for now.\nObviously PHP 7.1's array key destructuring would simplify that diff, but happy that PhpParser is PHP 5-compatible.. Ah bugger. Sorry. It's because both classes have a __toString method, and Psalm gets confused when merging the types. Fixing.... There was existing logic to support ints being cast to floats in function calls, and it (falsely) trickled into the type simplification logic \u2013 fixed here: https://github.com/vimeo/psalm/commit/5ec2a9742b3e39c6320509cb9f2e565da1505ac3. Yes \u2013 really, it's just telling Psalm not to worry. I could also put a /** @var int **/ declaration above thestrposcall, which would prevent the actual code from becoming polluted..FirstFindingVisitor::beforeTraverseinherits the return typenull|Node[], and this explicit (and I agree, wholly unnecessary given PHP's internals)return` statement acknowledges that.. ",
    "hgati": "ok, I'll use the provoded autoloader.\n. ",
    "patinthehat": "Would implementing some type of custom comments, such as:\n#PARSER_IGNORE_START\n    //code to ignore\n  #PARSER_IGNORE END\nbe a viable alternative?  It would allow users the flexability to ignore other code sections as well.\nJust a thought -- let me know what you think.\n--Trick\n. ",
    "novacrazy": "@patinthehat If you're going to do something like that it might just be easier to run it through a C-preprocessor before you send it to the lexer. \n. ",
    "fluxreiners": "thank you for your replies.\n@nikic a size limit is prone to false positives, there are other large files in that range that define classes and methods. I added a file size check of 1MB though.\n@patinthehat modifying the files manually decreases the usability too much (consider thousands of PHP files to check)\n. @nikic good idea, that is what I am doing now. I skip files larger than 1MB and for files that are greater than 200kb I add a tokenizer check.\n. ",
    "adineer": "@nikic Thanks for quick reply, first thing I did is that I added the test, it failed, then \"fixed\" it. Maybe it's PEBKAC, but doubt it :)\n. Point taken.\n. ",
    "Xeoncross": "Thank you very much. Now I see the same format for Node_Expr_MethodCall and Node_Expr_FuncCall as well.\n. Thank you! $prettyPrinter->prettyPrint([$node]) works great!\n. ",
    "ruudvanderweijde": "To get the params add:\nprint $this->pp->prettyPrint($node->params) . \"\\n\";\nTo get the docblock: https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeAbstract.php#L64\n$node->getDocComment();\n. Are you running version 0.9.3 or lower?\nPHP 5.5 is supported since 0.9.4\n. ",
    "marcioAlmada": "@Ocramius Thanks!\nI was still looping through the docs and missed this one: https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#pretty-printer\n. ",
    "rdlowrey": "\n. General +1 for test case inclusion in PRs.\n. ",
    "bwoebi": "So, you want to make it impossible to execute it through phpdbg? And every other future cli like SAPI?\n. ",
    "Mikulas": "Turns out there is a better way of achieving what I originally intended to use this for. Closing\u2026\n. Sure. I want to make git context aware, so a diff would for example highlight api changes and suppress inner method refactoring and typos that do not affect the method from the outside. (Practical for larger projects where it's unviable for everybody to know and understand every single line of code in the codebase).\nOriginally I let php-parser parse both file revisions and I detected changes based on the lines changed reported by git diff command. This proved fundamentally flawed. Way better approach is to compare the trees directly (even though considering the performance hit) where no lines are required whatsoever.\n. ",
    "dhotson": "Cool, thanks for the advice! :)\n. ",
    "BluntSporks": "OK, I reviewed this and the only feature that depended on the IDs of reduction actions was the preservation of heredoc strings. That feature is useful to me, so I kept it in my local copy, however I removed it from the version that I posted here in my latest commit. So this change should be ready to review and merge by you. Please let me know if you have any further trouble. Thanks!\n. I thought they weren't interested in the updates and already deleted my\nrepo. So don't worry about it.\nOn Thu, Sep 10, 2015 at 6:42 AM, Dmitry Patsura notifications@github.com\nwrote:\n\nAny news on this?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nikic/PHP-Parser/pull/116#issuecomment-139201510.\n. \n",
    "ondrejmirtes": "Look at Travis, you should fix the tests.\n. Also exit accepts a status code, die accepts a string to print.\n. @nikic Sorry, my bad. I used these functions in this way but didn't check the documentation before writing my remark.\n. @nikic By the way, this is the project I use PHP-Parser on: https://medium.com/@ondrejmirtes/phpstan-2939cd0ad0e3 (https://github.com/phpstan/phpstan) :). I tried a different approach, see the diff. Another place that could have NullableType can just call the wrapName function. I really don't know how to solve this by modifying the enterNode method since the FunctionLike signature is quite nested in the tree.\nI'd like if you helped me with this since you have a better idea how to solve this :) Thanks!\nThe original approach is here https://github.com/ondrejmirtes/PHP-Parser/commit/a25a93a7b7cf85560d44714b2bf25fff5deae793 if you consider it a better starting point.. Great, thank you!. OK, thanks for explaining! Yes, it's possible to eliminate possible types before passing the value to another place which I'll do \ud83d\ude0a. @TomasVotruba You should always call parent constructor. Even PHPStan points that out \ud83d\ude0a. Of course, I know. But you should call it if it exists.\nOn Fri, 31 Aug 2018 at 19:23, Graham Campbell notifications@github.com\nwrote:\n\n@ondrejmirtes https://github.com/ondrejmirtes You can only call it if\nit exists.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nikic/PHP-Parser/pull/528#issuecomment-417734553, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAGZuMaDSCr3w8sEVA9hbexKn8DPty10ks5uWXEAgaJpZM4V6Saw\n.\n-- \n\nOnd\u0159ej Mirtes\n. OK, thanks \ud83d\ude0a When do you plan to release 4.0.4? So I know how much time do\nI have to fix this \ud83d\ude0a\nOn Sat, 1 Sep 2018 at 13:25, Nikita Popov notifications@github.com wrote:\n\nTo clarify, what your code currently does is create a fully-qualified name\nwith components \"\", \"Foo\", \"Bar\". If you call toCodeString() on it, you'd\nget back \\Foo\\Bar. This is very likely not what you intended, which is\nwhat the new check is there to prevent.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nikic/PHP-Parser/issues/530#issuecomment-417852915,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAGZuHJX8vdPM389NBsCvWoKTpAqsrjNks5uWm61gaJpZM4WVGhS\n.\n-- \n\nOnd\u0159ej Mirtes\n. No, Exception is fine, warnings feel like they are from the last century (un-catchable and weird). Thank you!. I fixed it in PHPStan's codebase but I really suspect this will break people's code. What do you think about normalizing the string silently, e.g. trimming the backslash on the left side in the constructor? Only in case the result is unambigous.... OK, thanks. Feel free to close it or target 5.0 - but I'm not encouraging you to start a new major version because the transition period brings a lot of interoperability problems between tools and projects :) I'm happy that PHP-Parser stays in 4.x longer right now.. ",
    "ovr": "Any news on this?\n. @fezfez \nBut without xdebug it's not working :(\nMaybe we can rewrite it in better way\n. > The recursion limit only exists if xdebug is used\n\nOh okey, I see\nI thought that it's a standart functionality in php core but can be changed by xdebug\nMy miss :(\n\n@fezfez @nikic \nThanks\n. ping @nikic \nIt's needed for next scrutinizer ci, because i am going to setup \"sending code coverage report\" to it\n\nI am going to use required-dev phpunit\n. @GrahamCampbell \nOmg, schoolchild, go away with this spaming atack\n. @GrahamCampbell \nThis will works for all envs\n. It's a suggestion, in my opinion \"it's rly cool\"\n. I will close it, and send PR with scrutinizer CI code coverage\n. Yeap I can use any container, but how are you going to redeclare it in parser? \n. @nikic \nhttps://github.com/ovr/phpsa/blob/master/src/Definition/ClassDefinition.php\nI would like to write more functions to standart Class_ and use it by default in parser\nis it clear now? because I am not interested to write decorator or smthg else\nI haven't tried yet, but I suspect that doing this will adversely affect performance. The current alternative is to translate normal nodes to custom ones in a visitor -- is there any problem with doing that?\n\nI need to set/get all values from old node to new one :(\n. @nikic \nDid you try to remove and add it again?\n. @GrahamCampbell \nI didnt read you messages\n\nThe service I work on supports that.\n\nHow is it related to this issue? P>S Maybe I didnt undertand you\n. @nikic Super, I will send PR in few hours\n. Okey, but can We move it to test dir and rename to runner?\n. \u043e0\nThank you answer \ud83d\udc4d \n. @GrahamCampbell \nIt's not a standart to write parameter in the end\nFor example, On OSX Just try to use cp with -R parameter in the of exec comand\n. > pretty standard for symfony\nWhere did you read it?\n. @GrahamCampbell \nSometimes ago I got fails without it\nIt's not slow\n. Guys, it's rly useless but it's needed 1 line for before install and 1 line empty line after, 2 uneeded lines\n. ",
    "joelwurtz": "For me this should not be the role of this library to pretty print something as this will imply at lot of complexity here.\nI have resolved this by piping the generated code through https://github.com/FriendsOfPHP/PHP-CS-Fixer and it works well.\n. ",
    "m1guelpf": "@nikic I believe this can be closed now.... @nikic @TiMESPLiNTER Any updates?. @carusogabriel I'm simply using Name for this.. ",
    "abiusx": "I personally use this lib in a bunch of products, and everytime I have to grab all files and put them in different repos, its hard to maintain as a 3rd party lib. A lot of php libs are distributed as phar files.\nI think I can do that for this though, and submit a pull request. What do u think?\n. not all projects use composer. specially when they need to modify code.\n. there's a reason Phar is out there. this conversation is futile.\n. ",
    "aik099": "Should it?\nFor example if I call get_class on the object, than resulting string also doesn't contain leading slash.\n. I guess you're getting FQCN from wrong place. For example $node in following example represents a class and (string)$node->namespacedName will return A\\B (A is namespace, B is class name).\nHowever there won't be namespacedName property of PHP_Parser node, when you haven't added PHPParser_NodeVisitor_NameResolver node visitor to the traverser you're using along with a parser.\n. Maybe.\nAnyway I think, that since PHP_Parser isn't tokenizer and it represents logical pieces of the parsed file, then it tries to normalize the parsed data. E.g. if \\A and A means the same in that parsed file then it's normalized to same value.\nIf you try to validate if \\ is being used, then using tokenizer, like PHP_CodeSniffer would be more appropriate.\n. I suspect that keywords in general are case insensitive.\nCould you please add/update corresponding test case?\n. I thought, that all 3 are lowercased. I that parser can do some normalization, since writing keywords in uppercase doesn't seem like a good idea to me (even if it works). Same as calling IsSet when function name is isset.\n. Maybe you should introduce some random lowercased letter, e.g. SeLF to clearly see if it's really preserved case or just force uppercase.\n. Ah, so these ones were case-sensitive before PHP 5.5?\n. Can you provide minimal reproduction test case, that can be executed and debugged?\n. Any specific code piece you're referring?\n. Maybe that constant value was changed at some point PHP, but lexer using old value.\n. You should reformat whole DocBlock as well, because now method declarations do not align.\n. The _ is needed, because both class and function are reserved words and can't be used to name a class. That's why _ is there.\n. PR is valid. It adds missing _ to the @method annotation. Without this the IDE (as mentioned in PR description) won't properly auto-complete that.\nThere is no Builder\\Class class, but there is Builder\\Class_ which is fixed by that PR.\n. The test suggests, that result is always in uppercase. However code change lowercases it.\nI think test should check, that regardless of case in PHP file the result is lowercase.\n. Are you sure, this statement magic is stable. Right now Travis complains about it.\n. ",
    "sk-": "It's true that get_class don't have the trailing / either. However, that function returns the full path to the class.\nSo for example:\nphp\n<?php\nnamespace Foo;\nclass A {}\necho get_class(new A);\nwill output:\nFoo\\A\nwhereas the parser for this same code will print just A for the class name. So, there's no way to distinguish new A and new \\A just using the toString method.\nI think it would be better to just return the original information, without any resolving. In that way one could generate the exact same code after parsing.\n. Yes, I'm not using the NameResolver. To get the name I'm calling the toString method of the FullyQualified node that is present in the NodeExprNew.\nAs I said, I think that having the original string is useful so one can regenerate the same code (without adding extra namespaces to the names).\nIn my use case, I solved it by calling a function that just appends a leading \\ in case the node is fully qualified.\n. ",
    "TimeToogo": "Added the corresponding test :)\nHave to go to sleep now, its 2am in melbourne...\n. Finally got the test to pass.\nDid not realise the parser will automatically lowercase static:: calls.\nIs there any reason for this obscurity?\n. @aik099 As far as I can tell only static:: was lowercased, the others are left as user defined as the test illustrates.\n. @aik099 I just confirmed locally that for parent::and self:: the casing is fully preserved.\n. @nikic Thanks for this. \nReading over the changelog, it is interesting to find that in PHP 5.6 constants now support arrays as values.\n. Nice, even earlier than previously mentioned, congrats on v1.0.0!\n. ",
    "marius-balteanu": "thank you guys for the quick replies. @llaville, it is ok to reopen the issue https://github.com/llaville/php-compat-info/issues/123 from PHP-compat-info project?\n. ",
    "lyrixx": "I think var_dump does not give you lot of information because of you xdebug setting.\n. ",
    "joeyhub": "pretty printer.\nI'm not sure if addcslashes always works or not but var_Export is guaranteed to always work.\nSorry, it's hard to type while my wrist is broken.\n. If you look at the source for addcslashes and the php lexer you can establish that.\n. ",
    "mackenza": "@nikic yes, I am an idiot.  Sorry for wasting your time.  I had done a use for a different class but not for Node\\Name :(\n. ",
    "softius": "My bad. I didn't notice that there was a 0.9.5 available. composer update -o brought the new version.\nP.S. Thank you for such a great library!\n. ",
    "bkuhl": "I don't in the package I'm building.  I've included the following dependencies in my package and when I composer install --no-dev this error goes away.  So it's definitely associated with one of them...\n\"require-dev\": {\n        \"phpunit/phpunit\": \"~4.0\",\n        \"mockery/mockery\": \"~0.9\",\n        \"orchestra/testbench\": \"3.0.x\"\n    },\n. ",
    "cmb69": "\nThe PhpParser\\Node\\Stmt\\ClassMethod::isPublic return me always TRUE with code1 or code2 (public visibility declared or not)\n\nThat is caused by PhpParser\\Parser, which defaults to MODIFIER_PUBLIC when no visibility modifier is given. phpparser/grammar/zend_language_parser.php line 481:\n```\nvariable_modifiers:\n      non_empty_member_modifiers                            { $$ = $1; }\n    | T_VAR                                                 { $$ = Stmt\\Class_::MODIFIER_PUBLIC; }\n;\nmethod_modifiers:\n      / empty /                                           { $$ = Stmt\\Class_::MODIFIER_PUBLIC; }\n    | non_empty_member_modifiers                            { $$ = $1; }\n;\n```\nISTM that it is not possible to distinguish an implicit from an explicit public modifier as it is now.\nI'll try to come up with a patch; however, I won't be able to make a PR, due to no experience with Git (still stuck with SVN).\n. I have set up a Gist to show how isImplicitlyPublicProperty() can be used to distinguish implicit and explicit public properties. However, this uses a terrible hack to get the token list. @nikic: Is there any sane way to get the token list from the lexer or parser? Maybe adding LexerWithTokenOffsets::getTokens()?\n. @llaville\n\nFinally I've adopted another solution.\n\nAs @nikic has explained, using token_get_all() will not necessarily work when the emulative lexer (\\PhpParser\\Lexer\\Emulative) is used:\n\nand is even necessary if you extend the emulative lexer - which has different output than token_get_all\n. @llaville \nHave you tested the previous solution without the commit ?\n\nNo. Unfortunately, I was not able to install the dev version of PHP_Reflect due to a dependency mismatch with PHP_CompatInfo reported by Composer.\n\nOn first run it works, but on second run if you've the cachePlugin it fails !\n\nThat's most likely due to the incompatibility of token_get_all() and Lexer\\Emulative.\nCan't you add another field \"tokens\" to the event object (besides \"ast\") on the first run, and retrieve and use this information in subsequent runs?\nAnyway, these details might better be discussed in the respective PHP_Reflect issue.\n. ",
    "Fuco1": "Thanks for the write-up, I'll try to play with his over the weekend :)\n. Okey, I got it working. Do you want me to contribute the class upstream? I think it is fairly useful addition.\n. I've set up the project here: https://github.com/Fuco1/php-refactor/\nThe modified lexer is in php/FilePosLexer.php.\n. Oh, thanks! This is indeed much cleaner :)\n. ",
    "basz": "I've rewritten the class from @Fuco1 a bit to only extend the appropiate class https://gist.github.com/basz/91cf297aede881692855 for anyones pleasure...\n. thx got it working\nhttps://gist.github.com/basz/91cf297aede881692855 for anyone's pleasure...\n. ok, now i know what i should do... :-) i'll leave the issue open on your behave... thanks\n. ",
    "ockham": "CC'ing @nicolas-grekas as you might be interested because of #142\n. Thx for the speedy fix!\n. ",
    "kronusme": "Thanks for answer, @nikic!\n. ",
    "Ciantic": "@basz thanks for sharing. I think this will be valuable starting point for writing proper IDE auto-completion for PHP (in vscode). Small nugget for sure, but determining the context where the cursor is located at is the first thing to look at when filtering for auto-completion choices.\n. ",
    "suralc": "@nikic Both topics I raised here can be partially solved by extending the emulative Lexer and overriding getNextToken. Are you aware of any possible pitfalls when using the following code or should it be safe to use?\n``` php\n    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null)\n    {\n        $tokenId = parent::getNextToken($value, $startAttributes, $endAttributes);\n        // snipped....\n        } elseif ($tokenId == Parser::T_ARRAY) {\n            $startAttributes['traditionalArray'] = true;\n        }\n    return $tokenId;\n}\n\n```\nphp\n        elseif ($node instanceof Node\\Expr\\Array_) {\n            if (!$node->hasAttribute('traditionalArray')) {\n                $this->getResult()->addRequirement(RequirementReason::SHORT_ARRAY_DECLARATION, $node->getLine());\n            }\n        }\n. @gonzaloserrano  Most of this should be managable to implement, I guess.\nYou could use http://php5.laurent-laville.org/compatinfo/blog/ for most circumstances (not short arrays, though). Some things are however not (yet) implemented there:\nTake a look at the snippet above and the implementations(my project (some rewrites required), not related to the one linked above) here (Feel free to copy):\n- Lexer\n- PHP 5.4 Binary numbers\n- PHP 5.4 Short array\n- PHP 5.4 Always on - Short Echo\n. @nikic I can open a pull request later today/tomorrow. Would the following interface suffice or did I miss anything obvious?\nphp\ninterface FunctionLike { // implemented on Stmt\\Function; Stmt\\ClassMethod; Expr\\Closure\n    /**\n     * @return bool\n     */\n    public function returnsByRef();\n    /**\n     * @return string\n     */\n    public function getName();\n    /**\n     * @return Node\\Param[]\n     */\n    public function getParams();\n    /**\n     * @return null|string|Node\\Name[]\n     */\n    public function getReturnType();\n    /**\n     * @return Node[]\n     */\n    public function getBody();\n}\n. @nikic Please ping me if #203 requires further changes.\n. ",
    "gonzaloserrano": "Hi, this addition would be great! Since we have part of our codebase that supports PHP 5.3 and sometimes our devs use short array syntax by mistake, we could write a script to analyze the changed files and check for this behaviour.\n. Very cool projects @suralc, thanks!\n. ",
    "mcuadros": "Makes sense. Thanks!\n. Nice catch, thanks! Just the devil`s hand. Anyway this looks like untested :/\n. ",
    "edsonmedina": "+1\n. +1\nThe only workaround I could find is having a \"mute\" variable shared between NodeVisitors that I set on enterNode and later unset in leaveNove of the parent node. All visitors would have to respect this mute.\n. Brilliant. Thanks.\n. You're right, it doesn't make sense.\n. That's actually a good idea. Thanks.\n. I imagine you're describing something like this?\n```\n$context = new ContextStack(); \n// this visitor manages the stack\n$traverser->addVisitor (new ContextVisitor ($context)); \n// this visitor consumes the stack\n$traverser->addVisitor (new SomeOtherVisitor ($context)); \n```\nBut nothing guarantees me the ContextVisitor will always be the first to run, right?\nI usually make individual visitors keep track of all the relevant context they need, but this gets verbose quickly (lots of instanceof and state) and happens frequently.\nIt would be so much simpler if the context was provided by the parser (it already has the context in memory).\nIt could be an optional component if you think this would create unnecessary overhead.\n. Nikic's answer is satisfactory enough for me.\nA visitor can track the scope and others can have a reference to it (or to a shared context object).\nClosing this.\n. ",
    "kix": "Thanks!\n\u043f\u0442, 19 \u0434\u0435\u043a. 2014, 23:01, Nikita Popov notifications@github.com:\n\nI've merged the namespace portion in 01643e0\nhttps://github.com/nikic/PHP-Parser/commit/01643e06d3a3721ef6cd04fdaad2a3c3eae9ed5a.\nThe builder now also has addStmt/addStmts methods, because statements for\na namespace are supposed to be included in the namespace node (while the\napproach of just making it an empty namespace and adding statements after\nit also works if you'll only use the pretty printer afterwards).\nI've not merged the use part yet, because I don't think it makes much\nsense to have a separate builder class if it's going to directly create the\nnode without additional options. I'd probably go for returning the Use\nnode directly from $factory->use(), even if it might not be the cleanest\ndesign.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nikic/PHP-Parser/pull/157#issuecomment-67673396.\n. @nikic, well, that's great; I missed the as method, thanks for adding it.\n. OK, got it, though I don't really know how to fit it into the current doc, as this does not really fit into the doc's fluid style:\n\n``` php\n$method = $factory->method($action . 'Action');\n$node = $method->getNode();\n$node->setAttribute('comments', [new \\PhpParser\\Comment\\Doc(\n    \"/* \\n\n      * Wowe, such dockbock \\n\n      * \\n\n      * @Much\\Annotations\n      /\"\n)]);\n$class->addStmt($node);\n```\n. That's great, thanks!\n\u0441\u0431, 13 \u0434\u0435\u043a. 2014, 17:49, Nikita Popov notifications@github.com:\n\nI've added setDocComment() methods to the relevant builders (class,\ninterface, function, method, property), so you don't need to manually\ncreate a doc comment array. See 2438848\nhttps://github.com/nikic/PHP-Parser/commit/2438848487bc2564c2fe472c5bf6db54153ce6f3\n.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nikic/PHP-Parser/pull/159#issuecomment-66875357.\n. \n",
    "stuartherbert": "Ah, of course. Thank you for the quick reply!\n. ",
    "tomzx": "I like it, thanks @nikic!\n. I was hoping it would be possible to use PHP equal operator to automatically compare the structures recursively, however due to the fact that nodes have startLine/endLine (and possibly comments), it is simply not possible. Thus I was thinking that by clearing the attributes array (or never filling it in) it would be possible simply do $stmts1 == $stmts2.\nIt appears that if I create an emulative lexer with ['usedAttributes' => []] as $options, I can do exactly just that.\nIs there any case where that would cause issues/not work?\n. Thanks for the help!\n. In Lexer::getNextToken\nhttps://github.com/nikic/PHP-Parser/blob/e4a54fa90a5cd8e8dd3fb4099942681731c5cdd3/lib/PhpParser/Lexer.php#L243\n$token is an array\nhttps://github.com/nikic/PHP-Parser/blob/e4a54fa90a5cd8e8dd3fb4099942681731c5cdd3/lib/PhpParser/Lexer.php#L253\nthe value of the pointed drop token is set\nhttps://github.com/nikic/PHP-Parser/blob/e4a54fa90a5cd8e8dd3fb4099942681731c5cdd3/lib/PhpParser/Lexer.php#L264\nthus the else block is executed\nhttps://github.com/nikic/PHP-Parser/blob/e4a54fa90a5cd8e8dd3fb4099942681731c5cdd3/lib/PhpParser/Lexer.php#L276\nand the continue returns us to the beginning of the while block\nhttps://github.com/nikic/PHP-Parser/blob/e4a54fa90a5cd8e8dd3fb4099942681731c5cdd3/lib/PhpParser/Lexer.php#L280\nwhich prevents this bit of code from being executed, and thus we end with endLine not being updated, . Can you please provide the full error stack trace by calling composer.phar with -vvv?\nFurthermore, this doesn't look like an issue that is going to be related to PHP-Parser.. ",
    "dpb587": "Well that's confusing [to me]. I appreciate the details though - it definitely points me in the right direction on what I need to learn more about and try. Thanks!\n. ",
    "cweagans": "That's really helpful. Thanks! Perhaps I'll be able to submit a PR at some point. If not, do you take consulting work on this project? If so, can you send me a quote for finishing the error recovery via email? me@cweagans.net\n. @nikic So I've been playing with that errorRecovery2 branch, and I think it's working pretty well. I'd like to suggest merging it to get more people using it. If there's any feedback, then I'd be happy to work on incorporating it. If not, then a new release could be tagged with this included. What do you think?\n. ",
    "jminkler": "Guess also 'and' \nAvoid the use of logical operations (XOR, OR, etc) in favor of operators like && and ||\n\nif ($this->candidateBox !== false) {\n. \n",
    "remicollet": "Yes, I'm able to get the test suite from a clone of the repo, but this is terribly ugly.\nIf composer don't want the test suite, this is a composer issue, which doesn't have to be fixed in each package, but in composer.\n. I'd just like https://github.com/nikic/PHP-Parser/archive/v1.1.0.tar.gz to be usable for downstream distribution.\nBut close this one if you don't care.\nComposer just introduce very bad practices instead of very old good practices (having doc + test in distribution / official tarball).\n. Notice if you don't distribute \"test\", no need to distribute phpunit.xml\n. Sorry, but I don't think this is useless. I still disagree and still think \"test\" and \"doc\" should be included.\nElse remove everything not needed by composer. Why do you keep README, LICENSE, .*.md ?\nAnd yes, I plan to open a bug on every project which will drop test in the future.\n. Thanks.\n. Thanks!\n. Yes, everything ok now, Thanks!!\n. See https://github.com/Microsoft/tolerant-php-parser/issues/35. > you still feel the same way about not excluding any files via .gitattributes?\nYes\n(sadly PHP is the only language without a proper installer, able to manage file role, such as the old pear/pecl, npm, cpan, pip, ...). ",
    "DavidPrevot": ":+1:\n. ",
    "garfix": "Thanks, Nikic, I understand why this is hard to implement, and your alternative will work just fine for me. :)\n. ",
    "avindra": "Linking related issue in other project:\nhttps://github.com/bobthecow/psysh/issues/185\n. ",
    "mnapoli": "OK thanks, what I could do is add a new implementation of the NodeTraverserInterface that doesn't clone nodes?\nI'm afraid I would have to duplicate a few lines of code (even if I extend NodeTraverser) but at least it would be there for people to use.\n. Well that makes much more sense for such a simple stuff, you are right.\nI opened a PR here: #186\n. ",
    "sa-tasche": "Yes, some thought that 'extends' means always 'parent class'.\nBut for interfaces, it means 'interface'. \n. Where is the difference between the checking if Stmt is null or an empty array and checking if noBody is true/false?!\n-1\n. ",
    "malkusch": "Thank you.\n. ",
    "cakebake": "Thanks for the confirmation! The description confused me a little and I wanted confirmation.\nIs there an elegant way to keep the comments, which were over a include? I do not know why, but comments are considered as instanceof \\PhpParser\\Node\\Expr\\Include_. However, I can solve this in my code, too.\nAt this point my respect and thanks for the parser :)\n. Wow that was a copy and paste solution! Nice Api, perfect!! Greez from/to Germany ;)\nMy final code:\n``` php\n$stmts = $this->getPhpFileCombine()->traverse()->getStmts();\nif (isset($stmts[0])) {\n    $stmts[0]->setAttribute('comments', array_merge(\n        ($node->hasAttribute('comments')) ? $node->getAttribute('comments') : [],\n        ($stmts[0]->hasAttribute('comments')) ? $stmts[0]->getAttribute('comments') : []\n    ));\n}\nreturn $stmts;\n```\n. Now I just pushed the repo :D Thanks for the Tip ^^\n. ",
    "addiks": "I have now added a parameter (--with-column-info / -c) to the php-parse.php script that will show column-information for syntax-errors, made the error-class work with token-data instead of columns directly and written a test for the new behaviour in the error-class. The default behaviour does not change anymore but needs to be triggered using that parameter.\n. I think EOF errors should display the last character as the error to directly show where the error is without interfering too much. When errors would mark an entire class (or such) as faulty it should only show the class-name at the top as an error to prevent other errors in that class to be hidden by the whole class to be marked as an error. In cases where no detailed column-informations are available it is fine to not have/show column-information, just adding artificial column-numbers would create indistinguishable situations. Column-numbers should be 1-based to be consistent with line-numbers. (I didn't implemented that 0-based on purpose, i just build it so that it lined up correctly in my text-editor.) That are however not hard opinions. If you want to build it differently just do it, i am fine with it.\n. ",
    "msjyoo": "Please see https://github.com/nikic/PHP-Parser/pull/234\n. Whoops, put the wrong class name in the commit message. If you could modify that when you apply the patch that'd be fantastic.\n. @nikic Sure, but all you're doing is wrapping the string format into a class and giving that instead. I could write a parser for the format I've described (which would be easy) and it would be the exact same result.\nA Scope class is pretty useless for a scope resolver, because at the end of the day, every scope is unique and a string format perfectly represents that. Sort of like a scope hash, except this is more descriptive.\nWith the string format, I could easily put it into a hash table(array key), along with all the variables and functions inside (the scope), and be guaranteed that the string is a unique external representation of that scope.\nAlso, I was following the pattern from NameResolver and the previous PR as well, so instead of another Visitor having to implement this Resolver just to use it - I can run it, and have the scope result embedded in the attributes.\n. @nikic You're right, the use case for this isn't to back-reference a class or a function inside a visitor, but rather provide a unique identifier for each Node which can be accessed after the traversal is complete. My use case needs to keep track of function scopes / variables inside scopes (a static type analyser) and a string format is the simplest to deal with, since scopes do not inherit there is no need for a complex data structure.\nI guess what could be done is have a Scope object like you've implemented (which will contain the AST Nodes), but have that added as an attribute to each Node and not as an injected complement to another visitor - similar to NameResolver. That way, visitors can access the scope object by getAttribute, it can be accessed afterwards in the same way, and a __toString() method can convert the Scope to a unique string that can be used in a hash table / and for comparison.\nRegarding the Closure collision - right now I'm using startFilePos since that is guaranteed to be unique for each closure, but the default lexer doesn't select that as a default option so something alternative might need to be used?\nI'm not sure how the conditional function issue can be solved when converting to string format short of a pointer keeping track of functions with the same name, and appending numbers.\n. Wouldn't that cause a recursion? e.g. The class would also have to have the class methods, which in turn should have their parent class, and so on and so on.\n. Thanks!\n. Just wondering, is it possible to have union type hints instead of the generic Expr type hint then?\n. ",
    "DeepDiver1975": "Just did find Equal vs Identical and NotEqual va Not Identical - sorry for the noise\n. ",
    "Xlator": "Yeah, was my mistake. I was running 0.9.3 through vim-php/phpctags. Fixed it by deleting composer.lock and remaking the .phar archive. Sorry.\n. ",
    "mindplay-dk": "Oddly, even if I insert a junk null statement at the end of the file, the comment doesn't get associated with that either.\n``` PHP\n$code = '<?php\n$foo !== 2; # just because\n;null;\n';\n$nodes = $parser->parse($code);\nvar_dump($nodes);\n```\nOutput:\narray(2) {\n  [0] =>\n  class PhpParser\\Node\\Expr\\BinaryOp\\NotIdentical#10 (4) {\n    public $left =>\n    class PhpParser\\Node\\Expr\\Variable#8 (3) {\n      public $name =>\n      string(3) \"foo\"\n      private $subNodeNames =>\n      NULL\n      protected $attributes =>\n      array(2) {\n        'startLine' =>\n        int(3)\n        'endLine' =>\n        int(3)\n      }\n    }\n    public $right =>\n    class PhpParser\\Node\\Scalar\\LNumber#9 (3) {\n      public $value =>\n      int(2)\n      private $subNodeNames =>\n      NULL\n      protected $attributes =>\n      array(2) {\n        'startLine' =>\n        int(3)\n        'endLine' =>\n        int(3)\n      }\n    }\n    private $subNodeNames =>\n    NULL\n    protected $attributes =>\n    array(2) {\n      'startLine' =>\n      int(3)\n      'endLine' =>\n      int(3)\n    }\n  }\n  [1] =>\n  class PhpParser\\Node\\Expr\\ConstFetch#12 (3) {\n    public $name =>\n    class PhpParser\\Node\\Name#11 (3) {\n      public $parts =>\n      array(1) {\n        [0] =>\n        string(4) \"null\"\n      }\n      private $subNodeNames =>\n      NULL\n      protected $attributes =>\n      array(2) {\n        'startLine' =>\n        int(5)\n        'endLine' =>\n        int(5)\n      }\n    }\n    private $subNodeNames =>\n    NULL\n    protected $attributes =>\n    array(2) {\n      'startLine' =>\n      int(5)\n      'endLine' =>\n      int(5)\n    }\n  }\n}\nThe comment before the junk null statement is simply dropped.\nI really think that attempting to associate comments as attributes of nodes is a mistake - comment nodes probably should have been represented as just comment nodes. Establishing the association of comments as attributes of (e.g.) class/interface declarations, doesn't really seem like a parser concern? With the possible exception of doc-blocks which do proceed a declaration that can have the previous doc-block applied as an attribute... (?)\n. Yeah, I see the problem. Hmm, too bad.\nI can tell you what I had in mind - I think it's a pretty cool idea, I got it from Nim's test approach, and discovered that this is valid syntax and possible in PHP as well.\n``` PHP\ntest(\n    'My test description',\n    function () {\n        $foo = 1;\n        $bar = 2;\n    $foo < $bar; # foo is less than bar\n    $foo + 1 === $bar; # and so forth\n}\n\n);\n```\nThe test() function would obtain the source-code of the closure (I got that working) and then process any stand-alone expressions, generating an assertion for each of them, e.g. transforming the function body into something like:\n``` PHP\ntest(\n    'My test description',\n    function () {\n        $foo = 1;\n        $bar = 2;\n    ok($foo < $bar, '$foo < $bar', 'foo is less than bar');\n    ok($foo + 1 === $bar, '$foo + 1 === $bar', 'and so forth');\n}\n\n);\n```\nFrom which the test-runner output would be:\n```\n=== My test description ===\n\nOK: foo is less than bar: $foo < $bar\nOK: and so forth: $foo + 1 === $bar\n```\n\nI love this test format - not having to write assertion statements, but just simply writing stand-alone expressions with comments, would make for a very low-noise test format. You could even eliminate most of the comments by just giving meaningful names to variables, which would make the test (and output) practically self-explanatory.\nFor that matter, you could even place the tests in external files, eliminating the use of closures and any test-framework API at all :-)\nPerhaps I can use the Lexer stand-alone without the Parser to implement this? At least that would be better than token_get_all().\nDo you know of any other implementation of a CFT for PHP?\nOr would it make sense to introduce an additional layer in your parser? (not asking you to do the work here of course, just asking if you think it's feasible - or would the additional intermediary CFT model cause too much CPU and memory overhead?)\n. Any chance this improved with the 4.0 release?\nPerhaps comments will be preserved like white space without modifications?. ",
    "natebrunette": "Why would a method return type have multiple name nodes?\n. My question is why is it an array?  An array on return type suggests multiple return types.  As it is, it's saying that this member variable can be multiple Name objects.  This doesn't make sense for return typing.\nLook at the Class_ member variables.  Class_::$extends is typed to Node\\Name because a class can only extend one class.  Class_::$implements is typed to Node\\Name[] because a class can implement many interfaces.\n. @nikic Thank you.\n. ",
    "ReneeVandervelde": "@GrahamCampbell They're talking about the declared return types in PHP-7. Which don't allow multiple returns nor nulls. As opposed to the non-declared implicit ones in PHP-5.\n. ",
    "mintbridge": "Thanks, i guess not many classes need no namespace anymore with PSR2 becoming popular\n. ",
    "tleb": "\nThanks, i guess not many classes need no namespace anymore with PSR2 becoming popular\n\nIt's rather because of PSR-0 and PSR-4. (Mainly PSR-4 though.)\n@nikic This code didn't work for me. It was missing ->getNode() for the use() and class() methods. Is it normal no exception are throwed when getNode() isn't called? I had a CLI stopped working, complete crash of the script.\nBTW, amazing library!\n. I would recommend creating an Helper class to create all those basic things (null, true, false, etc).\n. You could just use any container and add the nodes you use to it...\n. Redeclare? Could you explain what you are trying to do?\n. ",
    "vandroids": "Ok. Thanks for support!\n. ",
    "jesseschalken": "Oh awesome, thank you @nikic!\n. A method can have no body (abstract/interface method, ;), an empty body ({}), or a non-empty body ({...}). Stmt[]|null fits this precisely.\nIf you introduce a distinct noBody property then what would it mean if noBody is true but stmts is not []? Such a configuration would be invalid, but allowed according to the types of the properties.\n. Don't forget list(...) = ...; :stuck_out_tongue: \n. You can avoid adding the extra parameter to everything by having it as a property. Then you can either do:\n``` php\nprivate function indented() {\n    $self = clone $this;\n    $self->nl .= '    ';\n    return $self;\n}\nprotected function pThing(Thing $node) {\n    // ...\n    $s = $this->indented()->p($node->foo);\n    // ...\n}\n```\nOr, if the overhead of the clone is high, set $nl temporarily and set it back again:\n``` php\nprivate function indent() {\n    $nl = $this->nl;\n    $this->nl .= '    ';\n    return $nl;\n}\nprotected function pThing(Thing $node) {\n    // ...\n$nl = $this->indent();\n$s  = $this->p($node->foo);\n$this->nl = $nl;\n// ...\n\n}\n```\nI suspect either method would be more performant than the repeated searching and replacing.\n. @nikic Gah, I thought automatic intish string => int conversion was only a thing that happened with arrays, not all ArrayAccess. That's annoying.\nThanks for the prompt fix, it works now. :). @nikic That makes sense to me. I would expect pretty printing new LNumber(\\PHP_INT_MIN) to yield an expression that evaluates to an integer, even if that means emitting -9223372036854775807 - 1. Unfortunately that means the syntax tree doesn't precisely round-trip through the pretty printer, but that's a better problem to have if the code is still semantically equivalent.. ",
    "Lewik": "php\nnew ConstFetch(new Name('null'))\nIs there simpler way?\n. ",
    "litowitz-2": "I figured it out, it was setup to strip line endings before parsing. This resulted in the problem you had suspected.\n. ",
    "fezfez": "See doc (https://github.com/nikic/PHP-Parser/blob/1.x/doc/2_Usage_of_basic_components.markdown)\nIt say that you should set it at 3000\n. @GrahamCampbell why ?\n. Until composer does not have a stable release, its need. By the way its pretty fast\n. what do mean ?\n. @GrahamCampbell : before-install is a good solution\n. ",
    "avevlad": "\nOmg, schoolchild, go away with this spaming atack\n\n:+1: @GrahamCampbell  go contirube laravel\n. ",
    "dupuchba": ":+1: for this one \n. Is it possible, using your library, to:\n1. Parse a file\n2. Add/change something\n3. Generate the same file with updated content\nYes you even have examples in the doc, reddit !!! ;-).\nDon't forget that once you prettyPrint your node to a new file you loose formatting!\n. ",
    "digitalkaoz": "great thanks :)\n. thanks :) im thinking about that a bit further...\ni think ill try to write a pretty printer which utilizes a php-cs-fixer config file then the formatting will depends on the users preference\n. ",
    "AydinHassan": "@nikic Fixed and updated the PR description, now excuse me while I go back to page 1 in my PHP book :sob: \n. Thanks :smile: \n. Wow, that's embarrassing :(\n. ",
    "jclaveau": "Ow,  forgot to remove a visitor on my traverser...\nWhat if go somewhere else now?\n :walking: \nThanks for your reactivity and sorry for the time lost :) \n. ",
    "bpicolo": "@nikic  So I'd have to change the grammar, yeah? Currently stuck here:\nencaps_list:\n      encaps_list encaps_var                                { push($1, $2); }\n    | encaps_list T_ENCAPSED_AND_WHITESPACE                 { $2 = Scalar\\String_[$2]; push($1, $2); }\n    | encaps_var                                            { init($1); }\n    | T_ENCAPSED_AND_WHITESPACE encaps_var                  { init($1, $2); }\n;\nGot the T_ENCAPSED_AND_WHITESPACE after encaps_list to work properly, haven't gotten the final case to work yet.\nT_ENCAPSED_AND_WHITESPACE encaps_var                  { init($1, $2); }\n^^ Haven't successfully modified the grammar such that $1 becomes a scalar string node yet. I'm not suuuuper familiar with writing formal grammars and there's some trickery in the custom functions hah. Any idea there?\n. I thought about the file positions in the lexer part, but that doesn't work because the strings weren't becoming a node of any sort, and so didn't have attributes carried along. The above suggestion does seem to work as intended : ) Nice\nThanks @nikic.  I'll have to maintain a fork for now, let me know if it seems reasonable to try to merge this,\n. @nikic  ahhh, gotcha.\n. ",
    "ScreamingDev": "Works like a charm! Thank you @nikic !\nI tried it in my project and am now ready for a more generic approach.\nThis issues seems closed to me, as it can be solved by using the visitor.\nHappy new year!\n. ",
    "pk-fr": "sorry ... it was a bug in the obfuscator .....\nthe faulty code was:\n\n$last_inst  = array_pop($stmts); \n $stmts      = shuffle_statements($stmts); \n $stmts[]    = $last_inst;\nas stmts was array(0) {} ..... I added a null stmt :o(   ....  \nSorry to have disturbed you for nothing... \nI should have checked twice ....\n. ",
    "theofidry": "Sorry for the PR, just wanted to check what would happen under PHP 5.3 :/\n. Indeed, updated @nikic :)\n. @nikic maybe it just requires another build?\n. You're welcomed :)\n. @nikic it may be worth mentioning that in the docs, GC and/or xdebug really makes it tremendously slower, often between 10-20x time difference. \ud83d\udc4c  Many thanks. To prefix it: https://github.com/humbug/php-scoper/blob/master/src/NodeVisitor/IgnoreNamespaceScoperNodeVisitor.php#L32. Maybe to expand a bit more. The library is about prefixing the namespace to isolate the code, mostly in the context of a PHAR to avoid any issue when it executes people's code. We however avoid to touch things from the global namespace (internal code or third-party code alike) so we need to count the number of elements the name to know if we should prefix that one or not.. \ud83d\udc4c . @borNfreee you may also ran into the issue with the Lexer cf. https://github.com/humbug/php-scoper/blob/master/scoper.inc.php#L48. It would be great to fix it here at the core rather than those ugly brittle patches. Awesome, thanks :). There you go :). I'm also curious about the answer, so far the most appropriate place I found was in the NodeTraverser instead of a NodeVisitor.. Reconsidering my fix as it indeed looks wrong. The actual issue I think is that the array node always seem to specify the syntax, so have the shortArraySyntax does not seem to have the desired effect. What I would like/expect is enforce the syntax. Indeed if you have:\n$x = [];\nShouldn't you have a way to force the printer to print array() or [] depending of the PHP target?. Closing as I don't think it's the proper fix issue.\nIdeally I would like the Printer to be able to print valid PHP code in a given target regardless of what version the original code was written in. That would however require more changes, e.g. being able to drop some typehints and return values and bail out properly when no equivalent is given.. Thanks! Will dig into this :). Yes sorry. For example with the following example, I could replace:\nphp\nconst X = 'foo', Y = 'bar';\nby:\nphp\nconst X = 'foo';\nconst Y = 'bar';\nTo do so you could image the following node visitor:\n```php\nfinal class ReplaceConstStmts extends NodeVisitorAbstract\n{\n    /*\n     * {@inheritdoc}\n     /\n    public function enterNode(Node $node): Node\n    {\n        if (false === ($node instanceof Node\\Stmt\\Const_)) {\n            return $node;\n        }\n    return new NullNode(\n        array_map(\n            function (Node\\Const_ $constant) use ($node): Node\\Stmt\\Const_ {\n                return new Node\\Stmt\\Const_([$constant], $node->getAttributes());\n            },\n            $node->consts\n        )\n    );\n}\n\n}\n```\nAnd when printing the array of nodes, NullNode would actually not be rendered but only its wrapped nodes\nThe example above is one kind of transformation that makes much easier for PHP-Scoper since sometimes I need to transform const into define(). I already do a similar transformation for the grouped use statements although I can do that one in the traverser directly.\nMore generally though, I think it would make it easier to manipulate the AST that way.. >Isn't this the same as using the array return value in leaveNode()?\nIt differs in several way:\n\nIt can be used in enterNode() as well as you noted\nThe parent does not require to be an array\n\nI would be fine with returning an array as well instead. I suggested NullNode because it looks easier to deal with. @TomasVotruba I do, however I really have no time to look into this right now and unlikely to have any before new year.\nI'm also still not sure wether or not @nikic is cool with it.\nNonetheless, if you have a couple of examples they would be welcome as they may help to move forward with the discussion regarding the API and to decide if worth having here in the library or not. >I don't understand. php-parser already support adding of any node you could think of.\nI'm confused. Do you have examples? Because my two first comments are exactly this. @TomasVotruba it is a good solution to delegate the adding/removal of nodes the way you did. But overall I find the solution quite complex compared to adding a NullNode which would be only here to nest nodes/statements and not be rendered at all as explained here. I just thought a null object would be easier to deal with semantically. But that's a suggestion like another, so if it's easier to deal with an array of nodes instead of a null object it's fine by me.\n@nikic any opinion about this? I may try to do a PR but I would rather make sure we're on the same page first. @TomasVotruba having an empty constructor would do:\nhttps://3v4l.org/1hkph\nMaybe a @trigger_error() deprecation message could be added to warn people to no longer call parent::__construct(). urg I see, ok I'll have to patch a couple of things on my side then. Thanks for the quick answer!. Is there a point to keep using an old version of composer?\n. Not following you @Taluu: I don't see the point of risking to break the tests because of not having Composer up to date. Besides composer also evolves with time to resolve dependencies faster and in a better way. Why disregarding that?\n. > Nothing should prevent someone with a out-of-date composer installation to install the lib.\nIf that's your concern you should add tests for that to effectively try it with and outdated composer version, not a random version on which you have no control of.\n\nOtherwise, why limit to composer and not upgrade php and everything else ?\n\nI don't see how it is related here. Upgrading PHP has an influence on the code of your application/library. In this case it doesn't matter if you're using composer v1.0.0-alpha1 or v1.0.0-alpha11, BC or not. It would be a different story if we were talking of a composer extension, but that's not the case here.\n. So as the Composer version doesn't matter (to the library), why disregarding the benefits brought by newest version?\n. > And also : https://docs.travis-ci.com/user/languages/php#Installing-Composer-packages\nHa finally, something more constructive! Indeed if Travis composer version is updated periodically, absolutely no need for that.\n. I personally find it horrendous: it makes the core really unreadable besides this optimisation can in theory benefit to all functions (although less than if opcache optimised). So I would strongly suggest to import symbols with use statements, e.g. use function string or use const PHP_EOL rather than this. I'm not against the change but isn't that a BC break?. same here. [$expectedTokenType, $expectedTokenText]?. damn. ",
    "keradus": ":+1:\n. ",
    "jedahan": "ok weird, installing it locally didn't work, but globally did. Looks like my dev environment is all sorts of funky. Thanks for the quick reply!\n. ",
    "jaytaph": "I see this is already fixed in 719ca71d4ac80e1985dcd91dd8ec5a47db58ad80\n. ",
    "stevemiketa": "Fantastic.  Thanks for the fast reply!\n. ",
    "jhodgdon-drp": "Another related issue is #469 I think. The first problem is actually in the parser. See #469. By the way THANK YOU for this project! We had our own parser and pretty printer in our project, and using this library has made our code much cleaner, more understandable, and more maintainable. I'm just going to file a few issues about the Pretty Printer class that I came across... they aren't holding me up though since we needed our own pretty printer class anyway. Thanks!. I'll make a pull request with the code I used to accomplish this. Fairly straightforward.... Oh, never mind! It looks like this has already been fixed in the latest development code:\n{\n                return '(' . $this->p($node) . ')';\n            }\n        }\n        return $this->p($node);\nSorry about the duplicate issue! I used composer to download and probably got the latest release instead of the development version.. Well. It is fixed in the \"master\" branch but not in the 3.x branch. Perhaps I will reopen it?. I'm not familiar with your branch strategy in this project, so I'll leave it to you to decide to leave this open or not, and whether or not to port this change to the 3.x branch. Anyway, it isn't standing in my way (I just overrode the pPrec() method in my pretty printer class).\nWhich is all working very well, thanks to your clear code! It was really easy to figure out what to override, and the structure of the Pretty Print classes is quite clear.. That may be. I would argue that all multi-line is much better than all in-line, and that particular sample is not code that I see a lot in PHP... certainly discarding comments that are in arrays that are parsed out is also bad.\nI guess maybe the array needs some kind of flag to say whether it should be one-line or multi-line, if you want to support both?. Thanks for the fast work!!. ",
    "afraca": "Actually Nikita, this is a syntactic issue. I'm not really sure how official the php-langspec is, but:\nhttps://github.com/php/php-langspec/blob/master/spec/09-lexical-structure.md#general-2\n\noctal-literal::\n      0\n      octal-literal   octal-digit\n\n(Where octal digit is self-explanatory)\n. ",
    "asgrim": "FWIW, at least using Better Reflection it seems void return type works without any changes - Roave/BetterReflection#209\n. Ah yes, makes sense - I think at Better Reflection's level, that subtlety is lost / ignored - we parse the string and phpDocumentor/TypeResolver turns it into a phpDocumentor\\Reflection\\Types\\Void anyway.\n. @nikic Ah, apologies, not sure how I missed that one! Feel free to close both my issues if they don't add any value for you :) thank you.\n. ",
    "algo13": "sorry.\nIt was my mistake.\nprint \\0 ?\n```\n\nphp-parse --pretty-print \"<?php echo trim('str', \\\"\\n\\\");\n\n!/usr/bin/env php\n====> Code <?php echo trim('str', \"\\n\");\n==> Pretty print:\n<?php\necho trim('str', \"\\n\");\n```\n```\n\nphp-parse --pretty-print \"<?php echo trim('str', \\\"\\0\\\");\n====> Code <?php echo trim('str', \"\\0\");\n==> Pretty print:\n<?php\n\necho trim('str', \" \"); //< real \\0\n```\n. @nikic I am sorry.\nI adjusted the logs.\n. ",
    "Kvartir54": "Thanks, @nikic. But can you tell more in detail, what to do with it? and how to apply it to my classes and method?\n. I see, thanks @nikic\n. ",
    "SundialServices": "I'd like to add one more note to my point (2) above:  in order to create parent/sibling branches without creating storage-loops (such that e.g. print_r() never completes!), I used integers for these attributes, which are indexes to a separately-stored array of node-references.  Each node also carries an attribute which contains its own index-number.  (And yes, my ever-suspicious routines confirm that the two are the same.)\nSo the ->nextSibling is not an attribute, but a method.  Works the same way but doesn't mess with the PHP garbage-collector's mind.\nRecalling now how I did the code, I found it more expedient to make slight modifications to the runner itself, because it most-easily had the necessary information, whereas a visitor sees one node at a time.  I'm sure that it could be done both ways.  In any case, I'd like to see this as an official (and, optional ...) feature.\nWith regard to my point (1) above, I wound up co-opting the HaltCompiler node type ... which didn't seem to be used.  To this node-type is added an indicator of what include-file you are entering, through mandatory attributes.  By detecting this node type, and confirming that it does bear these attributes (vs. being an actual instruction to halt the compiler!), one can traverse the entire include-file structure and leave indicators within the AST of where each one begins.. I agree that it would not be worth changing and have closed the issue accordingly.  I'll modify my scanner.\nHowever, may I ask that you please add a comment showing exactly what subtree I'd be looking at, and which node in that subtree would carry the byRef attribute that I'd be looking for?  I think that this would be useful and helpful documentation, for the next person who has this same issue.  Thanks.  \n(And, P.S.:   \"what a great tool!\"). Sorry to have been late to reply to this:  \"Perfect!  Thank you so much!\". ",
    "vedmant": "Thanks, this works! Few more questions if you don't mind, how can I maintain correct indentation and if it parses blank lines?\n. I see, thanks, I thought I can use it to edit code.\n. ",
    "nursultanturdaliev": "@GrahamCampbell after reading your comments I also don't think it's a good pull request! Thank you for the feedback.\n. ",
    "TysonAndre": "I started working on converting \\PHPParser\\Node to \\ast\\Node, but right now, most node types are stubs/TODOs. See https://github.com/TysonAndre/php-parser-to-php-ast\n\nThe final goal is to create equivalent objects to php-ast, for the test files used by php-ast, when converting from \\PHPParser\\Node to \\ast\\Node (With the exception of line numbers of some node types)\nThe test suite is set up. 22 of 28 tests are failing.\n  EDIT(March 17th): only 5 of the tests are failing, and that is due to line numbers. php-ast will be fixed by https://github.com/nikic/php-ast/issues/50#issuecomment-287343289\nNo plans to convert \\ast\\Node to \\PHPParser\\Node in that repo.\nWill update if this is completed. I'm finished implementing https://github.com/TysonAndre/php-parser-to-php-ast (One way conversion to php-ast) (May refactor the API, though)\n\nI looped over php-ast's tests and added a few overlooked node types(goto, label, __halt_compiler() (I didn't implement the offset lookup yet, but that's doable (e.g. with php tokenizer or searching for that line)).\nI also fixed some incorrecly set flags.\n\nStart line numbers are slightly different in the output for statement lists, etc.\nThere's two modes of execution taking advantage of PhpParser's error tolerance: Omit statements with errors, or try to add placeholders. (e.g. convert $a = $this-> to $a = $this->__INCOMPLETE_PROPERTY__)\n   These aren't tested yet.\n\n. Sorry. The codebase I used was for php7.1, but I encountered this error trying to run this in hhvm nightly. Running without hhvm.php7.all=1 is one workaround for that.\nAlso, this PR is incomplete - I'd have to change the places where new Error was called (When the intent was PhpParser\\Error). E.g. ParserAbstract.php. ",
    "moorscode": "A problem here is that new-lines are not being parsed and disappear, so we cannot \"restore\" them at the proper position.\n. ",
    "KKSzymanowski": "Thanks for your responses.\nWhat I did to achieve this was\n1. Generate AST from file\n2. Find last use before class definition and remember it's line number\n3. Load file as an array of lines using file($path) method.\n4, Add my line to this array using array_splice\n5. Do the same for trait use statement inside class body\n6. Implode the array and save to file.\nIt turned out to be quite complicated but apparently it works. What I mean by complicated, is it produced quite a spaghetti code and refactoring small pieces to separate methods rendered the class enormous.\nAlso, you may be right that working with just the tokens, omitting parsing stage can be easier. I will try it out some time soon.\n. ",
    "javiern": "sorry for not responding, i was out for a while,  the problem i think was my fault, because i manipulate de tree to extract parts of them, i supose iam was doing something wrong because i cannot find a simple case that reporduce the same failure... thanks any way....\n. ",
    "JanTvrdik": "@nikic This issue is still there, reproduction is trivial, just try to directly print \\PhpParser\\Node\\Scalar\\EncapsedStringPart \u2013 \\PhpParser\\Node\\Scalar\\EncapsedStringPart is instance of Scalar and therefore instance of Expr, so the printer should be able to handle this without fatal error OR \\PhpParser\\Node\\Scalar\\EncapsedStringPart should not be instance of Expr.. The circumstances are not interesting in this case. I basically iterate over \\PhpParser\\Node\\Scalar\\Encapsed::$parts and recursively process each part and as part of the processing the expression may be printed. I can easily work around this issue in my case, but I still think that the current behavior with fatal error is not correct.. Can the quotation context be added as EncapsedStringPart's attribute?. ",
    "ArminVieweg": "Oh! Strange that I did not find it by myself. I'm sure I've searched for \"Return_\".\nHowever... Thanks! :)\n. ",
    "in-the-name-of-science": "Ah yes. That did the trick. Thanks!\n. ",
    "luisfredgs": "\nHello, I'm using laravel 5.2 with nikic/php-parser included, i don't know yet what version. Please, see my composer.json\n{\n    \"name\": \"nikic/php-parser\",\n    \"description\": \"A PHP parser written in PHP\",\n    \"keywords\": [\"php\", \"parser\"],\n    \"type\": \"library\",\n    \"license\": \"BSD-3-Clause\",\n    \"authors\": [\n        {\n            \"name\": \"Nikita Popov\"\n        }\n    ],\n    \"require\": {\n        \"php\": \">=5.4\",\n        \"ext-tokenizer\": \"*\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"~4.0\"\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"PhpParser\\\": \"lib/PhpParser\"\n        }\n    },\n    \"bin\": [\"bin/php-parse\"],\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"2.1-dev\"\n        }\n    }\n}\nUbuntu 16.04 LTS\nPHP Version 5.6.24\n. Yes, on composer.lick file founded:\n\"require\": {\n                \"nikic/php-parser\": \"^1.2|^2.0\",\n                \"php\": \">=5.4\",\n                \"symfony/polyfill-php56\": \"^1.0\"\n            },\ni tried run composer dump-autoload, but not fixed.\n. v2.1.0 was listed. Thanks!\n. ",
    "plateena": "Ok it was an old file. Don't know why composer won't update it. Remove entire PhpParser folder and run composer again.\n. ",
    "rcrum003": "That was it! thanks!\n. ",
    "mo-ba": "hey, thanks for reply.\nwhat? how?\ncould you provide me a link to some docs or examples or implementations?\n. hi guys!\ni will make some prototype, when i find some time, this should explain my suggesteion\ngrtz. ",
    "khusseini": "Amazing, thank you :)\n. ",
    "djmattyg007": "Cheers!\n. Thanks!\n. ",
    "Sobak": "Ach, I supposed that it has been already proposed but couldn't find related issue/PR. Thanks for the explanation, though.\n. ",
    "PhillippOhlandt": "Yeah I get that the pretty printer doesn't preserve code formatting. But in this case, the information about the starting line for the docblock is there, it just won't get used. Any ideas for a workaround?\n. Ah, interesting. Will play a little bit with that. It's the first time I use this library and I want to use it mainly for inserting functions or function content into existing classes.\n. ",
    "sunverwerth": "awesome\n. ",
    "cmack": "@GrahamCampbell yes, php7 with php parser v. 2.1.1 I have another similar error that I was going to file as a separate bug but it sounds like it might be similar root cause. Similar error for classes with include() methods: \nPHPParser: Syntax error, unexpected T_INCLUDE, expecting T_STRING on line 58\n. ah I think I misunderstood your comment, now checking to see if it's being parsed as php7 by parser.\n. mea culpa. It appears the tool I am using is not using the parser version I tell it to. I'll close this since I need to debug further. Sorry for the noise.\n. ",
    "dugajean": "Which file do you want me to check exactly?\n\nThe problem is that this started happening all of a sudden. The project worked as it should, then I try it after a week and this happens. I'm confused.\n\nEDIT\nI just checked if that String_ class exists in PhpParser\\Node\\Scalar and it doesn't. These are the contents of the scalar directory:\n\n. ",
    "martinsik": "Isn't this already resolved by NodeTraverser ::DONT_TRAVERSE_CHILDREN?\nhttps://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeTraverser.php#L100. Isn't this left like this intentionally?\nSee comment in https://github.com/nikic/PHP-Parser/blob/master/grammar/php5.y#L647. ",
    "PabloJoan": "I think it might be phpDox's problem. https://github.com/theseer/phpdox/issues/289 I'll keep you posted on this issue. ",
    "phpguru": "Gotcha, fair enough. We'll just add the folder to the list of directories we delete before pushing to production. . ",
    "onet4": "You are right. Not sure why but I was using v2.1.1. Installed v3.0.2 and now attributes are included.\nThank you.. You know DOM nodes can be retrieved with XPath. I'm looking for a mechanism similar to it. . Will be great if it's possible.. ",
    "Potherca": "You might want to take a look at a similar project: https://github.com/tito10047/PHP-to-Javascript (also usesnikic/PHP-Parser).. ",
    "vaibhav-kaushal": "@Potherca Lovely! I think I would give it a good read :). ",
    "RobbiNespu": "I dont know. but for sure, i not modified the bin-dir. ",
    "noder123": "Bump. My new laravel app is broken (unable to run after composer update). Not sure if laravel has a hard dependency on this package though.\nThanks for the awesome package!. @nikic: sorry for the late reply, but I'm still getting this error even after removing vendor directory and performing composer update/install.. @nikic: I cleared composer cache and it started working again. Thanks for your support.. ",
    "Rivendall": "Thank You for your useful answer. \nI have an idea for resolve this problem, but I think, it works on small project, and tested in \nsmall project. \nIn my idea, we have to a pre parse after send code to php parser, and process code. \nIn this process, we should replaces any include in code, manually, then new files send to php parser for create AST. Of course, this is your idea in the AST, but I say, replaces after send to parser. but there are problems about recursive includes.\nWhat is your idea? What do you think about thats? Is it possible? \nThank you. . @muglug , Thank you for answer. Your answer is true. I want to use php parser in the simple static code analyzer for php. After a lot of research, i choose php parser for create AST and parse code after analysis. But i don't know is there any library or tools for recognize include, require and etc in code? or is it possible? or is it needs for static analyzer? \nIf you have any help or ideas, please share with me. \nI wrote some algorithms for replace Include ... in code, but there are any problems for develop. \nI want to sure, there aren't any way for this work. . For example this line \n$parser = new PhpParser\\Parser(new PhpParser\\Lexer\\Emulative) ;\nmeans create new instance of parser. is it? \nwhat about other line in this code. . ",
    "markbook2": "@nikic Which node (class of node/node type) can be used as replacement for the require? If NodeVisitor returns an array the NodeTraverser shows the error\n'leaveNode() may only return an array if the parent structure is an array'\nI try to find a valid type and tried to replace the require expression with the InlineHTML node but it does not handle the all cases. The included files can contain PHP code, HTML code, combination of PHP and HTML, be empty. I.e. I am asking about a way of replacing a node with an array of nodes.. @nikic \n\nJust to make sure, are you using PHP-Parser 3.0 or the master branch?\n\nWe use HEAD of the master branch.\n\nCan you provide some more context on what you're trying to do?\n\nWe work on template engine which is a transpiler (source-to-source compiler), it takes template language (let's call it L1) and translates it into PHP. The L1 has the same syntax as PHP but some language constructs have different semantics (for e.g. the require, see below).\nIn the L1 the require language construct can't be used as expression and works as follows:\n1) Evaluate the expression e in the require e using PHP rules and get as result a string with the file path\n2) Read the file using the path from 1) using file_get_contents() and process the all require directives in it recursively.\nWe try to achieve this through modifying the AST with the following code:\n```php\n// Compiler\nclass Compiler {\n    public function compile($phpTemplateCode, bool $print = true) {\n        $parser = new Parser(new Lexer());\n        $nodes = $parser->parse($phpTemplateCode);\n        $traverser = new NodeTraverser();\n        $traverser->addVisitor(\n            new Processor($this)\n        );\n        $nodes = $traverser->traverse($nodes);\n        if (!$print) {\n            return $nodes;\n        }\n        $prettyPrinter = new PrettyPrinter();\n        return $prettyPrinter->prettyPrintFile($nodes);\n    }\n}\n// Processor used in Compiler:\nclass Processor extends NodeVisitorAbstract {\n    public function __construct($compiler) {\n        $this->compiler = $compiler;\n    }\npublic function leaveNode(Node $node) {\n    if ($node instanceof IncludeExpr) {\n        // For simplicity assume that the $node->type == TYPE_REQUIRE.\n\n        $nodes = $this->evalRequire($node->expr);\n\n        // What to do with nodes?\n    }\n}\n\nprotected function evalRequire(Expr $expr) {\n    $filePath = $this->evalExpr($expr);\n    $code = file_get_contents($filePath);\n    return $this->compiler->compile($code, false);\n}\n\nprotected function evalExpr(Expr $expr) {\n    $printer = new PrettyPrinter();\n    return eval('return ' . $printer->prettyPrintExpr($expr) . ';');\n}\n\n}\n```\nHere is an example of L1:\n```php\n// File require-test.phtml\n<?php require DIR . '/included-1.phtml'; ?>!\n// File included-1.phtml\nHello <?php require DIR . '/sub-dir/included-2.phtml'; ?> works\n// File sub-dir/included-2.phtml\n<?php echo 'World' ?>\n```\nand an example of the usage:\nphp\necho (new Compiler())->compile(file_get_contents(\"require-test.phtml\"));\nExpected result is:\n<h1>Hello World works!</h1>\nAs the $nodes in\nphp\n$nodes = $this->evalRequire($node->expr);\nis an array we can't return it as result, because the mentioned above error\nleaveNode() may only return an array if the parent structure is an array\nwill be displayed.. @nikic it works, thanks!. I had not found any occurrences of the PrettyPrinterAbstract::noIndentToken property anywhere except the constructor of the PrettyPrinterAbstract. Can it be removed instead of adding the declaration, proposed here?. ",
    "ao2": "Hi,\npreserving original code formatting when performing AST transformations will be very useful for code refactoring.\nHowever, even without it php-parser has still been useful to me as a validating tool for automatic refactoring done with other mechanisms which do preserve the formatting.\nHere is an example using sed and regexes (which I don't trust myself with) for the actual refactoring and php-parser for validation: https://git.ao2.it/experiments/php-drupal-console-code-refactoring.git/tree\nFeel free to take the php code as an example for php-parse, it implements a visitor which changes the second argument of a particular function to be null under certain conditions.. ",
    "gplanchat": "Hello\nA few months ago, I wrote an AST merger: https://github.com/kiboko-labs/akeneo-product-values-management/blob/master/src/Builder/ClassMerger.php\nIt is very specialized to the needs I had: appending properties and methods to existing classes. Maybe this solution could be some way to answer some of these needs?. ",
    "vovafeldman": "@nikic any ETA on releasing a stable version of format preservation? We really need it :). ",
    "jamesckemp": "Yes please!. ",
    "raducretu": "+1. ",
    "Juddling": "Hi all, I'm trying to modify some existing code - just pushing an item onto the end of an array, but the formatting is coming out like so:\n```\n--- Expected\n+++ Actual\n@@ @@\n <?php\nreturn [\n     'one',\n     'two',\n-    'three',\n-    'four'\n+    'three', 'four'\n```\nI cloned an existing node in the hope that it would copy the starting position.\nHere is the relevant code:\n```php\n    public function addToArray($code)\n    {\n        $visitor = new class extends NodeVisitorAbstract {\n            public function leaveNode(Node $node) {\n                if ($node instanceof Array_) {\n                    $newItem = clone $node->items[0];\n                    $node->items[] = $newItem;\n                    return $node;\n                }\n            }\n        };\n    return $this->modify($code, $visitor);\n}\n\npublic function modify($code, $visitor)\n{\n    $oldStmts = $this->parser->parse($code);\n    $oldTokens = $this->lexer->getTokens();\n    $newStmts = $this->traverser->traverse($oldStmts);\n\n    $this->traverser->addVisitor($visitor);\n\n    $newStmts = $this->traverser->traverse($newStmts);\n    return $this->printer->printFormatPreserving($newStmts, $oldStmts, $oldTokens);\n}\n\n```\nCould someone please advise me if this is a bug or not yet supported?. ",
    "rainbow-alex": "What about preserving redundant parentheses? When I parse:\n<?php echo (3);\nI get:\narray(\n    0: Stmt_Echo(\n        exprs: array(\n            0: Scalar_LNumber(\n                value: 3\n            )\n        )\n    )\n)\nWhich makes it almost impossible to restore the parentheses without some very complicated walking.. ",
    "Gert-dev": "I'm quite honestly not sure. I'm (ab)using the pretty printer as a sneaky way to check if two node hierarchies represent the same code by converting them to a string, so I don't really have a need for pretty printing a syntactically invalid file. Because of this, I'm happy with whichever approach you decide to take, as for my use case, it won't cause anything to break nor gain any functionality :-).. Thanks for looking into improving performance and memory usage, I do a lot of parsing and traversing/visiting using php-parser and will certainly benefit from it.\nI notice that especially large files become problematic. I discovered a file that takes around 10 seconds to parse here, which is part of the TCPDF fonts that encode font data in PHP files. I know, not the greatest idea, but they really pressure the parser's performance as well as spike memory usage. These files may be a bit artificial, but I wanted to pass these to you anyway as sample to measure possible memory and performance improvements.\nAs for storing the attributes in associative arrays: I'm not deeply familiar with PHP internals, but I have heard of the php-ds project which offers a PHP library with a Map data type that can automatically switch to a PHP extension implementation if it's enabled. This way users enabling that extension could automatically squeeze out extra performance and ones without it will just transparantly fall back to the plain PHP implementation. I don't know if this will help memory usage and performance, but as the extension is written in plain C it could be worth investigating. Also, its docs are here, in case it's hard to find.. @nikic Your suggestion regarding the GC was a very good one. I found that disabling it in my (long-running) process resulted in a rather noticeable performance improvement and reduction in latency. I've switched to manually collecting circular references every so often using gc_collect_cycles instead.\nI also wanted to drop a, potentially rather extreme, idea I had when investigating potential performance improvements in my own code, which I realized might also be relevant to php-parser: would it be possible to parallellize parsing and/or traversing?\nI'm not sure as to what extent parallellization is possible for parsing, but in the case of visiting it would (?) be possible to spawn up to n workers simultaneously for the root nodes of an array, which would then spawn more workers (up to a maximum) as they descend down the tree and invoke the visitors. I'm thinking of something like D's parallel or OpenMP's parallel for.\nThis should probably be put behind a switch, since the caller's visitors may or may not be ready for asynchronous execution; they may be holding state based on the previously hit node, for example. \nI'm also not sure how good threading support is in PHP (I've heard the, not so positive but possibly outdated, stories, however). In any case, as an extension such as pthreads, which seems to be one of the few extensions that works on all major platforms, can't really be a hard requirement for php-parser, something like a polyfill that reverts to the old behavior or simply a conditional switch may be desired.\nJust to be clear: this isn't a feature request and it may not even be actually possible in php-parser, but I wanted to throw the idea out there.. @nikic You're absolutely right and I'm aware. I should investigate this in detail at some point. Granted, there are a lot of objects going around, but if and why I specifically hit this limit I have not figured out yet (perhaps the solution is even rather trivial to avoid, once tracked down).\nI realize disabling the circular reference collector is somewhat of a band aid in this regard, but the situation currently being as it is (i.e. me not having found the root cause yet), as I see it, the references are already leaking, so if I can improve performance by not worsening the already poor situation, so be it \ud83d\ude04.\nUnfortunately for me, since my project handles code bases of theoretically infinite sizes, there will likely be a point where this becomes close to unavoidable or where extreme measures will be required to avoid the buffer hitting its maximum.\nApart from that, there is probably a reason for having chosen the amount of 10.000 - my guess is a buffer is allocated up front and they needed a sane default for its size, which is okay - but I don't really understand why this is currently handled rather poorly in extreme situations:\n\nThere is no INI directive to change it - admittedly it probably wasn't necessary for web request handling, which is what PHP seems to be used most for\nThere is no backoff mechanism in place - as mentioned in the article of Anthony Ferrara\nThere is no automatic reallocation of the buffer to a larger, e.g. double, size - a bit like C++'s std::vector does, IIRC\n\nIn conclusion, the PHP runtime basically just throws its hands up in the air and says \"Damn, son, I can't handle this many objects, I'm bailing\". All of this is happening completely without any sort of warning to the developer. In languages such as C there is no one to tell you you are leaking memory (it's your own fault, after all, should have freed it if you allocated it), but in this case PHP could at least warn that there is no more room in the buffer and a leak may ensue.\n... but you don't need to answer any of this, I just wanted to vent a bit of frustration \ud83d\ude09.\nRegarding the parallelization (with proper spelling, this time \ud83d\ude04), you may be right. I guess it all depends on how many objects there are to traverse as well as what the user is doing in the visitors themselves. If nothing else than collecting some data is happening, even for larger hierarchies, I suspect parallelizing them will have little effect.\n. @nikic That's great to hear! I must admit that I hoped my rant would somehow propagate up the chain to the core, as I knew you were involved there. My apologies for this sneaky tactic :wink: .\nPurely out of interest and at the risk of going off-topic - I'm also not familiar with PHP core -, but if I don't disable GC and I hit the limit, how are new roots being tracked if none of the existing ones can be dropped? I assumed that some sort of static buffer with a maximum length was being used, so I naturally assumed that any new entries would not be able to fit into this buffer, causing them to be dropped and in turn resulting in these circular references never being able to be resolved and, thus, freed, resulting in a memory leak. \nEDIT: On a more on-topic note. I'm not sure if this is feasible at all, but some sort of incremental parsing system might also provide a boon for performance in scenario's where little changes are made to source code, such as in language server scenario's. These currently require some sort of intelligent mechanism on the caller's side to determine what parts of the code to parse or just reparsing the entire source code. Apparently atom's upcoming tree-sitter does something similar. On a side note, it apparently can also recover from errors and seems to be fairly generic, there was a talk about it at FOSDEM that's freely viewable here.. @muglug Looks interesting! The branch seems to have disappeared in the meantime, is it this commit you are referring to?\nIt would be neat if this could be a decorator just implementing the Parser interface that works transparently by only parsing the necessary parts of the file when it detects it's been changed (and otherwise just does the normal parsing).\nThe results of the operation could then be stored somewhere in a predesignated folder (such as /tmp or memory). In my case I'd probably need to limit that cache to a fixed size as code bases can be large, but that shouldn't be a problem, as most recently used files - the ones the user is working in - will stay hot in the cache anyway.\n@mattacosta Interesting benchmarks. One should however provide some nuance to these benchmarks as it appears the tolerant PHP parser is not fully compliant yet - at least according to the checkboxes in its README. Thus while it may give some insight, it currently is a bit like comparing apples to oranges as, in order to become as compliant as PHP-Parser is, performance may degrade as a result.. I'm not familiar with the impact this has on the rest of the code or how hard this is to accomplish, of course, but it seems as if the error node should never be including a token that is not part of it at all, even if it were valid. Is it perhaps an option to make this error node take up no space whatsoever or, reduce its endFilePos by one?. You're right, I did some more investigating and it turns out I didn't correctly see what the problem was. What is happening is that I\"m traversing a tree to find ClassMethod nodes and I'm extending the NameResolver to do the resolving. My enterNode unconditionally calls parent::enterNode. When the NameResolver encounters such a node, it immediately calls resolveSignature to do the resolving. After that, it exits and my method parses the entire class method definition, including its parameters, return type, and so on.\nIn other words, you did certainly implement it, but because the new resolving code is not in the resolveSignature method (where I expected it to be in my first post), my code, which depends on the resolved types, is executing before the newly added elseif block is executed. It is still executed, but after my code is done exceuting, which explains why your tests are succeeding :-).\nTo conclude, it's not so much of a bug, just not the behavior I expected. In order to get the types resolved, I now either have to do the entire resolving beforehand and visit the hierarchy twice, or move my code to the leaveNode method for the ClassMethod node in order for the resolving to have already happened. I can't immediately process any ClassMethod (nor Param nodes, for that matters), as type resolving happens only when the parent descends into the name nodes of the types themselves.\nI'll leave you to decide if you want to change the behavior or not. If not, I won't hold it against you and I'll look into working around it :-).. Doh, I've literally just released a new version of my package with the specific Git commit and came here to report that it is indeed fixed. No problem though, now I'll be able to lock Composer to a specific version again instead of a commit. Keep up the great work! \ud83d\udc4d . That makes sense. Since it's not an issue that's easy to solve for php-parser, I'll look into investigating a manual fix for this at some point in the future in my codebase. Thanks for the information!. Ugh, you are right. I see now I even used it before. Don't know where I got the idea that this wasn't possible. Apologies!\nEDIT: I must have mistaken this for function bodies. I've opened a separate issue to keep your issues nice and separate in  #421.. That was an idea I had too. However as mentioned, there can be a theoretically infinite number of characters between the end of the parameter list (or even the return type) and the function body:\n```php\nfunction foo(string $start): Foo // I have a { here in this comment, which the strpos will match\n{\n}\n```\n... one would then need to verify that the curly brace is not inside a comment, whilst the comment may not even be a part of any node and it is unfortunate, since now the application needs to be aware of how the code needs to be parsed and treated.\nThe proposal in #16 to replace the arrays seems like one I could live with for this, granted that the startFilePos and endFilePos of that block starts just before (or just after, either is fine) the opening and closing curly brace and not the actual first statement, which may or may not be present :-).\nEDIT: I just noticed I used the wording \"paranthesis\" in my OP, whilst I actually meant curly braces. I see now that that may have been confused with the parameter list instead of the body, sorry if that wasn't clear.. Thanks for the tip. I'll close this since you've basically given me a decent solution and the other ticket regarding the block statement also represents a solution to this problem. Thanks!. Thanks for your response. That indeed makes sense. Undoubtedly using inclusive ranges was an explicit decision you had good reasons for in the past. It may make sense, if it isn't already, to document this somewhere that this is an intended side effect.\nNow that I know this, I'll look into ways to working with this in my implementation. Thanks!. I guess half-closed intervals is one of those things that I have become accustomed to, a bit like zero-indexed arrays. Apart from that, I never had any hard preference for them, but now that I've seen the implications for empty ranges, that is no longer the case \ud83d\ude04.\nI can't speak for other users, but I would be open to modifying my code to use both the Location objects and the half-closed intervals, if you decided to change it.. Wanted to chip in with a question: is there a possible technical limitation as the reason that docblocks and comments aren't actually separate nodes? I wanted to ask as 4.0.0 is now in the works and, if a BC break is to happen, this would be an opportune time.\nIn some scenario's attaching docblocks to the next node is intuitive, such as when a method docblock is present, it obviously belongs to the method below it. In other cases, it is rather awkward, such as in this case where the docblock has no bearing on the next elment at all or just contains general information.\nPerhaps introducing a separate node for comments as well as docblocks would provide a solution? The next node could, if backwards compatibility is desired, still contain a reference to that node.\nIt would also make scenario's such as \"find whatever is located at this offset in the file\" more intuitive, which could then also include a docblock or comment without having to scan neighbouring nodes.. My main goal was to get a somewhat sensible AST for this erroneous code autocompletion could continue functioning for incomplete statements, which appears to work with this change, so more than good enough, in fact, thanks!. Thanks! That already helps, especially when using snippets that generate an empty method body, in which case the second case doesn't happen.\nIs the second case something you want to do at some point in the future or too difficult to solve?. @nikic That is true and this change also takes away some of the pain, upping (the illusion of) professional autocompletion in Serenata.\nFeel free to close this or leave it open if you want to revise it at some point in the future.. When updating to this commit, I can now generate proper autocompletion in the aforementioned scenario for users needing to update an array element, so this seems very reasonable, thanks!. ",
    "mattacosta": "Results from parsing every PHP file in some large frameworks:\nDrupal (8.6.x @ 5d17da1) - 8401 files\n| parser | time (ms) | memory (kb) |\n| :--- | ---: | ---: |\n| microsoft/tolerant-php-parser | 16455.64 | 1174311.48 |\n| nikic/php-parser | 25693.36 | 1784685.80 |\nMagento2 (2.3-develop @ b252ca0) - 21688 files\n| parser | time (ms) | memory (kb) |\n| :--- | ---: | ---: |\n| microsoft/tolerant-php-parser | 32648.24 | 2384537.00 |\n| nikic/php-parser | 43200.28 | 3423339.44 |\n. @Gert-dev There haven't been any significant changes to that README in almost two years. For instance, it still references a custom lexer, but that was abandoned prior to release and it currently uses token_get_all instead. I do not expect a PHP-based implementation to be faster than that either.\nAs for compliance, you are correct in that it still has a lot of room for improvement, especially with regard to expressions. Even if corrected however (and that is a big if), I do not expect the time-complexity of the methods used to parse those rules to change significantly, so any performance changes should be minimal.\nFor those interested in pure speed, I should also mention that I tested some fully-representative, JS-based implementations and they were both roughly twice as fast (or better) than their PHP-based counterparts. While that really is apples to oranges, I still think it'd be interesting to see what could be done to close the gap.. ",
    "shashankkrjain": "Sorry for this. There was a weird error I was facing, and I believed this fixed it. However, it didn't and I had to delete vendor folder and reinstall everything to make it work. All plugins with executable were giving errors so this was not particularly this plugin.. ",
    "fredemmott": "Should be fixed in the next HHVM release, https://github.com/facebook/hhvm/commit/29fc86f9ddefc918549c201ebe5ee8a978efde44. ",
    "borNfreee": "Solution is to use (with modifications) code from #238 that adds parent relations for each node:\n```php\nclass ParentConnectorVisitor extends NodeVisitorAbstract\n{\n    const PARENT_KEY = 'parent';\nprivate $stack;\n\npublic function beforeTraverse(array $nodes)\n{\n    $this->stack = [];\n}\n\npublic function enterNode(Node $node)\n{\n    if (! empty($this->stack)) {\n        $node->setAttribute(self::PARENT_KEY, $this->stack[count($this->stack) - 1]);\n    }\n\n    $this->stack[] = $node;\n}\n\npublic function leaveNode(Node $node)\n{\n    array_pop($this->stack);\n}\n\n}\n``. Thank you!. Great, thank you. Do you plan to release a new tag for 3.x?. Thank you!. thank you. @phil-davis done, thank you. @sanmai Reflection classes are added by our own visitor https://github.com/infection/infection/blob/master/src/Visitor/ReflectionVisitor.php#L48. extra line?. I've updated the code and test to make sureleaveNode()can replace the node whenDONT_TRAVERSE_CURRENT_AND_CHILDREN` is used. ",
    "SignpostMarv": "it was a case of \"if I'm adding this, why not add this other thing?\"- if we're not particularly fussed about exposing additionalAttributes, I can force-push it without the additional attributes method?. done :). Inside a ->addStmt() call of the factory-defined __construct() method:\nphp\n->addStmt(\n                new Assign(\n                    new PropertyFetch(\n                        new Variable('this'),\n                        'providerInstance'\n                    ),\n                    new StaticCall( // line 142\n                        new Name(\n                            'SerialisedElementSource'\n                        ),\n                        'InstantiateElementsProviderWithDependencies',\n                        [\n                            new Variable(\n                                'GetSerialisedElement'\n                            ),\n                            new Variable(\n                                'GetHtmlFragmentDeserialiserInterface'\n                            ),\n                        ]\n                    )\n                )\n            )\nAn if statement that's calling a method built later or throwing an exception:\nphp\nnew If_(\n                    new Identical(\n                        new FuncCall( // line 200\n                            new Name('method_exists'),\n                            [\n                                new Variable('this'),\n                                new Variable('methodName'),\n                            ]\n                        ),\n                        new ConstFetch(\n                            new Name('false')\n                        )\n                    ),\n                    [\n                        'stmts' => [\n                            new Throw_(\n                                new New_( // line 214\n                                    new Name('InvalidArgumentException'),\n                                    [\n                                        new Concat(\n                                            new Concat(\n                                                new Concat(\n                                                    new Concat(\n                                                        new Concat(\n                                                            new Concat(\n                                                                new String_(\n                                                                    'Argument 1 passed to '\n                                                                ),\n                                                                new ClassConstFetch(\n                                                                    new Name('static'),\n                                                                    new Name('class')\n                                                                )\n                                                            ),\n                                                            new String_('::')\n                                                        ),\n                                                        new MagicConst\\Method()\n                                                    ),\n                                                    new String_(\n                                                        '() does not have a coresponding method ('\n                                                    )\n                                                ),\n                                                new Variable('elementRef')\n                                            ),\n                                            new String_(')')\n                                        ),\n                                    ]\n                                )\n                            ),\n                        ],\n                    ]\n                )\nsomewhere down the chain of $factory->method('foo')\nphp\n)->addStmt(\n                new Return_(\n                    new MethodCall( // line 251\n                        new Variable('this'),\n                        new Variable('methodName'),\n                        [\n                            $this->factory->param(\n                                'args'\n                            )->makeVariadic()->getNode(),\n                        ]\n                    )\n                )\n            )\nA loop that takes some parsed phpdoc annotations to add all the methods to avoid runtime reflection:\nphp\n        foreach ($annotations as $index => $annotation) {\n            $annotationMethodName = ('method_' . hash('sha256', $annotation));\n            $builderClass->addStmt(\n                $this->factory->method(\n                    $annotationMethodName\n                )->makePublic()->addParam(\n                    $this->factory->param(\n                        'args'\n                    )->makeVariadic()\n                )->addStmt(\n                    new Return_(\n                        new MethodCall( // line 292\n                            new PropertyFetch(\n                                new Variable('this'),\n                                'providerInstance'\n                            ),\n                            $methodNames[$index],\n                            [\n                                $this->factory->param(\n                                    'args'\n                                )->makeVariadic()->getNode(),\n                            ]\n                        )\n                    )\n                )\n            );\n        }. p.s. if there's a cleaner way of constructing Concat that I missed when perusing the code, please tell me :D. re: ->concat, I was thinking of adding it on Concat itself, i.e.\n```php\n<?php\nnamespace PhpParser\\Node\\Expr\\BinaryOp;\nuse PhpParser\\Node\\Expr\\BinaryOp;\nclass Concat extends BinaryOp\n{\nprotected static function ConcatFromExprsRecursive(array $exprs) : Concat\n{\n    $argWasZero = array_shift($exprs);\n    if (count($exprs) === 2) {\n        return new static(\n            $argWasZero,\n            new static($exprs[0], $exprs[1])\n        );\n    }\n\n    return new static(\n        $argWasZero,\n        static::ConcatFromExprsRecursive($exprs)\n    );\n}\n\npublic static function ConcatFromExprs(...$exprs) : Concat\n{\n    $numberOfExprs = count($exprs);\n    if ($numberOfExprs < 2) {\n        throw new InvalidArgumentException(\n            static::class .\n            '::' .\n            __METHOD__ .\n            '() requires at least two arguments'\n        );\n    } elseif ($numberOfExprs === 2) {\n        return new static($exprs[0], $exprs[1]);\n    }\n\n    return static::ConcatFromExprsRecursive($exprs);\n}\n\n}\n```\ndifference:\ndiff\ndiff --git a/app/baked-serialised-element-providers/BakedSerialisedElementSource_1408c0b3ec1c3629e889f4089270aa7cb1BQZKqdp2CV3QV5nUEsqSg1ygegLmqRygj.php b/app/baked-serialised-element-providers/BakedSerialisedElementSource_1408c0b3ec1c3629e889f4089270aa7cb1BQZKqdp2CV3QV5nUEsqSg1ygegLmqRygj.php\nindex bd2a729..a29b736 100644\n--- a/app/baked-serialised-element-providers/BakedSerialisedElementSource_1408c0b3ec1c3629e889f4089270aa7cb1BQZKqdp2CV3QV5nUEsqSg1ygegLmqRygj.php\n+++ b/app/baked-serialised-element-providers/BakedSerialisedElementSource_1408c0b3ec1c3629e889f4089270aa7cb1BQZKqdp2CV3QV5nUEsqSg1ygegLmqRygj.php\n@@ -19,7 +19,7 @@ public function GetSerialisedElement(string $elementRef, ...$args) : array\n     {\n         $methodName = 'method_' . hash('sha256', $elementRef);\n         if (method_exists($this, $methodName) === false) {\n-            throw new InvalidArgumentException('Argument 1 passed to ' . static::class . '::' . __METHOD__ . '() does not have a coresponding method (' . $elementRef . ')');\n+            throw new InvalidArgumentException('Argument 1 passed to ' . (static::class . ('::' . (__METHOD__ . ('() does not have a coresponding method (' . ($elementRef . ')'))))));\n         }\n         return $this->{$methodName}(...$args);\n     }\nThe relevant generator code:\nphp\n                            new Throw_(\n                                new New_(\n                                    new Name('InvalidArgumentException'),\n                                    [\n                                        new Arg(\n                                            Concat::ConcatFromExprs(\n                                                new String_(\n                                                    'Argument 1 passed to '\n                                                ),\n                                                new ClassConstFetch(\n                                                    new Name('static'),\n                                                    new Name('class')\n                                                ),\n                                                new String_('::'),\n                                                new MagicConst\\Method(),\n                                                new String_(\n                                                    '() does not have a coresponding method ('\n                                                ),\n                                                new Variable('elementRef'),\n                                                new String_(')')\n                                            )\n                                        ),\n                                    ]\n                                )\n                            ),. Is there code in the builder already for auto-conversion of types the appropriate node ?. Perhaps make it a function ?. ",
    "DragorWW": "@nikic yes, i will can create PR for this functional.. @nikic may be const MAGIC_NAMES change to protected static $magicNames?. @nikic fix it. ",
    "tsufeki": "It seems that comments \"in the middle\" of compound statements are ignored too, for example\nphp\n<?php if /* a */ (7) {}. One more thing: comments are often repeated, i.e. same comment appears in many nodes. This can be seen in tests, for example parser/blockComments.test. Is this intended? If so, what are the rules for repetition? Thanks for your work.. ",
    "limeb": "@tsufeki in my opinion <?php if /* a */ (7) {} is acted as intended.  I believe the comments are intended for typical documentation which wouldn't include such.. I'm afraid you are probably right that trying to modify the XML myself is pretty crazy.\nYour advice is solid.  Nice to see you around SO.\nI have been reading through your tests and docs.  Now that you mentioned it I see the serialize function.\nDo you mind directing me to where an example of converting XML to php code?  I have found this example in the docs but its not quite there.  I will likely close this issue soon.  The XML function does seem useful although complex.\n```php\n$xml2 = <<\n\n\n\n\ntest\n\n\n1\n1\n1.5\n\n\n\n\n\nXML;\n$result = array(\n    array(), array(),\n    'test', '', '',\n    1,\n    1, 1.5,\n    true, false, null\n);\n$unserializer  = new PhpParser\\Unserializer\\XML;\nprint_r($unserializer->unserialize($xml));\n```. ",
    "stanvass": "When I was processing line comments, the way they are assigned to the next statement, I thought, isn't the expected way to factor this. Wouldn't it be better if they are a statement/expression on their own?. My bad, it seems multiple semicolon namespaces are valid.. ",
    "j-d": "Good points. Thanks for your prompt response.\nMaybe just add null to the type annotation and that will be enough. My issue was that I was not expecting to find null after seeing ArrayItem[] here.. Thanks. I think this issue is still happening on 4.0.3. ",
    "hoangweb": "thanks. ",
    "romainneutron": "I don't reproduce the issue anymore. However, I remember it was using symfony php 7.0 polyfill with PHP 5.5. This part of the code of the polyfill triggered an error, leading to Lexer::errorMayHaveOccurred returning true.. Does it help you? . ",
    "krageon": "You could transform your POSTed code using a Parser instance, and subsequently put that into the stmts that belong to that Method. If you then print your AST, you should see whatever you typed into that box inside the function (assuming it was parseable). . ",
    "bobthecow": ":) Thanks!. Per the Unicode CLDR, Persian and Arabic use different a glyph (\u066b instead of , as a decimal separator) but I'm not sure if that's what setlocale actually spits out, or if it just uses a comma. And I can't test either of those on my machine.\nhttp://www.unicode.org/cldr/charts/28/verify/numbers/fa.html\nhttp://www.unicode.org/cldr/charts/28/verify/numbers/ar.html. Thank you!. ",
    "azurre": "Sorry. I mean original value.\nSomething like this:\npublic function getValue()\n    {\n        if ($this->value instanceof String_) {\n            return $this->value->value;\n        } elseif ($this->value instanceof Array_) {\n            return $this->value->toArray();\n        } elseif ($this->value instanceof LNumber) {\n            return $this->value->value;\n        } elseif (property_exists($this->value, 'value')) {\n            return $this->value->value;\n        }\n...\n}\n. ",
    "TiMESPLiNTER": "I want to use it for other grammar files than just the php5 and php7 yaccs. And that way I can reuse this instead of copying everything to a new project...\nMaybe a separate repository for the yacc parser builder/generator would also be a nice solution. So I don't have to pull in all the other PHP parser code stuff (all the node classes, etc).\nOr I could just remove the bin/build-parsers again, restore the file in the grammar dir which just uses the ParserBuilder class.. You're absolutely right if you say that there is specific code to the PHP parser but there are also a lot of general things handled in it which one would need to create a parser (for example initializing an array and put elements into it, etc). Plus the whole kmyacc thingy which would be the same for many other programming languages I guess. So I think an own repository would totally make sense which gives you a public API to things which make sense to generalize. I mean everyone can extend the basic ParserBuilder class from that new repo then and add features to fit the needs of the grammar for the language which should be parsed.\nJust to teach myself YACC I wrote a YACC parser using your parser generator code successfully (sure this is a pretty primitive parser compared to the PHP parser but I didn't need to change a line at all in your rebuildParser.php script (except the FQ namespace fix).. ",
    "CaledoniaProject": "Looks like I should use getAttribute('startLine') .... just found it . ",
    "cjohansson": "It seems I had a syntax error :(. Ok I was able to reproduce it now. Sure here it is\nJust PHP without PhpParser works:\nphp -f testClass.php \nmyEchoAmyEchoB\nWith PhpParser, Fatal error:\n```\nphp -f test.php \nPHP Fatal error:  Uncaught PhpParser\\Error: No code may exist outside of namespace {} on line 28 in /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:449\nStack trace:\n0 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/Parser/Php7.php(817): PhpParser\\ParserAbstract->handleNamespaces(Array)\n1 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php(262): PhpParser\\Parser\\Php7->reduceRule1()\n2 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php(50): PhpParser\\ParserAbstract->parse('<?php\\n\\nnamespac...', Object(PhpParser\\ErrorHandler\\Throwing))\n3 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php(31): PhpParser\\Parser\\Multiple->tryParse(Object(PhpParser\\Parser\\Php7), Object(PhpParser\\ErrorHandler\\Throwing), '<?php\\n\\nnamespac...')\n4 /Users/christianjohansson/Web/PHPParser/test.php(7): PhpParser\\Parser\\Multiple->parse('< in /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 449\nFatal error: Uncaught PhpParser\\Error: No code may exist outside of namespace {} on line 28 in /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php:449\nStack trace:\n0 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/Parser/Php7.php(817): PhpParser\\ParserAbstract->handleNamespaces(Array)\n1 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php(262): PhpParser\\Parser\\Php7->reduceRule1()\n2 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php(50): PhpParser\\ParserAbstract->parse('<?php\\n\\nnamespac...', Object(PhpParser\\ErrorHandler\\Throwing))\n3 /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/Parser/Multiple.php(31): PhpParser\\Parser\\Multiple->tryParse(Object(PhpParser\\Parser\\Php7), Object(PhpParser\\ErrorHandler\\Throwing), '<?php\\n\\nnamespac...')\n4 /Users/christianjohansson/Web/PHPParser/test.php(7): PhpParser\\Parser\\Multiple->parse('< in /Users/christianjohansson/Web/PHPParser/vendor/nikic/php-parser/lib/PhpParser/ParserAbstract.php on line 449\n```. Ok you mean create a unit test for it and do a pull request? All source code is in the first comment, it's not much. Sure, I can do that later this week if you want. ",
    "kukulich": "Thank you :). ",
    "ircmaxell": "\nWould I be mistaken in the assumption that what you're looking for here is not actually an interface, but rather the ability to write PrettyPrinter rather than PrettyPrinterAbstract in type hints?\n\nWell, yes and no.\nRight now there's a single implementation of PrettyPrinter (PrettyPrinter\\Standard). The two classes today (Abstract and Standard) are quite tightly coupled in that most use-cases would extend Standard instead of Abstract just due to the nature of the implementation.\nSo that raises a significant question: what's the purpose of Abstract in the first place? \nIntroducing an interface for the type would allow Abstract to pull in the default implementation of Standard, and let Standard simply an empty extension. Then that opens the door to extending Abstract simply to render exactly what's needed (overriding the Abstract methods as needed).\nFor example, to implement a pretty printer that strips out comments, you would simply need to extend abstract and override pComments to always return ''. \nAgain, not a huge win, but seems that the symmetry with the rest of the design may be worth while.\nPushing a fix adding the other 3 methods + some docs.... ",
    "vmitchell85": "Yeah @nikic thanks... I was trying to run Builder commands on Parser classes... figured it out.... ",
    "soullivaneuh": "@nikic Do you have any ETA for a stable patch release? :-). ",
    "codeliner": "@nikic of course, done. ",
    "khalyomede": "FuncCall expected a \\PhpParser\\Node\\Name, raw string does not works.. ",
    "carusogabriel": "@nikic May we require minimum PHP 7.1 in version 4.0?. @TomasVotruba Manually, but sometimes, regular expressions help me :sweat_smile: . @TomasVotruba No way that exists a tool to automate this process :scream: :heart_eyes: \nI'm going to study rectorphp/rector, and help you improve this process! Also, start to use (and reference, for sure) :nerd_face: . @legoktm Could you elaborate how would you use it?. @nikic If I try to fix it, should be submitted to 3.x branch?. @TomasVotruba Is something to consider. But we would need to be careful, there are some classes, like Php5 that have closures with fold methods and sentences. Unfold them would create an amount of code pharaonic. I did the most simple ones. I guess we can join forces to simplify some classes and then apply a Coding Standard :sweat_smile: . @nikic Perfect, I do understand your point, just did to follow the best practices out there :smile: \nIs there any other commit that you are interested in, or may I close it?. @TomasVotruba I used PHP-CS-Fixer's rule called visibility_required for this one.\nThe others I'll need to remember, I email you later with them :smile: . No, was just about make them protected, and make code like:\nphp\n$node->args[0] -> $node->getFirstArg() or $node->getArg(0);\n:smile: . > We can't make the property private because it's a subnode (things like node dumping would break)\nYeah, just test it \n\nWe could mark it as @internal in phpdoc though.\n\nMaybe, but my idea was to avoid false-positives with PHPStan, like:\nCannot call method toString() on PhpParser\\Node\\Expr|string\n, but\n\nFor the record, the preferred way is to use toString()\n\nseems to solve some of them :)\nThanks for the explanation. @nikic @Sewens Something like:\nClass | Node\n----- | -----\nPhpParser\\Node\\Expr\\BinaryOp\\NotIdentical | !==\n?. > Would it make sense to also list the subnodes (and their types)?\n@nikic What do you have in mind? My idea was:\n```md\nNode\\Expr\n(All Node\\Expr subnodes here)\n```\nGonna try to list all of them this afternoon, so we can start to struct the files.. > By subnodes I meant the properties of the node. So Class_ has flags, name, stmts etc.\nInteresting didn't think on that. Added to our roadmap.\n\nE.g. you'd already have to know whether something is an expression or a statement to search for it.\n\nGood point, so let's keep this in one file for now.\nI'm sorry for my delay, I'm a little busy with some stuff from the work, but I hope we can document everything this weekend :)\n. Yep, I'll review the changes between branches, sorry!. This change was made because of:\nStrict comparison using === between null and PhpParser\\Node will always evaluate to false.. This change was made because of:\nStrict comparison using !== between PhpParser\\Node and null will always evaluate to true.. Thanks, gonna fix it.. Nops. As FullyQualified extends the Node\\Name, isRelative method is still available. I only removed because the code in parent's one is the same.. We don't use PHP 7.1 here, yet :smile: . ",
    "KugiHaito": "@nikic Is it possible to implement overhead of methods?\n. ",
    "VolCh": "As far I understand it generated by new Namespace_(new FullyQualified(''), ...) at https://github.com/goaop/parser-reflection/blob/master/src/NodeVisitor/RootNamespaceNormalizer.php#L47\nduring parsing file without any namespace, i. e. global namespaces \nP.S. What is expected behavior for (new Namespace_(new FullyQualified('')))->toString() ?. ",
    "joachim-n": "Indeed, I see the problem.\nTo me at least, conceptually, a docblock that has spacing either side of it isn't attached to anything.\n@file docblocks are one such example, but they are used for other kinds of documentation too, eg in https://github.com/drupal/core/blob/8.5.x/core.api.php. ",
    "guangrei": "yes... solved, thanks you very much \ud83d\ude07. ",
    "loren-osborn": "Here is a NodeVisitor that fixes the issue.  It defaults to the current PHP version, but is easily settable. ~~It does not currently have any knowledge of PHP 7.2, but should be easy to add~~ [Added]:\nhttps://github.com/loren-osborn/parser-reflection/blob/losborn_passThrough_squashed/src/NodeVisitor/BuiltinTypeFixer.php\nBeyond PHP 5 vs 7, is there anyway to tell PhpParser what version of PHP to parse code as?\n[UPDATE] \nFixed link above. Added support for object in PHP \u2265 7.2.. @nikic, please let me know if a there is a way to tell the parser what SPECIFIC PHP version it should parse like. Should a feature equivalent to what this NodeVisitor provides be welcome?. ",
    "Azhovan": "Nice. ",
    "SamMousa": "That's what I thought after inspection, thanks for confirming!. ",
    "emmetog": "Ok, thanks for the feedback @nikic. ",
    "weaverryan": "Thanks @nikic! I'm looking forward to it. I noticed the docs reorg lately - it feels a bit \"flatter\" to me now (in a good way) - easy to see everything from the docs homepage :). Wooohoooo! I owe you for having this great new feature, right when we needed it <3. Thanks for the info! Unfortunately, it's still over my head :/. I've worked around it on our end (no big deal). If you don't think it's worth fixing, then please feel free to close.\nCheers!. ",
    "mnpenner": "@nikic Nope, didn't pass any options:\nphp\n$traverser->addVisitor(new NameResolver);\nIt definitely doesn't look like it resolved the type for me.\nphp\nif((string)$param->type == 'SymfonyRequest') {\n    var_dump($param->type);\n    echo $dumper->dump($param->type);\n    exit;\n}\nOutputs:\nobject(PhpParser\\Node\\Name)#19222 (2) {\n  [\"parts\"]=>\n  array(1) {\n    [0]=>\n    string(14) \"SymfonyRequest\"\n  }\n  [\"attributes\":protected]=>\n  array(4) {\n    [\"startLine\"]=>\n    int(10)\n    [\"startFilePos\"]=>\n    int(350)\n    [\"endLine\"]=>\n    int(10)\n    [\"endFilePos\"]=>\n    int(363)\n  }\n}\nName(\n    parts: array(\n        0: SymfonyRequest\n    )\n)\nI did, however, change the lexer options because I want the char offsets:\nphp\n$lexer = new PhpParser\\Lexer([\n    'usedAttributes' => [\n        'comments', 'startLine', 'endLine', 'startFilePos', 'endFilePos',\n    ]\n]);\nCould that have done it?. @nikic The script is a major hackjob, but here it is.\nThe relevant parts (I think) are:\n```php\n$dumper = new NodeDumper;\n$lexer = new PhpParser\\Lexer([\n    'usedAttributes' => [\n        'comments', 'startLine', 'endLine', 'startFilePos', 'endFilePos',\n    ]\n]);\n$parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP5, $lexer);\n$traverser = new NodeTraverser();\n$traverser->addVisitor(new NameResolver);\n$traverser->addVisitor(new ClassExtractor); // <-- my class\n...\n$ast = $parser->parse($code);\n$traverser->traverse($ast);\n```\n. @nikic Yup, that was it. Thank you so much! Sorry for taking your time, that was my mistake :smile: . ",
    "davidmpaz": "+1 for:\n\nit might be best to create a separate Modifiers class for it\n\nNot directly using PHP-Parser in PHP, but taking it as reference for some other language related work. I agree It would be better if treated those as separate. \nThe same idea apply to Visibility. Currently Modifiers as well as Visibility are treated the same, as flags, if I have understood well the code in Class_ and ClassMethod.\nPlease take in consideration i am not aware about implementation issues this could bring. Just providing my 2 cents.. ",
    "BackEndTea": "Thanks for the help, personally i solved it like this in a base class\n```php\n    protected function wrapInExpression(Node $node)\n    {\n        if ($this->shouldWrap === null) {\n            $this->shouldWrap = class_exists(Node\\Stmt\\Expression::class);\n        }\n    if ($this->shouldWrap) {\n        return new Node\\Stmt\\Expression($node);\n    }\n    return $node;\n\n}\n\n```. ",
    "vaceletm": "Oh yes it does !\nThanks for all, you really rocks \\o/. FYI, I wrote a quick blog post on what we are doing with php parser: https://blog.tuleap.org/php-automated-refactoring-php-parser-convert-simpletest-mocks-mockery and the corresponding project on github: https://github.com/Enalean/simpletest2mockery. ",
    "nterray": "Thanks for the suggestion, I will try it.\n@TomasVotruba I thought about it. Unfortunately, the legacy code that I try to rewrite thanks to PHP-Parser is full of odd (& old) coding styles (if any) and in my refactoring I prefer to style only the updated lines and not the whole file. I'm afraid that php-cs-fixer will change more lines than needed.. @nikic Unfortunately pMaybeMultiline has private access therefore I cannot call it from CustomPrettyPrinter.\nNevertheless by copying private methods pMaybeMultiline and hasNodeWithComments inside the CustomPrettyPrinter, it works like a charm. Closing the issue then.\nThank you. . ",
    "golddragon007": "Yes, here it is:\n[project-dir]\\web>php \"C:\\Program Files (x86)\\DevDesktop\\tools\\composer.phar\" -vvv install\nNo composer.json in current directory, do you want to use the one at [project-dir]? [Y,n]? y\nReading ./composer.json\nLoading config file C:/Users/Marton/AppData/Roaming/Composer/auth.json\nLoading config file ./composer.json\nChecked CA file C:\\Program Files (x86)\\DevDesktop\\common\\cert\\cacert.pem: valid\nExecuting command ([project-dir]): git branch --no-color --no-abbrev -v\nReading C:/Users/Marton/AppData/Roaming/Composer/composer.json\nLoading config file C:/Users/Marton/AppData/Roaming/Composer/auth.json\nLoading config file C:/Users/Marton/AppData/Roaming/Composer/composer.json\nLoading config file C:\\Users\\Marton\\AppData\\Roaming\\Composer/auth.json\nReading C:\\Users\\Marton\\AppData\\Roaming\\Composer/auth.json\nReading [project-dir]/vendor/composer/installed.json\nReading C:/Users/Marton/AppData/Roaming/Composer/vendor/composer/installed.json\nLoading plugin cweagans\\Composer\\Patches\nLoading plugin DrupalComposer\\DrupalScaffold\\Plugin\nLoading plugin Composer\\Installers\\Plugin\nLoading plugin Hirak\\Prestissimo\\Plugin\nRunning 1.6.2 (2018-01-05 15:28:41) with PHP 7.0.25 on Windows NT / 10.0\nReading ./composer.lock\n\npre-install-cmd: DrupalProject\\composer\\ScriptHandler::checkComposerVersion\nLoading composer repositories with package information\nInstalling dependencies (including require-dev) from lock file\nReading ./composer.lock\nResolving dependencies through SAT\nDependency resolution completed in 0.008 seconds\nAnalyzed 342 packages to resolve dependencies\nAnalyzed 1134 rules to resolve dependencies\nNothing to install or update\nPackage egeloen/http-adapter is abandoned, you should avoid using it. Use php-http/httplug instead.\nGenerating autoload files\n\n[ErrorException]\n  file_put_contents([project-dir]\\vendor\\bin/php-parse): failed to open stream: No such file or directory\nException trace:\n () at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer/BinaryInstaller.php:167\n Composer\\Util\\ErrorHandler::handle() at n/a:n/a\n file_put_contents() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer/BinaryInstaller.php:167\n Composer\\Installer\\BinaryInstaller->installUnixyProxyBinaries() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer/BinaryInstaller.php:146\n Composer\\Installer\\BinaryInstaller->installFullBinaries() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer/BinaryInstaller.php:86\n Composer\\Installer\\BinaryInstaller->installBinaries() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer/LibraryInstaller.php:159\n Composer\\Installer\\LibraryInstaller->ensureBinariesPresence() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer/InstallationManager.php:147\n Composer\\Installer\\InstallationManager->ensureBinariesPresence() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Installer.php:308\n Composer\\Installer->run() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Command/InstallCommand.php:119\n Composer\\Command\\InstallCommand->execute() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/vendor/symfony/console/Command/Command.php:242\n Symfony\\Component\\Console\\Command\\Command->run() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/vendor/symfony/console/Application.php:842\n Symfony\\Component\\Console\\Application->doRunCommand() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/vendor/symfony/console/Application.php:193\n Symfony\\Component\\Console\\Application->doRun() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Console/Application.php:251\n Composer\\Console\\Application->doRun() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/vendor/symfony/console/Application.php:117\n Symfony\\Component\\Console\\Application->run() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/src/Composer/Console/Application.php:100\n Composer\\Console\\Application->run() at phar://C:/Program Files (x86)/DevDesktop/tools/composer.phar/bin/composer:58\n require() at C:\\Program Files (x86)\\DevDesktop\\tools\\composer.phar:24\ninstall [--prefer-source] [--prefer-dist] [--dry-run] [--dev] [--no-dev] [--no-custom-installers] [--no-autoloader] [--no-scripts] [--no-progress] [--no-suggest] [-v|vv|vvv|--verbose] [-o|--optimize-autoloader] [-a|--classmap-authoritative] [--apcu-autoloader] [--ignore-platform-reqs] [--] [].... ",
    "Lucky-Loek": "Yeah it is!. Ah, I was wondering where it came from. Thanks!. ",
    "Kolesar": "I do not know if this is the right topic, but do not want open one more.\nI cannot find how to add a new node in any case here.\nI want to add one new use, but I do not know how :(\nI guess it is something here:\npublic function enterNode(Node $node)\n{\n   if ($node instanceof Node\\Stmt\\Use_) {\n   }\n}. ",
    "danog": "A temporary workaround could be returning the following node:\nnew Node\\Stmt\\If_(\n    new Node\\Expr\\ConstFetch(new Node\\Name('true')),\n    ['stmts' => $arrayOfStmts]\n);\nA bit ugly, but it does the job.. ",
    "BlakeMScurr": "Great, thanks for the recommendations and detailed explanation.. ",
    "ProgMiner": "Yes, this is better idea.\nI think these additional functions can be called funcUse and constUse like funcCall and constFetch. What do you think about it?. Ok, thanks.\nI did it this way already, but opened this issue to find out that there is no better way :). Oh, thanks. I don't know about this. Yes, maybe.\nI think also a special document about naming (about Name, Identifier, etc) is needed.\nThanks for answer!. By the way, my PR #516 with builders for TraitUse and TraitUseAdaptation probably can resolve trait construction troubles.. And another one question: what do you think about needing an additional feature of NameResolver for removing Use_ nodes?. Ok, maybe I can help you by sending PR?. I have added this method for adding traits after builder constructing. Maybe I have to modify or remove constructor?. ",
    "prail": "What exactly do you mean by gap? Some example code and what you would expect the tree to look like would be great.\nEDIT: From looking at BinaryOp.php it seems there is nothing set up to store spacing details.. ",
    "webmake": "Worked perfectly, thanks. ",
    "voku": "Big thanks for the help and for your work, it works pretty good (https://github.com/voku/7to5/commit/7a62d127552e34c294aa04b59816727a25f430a4) :) but now I have a different problem... \n... after converting a class from PHP7 -> PHP5 there was a different behavior in \"if\"-conditions, so I tried to fix it, with this \"hack\":\n-> https://github.com/nikic/PHP-Parser/pull/532. correct :) these \"require_once\" usages in the tests have now been removed. ",
    "phil-davis": "@borNfreee can you please edit the title of this PR to correct the name of the constant:\ns/DONT_TRAVERSER_CURRENT_AND_CHILDREN/DONT_TRAVERSE_CURRENT_AND_CHILDREN/\nThat will reduce any future confusion about the exact constant name.\nUnfortunately the mis-spelling is in the commit title also - hopefully nobody does cut-paste from there instead of reading the doc!. ",
    "sanmai": "Oh, thanks! I'll be looking towards there then.. Oh, better and better! This is all my fault! :man_facepalming:. ",
    "ankurk91": "@nikic \nAm i missing something here?. ",
    "pepakriz": "But now isAnonymous method is broken, right? https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Stmt/Class_.php#L73. ",
    "eeliu": "@nikic  thanks . It met my request, thanks a lot!. This is an inessential requirement, and looks ugly!. @nikic \nThanks  \ud83d\udc4d \nI changed the above to these\n\nCode\n\n```\n$printNode = new Node\\Stmt\\Expression($factory->methodCall(new Node\\Expr\\Variable('p'),'Before'));\n$expNode =  new Catch_([new Node\\Name(\"\\Exception\")],new Node\\Expr\\Variable(\"e\"),\n    [new Node\\Stmt\\Expression($factory->methodCall(new Node\\Expr\\Variable('p'),'Exception'))]);\n$finNode = new Finally_([new Node\\Stmt\\Expression($factory->methodCall(new Node\\Expr\\Variable('p'),'End'))]);\n```\nand got what I expected . \n. ",
    "level39": "@nikic \nPerfect. Thank you so much for your quick response.. ",
    "subabrain": "Hello and Thanks!\nsorry but i didnt get it to work ... maybe you can give an example - thanks a lot!. ok - here an example:\n```\n<?php\n$var1 = \"some_value\"; //First assigned Value\n$var2 = $var1; //The first variable ($var1) is assigned to $var2\n//...\n//Now i will echo the last Variable is assigned to the first one\necho $var2;\n//Now i want to get out the value of the first assigned variable\n//I could do this with regex but if i have the following Construct:\nclass test {\npublic $var1 = \"first\";\npublic $var2;\n\npublic function test() {\n\n    $this->var2 = $this->var1;\n\n}\n\npublic function echo_it() {\n\n    echo $this->var2;\n\n}\n\n}\n$inst = new test();\n$inst->test();\n$inst->echo_it();\n?>\n```. yes thats it \ud83d\udc4d . hey thanks a lot - but how to ge a node from the code? Thanks!. okay - i see - but i get the following error:\n\nFatal error:  Uncaught Error: Call to a member function getNodeStaticType() on null in E:\\xampp\\htdocs\\rector\\src\\Rector\\TypeAnalyzerTrait.php:76\nStack trace:\n0 E:\\xampp\\htdocs\\rector\\utils\\showcase\\src\\GetStringValueRector.php(29): Rector\\Rector\\AbstractRector->getStaticType(Object(PhpParser\\Node\\Stmt\\Expression))\n1 E:\\xampp\\htdocs\\rector\\utils\\showcase\\src\\GetStringValueRector.php(52): Rector\\Showcase\\GetStringValueRector->refactor(Object(PhpParser\\Node\\Stmt\\Expression))\n2 {main}\nthrown in E:\\xampp\\htdocs\\rector\\src\\Rector\\TypeAnalyzerTrait.php on line 76\n\nmaybe you can help me a last time - thx a lot!\n. ok - sorry ill do that ;). ",
    "zhujinxuan": "Hi, @nikic . it is almost done.  But there is still a problem, how can I get the line number of all commas in checkArray_ ?  Currently, I have no idea how to access the line number. . Hi, @nikic .  I have finished on the comment and emit error with start line.  It is ready for review now.\nA bug exists for this solution:\n[$a, [$b,,],$c] = $d;\nwill parse [$b,,] as deference_scalar_array.  I will look into php7.y to find a walkaround.\n. The reason is here:\nhttps://github.com/nikic/PHP-Parser/blob/90ee36a7fcef4f27446148b67cd2a45abe783170/grammar/php7.y#L970-L972\nFor destruction, the inner array for always considered as scalar rather than array_short_syntax. \nIs there a method to cancel some emitted error or to hook expr: array_short_list '=' expr?  Then I can lazy submit the emitted error in expr: array_short_list '=' expr.\nOr we can also hard code a set of rules of array_left and expr_left for the destructing array.. I think we shall have separate array_item_left and array_short_list_left, the following code is illegal in php but legal in current parser:\n[array($a)] = [[1]];. Cannot be fixed by adding expr_left.  kmycc consider the definition of expr_left and expr conflicting because they both have variable and '['.\nParent node information. is necessary for this problem.  @nikic  Can I know whether I can get the info of parent node by #1 or alike?\n. Cannot find a way to fix it.  Close this PR. ",
    "flip111": "@nikic maybe reflection can help for the subNodes. However the Class_ has as first argument the $name which is not part of the subNodes. Break_ has as first argument $num (number of loops to break). I see no other solution than to hand craft these things for each class in PHP-Parser. If there is another solution i'm interested to hear about it. Suppose now that each class needs it's own customized code for this type of dumper. Where should the dumper code live and how to keep it in sync with the node constructor arguments? Or is the structure of the PHP-Parser nodes already stable?. @nikic when i look here name is not part of the subNodes of class https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Stmt/Class_.php#L31-L34 I don't understand your comment that name is also a subnode. @nikic ok i can try to make this. Is PR welcome? Where should this code live?. Found a class that is irregular.. the constructor can not be created with the same name as the subNodes.\nhttps://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Name.php#L20-L29\nThere needs to be a translation from parts to name first.. I have this now .. it works for some code, but not fully tested. Maybe i can finish this and send PR ?\n```php\n<?php\nuse PhpParser\\Node as N;\nuse PhpParser\\Node\\Expr as E;\nuse PhpParser\\Node\\Scalar as SV;\n// assumes values have already been transformed into AST nodes\nfunction wrapArray($array) {\n  $wrapped = [];\n$i = 0;\n  $nonAssoc = true;\n  foreach ($array as $key => $value) {\n    if (is_array($value)) {\n      $value = wrapArray($value);\n    }\n    if (is_string($key)) {\n      $wrapped[] = new E\\ArrayItem($value, new SV\\String_($key));\n    } elseif (is_int($key)) {\n      if ($key !== $i) {\n        $nonAssoc = false;\n      }\n  // don't set an explicit key when we can use php auto indexing\n  if ($nonAssoc) {\n    $wrapped[] = new E\\ArrayItem($value);\n  } else {\n    $wrapped[] = new E\\ArrayItem($value, new SV\\LNumber($key));\n  }\n}\n\n$i++;\n\n}\nreturn new E\\Array_($wrapped);\n};\nfunction astToAstBuild($node) {\n  if (is_array($node)) {\n    array_walk($node, function(&$value, $key) { $value = astToAstBuild($value); });\n    return $node;\n  } elseif (is_object($node)) {\n    $args = array_map(function($refl_par) {\n      return [ 'name' => $refl_par->name\n                // empty array means \"no value\"\n                // filled array means \"a value\"\n             , 'default' => $refl_par->isOptional() ? [$refl_par->getDefaultValue()] : []\n             ];\n    }, (new \\ReflectionClass($node))->getConstructor()->getParameters());\n$nonConstructorParameterSubnodes = array_diff($node->getSubNodeNames(), array_column($args, 'name'));\n\nforeach ($args as $key => ['name' => $name, 'default' => $default]) {\n  if ($name === 'subNodes') {\n    $subNodes = [];\n\n    // only process array items that were listed as being a subNode\n    // but not an explicit constructor parameter\n    foreach ($nonConstructorParameterSubnodes as $k) {\n      $v = $node->{$k};\n\n      if ($k === 'stmts') {\n        if ($v !== []) {\n          $subNodes[$k] = $v;\n        }\n      } else {\n        // can put some custom rules per class here\n        if (get_class($node) === 'PhpParser\\Node\\Stmt\\Class_') {\n          if (  ($k === 'flags' && $v !== 0)\n             || ($k === 'extends' && $v !== null)\n             || ($k === 'implements' && $v !== [])\n             ) {\n            $subNodes[$k] = $v;\n          }\n        // when not specifying rules per class it can lead to more noise in the output\n        } else {\n          $subNodes[$k] = $v;\n        }\n      }\n    }\n\n    $args[$key]['value'] = $subNodes;\n  } elseif ($name === 'attributes') {\n    $args[$key]['value'] = []; // ignoring attributes for the moment\n  } elseif (($node instanceof \\PhpParser\\Node\\Name) && $name === 'name') {\n    $args[$key]['value'] = $node->toString();\n  } else {\n    $args[$key]['value'] = $node->{$name};\n  }\n\n  unset($args[$key]['name']); // don't need this information anymore\n}\n\n// find out which constructor parameters can use the default value\n$args = array_reverse($args, true);\n$can_use_default = true;\nforeach ($args as $k => $v) {\n  if (count($v['default']) === 0 || $v['value'] !== $v['default'][0]) {\n    $can_use_default = false;\n  }\n\n  $args[$k]['can_use_default'] = $can_use_default;\n  unset($args[$k]['default']); // don't need this information anymore\n}\n$args = array_reverse($args, true);\n\n$argsBuild = [];\nforeach ($args as $arg) {\n  if ($arg['can_use_default']) {\n    break;\n  }\n\n  $ret = astToAstBuild($arg['value']);\n\n  if (is_array($ret)) {\n    $ret = wrapArray($ret);\n  }\n\n  $argsBuild[] = new N\\Arg($ret);\n}\n\nreturn new E\\New_(new N\\Name(get_class($node)), $argsBuild);\n\n} elseif (is_string($node)) {\n    return new SV\\String_($node);\n  } elseif (is_int($node)) {\n    return new SV\\LNumber($node);\n  } elseif ($node === null) {\n    return new E\\ConstFetch(new Node\\Name('null'));\n  } elseif (is_float($node)) {\n    return new SV\\DNumber($node);\n  } elseif (is_bool($node)) {\n    return new E\\ConstFetch(new Node\\Name($node ? 'true' : 'false'));\n  } else {\n    printf(\"Not handled:\\n\");\n    var_dump($node);\n    die();\n  }\n}\n```. ",
    "jeroenherczeg": "Thank you @nikic, also for your opensource work!. For reference to the docs\nhttps://github.com/nikic/PHP-Parser/blob/master/doc/component/Name_resolution.markdown#the-nameresolver-visitor\n\nUnqualified function and constant names inside a namespace cannot be statically resolved. Inside a namespace Foo, a call to strlen() may either refer to the namespaced \\Foo\\strlen(), or the global \\strlen(). Because PHP-Parser does not have the necessary context to decide this, such names are left unresolved. Additionally a namespacedName attribute is added to the name node.. \n",
    "localheinz": "Thank you, @nikic!. Thank you, @nikic!. ",
    "Netmosfera": "In all these years, I never noticed that :D weird. Thanks. . ",
    "leilaes": "Hey, I want to use the offset for generating SSA in https://github.com/ircmaxell/php-cfg which uses your library :) sorry for my mistake in creating a PR. I want to see the offset in the generated SSA by php-cfg. Then, I want to find all the references to a variable including their offsets. Thank you for the suggested repo, I will have a look :). Then, I will check if all the references to a variables have been sent to a specific function as part of a bigger project :). I\u2019m working on CLQL for https://www.codelingo.io/ which is basically a language for querying AST. But we\u2019re trying to add SSA (and call graph). Basically as soon as I can generate JSON from PHP code in the below format we\u2019ll be able to plug it in to our system and make SSA queryable:\nphp source:\n<?php\n$a = \"a\";\n$b = $a;\njson output:\n{\"to\":{\"filename\":\"example.php\",\"start_offset\":16,\"end_offset\":17},\"from\":{\"filename\":\"example.php\",\"start_offset\":6,\"end_offset\":7}}\nAlthough I\u2019m slightly new, so I\u2019m not totally sure how our system works yet.\nThe system is currently closed source, but we really want to open it up in the 6-12 month time frame.\n. Thank you very much for suggesting ClangMR :) Sure, I will let you know when we make all the required changes and CLQL for the above purpose is implemented.. ",
    "vvval": "\nWhat happens if you add them before first class?\n\n@TomasVotruba \nI tried to insert the new Node\\Stmt\\Use_(...) into the nodes which I got from the parser:\nphp\n$nodes = $parser->parse($source);\n//$classNodePosition = 2;\n$useNodeBuilder = new \\PhpParser\\Builder\\Use_('Example', \\PhpParser\\Node\\Stmt\\Use_::TYPE_NORMAL);\n$before = array_slice($nodes, 0, $classNodePosition);\n$after = array_slice($nodes, $classNodePosition);\n$nodes = array_merge($before, [$useNodeBuilder->getNode()], $after);\nBut in this case, the printer failed asserting:\nassert(): assert($itemStartPos >= 0 && $itemEndPos >= 0) failed\nvendor\\nikic\\php-parser\\lib\\PhpParser\\PrettyPrinterAbstract.php:787\nvendor\\nikic\\php-parser\\lib\\PhpParser\\PrettyPrinterAbstract.php:515. ",
    "zh7314": "thanks every helpful. ",
    "fitztrev": "It seems the issue is only on PHP 7.2. Just tried on 7.3 and the warning is not there.. Had to do with PHP zend.assertions config. See rectorphp/rector#1157 for more details.. ",
    "rivetweb": "forgot <?php in parsed file. ",
    "stof": "return is not needed here\n. ",
    "francisbesset": "Fixed.\n. ",
    "cspray": "I thought about this and I decided not to. There's no strictness on adding a visitor so a visitor may theoretically be added twice. If it is then I want to make sure we get all of them.\nIf we limited the Visitor on the add side I would do so here too but we don't so I didn't :)\n. This is certainly something I don't mind adding as I thought of it myself. My only concern would be with the ability to add the same visitor twice. If you don't think that is a use case we really need to worry about then I can add the break in.\n. ",
    "RobLoach": "This is a .php file, however, so it's not needed. If this was bin/parse, then it would need it.\n. ",
    "hacfi": "You could remove the y from phpy if you commit again\n. ",
    "Taluu": "just not the concern of this lib\n. Once again, because this is not the concern of the lib to actually have an updated composer. Nothing should prevent someone with a out-of-date composer installation to install the lib. Otherwise, why limit to composer and not upgrade php and everything else ?\n. > In this case it doesn't matter if you're using composer v1.0.0-alpha1 or v1.0.0-alpha11, BC or not. It would be a different story if we were talking of a composer extension, but that's not the case here.\nYou said it yourself. It doesn't matter which version of composer is used on travis.\n. Which are ? Even looking at the requirements, the composer install is almost unecessary...\n. And also : https://docs.travis-ci.com/user/languages/php#Installing-Composer-packages\nAs it is said, it is perfectly safe to ignore this warning\n. that's as constructive as the fact that this is not the concern of this lib to have a composer up to date but whatever...\n. ",
    "hansott": "Done!. ",
    "ronfroy": "You should maybe add a line break here. ",
    "cos": "done. "
}