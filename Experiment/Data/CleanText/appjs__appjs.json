{
    "milani": "@Benvie Thank you!\n. You are right. I should change it later when Mac and Windows are supported.\n. It was a slow moving project and suddenly HN magic happened! \n. You know, it is not only about ubuntu but also all linux dists.\n. Thank you!\n. Hey!\nThank you for your nice work. Before merging we need to discuss somethings.\n- npm-debug.log is committed to the project. We don't want it.\n- You added global router settings (caseSensitive and the other option) to window settings. This is not logical. window settings are specific to an instance of window. But router settings are application-wide settings. So we should separate them.\n- Do we really need these settings?\nI didn't traced the whole patch, I add more comments later. It seems you added very nice features I was thinking about like url parameters. Before making any further change, please discuss it first in appjs-dev mailing list so we can decide what is the best thing to put our effort on:) \nThank you again for the pull request. I know you have spent a lot of your valuable time on it.\n. @michael-lawrence Request and Response objects that we use are not http compatible so routing libraries can not handle them. I try to figure out how it can be made possible.\n@Takeno We are changing the appjs API which is time consuming and during that we changed routers a lot so I will merge your changes manually after refactoring AppJS. Thank you for your nice work.\n. merged manually. thx.\n. Hey thank you:)\nWe had app.init() function which we decided to remove. and we decided to keep the API unchanged till we start working on 0.2.0.\nMy suggestion is to rename createApp to init which makes it more clear because createApp suggests that there can be two apps in the same node process by calling createApp two times. I will merge it to another branch.\n. I merge it but later I will rename disable to hideOn\n. There is something terribly wrong here in our implementation. We should not use query string as body.\n. Yes exactly. Would you please update your pull request?\n. I fixed the issue with the commit referenced here. Thanks for your attention to this issue:)\n. Patch created. I will merge later after implementing logger in C++.\n. C++ addon reads icons directly. Instead we should pass it a buffer of icon file content. This way we can read the icon from package in js side, pass the buffer to C++. I don't know if it is possible or not.\n. We don't know which file is an icon and which is not. There are icons for menu, window etc. all need special care. They don't use router, actually they can not. For example in Win32, to create an icon for a menu item, I pass file path to GDI method Gdiplus::Bitmap::FromFile and it returns a handle to Bitmap icon! We should find methods to create Bitmap icon from file content instead.\n. Thank you.\n. Thank you.\n. Thank you.\n. Thank you:) Let me merge it manually and test on other platforms.\n. @Benvie Thank you!\n. You are right. I should change it later when Mac and Windows are supported.\n. It was a slow moving project and suddenly HN magic happened! \n. You know, it is not only about ubuntu but also all linux dists.\n. Thank you!\n. Hey!\nThank you for your nice work. Before merging we need to discuss somethings.\n- npm-debug.log is committed to the project. We don't want it.\n- You added global router settings (caseSensitive and the other option) to window settings. This is not logical. window settings are specific to an instance of window. But router settings are application-wide settings. So we should separate them.\n- Do we really need these settings?\nI didn't traced the whole patch, I add more comments later. It seems you added very nice features I was thinking about like url parameters. Before making any further change, please discuss it first in appjs-dev mailing list so we can decide what is the best thing to put our effort on:) \nThank you again for the pull request. I know you have spent a lot of your valuable time on it.\n. @michael-lawrence Request and Response objects that we use are not http compatible so routing libraries can not handle them. I try to figure out how it can be made possible.\n@Takeno We are changing the appjs API which is time consuming and during that we changed routers a lot so I will merge your changes manually after refactoring AppJS. Thank you for your nice work.\n. merged manually. thx.\n. Hey thank you:)\nWe had app.init() function which we decided to remove. and we decided to keep the API unchanged till we start working on 0.2.0.\nMy suggestion is to rename createApp to init which makes it more clear because createApp suggests that there can be two apps in the same node process by calling createApp two times. I will merge it to another branch.\n. I merge it but later I will rename disable to hideOn\n. There is something terribly wrong here in our implementation. We should not use query string as body.\n. Yes exactly. Would you please update your pull request?\n. I fixed the issue with the commit referenced here. Thanks for your attention to this issue:)\n. Patch created. I will merge later after implementing logger in C++.\n. C++ addon reads icons directly. Instead we should pass it a buffer of icon file content. This way we can read the icon from package in js side, pass the buffer to C++. I don't know if it is possible or not.\n. We don't know which file is an icon and which is not. There are icons for menu, window etc. all need special care. They don't use router, actually they can not. For example in Win32, to create an icon for a menu item, I pass file path to GDI method Gdiplus::Bitmap::FromFile and it returns a handle to Bitmap icon! We should find methods to create Bitmap icon from file content instead.\n. Thank you.\n. Thank you.\n. Thank you.\n. Thank you:) Let me merge it manually and test on other platforms.\n. ",
    "naholyr": "Yep certainly, but I'm not sure other distros (especially non debianoids) will share the same name for this package, that's why ;)\n. Yep certainly, but I'm not sure other distros (especially non debianoids) will share the same name for this package, that's why ;)\n. ",
    "Takeno": "You're right! I will subscribe the appjs-dev mailing list soon.\nFor these settings, maybe we don't need them. I'm only a WebDev (no desktop) so I was thinking about router like my habit, for web server! Instead man who compose url request is the same of who build the software.\nWe will discuss the others issues in mailing list.\n. @milani Are you sure? I can clone this new appjs, write again the router and re-open a pull request; in this way you can work on other features. I wrote in the mailing-list \"Router Upgrade\" topic some days ago, if we want discuss what features of my pull request we need.\n. You're right! I will subscribe the appjs-dev mailing list soon.\nFor these settings, maybe we don't need them. I'm only a WebDev (no desktop) so I was thinking about router like my habit, for web server! Instead man who compose url request is the same of who build the software.\nWe will discuss the others issues in mailing list.\n. @milani Are you sure? I can clone this new appjs, write again the router and re-open a pull request; in this way you can work on other features. I wrote in the mailing-list \"Router Upgrade\" topic some days ago, if we want discuss what features of my pull request we need.\n. ",
    "michael-lawrence": "Would there possibly be a way to just use express as pluggable routing library? Would be great if the routing was abstracted out so we could use custom routing libraries if needed. \n. Would there possibly be a way to just use express as pluggable routing library? Would be great if the routing was abstracted out so we could use custom routing libraries if needed. \n. ",
    "ghost": "Thanks, I was getting errors from this at the tail end of the build but was too focused on other stuff to look at it. =D\n. The docs have been updated based on recent changes to the API (which also invalidates this pull request). Thanks though!\n. This part has also been updated and your pull doesn't reflect the changes.\n. Thanks!\n. I forgot to push a solution for this I came up with last night. It's in Hello World now.\n. Also this is useful for playing with keybinds: http://benvie.github.com/Keyboard/\n. I need to take a closer look at this newfangled mac package concept.\n. I want to merge this but one thing I wanted to do, if possible, was make this backwards compatible. That is: if initialize isn't called before the first createWindow, then it should be automatically run there. That way existing code doesn't need to initialize.\n. Thanks, I was getting errors from this at the tail end of the build but was too focused on other stuff to look at it. =D\n. The docs have been updated based on recent changes to the API (which also invalidates this pull request). Thanks though!\n. This part has also been updated and your pull doesn't reflect the changes.\n. Thanks!\n. I forgot to push a solution for this I came up with last night. It's in Hello World now.\n. Also this is useful for playing with keybinds: http://benvie.github.com/Keyboard/\n. I need to take a closer look at this newfangled mac package concept.\n. I want to merge this but one thing I wanted to do, if possible, was make this backwards compatible. That is: if initialize isn't called before the first createWindow, then it should be automatically run there. That way existing code doesn't need to initialize.\n. ",
    "BlessYAHU": "No problem.   I must need to clear my cache because I still don't see the One Minute Usage Overview code example in the readme or the OctoSocial example updated.\n. No problem.   I must need to clear my cache because I still don't see the One Minute Usage Overview code example in the readme or the OctoSocial example updated.\n. ",
    "DanBUK": "I will update the example to not use F keys.\n. On Mac by default one would need to use Fn+F11 to achieve 'F11' keypress. I've noticed in my testing that capturing 'normal' keys cannot be achieved using window.addEventListener('keydown') as the context is going to be one of the HTML elements that has focus.\nI may just remove the key binding from the example completely.\n. Going to re-submit pull requests properly..\n. I will update the example to not use F keys.\n. On Mac by default one would need to use Fn+F11 to achieve 'F11' keypress. I've noticed in my testing that capturing 'normal' keys cannot be achieved using window.addEventListener('keydown') as the context is going to be one of the HTML elements that has focus.\nI may just remove the key binding from the example completely.\n. Going to re-submit pull requests properly..\n. ",
    "graphnode": "Isn't F11 the usual key for fullscreen? Is this key reserved on Mac or Linux?\n. Isn't F11 the usual key for fullscreen? Is this key reserved on Mac or Linux?\n. ",
    "carlosypunto": "I think is better to use the default one. After that you may use a middleware as connect.bodyparser. \nhttps://github.com/senchalabs/connect/blob/master/lib/middleware/bodyParser.js\nI suggest:\nthis.body = request.post;\n. I think is better to use the default one. After that you may use a middleware as connect.bodyparser. \nhttps://github.com/senchalabs/connect/blob/master/lib/middleware/bodyParser.js\nI suggest:\nthis.body = request.post;\n. ",
    "sihorton": "I have done a lot of debugging on the 0.20 version and it seems to be some form of path issue. This should mean I can create a workaround.\n. The problem was caused by reading the icons, since I have packaged the applications appjs cannot read the applications directly from the disk. I have created a workaround for now that reads the icons from the appjs install directory instead. I will cancel this pull request, re-apply my changes and submit again.\n. We could also just extract the icons to a temporary folder and read them from there for now. Buffer would be a better long term solution though. I use a router so ideally appjs could make a \"request\" for the file and use the result of that to pass icon to C++.\n. I understand. We could have a directory called \"icons\" or similar in the package, then the appjs-package module can detect those files and extract them or ideally read them into memory and make the main appjs package aware of the resources something like app.addResource(name, Stream)  and then behind the scenes the module can do what is needed for the various platforms. It is probably going to be a bit messy to get it working well, but we can use workarounds for now.\n. I have implemented a fix for this problem. The app.js code should call a method app.prepareIcons(['content/icons/32.png'],function(err, iconList) {\n     var statusIcon = app.createStatusIcon({\n          icon:iconList['content/icons/32.png'],\n          tooltip:'AppJS Hello World',\n          menu:trayMenu\n        });\n});\niconList is a hashmap that returns the full path to a file so you can pass that into the c++ code. Internally when running packages appjs extracts the icons to a cache directory and uses a sha1 to name the file (to avoid duplicates). So when running inside a package file you would have to explicitly call the prepareIcons function. We can just add that function call to all of the examples on the website and the documentation and it should not cause any problems.\n. I have made further improvements to the packaging system which can land in a later pull request. I now transparently deflate / inflate with gzip for network transmission of the module files.\n. I have done 2 full rewrites of the packaging functionality after submitting this patch so the overall design has improved a large amount. My npm modules are more up to date and I will be releasing the next generation very soon. Sorry for the long comment but I have discussed these issues back and forward with various people. Here is my thinking:-\nThe out-of-the-box appjs package format is going to be open, you will be able to view the contents of the package in a hex editor, and since the project is open source whatever \"magic\" is used will be open for anyone to view on github and figure out how it works. It is relatively simple to take the code I have written and add a layer of encryption and decryption or public / private keys. That would be as secure as the algorithms that are used (openssl). The problem is that you will need to ask for the private key or password to unlock the contents of the package and if that is happening on the end users machine in an open source project then you are not going to be able to hide what you are doing. If you want for example to save all of your passwords into a file, encrypt it and then save it to disk. Then you can use the crypto module for nodejs and that will work reasonably well. The user would then need to enter in a password to unlock the data. Likewise if you want code signing with a private key and then verification using a public key of the person that signed the code then that is also possible with the nodejs crypto libraries.\nI have been asked similar questions by a number of other developers when they heard about the package format. What they want is to take an appjs application, package it up and then run it on the end users machine without it being \"open on the disk\" as it is now. So for example you write visual basic or delphi applications and then the compiler puts out an executable file that does not have all of the source code attached like appjs has. The problem with trying to do this with javascript is that javascript is highly dynamic and therefore if you take a function and call function.toString() then you will get the source code back of that function.\nSo if you want to develop a solution yourself then the answer is basically to write parts or all of the application as C or C++ node_modules. These can be installed alongside your application and can then hold logic in them that is not open like javascript. Obviously the downside of that is that it is generally many times slower to develop in C and that is why appjs is being used.\nIf your aim is to defeat the crackers that are able to crack microsoft office and windows -- products made by a billion dollar company then that is very difficult to ever achieve. Also delphi and visual basic application can be reverse engineered and their source code returned to a certain degree. The same is possible with java and C programs if you search long enough and put in enough effort.\nHaving said all of that I am still an engineer and generally like a challenge so have tried thinking through the problem and built a couple of prototypes. What I was able to do is create a modified nodejs binary that is able to run \"scrambled\" packages. Basically security by obscurity. Then by not releasing the source code of the modified version and not releasing the source code of the packager but only supplying binaries you put up a wall that will mean someone will need to poke around and try to figure out what you are doing in order to get back the source code. Hopefully that is enough that you have a more \"commercial\" package that does not leave all of the code on disk so it is more possible to sell. Obviously if a large amount of resources /expertise are expended to get the code then eventually it will break, but at the same time the same amount of resources / expertise could just develop an app better than the one you are developing so it is a zero sum game.\nI have had a number of conversations with people and this represents my latest thinking. What do you think? Is there an \"open\" way to hide the source code? Anything I am missing. Obviously if you want to discuss details then best to do it over chat or private messages rather than on github :-) Lots of people have asked me about it though so good that I write a full answer here!\n. It is possible to include your own modules into the nodejs build process. Doing this causes javascript modules to be compiled to machine code and then included in the binary. Doing the classic .toString() javascript function then returns:\n[Native Code]\nSo the build process has \"lost\" the original javascript source code and it is no longer available. By including your own code into the binary then you can call that from a script that you are running to do decryption. This works exactly the same as the built in nodejs modules, you just add your own module.\nUsing such a native code function you could then read in files and decrypt them or you could take core / key algorithms and place them directly in the binary. This represents quite a good way to go about packaging what would otherwise be open source files.\nIt still relies on security by obscurity.\n. Maybe you are looking for something like: https://github.com/crcn/nexe \"create a single executable out of your node.js apps\". \n. can you accept this pull request -- it updates the documentation to make building on windows much easier, and fixes simple build errors. Once that is done Ashish wants to add further updates to document all of the fixes to problems that came up for him. It would make it much easier for new people to checkout the code and get it building on windows.\n. On windows we have an issue that if we launch the application using node.exe then it will open a terminal window, this is fine for developers but very scary for end users. The only way to get rid of the terminal is to launch node from a windows executable. The current code works ok if you have everything in a single app directory, but if you want to install appjs \"once\" and then have it handle each app the launcher does not work. This is a step in that direction. I want deskshell to be able to run individual apps or installed globally to handle all .desk apps.\n. I have done a lot of debugging on the 0.20 version and it seems to be some form of path issue. This should mean I can create a workaround.\n. The problem was caused by reading the icons, since I have packaged the applications appjs cannot read the applications directly from the disk. I have created a workaround for now that reads the icons from the appjs install directory instead. I will cancel this pull request, re-apply my changes and submit again.\n. We could also just extract the icons to a temporary folder and read them from there for now. Buffer would be a better long term solution though. I use a router so ideally appjs could make a \"request\" for the file and use the result of that to pass icon to C++.\n. I understand. We could have a directory called \"icons\" or similar in the package, then the appjs-package module can detect those files and extract them or ideally read them into memory and make the main appjs package aware of the resources something like app.addResource(name, Stream)  and then behind the scenes the module can do what is needed for the various platforms. It is probably going to be a bit messy to get it working well, but we can use workarounds for now.\n. I have implemented a fix for this problem. The app.js code should call a method app.prepareIcons(['content/icons/32.png'],function(err, iconList) {\n     var statusIcon = app.createStatusIcon({\n          icon:iconList['content/icons/32.png'],\n          tooltip:'AppJS Hello World',\n          menu:trayMenu\n        });\n});\niconList is a hashmap that returns the full path to a file so you can pass that into the c++ code. Internally when running packages appjs extracts the icons to a cache directory and uses a sha1 to name the file (to avoid duplicates). So when running inside a package file you would have to explicitly call the prepareIcons function. We can just add that function call to all of the examples on the website and the documentation and it should not cause any problems.\n. I have made further improvements to the packaging system which can land in a later pull request. I now transparently deflate / inflate with gzip for network transmission of the module files.\n. I have done 2 full rewrites of the packaging functionality after submitting this patch so the overall design has improved a large amount. My npm modules are more up to date and I will be releasing the next generation very soon. Sorry for the long comment but I have discussed these issues back and forward with various people. Here is my thinking:-\nThe out-of-the-box appjs package format is going to be open, you will be able to view the contents of the package in a hex editor, and since the project is open source whatever \"magic\" is used will be open for anyone to view on github and figure out how it works. It is relatively simple to take the code I have written and add a layer of encryption and decryption or public / private keys. That would be as secure as the algorithms that are used (openssl). The problem is that you will need to ask for the private key or password to unlock the contents of the package and if that is happening on the end users machine in an open source project then you are not going to be able to hide what you are doing. If you want for example to save all of your passwords into a file, encrypt it and then save it to disk. Then you can use the crypto module for nodejs and that will work reasonably well. The user would then need to enter in a password to unlock the data. Likewise if you want code signing with a private key and then verification using a public key of the person that signed the code then that is also possible with the nodejs crypto libraries.\nI have been asked similar questions by a number of other developers when they heard about the package format. What they want is to take an appjs application, package it up and then run it on the end users machine without it being \"open on the disk\" as it is now. So for example you write visual basic or delphi applications and then the compiler puts out an executable file that does not have all of the source code attached like appjs has. The problem with trying to do this with javascript is that javascript is highly dynamic and therefore if you take a function and call function.toString() then you will get the source code back of that function.\nSo if you want to develop a solution yourself then the answer is basically to write parts or all of the application as C or C++ node_modules. These can be installed alongside your application and can then hold logic in them that is not open like javascript. Obviously the downside of that is that it is generally many times slower to develop in C and that is why appjs is being used.\nIf your aim is to defeat the crackers that are able to crack microsoft office and windows -- products made by a billion dollar company then that is very difficult to ever achieve. Also delphi and visual basic application can be reverse engineered and their source code returned to a certain degree. The same is possible with java and C programs if you search long enough and put in enough effort.\nHaving said all of that I am still an engineer and generally like a challenge so have tried thinking through the problem and built a couple of prototypes. What I was able to do is create a modified nodejs binary that is able to run \"scrambled\" packages. Basically security by obscurity. Then by not releasing the source code of the modified version and not releasing the source code of the packager but only supplying binaries you put up a wall that will mean someone will need to poke around and try to figure out what you are doing in order to get back the source code. Hopefully that is enough that you have a more \"commercial\" package that does not leave all of the code on disk so it is more possible to sell. Obviously if a large amount of resources /expertise are expended to get the code then eventually it will break, but at the same time the same amount of resources / expertise could just develop an app better than the one you are developing so it is a zero sum game.\nI have had a number of conversations with people and this represents my latest thinking. What do you think? Is there an \"open\" way to hide the source code? Anything I am missing. Obviously if you want to discuss details then best to do it over chat or private messages rather than on github :-) Lots of people have asked me about it though so good that I write a full answer here!\n. It is possible to include your own modules into the nodejs build process. Doing this causes javascript modules to be compiled to machine code and then included in the binary. Doing the classic .toString() javascript function then returns:\n[Native Code]\nSo the build process has \"lost\" the original javascript source code and it is no longer available. By including your own code into the binary then you can call that from a script that you are running to do decryption. This works exactly the same as the built in nodejs modules, you just add your own module.\nUsing such a native code function you could then read in files and decrypt them or you could take core / key algorithms and place them directly in the binary. This represents quite a good way to go about packaging what would otherwise be open source files.\nIt still relies on security by obscurity.\n. Maybe you are looking for something like: https://github.com/crcn/nexe \"create a single executable out of your node.js apps\". \n. can you accept this pull request -- it updates the documentation to make building on windows much easier, and fixes simple build errors. Once that is done Ashish wants to add further updates to document all of the fixes to problems that came up for him. It would make it much easier for new people to checkout the code and get it building on windows.\n. On windows we have an issue that if we launch the application using node.exe then it will open a terminal window, this is fine for developers but very scary for end users. The only way to get rid of the terminal is to launch node from a windows executable. The current code works ok if you have everything in a single app directory, but if you want to install appjs \"once\" and then have it handle each app the launcher does not work. This is a step in that direction. I want deskshell to be able to run individual apps or installed globally to handle all .desk apps.\n. ",
    "MisterRichardson": "Sihorton,\nI haven't started studying on your packaging solution, could you comment how could one try to hide part of the code in a encrypted manner that can only be accessed when the correct key is applied?\nI want to hide functionality of the application that should only be available with the correct authentication, and of course don't want a cracker to easily find out how I'm doing it.\nAny pointer on the subject will be helpful.\nThank you.\n. Sihorton,\nI haven't started studying on your packaging solution, could you comment how could one try to hide part of the code in a encrypted manner that can only be accessed when the correct key is applied?\nI want to hide functionality of the application that should only be available with the correct authentication, and of course don't want a cracker to easily find out how I'm doing it.\nAny pointer on the subject will be helpful.\nThank you.\n. ",
    "juzerali": "In the past I have also tried searching for a way to create nodejs binaries. Nodejs team believes it is possible but they won't delve into that. I searched a little more but found nothing. I have given up now.\n:100: for Basically security by obscurity , I have seen Java and even C++ getting decompiled to an extent that the program can be reproduced after putting in a decent amount of effort.\n. Yes, I am aware of packaging native modules in nodejs. What I meant by nodejs binaries was to obscure the javascript code itself, which, by far, I haven't seen.\n. In the past I have also tried searching for a way to create nodejs binaries. Nodejs team believes it is possible but they won't delve into that. I searched a little more but found nothing. I have given up now.\n:100: for Basically security by obscurity , I have seen Java and even C++ getting decompiled to an extent that the program can be reproduced after putting in a decent amount of effort.\n. Yes, I am aware of packaging native modules in nodejs. What I meant by nodejs binaries was to obscure the javascript code itself, which, by far, I haven't seen.\n. ",
    "YurySolovyov": "v8 snapshot?\n. v8 snapshot?\n. ",
    "neatcode": "I think the simplest way to protect the Javascript source code of a desktop application is to do the same thing we do for internet-based Javascript applications (front ends): minify the source before distributing the application, regardless of how it's packaged. Even better if you can minify the libraries your application uses with / at the same time as you minify your application's main source files. Most function names and variables will appear, after minification, like: b3(a4,g8,j8), var b8, var d9 = i77, ca32(), a5 = z2(a4,g8). This will make your source code largely useless EVEN IF the \"attacker\" recovers your source code and gets it to compile into a working application. Making modifications becomes much more difficult (I've tried this with internet-based Javascript front-ends that have been minified), to the point it's almost useless except for the most basic of modifications. It would usually be simpler to rewrite the whole program from scratch in order to make modifications and resell it, than to modify an existing \"minified\" one from the minified source to try to make a new product and sell it.\nIf you want a hacker-proof program beyond that, however, whether using Javascript or c++ or anything, your best bet is to make key functionality of your program only accessible over the internet and keep your (probably best minified) source for that key functionality exclusively on your own server. The app would function as a normal desktop app except for when certain key functionality is needed, then it would query your server online for the calculation. For example, Microsoft Word could make it so that whenever a table is created or resized or edited, the source that describes how to modify the table could be on Microsoft's server, and Microsoft Word would have to make a round-trip to the server to get the data for how to update the table. When the server is contacted, the software would, for example, send its Serial Number for verification alongside its data to be modified. Serial Numbers that are invalid or reused would be rejected, and the table would not successfully update, though other parts of the program may continue to work.\nThis last method is nearly fool-proof if you can guarantee the security of the server. One important thing to note is that it is key that the algorithm for producing Serial Numbers for your application is highly secure and can't be guessed or derived. In fact, I'd generate them from a \"true\" random number generating source such as a quantum random number generator, and keep a record of the ones you've produced for distribution on a server and make sure they're well guarded.\nStill, I highly recommend minifying the source code for Node.js desktop apps. This should be adequate even for enterprise-level software.\n. I think the simplest way to protect the Javascript source code of a desktop application is to do the same thing we do for internet-based Javascript applications (front ends): minify the source before distributing the application, regardless of how it's packaged. Even better if you can minify the libraries your application uses with / at the same time as you minify your application's main source files. Most function names and variables will appear, after minification, like: b3(a4,g8,j8), var b8, var d9 = i77, ca32(), a5 = z2(a4,g8). This will make your source code largely useless EVEN IF the \"attacker\" recovers your source code and gets it to compile into a working application. Making modifications becomes much more difficult (I've tried this with internet-based Javascript front-ends that have been minified), to the point it's almost useless except for the most basic of modifications. It would usually be simpler to rewrite the whole program from scratch in order to make modifications and resell it, than to modify an existing \"minified\" one from the minified source to try to make a new product and sell it.\nIf you want a hacker-proof program beyond that, however, whether using Javascript or c++ or anything, your best bet is to make key functionality of your program only accessible over the internet and keep your (probably best minified) source for that key functionality exclusively on your own server. The app would function as a normal desktop app except for when certain key functionality is needed, then it would query your server online for the calculation. For example, Microsoft Word could make it so that whenever a table is created or resized or edited, the source that describes how to modify the table could be on Microsoft's server, and Microsoft Word would have to make a round-trip to the server to get the data for how to update the table. When the server is contacted, the software would, for example, send its Serial Number for verification alongside its data to be modified. Serial Numbers that are invalid or reused would be rejected, and the table would not successfully update, though other parts of the program may continue to work.\nThis last method is nearly fool-proof if you can guarantee the security of the server. One important thing to note is that it is key that the algorithm for producing Serial Numbers for your application is highly secure and can't be guessed or derived. In fact, I'd generate them from a \"true\" random number generating source such as a quantum random number generator, and keep a record of the ones you've produced for distribution on a server and make sure they're well guarded.\nStill, I highly recommend minifying the source code for Node.js desktop apps. This should be adequate even for enterprise-level software.\n. ",
    "matthewkastor": "This pull request addresses issues brought up in https://github.com/appjs/appjs/issues/310\n. This pull request addresses issues brought up in https://github.com/appjs/appjs/issues/310\n. ",
    "joemccann": "cheers\n. cheers\n. ",
    "ashishnegi": "That would be right way. If this would test right, i would also do it for the rest of other functions like V8StringToWchar . \n. Yaa. he had talked about looking into it on local machine.\n. any progress on this Ingwie.\n. Closing PR as no response for long time.\n. That would be right way. If this would test right, i would also do it for the rest of other functions like V8StringToWchar . \n. Yaa. he had talked about looking into it on local machine.\n. any progress on this Ingwie.\n. Closing PR as no response for long time.\n. ",
    "IngwiePhoenix": "Is this still current? If so, I'd merge it if possible - or needed. I belive @milani hasn't merged it yet.\n. Altight, looks like thats my job now, as I own appjs now. Or more, i am the head maintainer. :) Let\u2019s see how that\u2019ll behave! ^^\nAm 23.12.2013 um 13:00 schrieb ASHISH NEGI notifications@github.com:\n\nYaa. he had talked about looking into it on local machine.\n\u2014\nReply to this email directly or view it on GitHub.\n. A fix drag0n is using since forever xD. But good that its issued to the actual repo...I think this is actualy better than relying on relative paths and alike.\nAm 24.09.2013 um 14:45 schrieb sihorton notifications@github.com:\nFor appjs platform I want the launcher in a different folder to the application, this fix uses the absolute path to nodejs meaning that it does not change the current working directory to the launcher exe. This may affect how node finds the node_modules directory (it may read from the application folder first after this change). This will not affect \"normal\" appjs apps since the current folder will always be the application folder anyway.\nYou can merge this Pull Request by running\ngit pull https://github.com/sihorton/appjs master\nOr view, comment on, or merge it at:\nhttps://github.com/appjs/appjs/pull/395\nCommit Summary\nFix for launcher to use absolute path to node.exe when launching appjs.\nFix for launcher to use absolute path to node.exe this fixes issue where launching an app changes the current working directory.\nMerge branch 'master' of http://github.com/sihorton/appjs\nFile Changes\nM data/win/launch/launch.cpp (24)\nM data/win/launch/launch.rc (0)\nPatch Links:\nhttps://github.com/appjs/appjs/pull/395.patch\nhttps://github.com/appjs/appjs/pull/395.diff\n. I have zero access to the actual htdocs so i can not really make the change appear. :< Sorry. I will pull it in, though.\nAm 04.12.2014 um 15:40 schrieb James Costian notifications@github.com:\nLooking at (appjs.com)[http://appjs.com/ http://appjs.com/], it's almost impossible to tell that this project is deprecated. This pull request will make it obvious, and it will also point users towards deskshell.\nYou can merge this Pull Request by running\ngit pull https://github.com/jamescostian/appjs patch-1\nOr view, comment on, or merge it at:\nhttps://github.com/appjs/appjs/pull/420 https://github.com/appjs/appjs/pull/420\nCommit Summary\nAdd deprecation notice to the front page\nFile Changes\nM index.html https://github.com/appjs/appjs/pull/420/files#diff-0 (4)\nPatch Links:\nhttps://github.com/appjs/appjs/pull/420.patch https://github.com/appjs/appjs/pull/420.patch\nhttps://github.com/appjs/appjs/pull/420.diff https://github.com/appjs/appjs/pull/420.diff\n\u2014\nReply to this email directly or view it on GitHub https://github.com/appjs/appjs/pull/420.\n. Is this still current? If so, I'd merge it if possible - or needed. I belive @milani hasn't merged it yet.\n. Altight, looks like thats my job now, as I own appjs now. Or more, i am the head maintainer. :) Let\u2019s see how that\u2019ll behave! ^^\nAm 23.12.2013 um 13:00 schrieb ASHISH NEGI notifications@github.com:\nYaa. he had talked about looking into it on local machine.\n\u2014\nReply to this email directly or view it on GitHub.\n. A fix drag0n is using since forever xD. But good that its issued to the actual repo...I think this is actualy better than relying on relative paths and alike.\nAm 24.09.2013 um 14:45 schrieb sihorton notifications@github.com:\nFor appjs platform I want the launcher in a different folder to the application, this fix uses the absolute path to nodejs meaning that it does not change the current working directory to the launcher exe. This may affect how node finds the node_modules directory (it may read from the application folder first after this change). This will not affect \"normal\" appjs apps since the current folder will always be the application folder anyway.\nYou can merge this Pull Request by running\ngit pull https://github.com/sihorton/appjs master\nOr view, comment on, or merge it at:\nhttps://github.com/appjs/appjs/pull/395\nCommit Summary\nFix for launcher to use absolute path to node.exe when launching appjs.\nFix for launcher to use absolute path to node.exe this fixes issue where launching an app changes the current working directory.\nMerge branch 'master' of http://github.com/sihorton/appjs\nFile Changes\nM data/win/launch/launch.cpp (24)\nM data/win/launch/launch.rc (0)\nPatch Links:\nhttps://github.com/appjs/appjs/pull/395.patch\nhttps://github.com/appjs/appjs/pull/395.diff\n. I have zero access to the actual htdocs so i can not really make the change appear. :< Sorry. I will pull it in, though.\nAm 04.12.2014 um 15:40 schrieb James Costian notifications@github.com:\nLooking at (appjs.com)[http://appjs.com/ http://appjs.com/], it's almost impossible to tell that this project is deprecated. This pull request will make it obvious, and it will also point users towards deskshell.\nYou can merge this Pull Request by running\ngit pull https://github.com/jamescostian/appjs patch-1\nOr view, comment on, or merge it at:\nhttps://github.com/appjs/appjs/pull/420 https://github.com/appjs/appjs/pull/420\nCommit Summary\nAdd deprecation notice to the front page\nFile Changes\nM index.html https://github.com/appjs/appjs/pull/420/files#diff-0 (4)\nPatch Links:\nhttps://github.com/appjs/appjs/pull/420.patch https://github.com/appjs/appjs/pull/420.patch\nhttps://github.com/appjs/appjs/pull/420.diff https://github.com/appjs/appjs/pull/420.diff\n\u2014\nReply to this email directly or view it on GitHub https://github.com/appjs/appjs/pull/420.\n. \n",
    "michalliu": "Hi, The website is hosted here, you can send a pull request to me, i'd like take a review and update the website.\n. Deprecation notice added\n. Hi, The website is hosted here, you can send a pull request to me, i'd like take a review and update the website.\n. Deprecation notice added\n. ",
    "Klortho": "Okay, thanks. New PR is here: https://github.com/appjs/appjs/pull/424\n. You can see what this looks like here: http://klortho.github.io/appjs/\n. Okay, thanks. New PR is here: https://github.com/appjs/appjs/pull/424\n. You can see what this looks like here: http://klortho.github.io/appjs/\n. "
}