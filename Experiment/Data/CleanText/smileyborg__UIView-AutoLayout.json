{
    "smileyborg": "Do you have some sample code or examples for Parus? Would be great to read through that instead of the API alone.\nAs far as combining the work of Auto Layout libraries, I think they're different enough to warrant different internals. This is because each project has different design goals and a different approach to the problem. Certainly, if there are specific things from one library missing in another, it's great to leverage the existing work and expose it in the other project (perhaps in that project's own way of doing things).\n. Hey David - just skimmed your diffs, this is awesome work. It looks like you did an excellent job. Let me review the changes more closely and make sure it's set to go.\nOriginally, I wrote this category to simplify things and decided that leading and trailing were going to be the same as left and right for the vast majority of folks (and as such, it would be better to omit them for simplicity). I did build things so that it would be fairly simple to add them in later on (as you have done), and I'm pretty sure I agree that this is the right way to go for the long term.\n. That looks correct and it should work fine (as long as the width of the containing thisWeekView is wide enough to allow each label some width that is >0.\nCan you copy paste the entire exception from the debug console?\n. Ah, got it working then?\n. No worries :) Auto Layout can be quite difficult & frustrating, even with a nice interface like this haha.\nLet me know if you run into any other issues! Good luck!\n. I just tested on my machine and it's working fine.\npod 'UIView+AutoLayout'\nwill install this project.\npod 'UIView-Autolayout'\nwill install @jrturton's project.\nNote the difference in the +/- and capitalization of the L.\n. Tyler Fox would be me :) Let me re-word it and include you by name to clarify!\n. Correct. I updated the Credits section -- hopefully more clear now!\n. So, this project is already listed on the official CocoaPods repository with a unique name: UIView+AutoLayout\nSee this previous discussion about the same thing: https://github.com/smileyborg/UIView-AutoLayout/issues/4\n. Closing this PR for the following reasons: podspec already exists in CocoaPods/Specs; Example app already links to the source files in the repo; no compelling reason to modify Readme; no name conflict exists.\n. I definitely see where the confusion comes from. But think about it this way: you're not calling a method autoCenterHorizontallyInSuperview, you're calling autoCenterInSuperviewAlongAxis:, and assuming you pass ALAxisVertical, then you're asking to line up the subview and its superview's vertical axes (which effectively centers the subview horizontally). Check out the simple diagram I threw together below for a visual.\nYou certainly have to read the method names carefully to really clarify the difference. But doing it this way is consistent with the other methods that act on axes, and once you understand this approach I think it's very straightforward to work with.\nIn any case, I do not wish to flip the CenterX and CenterY attributes. If you believe that this is still confusing, I'd be open to other suggestions to enhance the clarity of the API.\n\n. Constraints that you set up using UIView+AutoLayout are identical to constraints you might set up using VFL or by calling the NSLayoutConstraint API directly.\nThat means you animate constraint changes (after making the changes to the constraints) by calling [view layoutIfNeeded] from an animation block.\nThere's plenty more info on this topic here: http://stackoverflow.com/questions/12926566/are-nslayoutconstraints-animatable\nNow, if you're asking how to change multiple constraints but only animate one of them (applying the other changes immediately), that's actually something I haven't tried myself. What I would suggest is this:\n```\n// First, make all of your constraint changes that you don't want to animate here\n[view layoutIfNeeded]; // this will instantly apply the above changes\n// Now, make the change to the one constraint you wish to animate\n[UIView animateWithDuration:0.2 animations:^{ \n    [view layoutIfNeeded]; // this will animate the one constraint\n}];\n```\nLet me know if that works for you.\n. Oh, now I see what you're asking :)\nThe answer is incredibly simple: each of the UIView+AutoLayout API methods that creates constraints has a return value. All these methods will create the constraints, add them to the appropriate view, and then return the constraint (or if there are multiple, an NSArray of constraints) to you.\nSo, in your case, all you need to do is:\nNSLayoutConstraint *constraint = [self.savePopupView autoPinEdgeToSuperviewEdge:ALEdgeTop withInset:100.0];\nYou can of course assign that to a property instead, or whatever you like!\n. By missing, I assume you mean not visible?\nAny subview of UIView should work with this API unless it implements specific behavior that makes it generally incompatible with Auto Layout. (Now, UIScrollView, which UITextView inherits from, does have some important considerations to use with Auto Layout -- but that's when positioning/constraining subviews within the scroll view, not positioning the scroll view itself.)\nCan you perhaps share a fork of the example project on GitHub so I can see what you are trying that doesn't work?\n. I'm not sure I fully understand the use case for this here.\nThe new code looks good. However, it doesn't look to be substantially different than the other existing API methods which the methods call internally. Even if this use case is generally applicable to more people, it looks like we're only saving 1 line of code here for each API call.\nThis is the hardest part about designing an API like this: deciding when to draw the line between increasing the complexity/size of the API with new methods, and keeping it simple at the cost of some reduced functionality. For these particular methods, I'm leaning towards the latter.\nWhat do you think?\n. Have you had any thoughts on this? (I've been busy recently and haven't had much time to work on anything myself...)\nThe one thing that did come to mind is that this might make a really nice category of its own. Think of it as extensions to these helper methods, almost like a category on the category. This way, it would be completely independent so people who want to have additional API methods (perhaps with more raw power, etc) can just import the extra header for this new category, which internally wraps some calls to the existing API of this UIView+AutoLayout category. But for people who don't need or aren't doing these sort of things can stick with the basic core methods alone.\nWhat do you think?\n. I don't think copy-pasting some of the internal methods is that terrible if the idea is that this new category/pod would be used instead of the UIView+AutoLayout one, but I agree if both will exist it's not so great.\nWhat I would recommend is that we refactor the current project a bit so that all of the internal private methods (prefixed by al_) are exposed in a separate header file. So what that would look like:\nPublic API\n```\n// UIView+AutoLayout.h\n@interface UIView (AutoLayout)\n\n(NSArray *)autoCenterInSuperview;\n\n// ...etc\n@end \n```\nPrivate internal methods\n```\n// UIView+AutoLayoutInternal.h\n@interface UIView (AutoLayoutInternal)\n\n(UIView *)al_commonSuperviewOfViews;\n\n// ...etc\n@end \n```\nIf done this way, you could then #import UIView+AutoLayoutInternal.h at the top of your category and gain access to all the private methods. Regular users would continue to just #import UIView+AutoLayout.h which would only expose the public API methods.\nHow's that sound?\n. The internal methods would not be made public, they would just be available to import into other .m files (such as yours that are effectively extensions on the category).\nSince users would never import this private header, they would continue to not see these private methods at all.\nThis is the same design pattern recommended in Objective-C when you have a superclass with private methods that you only want to expose to subclasses.\n. No rush. Do you want to take a stab at refactoring this or would you like me to work on it when I get some time?\n. @caoimghgin I've been working on unit tests for this library recently, and I actually had a need to do effectively what we were discussing here. Take a look at the UIView+AutoLayoutInternal.h file.\nYou can probably take this file and more or less move it into the main repo source to accomplish what we were talking about. Let's just make sure to also add some more comments at the top warning regular users not to import this header of private/internal methods, since it will now be included in the source files they download.\n. Yes, CocoaPods definitely supports dependencies like this (haven't used them myself though). The idea is that UIView+AutoLayoutInternal.h would be part of this UIView+AutoLayout pod though, to allow other downstream libraries like yours to work on top of it, and to facilitate the unit tests as it currently does. That's why we need some big warnings to users not to import that header.\n. OK. I'm planning on waiting to release the next version until after the unit test suite is complete with near 100% code coverage. I'm trying to tackle a chunk each day, so hopefully it will be done within a week or so. If you want to work on any of this stuff sooner, just use the existing UIView+AutoLayoutInternal.h file locally alongside the current pod.\n. Sorry this took so long to follow up on! But great news:\n1. UIView+AutoLayout is now deprecated, because there's a brand new replacement: PureLayout! The main enhancement that PureLayout adds is full OS X support, with almost the entire codebase shared.\n2. As part of PureLayout, I've exposed the private internal methods in a header file that is included with the Cocoapod source (PureLayout+Internal.h). That means that you (and anyone else) who wants to build a dependent library can do so knowing that all the internal methods and functionality is available.\nLet me know what you think!\n. Interesting, can you share your use case for frequently needing to grab references to these constraints?\nThe \"bulk\" methods which create multiple constraints return arrays (in fact, these arrays are really more like sets, since the constraints are not ordered) because the expectation is that you may just want to remove all those constraints in one shot later on. If you need a reference to a specific constraint (such as to change its constant value), the expectation is that you wouldn't use these \"bulk\" methods which create multiple constraints (and return an NSArray).\nIn the numerous Auto Layout implementations I have come across so far, I have found that it's fairly rare to need to hold a reference to a specific constraint, and therefore it's reasonable to have to create/add these specific constraints one at a time.\nFor example, instead of using:\nNSArray *constraints = [view autoPinEdgesToSuperviewEdgesWithInsets:UIEdgeInsetsMake(10, 10, 10, 10)];\nyou would do the following if you needed to just hold a reference to the top edge constraint tweak the constant later on:\nNSLayoutConstraint *constraint = [view autoPinEdgeToSuperviewEdge:ALEdgeTop withInset:10];\n[view autoPinEdgeToSuperviewEdge:ALEdgeLeft withInset:10];\n[view autoPinEdgeToSuperviewEdge:ALEdgeBottom withInset:10];\n[view autoPinEdgeToSuperviewEdge:ALEdgeRight withInset:10];\nNow, returning a dictionary isn't unreasonable, but consider some of the more complex methods in the category that currently return an array of constraints. For the example you give, it's pretty simple because we're dealing with one view and its superview. But other methods involve arbitrary numbers of views, for example. What would the key be for each constraint? (Note that using the first attribute of the constraint isn't reliable -- constraints can be expressed \"backwards\" with the attributes flipped and work identically...this is effectively an implementation detail. It's also not scalable for multiple views, etc.)\nSo anyways, I'm curious about your use case that requires frequently access to individual constraints from within these arrays. If this is a valid and common use case, perhaps there's another way we can solve it.\n. Got it, thanks for the explanation. It sounds like even for you this is a somewhat infrequent use case. Designing complete API like this is somewhat of a balancing act between making sure it works well for most use cases, and keeping it as slim as possible. It's always easy to get caught up adding new things and before you know it, you have a bloated interface that is more complicated than it should be.\nFor the sake of not introducing a whole new set of methods with different return types, or making any breaking changes to the existing API, I'd rather leave things as they currently are. For now, I think this sort of thing falls into what I consider the \"client's burden\" -- you can definitely feel free to create your own category that adds some additional helpers/extensions, which could even wrap calls to the UIView+AutoLayout category and do whatever additional work is needed to keep your client code clean.\nAnyways, thanks for bringing this up -- always happy to hear about potential improvements and new use cases!\n. I see exactly what you're talking about. The pull request/code looks solid.\nA couple questions:\n- What about the other variant which uses a fixed size for each of the views, wouldn't this also apply to that? (The math on that one is trickier and may not be self explanatory, btw.)\n- Perhaps instead of exposing specific values for leading/trailing spacing, we just add an optional parameter that is a BOOL, which if YES includes the spacing before & after, but if NO the leading/trailing spacing is zero? In other words, is there really any reason to have to pass 3 different CGFloat values, since it seems there are only 2 probable uses?\ne.g. something like:\n(NSArray *)autoDistributeViewsAlongAxis:(ALAxis)axis withFixedSpacing:(CGFloat)spacing insetSpacing:(BOOL)shouldSpaceInsets alignment:(NSLayoutFormatOptions)alignment;\n. I can take a stab at this when I get some spare time (probably this weekend), it's probably more difficult to explain the math behind that other method without being in person :P\nAs far as what to expose, this comes back to the core design philosophy behind the API. The goal is not to solve everything, but instead to solve most things very well, with as thin & simple of a front end as possible.\nFor this specific case, given that you must already have a container view to distribute these subviews within, I'm going to say that it's therefore very easy to adjust the leading and trailing (or top & bottom) spacing to the first/last views by positioning the superview (assuming we're passing zero into the method you exposed). As a result, I would argue for only exposing a method like what I proposed, since I really do think it will cover the vast majority of cases, and even the rare ones have a straightforward solution.\nBasically, I'm arguing for trading off some flexibility (passing two arbitrary CGFloats) for a simpler API (just a YES or NO). It also makes it a little harder for magic numbers to get hardcoded, which is good.\nDo you think that's reasonable?\n. Cool, I will take a close look and integrate everything as soon as I get a chance to also work on the other variant.\n. Alright, I've gotten your changes merged in along with the corresponding new method for the fixed size variant. Thanks again for contributing!\nPlease do pull the latest and test both methods out -- make sure they're working for you.\n. First of all, make sure you are aware of this Technical Note: https://developer.apple.com/LIBRARY/ios/technotes/tn2154/_index.html\nI haven't tried doing exactly what you're doing myself. But I would use the 'Mixed Approach' Apple recommends in their technical note above.\nThat would mean, you create a plain container UIView that doesn't use Auto Layout (translatesAutoresizingMaskIntoConstraints = NO), then to this container view you add each of your dynamic-height subviews. Then, you add constraints to hook up each of these dynamic height subviews to one another vertically, with the top one connected to the top of the container view, and the bottom one connected to the bottom of the container view. (Don't connect the middle subviews with vertical constraints to the container view!)\nNext, you need to do basically what you would for a table view cell using Auto Layout -- make sure all the content is set, then force the container UIView to layout, then call systemLayoutSizeFittingSize: on it to find out how big it wants to be. Once you get this height, you set the container view's bounds.size.height to this value.\nFinally, (if not already done) add this container view as the one subview of the UIScrollView, and set the scroll view's contentSize to match the size of this container view.\nIf your content changes, you should basically just need to update the views with the new content, re-calculate the new height, and then update the frame of the container view & contentSize of the scroll view as needed.\nDoes that make sense?\n. By the way, in the horizontal dimension you wouldn't want to set fixed widths for anything - instead, you would pin the subviews to the left & right edges of the container view, and then before you do the layout calculation to get the height, just set the container view's width to be fixed at whatever the scroll view's width is in the current orientation of the device.\n. OK sounds good. If you do get around to implementing this, I think it would be really useful for people to have a sample project on GitHub that they could reference. I'd be happy to post the link around.\nI'm going to close this issue for now but feel free to comment here or open a new one if needed.\n. Did you see the comment here where the constant is defined?\nPerhaps a picture will clarify better:\n\nI promise that it is quite intuitive and consistent when you understand how it's defined!\n. Yes, you are correct in that initWithFrame: is the designated initializer for a UIView class. However, in my experience, calling init is functionally identical (in fact, I think I remember observing that UIView's init just calls [self initWithFrame:CGRectZero]).\nI'm not opposed to changing this, but the reason it's written with init is because specifying a starting frame is unnecessary and doesn't really make sense with auto layout.\nCan you share some examples of specific cases you have found where using +[new] or -[init] didn't work correctly?\n. One argument in favor of leaving it as init is that's exactly what [UIView newAutoLayoutView] will end up doing as well. This really only matters for subclasses of UIView, where I could see someone creating their own subclass and only overriding init (instead of initWithFrame:) because they intended the class to be used with auto layout and weren't thinking about using frames at all. Of course, they should be also overriding initWithFrame: and making sure to call super, but if this was omitted, the current code would at least run their code.\n. Let's leave it as is for now. I'm more than happy to change it if there is a compelling argument to do so though.\n. Hi Ethan,\nThis is the same question as raised in #14.\nThe definition is correct. I think where the confusion lies is when you try to think \"I want to vertically align two views\". Once you understand how these axes are defined (\"a vertical line through the center of the view\") it is quite easy to use.\n. Dupe of #18 \n. You have 2 options:\n1. Use 2 different cells with different reuse identifiers.\n2. Use 1 cell, and every time you set up your cell, you need to adjust the constraints by either removing incorrect ones & re-adding correct ones, or by adjusting the constant property of existing constraints.\nEmpty or hidden views will still be factored into auto layout calculations.\n. You should do that within the -[UITableViewCell updateConstraints] method of your cell subclass ideally.\n. See #16\n. First of all, UIView+AutoLayout has been deprecated. It is no longer being updated or supported, you should switch to using PureLayout.\nAs far as memory leaks, I have not observed any, and the library is used by many other developers who have not reported any issues. What has led you to believe that the issue is UIView+AutoLayout?\n. ",
    "rboisjoly": "great... not showing the actual constraints...\n.  \"NSLayoutConstraint:0x102a82e0 H:[UILabel:0x102a8120(19)]\",\n    \"NSLayoutConstraint:0x102a99d0 H:|-(1)-UILabel:0x102a8120\",\n    \"NSLayoutConstraint:0x102a9a40 H:[UILabel:0x102a8120]-(1)-[UILabel:0x102a8cc0]\",\n    \"NSLayoutConstraint:0x102a9ad0 H:[UILabel:0x102a8cc0]-(1)-[UILabel:0x102a8ed0]\",\n    \"NSLayoutConstraint:0x102a9b40 UILabel:0x102a8ed0.width == UILabel:0x102a8cc0.width\",\n    \"NSLayoutConstraint:0x102a9ba0 H:[UILabel:0x102a8ed0]-(1)-[UILabel:0x102a90f0]\",\n    \"NSLayoutConstraint:0x102a9bd0 UILabel:0x102a90f0.width == UILabel:0x102a8ed0.width\",\n    \"NSLayoutConstraint:0x102a9cb0 H:[UILabel:0x102a90f0]-(1)-[UILabel:0x102a9310]\",\n    \"NSLayoutConstraint:0x102a9ce0 UILabel:0x102a9310.width == UILabel:0x102a90f0.width\",\n    \"NSLayoutConstraint:0x102a9d40 H:[UILabel:0x102a9310]-(1)-[UILabel:0x102a9530]\",\n    \"NSLayoutConstraint:0x102a9d70 UILabel:0x102a9530.width == UILabel:0x102a9310.width\",\n    \"NSLayoutConstraint:0x102a9dd0 H:[UILabel:0x102a9530]-(1)-[UILabel:0x102a9750]\",\n    \"NSLayoutConstraint:0x102a9c00 UILabel:0x102a9750.width == UILabel:0x102a9530.width\",\n    \"NSLayoutConstraint:0x102a9ee0 UILabel:0x102a9750.trailing == UIView:0x102a8040.trailing - 1\",\n    \"NSLayoutConstraint:0x102aa440 H:[UIView:0x102a8040(175)]\",\n    \"NSLayoutConstraint:0x102a9a70 UILabel:0x102a8cc0.width == UILabel:0x102a8120.width\"\n. In case you are wondering, trying to build a UIView for a week, where each day has a fixed width and distributed within the week view.\nI also need a set of 7 \"Header\" views in a separate UIViews to place the day Initial.\nThings are not aligning easily...\nAs for Copy/Paste, here you go:\n2013-09-07 16:19:42.332 AgendaScolaire[13737:a0b] Unable to simultaneously satisfy constraints.\n    Probably at least one of the constraints in the following list is one you don't want. Try this: (1) look at each constraint and try to figure out which you don't expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you're seeing NSAutoresizingMaskLayoutConstraints that you don't understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints) \n(\n    \"\u00abNSLayoutConstraint:0x102a82e0 H:[UILabel:0x102a8120(19)]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a99d0 H:|-(1)-UILabel:0x102a8120\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9a40 H:[UILabel:0x102a8120]-(1)-[UILabel:0x102a8cc0]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9ad0 H:[UILabel:0x102a8cc0]-(1)-[UILabel:0x102a8ed0]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9b40 UILabel:0x102a8ed0.width == UILabel:0x102a8cc0.width\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9ba0 H:[UILabel:0x102a8ed0]-(1)-[UILabel:0x102a90f0]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9bd0 UILabel:0x102a90f0.width == UILabel:0x102a8ed0.width\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9cb0 H:[UILabel:0x102a90f0]-(1)-[UILabel:0x102a9310]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9ce0 UILabel:0x102a9310.width == UILabel:0x102a90f0.width\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9d40 H:[UILabel:0x102a9310]-(1)-[UILabel:0x102a9530]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9d70 UILabel:0x102a9530.width == UILabel:0x102a9310.width\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9dd0 H:[UILabel:0x102a9530]-(1)-[UILabel:0x102a9750]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9c00 UILabel:0x102a9750.width == UILabel:0x102a9530.width\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9ee0 UILabel:0x102a9750.trailing == UIView:0x102a8040.trailing - 1\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102aa440 H:[UIView:0x102a8040(175)]\u00bb\",\n    \"\u00abNSLayoutConstraint:0x102a9a70 UILabel:0x102a8cc0.width == UILabel:0x102a8120.width\u00bb\"\n)\nWill attempt to recover by breaking constraint \n\u00abNSLayoutConstraint:0x102a82e0 H:[UILabel:0x102a8120(19)]\u00bb\nBreak on objc_exception_throw to catch this in the debugger.\nThe methods in the UIConstraintBasedLayoutDebugging category on UIView listed in \u00abUIKit/UIView.h\u00bb may also be helpful.\n2013-09-07 16:19:42.334 AgendaScolaire[13737:a0b] Unable to simultaneously satisfy constraints.\nWill attempt to recover by breaking constraint \n\nBreak on objc_exception_throw to catch this in the debugger.\nThe methods in the UIConstraintBasedLayoutDebugging category on UIView listed in  may also be helpful.\n2013-09-07 16:19:42.334 AgendaScolaire[13737:a0b] Unable to simultaneously satisfy constraints.\n. Ah, I was also setting the size of the subviews... conflict, there.\n. got rid of the error... things not yet looking good, but no error is better :-) I'm surprised by how these constraints interact, not always what I expect.\nI'll keep you posted.\nThanks for the amazingly fast response!\n. ",
    "objectmethod": "You're right. My bad! :)  thanks\n. ",
    "jrturton": "The curse of usernames! I see now, you mean it was forked by you as opposed\nto the original repo written by you.\nOn 5 Oct 2013, at 08:17, Tyler Fox notifications@github.com wrote:\nTyler Fox would be me :) Let me re-word it and include you by name to\nclarify!\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/smileyborg/UIView-AutoLayout/issues/5#issuecomment-25743596\n.\n. Thankyou!\n. ",
    "atupem": "Hmm, that seems counter intuitive with a call to \n- (NSLayoutConstraint *)autoCenterInSuperviewAlongAxis:(ALAxis)axis\nwhere ALAxisVertical is required to center a view horizontally in it's superview.\n. Makes more sense now, thanks for the thorough answer!\n. ",
    "bredfield": "Thanks for the quick response! I'm familiar with animating constraints, my problem is figuring out how to reference a single constraint after setting it up with the category method. Typically with the NSLayoutConstraint I would save a reference to an individual one after creating it.\nHere's what I have: [self.savePopupView autoPinEdgeToSuperviewEdge:ALEdgeTop withInset:100.0] \nHow would I reference the top-pin to alter the constant? I appreciate the help, sorry if this is off-topic for an issue!\n. Ah, that makes sense. I Should have looked at the fact that the methods return the raw constraint(s). Thanks!\n. ",
    "caoimghgin": "I think being conservative with pulls is a very good idea!\nWith that in mind, I'd suggest the following...\nI remove from the .h file the following method...\nautoPinLeadingEdgeToView:leadingPeerView\nandTrailingEdgeToView:trailingPeerView;\nand keep the following method exposed....\nautoPinLeadingEdgeToView:leadingPeerView\nandTrailingEdgeToView:trailingPeerView forHeight:height\nThat way, we have a method which neatens up everything into a two line\ncall. In this particular use case (which I'll show in a moment).\n// With New Method\n[self.lastNameTextField autoPinEdge:ALEdgeTop toEdge:ALEdgeTop ofView:\nself withOffset:topInset relation:NSLayoutRelationEqual];\n[self.lastNameTextField autoPinLeadingEdgeToView:self.col1\nandTrailingEdgeToView:self.col2 forHeight:rowHeight];\n// Curent release methods\n[self.lastNameTextField autoPinEdge:ALEdgeTop toEdge:ALEdgeTop ofView:\nself withOffset:topInset relation:NSLayoutRelationEqual];\n[self.lastNameTextField autoPinEdge:ALEdgeLeading toEdge:ALEdgeLeading\nofView:self.col1];\n[self.lastNameTextField autoPinEdge:ALEdgeTrailing toEdge:ALEdgeTrailing\nofView:self.col2];\n[self.lastNameTextField autoSetDimension:ALDimensionHeight toSize:44.0f\n];\nThis may be a situation where many users simply would not use the\nautoLayout columns technique, which is something I've been working with for\na while now. The general idea is that newspapers and magazines have worked\nvery well using well defined column grid to lay out information in a\nvisually pleasing way. I'm finding it's working well for mobile devices too.\nFor a fuller use case scenario, this project attached would be helpful.\nIt's an experiment in creating greater separation between the View and\nController when programmatically creating layouts. (We are told to follow\nthe MVC Pattern, yet the viewController is mushed together pretty tightly\nby design).\nThe RJView is an example of creating a form a user may fill out where we'd\nlike to give the full rotation capabilities, possibly breaking and\nrecreating constraints upon rotation.\nAnyway, let me know what you think.\nOn Sun, Apr 6, 2014 at 12:37 PM, Tyler Fox notifications@github.com wrote:\n\nI'm not sure I fully understand the use case for this here.\nThe new code looks good. However, it doesn't look to be substantially\ndifferent than the other existing API methods which the methods call\ninternally. Even if this use case is generally applicable to more people,\nit looks like we're only saving 1 line of code here for each API call.\nThis is the hardest part about designing an API like this: deciding when\nto draw the line between increasing the complexity/size of the API with new\nmethods, and keeping it simple at the cost of some reduced functionality.\nFor these particular methods, I'm leaning towards the latter.\nWhat do you think?\n\nReply to this email directly or view it on GitHubhttps://github.com/smileyborg/UIView-AutoLayout/pull/10#issuecomment-39672943\n.\n. https://github.com/caoimghgin/ModelViewControllerStudy\n. You know something. Let me think on this for a day. It's useful, but I\ndon't think it's named properly. I'll come up with something!\n\nOn Sun, Apr 6, 2014 at 2:20 PM, Kevin Muldoon caoimghgin@gmail.com wrote:\n\nI think being conservative with pulls is a very good idea!\nWith that in mind, I'd suggest the following...\nI remove from the .h file the following method...\nautoPinLeadingEdgeToView:leadingPeerView\nandTrailingEdgeToView:trailingPeerView;\nand keep the following method exposed....\nautoPinLeadingEdgeToView:leadingPeerView\nandTrailingEdgeToView:trailingPeerView forHeight:height\nThat way, we have a method which neatens up everything into a two line\ncall. In this particular use case (which I'll show in a moment).\n// With New Method\n[self.lastNameTextField autoPinEdge:ALEdgeTop toEdge:ALEdgeTop ofView\n:self withOffset:topInset relation:NSLayoutRelationEqual];\n[self.lastNameTextField autoPinLeadingEdgeToView:self.col1\nandTrailingEdgeToView:self.col2 forHeight:rowHeight];\n// Curent release methods\n[self.lastNameTextField autoPinEdge:ALEdgeTop toEdge:ALEdgeTop ofView:\nself withOffset:topInset relation:NSLayoutRelationEqual];\n[self.lastNameTextField autoPinEdge:ALEdgeLeading toEdge:ALEdgeLeading\nofView:self.col1];\n[self.lastNameTextField autoPinEdge:ALEdgeTrailing toEdge:\nALEdgeTrailing ofView:self.col2];\n[self.lastNameTextField autoSetDimension:ALDimensionHeight toSize:\n44.0f];\nThis may be a situation where many users simply would not use the\nautoLayout columns technique, which is something I've been working with for\na while now. The general idea is that newspapers and magazines have worked\nvery well using well defined column grid to lay out information in a\nvisually pleasing way. I'm finding it's working well for mobile devices too.\nFor a fuller use case scenario, this project attached would be helpful.\nIt's an experiment in creating greater separation between the View and\nController when programmatically creating layouts. (We are told to follow\nthe MVC Pattern, yet the viewController is mushed together pretty tightly\nby design).\nThe RJView is an example of creating a form a user may fill out where we'd\nlike to give the full rotation capabilities, possibly breaking and\nrecreating constraints upon rotation.\nAnyway, let me know what you think.\nOn Sun, Apr 6, 2014 at 12:37 PM, Tyler Fox notifications@github.comwrote:\n\nI'm not sure I fully understand the use case for this here.\nThe new code looks good. However, it doesn't look to be substantially\ndifferent than the other existing API methods which the methods call\ninternally. Even if this use case is generally applicable to more people,\nit looks like we're only saving 1 line of code here for each API call.\nThis is the hardest part about designing an API like this: deciding when\nto draw the line between increasing the complexity/size of the API with new\nmethods, and keeping it simple at the cost of some reduced functionality.\nFor these particular methods, I'm leaning towards the latter.\nWhat do you think?\n\nReply to this email directly or view it on GitHubhttps://github.com/smileyborg/UIView-AutoLayout/pull/10#issuecomment-39672943\n.\n. You know, I actually did do some work on this, but haven\u2019t had the time to push it up to you. \n\n\nI think the extension category is a fine idea! Something like UIView+AutoLayoutForColumns\nI\u2019ll mock it up see how it looks!\nOn Apr 16, 2014, at 12:38 AM, Tyler Fox notifications@github.com wrote:\n\nHave you had any thoughts on this? (I've been busy recently and haven't had much time to work on anything myself...)\nThe one thing that did come to mind is that this might make a really nice category of its own. Think of it as extensions to these helper methods, almost like a category on the category. This way, it would be completely independent so people who want to have additional API methods (perhaps with more raw power, etc) can just import the extra header for this new category, which internally wraps some calls to the existing API of this UIView+AutoLayout category. But for people who don't need or aren't doing these sort of things can stick with the basic core methods alone.\nWhat do you think?\n\u2014\nReply to this email directly or view it on GitHub.\n. Hey Tyler,\n\nFinally got around to trying to extend the UIView+AutoLayout category and I suppose I wasn't finding much happiness...\nFirst, I was simply going to pop in my two new methods in a new category named UIView+AutoLayoutForColumns. However, to make that work, it would require a copy/paste of three private methods inside UIView+AutoLayout.m, which didn\u2019t seem like the nicest solution.\nNext, I thought I\u2019d get fancy and create a category on the category itself! No happiness there either (the + sign will degrade into a _ when creating the category extension, otherwise, I\u2019d think it would work fine).\nThirdly, I could simply rename the UIView+AutoLayout category to UIView+AutoLayoutForColumns, and then publish that as a pod from my own gitHub account but the additional feature, IMHO, doesn\u2019t really deserve a whole new repo. \nI\u2019ll remove the current pull request and upload a cleaner (more useful?) class and see if that looks good enough to pull in. However, if you have other ideas on how I might elegantly extend the category (which sounds like a fine idea) I\u2019m all ears.\nPS - Lately, I\u2019m using CocoaPods as repo for all things third party. Otherwise, I\u2019d happily import and modify UIView+AutoLayout at will. Besides. I\u2019d LOVE to have contributed something to a nice library. ;-)\nOn Apr 16, 2014, at 9:08 AM, Kevin Muldoon caoimghgin@gmail.com wrote:\n\nYou know, I actually did do some work on this, but haven\u2019t had the time to push it up to you. \nI think the extension category is a fine idea! Something like UIView+AutoLayoutForColumns\nI\u2019ll mock it up see how it looks!\nOn Apr 16, 2014, at 12:38 AM, Tyler Fox notifications@github.com wrote:\n\nHave you had any thoughts on this? (I've been busy recently and haven't had much time to work on anything myself...)\nThe one thing that did come to mind is that this might make a really nice category of its own. Think of it as extensions to these helper methods, almost like a category on the category. This way, it would be completely independent so people who want to have additional API methods (perhaps with more raw power, etc) can just import the extra header for this new category, which internally wraps some calls to the existing API of this UIView+AutoLayout category. But for people who don't need or aren't doing these sort of things can stick with the basic core methods alone.\nWhat do you think?\n\u2014\nReply to this email directly or view it on GitHub.\n. Hmmmm\u2026.\n\n\nI\u2019m not sure making the internal methods public would be so good. I like internal methods. Keeps things clean.\nWell, maybe check out the latest commit I did this morning. I added a ExampleConstraintDemo8\nIf that doesn\u2019t convince, nothing will ;-) \nOn Apr 22, 2014, at 11:35 AM, Tyler Fox notifications@github.com wrote:\n\nI don't think copy-pasting some of the internal methods is that terrible if the idea is that this new category/pod would be used instead of the UIView+AutoLayout one, but I agree if both will exist it's not so great.\nWhat I would recommend is that we refactor the current project a bit so that all of the internal private methods (prefixed by al_) are exposed in a separate header file. So what that would look like:\nPublic API\n// UIView+AutoLayout.h\n@interface UIView (AutoLayout)\n- (NSArray *)autoCenterInSuperview;\n// ...etc\n@end \nPrivate internal methods\n// UIView+AutoLayoutInternal.h\n@interface UIView (AutoLayoutInternal)\n- (UIView *)al_commonSuperviewOfViews\n// ...etc\n@end \nIf done this way, you could then #import UIView+AutoLayoutInternal.h at the top of your category and gain access to all the private methods. Regular users would continue to just #import UIView+AutoLayout.h which would only expose the public API methods.\nHow's that sound?\n\u2014\nReply to this email directly or view it on GitHub.\n. Well, in that case. I like! I\u2019ll have to circle back to this. Work must be done.\n\nOn Apr 22, 2014, at 11:46 AM, Tyler Fox notifications@github.com wrote:\n\nThe internal methods would not be made public, they would just be available to import into other .m files (such as yours that are effectively extensions on the category).\nSince users would never import this private header, they would continue to not see these private methods at all.\nThis is the same design pattern recommended in Objective-C when you have a superclass with private methods that you only want to expose to subclasses.\n\u2014\nReply to this email directly or view it on GitHub.\n. I\u2019d love to, so long as no rush.\n\nOn Apr 22, 2014, at 11:49 AM, Tyler Fox notifications@github.com wrote:\n\nNo rush. Do you want to take a stab at refactoring this or would you like me to work on it when I get some time?\n\u2014\nReply to this email directly or view it on GitHub.\n. Ahhh! Nice! I'll implement ASAP. \n\nSent from my iPhone\n\nOn May 2, 2014, at 8:43 PM, Tyler Fox notifications@github.com wrote:\n@caoimghgin I've been working on unit tests for this library recently, and I actually had a need to do effectively what we were discussing here. Take a look at the UIView+AutoLayoutInternal.h file.\nYou can probably take this file and more or less move it into the main repo source to accomplish what we were talking about. Let's just make sure to also add some more comments at the top warning regular users not to import this header of private/internal methods, since it will now be included in the source files they download.\n\u2014\nReply to this email directly or view it on GitHub.\n. Oh, that is nice! Just implimented. Say, if I intended to cocoaPod UIView+AutoLayoutColumns (private/public... not sure) I'd bet I would add UIView+AutoLayout as a dependency and let the manager handle the install of your pod. (I am playing catch-up with pods so looking forward to making one of my own). Anyway, I'm wondering if I should include UIView+AutoLayoutInternal.h in my pod or do you think you'll distro  UIView+AutoLayoutInternal.h within next version of UIView+AutoLayout? \n. Brilliant. Yes. When you're satisfied with UIView+AutoLayoutInternal, bundle it up with your pod. Let me know there is an update, and I'll put out a pod which links up! I think we can close out this pull request ;-)\n. \n",
    "eoghain": "You have a very valid point.  My use case may not be that common, basically I have a view that I want to place in a given position for one state, and then move it over 20 points in another state. So while I could easily make the 4 calls to set it's edges and only hold onto the edge I want to animate, I was hoping to use the bulk call as it's nice and concise and just grab out my one constraint that i'll animate later.  I guess I just like that using the single call over the multiple when it's just as clear what's going on as the more called out steps.\nI agree that my example is a very simplistic setup and doesn't take into account any of your more complex layout helpers.  One of the reasons I didn't just make the changes and issue a pull request.  I didn't want to miss something, or just be going down the wrong path.\nWhile using the first attribute isn't a guarantee, that is only because I'm accessing it from the outside.   I'd assume that if the API was changed to return a dictionary it'd be built to avoid any ambiguity.\nobjc\n- (NSDictionary *)autoPinEdgesToSuperviewEdgesWithInsets:(UIEdgeInsets)insets\n{\n    NSMutableDictionary *constraints = [NSMutableDictionary new];\n    constraints[@( ALEdgeTop )] = [self autoPinEdgeToSuperviewEdge:ALEdgeTop withInset:insets.top];\n    constraints[@( ALEdgeLeading )] = [self autoPinEdgeToSuperviewEdge:ALEdgeLeading withInset:insets.left];\n    constraints[@( ALEdgeBottom )] = [self autoPinEdgeToSuperviewEdge:ALEdgeBottom withInset:insets.bottom];\n    constraints[@( ALEdgeTrailing )] = [self autoPinEdgeToSuperviewEdge:ALEdgeTrailing withInset:insets.right];\n    return constraints;\n}\nAnyway feel free to close this if you don't see any merit to the change.  I can use the more explicit way of setting each edge so as to avoid a possible issue with the constraint being expressed \"backwards\". \n. ",
    "rahul-malik": "\nWhat about the other variant which uses a fixed size for each of the views, wouldn't this also apply to that? (The math on that one is trickier and may not be self explanatory, btw.)\n- I briefly looked at this and I'd be willing to make these modifications but the math that is currently used is a bit difficult to decipher. If you can clarify how the multiplier and constant values are calculated I can try to update it as well.\n\nObjective-C\nCGFloat multiplier = (i * 2.0f + 2.0f) / (numberOfViews + 1.0f);\nCGFloat constant = (multiplier - 1.0f) * size / 2.0f;\n\nPerhaps instead of exposing specific values for leading/trailing spacing, we just add an optional parameter that is a BOOL, which if YES includes the spacing before & after, but if NO the leading/trailing spacing is zero? In other words, is there really any reason to have to pass 3 different CGFloat values, since it seems there are only 2 probable uses?\n- I think the flexibility could allow for new use cases. I could imagine situations where you want to just apply a particular leading spacing and distribute the views amongst the remaining space. I can also add the method you've specified (or update the existing one) with the BOOL approach which would then call the method I added with zero trailing and leading spacing to simply that use case.\n\nThoughts?\n. Yeah I think thats reasonable. I'll update the method I wrote as discussed and assume you'll take care of the fixed size variant.\n. Just updated the code. Let me know what you think.\n. ",
    "lluis-lsm": "You need to setup all the vertical constraints. \nTop to first view, between views, last view to bottom. \nSent from my iPhone\n\nOn 10 May 2014, at 11:25, hiramgeeks notifications@github.com wrote:\nHey smileyborg,\nFirst of all, congrats for your efforts developing UIView-AutoLayout. A very sincere THANK YOU!\nMy question is about a UIScrollView. I'm trying to do something like the Facebook Timeline, but I don't want to use UITableView in order to learn AutoLayout and also to have more freedom to customize.\nI want to put an empty UIScrollView in a View Controller and, in runtime, I will add subviews with dynamic heights, but the scroll view never gets the correct contentSize height.\nWhich constraints would you suggest me to add?\nIs it necessary to add Vertical Space from every added View's bottom to Scroll View bottom?\nAfter days trying to solve these issue, I'm wondering if AutoLayout is really ready for being used purely without frames.\nI appreciate your help. Thanks in advance.\n\u2014\nReply to this email directly or view it on GitHub.\n. Superb explanation.\n\nSent from my iPhone\n\nOn 10 May 2014, at 22:54, hiramgeeks notifications@github.com wrote:\nTerrific, Tyler! Your recommendation about the mixed approach gives me some \nrelief. O thought I would be cheating by using it. LOL \nIf you don't mind, I'll consider a donation in a near future for your great \nwork. : ) \nCheers from Brazil \nEm s\u00e1bado, 10 de maio de 2014, Tyler Fox notifications@github.com \nescreveu: \n\nBy the way, in the horizontal dimension you wouldn't want to set fixed \nwidths for anything - instead, you would pin the subviews to the left & \nright edges of the container view, and then before you do the layout \ncalculation to get the height, just set the container view's width to be \nfixed at whatever the scroll view's width is in the current orientation of \nthe device. \n\u2014 \nReply to this email directly or view it on GitHubhttps://github.com/smileyborg/UIView-AutoLayout/issues/13#issuecomment-42753835 \n. \n\u2014\nReply to this email directly or view it on GitHub.\n. \n\n",
    "ghost": "Hi lluis-lsm,\nThanks for your reply. I'm gonna try to implement this way. I come back to\nthank you or to ask for more help.\nI swear that I am not asking before reading a lot and trying. Most people\nask when they are lazy. :)\nEm s\u00e1bado, 10 de maio de 2014, lluis-lsm notifications@github.com\nescreveu:\n\nYou need to setup all the vertical constraints.\nTop to first view, between views, last view to bottom.\nSent from my iPhone\n\nOn 10 May 2014, at 11:25, hiramgeeks notifications@github.com<javascript:_e(%7B%7D,'cvml','notifications@github.com');>\nwrote:\nHey smileyborg,\nFirst of all, congrats for your efforts developing UIView-AutoLayout. A\nvery sincere THANK YOU!\nMy question is about a UIScrollView. I'm trying to do something like the\nFacebook Timeline, but I don't want to use UITableView in order to learn\nAutoLayout and also to have more freedom to customize.\nI want to put an empty UIScrollView in a View Controller and, in\nruntime, I will add subviews with dynamic heights, but the scroll view\nnever gets the correct contentSize height.\nWhich constraints would you suggest me to add?\nIs it necessary to add Vertical Space from every added View's bottom to\nScroll View bottom?\nAfter days trying to solve these issue, I'm wondering if AutoLayout is\nreally ready for being used purely without frames.\nI appreciate your help. Thanks in advance.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/smileyborg/UIView-AutoLayout/issues/13#issuecomment-42741854\n.\n. Hey,\n\nShould I remove the vertical space constraint (the one with 500 constant) when I add a new button? If so, what would be the constant I should put? :-( I have no idea on how I can calculate this constant without checking frames, contentSize...\nAnother problem is that IB requires that I add a Width constraint to button, this means I can't support landscape orientations without some \"magic numbers\" in code... :-1: \n\nThanks\n. Terrific, Tyler! Your recommendation about the mixed approach gives me some\nrelief. O thought I would be cheating by using it. LOL\nIf you don't mind, I'll consider a donation in a near future for your great\nwork. : )\nCheers from Brazil\nEm s\u00e1bado, 10 de maio de 2014, Tyler Fox notifications@github.com\nescreveu:\n\nBy the way, in the horizontal dimension you wouldn't want to set fixed\nwidths for anything - instead, you would pin the subviews to the left &\nright edges of the container view, and then before you do the layout\ncalculation to get the height, just set the container view's width to be\nfixed at whatever the scroll view's width is in the current orientation of\nthe device.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/smileyborg/UIView-AutoLayout/issues/13#issuecomment-42753835\n.\n. Yeah, I give it up for now to meet my deadline. I'm \"officially too stupid for AutoLayout with UIScrollView\". It seems that only Apple can do the magic of a UITableView. I'll resume the research as soon as I finish this project. Thanks anyway.\n. BTW, in the meantime, I'll do with a UITableView...\n. Alright! I'll manage to do that. Thanks!\n. Hi AmyCao,\n\nAs far as I can recall, I needed to use UITableView to resolve this\nproblem. At that time, with the dead line approaching, I gave up\nimplementing the solution from scratch by myself.\nThese things should be a lot easier to do. The API should provide more\nready-to-use resources for a so common problem.\nI would tell you to look for cocoapods and Cocoa controls. There must have\nan open source solution for this problem (at least partially) there.\nEm 12/07/2015 02:21, \"AmyCao\" notifications@github.com escreveu:\n\nHi @hiramgeeks https://github.com/hiramgeeks ,\nHow did you implement this part: UIScrollView to grow dynamically while\nadding views at runtime? I really appreciate your help. I have been working\non this part for several days.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/smileyborg/UIView-AutoLayout/issues/13#issuecomment-120689032\n.\n. Tyler is right. It's very unlikely that there are memory leaks caused by\nUIView+AutoLayout.\n\nI would recommend that you review your UITableViewDelegate and\nUITableViewDataSource implementations. You are probably forcing a cell\ndequeue and not using/returning them. So the system can't access them in\norder to manage memory properly.\nI can provide you more details if you need. I had similar issues before,\nbut they were all about my implementation.\n2014-09-26 10:25 GMT-03:00 Tyler Fox notifications@github.com:\n\nFirst of all, UIView+AutoLayout has been deprecated. It is no longer being\nupdated or supported, you should switch to using PureLayout\nhttps://github.com/smileyborg/PureLayout.\nAs far as memory leaks, I have not observed any, and the library is used\nby many other developers who have not reported any issues. What has led you\nto believe that the issue is UIView+AutoLayout?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/smileyborg/UIView-AutoLayout/issues/20#issuecomment-56960675\n.\n. \n",
    "AmyCao": "Hi @hiramgeeks ,\nHow did you implement this part: UIScrollView to grow dynamically while adding views at runtime? I really appreciate your help. I have been working on this part for several days.\n. ",
    "TerryMichel": "Hi, \nI can of dig out an old post but here is an implementation of an HorizontalScrollView using auto layout if this can help anyone ;)\n. ",
    "mgregor": "Terry's solution was spot on and a lot less complicated that some other solutions I have seen posted!  Thanks Terry!!\n. ",
    "tcurdt": "Totally get where you are coming from - and I just checked. Indeed init is calling [self initWithFrame:CGRectZero] ...hence I must have misdiagnosed the original problem I had. (I am a little puzzled what the problem was then. Odd. Anyway!)\nSo I guess we could just close this issue but... given that initWithFrame: is the designated initializer and UIView is doing the same thing - why not do the obvious thing? After all it's an implementation detail that is hidden anyway in initForAutoLayout. It would be a little clearer and it would save one selector call - not that the latter really matters that much ;)\nAnyway - up to you. I will raise an issue if I run into it again. But if it was me - I would change it to directly call the designated initializer.\n. ",
    "zhjuncai": "I pretty sure it's a small mistake\n. Yes, you are right, thanks very much for your link, I think I understand it better. BTW, great work, I change all my auto layout by using your category. thanks a lot\n. ",
    "Sourav14": "I want to use the second option. When can i remove the incorrect constraints & and add the new ones.\nCan you please point me to the method where should i do that..?\n. ",
    "xRuby": "can help me \uff1f\n. "
}