{
    "MichaelDrogalis": "These are all great changes. Thank you, Stefan!\n. Absolutely, yes. Thank you!\n. Ah, thank you so much. Would you like commit rights?\n. Wasn't sure if you wanted them. Done. :+1: \n. Thank ya! :)\n. @dparis I got out a version with your removal functions and some banged versions that I wrote on 0.5.2-SNAPSHOT. I now have need of them :)\nNeed to write tests, then I'll pitch it over to you for code review before putting it out on 0.5.2.\n. That's 100% exactly what happens.\nHappy moving!\nOn Wed, Nov 6, 2013 at 3:47 PM, Dylan Paris notifications@github.comwrote:\n\nAwesome. I've been super swamped this last week between continual deadline\nwork and my wife and I moving across town. Be happy to review once you get\nthose changes finalized.\nTurns out I was misunderstanding the way the supervisor hook thing worked,\nI assumed that the function meta was orthogonal from way the hook was\nimplemented. I haven't dug into it yet, but from your description it sounds\nlike at the time of calling one of the bang methods, the meta gets frozen\ninto the hook?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/MichaelDrogalis/dire/issues/5#issuecomment-27912051\n.\n. Got an unexpected nugget of free time!\n\nPull request out for master from develop.\n. Fixed in 0.4.2.\n. Shipped in 0.4.4.\n. Since we're using try+ inside Dire, perhaps we can catch Object as seen in the second example? (https://github.com/scgilardi/slingshot#usage) It feels hacky though.\nI still think there's something to implementing an arbitrary function dispatcher to help solve this problem. Having a lot of trouble visualizing how it should work though.\nAt any rate, I absolutely want to support Slingshot.\n. I added an implementation for arbitrary function dispatch on develop. While one still has to perform some set up for it to work well with Slingshot, it's a step in the right direction. https://github.com/MichaelDrogalis/dire/blob/develop/test/dire/test/dispatch_test.clj#L6\nAnother example: https://gist.github.com/MichaelDrogalis/5377029\n@oneness \n. Yeah, after sleeping on it, I think you're right. There's also no reason to have arbitrary function dispatch if we have full slingshot support, given that for the custom dispatch to be useful, you'd be using throw+ anyhow.\nI'll play around with copy-pasting the code in to make sure our assumptions are correct, then I'll talk to Phil about perhaps exposing catch+.\n. I am stuck on this, for the record.\n. Certainly no rush!\n. With #17, this is done. :) Thanks @dparis !\n. Doesn't get much better than that! It's out on 0.5.0-SNAPSHOT, and will be released as 0.5.0 tomorrow morning.\n. Yeah, they should all be allowed docstrings. I just forgot to add them in. :)\n. Fixed in 0.4.2.\n. Thank you very much. Would you like commit rights?\n. Just deployed this to 0.4.3.\n. Eeek, sorry I didn't see this earlier. GitHub's notification system isn't so great.\nIt's okay - I need a better way to lay out the documentation. It's not the most intuitive thing.\n. And to answer your question - yes. The functions without '!' have no side effects.\n. Very much agreed. Thank you!\n. Deployed on dire-0.4.5-SNAPSHOT.\n. Can you come up with some examples of code that would benefit from this?\n. Oh yeah. I wrote something along the same idea yesterday. Perhaps it can live in here?\nhttps://gist.github.com/MichaelDrogalis/6638777\n. Hiya @dparis!\nWow, this is terrific! Thanks for your effort :)\nGive me a couple of days to stew on this. I'll keep you in the loop.\n. Will do! Super glad to hear the library is working out for you. :) Thanks again for your help.\n. Heya @dparis. I gave this a review and found some minor things. I had a cow when I realized that you can catch based on an arbitrary predicate - that's terrific. I'd be happy to merge after the issues are resolved. Thanks so much! :)\n. Oh, also - would it be possible to change the pull request to merge into develop? If not, I can apply a patch.\n. You can squash them into one commit if you prefer. It doesn't matter much to me. One other thing - be sure to change the project version to 0.5.0-SNAPSHOT, not 0.5.0. I want to upgrade a few projects before releasing.\nOnce again - thank you so much for this patch. You are awesome. :D\n. Took some time this weekend to test the impending changes on other projects. Everything looks great. Tuesday morning seems good for a release.\n. Howdy @dparis. Consider there to be no hard release deadline if we want to make some tweaks. I only picked that date because it's a good time to get a lot of eyes on a new release. :)\nFor 1: That's actually intentional. I didn't want ordering to matter, in a similar way to how multimethods works. Sometimes more than one handler can apply, and that's where I stopped short of using something like prefer-method. If it's a problem that you're having in real usage of the library, we can address it. If not, I wouldn't worry.\nFor 2: Yes, I can help look into it as well.\nAgain, no rush when we're still making the patch bullet proof. Have a good Sunday!\n. \"Gotta catch 'em all\" - made me laugh. :P\nI see your concern here. I think if we take the time to carefully consider a way to offer optional ordering semantics, it would more closely emulate try/catch - which is good IMO. So this sort of use case seems alright, but let's handle it after this patch goes through. We can collaborate on it.\nRegarding how to do it now, the best you have is to catch the most general thing and dispatch on a multimethod. It's actually not a bad approach, especially if everything throws clojure.lang.ExceptionInfo, but we can do better for sure.\nBy the way, what domain are you writing this pipeline for? Just curious.\n. @dparis Thanks for this! No worry about rebasing at all. I will get some docs written up tonight and a blog post out for tomorrow to promote your patch!\nDo you want to get in touch over email to discuss the remaining issues? I understand why it's a problem, and we can fast-track those changes. mjd3089 at rit dot edu\n. This has been merged in, and is available on 0.5.0-SNAPSHOT.\nSo awesome.\n. @johnworth Hey, thanks for the patch. You can remove the private on the function to ease testing. I will accept the patch after that change.\n. @dparis is correct. It would be a good idea to see a minimal case that triggers this behavior for you.\n. I will try to reproduce this tonight.\n. Just to note: usually you want to use prehooks for side-effecty concerns like logging, and preconditions for validation - rather than doing both in the prehook.\nI will still try to figure it out anyway.\n. Alright, yeah that completely makes sense. The prehooks are executed inside a try+ block here. The Slingshot error raises, drops into the most generic catch, which tries to do a normal throw on a Slingshot exception. I have no problems merging this.\n. Deployed on 0.5.1.\n. Easy way to find out where it was introduced. @johnworth Can you see if this behavior can be observed in versions prior to 0.5.0?\n. @johnworth Huh, weird. No worries.\n@dparis My fault, I was working pretty fast and misread something. Slingshot-y things should be caught higher up as you're thinking. Sorry for the noise!\n. Didn't get to try and reproduce last night. Will try again tonight.\n. I was able to come up with the same error message when using normal throw and not throw+.\nHow you got that stack trace .. I'm not sure. Because they certainly don't match.\n. How're you able to pull it off? I couldn't make it happen when I implemented it because it would lose the metadata from the var-root.\n. Clojure's metadata is extremely tricky to get right when you're passing a var between functions. The var call (I think) won't resolve inside the function because AFAIK the scope will be lost. Give it a try though.\n. Give it a shot. I wouldn't mind making that change for 1.0.0, but it's not easy (perhaps not possible either).\n. Ahh, yeah I had considered this a while ago. I came to the same conclusion. I'd rather let application developers make choices about things like concurrency rather than me. Otherwise we'd end up with an explosion in the number of 'specialty' hooks.\n. Great stuff, thanks for doing this! I'll take a closer look tonight and merge in. :)\n. Thanks for this! I don't want to deploy just yet. This is a case that I can easily see someone getting confused:\n``` clojure\n(defn f [x] (inc x))\n(defn a [y]\n  (prn \"A:\" y))\n(defn b [y]\n  (prn \"B:\" y))\n(with-pre-hook! #'f a)\n(with-pre-hook! #'f b)\n(f 1)\n(prn \"***\")\n(remove-pre-hook #'f a)\n(f 1)\n```\nObviously hook a isn't cleared, and both hooks remain. Since there aren't any banged versions of remove, users would probably think this set of remove functions serve both purposes. I think we should try to create a set of banged remove functions too. Removing the supervisor hook entirely is too much in some cases. For example, if I had a hook and a handler, and just remove to remove the handler and keep the hook - I can't do that.\n. Agreed about your last sentence.\n. By the way, the result of those two function invocations are:\ntext\n\"B:\" 1\n\"A:\" 1\nAnd\ntext\n\"B:\" 1\n\"A:\" 1\n. I think we can get around this for banged versions by removing the supervisor hook, removing the relevant handler, and adding the supervisor hook back in.\n. I'm in no rush to get it out, & busy as well. Hang in there!\nOn Mon, Nov 18, 2013 at 1:17 PM, Dylan Paris notifications@github.comwrote:\n\n@MichaelDrogalis https://github.com/MichaelDrogalis Haven't forgotten,\njust been buried under moving errands and work deadlines. Hoping to have\nsome time to review later in the week, but a cursory scan of the changes\ndoesn't reveal anything obviously wrong. Cheers!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/MichaelDrogalis/dire/pull/23#issuecomment-28723175\n.\n. Ahh, sloppy on my part. Thank you! Added to contributor list.\n. @ludwik Interesting idea. Would night-vision help for now?\n. Considering implementation. I'll let you know soon. :)\n. Yeah, I like this. I'll try to get it out by the end of this week.\n. Really busy this week. Might be able to get to it next week. Patch would be stellar, too. ;)\n. Fixed in #28.\n. That's definitely plausible. I don't see anything wrong with your usage of the library. Does it work when used within the same namespace?\n. That's really weird. Are you sure the namespace containing the hooks is getting required before the function call?\n. No problem, happens all the time! Closing unless anything else arises.\n. Excellent, thank you! Will cut a release momentarily.\n. Out in 0.5.3. Thanks again!\n. Hey there,\n\nWith 0.5.3, I ran the following: https://gist.github.com/MichaelDrogalis/698c4468185798e76ee2\nCan you ensure that you see the same?\n. Closing for now. Reopen if you're still stuck.\n. This is a terrific idea! Thanks for contributing! I, too, wanted something along these lines. I never had time to chase it down though.\nI don't have time to look at this today, but I'll try to diagnose what's happening in the next few days. I think this would be a massive step forward for Dire if we can pull it off, though. Maybe try Alex Miller in #clojure if you're totally stumped. He's a pro with the innards of Clojure. :)\n. @MichaelDrogalis (Tagging myself so I get email notifications, GitHub is pretty terrible about this)\n. It doesn't, no. At least I'm quite sure it doesn't. Try it out though.\n. @didibus They don't mutate the functions in-place.\n. I'm not aware of any issues, but the drawback is that you no longer have your original function. Same set of trade-offs as using a bash-in-place variable.\n. Seems fine, a PR would be great - thanks!\n. Thanks! Released under 0.5.4.\n. Let's make the version 0.5.0-SNAPSHOT, and as you said revert the project name when its merge time.\n. This can go. It was a dependency for LazyTest.\n. This can be dropped.\n. I have no idea what I was thinking when I included this. Hah.\n. Think it would be okay to just let it blow up? I wouldn't want to suppress any problems in the predicate function.\n. My vote is for throwing clojure.lang.ExceptionInfo here, same reason as above. What'cha think?\n. I think we can get away with just returning (match-handler-selector handlers object) here, and not explicitly returning true or false.\n. Whitespace.\n. That's a solid argument to do it your way. Leave as is.\n. Gonna take a little more time to think this one through.\n. Ah, I understand. It just looked odd returning either true or false based off an if. We can achieve the same effect by wrapping the if test in (boolean ...), in that case.\n. Okay, considering this one really carefully.\nI think it would be best to call the selector with no try/catch and just let it blow up. Suppressing exceptions is a really scary thing to me. You're right about it being hard to throw a Slingshot or Dire exception at this point in the code.\nThe downside is that you lose the stack trace that caused an exception in the first place, but if your selector is still problematic to the point of causing an exception in its own right - its also got to be dealt with. Additionally, if we suppress the exception in a selector, no one can have handlers on selectors. ( don't think anyone would do this, but you never know how people are going to compose the constructs of a language like this.\nI played around with it for a while at the REPL and preferred the exception coming out of the selector error and not being suppressed. That being said, I'm still open to being convinced about doing something different. We don't have to rush this.\n. Oh - my apologies. It was meant for the one above. I agree with your decision here.\n. Yes, absolutely. I think this is a terrific solution. Thanks for your thorough reasoning! After this is patched up, fire a new pull request my way and I will get it merged ASAP. Exciting stuff!\n. ",
    "oneness": "Still waiting for commit rights...\nOn Sun, Mar 31, 2013 at 2:34 PM, Michael Drogalis\nnotifications@github.comwrote:\n\nAh, thank you so much. Would you like commit rights?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/MichaelDrogalis/dire/pull/4#issuecomment-15698378\n.\n\n\n\nKasim\n  Sr. Software Engineer\n  Runa Inc.\n  2 West 5th Ave Suite 300\n  San Mateo, CA 94402\n. \n",
    "dparis": "I'm going to look into this, seems pretty straightforward at first glance.\n. Awesome. I've been super swamped this last week between continual deadline work and my wife and I moving across town. Be happy to review once you get those changes finalized.\nTurns out I was misunderstanding the way the supervisor hook thing worked, I assumed that the function meta was orthogonal from way the hook was implemented. I haven't dug into it yet, but from your description it sounds like at the time of calling one of the bang methods, the meta gets frozen into the hook?\n. Glad it's working out! Let me know if you run across any problems with the new functionality.\n. For the time being, this functionality can be accessed using my clojars fork:  https://clojars.org/org.clojars.dparis/dire\nLet me know if/when this gets merged into upstream and I'll happily get rid of my fork.\n. Just wanted to leave some feedback. I've been using the new slingshot syntax within an app I'm working on and it seems to work great so far. \nIn a processing pipeline where data is passed through numerous chained functions, I've got pre- and post -conditions checking data validity at each pipeline step. In the pre-/post-condition handlers, I'm performing some error validation and constructing an exception map using an error constructor function which contains a context-aware message, an array of the offending data, and the arguments to the pipeline function that caused the failure. I'm then throwing this map using throw+. Finally, I've added handlers to the pipeline wrapper function which can handle specific error types differently, or generically by looking at the type namespace. \nThe top-level handlers generally log the error, signal the error on an external queue for notification purposes, and allow the daemon which feeds the pipeline to continue processing. All this without having having any exception handling try/catch/throw code or validation code within my application logic, and without any custom exception classes.\nThanks to @MichaelDrogalis and all Dire and Slingshot contributors!\n. @MichaelDrogalis Sure thing. :smile: Glad I could contribute, and I hope I didn't overlook anything important. If you come up with any additional test cases that fail or need to be fleshed out, I'd be happy to poke at it some more.\nAlso, FYI, I updated the project group so that I could deploy my fork to clojars. If you do end up wanting to merge this upstream, let me know before you do and I can reset the project settings in the PR if you prefer to do the merge without having to edit anything afterwards.\n. @MichaelDrogalis Once the above discussions are resolved, I'll close this PR and open another one against the development branch. Github won't let you change the PR target after it's been created. Bummer!\nSince I'll be doing that, I could rebase my commits into a single commit. Would you prefer that, or do you want to maintain the granularity of my individual commits?\n. @MichaelDrogalis Hey, glad it's working out. I had a major deadline come up and I've been really slammed the last few days. I hope to get a chance to review some things before tuesday, but if not I'll get a PR containing at least the above fixes re-submitted against the dev branch by tomorrow evening (PST). I've been using the new branch in an app over the weekend, and I found it mostly works as expected, but there were a couple of issues:\n1. I'm not sure yet, but I think I'm seeing a bug related to the non-deterministic way selectors are ordered. Because they can be registered from anywhere, coupled with the fact that the error-handlers meta is storing the registered handlers in a simple hashmap, there's no intuitive way to know in which order they'll be applied. I was considering solving this using a priority-map but I haven't had time to flesh out the exact implementation. In essence, though, you'd ideally be able to call with-handler using the current syntax and get the current behavior, but optionally pass a priority argument which would allow for fine-grained control over the order in which the selectors are matched. Since priority-map essentially also functions as a priority queue, I should be able to keep the same recursive iteration logic and just make the values a map with a priority and function as values rather than just a bare function.\n2. There seems to be some unexpected behavior when throwing from within a handler and expecting the error to bubble up from there. This could be because the selection application order issue mentioned above is masking the intended behavior. I don't know yet since I haven't had a chance to really dig into debugging it.\nThankfully, both of those cases should be easy to write tests for, so hopefully it'll be quick fix. If I can't get around to it by Monday, I'm sure you could release the current version with some warning text informing people that selection application order is still non-deterministic and may cause unexpected behavior if a throw object matches multiple selectors within a given selector type.\nCheers!\n. Regarding 1:\nMy issue arises from a use case where I'm building a pipeline from composable functions, each of which can throw any number of exceptions. So:\n``` clojure\n(defn step1 [a]\n  ;; May throw any number of exceptions from consumed external libraries\n)\n(defn step2 [a]\n  ;; May throw any number of exceptions from consumed external libraries\n)\n(defn pipeline [a]\n  (-> a\n       (step1)\n       (step2))\n;;\n;; I'd like to do something like this...\n;;\n;; This particular exception is recoverable at the call site with some cleanup\n(with-handler! #'step1\n  some.specific.Exception\n  (fn [e & args] (step1 (clean-up args))))\n;; Uh oh, something happened when we foo'ed the bar. Maybe this step performs a\n;; lot of calculations using external libraries for net access / machine learning \n;; classification / etc, and I don't have time to read through the docs of every \n;; single library dependency used in order to handle every custom exception. Gotta \n;; catch 'em all!\n(with-handler! #'step1\n  Throwable\n  (fn [e & args] (generate-and-throw+ :step-1-exception e)))\n(with-handler! #'step2\n  Throwable\n  (fn [e & args] (generate-and-throw+ :step-2-exception e)))\n;; Let's say any :step-2-exception is always recoverable if we perform \n;; some cleanup and retry the entire pipeline again from the beginning\n(with-handler! #'pipeline\n  [:type :step-2-exception]\n  (fn [e & args] (do (log/info e) (pipeline (cleanup args)))))\n;; Caught some kind of unhandled exception here that could have \n;; come from any pipeline step, so log it and die\n(with-handler! #'pipeline\n  Throwable\n  (fn [e & args] (log/fatal e)))\n```\nEssentially, I'd like to be able to trap and handle specific exceptions at the individual step level, but in the case of an unpredictable exception at any given step I'd like to throw a step-specific custom exception so that the pipeline handlers can know at which step the unhandled exception came from. Right now, because Throwable will also catch any instances of some.specific.Exception, the handler on step-1 will sometimes apply the incorrect handler depending solely on the order that the selector tries to match them.\nIf you have any tips on how to implement this more effectively, I'd appreciate any guidance. :smile:\n. Closing in favor of the #17 PR against the develop branch.\n. Sure, let's email. Got a busy week ahead of me, but I should have some time towards the end to hack on this a bit more.\n. @johnworth I'm not opposed to making that change, I only kept the original throw because I didn't want to make any unnecessary changes to the existing behavior. That said, I'm very curious to know what your handler is that's allowing this case to happen. In order to get into the (apply-handler ...) call at all, it would need to have successfully caught something which was matched positively against (match-selector-handler ...). However, once it's in the handler application function, it just runs that same selector matching logic again in order to determine which handler to apply (which I admit is kind of crappy, but I couldn't see a way to inject a return from a catch clause into the handler invocation body).\nSo basically, you'd need to be throwing something which was caught by at least one handler selector, but that subsequently was unable to be matched to any registered error handler. I can think of the following cases where that might happen (and I'm not even sure these are possible):\n1. You register a predicate selector which relies on some kind of mutable state which changes between the first invocation of the selector matching function and the second. Something like: \nclojure\n(defn mutable-pred [e] (earlier-than (get-current-system-time) (:some-timestamp e)))\n1. You somehow modify the registered error handlers on the function var's meta within a predicate matcher such that when the selector matching function is run again it can't find the original selector.\nIf possible, please share the thrown object and the handler which caught it. Catching edge cases is good, so I'm all for the change if @MichaelDrogalis signs off, but I'm more concerned that there's an obvious case that I forgot to handle.\nCheers!\n. @MichaelDrogalis Wait, really? If the exception hits the three catch clauses in the try+ block during the (supervised-meta ...) call and it doesn't match any of them, it'll just go with the bottom one? I thought the behavior was such that if none of the catch clauses matched, it would just raise out of the try+ as an uncaught exception. The HoF (generate-catch-predicate ...) should, based on the meta being passed in and the object being thrown in this case, never return a predicate which returns true, so it should never actually get to the catch clause body to call (apply-handler ...). If try+ does work like this, where the bottom catch clause always fires regardless of if the clause selector matches, I'll need to totally re-evaluate how I've been using slingshot. :cold_sweat:\nI just tried to reproduce this and couldn't make it happen as described. I'll post my sample code if it would be helpful, but when I ran it I just got a normal throw+ exception raised from the try+ block.\nI still think it's probably a good change to make, but I'm scared now that I've either missed an obvious error case, or else misunderstood how slingshot catches errors. Or both. :grimacing: \n. @johnworth It happens, no worries. Last night, I spent two hours trying to debug why AngularJS's url router was magically changing my url route when I clicked on a button that had no state change directives attached. Totally went off into the weeds chasing down a bunch of HTTP error handling logic within my whole stack, server to client, before I realized that the \"buttons\" I was clicking were just re-styled anchor tags with the conventional \"#\" as a dummy href. Turns out the url router catches even those, and since client-side routing has also adopted the \"#\" as a default prefix to prevent URLs from hitting the server, it thought I was trying to browse to \"#\" and changing my app state to the client-side default route.\nFUN!\nAt least in this case, some kind of positive fix came out of it.\n@MichaelDrogalis Still concerned about misunderstanding the way slingshot is handling catching errors. Mind clarifying what you meant by:\n\nSlingshot error raises, drops into the most generic catch, which tries to do a normal throw on a Slingshot exception.\n. @MichaelDrogalis No problem at all, I'm just glad I hadn't misunderstood anything. :relieved: \n. (var ...), yo. Check out the documentation:  http://clojure.org/special_forms#var\nThe symbol must resolve to a var, and the Var object itself (not its value) is returned. The reader macro #'x expands to (var x).\n\nSo if your with-* functions expect to be called with some kind of #'fn-symbol as the task-var arg, that should be the same as calling it with (var fn-symbol). At that point, just add a little method indirection to pass task-var into a converter, say, (task-arg->var) and that should do it. The converter can just pass through args which are already vars, so it shouldn't affect existing behavior.\nIf I've missed some subtlety here, please let me know, since I'm not very familiar with the intricacies of Clojures metadata handling. Otherwise, should be a straightforward change.\n. Ah, good call! I think there might be a way around that using the intern built-in, but I'll have to poke around for it. I should have guessed there'd be more to it, since it hadn't been done yet and seemed like such low-hanging fruit. :grin:\n. Alright, I'll probably keep this one on the back-burner for now then. Something to fiddle with in my free (ha!) time.\n. Alright, works for me! Closing out, let me know if you want to re-visit this for some reason.\n. Oh, and if you want me to bump the version number or something in the PR, just let me know to what.\n. Double-oh, just FYI, I pulled in the core.incubator for their implementation of dissoc-in. If you want to keep it out, I can just copy-paste the method def into dire.core, it's pretty small.\n. Yeah, I wondered about how to handle this. In fact, I may have misunderstood how it works, currently. I was under the impression that the embedded supervise hook was essentially separate from the various handlers. By adding/clearing the supervise hook, you only change the need to call supervise. All of the handlers use a separate mechanism. \nAs such, wouldn't the sample code above leave hook b in place, along with the baked-in supervisor call? I'm not at my workstation, so I can't test it to verify the current behavior, but I would guess the final call to f would call the b pre-hook and then execute f. If one were then to add a line calling (remove-supervisor #'f) at the end, the b pre-hook would still be registered, but the caller would need to wrap further f calls in a (supervise ...) for it to fire.\nIn any case, coming up with matching bang methods is fine by me, but I think there ought to be a consistent behavior regarding the supervisor hook. It makes the most sense to me that a remove-*! function would remove the registered handler and then, if no dire handler types are found, clear the supervisor hook.\n. @MichaelDrogalis Haven't forgotten, just been buried under moving errands and work deadlines. Hoping to have some time to review later in the week, but a cursory scan of the changes doesn't reveal anything obviously wrong. Cheers!\n. My only concern with just letting it blow up is that this function is called within the context of handling an exception already. If it blows up by raising another exception, it'll obfuscate the original exception and might cause confusion. Strike that:  it'll definitely cause confusion, or at least it did when I was writing it. :smile: \nCouldn't figure out why, when I was throwing a custom exception, I not only wasn't handling it with the registered error-handler, it was somehow turning into an unhandled IllegalArgumentException. Burned some time trying to figure out why my initial throw+ code was throwing that exception instead. Turns out, in the predicate match, I had a typo that was causing a keyword to get passed to function instead of a variable.\nI thought that returning false in those cases would at least cause the original exception to go unhandled, which gives a clear indication that the predicate isn't matching properly. I personally would prefer that while debugging over getting potentially any other kind of Exception raised from the predicate instead of the one I was expecting. And I'm not sure, but if an exception is raised within a catch clause, does it then get passed to the next catch clause for matching? If so, imagine if that raised exception was then erroneously swallowed up by a subsequent handler. Ugh.\nThat being said, I can see a legitimate case for both ways, so I'm happy to defer to your judgement.\n. I think this case is a bit different than the one above. This multimethod default will only be hit if an unrecognized or invalidly formatted selector is used when calling with-handler. Slingshot handles this kind of thing like so:  https://github.com/scgilardi/slingshot/blob/master/src/slingshot/support.clj#L161\nI think it might be a good idea to do likewise, but I'm not sure how to format the exception. Would it be a dire exception? Should we try to re-create the slingshot exception? In essence, it ought to be the slightshot exception, since we ought to be deferring to their (currently unexposed) catch logic to handle matching their selector syntax. Whatever kind of exception gets raised here, it'll build a back-compat issue into dire; you wouldn't want to change the exception carelessly once it's released since people may build code around it. If slingshot ever does expose the catch clause logic, would dire need to then update the exception thrown in this case?\nI didn't have good answers to those questions, so I did what any good dev would do and punted. :laughing:   Suggestions welcomed.\n. That's true. I think I was just paranoid about how slingshot was set up to test truthiness. I know the README explicitly states that a predicate selector must take one argument and return a truthy value, but given that selectors might at some point resolve into all kinds of things going forward (new slingshot syntax, some creative use of a function generator, etc) I thought being explicit would be more clearly reflect the intent of passing a predicate to slingshot as a selector.\nAgain, happy to defer to you if you have a strong opinion about it, though if that's the case I'd be genuinely interested to hear your reasoning.\n. Did you mean for this comment to refer to the above issue of wrapping the predicate selector call in a try/catch? This comment refers to the case where the multimethod tries to match the selector type to either a vector, a class name, or a predicate function, and fails. When it can't match the selector type (like if someone tried to call with-handler and passes a list or a map as the selector or something), it falls back to the multimethod default which is just to return false.\nThis makes it look to slingshot like no matching selector was found. That's different than how slingshot handles the case of an unrecognized or malformed selector, which is to throw+ a slingshot exception indicating the poorly formed selector.\n. Nice, I hadn't seen that function. I'll update this code.\n. Sounds good. Just bear in mind that if dire ever does pass through to slingshot directly to handle the catch clauses, you might need to wrap that call in a try/catch and return false on any exceptions it raises. Otherwise you'd be introducing a different behavior to consumers of dire.\nNot a huge deal, but I figured I'd mention it for posterity. :smile:\n. I'm not sure I follow your point from below. \nLet's say we create a selector predicate which checks the thrown object to see if it's a string that ends with a question mark, just for example. My predicate handler would potentially have to accommodate all kinds of stuff thrown by throw+:\n1. If I throw a matching string, predicate returns true, exception gets handled by the registered handler.\n2. If I throw a non-matching string, predicate returns false, exception gets passed to the next catch clause.\n3. If I throw anything that causes the string operations called in my predicate to throw an exception, the exception will get caught within the multi-method and the predicate will return false. At that point the exception gets passed to the next catch clause. \nCase 3 should include attempting to match a Throwable instance, so no errors originating outside of the predicate selector would be suppressed. Essentially, any errors which happen within the predicate will turn that predicate call into a false value for the purposes of matching the thrown object to a selector, not handing the thrown object itself.\nHowever, this does mean that predicate exceptions get suppressed, which is a bit concerning. I think I have a solution, though. I realized that I wasn't using try+ here. Consider:\nclojure\n(try+\n  (selector object)\n  (catch Throwable e\n    (throw+ {:type ::predicate-selector-exception :predicate-arg object})))\nThe slingshot docs say:\n\nWhen throw+ throws a non-Throwable object from within a try+ catch clause, the outermost wrapper of the caught object being processed is captured as the cause of the new throw+.\n\nI take that to mean that the exception caught while calling the predicate would be contained within the hidden &throw-context arg as the :cause if you catch it in a try+ later. As well, if you include the object passed to the predicate within the new exception, you can see what argument caused the predicate to fail.\nAt that point, I think all of the bases are covered. People could easily debug the predicate exception, and you'd be able to see what the original exception was in those cases.\nI might have some time to look at this after tomorrow to see if it's viable. Let me know what you think.\nCheers!\n. ",
    "glenjamin": "I think the only way to get slingshot sugar without just copy-pasting the matching functions, is to get slignshot to expose a catch+ function, which does the handling as seen at https://github.com/scgilardi/slingshot/blob/master/src/slingshot/support.clj#L179\nDire would then be able to do something like (catch Throwable e (catch+ e catch-clauses))\n. I'm still intending to have a crack at this, when I get some time!\n. Awesome work! I'd just put this back on my todo list - now I can cross it off already :)\n. ",
    "rodnaph": "Just realised you can't do this because you have to explicitly attach the :precondition to a function.\nWell, if there's a way to do this kind of thing anyway that would be good.  Thanks.\n. To carry on my monologue, I rolled my own...\nclojure\n(defn with-validations\n  \"Attach validations to the specified functions\"\n  [v & body]\n  (let [all-args (apply hash-map body)\n        val-args (dissoc all-args :on-error)]\n    (doseq [validator (keys val-args)\n            failure-message (vals val-args)]\n      (let [identifier (keyword (gensym))]\n        (with-precondition! v\n          identifier\n          validator)\n        (with-handler! v\n          {:precondition identifier}\n          (partial (or (:on-error all-args)\n                       (fn [e & args]))\n                   failure-message))))))\nWhich can then be used like...\nclojure\n(with-validations #'create-user-entity\n  has-valid-username \"Username is not valid\"\n  has-matching-passwords \"The passwords do not match\"\n  :on-error (fn [message e & args] ...))\nCan be improved probably, just a first attempt.\nVery nice library though - thanks again!\n. ",
    "johnworth": "Okay, here's a summary of what I'm doing:\nI have this this function:\nclojure\n(defn do-rename\n  [{user :user} {source :source dest :dest}]\n  (irods-actions/rename-path user source dest))\nhttps://github.com/iPlantCollaborativeOpenSource/Donkey/blob/dev/src/donkey/services/filesystem/controllers.clj#L68-L70\nI'm registering this pre-hook in another namespace to do some logging and validation:\nclojure\n(with-pre-hook! #'do-rename\n  (fn [params body]\n    (log/warn \"[call][do-rename]\" params body)\n    (validate-map params {:user string?})\n    (validate-map body {:source string? :dest string?})\n    (when (super-user? (:user params))\n      (throw+ {:error_code ERR_NOT_AUTHORIZED\n               :user       (:user params)}))))\nhttps://github.com/iPlantCollaborativeOpenSource/Donkey/blob/dev/src/donkey/services/filesystem/controllers_prehooks.clj#L36-L43\nI'm (use)ing the namespace containing those functions in a higher-level namespace here:\nclojure\n(ns donkey.routes.filesystem\n  (:use [compojure.core]\n        [donkey.auth.user-attributes]\n        [donkey.services.filesystem.controllers]\n        [donkey.services.filesystem.controllers-prehooks]\n        [donkey.services.filesystem.controllers-posthooks]\n        [donkey.util.validators :only [parse-body]]\n        [donkey.util.transformers :only [add-current-user-to-map]]\n        [donkey.util]\n        [slingshot.slingshot :only [try+ throw+]])\n  (:require [donkey.util.config :as config]\n            [clojure.tools.logging :as log]\n            [dire.core :refer [with-pre-hook!]]))\nhttps://github.com/iPlantCollaborativeOpenSource/Donkey/blob/dev/src/donkey/routes/filesystem.clj#L4-L5\nThe error occurred when a Slingshot exception was raised from the (irods-actions/rename-path) function that's called in (do-rename).\nI don't have any error handlers registered yet, just pre- and post-hooks. I wanted to get those in place before I took a stab at replacing our homegrown error-handling with functionality from dire. Could the fact that I don't have any error handlers registered yet be part of the problem?\nThis code that I've added recently makes me suspicious, but I'm probably wildly off in the weeds. It's the code that will fire off the (do-rename) function that has the pre-hook associated with it.:\n``` clojure\n(defn- pre-process-request\n  [req & {:keys [slurp?] :or {slurp? false}}]\n  (if-not (contains? (:params req) :proxytoken)\n      (throw+ {:error_code \"ERR_MISSING_PARAM\"\n               :param \"proxyToken\"}))\n  (let [req (assoc req :params (add-current-user-to-map (:params req)))]\n    (if slurp?\n      (assoc req :body (parse-body (slurp (:body req))))\n      req)))\n(defn- ctlr\n  [req slurp? func & args]\n  (let [req  (pre-process-request req :slurp? slurp?)\n        argv (mapv #(get req %) args)]\n    (trap #(apply func argv))))\n(defn controller\n  [req func & args]\n  (let [p (if (contains? (set args) :body) \n            (partial ctlr req true func) \n            (partial ctlr req false func))]\n      (apply p args)))\n```\nhttps://github.com/iPlantCollaborativeOpenSource/Donkey/blob/dev/src/donkey/routes/filesystem.clj#L15-L36\n(do-rename) gets passed into (controller), which modifies the request map, pulls values out of the it, and calls (apply) on the function, passing it the extracted values from the request.\nI'm trying to tame this part of our codebase, it's gotten unwieldy after some somewhat rushed releases. Sorry for the clutter.\nPlease let me know if there is any other information that you need. Finding your way around our codebase can be an adventure. \n. Now that I look back on it, I guess that isn't exactly a minimal case. Sorry! \nI took a stab at replicating the error more exactly in the unit tests, but wasn't able to replicate it without calling (default-error-handler) directly. \n. This is weird and embarrassing, but I went back through versions 0.5.0 and 0.4.4 and have been unable to reproduce the issue. I haven't made any changes to my code that would have magically fixed it either. I went so far as to nuke dire from my ~/.m2/repository/ directory just to make sure I wasn't somehow picking up the wrong jar, and I modified my project.clj to let dire pull in slingshot rather risk pulling in an incompatible version.\nUsually when I have these kinds of issues it seems to be either threading or timing related. My guess at this point is that the issue is on my end. \nI apologize for the confusion, this is really baffling me.\n. ",
    "ludwik": "Great!\nNight-vision feels like the light weight repl use case. This being in dire feels like it could be used in production to embed optional debug logging, without code alterations, which is v cool.\n. ",
    "lkrubner": "I guess this would happen if there had already been an exception on that thread, which had gone uncaught? \n. Strangely, if I do this:\n```\n   (ns loupi.persistence-queue\n   (:require\n    [loupi.persistence :as persistence]\n    [slingshot.slingshot :as slingshot]\n    [lamina.core :as lamina]\n    [dire.core :as dr]))\n(def ^:private persistence-channel (lamina/channel))\n(defn persist-this-item [context-wrapper-for-database-call]\n   (lamina/enqueue persistence-channel\n                   (fn []\n                     (persistence/make-consistent context-wrapper-for-database-call))))\n(dr/with-eager-pre-hook! #'persist-this-item\n   \"An optional docstring.\"\n   (fn [a] (println \"Logging something before preconditions are evaluated.\" )\n     (println (str a))))\n```\nThen the \"Logging something before preconditions are evaluated.\" shows up in my terminal. But if move the pre-hook to its own namespace:\n```\n(ns loupi.supervisor\n  (:require\n   [loupi.perpetual :as perpetual]\n   [loupi.startup :as startup]\n   [loupi.server :as server]\n   [loupi.dates :as dt]\n   [clojure.string :as st]\n   [clj-stacktrace.core :as stack]\n   [dire.core :as dire]\n   [taoensso.timbre :as timbre]))\n(dire/with-eager-pre-hook! #'loupi.persistence-queue/persist-this-item\n  \"An optional docstring.\"\n  (fn [a b] (println \"Logging something before preconditions are evaluated.\")))\n```\nThen this does not appear in my terminal output: \"Logging something before preconditions are evaluated.\")\nAnd it makes no difference if I use :use to include the namespace:\n```\n(ns loupi.supervisor\n  (:require\n   [loupi.perpetual :as perpetual]\n   [loupi.startup :as startup]\n   [loupi.server :as server]\n   [loupi.dates :as dt]\n   [clojure.string :as st]\n   [clj-stacktrace.core :as stack]\n   [dire.core :as dire]\n   [taoensso.timbre :as timbre]\n   (:use\n    [loupi.persistence-queue])))\n(dire/with-eager-pre-hook! #'loupi.persistence-queue/persist-this-item\n  \"An optional docstring.\"\n  (fn [a b] (println \"Logging something before preconditions are evaluated.\")))\n```\n. Damn, that was obvious. I'd changed the order of things being required, and I'd left out a crucial one. \n. ",
    "MatthewDarling": "Example of the fact that it doesn't work:\nclojure\ndire.metadata> (apply-dire-meta! #'test-fn)\n({:dire.core/supervisor-hook-key #<core$partial$fn__4190 clojure.core$partial$fn__4190@44708681>})\ndire.metadata> (clojure.pprint/pprint (meta (var test-fn)))\n{:arglists ([a b]),\n :dire/eager-pre-hooks #{eager-pre-hook},\n :dire/preconditions {:pre precondition},\n :ns #<Namespace dire.metadata>,\n :name test-fn,\n :dire.metadata/handlers {:dire.metadata/pre-handlers [pre-handler]},\n :dire.metadata/wrap-hooks [wrap-hook],\n :column 1,\n :dire/error-handlers {{:precondition :pre} pre-handler},\n :dire.metadata/eager-pre-hooks [eager-pre-hook],\n :doc \"Docstring\",\n :dire.metadata/preconditions [precondition],\n :dire/wrap-hooks #{wrap-hook},\n :line 75,\n :file \"/Users/matthewdarling/src/dire/src/dire/metadata.clj\"}\nnil\ndire.metadata> (test-fn 10 2)\n5\n(also, apologies for the probable e-mail spam, I keep seeing issues that need to be fixed before anyone else can actually try this out)\n. ",
    "mcktrtl": "I wanted to do this as well and was disappointed when I found this on google and it wasn't working. I dived a bit deeper to see if I could figure it out myself, and it seems dire already does this? Or at least, does what I needed (and thought this was):\nclojure\n(require '[dire.core :as dire])\n(defn ^{:dire/preconditions {:not-three (fn [x] (= x 3))}} increase [x] (inc x))\n(increase 3)                            ;=> 4\n(increase 2)                            ;=> 3\n(dire/supervise #'increase 3)           ;=> 4\n(dire/supervise #'increase 2)           ;=> ExceptionInfo throw+: {:type :dire.core/precondition, :precondition :not-three}\n(dire/hook-supervisor-to-fn #'increase) ;=> {:dire.core/supervisor-hook-key #<core$partial$fn__4228 clojure.core$partial$fn__4228@72ad15e6>}\n(increase 3)                            ;=> 4\n(increase 2)                            ;=> ExceptionInfo throw+: {:type :dire.core/precondition, :precondition :not-three}  dire.core/eval1887/fn--1888 (core.clj:210)\n. ",
    "didibus": "And what are the disadvantages of mutating the function in place? Could it lead to issues? What situations should I be aware of where it would be problematic and I should instead use supervisor?\nThank you.\n. Ok, I see, so you wouldn't be able to call the function without the hooks being a a part of it anymore.\nSo there shouldn't be any Clojure specific corner cases to watch out for? Like the possibility that if I use my function too early, it hasn't been hooked up yet, or that it is being changed in the middle of something using it, etc?\n. ",
    "oubiwann": "Well, I'd forgotten about the custom selectors (which are vectors), so the solution I've put together is different than the simple proposition in the ticket description. That being said, this is much less hacky (so I'm happy about that).\nIt did require a change to the private function selector-type, though -- the check for :key-values was originally vector? and ensuring there were an even number of elements. This would obviously conflict with an even number of exceptions. So I added a third requirement: every other element must be a keyword for it to be a :key-values. This then left room for a new selector type: :class-names.\nTo pair with that, I added a new selector-matches? method that checks that the given object is an instance of at least one of the elements in the vector of exception classes.\nCaveat about midje: I've only used it once before! Let me know if you'd prefer the added tests to done differently :-) (as expected, though: added tests fail without the changes and pass with them). \nNote that when I submit the PR, I'll paste some of this text there for reference ...\n. Ah, one thing I missed -- updating the README. I'll push an update shortly ...\n. Sweet! \nJust pulled it down ... and updated my code to use it :-)\n. "
}