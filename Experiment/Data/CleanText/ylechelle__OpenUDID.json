{
    "ylechelle": "My tests were indeed not thorough enough. I tested across two distinct apps but compiled with the same certificate (same TLD bundle identifiers)... I need to do more testing. I'm afraid you might be right...\n. ok guys, I concur. Keychain is a no go across apps with a different certificate... #fail\nBack to the drawing board. Looking at UIPasteboard right now, looks promising... #hope\n. Ok, looks like it's working. Code is actually simpler and no longer depends on the Security framework.\nLet me know what you think ;-)\n. Hi Zac.\nOur messages crossed. I just finished implementing the UIPasteboard version.\nIt works across apps & certs! See latest commit.\nI was also thinking about a distributed persistence managed by each individual subscriber app in the event the pasteboard does indeed vanish. I'll get to it by Monday.\n. of course; DragKit ;-)  Hats off @Zac.\n- Persistence against deletion must be built-in to avoid loss of OpenUDID; the way to do this is to distribute the responsibility to all subscriber apps; when the pboard vanishes, any app can rebuild it. I now see @Zac's point. Creating numeric variation of the pboard on a per app basis should create some stability. Is there any way to find the \"creator\" of a pboard? \n- Anti-tampering or at least notification of tempering must be built-in by checking against the local copy\nmore later... \n. Agreed. And Apple could equally decide to deprecate access to it.\nBetter to use something rather different and random even.\nOn  2-Sep-2011, at 7:17 AM, schwa wrote:\n\nOnce you're using the MAC address you're back to why Apple deprecated UDID in the first place... There are some privacy issues related to distributing a MAC address even if it has been salted & hashed.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/1#issuecomment-1975865\n. Actually, the object of the exercise was to build a process that was no necessarily recomputable because MAC address or indeed the original UDID are private and hardcoded addresses.\n\nMAC addresses are used for Wifi security and other things like VPN, etc... it shouldn't be shared in the wild, even salted & hashed. Too sensitive.\nA persistent and 99.9% unique key that can be shared across vendors which can also be opted- or wiped-out is a good enough proxy for what the industry needs. \n. tested in Simulator or device? on the device, the pasteboard was lost for me. \n. @zac has the correct suggestion.\n. @zac @mcorner @schwa @tbrannam please have a look and let me know what you think. This v1.0 seems to fit the bill. I'm closing this issue. Please open new ones if applicable.\n. CFUUIDCreate(kCFAllocatorDefault) creates a random UUID here, not a UDID.\n. > i want to know that OpenUDID algorithm get the UDID from IPhone devices to generate new UDID ?\n\ncan't explain the algorithm simply here; but if you trace the call, you will see that the randomly generated OpenUDID is generated once and is persistent across apps via a distributed array of pasteboards.\nif i uninstalled app and re-install again, the UDID will change or not?\nit will not change theoretically, except if on your device there is only one app that uses OpenUDID which statistically isn't the case if you have 50 apps or more\u2026 (i.e. most people really)\n. No prob. Thanks for the scrutiny and interest.\n. Hello Vova,\n\nGreat feedback.\nYour analysis is correct. One OpenUDID implementation removed => resets and generates a new OpenUDID. N implementations, and remove them all => also resets. However, remove N-1 implemnatations, and you get persistence. Hence, true persistence is achieved the more OpenUDID is adopted, with an exponential factor. Do you see an alternative to make it more persistent? (apart from using a central cloud-based repository?\nRe: the deprecation, I did consider this issue.\nFor one thing, I believe Apple will not completely remove it, but rather, make it part of the private API.\nSo the main issue there, I think, is for new apps to be approved with this.\nNow, your suggested makes total sense for existing implementations - you never know. Apple might make this call totally unavailable in iOS 6. Better be safe than sorry. I will update the code accordingly.\nBest,\nYann.\n. Hi Tony, good call!.\nUnfortunately, I don't know why this constructor call is leaking and not the same one with create:YES\nOthers, any idea?\nYann\n. Hi,\nThanks for this.\nI'll look at the leak and see how else I can fix it.\nUsing the NSUserDefaults to create yet another copy is perhaps redundant.\nCheck OpenUDID.m:174 (or about)\n// Do we have a local copy of the OpenUDID dictionary?\n    // This local copy contains a copy of the openUDID, myRedundancySlotPBid (and unused in this block, the local bundleid, and the timestamp)\n    //\n    id localDict = [defaults objectForKey:kOpenUDIDKey];\n    if ([localDict isKindOfClass:[NSDictionary class]]) {\n        localDict = [NSMutableDictionary dictionaryWithDictionary:localDict]; // we might need to set/overwrite the redundancy slot\n        openUDID = [localDict objectForKey:kOpenUDIDKey];\n        myRedundancySlotPBid = [localDict objectForKey:kOpenUDIDSlotKey];\n        OpenUDIDLog(@\"localDict = %@\",localDict);\n    }\nEssentially, if you've called [OpenUDID value] once, then you can subsequently pickup that value from [[[NSUserDefaults standardUserDefaults] objectForKey:kOpenUDIDKey] objectForKey:kOpenUDIDKey]\nYann.\n. closing this because the issue was in fact fixed on September 9 by adding the kOpenUDIDSessionCache static variable.\n. it's all pretty random and unique in the end no? once hashed with md5, we get little collisions either way.\n. Guys, I still haven't merged that pull request - I need more arguments in favor of using CFUUID over [NSProcessInfo globallyUniqueString]... why not use both methods randomly at the same time to add more spice? \n. indeed\n. Not quite. The pull request is incorrect in terms of reformatting. But the core argument stands. Need to use CFUUID vs.  [NSProcessInfo globallyUniqueString] - will get to it within 24h.\n. Hi Patrick,\nTHe time has come. THe call has been removed...\nYann\n. That's a very good point Josh. \nInitially Keychain was naively thought to help share across apps; but indeed, that was limited to apps within the same publisher namespace. So the entire logic was rewritten around UIPasteboard.\nNow, are you sure that if you delete all apps of a given namespace, the corresponding keychain entries remain???\nIf so, you are right, that would add even greater stability.\nCare to improve the code?? ;-)\n. I wouldn't actually want to impose creating a UIWebView as the overhead is probably too great.\nBut point taken on the Keychain - great idea indeed.\nWill think of adding this time permitting, unless someone volunteers to help out.\nThe only downside with the Keychain is that you have to link with another framework - but nothing too complicated for most I hope ;-)\n. Josh, I'll review asap and will surely merge. At first sight, it looks solid.\n. Hello Josh,\nI want to integrate this, but it needs to be redone to merge with the recent priority changes.\n1/ integration is the right way to go\n2/ but the wrapper needs to be modified/refactored and be prefixed with OUDID_ to make sure that it doesn't conflict with other wrappers if OUDID is included in libraries, etc... \nWould you take care of redoing it from the main branch?\nThanks.\n. Great! No rush I suppose\u2026 \nHave a great vacation either way.\nOn  30-Mar-2012, at 4:28 PM, Josh Pressnell wrote:\n\nYann,\nSure, can do\u2026  I'm stepping out for vacation just now.  I'll see if I can get it from the hotel tonight.\n-Josh\n. Actually, if that \"fraudulent\" base UID is random, then it works just the same!\nOpenUDID only needs some form of random string with little possible collision.\nA fraudulent app would have to be pretty popular and widespread to preempt other valid OpenUDID hosts.\nA closed source library could always be hijacked/hacked, and would not comfort most developers who need full disclosure and transparency. OpenUDID wins if enough apps adopt it - it will be stronger as more apps adopt it, exponentially so.\nIf that's not the case, then it's not worth pursuing this effort.\n\nI need to check what SecureUDID is really about. From what I gather, it's an offspring of OpenUDID largely inspired by OpenUDID and not in the spirit of this initial project. The authors should have joined the effort/discussion and contribute to this one instead of adding further confusion... which is the last thing we need for persistent and cross-app UID sharing!\n. This was the only way I could think of that would not rely on a central and authoritative repository. We have to hope that the positive forces are stronger than the destructive ones ;-)\n. Let's close this issue and discuss in Issue #11\n. Actually, the point of the bundle ID was to let other developers create an app that would essentially provide a UI for users to opt out of certain apps.\nIf the bundle ID is obsfucated, then it's impossible for anyone to create an app that lists current apps using OpenUDID on the device, and opt-out of one or more apps.\nSo this fix somehow brings the implementation closer to the original uniqueIdentifier, accessible by all, and not facilitating the discrete opt-out process. So it's a step-back re: the original specs (that wanted to do good by the user). No?\n. I'm not sure I trust that all developers would in fact implement this in their UI, do you? ;-)\nUsing your mechanism, it is true that one cannot discretely opt-out (i.e. discriminating one-by-one and by name), it's all or nothing... is this what you mean?\n. yes, yes, I'm with you both ;-)\n. Done!\n. Also, I think we introduced a new problem here: every time the app is removed and reinstalled, it creates a new UIPasteboard slot. Here's what I suggest... we use a hashed version of the bundleid, or (oh no!) a hashed version of the MAC address. These are fixed items that remain within the device, and not used for the ultimate OpenUDID key.... what do you think?\n. the problem here is not the UDID - indeed, it will be picked up.\nthe problem is with 100 UIPasteboardS: if the guid is new, then we will create A NEW PASTEBOARD CLONE for no good reason:\n```   OpenUDIDLog(@\"Available Slot %@ Existing Slot %@\",availableSlotPBid,myRedundancySlotPBid);\n    if (availableSlotPBid!=nil && (myRedundancySlotPBid==nil || [availableSlotPBid isEqualToString:myRedundancySlotPBid])) {\nif TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR\n    UIPasteboard\\* slotPB = [UIPasteboard pasteboardWithName:availableSlotPBid create:YES];\n    [slotPB setPersistent:YES];\n\n```\n```\n. Tom,\nIndeed, let's forget about the MAC, and the hashed bundle id. Doesn't work.\nI think I found an acceptable solution, which hopefully doesn't open another corner-case loop-hole.\nWhat if we use the UIPasteboards not as a scarce resource, but rather like a FIFO queue.\nIn the event an app somehow regenerates its key (GID), then it adds another Pasteboard if an empty one is available, and if not, it overrides the oldest one.\nWhat do you think?\n. Perfectly relevant. Thanks for the patch.\n. I agree that devs can selectively compile for ARC or not, but it's more of a pain to integrate for them.\nNot everyone has upgraded to a version of Xcode that supports ARC; and I'm sure lots will keep using non-ARC code for a while.\nAlternative is to have one ARC version and one non-ARC version, which is a pain to maintain.\nI'm in favor to keep this simple define trick.\nHowever, Matt, you're right. The defines have nothing to do in the header file!!!\nMoving them right away into the .m file so that they no longer have an impact in other parts of the hosting project.\nMakes sense?\n. ok ;-) \nSo let's be pragmatic. Let's keep these convenience #define for a while in the .m and clean up the code to be fully ARC-based in a few months? Say after WWDC 2012? How's that?\n. Ok, your arguments won me over. Merging now ;-)\n. We now have the issue of trying to create a code base that works with legacy non-arc libraries that are NOT pre-compiled, and therefore require younger developers (beginners) to meddle with the flags.\nThe #define approach was definitely more flexible... Could everyone in this thread live with a dynamic ARC code if the #define are in the implementation file???\n. I'm not suggesting it is hard for any of us in this thread. I'm talking about lib developers who will have to keep integrating the latest commit and go backwards for their users (in the case of libs distributed as source code - and there are many).\nYou still haven't answered my question re: the pragmatic #define approach? Can you live with it or is is \"difficult\" for you? ;-)\nMy feeling is that we need to go back to the pragmatic approach for a few more months...\n. @mattjgalloway - direct users of OpenUDID might find this acceptable. Might. But users of lib A or B that embeds OpenUDID and does NOT require ARC to compile would be forced to add this compile flag JUST for OpenUDID and developers of lib A or B (big ones actually, not naming names) are not ready to enforce ARC compiling just yet... agreed it's the way forward, but even Apple does not force ARC by default (many existing samples, etc...).\n@mattjgalloway  @steipete you guys should run a separate branch that is ARC by default. How's that?\n. Ok, now we're talking ;-) The main concern right now is to help MOST developers adopt OpenUDID. So I'm in favor of going non-ARC or macros. @mattjgalloway @NSElvis please weigh in!\n. Ok. Sorry @kajinka13 \nWe're going back to non-ARC.\nMakes sense after all.\n. Time permitting yes. But I think in a few months (post-WWDC, post iOS 6?), we'll be ready to move to ARC fully as well...\n. We're back to non-ARC folks.\n. System pasteboards are persistent by default.\nIf the pasteboard is erased, then the app recreates it from the local cache which also is persistent across restores and reboots.\nSo yes, it's persistent.\nOn  28-Mar-2012, at 12:44 PM, Heyward Fann wrote:\n\nThe UDID is saved in a special pasteboard. Is the pasteboard keep the same after system update, via OTA or iTunes, or restore?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/13\n. Theoretically no.\nBut there is no 100% guarantee.\nYou'd have to have a case where:\n- all apps that use OpenUDID are removed from device (i.e. deleted explicitly, along with their data)\n- all openudid.org pasteboards are erased or compromised\n  Then yes, your case will occur.\n  Conclusion: the more apps use OpenUDID, the more universal it gets.\n  It starts to become super robust with just 2 or 3 apps!\n\nOn  28-Mar-2012, at 1:09 PM, Heyward Fann wrote:\n\nWill this happen?\nApp A and B both have OpenUDID, run A at first and create the UDID base on A's [[NSProcessInfo processInfo] globallyUniqueString], and B get the UDID for use. Then, device is restored and the pastedboard and local cache is missing. this time run B at first and create the UDID base on B's [[NSProcessInfo processInfo] globallyUniqueString]. Now, the two UDID are different and we can't distinguish the device.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/13#issuecomment-4754847\n. One of the goals of OpenUDID is to not use the MAC address at all, otherwise, it's a much simpler solution.\nThe MAC address should not be shared with 3rd parties at all. So let's not go there if we can avoid (and we can for now).\n. James, I think the code Anupam wrote was meant to do it by default, but introduced a bug (two different keys really).\nI'll check with him.\n. This scenario is indeed possible.\n\nHere, this calls for a signature that uses the MAC address to sign and compare with former, and regenerate the OUDID in that case. Makes sense?\n. @gavtron  Feel free to suggest the code for it with a pull request. Otherwise, I should be able to address this by the end of the week...\n. Chris,\nSorry but these last two only suggest a non persistent and non shareable UUID (user unique id)... which is fine for certain in-app needs, but not at all a replacement for the former persistent and shareable UDID (unique device id).\nAs for any scheme based on the MAC address and/or bundle-id, it's either too sensitive (see many discussions elsewhere on this topic) or not universal enough.\nThis issue #17 is ONLY about corner cases where OpenUDID is in fact duplicate because of the persistence across restores on different \"active devices\". I will close this topic since there is consensus on how to solve this.\n. Correct.\nHere, this calls for a signature that uses the MAC address to sign and compare with former, and regenerate the OUDID in that case. Makes sense? \n. Please follow-up in Issue #17 \n. Good call.\nOn it.\n. Wait, the license it MIT right now...\nHow is this not good?\n/*\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \"Software\"), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n. done. Good call thanks.\nOn  30-Mar-2012, at 11:46 AM, Peter Steinberger wrote:\n\n\"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\" ... this means that devs need to put it somewhere in an about box, telling that they use openUDID.\nYou want something like the zlib license, which doesn't requires attribution on the binary file. http://en.wikipedia.org/wiki/Zlib_License\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/19#issuecomment-4839441\n. Well, no, you need to go through the loop to find out if there has been an opt out for that bundleid/guuid... perhaps a break after the optedOut makes sense indeed.\n. Please take a look at the following:\nhttp://stackoverflow.com/questions/7747783/is-arc-really-supported-in-ios-4-the-ios-4-2-sdk-is-missing-arc-related-symbols\n\nExcerpt:\n\"ARC is supported on iOS 4.0 and above. You need to use the iOS 5.x SDK but can select iOS 4.3 for the Deployment Target. The one thing that is not supported in 4.x is automatic weak reference zeroing.\nOh, Xcode 4.2 is now out of NDA and can be used to submit apps.\"\n. Please discuss directly there: https://github.com/ylechelle/OpenUDID/pull/12\n. Good catch @doomspork \nThanks\n. If the app in question is the only one supporting OpenUDID on that device/simulator.\n. OpenUDID was a great proxy/alternative to UDID (via uniqueIdentifier) pre-iOS 6. Today, you should rely on either IDfA (Identifier for Advertisers) if you're looking for cross-app identification or vendorIdentifier if within the same publisher space. The latter is the most persistent but will not work across apps. If you need to support iOS 5 and below, then you should use OpenUDID for legacy support...\n. indeed\n. Hi,\nNo worries. It's okay to ask.\nI'll be drafting a workflow document that explains how it works (inner workings of OpenUDID for non-programmers).\nNote that OpenUDID for iOS  has nothing to do with the browser or HTML. It's a native piece of code that serves a unique and persistent identifier to the native app that includes it. It is a strict attempt at replacing the original UDID provided by a formally public iOS API. OpenUDID does not use fingerprinting, cookies, etc... \nOpenUDID may be used with advertising networks that support it, and permits installs tracking by simply comparing the unique identifiers at the click level and the unique identifiers are the installation level (where the installed unique identifiers are a subset of the clicked unique identifiers).\nHope this helps,\nYann\n. openUDID only generates the value (a unique/persistent value) or picks it up from an array of pasteboards if previously generated on the device. \nOpenUDID does NOT send anything nor does it work for typical HTML/browser ads.\nOpenUDID is a strict replacement to the iOS API called \"deviceIdentifier\".\nPlease refer to alternative tracking techniques for HTML/Safari tracking.\n. > So how do all those ad networks who use your system track app installs coming from their publishers' website?\n\nNot all of those networks propose web/banner-based advertising.\n\"Please refer to alternative tracking techniques for HTML/Safari tracking\"\nTypically, these networks will let you install a piece of code that takes care of the tracking. If they support OpenUDID, that means they most likely integrated it inside their code. \nDoes that mean safari cannot access the pasteboards on the device or has this never been tried?\nI mean to say that if it is possible to access pasteboards via safari then your algorithm for creating openUDID can be used in JavaScript, isn't it achievable?\nCorrect. Safari has no programmatic access to the pasteboard.\n. Sorry to say, it's not that simple (hundreds of man/hours have been spent on this already, and reviewed by hundreds of developers...).\n\n1/ must use a different type of pasteboard\n2/ any native app can certainly tap into any pasteboard\n3/ but an HTML page or a Javascript cannot directly tap into that pasteboard, even the plain text one, and even on the Safari desktop (except if you use Flash, which of course doesn't exist on iOS)\n. This might be the case if you only have one application using OpenUDID and you remove it. Typically, on a live phone with many apps installed, given the fact that OpenUDID is supported by over 17 ad networks and many individual developers, then the id is likely to be preserved fully.\n. The logic is based on replicating the identifier across multiple dedicated pasteboards, the frequency of which ensures persistence and stability in a given device. \n. Yes, although that is a rare occurrence in real life.\nIt's often the case in simulator mode.\n. Indeed, your use case makes sense. OpenUDID is not hardware based; so if you reset everything, then the id is recreated\u2026 if however you restore, then it will most likely be recovered\nOn  14-Jun-2012, at 12:37 AM, Zero1 wrote:\n\nI am testing OpenUDID  just by printing it out on a label. I deleted the app and reinstalled it again. The number remained unchanged. But, when I reset the device to the factory settings, and then installed the app again, the number changed. is this faced \nNSString * openUDID = [OpenUDID value];\n   NSLog(@\"The value is %@\",openUDID);\n[idLabel setText:openUDID];\nI tried uninstalling the app and running it again in the device, the OpenUDID value doesn't change.  However, when you reset the device and run the same app again, the OpenUDID value changes, Am I doing something wrong? Or is this the way it should work.\nPlease advise.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/33\n. Are you using the latest version? The identifier is indeed 36 chars, see the code below:\n\n```\n+ (NSString*) _generateFreshOpenUDID {\nNSString* _openUDID = nil;\n\n// August 2011: One day, this may no longer be allowed in iOS. When that is, just comment this line out.\n// March 25th 2012: this day has come, let's remove this \"outlawed\" call...\n\nif TARGET_OS_IPHONE\n//    if([UIDevice instancesRespondToSelector:@selector(uniqueIdentifier)]){\n//        _openUDID = [[UIDevice currentDevice] uniqueIdentifier];\n//    }\nendif\n// Next we generate a UUID.\n// UUIDs (Universally Unique Identifiers), also known as GUIDs (Globally Unique Identifiers) or IIDs \n// (Interface Identifiers), are 128-bit values guaranteed to be unique. A UUID is made unique over \n// both space and time by combining a value unique to the computer on which it was generated\u2014usually the\n// Ethernet hardware address\u2014and a value representing the number of 100-nanosecond intervals since \n// October 15, 1582 at 00:00:00.\n// We then hash this UUID with md5 to get 32 bytes, and then add 4 extra random bytes\n// Collision is possible of course, but unlikely and suitable for most industry needs (e.g. aggregate tracking)\n//\nif (_openUDID==nil) {\n    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);\n    CFStringRef cfstring = CFUUIDCreateString(kCFAllocatorDefault, uuid);\n    const char *cStr = CFStringGetCStringPtr(cfstring,CFStringGetFastestEncoding(cfstring));\n    unsigned char result[16];\n    CC_MD5( cStr, strlen(cStr), result );\n    CFRelease(uuid);\n\n    _openUDID = [NSString stringWithFormat:\n            @\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%08x\",\n            result[0], result[1], result[2], result[3], \n            result[4], result[5], result[6], result[7],\n            result[8], result[9], result[10], result[11],\n            result[12], result[13], result[14], result[15],\n            arc4random() % 4294967295];  \n}\n\n// Call to other developers in the Open Source community:\n//\n// feel free to suggest better or alternative \"UDID\" generation code above.\n// NOTE that the goal is NOT to find a better hash method, but rather, find a decentralized (i.e. not web-based)\n// 160 bits / 20 bytes random string generator with the fewest possible collisions.\n//\n\nreturn _openUDID;\n\n}\n```\n. nice catch\nOn  17-Jul-2012, at 2:17 AM, ghelton wrote:\n\nI'm getting a warning where _openUDID is defined:\nOpenUDID.m:142:91: Format specifies type 'unsigned int' but the argument has type 'long long'\nwould there be an issue with changing \narc4random() % 4294967295\nto\narc4random() % ULONG_MAX\nThis seems to resolve the issue.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/37\n. Yes, though I have had absolutely no team to deal with it over the past 6 months\u2026 please accept my apologies\n. Definitely yes\n. The strength of the system is that it is standalone and decentralised. Its weakness is that it is decentralized, and therefore no repository can ensure uniqueness. The system is as strong as it gets at scale (i.e. many apps using it across a large user base). The OpenUDID is very close to being unique, really. Collisions are as unlikely as one winning the lottery 10 times in a row... \n\nThat being said, going forward, I urge all to start using the more than desirable IDfA (identifier for advertising) and/or Vendor Identifier. They fulfill all requirements going forward.\n. First of all, I do not recommend that you use OpenUDID on iOS 7 (see note that it is now deprecated and will no longer be supported). That being said, your issue is possibly directly related to the fact that you had one single app depending on OpenUDID on your device, then was removed which cleared all traces of OpenUDID on that device, and therefore a new token was recreated afterwards. OpenUDID is persistent only when at least one app using it remains on the device.\n. ",
    "mcorner": "I was wondering the same thing.  Oddly it does seem to work on the simulator (build two apps with the library and both seem to get the same UDID).  Tried it on a 4.2 device and got different IDs.  I haven't updated my phone to 5.0beta, but someone would have to try that, but seems very likely that this doesn't work....\n. Hadn't seen the pasteboard, but very interesting... you can actually persist it across reboots.   Let us know what you see, very interested in this.   Other off-the-wall possibilities: \n-iCloud (kv or documents), but it seems hard to share iCloud data across apps from different teamids.  Haven't dug into that.\n-new single signon capabilities (haven't dug into that either).\n. One comment on the loss of the pastebin when deleting apps:\nI see that is in the documentation, but when I test that it seems to persist even though I deleted the app that created it.  I can try rebooting as well, but has anyone verified this?\n. Ah, never mind, just \"rediscovered\" the #if TARGET_IPHONE_SIMULATOR in the code.\n. ",
    "zac": "UIPasteboard is an option. The first app that includes this code will look for a shared pasteboard at the \"org.openudid.udid\". If it exists, it uses that. If it doesn't, it creates one and sets it.\nThe show-stopper with that is if the first application gets deleted, the shared pasteboard dies too. The next app to open up would then re-create the pasteboard with a new UUID. Not good.\nHere's a (crazy) workaround solution.\nThe first app goes through the following pasteboards looking for a UUID. \"org.openudid.0\", \"org.openudid.1\", \"org.openudid.2\", etc. all the way up to some number which represents the number of concurrent apps on the system that can support this.\nTwo possibilities:\n1) If it finds a UUID, It creates the first available pasteboard slot it can and copies the UUID it discovered into the new pasteboard. That way it owns a pasteboard and there is no single point of failure. It can cache in prefs so a restore from backup doesn't wipe the UUID. It should also cache the pasteboard it ends up using for defragmentation purposes (more on that below).\n2) If it doesn't find one in the initial search, it creates a UUID (or uses the cached prefs UUID) and puts it into \"org.openudid.0\".\nYou'll also want to do some kind of defragmentation. When your app launches it should check to see if there isn't a lower slot it could occupy (signifying another app was deleted). If there is, it moves it's UUID to a lower slot and updates the cached prefs slot.\nI might take a crack and implementing next week if there are no takers.\n. ",
    "ELLIOTTCABLE": "@zac, the obvious issue; what if you delete apps 1 to N (where N being how high it will check before deciding there are no apps, and resorting to creating a new one), without ever opening apps N+1 to M to cause defragmentation? You can never check high enough with that system.\nSolution: org.openudid.fragments++ each time one copies the data. Then again, that \u201cbreaks\u201d defragmenting (that is, the number will always climb upwards, because there\u2019s no way to know, when defragmenting, whether a previous defragmentor decremented it\u2020); so you\u2019re basically stuck with each app searching even further past deleted apps as the phone (or rather, the set-of-restored-apps-and-prefrences) grows older and older. This could eventually become somewhat slow, especially if you\u2019re doing this on-startup.\n\u2020 If you try to decrement fragments with-defragmentation: App N+1 launches, finds nothing from 0 to N, decrements fragments by N (number of slots it just checked and confirmed-empty. App N+2 launches, finds slot 1 taken, and 1 to N empty; decrements framents by N-1. fragments is now fragments - 2N + 1 instead of fragments - N.\n. ",
    "schwa": "cough Greasy hack cough\n. @ylechelle See Zac's comments. If the app that creates the pasteboard is deleted the data is lost for ALL apps.\nZac has a lot of experience hacking with the pasteboard. I'd definitely take his advice to heart if I were you.\n. Once you're using the MAC address you're back to why Apple deprecated UDID in the first place... There are some privacy issues related to distributing a MAC address even if it has been salted & hashed.\n. ",
    "tbrannam": "Is there any reason why the MAC address of en0 (and/or en1) aren't used as the seed.  MAC addresses are historically unique - combining two if available as a seed for a hash (SHA1 perhaps) would yield the same value for a given device.  It can be independently calculable in each process.\n. I see - somehow I thought that the object of the exercise was to build an algorithm that was recomputable and unique.  Isn't the point of OpenUUID itself opening up privacy issues?  Perhaps Apple would just ban any application that consumes this code?\nI'm intrigued by the comment that the MAC address is somehow special as a unique value that shouldn't be used salted & hashed, have any recommended reading on that topic?\n. ",
    "MechinMaru": "i doubt that\nthis code \nif (_openUDID==nil) {\n```\n       CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);\nCFStringRef cfstring = CFUUIDCreateString(kCFAllocatorDefault, uuid);\nconst char *cStr = CFStringGetCStringPtr(cfstring,CFStringGetFastestEncoding(cfstring));\nunsigned char result[16];\nCC_MD5( cStr, strlen(cStr), result );\nCFRelease(uuid);\n\n_openUDID = [NSString stringWithFormat:\n        @\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%08x\",\n        result[0], result[1], result[2], result[3], \n        result[4], result[5], result[6], result[7],\n        result[8], result[9], result[10], result[11],\n        result[12], result[13], result[14], result[15],(NSUInteger)(arc4random() % NSUIntegerMax)];\n\n}\n```\nCFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault); //// get udid from iphone device?  please description this code, how it work  \nThank you\n. i want to know that OpenUDID algorithm get the UDID from IPhone devices to generate new UDID ?\nif i uninstalled app and re-install again, the UDID will change or not?\n. i want to know that openUDID will generate redundant UDID  with another device or not?\n. ",
    "dkoslow-gs": "Apologies, this was addressed in your bug fix in commit 838a0bdfd1762a4955d4.\n. ",
    "uvalh": "Hi,\ndon't know if it is still actual but i also got the leaks Tony mention, they appear after re-allocating a class that uses openUDID.\nMy conclusion is that sending slotPBid for pasteboardWithName\nas a dynamic NSString  it will increase the retainCount and can cause a problem when the pool try to release the object, if i send a static NSString* const for pasteboardWithName the leaks are gone. \nAlso i didn't find any docs regarding pasteboardName for sending dynamic NSString it may not work well with dynamic objects.\nThe problem with openUDID algorithm is that it has to create a dynamic  NSString for searching the slots.\nWhat i did to stop the leaks is to call only once [OpenUDID value] and store the udid in the NSUserDefaults.\nNSUserDefaults *user_defaults = [NSUserDefaults standardUserDefaults];      \nNSString *udid = [user_defaults objectForKey:@\"openUDID_udid\"];\nif(!udid){\n    udid = [OpenUDID value];\n    [user_defaults setObject:udid forKey:@\"openUDID_udid\"];\n    [user_defaults synchronize];\n}\nHope it is helpful.\n. That will do the work. thanks.\nUpdate 2:\nmeanwhile If its OK with you i added to  OpenUDID.h file the line:\n#define kOpenUDIDKey   @\"OpenUDID\"\nand removed the static NSString * const kOpenUDIDKey from the OpenUDID.m file\nUpdate 1:\nIn the same context if you already save the openUdid in the user defaults why wont you add return with the value ? is it because you need to update the availableSlotPBid value?\nobjc\n  id localDict = [defaults objectForKey:kOpenUDIDKey];\n    if ([localDict isKindOfClass:[NSDictionary class]]) {\n        localDict = [NSMutableDictionary dictionaryWithDictionary:localDict]; // we might need to set/overwrite the redundancy slot\n        openUDID = [localDict objectForKey:kOpenUDIDKey];\n        myRedundancySlotPBid = [localDict objectForKey:kOpenUDIDSlotKey];\n        OpenUDIDLog(@\"localDict = %@\",localDict);\n        return openUDID;\n    }\n. ",
    "jessearmand": "The CFUUID string needs to be hashed as well with 4 random bytes added to it.\n. From the docs of NSProcessInfo.\nGlobal ID for the process. The ID includes the host name, process ID, and a time stamp, which ensures that the ID is \"unique for the network\".\nIt's not guaranteed to be unique to the computer. \n. That's a good question. I'm curious with this loop as well. Even though this 100-cycle loop is not really a noticeable processing bottleneck.\nI tried to put a break, when the availableSlotPBid is assigned:\n```\n    for (int n=0; n<kOpenUDIDRedundancySlots; n++) {\n        NSString* slotPBid = [NSString stringWithFormat:@\"%@%d\",kOpenUDIDSlotPBPrefix,n];\nif TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR\n    UIPasteboard* slotPB = [UIPasteboard pasteboardWithName:slotPBid create:NO];\n\nelse\n    NSPasteboard* slotPB = [NSPasteboard pasteboardWithName:slotPBid];\n\nendif\n    OpenUDIDLog(@\"SlotPB name = %@\",slotPBid);\n    if (slotPB==nil) {\n        // assign availableSlotPBid to be the first one available\n        if (availableSlotPBid==nil) { \n            availableSlotPBid = slotPBid;\n            break;\n        }\n    } else {\n        NSDictionary* dict = [OpenUDID _getDictFromPasteboard:slotPB];\n        NSString* oudid = [dict objectForKey:kOpenUDIDKey];\n        OpenUDIDLog(@\"SlotPB dict = %@\",dict);\n        if (oudid==nil) {\n            // availableSlotPBid could inside a non null slot where no oudid can be found\n            if (availableSlotPBid==nil) availableSlotPBid = slotPBid;\n        } else {\n            // increment the frequency of this oudid key\n            int count = [[frequencyDict valueForKey:oudid] intValue];\n            [frequencyDict setObject:[NSNumber numberWithInt:++count] forKey:oudid];\n        }\n        // if we have a match with the bundleid, then let's look if the external UIPasteboard representation marks this app as OptedOut\n        NSString* bid = [dict objectForKey:kOpenUDIDBIDKey];\n        if (bid!=nil && [bid isEqualToString:bundleid]) {\n            myRedundancySlotPBid = slotPBid;\n            optedOutDate = [dict objectForKey:kOpenUDIDOOTSKey];\n            optedOut = optedOutDate!=nil;\n        }\n    }\n}\n\n```\nThis should be okay, right? Since it doesn't need to keep looking for available slots when one is already found.\n. ",
    "lhunath": "Because the NSProcessInfo stuff is hacky and clumsy?\n. ",
    "pal": "This is done, no? Close the issue?\n. +1 \nPlease merge this to main branch.\n. ",
    "thanatos0801": "I'm positive that the keychain entries will persist across installations, as I've already experienced that with several of my own apps.\nAnother possibility would be to use a cookie and a hidden UIWebView that's not in actual displayed view tree.  This would provide some cross-app persistence that would stick around in the OS independent of the application, although the cookie could eventually be yanked by the user.  \nI'd probably recommend starting with the UIPasteboard, backing off to the cookie, and then finally checking the keychain.  This would provide quite a bit more \"extended stability\" than just relying on the pasteboard alone.\n. Perhaps make the UIWebView an option via a compiler switch... the benefit of using a cookie is that if someone installs a NEW OpenUDID enabled app before reinstalling the last removed OLD one, they still keep the same UDID value rather than generating a new one.  I might be able to find a way to access the cookie store without using a full up UIWebView.  I may look into it.\n. Okay... did a little research.  Cookies are sandboxed as well, so that won't work as a back-off.  I've added the keychain support though, and have sent you a pull request.  If you feel so inclined, would LOVE to see attribution to Vora Labs (http://voralabs.com)... but glad to contribute to a much-needed replacement UDID mechanism!\n. I thought about that... I could probably strip down the KeyChainWrapper class to what I actually used and include it in-line.  The extra files didn't bother ME all that much... But I'll work on it.\nSent from my iPad\nOn Mar 28, 2012, at 8:35 PM, Erik Lindberg reply@reply.github.com wrote:\n\nIt would be nice if it\u2019s totally incorporated in OpenUDID.h/m and not with an added separate file too.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/7#issuecomment-4794568\n. Okay.. updated the pull request to all be in the OpenUDID.h/.m source files.  Really just merged the KeychainItemWrapper into the source of OpenUDID.m... worked quite nicely.\n. Yann,\n\nSure, can do\u2026  I'm stepping out for vacation just now.  I'll see if I can get it from the hotel tonight.\n-Josh\n== Chance favors the prepared mind...\nOn Mar 30, 2012, at 10:16 AM, Yann Lechelle wrote:\n\nHello Josh,\nI want to integrate this, but it needs to be redone to merge with the recent priority changes.\n1/ integration is the right way to go\n2/ but the wrapper needs to be modified/refactored and be prefixed with OUDID_ to make sure that it doesn't conflict with other wrappers if OUDID is included in libraries, etc... \nWould you take care of redoing it from the main branch?\nThanks.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/pull/8#issuecomment-4843279\n. Sorry this took so long.  Got very busy.  Built and tested with latest merged master code and prefixed the keychain class, as requested.\n. \n",
    "Shadester": "It would be nice if it\u2019s totally incorporated in OpenUDID.h/m and not with an added separate file too.\n. ",
    "andrejvanderzee": "Hi,\nShouldn't the following be added to the keychain?\n[keychain setObject:kSecAttrAccessibleAlwaysThisDeviceOnly forKey:kSecAttrAccessible];\nIf I understand correctly, this enforces the OpenUDID to be removed after a restore on a different device.\nWhen will the keychain be merged to the main branch?\n. ",
    "grantland": "Yeah it seems SecureUDID only works for your apps and not all SecureUDID apps.\nIn terms of the \"fraudulent\" base UID, the third party could make it a hardcoded value so all OpenUDIDs are the same. It's a possibility and any possibility when creating an identification library is bad.\nThe frequency is a really good safeguard though.\n. ",
    "anupamtulsyan": "I agree, its a major privacy concern if bundle unique identifier is used. This information in no way should be accessible across partners. \nI have changed this and sent a pull request to use guuid instead of bundle id. \n. I think opt out process should be specific to an app. So, the developer who integrates open udid should give an option to user if he wants to opt out rather than creating a generic app for opt out. Also, there can still be a feature where user can opt-out of all apps. \n. thnks!\n. Even if he the app is re installed with a new guuid it will pick up\nthe right udid based on frequency. The only issue i see is with opt\nout. For that user if he has previously opted out and then re\ninstalled the app opt out fails.\nI think if we want to solve this we will need to use hashed version of\nbundle id. If mac address is used then all the apps will write the\nsame value in all the slots?? There will be no differentiator for\napps. am i missing something??\nOn Mar 30, 2012, at 7:29 AM, Yann Lechelle\nreply@reply.github.com\nwrote:\n\nAlso, I think we introduced a new problem here: every time the app is removed and reinstalled, it creates a new UIPasteboard slot. Here's what I suggest... we use a hashed version of the bundleid, or (oh no!) a hashed version of the MAC address. These are fixed items that remain within the device, and not used for the ultimate OpenUDID key.... what do you think?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/pull/11#issuecomment-4843545\n. I think it defeats the purpose of openUDID if mac address is used. All the apps can then directly use some hashed version of mac address. why is open udid needed then?\n. \n",
    "tomhubina": "ylechelle - if your concern is regarding developers doing \"bad\" things, then you should consider the bad things that can be done with things the way they are. If someone forks the existing code base and everyone else out there is using the code as it stands today ...\n1. Use the GUID mechanism to hide their presence, prevent end users from blocking them with apps, and still gain the benefits of OpenUUID for install tracking.\n2. Don't insert their own data into the pastebook, just mine it for data to track application installs and removals across the entire ecosystem, mine that for specific player behaviors, etc. Disguise that in some other free utility application that gains additional personal identifying information and you have a massively valuable and totally invasive data warehouse to tap into.\n3. For the more cutthroat areas out there a malicious developer could ignore using OpenUUID for their own tracking, and just consume the data to do things like:\n   - Detect which competitors have apps installed on their players device, and when those apps were installed\n   - Tailor their offerings to their users to promote their other titles, \"Hey .. you like Game X, you probably would like our Game Y a lot better!\"\n   - Incentivize players to uninstall competitor apps by tracking when a specific app is removed from the pastebook, \"I see you have App X installed .. delete it and we'll give you some cool thing!\"\nAlso, as a potential final nail in the coffin - Unless there's some kind of mandatory central registry, I think an end user will only be able to disable applications on an app by app basis after the fact (have to know which one to disable, and you don't know what they are till the tracking has already occurred on first launch) which I think will ultimately defeat any attempts at per-application tracking disabling.\nI think you're FAR better off exposing as little as you can and having a global, \"Disable all please, thank you!\" that the end users can trigger. BTW - if that's desired (and I tend to think it's a good idea), then we need to be able to determine that the user has disabled the tracking so we can instruct advertisers not to show them offers and such that rely on the tracking.\n. If you store a hash of the bundle id, it's still going to be unique per game, which means it has all the same problems as storing the bundle id.\nIf OpenUDID includes that Mac address, then putting some computed value on the pasteboard is completely pointless. Just use the Mac address everywhere and be done with it.\nAs for the growth of the pasteboard, I was under the impression that when you uninstall an application that anything it added to the pasteboard is removed. As I recall, that's the whole reason why each app has a unique entry on the pasteboard. With that in mind, how can an app have more than one entry on the pasteboard?\n. That sounds fine .. but you lose the ability to disable tracking on individual apps (something I personally think isn't very valuable, and hard to achieve anyway).\nDoes it makes sense that each app should automatically regenerate its GID if its missing and put itself back in the queue? The pasteboard would continuously cycle once you had more apps than the FIFO depth .. dunno if that's good or bad, or if it even matters. It feels like a moving target might be \"good\" from an obfuscation standpoint, but I have nothing to back that up. shrug\n. ",
    "jamesrz2live": "Just wanted to point out that the GUID generated for the application is never saved to the user defaults. Therefore, every time the user runs an application with OpenUDID it will generate a new application GUID (and therefore a new UDID). I've submitted a fix in pull request #16.\n. ",
    "steipete": "Sorry, but why is this needed, like really? Everyone can just use -fno-objc-arc or -f-objc-arc and it works beautifully. Using macros to have both ARC and Non-ARC completely defeats the purpose of ARC, thus being less work for the developer.\n. ARC is supported since Xcode 4.2. If you're using anything older, you're doing it wrong. Really. (and good call on the submission, @mattjgalloway) Just choose one (i'd go for ARC anytime) and add a ifdef that error's if it's being compiled w/o ARC. People usually don't add OpenUDID multiple times each day, so it's not really annoying. And if you're using ARC, there is no issue at all. More an \"issue\" for legacy apps. I fear that if you change that later, it probably does more harm that going with the right solution initially.\n. No. I'd be hard on that one. It's REALLY not hard to set a flag on a file. If people don't get that, they shouldn't write apps at all.\n. How's your crash problem related to ARC? ARC works down all the way till iOS4, Xcode is clever enough to add the small helper library libarclite.a to support older devices.\n. They're not. In that case the library would add the compatibility libraries by default, and the user wouldn't have to care about that at all. But I agree that this can be troublesome, because there's a problem when those are not used as submodules but precompiled binary blobs; in that case it could happen that multiple libraries have arc compatibility libs and one would need to use some command line tools to make it work. (thank god this problem goes away as we drop iOS4)\nApple doesn't force ARC, but I bet everything that you'll never see sample code using ARC macros. If you're worried about the above, just remove ARC support. Better than mixing both worlds.\n. \"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\" ... this means that devs need to put it somewhere in an about box, telling that they use openUDID.\nYou want something like the zlib license, which doesn't requires attribution on the binary file. http://en.wikipedia.org/wiki/Zlib_License\n(But then again, most people don't care)\n. ",
    "mattjgalloway": "Agreed. Not only that but this commit pollutes any code that imports OpenUDID.h with some #defines that have not even been attempted to be namespaced in any way (e.g. prefix with OUD_ or something).\n. Moving the defines to the implementation file is definitely a good idea. Personally I agree with @steipete and just choose one and then stick an error at the top that is caught if you're building for ARC and the code is chosen to not support ARC or vice-versa.\nYour argument about not upgrading to a version of Xcode that supports ARC is invalid IMO since you need to be using the latest Xcode to submit to the App Store anyway. Also, people should upgrade anyway :-).\n. Couldn't agree more. Also, if you make the error provide instructions for what to do then the user will be able to fix it. e.g.:\n``` objective-c\nif ! __has_feature(objc_arc)\nerror This file requires ARC to be enabled. Either enable ARC for the entire project or use -fobjc-arc flag.\nendif\n```\n. I've put in a pull request with how I would do this - https://github.com/ylechelle/OpenUDID/pull/20\nFor what it's worth, your current code wouldn't compile under ARC anyway since a bridging cast was missing.\n. @ylechelle - how do they have to go back and keep integrating the latest commit? People who are not using ARC in their main project just need to add -fobjc-arc flag to the compile flags for the files contained within OpenUDID and then that is it. (And need to link with -fobjc-arc set as well for the 4.x backwards compatibility to be compiled in.). I don't see why that's hard?\n@jcgsxr - if you're having crashing bugs, then fix them. The fix will not be \"disable ARC\" - there must be something wrong somewhere.\n#define is not a pragmatic approach, IMO. It's just making it easy for developers to miss out on slowly migrating to ARC. Remember, they don't need to convert their whole project to ARC - they can just compile OpenUDID with ARC enabled. That to me is a nice little introduction that everyone should be doing. And if they can't do it, then as @steipete suggests - they shouldn't be writing apps.\n. @ylechelle But still, you just need to enforce it on the OpenUDID compilation units - which is only 1 file. That's not a big deal and everyone should be comfortable doing this, IMO.\nIf only there was a #pragma for turning on ARC for a file, then we wouldn't have to be having this debate...\n. Absolutely. Pick ARC or non-ARC and stick with it. I believe that was the original stance in this conversation :-). If you want 100% support for non-ARC, then choose non-ARC.\n. I suggest having an ARC branch as well so that at least it'll be easy to switch over / people can take their pick.\n. ",
    "3lvis": "Where are the down votes for pull requests?\n. Is not about if it's easy or difficult. Is about best practices and how things have to be done.\n. ",
    "jcgsxr": "On a related note, we manage and distribute an SDK as part of integrating our ad products into applications. A number of developers in our ad network have users who are running iOS versions 4.2 and below, which causes crash issues for them. \nWhether or not using ARC is considered a best practice, this becomes a blocking issue for us as we can't just cut out a portion of our user base. I can only assume that this would also be a blocking issue for others as well who are potentially considering OpenUDID, since we must support all devices and OS versions at the end of the day.\nI agree with Yann, in that the #define approach is more flexible. I think it's all about making a solution like OpenUDID more widely accepted, instead of drawing some hard line by enforcing a specific coding practice.\n. I may have misspoke. To clarify, compiling and attempting to run this code on devices running iOS 3.x won't work.\n. ",
    "myell0w": "100 % on @steipete's side here: pick either ARC, or non-ARC, no macros, no separate branch for ARC. And for libraries created now, ARC should be used as Apple is moving towards ARC everywhere.\n. ",
    "fannheyward": "Will this happen?\nApp A and B both have OpenUDID, run A at first and create the UDID base on A's [[NSProcessInfo processInfo] globallyUniqueString], and B get the UDID for use. Then, device is restored and the pastedboard and local cache is missing. this time run B at first and create the UDID base on B's [[NSProcessInfo processInfo] globallyUniqueString]. Now, the two UDID are different and we can't distinguish the device.\n. ",
    "kajinka13": "yes, I suppose, but it was to solve the problem of the hypothetical collision.\n. ",
    "dgutzeit": "+1 for this approach\n. ",
    "patoth": "+1, just make sure former OUDID generated with past versions remains the same.\n. ",
    "Gavtron": "+1, and I'm curious when this change is going to be made, because nothing's been done with it for a few days and this seems pretty important\n. I saw this same issue happen when I added OpenUDID to a non-arc project and tried running it on a pre-iOS 5 device. I'm assuming your project is a non-arc project as well, so you're only enabling arc for OpenUDID.\nI fixed it by adding \"-fobjc-arc\" to the Other Linker Flags in the build settings for my app, and then it worked perfectly fine.\nPerhaps a comment about this should be added to the \"tutorial\" part that explains how to enable arc for the file.\n. Also refer to the other issue \"Compile error in iOS 4.3\", because there's a linker flag that needs to be added that I'm not sure if that stackoverflow thread mentions or not. Because without that linker flag, you get exactly the error you pasted above.\n. ",
    "brodybits": "There is already a nice solution, based on the MAC address by itself or in combination with the bundle ID at: https://github.com/gekitz/UIDevice-with-UniqueIdentifier-for-iOS-5\n. I also found https://code.google.com/p/objc-guid/ and http://stackoverflow.com/questions/427180/how-to-create-a-guid-uuid-using-the-iphone-sdk\n. ",
    "josemore": "hi, the iOS port has a ZLib license explicity declared but that's not the case for the Android port. Is the Android port assigned with the same ZLib license?\n. ",
    "ikovalisko": "Agree, could you please add this comment so other guys will have less pain?\n. ",
    "mabene": "I was wrong; the UDID stays always the same. But it looks like the code goes through the 100-cycle loop every time the app is relaunched. Is this the intended behavior?\n. ",
    "sshahidaslamm": "Hi,\nI am runing iOS 5 sdk. when i choose iPhone 5 simulator it works fine and when i choose iPhone 4.3 or 4.0 it crashes on \nNSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];\nthe stackoverflow link not worked for me, Here is the error log :\nCurrent language:  auto; currently objective-c\ndyld: lazy symbol binding failed: Symbol not found: _objc_retainAutoreleasedReturnValue\n  Referenced from: /Users/mbpro/Library/Application Support/iPhone Simulator/4.3.2/Applications/36937277-9D1C-41C0-AD19-DA009B5C6A41/IBFS.app/IBFS\n  Expected in: /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.3.sdk/System/Library/Frameworks/Foundation.framework/Foundation\ndyld: Symbol not found: _objc_retainAutoreleasedReturnValue\n  Referenced from: /Users/mbpro/Library/Application Support/iPhone Simulator/4.3.2/Applications/36937277-9D1C-41C0-AD19-DA009B5C6A41/IBFS.app/IBFS\n  Expected in: /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.3.sdk/System/Library/Frameworks/Foundation.framework/Foundation\n(gdb) \n. Solved by this and yes it should be added to the \"tutorial\" part that explains how to enable arc for the file.\nhttps://github.com/ylechelle/OpenUDID/issues/21\nThanks\n. ",
    "doomspork": "Thank YOU for putting together, and maintaining, this project!\n. ",
    "blackcct": "i find the leak that run jcgsxr's code in iPhone4 ios 4.3.4\nbut then i use iPhone4s ios 5.1.1 it's nothing to happen\nhttps://dl.dropbox.com/u/67903815/UIPasteboard_Leak.png\n. ",
    "orarbel": "you added a release at the end of the method but incase guuid was fetched from defaults ([defaults objectForKey:kAppGUUID]), it must not be released.\nmy suggestion is to retain if fetched from defaults: NSString * guuid = RETAIN((NSString *) [defaults objectForKey:kAppGUUID]);\nthen it will always have to be released \n. why is it weird? it's the same code as i reported that leaks\n. ",
    "ianmurrays": "Was this ever fixed?\n. ",
    "Matiaz": "is this still happening ? :S\n. it happens also when you reinstall the app, for example delete your app and install it again, and you will see that behavior.\n. is this still happening ? \n. ",
    "jdschmitt": "I'm seeing the same behavior. Is this only limited to OS upgrades and iCloud restores? Would be nice to get confirmation.\n. That's interesting. I was not always seeing the ID change on reinstall but there very well could have been more than one app on the device with OpenUDID.\nWe are trying to determine if we can rely on this ID to know if an app is uninstalled and reinstalled that it was the same device. Sounds like we can't really rely on that.\n. ",
    "marconealberto": "this is still happening. Is there any way to disable the iCloud syncing? \n. ",
    "adambair": "+1 Indeed. Thanks, this helped me out. \n. ",
    "Adcommunal": "Thank you so much for the quick response! I really appreciate it. After posting here I found this link (http://www.veracode.com/blog/2012/04/a-brief-field-guide-to-post-udid-unique-ids-on-ios/) that really helped me get a better understanding of openUDID.\nWe want to implement this system on our network ASAP because we already have app developers waiting for us.\nAs per my understanding of openUDID, this is what happens:\nUser installs app (that has openUDID) -> openUDID code runs -> looks for already present openUDID on the user's device's PasteBoards -> If it finds an openUDID it sends it over to the ad networks (i guess?), if it doesn't find one then it produces a new openUDID and sets it on the PasteBoard.\nHave I got that part right?\nAll this happens in the native app. But what about the part when the user clicks on the ad when browsing a publisher's page on their safari browser? How is that webpage going to access PasteBoard and do the same process as the native app?\n. We really want to be the 18th company using your system :)\n. So how do all those ad networks who use your system track app installs coming from their publishers' website?\n\"Please refer to alternative tracking techniques for HTML/Safari tracking\"\nDoes that mean safari cannot access the pasteboards on the device or has this never been tried?\nI mean to say that if it is possible to access pasteboards via safari then your algorithm for creating openUDID can be used in JavaScript, isn't it achievable?\n. From what I understand of UIPasteboards in iPhones, its a place where any native application can write and read data. Isn't it similar to the \"clipboards\" where the copy-paste data is stored? I am certain that Safari can access that. What about using that clip-board to store openUDID? I know the data inside will be altered when user uses copy-paste for different purposes so obviously this won't work every time. BUT, the chances of user using copy-paste, during the process of them clicking on the ad -> going to apple store -> installing the app, are very rare. So it might work! ..Just a thought :)\n. You are awesome man. Thanks for the quick responses.\nOK, so openUDID only works with native apps. We have got publishers who can host our ads in their native app, so we can definitely use openUDID. You mentioned in your 2nd comment that you will be drafting a work-flow document, I am looking forward to that, looks very interesting. Moreover, where can I find directions for using openUDID? is it hard to implement? Any help in this regard will be greatly appreciated.\n. ",
    "paiv": "Be aware of this case, as commented on SO:\n\nkeychain can be restored to other devices if the user encrypts their backup. This can result in a situation where multiple devices share the same UUID. To avoid this, set the accessibility of your keychain item to kSecAttrAccessibleAlwaysThisDeviceOnly.\n. \n",
    "pgorrow": "Can you explain the mechanics of what happens in this case (what causes the OpenID to change) and how having another app that uses OpenUDID prevents the id from changing during a reinstall?\n. Thanks.  I was unaware of the potential of perserving data via shared UIPasteboards.\n. ",
    "sujithkris": "@ylechelle \nCan we conclude that the OpenUDID value will change if the last application having openUDID is uninstalled ?\n. @ylechelle \nMore question : \n1.Are you using system pasteboard or application pasteboard? \n2. Whether values remains same if we uninstall/reinstall the last app from device, if we use system pasteboard ??\n( I am getting different values for unistall/reinstall of last application using OpenUDID)\n1. Is Keychain also remove value stored in it if we uninstall the app from device which wrote to keychain ?\n. ",
    "zeroCoder1": "Thank you for the response. I tried doing that. I reset the device. I restored a backup and the oudid is the same... Thank you for this wonderful idea of using openudid.\n. ",
    "gurre": "I can confirm this bug. Instruments output:\nAddress Category    Event Type  RefCt   Timestamp       Size    Responsible Library Responsible Caller\n0x2a78b0    Malloc 128 Bytes        Malloc  1   00:04.481.486   128 libsystem_c.dylib   vasprintf_l\n0x2a78b0    Malloc 128 Bytes        Free        0   00:04.486.926   -128    Foundation      NSLogv\n0x2a78b0    CFString (store)            Malloc  1   00:04.488.444   64  TheApp          +[OpenUDID valueWithError:]\n. ",
    "postmechanical": "Just ran into Instruments reporting this leak as well which is odd since I'm using the version with the following:\nNSString * appUID = (NSString *) [defaults objectForKey:kOpenUDIDAppUIDKey];\nif(appUID == nil)\n{\n  // generate a new uuid and store it in user defaults\n  CFUUIDRef uuid = CFUUIDCreate(NULL);\n  appUID = (NSString *) CFUUIDCreateString(NULL, uuid);\n  CFRelease(uuid);\n}\n. ",
    "yizhaorong": "NSString * appUID = (NSString *) [defaults objectForKey:kOpenUDIDAppUIDKey];\n    if(appUID == nil)\n    {\n      // generate a new uuid and store it in user defaults\n      CFUUIDRef uuid = CFUUIDCreate(NULL);\n      appUID = (CFBridgingRelease(CFUUIDCreateString(NULL, uuid)));\n      CFRelease(uuid);\n    }\n. ",
    "shalupandey": "No..i am using the code before this change is been done ( commented the //\n_openUDID = [[UIDevice currentDevice] uniqueIdentifier]; // } ).\nBut the point is there must be other apps also which will be using the\nolder code and hence generating 40 char id. And when my app tries to read\nit, 40 char id id being returned. Because code is trying to read the value\nstored by other apps and if not found then only generate..am i correct?\nPlease suggest if my understanding is wrong..\nThanks a lot...\nOn Jun 20, 2012 4:40 PM, \"Yann Lechelle\" \nreply@reply.github.com\nwrote:\n\nAre you using the latest version? The identifier is indeed 36 chars, see\nthe code below:\n```\n+ (NSString*) _generateFreshOpenUDID {\nNSString* _openUDID = nil;\n// August 2011: One day, this may no longer be allowed in iOS. When\nthat is, just comment this line out.\n   // March 25th 2012: this day has come, let's remove this \"outlawed\"\ncall...\nif TARGET_OS_IPHONE\n//    if([UIDevice instancesRespondToSelector:@selector\n(uniqueIdentifier)]){\n//        _openUDID = [[UIDevice currentDevice] uniqueIdentifier];\n//    }\nendif\n// Next we generate a UUID.\n   // UUIDs (Universally Unique Identifiers), also known as GUIDs\n(Globally Unique Identifiers) or IIDs\n   // (Interface Identifiers), are 128-bit values guaranteed to be unique.\nA UUID is made unique over\n   // both space and time by combining a value unique to the computer on\nwhich it was generated\u2014usually the\n   // Ethernet hardware address\u2014and a value representing the number of\n100-nanosecond intervals since\n   // October 15, 1582 at 00:00:00.\n   // We then hash this UUID with md5 to get 32 bytes, and then add 4\nextra random bytes\n   // Collision is possible of course, but unlikely and suitable for most\nindustry needs (e.g. aggregate tracking)\n   //\n   if (_openUDID==nil) {\n       CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);\n       CFStringRef cfstring = CFUUIDCreateString(kCFAllocatorDefault,\nuuid);\n       const char *cStr =\nCFStringGetCStringPtr(cfstring,CFStringGetFastestEncoding(cfstring));\n       unsigned char result[16];\n       CC_MD5( cStr, strlen(cStr), result );\n       CFRelease(uuid);\n   _openUDID = [NSString stringWithFormat:\n\n@\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%08x\",\n               result[0], result[1], result[2], result[3],\n               result[4], result[5], result[6], result[7],\n               result[8], result[9], result[10], result[11],\n               result[12], result[13], result[14], result[15],\n               arc4random() % 4294967295];\n   }\n// Call to other developers in the Open Source community:\n   //\n   // feel free to suggest better or alternative \"UDID\" generation code\nabove.\n   // NOTE that the goal is NOT to find a better hash method, but rather,\nfind a decentralized (i.e. not web-based)\n   // 160 bits / 20 bytes random string generator with the fewest possible\ncollisions.\n   //\nreturn _openUDID;\n}\n```\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/ylechelle/OpenUDID/issues/35#issuecomment-6466557\n. \n",
    "gorkem-cetin": "@ylechelle Is there an update with this issue? It's there for more than 5 months already.\n. ",
    "adamdahan": "@gorkem-cetin seriously!!!\n. ",
    "farnell": "whoops, posted the bug in the wrong issue list. sorry\n. ",
    "yosit": "+1 on integrating it.\n. ",
    "philc": "Bump. @krzak is referencing the comment on 59bd385b2ef0e6c3bb67ae735ceeec981d41e409.\n. ",
    "danoli3": "thanks xavier :) :+1: \n. ",
    "zddd": "same issue here. using ARC, UIPasteboard pasteboardWithName says message sent to deallocated object.\n. @futur yes, i did set -fno-objc-arc. the crash does not occur every time, almost none while running in simulator, but much more likely to crash while running in device with iOS6.1\n. @joshhinman  well, just a hack.. Generate OpenUDID only once, (it's saved to UserDefault) . any time u want UDID, just retrieve from UserDefault... hope helps.\n. ",
    "futur": "@zddd hope you did implement the selective non-arc flag. I use 6.1, xc 4.6.. no issue with [OpenUDID valueWithError:] in my source. little more detail about error would help.\n. ",
    "joshhinman": "I'm getting this crash as well. Does anybody know what causes it? Solution?\n. ",
    "4ndrey": "The same issue here. Any solution from author?\n. ",
    "MatiBot": "Same here, any idea? anyone?\n. ",
    "HavenShen": "OK,i here.it's ok.\n\u00a0\n\u4e2a\u4eba\u5fae\u535a:http://weibo.com/havenoo\n\n\u53d1\u4ef6\u4eba\uff1a Mati Bot notifications@github.com\n\u6536\u4ef6\u4eba\uff1a ylechelle/OpenUDID OpenUDID@noreply.github.com \n\u53d1\u9001\u65e5\u671f\uff1a 2013\u5e744\u670830\u65e5, \u661f\u671f\u4e8c, 3:48 \u4e0b\u5348\n\u4e3b\u9898: Re: [OpenUDID] OpenUDID crashes on iOS 6 (#43)\nSame here, any idea? anyone?\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "kimimaro": "Got the same issue, any solutions?\n. ",
    "chinaxuyujian": "got the same problem,can anybody help???\n. ",
    "deepkpndey": "Guys, the issue is still open. Has anybody found why is it crashing, and what can be done to resolve this?\n. ",
    "mikemonaco": "does anyone know how to reproduce this crash?\n. ",
    "GrayLocus": "This issue still exists on iOS9.2.\n\nThe debug info is: \nClass _NSZombie_NSURLError is implemented in both ?? and ??. One of the two will be used. Which one is undefined.\n. ",
    "pschuegr": "No worries! Just wanted to see if this was something you wanted to move towards.\n. ",
    "henrytkirk": "I can confirm this. I think there are some iDevice management tools out there that do restores of a master profile to multiple (different) devices and it is duplicating the OpenUDID. I noticed this with bulk Educational purchases.\n. ",
    "iriand": "Yes, it still happenning. It is the major security hole. Applications using OpenUDID can't be sure that device identificator is uniqie.\nIs it on the roadmap to fix?\n. ",
    "kaandedeoglu": "I would like to see this as well please.\n. ",
    "liuzhao": "look see\n. ",
    "agitka": "@unglevan Read this http://blog.appsfire.com/udid-is-dead-openudid-is-deprecated-long-live-advertisingidentifier/\n. ",
    "xialin": "This is useful, please merge the request :+1: \n. ",
    "jiwq": "Thanks! @xialin \n. ",
    "greenmood": "I got it. The problem was with Testflight used in project. Testflight is using OpenUDID and it's not documented at all.\n. Same question. Can't see any problems. nonetheless i've used it a year ago and now i should migrate all users to \u0010IDFV+keychain. It hurts so much :( \n. ",
    "holiday": "Yepp, I'm also interested in whether support would be provided for the new 64-bit requirement by Apple.\n. ",
    "wxm5558": "is there any solutions? \n. ",
    "captain-black": "it maybe caused by app code sign.\n. "
}