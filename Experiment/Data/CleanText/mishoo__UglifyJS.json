{
    "mishoo": "Thanks.  Although I think the more appropriate place for it would be in bin/uglifyjs \u2014 since that's actually reading data from a file; the tokenizer/parser expect a JS string, which is always Unicode so the BOM should not be there anyway.  But I applied the patch as it is, as I see no harm.\n. Thanks.  I added this.\n. Thanks for this!  I've long wanted to start some test suite but was too lazy.\n. Hey Wiz, thanks for your work!  One question, as I was thinking about something similar but I was afraid that it could affect code logic in some corner cases.  For example:\nvar a = computeSomething();\nvar b = somethingElse() - a;\nThis could convert to:\nvar b = somethingElse() - computeSomething();\n(assuming that \"a\" is not used some place else).  However, now the functions are called in reverse order, and if they have side effects (for example, they do something to one global variable) then the composition of these effects might not be the same.  Does your patch avoid this situation?\nSorry I don't have the time to review your patches right now but I keep them in mind and will look over the weekend.  The optimizations are definitely cool!\nCheers,\n-Mihai\n. In fact, I think you are dealing only with assignments \u2014\u00a0but the question remains (I had in mind a more general idea to completely drop the variable \"a\" in cases like above, if it's used only once).  So the question for your patch should be, does:\na = computeSomething;\nb = somethingElse() - a;\ntransform to:\nb = somethingElse() - (a = computeSomething());\nIf so, I think it's not generally safe...\n. Related to issue #1 \u2014 let's track it there instead.\n. No longer current.\n. No longer current.  I suppose most users will prefer NPM now.\n. Thanks, pulled.\n. Reversed for now.  It seemed so simple and clear, but it's wrong...  Think that we take the first char (modulo 54), then divide n by 54, then take the next char modulo 64.  In order for this to return something bigger than 54 (so that we make use of 0123456789) we'd have to have floor(n/54) >= 54, which means that we only get to \"taste\" the optimization when there are more than 2915 variables in scope.  That's clearly wrong, and I fear that it might return duplicate values for different N-s less than 2915.\nIn my test on DynarchLIB it made no difference.\nA proper solution should do it backwards (in fact the whole base54 function is wrong, in that the returned string should be reversed; but it happens that we don't care about this, as they are valid identifiers anyway) \u2014 only the last digit should be taken base 54, the rest base 64, and the string reversed on return.\nSeems too complex to worth the trouble, though I'll look into it just for fun. ;-)\n. Oh, correction: it was reversed in my original code...\n. I don't dismiss this change, but I'm just wondering why you would need that?  The mangler should be smart enough not to touch any names that can be possibly used from some other place.\n. Sorry, this wins almost nothing and I don't think we should do it.  (Closure doesn't either, BTW).\n. No worries, I wasn't going to pull it. ;-)\n. Hmm, I won't apply this because then the following usage will break:\nuglifyjs source.js > output.js\n(as the debug output will go into the minified file).  Not sure about rake (never used it) but uglifyjs should exit with a normal status even if it warns, so rake should not see a problem.  Perhaps try to redirect stderr to /dev/null?  (or we can, and in fact should, have an option to keep quiet).\n. No longer current.\n. Thanks, pushed.  I'll expose it to the CLI later.\n. I'm pretty sure that it won't output any newlines if beautify is false.  Otherwise it's a bug.  Are you sure that works?  (sorry, can't check now, I will look later).\n. There is an `--ascii' option now that makes it easy to quote any non-ASCII characters in strings as \\uXXXX escapes.  That would be safer for users who don't bother to declare UTF-8 charset for .js on their servers.\nI'm not sure why only \\u2028' and\\u2029' should have special treatment.\n. Point taken, thanks, applied.\n. package.json is now fixed; as for one-step compression function I don't feel it's necessary (and yeah, definitely not in index.js, which doesn't exist anymore).\n. No longer current.\n. Just wondering, did you benchmark?  I don't think it saves anything..\n. I know the theory, but practice is sometimes different. ;-)  In that case you're creating a closure.  It'll have to switch scope every time it's called.  It's probably not slower, but I'm pretty sure it's not faster either, so that's why I was wondering whether you benchmarked it.  If it's about the same speed, then it doesn't worth cluttering the code.\n. comments (closed by 9c4fbf4a1081d544dec85e505553883c61ca34b6)\n. Thanks and sorry for the delay.\n. > you didn't like any of these?\nOnly this one eb01a831d5b41914173a4c8db89e189813640cb3 \u2014 I merged it manually.\nI'm not a fan of jslint, btw.\n. This was merged manually, thanks!\n. Thanks!\n. Looks like your patch caused issue #283 \u2014 I pushed a fix but I'm somewhat guessing. :-)  Could you take a look and see if it doesn't break the logic of your patch?\n. String.prototype.substr(start, length) is defined in ECMA-262 (ECMAScript 5th edition, section B.2.3).  Am I missing something?\n. There's nothing new about substr, it's been there forever and supported by all JS engines I know.  Perhaps IronJS is work in progress.\n. Your fix is incorrect because it drops the > or the whitespace character.  Anyway, I pushed something similar.\n. This patch is big and I'm against putting it in core.  If you care to separate it into another file, similar to ast_squeeze_more, then I'm willing to include.\nAs for the walker change, instead of exporting walkers you could use now w.dive(this) (it's new API)\u2014it allows you to recurse into the current node, ignoring the user-supplied walker for it, which I think is exactly what you need.\n. Thanks!\n. I would write another walk function instead, and export it as walk_postorder or something.\nIf I understand correctly, it applies the default walker first (A), then if there is an user-supplied walker it calls that too (B) and returns B or A.  Just wondering, what's the use case for this?\n. I think the easiest way would be to provide a walk_default function that would invoke only the default walker on a node, ignoring any user-provided walkers.  Thus in your handlers where you need depth-first you'd do w.walk_default(this), then do your own processing of the result.\nIt's pretty easy to add this, will do later.\n. Thanks for taking the time to write it, but your version seems more complex than needed.  I handled it differently, hope you'll be happy with it.  (just do new_node = w.dive(this) in a walker to go in-depth first, then work on/return new_node).\n. This one is buggy:\njs\n// problem 1: this.foo is dropped\nthis.foo = 0;\nthis.bar = 0;\nthis.baz = 0;\n// problem 2: b -= b += 5?\nif (a < 0) b += 5;\nelse b -= 5;\n===> uglified:\njs\nthis.baz = this.bar = 0, a < 0 && (b -= b += 5);\n. This is already handled in a more generic way \u2014 we always try to negate the IF condition to see if it leads to smaller code, and the \"negate\" function does optimize this case.  It appears to work now, do you know of a case when it doesn't?\n. @michaelficarra: ah, correct.  It's only for ifs:\necho 'if (a <= b) foo(); else bar()' | uglifyjs; echo\na>b?bar():foo()\n. > switching to an option parser [...] that would auto-generate usage docs would be a better approach.\nAgreed.  Patches? :-)\n. I modified slightly the regexp fix, so that's why it's not a direct merge.  Thanks!\n. The fix is good, but the problem doesn't exist. ;-)\n. What I meant is that there will never be a case of, for example, [ \"call\", [ \"defun\" ....  There will always be \"function\" instead of \"defun\", and \"function\" was already covered.  \"defun\" only appears as statement.\nIf there is a way to reproduce the bug, please let me know.\n. Yep, that's clear now, thanks.\n. Good catch, thanks!\n. The comments will be attached to the statement where the function is used.  For example if you have something like\njs\n// comment\nvar foo = function(){ ... }\nThe tree will be something like this:\njs\n[ \"stat\",\n  [ \"var\", [\n    [ \"foo\", [ \"function\" ... ]]]]]\nThe stat node will receive the comments.\nI can see why you need your patch, but OTOH I'm not sure it's correct from our perspective to duplicate the comments there.  You can easily walk the AST and keep track of the previous comment.\n. You were correct, sorry for I overlooked this.  The issue was that the token actually embedded was the name token, not the function one.  I fixed it in a different way which seems more correct, let me know if it's fine for you now.\n. @michaelficarra is right, and case closed.  This particular patch doesn't buy us anything.  A patch to keep all comments in the AST (while not breaking the uglifier) is welcome, but not an easy job to do.\n. Sorry, it's definitely not the place for that in UglifyJS.\nYour implementation is wrong too, btw \u2014 why should it leave the 'a' in the code?  By calling read_line_comment, you're only skipping to the end of current line, so okay, you discard the <!...EOL, but then you continue to parse code on the next lines although you didn't yet encounter the end marker -->.  If you want it to work properly, it should be similar to read_multiline_comment.  Just FYI, I won't include it anyway.\n. Your example is incorrect compression because in the original code the significant argument was the third, and in the compressed code it's the first (hint: to make that work you'd have to track down where the function is called, and discard the first two arguments as well; almost impossible).\nUglifyJS explicitly prevents that from happening (which is why your code is actually simpler).\n. This has been tried before (5b2c91be0c63777e759c9baa6aa927fd56b4346c) but I rolled it back; I know it caused some problems, but I forgot what it was..  I'm holding it off for now.\n. @michaelficarra: I know.. I'm sorry about that.  I remember I ran compression on a big app, noticed some runtime problems and rolled it back without investigating further.\nI'll give it another try but personally I dislike the idea because it feels wrong (it's not base54 nor base64) and it doesn't buy much \u2014 I can't imagine code crazy enough to have more than a few hundred variables visible in scope, and that's well handled by the existing base54.\n. Maybe there was another issue, I couldn't find any problems now.  Merged.\n. I'm afraid this might break API for code that expects the plain property name, if it's really useful in some cases we could perhaps add an option for it and keep it off by default?\n. This is quite a comprehensive patch, thanks for it!\nQuestion, why not making those variables global?\n. Also, thanks for making it a separate step!  That's indeed the proper way to do it.\n. Fair enough...  The way I'm usually building my apps involves dumping all the scripts into a single big .js file and minifying that \u2014 so if I don't rely on any other scripts, this kind of bug would not bite me.  But I agree it can be bad in general.\n. Thanks!\n. Might also wanna check that args[0][0] == \"num\"?\n. Sorry for forgetting about this for so long.\nIn any case, in UglifyJS2 the interface is a bit simpler \u2014\u00a0you just pass a JS constant, not an AST.\n. This closes #370, right?\nEdit: right, just noticed you closed it.\n. Nice one, thanks!\n. I didn't even test it, but I think it's a good idea.  Yeah, we should think about the dynamic version, that'll be a lot better in general.  Any case, for now patch accepted \u2014\u00a0if it shaves 100b on jQuery then great, thanks! ;-)\n. Side note: because of the way planets are aligned, I can't run nodeunit right now to see how all the tests fail.\nThis patch is a nice example of a perfectly valid improvement which breaks all the tests, confirming my belief that unit testing (at least the way we think of it today) is not such a good idea.\n. I still didn't bother to get nodeunit working, but your patch looks good to me. Thanks.\n. I missed walking the arguments and it's pretty important.  Also, npm commands worked\u00a0\u2014 thanks.\n. @rvanvelzen good catch.  It calls for a lot more complicated fix.\nCode generator is probably the most complex part of UglifyJS.\n. Yep, fixing it at AST-level seems like a better idea.  I'll push this tomorrow.\n. It's not acceptable to modify the member function like that.  Feel free to modify get_mangled (in process.js in function ast_mangle) to do a custom loop through the names instead of calling member.\n. Thanks!\n. Thanks.  Although I think the more appropriate place for it would be in bin/uglifyjs \u2014 since that's actually reading data from a file; the tokenizer/parser expect a JS string, which is always Unicode so the BOM should not be there anyway.  But I applied the patch as it is, as I see no harm.\n. Thanks.  I added this.\n. Thanks for this!  I've long wanted to start some test suite but was too lazy.\n. Hey Wiz, thanks for your work!  One question, as I was thinking about something similar but I was afraid that it could affect code logic in some corner cases.  For example:\nvar a = computeSomething();\nvar b = somethingElse() - a;\nThis could convert to:\nvar b = somethingElse() - computeSomething();\n(assuming that \"a\" is not used some place else).  However, now the functions are called in reverse order, and if they have side effects (for example, they do something to one global variable) then the composition of these effects might not be the same.  Does your patch avoid this situation?\nSorry I don't have the time to review your patches right now but I keep them in mind and will look over the weekend.  The optimizations are definitely cool!\nCheers,\n-Mihai\n. In fact, I think you are dealing only with assignments \u2014\u00a0but the question remains (I had in mind a more general idea to completely drop the variable \"a\" in cases like above, if it's used only once).  So the question for your patch should be, does:\na = computeSomething;\nb = somethingElse() - a;\ntransform to:\nb = somethingElse() - (a = computeSomething());\nIf so, I think it's not generally safe...\n. Related to issue #1 \u2014 let's track it there instead.\n. No longer current.\n. No longer current.  I suppose most users will prefer NPM now.\n. Thanks, pulled.\n. Reversed for now.  It seemed so simple and clear, but it's wrong...  Think that we take the first char (modulo 54), then divide n by 54, then take the next char modulo 64.  In order for this to return something bigger than 54 (so that we make use of 0123456789) we'd have to have floor(n/54) >= 54, which means that we only get to \"taste\" the optimization when there are more than 2915 variables in scope.  That's clearly wrong, and I fear that it might return duplicate values for different N-s less than 2915.\nIn my test on DynarchLIB it made no difference.\nA proper solution should do it backwards (in fact the whole base54 function is wrong, in that the returned string should be reversed; but it happens that we don't care about this, as they are valid identifiers anyway) \u2014 only the last digit should be taken base 54, the rest base 64, and the string reversed on return.\nSeems too complex to worth the trouble, though I'll look into it just for fun. ;-)\n. Oh, correction: it was reversed in my original code...\n. I don't dismiss this change, but I'm just wondering why you would need that?  The mangler should be smart enough not to touch any names that can be possibly used from some other place.\n. Sorry, this wins almost nothing and I don't think we should do it.  (Closure doesn't either, BTW).\n. No worries, I wasn't going to pull it. ;-)\n. Hmm, I won't apply this because then the following usage will break:\nuglifyjs source.js > output.js\n(as the debug output will go into the minified file).  Not sure about rake (never used it) but uglifyjs should exit with a normal status even if it warns, so rake should not see a problem.  Perhaps try to redirect stderr to /dev/null?  (or we can, and in fact should, have an option to keep quiet).\n. No longer current.\n. Thanks, pushed.  I'll expose it to the CLI later.\n. I'm pretty sure that it won't output any newlines if beautify is false.  Otherwise it's a bug.  Are you sure that works?  (sorry, can't check now, I will look later).\n. There is an `--ascii' option now that makes it easy to quote any non-ASCII characters in strings as \\uXXXX escapes.  That would be safer for users who don't bother to declare UTF-8 charset for .js on their servers.\nI'm not sure why only \\u2028' and\\u2029' should have special treatment.\n. Point taken, thanks, applied.\n. package.json is now fixed; as for one-step compression function I don't feel it's necessary (and yeah, definitely not in index.js, which doesn't exist anymore).\n. No longer current.\n. Just wondering, did you benchmark?  I don't think it saves anything..\n. I know the theory, but practice is sometimes different. ;-)  In that case you're creating a closure.  It'll have to switch scope every time it's called.  It's probably not slower, but I'm pretty sure it's not faster either, so that's why I was wondering whether you benchmarked it.  If it's about the same speed, then it doesn't worth cluttering the code.\n. comments (closed by 9c4fbf4a1081d544dec85e505553883c61ca34b6)\n. Thanks and sorry for the delay.\n. > you didn't like any of these?\nOnly this one eb01a831d5b41914173a4c8db89e189813640cb3 \u2014 I merged it manually.\nI'm not a fan of jslint, btw.\n. This was merged manually, thanks!\n. Thanks!\n. Looks like your patch caused issue #283 \u2014 I pushed a fix but I'm somewhat guessing. :-)  Could you take a look and see if it doesn't break the logic of your patch?\n. String.prototype.substr(start, length) is defined in ECMA-262 (ECMAScript 5th edition, section B.2.3).  Am I missing something?\n. There's nothing new about substr, it's been there forever and supported by all JS engines I know.  Perhaps IronJS is work in progress.\n. Your fix is incorrect because it drops the > or the whitespace character.  Anyway, I pushed something similar.\n. This patch is big and I'm against putting it in core.  If you care to separate it into another file, similar to ast_squeeze_more, then I'm willing to include.\nAs for the walker change, instead of exporting walkers you could use now w.dive(this) (it's new API)\u2014it allows you to recurse into the current node, ignoring the user-supplied walker for it, which I think is exactly what you need.\n. Thanks!\n. I would write another walk function instead, and export it as walk_postorder or something.\nIf I understand correctly, it applies the default walker first (A), then if there is an user-supplied walker it calls that too (B) and returns B or A.  Just wondering, what's the use case for this?\n. I think the easiest way would be to provide a walk_default function that would invoke only the default walker on a node, ignoring any user-provided walkers.  Thus in your handlers where you need depth-first you'd do w.walk_default(this), then do your own processing of the result.\nIt's pretty easy to add this, will do later.\n. Thanks for taking the time to write it, but your version seems more complex than needed.  I handled it differently, hope you'll be happy with it.  (just do new_node = w.dive(this) in a walker to go in-depth first, then work on/return new_node).\n. This one is buggy:\njs\n// problem 1: this.foo is dropped\nthis.foo = 0;\nthis.bar = 0;\nthis.baz = 0;\n// problem 2: b -= b += 5?\nif (a < 0) b += 5;\nelse b -= 5;\n===> uglified:\njs\nthis.baz = this.bar = 0, a < 0 && (b -= b += 5);\n. This is already handled in a more generic way \u2014 we always try to negate the IF condition to see if it leads to smaller code, and the \"negate\" function does optimize this case.  It appears to work now, do you know of a case when it doesn't?\n. @michaelficarra: ah, correct.  It's only for ifs:\necho 'if (a <= b) foo(); else bar()' | uglifyjs; echo\na>b?bar():foo()\n. > switching to an option parser [...] that would auto-generate usage docs would be a better approach.\nAgreed.  Patches? :-)\n. I modified slightly the regexp fix, so that's why it's not a direct merge.  Thanks!\n. The fix is good, but the problem doesn't exist. ;-)\n. What I meant is that there will never be a case of, for example, [ \"call\", [ \"defun\" ....  There will always be \"function\" instead of \"defun\", and \"function\" was already covered.  \"defun\" only appears as statement.\nIf there is a way to reproduce the bug, please let me know.\n. Yep, that's clear now, thanks.\n. Good catch, thanks!\n. The comments will be attached to the statement where the function is used.  For example if you have something like\njs\n// comment\nvar foo = function(){ ... }\nThe tree will be something like this:\njs\n[ \"stat\",\n  [ \"var\", [\n    [ \"foo\", [ \"function\" ... ]]]]]\nThe stat node will receive the comments.\nI can see why you need your patch, but OTOH I'm not sure it's correct from our perspective to duplicate the comments there.  You can easily walk the AST and keep track of the previous comment.\n. You were correct, sorry for I overlooked this.  The issue was that the token actually embedded was the name token, not the function one.  I fixed it in a different way which seems more correct, let me know if it's fine for you now.\n. @michaelficarra is right, and case closed.  This particular patch doesn't buy us anything.  A patch to keep all comments in the AST (while not breaking the uglifier) is welcome, but not an easy job to do.\n. Sorry, it's definitely not the place for that in UglifyJS.\nYour implementation is wrong too, btw \u2014 why should it leave the 'a' in the code?  By calling read_line_comment, you're only skipping to the end of current line, so okay, you discard the <!...EOL, but then you continue to parse code on the next lines although you didn't yet encounter the end marker -->.  If you want it to work properly, it should be similar to read_multiline_comment.  Just FYI, I won't include it anyway.\n. Your example is incorrect compression because in the original code the significant argument was the third, and in the compressed code it's the first (hint: to make that work you'd have to track down where the function is called, and discard the first two arguments as well; almost impossible).\nUglifyJS explicitly prevents that from happening (which is why your code is actually simpler).\n. This has been tried before (5b2c91be0c63777e759c9baa6aa927fd56b4346c) but I rolled it back; I know it caused some problems, but I forgot what it was..  I'm holding it off for now.\n. @michaelficarra: I know.. I'm sorry about that.  I remember I ran compression on a big app, noticed some runtime problems and rolled it back without investigating further.\nI'll give it another try but personally I dislike the idea because it feels wrong (it's not base54 nor base64) and it doesn't buy much \u2014 I can't imagine code crazy enough to have more than a few hundred variables visible in scope, and that's well handled by the existing base54.\n. Maybe there was another issue, I couldn't find any problems now.  Merged.\n. I'm afraid this might break API for code that expects the plain property name, if it's really useful in some cases we could perhaps add an option for it and keep it off by default?\n. This is quite a comprehensive patch, thanks for it!\nQuestion, why not making those variables global?\n. Also, thanks for making it a separate step!  That's indeed the proper way to do it.\n. Fair enough...  The way I'm usually building my apps involves dumping all the scripts into a single big .js file and minifying that \u2014 so if I don't rely on any other scripts, this kind of bug would not bite me.  But I agree it can be bad in general.\n. Thanks!\n. Might also wanna check that args[0][0] == \"num\"?\n. Sorry for forgetting about this for so long.\nIn any case, in UglifyJS2 the interface is a bit simpler \u2014\u00a0you just pass a JS constant, not an AST.\n. This closes #370, right?\nEdit: right, just noticed you closed it.\n. Nice one, thanks!\n. I didn't even test it, but I think it's a good idea.  Yeah, we should think about the dynamic version, that'll be a lot better in general.  Any case, for now patch accepted \u2014\u00a0if it shaves 100b on jQuery then great, thanks! ;-)\n. Side note: because of the way planets are aligned, I can't run nodeunit right now to see how all the tests fail.\nThis patch is a nice example of a perfectly valid improvement which breaks all the tests, confirming my belief that unit testing (at least the way we think of it today) is not such a good idea.\n. I still didn't bother to get nodeunit working, but your patch looks good to me. Thanks.\n. I missed walking the arguments and it's pretty important.  Also, npm commands worked\u00a0\u2014 thanks.\n. @rvanvelzen good catch.  It calls for a lot more complicated fix.\nCode generator is probably the most complex part of UglifyJS.\n. Yep, fixing it at AST-level seems like a better idea.  I'll push this tomorrow.\n. It's not acceptable to modify the member function like that.  Feel free to modify get_mangled (in process.js in function ast_mangle) to do a custom loop through the names instead of calling member.\n. Thanks!\n. ",
    "WizKid": "the find_first_execute function only looks for the first thing that will be executed. So it will only move it in if the variable is the first thing that is executed in the next statement. Just so we don't move the order of statements.\nSo it will compress:\n    longvar = func1();b=longvar-func2();\n    ->\n    b=(longvar=func1())-func2()\nBut not:\n    longvar = func1();b=func2()-longvar;\n    ->\n    longvar=func1(),b=func2()-longvar\n. Sound like there should be a argument to Uglify if standard classes like Array, Object, Boolean and similar can be minified or not. Because I guess most people don't changes them but there are probably someone that does.\n. the find_first_execute function only looks for the first thing that will be executed. So it will only move it in if the variable is the first thing that is executed in the next statement. Just so we don't move the order of statements.\nSo it will compress:\n    longvar = func1();b=longvar-func2();\n    ->\n    b=(longvar=func1())-func2()\nBut not:\n    longvar = func1();b=func2()-longvar;\n    ->\n    longvar=func1(),b=func2()-longvar\n. Sound like there should be a argument to Uglify if standard classes like Array, Object, Boolean and similar can be minified or not. Because I guess most people don't changes them but there are probably someone that does.\n. ",
    "michaelficarra": "What is the desired output for 0.0000100? 1e-5? 100e-7? 1.00e-5? Something else? We should decide this before merging the commit. We need to make a decision about significant digit preservation. After this decision is made, we can write some test cases and you can make your solution conform to that.\n. I think the proper way to express the number would be 1.00e-5, but I was never a fan of preserving significant digits, especially when attempting to minify code. I'd go with 1e-5 as well.\n. Alright, that was painful. Had some git problems there. Anyway, the break statement was inserted. Good now?\n. ping\n. ping?\n. This brings up concerns similar to those in the recent discussion about the Array constructor. I agree with lautis that the usefulness of this commit is definitely questionable. Who writes code like that? It has been shown over and over that double-notting (!!) is a shorter and more efficient way to do boolean coercion. It can only break things by accepting this commit, and no real project will receive any benefit. I feel the same way about the Array minification commits.\n. There's a problem with your new commits. Boolean(0,1) is not !!(0,1). The comma operator returns the value from the last expression, not the first.\n. Awesome. Great enhancement, csnover.\n. ping\n. Yeah, I think this one should be reopened. It looks good to me, and it will until I hear a real argument against it.\n. Didn't benchmark, but I am certain it is better. There are fewer property accesses. This is a common practice and should be adopted as long as it benches at <= the current time.\n. @mishoo: ping\n. Nice, I like it. +1\n. This is completely undocumented as of right now. Some documentation would be nice.\n. I like all of these except \"81fdb2d Insured from semicolon insertion\" and \"ac03f9f Stylistic modifications in \"parse-js.js\" for the sake of jslint\". The first is unnecessary and makes the code slightly less readable, and the second is god-awful. Readable code is more important than passing JSLint ... which is not important at all.\n. > I thought that a (bad) browser may put a semicolon in the end of a line without looking at the next line.\nCommon misconception. Even IE6 does proper automatic semicolon insertion. See http://inimino.org/~inimino/blog/javascript_semicolons\n. @mishoo: you didn't like any of these?\n. I think the only other one I'd pull in is fb0f9984be3823e9cb81c158e92c2ed97fac47ac. And I definitely share your sentiments about jslint.\n. I don't like this. If we see a \"\\v\", the author obviously wasn't targetting IE<=8. If they were, they would have written \"\\u000b\" in the first place. I think we should revert this. At the very least, \"\\x0b\" is smaller.\nedit: never mind\n. @thorn0: You're right. I was assuming that people were compiling using the engine they were targeting, which is obviously not a safe assumption. I've edited my post.\n. I like it. +1.\n. @mishoo: I don't see it:\n$ echo 'a <= b ? c : d' | bin/uglifyjs; echo\na<=b?c:d\n$\n. @mishoo: so, re-open?\n. I think switching to an option parser (like harthur/nomnom) that would auto-generate usage docs would be a better approach.\n. Nice. LGTM\n. @paulbaumgart: can you post a problematic compilation?\n. update: ignore this post\n@paulbaumgart:\n\nthe valid JS: (function(){}) Becomes the invalid function declaration: function(){}\n\nThen it looks like you've stumbled onto a legitimate bug, but fixed it in the wrong place. The bug is the incorrect parse of (function(){}) as a defun instead of the function expression that it is. So rather than wrapping defuns without names in parentheses, we should be correcting that parse. Though, it would still be appropriate to have a sanity check that prevents defuns from being output without names.\n. Oh, well it looks like I was mistaken then. And so was @mishoo. I think we should probably re-open this.\nedit: by the way, thanks for being persistent\n. No, no, no. -g shouldn't be used on shared machines. Just add ~/node_modules (or wherever npm is configured to put binaries) to your PATH. Installing everything to system directories was not the intended use of npm. If it was, it wouldn't require a special flag.\n. Sorry, I'm not a collaborator. I believe @mishoo is the only one with push access to this repo. But if you make a nice pull request with the kind of documentation you'd like (that doesn't encourage users to mess with anything outside their home directory), I'm sure he'd pull it.\n. LGTM. +1\n. @mathiasbynens: I hope you know that this isn't going to cause UglifyJS to preserve all comments that appear to be licenses, just the initial comment(s) in the file. So UglifyJS will actually be outputting fewer comments than before.\n. Nope, we still drop all comments that aren't at the start of the file. They never even enter the AST, and this doesn't change that.\n. +1\n. @mishoo: it appears no reason was given: ae50289816da1e20403726f7e943aff0605004d9\n. @mishoo: the original implementation seemed a little cleaner and more efficient. Maybe you'd want to go with that instead?\n. Don't use try/catch for program control flow. Define function needsContextCaching(body){} or something.\nAlso, you're adding a that variable to the body (assigning this to it), but you aren't checking that the body doesn't already contain a that variable.\nedit: I see you're inside a function already (many_this), and using the try/catch to escape from the walker function. That's a little trickier. I'll think about an improvement for that. If only we had block lambdas!\n. Instead of bailing out when you see a variable named mangle_my_this_ref__, why not continually change it until it's no longer in scope?\n. It'd actually be shorter: while(HOP(body.scope.refs, that)) that += '_';\n. Why not pass options.except instead?\n. In my opinion, that would be a better interface to next_mangled.\n. ... this doesn't look like it would work. Did you forget some commits? Also, no tests?\n. > Am I overlooking something?\nNo, you're not overlooking them. Tests for the API don't exist :(.\nAlso, I now see that you aren't meant to pass in an arbitrary delimiter character, but actually just choose between ' or \" as the delimiter for all strings, regardless of which representation is shorter. I don't see the usefulness of this. If you're representing the string containing the character data '\", either representation would cause problems for you. It just needs to be properly escaped when inserted into the HTML attribute. This is the same problem discussed in the horrid #164.\n. Was the list weighted by how common each reserved word is in real-world code? I bet function is an extremely common keyword, so its characters should have a higher weight, pushing e out of that front position. Also surprising: 5 has a higher precedence than 1. Remember that numbers are used outside of identifiers, and I bet adding/subtracting 1 in an expression is a common task (length + 1, you get the idea). I don't think this is acceptable yet, at least not without a better explanation of the methodology. -1 for now.\nedit: @ralphholzmann has a much better approach.\n. LGTM\n. Why would that be useful?\n. Patch works for me. Build now takes ~5 seconds. @mishoo: can you review/merge this?\n. A more general solution would be to provide a function. The function could test a regex or do any number of things.\n. What is the desired output for 0.0000100? 1e-5? 100e-7? 1.00e-5? Something else? We should decide this before merging the commit. We need to make a decision about significant digit preservation. After this decision is made, we can write some test cases and you can make your solution conform to that.\n. I think the proper way to express the number would be 1.00e-5, but I was never a fan of preserving significant digits, especially when attempting to minify code. I'd go with 1e-5 as well.\n. Alright, that was painful. Had some git problems there. Anyway, the break statement was inserted. Good now?\n. ping\n. ping?\n. This brings up concerns similar to those in the recent discussion about the Array constructor. I agree with lautis that the usefulness of this commit is definitely questionable. Who writes code like that? It has been shown over and over that double-notting (!!) is a shorter and more efficient way to do boolean coercion. It can only break things by accepting this commit, and no real project will receive any benefit. I feel the same way about the Array minification commits.\n. There's a problem with your new commits. Boolean(0,1) is not !!(0,1). The comma operator returns the value from the last expression, not the first.\n. Awesome. Great enhancement, csnover.\n. ping\n. Yeah, I think this one should be reopened. It looks good to me, and it will until I hear a real argument against it.\n. Didn't benchmark, but I am certain it is better. There are fewer property accesses. This is a common practice and should be adopted as long as it benches at <= the current time.\n. @mishoo: ping\n. Nice, I like it. +1\n. This is completely undocumented as of right now. Some documentation would be nice.\n. I like all of these except \"81fdb2d Insured from semicolon insertion\" and \"ac03f9f Stylistic modifications in \"parse-js.js\" for the sake of jslint\". The first is unnecessary and makes the code slightly less readable, and the second is god-awful. Readable code is more important than passing JSLint ... which is not important at all.\n. > I thought that a (bad) browser may put a semicolon in the end of a line without looking at the next line.\nCommon misconception. Even IE6 does proper automatic semicolon insertion. See http://inimino.org/~inimino/blog/javascript_semicolons\n. @mishoo: you didn't like any of these?\n. I think the only other one I'd pull in is fb0f9984be3823e9cb81c158e92c2ed97fac47ac. And I definitely share your sentiments about jslint.\n. I don't like this. If we see a \"\\v\", the author obviously wasn't targetting IE<=8. If they were, they would have written \"\\u000b\" in the first place. I think we should revert this. At the very least, \"\\x0b\" is smaller.\nedit: never mind\n. @thorn0: You're right. I was assuming that people were compiling using the engine they were targeting, which is obviously not a safe assumption. I've edited my post.\n. I like it. +1.\n. @mishoo: I don't see it:\n$ echo 'a <= b ? c : d' | bin/uglifyjs; echo\na<=b?c:d\n$\n. @mishoo: so, re-open?\n. I think switching to an option parser (like harthur/nomnom) that would auto-generate usage docs would be a better approach.\n. Nice. LGTM\n. @paulbaumgart: can you post a problematic compilation?\n. update: ignore this post\n@paulbaumgart:\n\nthe valid JS: (function(){}) Becomes the invalid function declaration: function(){}\n\nThen it looks like you've stumbled onto a legitimate bug, but fixed it in the wrong place. The bug is the incorrect parse of (function(){}) as a defun instead of the function expression that it is. So rather than wrapping defuns without names in parentheses, we should be correcting that parse. Though, it would still be appropriate to have a sanity check that prevents defuns from being output without names.\n. Oh, well it looks like I was mistaken then. And so was @mishoo. I think we should probably re-open this.\nedit: by the way, thanks for being persistent\n. No, no, no. -g shouldn't be used on shared machines. Just add ~/node_modules (or wherever npm is configured to put binaries) to your PATH. Installing everything to system directories was not the intended use of npm. If it was, it wouldn't require a special flag.\n. Sorry, I'm not a collaborator. I believe @mishoo is the only one with push access to this repo. But if you make a nice pull request with the kind of documentation you'd like (that doesn't encourage users to mess with anything outside their home directory), I'm sure he'd pull it.\n. LGTM. +1\n. @mathiasbynens: I hope you know that this isn't going to cause UglifyJS to preserve all comments that appear to be licenses, just the initial comment(s) in the file. So UglifyJS will actually be outputting fewer comments than before.\n. Nope, we still drop all comments that aren't at the start of the file. They never even enter the AST, and this doesn't change that.\n. +1\n. @mishoo: it appears no reason was given: ae50289816da1e20403726f7e943aff0605004d9\n. @mishoo: the original implementation seemed a little cleaner and more efficient. Maybe you'd want to go with that instead?\n. Don't use try/catch for program control flow. Define function needsContextCaching(body){} or something.\nAlso, you're adding a that variable to the body (assigning this to it), but you aren't checking that the body doesn't already contain a that variable.\nedit: I see you're inside a function already (many_this), and using the try/catch to escape from the walker function. That's a little trickier. I'll think about an improvement for that. If only we had block lambdas!\n. Instead of bailing out when you see a variable named mangle_my_this_ref__, why not continually change it until it's no longer in scope?\n. It'd actually be shorter: while(HOP(body.scope.refs, that)) that += '_';\n. Why not pass options.except instead?\n. In my opinion, that would be a better interface to next_mangled.\n. ... this doesn't look like it would work. Did you forget some commits? Also, no tests?\n. > Am I overlooking something?\nNo, you're not overlooking them. Tests for the API don't exist :(.\nAlso, I now see that you aren't meant to pass in an arbitrary delimiter character, but actually just choose between ' or \" as the delimiter for all strings, regardless of which representation is shorter. I don't see the usefulness of this. If you're representing the string containing the character data '\", either representation would cause problems for you. It just needs to be properly escaped when inserted into the HTML attribute. This is the same problem discussed in the horrid #164.\n. Was the list weighted by how common each reserved word is in real-world code? I bet function is an extremely common keyword, so its characters should have a higher weight, pushing e out of that front position. Also surprising: 5 has a higher precedence than 1. Remember that numbers are used outside of identifiers, and I bet adding/subtracting 1 in an expression is a common task (length + 1, you get the idea). I don't think this is acceptable yet, at least not without a better explanation of the methodology. -1 for now.\nedit: @ralphholzmann has a much better approach.\n. LGTM\n. Why would that be useful?\n. Patch works for me. Build now takes ~5 seconds. @mishoo: can you review/merge this?\n. A more general solution would be to provide a function. The function could test a regex or do any number of things.\n. ",
    "fintanf": "Ah yes, I hadn't thought about trailing zeroes, I had just fixed the error I'd seen.\nMy preference (for your example) would be 1e-5.\n. Ah yes, I hadn't thought about trailing zeroes, I had just fixed the error I'd seen.\nMy preference (for your example) would be 1e-5.\n. ",
    "lautis": "Thought of this a bit and Boolean() seems to be equivalent of !! in all cases, even when there is more than one parameter. This is perhaps slightly more justifiable optimization.\nWho writes code like that is a good question.\n. michaelficarra, thanks for pointing that out. Minifying Boolean() with !! doesn't seem feasible when there's multiple arguments involved.\nIMHO, Boolean, Array and Object optimizations would fit --unsafe option.\n. Thought of this a bit and Boolean() seems to be equivalent of !! in all cases, even when there is more than one parameter. This is perhaps slightly more justifiable optimization.\nWho writes code like that is a good question.\n. michaelficarra, thanks for pointing that out. Minifying Boolean() with !! doesn't seem feasible when there's multiple arguments involved.\nIMHO, Boolean, Array and Object optimizations would fit --unsafe option.\n. ",
    "jdalton": "+1, I <3 this!\n. +1, I <3 this!\n. ",
    "cadorn": "I am using it to mangle CommonJS/AMD code where the declarations must stay in tact in order for the browser loader to be able to identify and call the factory function appropriately and scrape the require() dependencies.\nFor example, the following must stay in tact.\ndefine(function(require, exports, module) { require(\"foo\"); });\nIf this ends up being the only use-case we could add a flag instead and reserve the three variables automatically, but I thought I would make it more generic in case other variables pop up which may happen.\n. I am using it to mangle CommonJS/AMD code where the declarations must stay in tact in order for the browser loader to be able to identify and call the factory function appropriately and scrape the require() dependencies.\nFor example, the following must stay in tact.\ndefine(function(require, exports, module) { require(\"foo\"); });\nIf this ends up being the only use-case we could add a flag instead and reserve the three variables automatically, but I thought I would make it more generic in case other variables pop up which may happen.\n. ",
    "satyr": "\nthis wins almost nothing\n- typeof x === '...' is a common operation (jQuery uses this form, for example).\n- === and !== are essential and frequently used.\nI don't think we should do it\n\nhttp://dmitrysoshnikov.com/ecmascript/note-2-ecmascript-equality-operators/\n\n(Closure doesn't either, BTW).\n\nOne more point against it, no?\n. > this wins almost nothing\n- typeof x === '...' is a common operation (jQuery uses this form, for example).\n- === and !== are essential and frequently used.\n\nI don't think we should do it\n\nhttp://dmitrysoshnikov.com/ecmascript/note-2-ecmascript-equality-operators/\n\n(Closure doesn't either, BTW).\n\nOne more point against it, no?\n. ",
    "marijnh": "Heh. I like where this is going. You could even port the type inferrer at https://github.com/akapav/js/blob/master/infer.lisp for more powerful type reasoning. (Convert x==\"\" to !x when x is known to be string, and so on.)\n. Heh. I like where this is going. You could even port the type inferrer at https://github.com/akapav/js/blob/master/infer.lisp for more powerful type reasoning. (Convert x==\"\" to !x when x is known to be string, and so on.)\n. ",
    "vannitotaro": "Hey, mishoo!\nWith\n\nI did not know how to exclude a commit from a pull request\n\nI did not mean to exclude all the patches from the pull request, but only one of the two commits! :)\nOK for not pulling node -> nodejs (commit 7a688541),\nbut what about pulling the regex fix (commit 30b7977)?\nAs michaelficarra pointed out here https://github.com/mishoo/UglifyJS/issues#issue/89/comment/754824 it shoud be fixed.\n. Hey, mishoo!\nWith\n\nI did not know how to exclude a commit from a pull request\n\nI did not mean to exclude all the patches from the pull request, but only one of the two commits! :)\nOK for not pulling node -> nodejs (commit 7a688541),\nbut what about pulling the regex fix (commit 30b7977)?\nAs michaelficarra pointed out here https://github.com/mishoo/UglifyJS/issues#issue/89/comment/754824 it shoud be fixed.\n. ",
    "Leonya": "Right, I didn't see that... In fact, I tried redirecting stderr to stdout before doing this patch, it didn't help. Actually, this debug output should probably just respect the --verbose flag since a CLI app should be silent by default anyway. As for terminating on stderr - this is a default behaviour of most build systems. rake does this, GNU make does this as well.\n. Right, I didn't see that... In fact, I tried redirecting stderr to stdout before doing this patch, it didn't help. Actually, this debug output should probably just respect the --verbose flag since a CLI app should be silent by default anyway. As for terminating on stderr - this is a default behaviour of most build systems. rake does this, GNU make does this as well.\n. ",
    "sstephenson": "Here's how the distributable version looks: http://dl.dropbox.com/u/6759414/uglify.js\n. Here's how the distributable version looks: http://dl.dropbox.com/u/6759414/uglify.js\n. ",
    "wbzyl": "Please remove the trailing comma. \n--W\u0142odek Bzyl\n. Please remove the trailing comma. \n--W\u0142odek Bzyl\n. ",
    "timruffles": "so running the build 3 times with:\nindent_level: 0                        = newlines, with no indents\nindent_level: 0, beautiful: false = newlines, with no indents\nnothing                                   = minified\nSo at the mo the simplest way of preserving newlines is indent_level: 0.\n. so running the build 3 times with:\nindent_level: 0                        = newlines, with no indents\nindent_level: 0, beautiful: false = newlines, with no indents\nnothing                                   = minified\nSo at the mo the simplest way of preserving newlines is indent_level: 0.\n. ",
    "chriskr": "It's not about a missing UTF-8 charset declaration on the server, the file in question has actually a lot of UTF-8 chars outside the ASCII range. The chars in question need special treatment, if they are part of a string, because they are newline chars, on parsing you treat them differently too ($TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\") in parse-js.js). Not treating them specially in a string in make_string will return a broken string.\n. Thanks too!\n. It's not about a missing UTF-8 charset declaration on the server, the file in question has actually a lot of UTF-8 chars outside the ASCII range. The chars in question need special treatment, if they are part of a string, because they are newline chars, on parsing you treat them differently too ($TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\") in parse-js.js). Not treating them specially in a string in make_string will return a broken string.\n. Thanks too!\n. ",
    "Sannis": "Maybe it is better to use Markdown for this, and ronn to convert it to uglifyjs.1?\n. Maybe it is better to use Markdown for this, and ronn to convert it to uglifyjs.1?\n. ",
    "marcelometal": "Hi Sannis, I made initial version of manpage for Debian. Feel free to convert it. ;)\n. Hi Sannis, I made initial version of manpage for Debian. Feel free to convert it. ;)\n. ",
    "MadRabbit": "maybe you could make a simple one-step compression interface in some other place where you see it fits? we use ugly in many projects with pure node and it's a bit nagging to copypaste that bit of code. Mean, normally all you need is just to compress a string and it feels wrong to make those parsing/generating calls explicitly all the time.\nAnyhow, thanks for your work and please keep it up!\n. maybe you could make a simple one-step compression interface in some other place where you see it fits? we use ugly in many projects with pure node and it's a bit nagging to copypaste that bit of code. Mean, normally all you need is just to compress a string and it feels wrong to make those parsing/generating calls explicitly all the time.\nAnyhow, thanks for your work and please keep it up!\n. ",
    "stephank": "I'm guessing what I just found is related to this.\nThe following breaks:\na({ b: (c, d) });\nThe CLI throws an exception, while using Uglify as a library miscompiles this into the following invalid code:\na({b:c,d})\nTake away the function call or the sequence and it works, but the combination seems to be problematic.\nCoffeeScript generates this kind of code for the following, for example:\nmodel.set favorite: model.id in favorites\n. Ah, I missed that just { b: (c, d) } also miscompiles. You're absolutely right.\n. I'm guessing what I just found is related to this.\nThe following breaks:\na({ b: (c, d) });\nThe CLI throws an exception, while using Uglify as a library miscompiles this into the following invalid code:\na({b:c,d})\nTake away the function call or the sequence and it works, but the combination seems to be problematic.\nCoffeeScript generates this kind of code for the following, for example:\nmodel.set favorite: model.id in favorites\n. Ah, I missed that just { b: (c, d) } also miscompiles. You're absolutely right.\n. ",
    "schmerg": "Er, I'm still seeing the error without the outer function call, that is\nsomevar = { b: (c,d) };\nthrows, and\n{ b: (c,d) }\nget incorrectly minifed as\nb: (c,d)\n(that is, it loses the outer curly braces) whereas\n``` a=(c,d)\nis handled properly, so my first feeling is that it's the object literal code.\nI also notice that if you're not running the minify steps (eg call with --beautify) then the construct is parsed but written incorrectly\na({b:(c,d)})\nbecomes\na({\n    b: c, d\n});\nwhich is wrong as d has now become a dangling key, so it suggest to me that the error is in the AST representation.\nI'm in the middle of something now, but will try to have a look at this in the next day or two...\n``````\n. OK, so I've found it - the problem is in the generation of code. That is, it parses the exp fine but generates the seq without parentheses, and the error is thrown because, as a check, the generated code is run thru the parser again (that's why the \"--beautify\" call can be handy as it doesn't do the re-parse step).\nSo when generating code for the value for an object, it calls the plain 'val = make(p[1])' when it should be calling 'val = parenthesize(p[1], \"seq\")' (a routine that explicitly makes the value, and parenthesizes it it's a seq). The generation for \"throw\" looks to have the same error. I'll prepare a seperate path and make a pull request, but if you want to patch your own in the meantime, it's around line 1400 of process.js\n. Issue reported as #180 and fix submitted as 38358b7a7e2d214b711b4f52b8d932b312502d90\n. Apologies, I held back on writing docs expecting people may want changes...\nI m away for a few days but will write some docs and submit a pull request\n On 29 Apr 2011 15:48, \"michaelficarra\" \nreply@reply.github.com\nwrote:\n\nThis is completely undocumented as of right now. Some documentation would\nbe nice.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mishoo/UglifyJS/pull/137#issuecomment-1075588\n. Documentation added to README.html and README.org (realising that the former is constructed from the latter, but is perhaps easier to read and comment upon) and pull request issued\nhttps://github.com/mishoo/UglifyJS/pull/141\n. Actually it probably only needs the last commit - the first commit edits the README.html which is generated from the the .org file\n. Er, I'm still seeing the error without the outer function call, that is\nsomevar = { b: (c,d) };\nthrows, and\n{ b: (c,d) }\nget incorrectly minifed as\nb: (c,d)\n(that is, it loses the outer curly braces) whereas\n\n``` a=(c,d)\nis handled properly, so my first feeling is that it's the object literal code.\nI also notice that if you're not running the minify steps (eg call with --beautify) then the construct is parsed but written incorrectly\na({b:(c,d)})\nbecomes\na({\n    b: c, d\n});\nwhich is wrong as d has now become a dangling key, so it suggest to me that the error is in the AST representation.\nI'm in the middle of something now, but will try to have a look at this in the next day or two...\n``````\n. OK, so I've found it - the problem is in the generation of code. That is, it parses the exp fine but generates the seq without parentheses, and the error is thrown because, as a check, the generated code is run thru the parser again (that's why the \"--beautify\" call can be handy as it doesn't do the re-parse step).\nSo when generating code for the value for an object, it calls the plain 'val = make(p[1])' when it should be calling 'val = parenthesize(p[1], \"seq\")' (a routine that explicitly makes the value, and parenthesizes it it's a seq). The generation for \"throw\" looks to have the same error. I'll prepare a seperate path and make a pull request, but if you want to patch your own in the meantime, it's around line 1400 of process.js\n. Issue reported as #180 and fix submitted as 38358b7a7e2d214b711b4f52b8d932b312502d90\n. Apologies, I held back on writing docs expecting people may want changes...\nI m away for a few days but will write some docs and submit a pull request\n On 29 Apr 2011 15:48, \"michaelficarra\" \nreply@reply.github.com\nwrote:\n\nThis is completely undocumented as of right now. Some documentation would\nbe nice.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mishoo/UglifyJS/pull/137#issuecomment-1075588\n. Documentation added to README.html and README.org (realising that the former is constructed from the latter, but is perhaps easier to read and comment upon) and pull request issued\nhttps://github.com/mishoo/UglifyJS/pull/141\n. Actually it probably only needs the last commit - the first commit edits the README.html which is generated from the the .org file\n. \n",
    "busticated": "+1 for the:\nif ( false ) {\n    // do stuff\n}\ndead branch removal optimization.\n. +1 for the:\nif ( false ) {\n    // do stuff\n}\ndead branch removal optimization.\n. ",
    "aaronblohowiak": "Giving credit where it is due, this was at the behest of SubStack, but thanks for the +1\n. Anything I can do to make this more appealing, @mishoo?\n. Giving credit where it is due, this was at the behest of SubStack, but thanks for the +1\n. Anything I can do to make this more appealing, @mishoo?\n. ",
    "tav": "Here's the direct link to the issue for those of who haven't been following the conversation:\n- https://github.com/mishoo/UglifyJS/issues/125\n. Nice work with the documentation @schmerg.\n@mishoo, just want to flag up that only the 2 most recent commits need to be cherry-picked...\nThanks guys!\n. Here's the direct link to the issue for those of who haven't been following the conversation:\n- https://github.com/mishoo/UglifyJS/issues/125\n. Nice work with the documentation @schmerg.\n@mishoo, just want to flag up that only the 2 most recent commits need to be cherry-picked...\nThanks guys!\n. ",
    "JakeWharton": "I have decided this is outside the scope of the project and is trivial to implement as a standalone add-on. It is available at https://github.com/JakeWharton/uglify-js-middleware.\n. I have decided this is outside the scope of the project and is trivial to implement as a standalone add-on. It is available at https://github.com/JakeWharton/uglify-js-middleware.\n. ",
    "nodirt": "Well, I came from .NET where I'm used to some static checking.\nI guess I should have put my stylistic changes to a separate branch to keep them private.\nAs for semicolon insertion, are you sure it is unnecessary? Can't it cause problems with IE6 or something? I thought that a (bad) browser may put a semicolon in the end of a line without looking at the next line.\n. Thanks. I didn't know that\n. Well, I came from .NET where I'm used to some static checking.\nI guess I should have put my stylistic changes to a separate branch to keep them private.\nAs for semicolon insertion, are you sure it is unnecessary? Can't it cause problems with IE6 or something? I thought that a (bad) browser may put a semicolon in the end of a line without looking at the next line.\n. Thanks. I didn't know that\n. ",
    "strager": "Looks good to me.\n. Looks good to me.\n. ",
    "asbjornu": "Oh, I didn't know. ECMAScript 5 is probably so new that some more esoteric JS engines haven't implemented it yet, like IronJS. I'll see whether the support for it can be patched in there. Thanks!\n. True. In browser engines (like V8, which node.js uses), substr has been supported for years. But since it's not defined in ECMA-262 until recently, it's understandable that engines based on ECMA-262 (and not what browsers have to support) don't support substr. However, to achieve ES5 compliancy those engines of course need to implement the substr function, so they might as well do it now rather than later.\nIronJS is indeed work in progress; the current version is only 0.2. I'll see what I can do to get substr support in it. Thanks!\n. Oh, I didn't know. ECMAScript 5 is probably so new that some more esoteric JS engines haven't implemented it yet, like IronJS. I'll see whether the support for it can be patched in there. Thanks!\n. True. In browser engines (like V8, which node.js uses), substr has been supported for years. But since it's not defined in ECMA-262 until recently, it's understandable that engines based on ECMA-262 (and not what browsers have to support) don't support substr. However, to achieve ES5 compliancy those engines of course need to implement the substr function, so they might as well do it now rather than later.\nIronJS is indeed work in progress; the current version is only 0.2. I'll see what I can do to get substr support in it. Thanks!\n. ",
    "RGustBardon": "Already fixed in 6a873a7757895fdc06501854e4ba84e15c12a74a.\n. javascript\nif (0 === Math.random()) {\n  _ = 0;\n}\n``` javascript\nvar _ = '';\nif (0 === Math.random()) {\n  _ += 42;\n}\nif (-1 !== _.indexOf('0')) {\n  throw new Error();\n}\n```\njavascript\n!function() {\n  Object.defineProperty(this, '_', {\n    get: function() {\n      throw new Error();\n    }\n  });\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}();\njavascript\n!function() {\n  Object.defineProperty(this, '_', {\n    set: function(v) {\n      throw new Error();\n    }\n  });\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}();\njavascript\nwith ({\n  get _() {\n    throw new Error();\n  }\n}) {\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}\njavascript\nwith ({\n  set _(v) {\n    throw new Error();\n  }\n}) {\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}\n``` javascript\nvar Foo = function() {\n};\nFoo.prototype.toString = function() {\n  throw new Error();\n};\nvar _ = new Foo();\nif (0 === Math.random()) {\n  _ += 42;\n}\n```\n``` javascript\nvar Foo = function() {\n};\nFoo.prototype.valueOf = function() {\n  throw new Error();\n};\nvar _ = new Foo();\nif (0 === Math.random()) {\n  _ += 42;\n}\n```\n. This patch has been merged as b8c7715561d1555776f75b3cc7d33bf69cda19aa.\n. Some pitfalls in dbf2df3a45fbafaec7326eda060ee72dd7c8695e:\njavascript\nvar foo = {}, bar = '_baz';\nfoo._baz = 42;\nconsole.log('number' === typeof foo[bar]);\nconsole.log(foo.hasOwnProperty('_baz'));\nconsole.log(-1 !== Object.keys(foo).indexOf('_baz'));\nwith (foo) {\n  console.log('number' === typeof _baz);\n}\n. Duplicate of issue #219.\n. Fails when no source elements are present. When it comes to global code, it fails when a program is empty. When it comes to function code, it fails when it comes to\njavascript\n!function() {\n};\nbut not when it comes to\njavascript\n!function() {\n  42;\n};\nIt is assumed (in the EqualityExpression in line 913) that body has at least one element. \n. Results in more source characters in a scope where no mangling takes place (cf. Scope.prototype.get_mangled in ./lib/process.js).\n``` javascript\n!function() {\n  !function() {\n    eval('');\n  };\n  void [typeof this, typeof this, typeof this, typeof this];\n};\n!function() {\n  !function() {\n    with ({});\n  };\n  void [typeof this, typeof this, typeof this, typeof this];\n};\n```\nAdds a variable declaration in the global scope.\njavascript\nvoid [typeof this, typeof this, typeof this, typeof this];\n. this could be consolidated in the global scope by employing a closure (if it results in less source characters).\nbash\nuglifyjs -c <<ENDH\nvoid [null, null, null, null, null, null, null, null, null, null];\nwith ({});\nvoid [null, null, null, null, null, null, null, null, null, null];\nENDH\nLine 973 of ./lib/process.js (5523a29d55e9bd5fcb9143058f164a3b3c86fbb1) calls unshift on the body. This turns a Directive Prologue into an expendable sequence of StringLiteral tokens.\njavascript\n!function() {\n  'foo';\n  'bar';\n  void [typeof this, typeof this, typeof this, typeof this];\n};\n. @curiousdannii It has been claimed otherwise in #228.\n. Thank you for pulling the patch.\n\nwhy not making those variables global?\n\nUnobtrusiveness of new variables was a design goal. Consolidation of jQuery 1.7.1 uses identifier names up to gv. Global variables could be overwritten by another script added to a Web page. For instance, this scenario could happen with two independent scripts available from a content delivery network.\nWhat follows is a small demonstration of the problem.\nsh\n$ echo \"var quux = 42;\" > foo.js\n$ echo \"var quux = 'baz';\" > bar.js\nhtml\n<!DOCTYPE html>\n<meta charset=\"UTF-8\" />\n<title></title>\n<script type=\"application/ecmascript\" src=\"foo.js\"></script>\n<script type=\"application/ecmascript\" src=\"bar.js\"></script>\n<script type=\"application/ecmascript\">console.log(typeof quux);</script>\n. All the methods use the abstract operation ToInteger for the argument matching their first formal parameter.\njavascript\nconsole.log(\"abcdef\".slice(\"2\"), \"abcdef\".substr(\"2\"), \"abcdef\".substring(\"2\"));\n. Due to an extra next() (line 579 of ./lib/parse-js.js):\n- $ echo '/**/' | uglifyjs results in an error,\n- $ echo '/*a*/' | uglifyjs results in another error,\n- $ echo '/*ab*/' | uglifyjs results in /*b*/;.\n. @paulbaumgart : Thank you for reviewing this pull request. A fix has also been pushed for #331.\n. When it comes to evaluating the production MemberExpression : MemberExpression [ Expression ], this is to be expected. Relevant steps are as follows:\n1. \u201cDivision of a nonzero finite value by a zero results in a signed infinity.\u201d (11.5.2).\n2. \u201cLet propertyNameReference be the result of evaluating Expression.\u201d (11.2.1).\n3. \u201cLet propertyNameValue be GetValue(propertyNameReference).\u201d (11.2.1).\n4. \u201cIf Type(V) is not Reference, return V.\u201d (8.7.1)\n5. \u201cLet propertyNameString be ToString(propertyNameValue).\u201d (11.2.1).\n6. \u201cIf m is infinity, return the String \"Infinity\".\u201d (9.8.1).\nWould it not be more consequent to replace Number.NaN with 0/0 instead of NaN?\n. As suggested in #262, should this transformation be applied, it could be more useful to transform  -Infinity into 1/-0 instead of -1/0 (cf. #411).\n. @rvanvelzen: It reintroduces parentheses because the token is always a left parenthesis:\njavascript\njsp.tokenizer(\"(\" + expr.slice(position) + \")\")()\nNo matter how expr is sliced, a left parenthesis is added in front of it. If the number of parentheses never decreases, the function cannot return the Boolean value true. In fact, expr should not have been sliced at all (cf. #388).\n. @paulbaumgart: Thank you for reporting this problem. c52434533715b1eb573f12eac53164e2ecb36874 can now be applied cleanly on the current master (i.e. 4a259ae06c1b0bc611754150bd8e96b030141593).\n@mishoo: With regard to 59ce11d0abab902ca05bf5aee1138af13e1837db, one is able to save half a second while squeezing jQuery 1.8pre with a simple check whether a parenthesis is present (if it is not, the tokenizer is not used; 978566500a96d6c8e76fa7268bbdd69715d9d6ad). Still, it slows down the process by approximately 0.14 seconds in comparison to the current master.\n. @paulbaumgart: With regard to the test case, not that it must not be like this, however:\n``` javascript\nvar foo = function() {\n  throw new Error;\n};\n// Each of the following two lines is terminated with a semicolon.\n(function(){return foo;})();\n(function(){})();\n// None of the following two lines is terminated with a semicolon.\n(function(){return foo;})()\n(function(){})()\n. @rvanvelzen: `_=0,!!_` (cf. #84).\n. javascript\nwith({get (){throw 0}}){}\n``\n. @rvanvelzen: No need to use thewith` statement.\njavascript\n!function(){Object.defineProperty(this,'_',{get:function(){throw 0}});_}()\n. One could also consider eliminating those expressions in question that are separated by the comma operator, e.g. 42;42,42.\n. javascript\nnull;null,false;null,true\n(cf. #330)\n. @rvanvelzen: @paulbaumgart is probably referring to cases like the following:\njavascript\nObject.prototype.valueOf=function(){throw 0};+{},-{},~{},+[],-[],~[],+/_/,-/_/,~/_/\nWith regard to the comma operator, if 0,0; becomes ;, it might be worth to consider transforming _,0; into _;.\n. @FarSeeing: Thank you for reviewing this pull request and submitting further suggestions.\n. @michaelficarra: Thank you for reviewing this pull request.\n. @rvanvelzen: Thank you for reporting the error and offering a solution.\n@mishoo: Thank you for implementing the solution.\n. Already fixed in 6a873a7757895fdc06501854e4ba84e15c12a74a.\n. javascript\nif (0 === Math.random()) {\n  _ = 0;\n}\n``` javascript\nvar _ = '';\nif (0 === Math.random()) {\n  _ += 42;\n}\nif (-1 !== _.indexOf('0')) {\n  throw new Error();\n}\n```\njavascript\n!function() {\n  Object.defineProperty(this, '_', {\n    get: function() {\n      throw new Error();\n    }\n  });\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}();\njavascript\n!function() {\n  Object.defineProperty(this, '_', {\n    set: function(v) {\n      throw new Error();\n    }\n  });\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}();\njavascript\nwith ({\n  get _() {\n    throw new Error();\n  }\n}) {\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}\njavascript\nwith ({\n  set _(v) {\n    throw new Error();\n  }\n}) {\n  if (0 === Math.random()) {\n    _ += 42;\n  }\n}\n``` javascript\nvar Foo = function() {\n};\nFoo.prototype.toString = function() {\n  throw new Error();\n};\nvar _ = new Foo();\nif (0 === Math.random()) {\n  _ += 42;\n}\n```\n``` javascript\nvar Foo = function() {\n};\nFoo.prototype.valueOf = function() {\n  throw new Error();\n};\nvar _ = new Foo();\nif (0 === Math.random()) {\n  _ += 42;\n}\n```\n. This patch has been merged as b8c7715561d1555776f75b3cc7d33bf69cda19aa.\n. Some pitfalls in dbf2df3a45fbafaec7326eda060ee72dd7c8695e:\njavascript\nvar foo = {}, bar = '_baz';\nfoo._baz = 42;\nconsole.log('number' === typeof foo[bar]);\nconsole.log(foo.hasOwnProperty('_baz'));\nconsole.log(-1 !== Object.keys(foo).indexOf('_baz'));\nwith (foo) {\n  console.log('number' === typeof _baz);\n}\n. Duplicate of issue #219.\n. Fails when no source elements are present. When it comes to global code, it fails when a program is empty. When it comes to function code, it fails when it comes to\njavascript\n!function() {\n};\nbut not when it comes to\njavascript\n!function() {\n  42;\n};\nIt is assumed (in the EqualityExpression in line 913) that body has at least one element. \n. Results in more source characters in a scope where no mangling takes place (cf. Scope.prototype.get_mangled in ./lib/process.js).\n``` javascript\n!function() {\n  !function() {\n    eval('');\n  };\n  void [typeof this, typeof this, typeof this, typeof this];\n};\n!function() {\n  !function() {\n    with ({});\n  };\n  void [typeof this, typeof this, typeof this, typeof this];\n};\n```\nAdds a variable declaration in the global scope.\njavascript\nvoid [typeof this, typeof this, typeof this, typeof this];\n. this could be consolidated in the global scope by employing a closure (if it results in less source characters).\nbash\nuglifyjs -c <<ENDH\nvoid [null, null, null, null, null, null, null, null, null, null];\nwith ({});\nvoid [null, null, null, null, null, null, null, null, null, null];\nENDH\nLine 973 of ./lib/process.js (5523a29d55e9bd5fcb9143058f164a3b3c86fbb1) calls unshift on the body. This turns a Directive Prologue into an expendable sequence of StringLiteral tokens.\njavascript\n!function() {\n  'foo';\n  'bar';\n  void [typeof this, typeof this, typeof this, typeof this];\n};\n. @curiousdannii It has been claimed otherwise in #228.\n. Thank you for pulling the patch.\n\nwhy not making those variables global?\n\nUnobtrusiveness of new variables was a design goal. Consolidation of jQuery 1.7.1 uses identifier names up to gv. Global variables could be overwritten by another script added to a Web page. For instance, this scenario could happen with two independent scripts available from a content delivery network.\nWhat follows is a small demonstration of the problem.\nsh\n$ echo \"var quux = 42;\" > foo.js\n$ echo \"var quux = 'baz';\" > bar.js\nhtml\n<!DOCTYPE html>\n<meta charset=\"UTF-8\" />\n<title></title>\n<script type=\"application/ecmascript\" src=\"foo.js\"></script>\n<script type=\"application/ecmascript\" src=\"bar.js\"></script>\n<script type=\"application/ecmascript\">console.log(typeof quux);</script>\n. All the methods use the abstract operation ToInteger for the argument matching their first formal parameter.\njavascript\nconsole.log(\"abcdef\".slice(\"2\"), \"abcdef\".substr(\"2\"), \"abcdef\".substring(\"2\"));\n. Due to an extra next() (line 579 of ./lib/parse-js.js):\n- $ echo '/**/' | uglifyjs results in an error,\n- $ echo '/*a*/' | uglifyjs results in another error,\n- $ echo '/*ab*/' | uglifyjs results in /*b*/;.\n. @paulbaumgart : Thank you for reviewing this pull request. A fix has also been pushed for #331.\n. When it comes to evaluating the production MemberExpression : MemberExpression [ Expression ], this is to be expected. Relevant steps are as follows:\n1. \u201cDivision of a nonzero finite value by a zero results in a signed infinity.\u201d (11.5.2).\n2. \u201cLet propertyNameReference be the result of evaluating Expression.\u201d (11.2.1).\n3. \u201cLet propertyNameValue be GetValue(propertyNameReference).\u201d (11.2.1).\n4. \u201cIf Type(V) is not Reference, return V.\u201d (8.7.1)\n5. \u201cLet propertyNameString be ToString(propertyNameValue).\u201d (11.2.1).\n6. \u201cIf m is infinity, return the String \"Infinity\".\u201d (9.8.1).\nWould it not be more consequent to replace Number.NaN with 0/0 instead of NaN?\n. As suggested in #262, should this transformation be applied, it could be more useful to transform  -Infinity into 1/-0 instead of -1/0 (cf. #411).\n. @rvanvelzen: It reintroduces parentheses because the token is always a left parenthesis:\njavascript\njsp.tokenizer(\"(\" + expr.slice(position) + \")\")()\nNo matter how expr is sliced, a left parenthesis is added in front of it. If the number of parentheses never decreases, the function cannot return the Boolean value true. In fact, expr should not have been sliced at all (cf. #388).\n. @paulbaumgart: Thank you for reporting this problem. c52434533715b1eb573f12eac53164e2ecb36874 can now be applied cleanly on the current master (i.e. 4a259ae06c1b0bc611754150bd8e96b030141593).\n@mishoo: With regard to 59ce11d0abab902ca05bf5aee1138af13e1837db, one is able to save half a second while squeezing jQuery 1.8pre with a simple check whether a parenthesis is present (if it is not, the tokenizer is not used; 978566500a96d6c8e76fa7268bbdd69715d9d6ad). Still, it slows down the process by approximately 0.14 seconds in comparison to the current master.\n. @paulbaumgart: With regard to the test case, not that it must not be like this, however:\n``` javascript\nvar foo = function() {\n  throw new Error;\n};\n// Each of the following two lines is terminated with a semicolon.\n(function(){return foo;})();\n(function(){})();\n// None of the following two lines is terminated with a semicolon.\n(function(){return foo;})()\n(function(){})()\n. @rvanvelzen: `_=0,!!_` (cf. #84).\n. javascript\nwith({get (){throw 0}}){}\n``\n. @rvanvelzen: No need to use thewith` statement.\njavascript\n!function(){Object.defineProperty(this,'_',{get:function(){throw 0}});_}()\n. One could also consider eliminating those expressions in question that are separated by the comma operator, e.g. 42;42,42.\n. javascript\nnull;null,false;null,true\n(cf. #330)\n. @rvanvelzen: @paulbaumgart is probably referring to cases like the following:\njavascript\nObject.prototype.valueOf=function(){throw 0};+{},-{},~{},+[],-[],~[],+/_/,-/_/,~/_/\nWith regard to the comma operator, if 0,0; becomes ;, it might be worth to consider transforming _,0; into _;.\n. @FarSeeing: Thank you for reviewing this pull request and submitting further suggestions.\n. @michaelficarra: Thank you for reviewing this pull request.\n. @rvanvelzen: Thank you for reporting the error and offering a solution.\n@mishoo: Thank you for implementing the solution.\n. ",
    "mathiasbynens": "I added the $1 in a later commit, but you had already closed the pull request by then :) Anyway, thanks!\n. \n. @michaelficarra I do realize that; but this brings us one step closer to parsing all license-like comments, doesn\u2019t it?\n. RT @cowboy \n\nAdding complex rules that dictate where to-be-preserved comments need to be located might be overly complex. What if you just documented that comment nodes between statements that would otherwise be combined will prevent them from being combined?\n. I added the $1 in a later commit, but you had already closed the pull request by then :) Anyway, thanks!\n. \n. @michaelficarra I do realize that; but this brings us one step closer to parsing all license-like comments, doesn\u2019t it?\n. RT @cowboy \nAdding complex rules that dictate where to-be-preserved comments need to be located might be overly complex. What if you just documented that comment nodes between statements that would otherwise be combined will prevent them from being combined?\n. \n",
    "eirikurn": "Great to see the quick response. Thanks.\n. Great to see the quick response. Thanks.\n. ",
    "thejh": "Now it is also able to handle stuff like this:\nswitch (a) {\n  case 1:\n  case 2:\n  case 3:\n    foo();\n    break;\n  case 4:\n    bar();\n    break;\n  default:\n    baz();\n}\nResult:\na===1||a===2||a===3?foo():a===4?bar():baz()\nThis causes a further size reduction of 22/15 bytes for prototype.js (73/32 bytes in total).\n. Isnt \"may\" == \"may not\"?\n. Fixed one easy bug, only simple assignments (=) are treated this way now, but the problems with this.foo being dropped and if (a) b=2; else c=2 getting compiled to a&&(c=b=2) still remain. :(\n. +1\n. Hmm, actually, looks like some of the token data is messed up. :(\n```\n\nast.statements[1].stat.rvalue\n{ parent: null,\n  type: 'num',\n  scope: null,\n  children: [Getter],\n  rawNode: \n   [ { name: 'num',\n       start: [Object],\n       end: [Object] },\n     4 ],\n  position: \n   { startToken: \n      { type: 'num',\n        value: 4,\n        line: 1,\n        col: 2,\n        pos: 6,\n        endpos: 7,\n        nlb: false,\n        comments_before: [] },\n     endToken: \n      { type: 'operator',\n        value: '+',\n        line: 1,\n        col: 1,\n        pos: 5,\n        endpos: 6,\n        nlb: false,\n        comments_before: [] } },\n  value: 4 }\n```\n. It works now. Example (it was highlighted by itself): http://thejh.github.com/boxednodes.html\n@mishoo Are you going to merge this?\n. Now it is also able to handle stuff like this:\n\nswitch (a) {\n  case 1:\n  case 2:\n  case 3:\n    foo();\n    break;\n  case 4:\n    bar();\n    break;\n  default:\n    baz();\n}\nResult:\na===1||a===2||a===3?foo():a===4?bar():baz()\nThis causes a further size reduction of 22/15 bytes for prototype.js (73/32 bytes in total).\n. Isnt \"may\" == \"may not\"?\n. Fixed one easy bug, only simple assignments (=) are treated this way now, but the problems with this.foo being dropped and if (a) b=2; else c=2 getting compiled to a&&(c=b=2) still remain. :(\n. +1\n. Hmm, actually, looks like some of the token data is messed up. :(\n```\n\nast.statements[1].stat.rvalue\n{ parent: null,\n  type: 'num',\n  scope: null,\n  children: [Getter],\n  rawNode: \n   [ { name: 'num',\n       start: [Object],\n       end: [Object] },\n     4 ],\n  position: \n   { startToken: \n      { type: 'num',\n        value: 4,\n        line: 1,\n        col: 2,\n        pos: 6,\n        endpos: 7,\n        nlb: false,\n        comments_before: [] },\n     endToken: \n      { type: 'operator',\n        value: '+',\n        line: 1,\n        col: 1,\n        pos: 5,\n        endpos: 6,\n        nlb: false,\n        comments_before: [] } },\n  value: 4 }\n```\n. It works now. Example (it was highlighted by itself): http://thejh.github.com/boxednodes.html\n@mishoo Are you going to merge this?\n. \n",
    "thorn0": "The issue has nothing to do with the size of obfuscated code. But without this patch the parser just doesn't work with the JScript engine.\n. The issue has nothing to do with the size of obfuscated code. But without this patch the parser just doesn't work with the JScript engine.\n. ",
    "paulbaumgart": "Right, it applies the default walker first because that goes and visits child nodes, and only applies the user-supplied walker after returning back to the node.\nI'm doing subtree modifications (re-writing JS) and am creating my own walkers to do so for certain types of nodes. I want to be sure to modify the deepest nodes first because modifications to parent nodes need to take into account modifications to child nodes.\nI originally wanted to just add a parameter to the walk function (or create a new walk function), but realized it would have to be passed along with all of walkers. That seemed worse than just adding a global variable (which I agree isn't great either), but it's a judgment call I'll defer to you.\n. Thinking about this more, it's not very useful as it is: if at all, you'd want to be able to specify a walk function for both pre- and postorder calling.\nI'll figure out something better and resubmit.\n. Great, that's a much cleaner approach and works very well. Thanks!\n. Not for minifying files, sure, but I'm using the parser/source-reconstructor to handle JS that e.g. might get passed to eval().\nSo it depends on whether a sub-goal of UglifyJS is to create a performant tool for general purpose JS parsing or not, I suppose. It's already most of the way there. :)\n. As a minimal case, the valid JS:\n(function(){})\nBecomes the invalid function declaration:\nfunction(){}\ni.e.\nbefore patch:\nnode -e \"require('./lib/process').gen_code(require('./lib/parse-js').parse('(function(){})'))\"\nfunction(){}\nafter patch:\nnode -e \"require('./lib/process').gen_code(require('./lib/parse-js').parse('(function(){})'))\"\n(function(){})\n. I fixed the commit message typo btw: https://github.com/proxv/UglifyJS/commit/1721863f2e35f1f9f5eb932cad9ec2e35196fad5\n. This is the behavior I get:\nnode -e \"JSON.stringify(require('./lib/parse-js').parse('(function(){})'))\"\n[\"toplevel\",[[\"stat\",[\"function\",null,[],[]]]]]\nThe code I added wraps functions in parens but not defuns.\n. Thanks!\n. The test shouldn't be removed: the failure points to a real bug, fixed here: https://github.com/mishoo/UglifyJS/pull/357\n. I can't find any tests at all for gen_code. Am I overlooking something?\nThis is just an API addition. The HTML attribute use-case was just one example of why anyone would want to use this option. There are probably others.\n. Good point, somehow I only tried js-style backslash escaping and not HTML entities. Html entities work just dine. No need for this feature after all.\n. Somewhat related: this issue can be closed: https://github.com/mishoo/UglifyJS/issues/243\n. FYI, looks like this patch no longer applies cleanly to master.\n. @RGustBardon: https://github.com/mishoo/UglifyJS/pull/401 was the problem, so it's all good!\n. This looks great. Would you mind adding a test for the behavior of side_effects in test/unit/compress, with a mix of expressions that should and shouldn't be removed by your additions to ast_squeeze + the expected output?\n(Run with: npm test from the top-level repo dir.)\n. Since this is an unsafe transformation in pathological cases, maybe it should go in ast_squeeze_more ?\n. Right, it applies the default walker first because that goes and visits child nodes, and only applies the user-supplied walker after returning back to the node.\nI'm doing subtree modifications (re-writing JS) and am creating my own walkers to do so for certain types of nodes. I want to be sure to modify the deepest nodes first because modifications to parent nodes need to take into account modifications to child nodes.\nI originally wanted to just add a parameter to the walk function (or create a new walk function), but realized it would have to be passed along with all of walkers. That seemed worse than just adding a global variable (which I agree isn't great either), but it's a judgment call I'll defer to you.\n. Thinking about this more, it's not very useful as it is: if at all, you'd want to be able to specify a walk function for both pre- and postorder calling.\nI'll figure out something better and resubmit.\n. Great, that's a much cleaner approach and works very well. Thanks!\n. Not for minifying files, sure, but I'm using the parser/source-reconstructor to handle JS that e.g. might get passed to eval().\nSo it depends on whether a sub-goal of UglifyJS is to create a performant tool for general purpose JS parsing or not, I suppose. It's already most of the way there. :)\n. As a minimal case, the valid JS:\n(function(){})\nBecomes the invalid function declaration:\nfunction(){}\ni.e.\nbefore patch:\nnode -e \"require('./lib/process').gen_code(require('./lib/parse-js').parse('(function(){})'))\"\nfunction(){}\nafter patch:\nnode -e \"require('./lib/process').gen_code(require('./lib/parse-js').parse('(function(){})'))\"\n(function(){})\n. I fixed the commit message typo btw: https://github.com/proxv/UglifyJS/commit/1721863f2e35f1f9f5eb932cad9ec2e35196fad5\n. This is the behavior I get:\nnode -e \"JSON.stringify(require('./lib/parse-js').parse('(function(){})'))\"\n[\"toplevel\",[[\"stat\",[\"function\",null,[],[]]]]]\nThe code I added wraps functions in parens but not defuns.\n. Thanks!\n. The test shouldn't be removed: the failure points to a real bug, fixed here: https://github.com/mishoo/UglifyJS/pull/357\n. I can't find any tests at all for gen_code. Am I overlooking something?\nThis is just an API addition. The HTML attribute use-case was just one example of why anyone would want to use this option. There are probably others.\n. Good point, somehow I only tried js-style backslash escaping and not HTML entities. Html entities work just dine. No need for this feature after all.\n. Somewhat related: this issue can be closed: https://github.com/mishoo/UglifyJS/issues/243\n. FYI, looks like this patch no longer applies cleanly to master.\n. @RGustBardon: https://github.com/mishoo/UglifyJS/pull/401 was the problem, so it's all good!\n. This looks great. Would you mind adding a test for the behavior of side_effects in test/unit/compress, with a mix of expressions that should and shouldn't be removed by your additions to ast_squeeze + the expected output?\n(Run with: npm test from the top-level repo dir.)\n. Since this is an unsafe transformation in pathological cases, maybe it should go in ast_squeeze_more ?\n. ",
    "adamnbowen": "@thejh technically correct, but I feel that since there are (to my knowledge) no benchmarks on the optimizations, then we can't claim any possibility of faster code.  Also, I remember having a bit of trouble reading the sentence without \"not\" being in place. \nAs a side note, I should probably have used \"might not\" instead.\n. up to you, of course, feel free to close if it is contrary to your sensibilities.\n. @thejh technically correct, but I feel that since there are (to my knowledge) no benchmarks on the optimizations, then we can't claim any possibility of faster code.  Also, I remember having a bit of trouble reading the sentence without \"not\" being in place. \nAs a side note, I should probably have used \"might not\" instead.\n. up to you, of course, feel free to close if it is contrary to your sensibilities.\n. ",
    "ikokostya": "+1 for --help flag\n. +1 for --help flag\n. ",
    "kyledrake": "Cool, thanks! Could you update the documentation to provide this information? My motivation for this was simply to fix using the command-line tool with npm. The README doesn't document how to do this and it's causing issues for people that aren't super familiar with npm.\n. Cool, thanks! Could you update the documentation to provide this information? My motivation for this was simply to fix using the command-line tool with npm. The README doesn't document how to do this and it's causing issues for people that aren't super familiar with npm.\n. ",
    "edjafarov": "If we declare function without statement:\njavascript\n//comment\nfunction someFunctionName(){\n....\n}\nit is not working. Try this simple example and you will see that function do not have comment.\n. awesome! thanks!\n. If we declare function without statement:\njavascript\n//comment\nfunction someFunctionName(){\n....\n}\nit is not working. Try this simple example and you will see that function do not have comment.\n. awesome! thanks!\n. ",
    "stereobooster": "+1\n. +1\n. ",
    "stefounet": "Yep, I understand, i had an idea that you won't include it.\nBut my implementation is the right one to deal with the case I met (line 4521 of this file : http://www.yves-rocher.fr/images/js/allJSFiles.js) : I only want to get rid of one line of comment, the wrong one, with the wrong format.\n. Yep, I understand, i had an idea that you won't include it.\nBut my implementation is the right one to deal with the case I met (line 4521 of this file : http://www.yves-rocher.fr/images/js/allJSFiles.js) : I only want to get rid of one line of comment, the wrong one, with the wrong format.\n. ",
    "isaacs": "Sweet, thanks for the fast turnaround!\n. Sweet, thanks for the fast turnaround!\n. ",
    "davidlevy": "Do you know when it will be committed in the master ?\n. Do you know when it will be committed in the master ?\n. ",
    "iliakan": "Looks good so far.. How about to make it external to uglify? So I can remove anything or can modify it.. Maybe add hooks to default uglifier? Right now I can replace default squeezer by hijacking require(..)\ne.g uglify-console.js:\n```\nvar uglify = require(\"uglify-js\"), \n    pro = uglify.uglify;\npro.ast_squeeze_console = function(ast) {\n        var w = pro.ast_walker(), walk = w.walk, scope;\n         return w.with_walkers({\n                \"stat\": function(stmt) {\n                        if(stmt[0] === \"call\" && stmt[1][0] == \"dot\" && stmt[1][1] instanceof Array && stmt[1][1][0] == 'name' && stmt[1][1][1] == \"console\") {\n                                return [\"block\"];\n                        }\n                        return [\"stat\", walk(stmt)];\n                },\n                \"call\": function(expr, args) {\n                        if (expr[0] == \"dot\" && expr[1] instanceof Array && expr[1][0] == 'name' && expr[1][1] == \"console\") {\n                                return [\"atom\", \"0\"];\n                        }\n                }\n        }, function() {\n                return walk(ast);\n        });\n};\nvar ast_squeeze = pro.ast_squeeze;\npro.ast_squeeze = function() {\n  var ast = ast_squeeze.apply(this, arguments);\n  ast = pro.ast_squeeze_console(ast);\n  return ast;\n}\nrequire('./uglify.js');\n```\n. Looks good so far.. How about to make it external to uglify? So I can remove anything or can modify it.. Maybe add hooks to default uglifier? Right now I can replace default squeezer by hijacking require(..)\ne.g uglify-console.js:\n```\nvar uglify = require(\"uglify-js\"), \n    pro = uglify.uglify;\npro.ast_squeeze_console = function(ast) {\n        var w = pro.ast_walker(), walk = w.walk, scope;\n         return w.with_walkers({\n                \"stat\": function(stmt) {\n                        if(stmt[0] === \"call\" && stmt[1][0] == \"dot\" && stmt[1][1] instanceof Array && stmt[1][1][0] == 'name' && stmt[1][1][1] == \"console\") {\n                                return [\"block\"];\n                        }\n                        return [\"stat\", walk(stmt)];\n                },\n                \"call\": function(expr, args) {\n                        if (expr[0] == \"dot\" && expr[1] instanceof Array && expr[1][0] == 'name' && expr[1][1] == \"console\") {\n                                return [\"atom\", \"0\"];\n                        }\n                }\n        }, function() {\n                return walk(ast);\n        });\n};\nvar ast_squeeze = pro.ast_squeeze;\npro.ast_squeeze = function() {\n  var ast = ast_squeeze.apply(this, arguments);\n  ast = pro.ast_squeeze_console(ast);\n  return ast;\n}\nrequire('./uglify.js');\n```\n. ",
    "sjhewitt": "@iliakan I'm not convinced by that method of monkey-patching the ast_squeeze function. If you're going to be using it from within some node script you have control over, you might as well include the ast_squeeze_console function and make your own custom version of the uglify function that is in uglify.js:\n```\nvar uglify = require('uglify-js');\nfunction ast_squeeze_console(){ ... };\nfunction myUglify(orig_code, options){\n    options || (options = {});\n    var jsp = uglify.parser;\n    var pro = uglify.uglify;\nvar ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST\nast = ast_squeeze_console(ast); // get rid of console statements\nast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names\nast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations\nvar final_code = pro.gen_code(ast, options.gen_options); // compressed code here\nreturn final_code;\n\n};\n```\nFor command-line usage via bin/uglify some kind of plugin architecture could be useful, but I don't hold out much hope of it being included.\n. @iliakan I'm not convinced by that method of monkey-patching the ast_squeeze function. If you're going to be using it from within some node script you have control over, you might as well include the ast_squeeze_console function and make your own custom version of the uglify function that is in uglify.js:\n```\nvar uglify = require('uglify-js');\nfunction ast_squeeze_console(){ ... };\nfunction myUglify(orig_code, options){\n    options || (options = {});\n    var jsp = uglify.parser;\n    var pro = uglify.uglify;\nvar ast = jsp.parse(orig_code, options.strict_semicolons); // parse code and get the initial AST\nast = ast_squeeze_console(ast); // get rid of console statements\nast = pro.ast_mangle(ast, options.mangle_options); // get a new AST with mangled names\nast = pro.ast_squeeze(ast, options.squeeze_options); // get an AST with compression optimizations\nvar final_code = pro.gen_code(ast, options.gen_options); // compressed code here\nreturn final_code;\n\n};\n```\nFor command-line usage via bin/uglify some kind of plugin architecture could be useful, but I don't hold out much hope of it being included.\n. ",
    "simenbrekken": "I believe you can simply use sed to comment out any console statements before passing the script to UglifyJS.\nbash\nsed -E 's/(console\\.)/\\/\\/\\1/g' script.js | uglifyjs\n. I believe you can simply use sed to comment out any console statements before passing the script to UglifyJS.\nbash\nsed -E 's/(console\\.)/\\/\\/\\1/g' script.js | uglifyjs\n. ",
    "eduardocereto": "I do a lot of code with Google Analytics functions, and these functions all start with an underscore. And while I'd like to have this feature I can't use this because that would mangle these methods as well.\nMaybe add an option to mangle double underscores only ?\n. I do a lot of code with Google Analytics functions, and these functions all start with an underscore. And while I'd like to have this feature I can't use this because that would mangle these methods as well.\nMaybe add an option to mangle double underscores only ?\n. ",
    "iccir": "Thanks!  I needed this for some experimental site-wide passes that I'm working on.\nWith this change, {'foo': 1} adds the two-element Array [ \"string\", \"foo\" ] to the AST, while {foo: 1} adds a String \"foo\".  \nWould it be safer to always use a two-element Array, and have {foo: 1} add something like {\"literal\", \"foo\"}?\nTesting if (key[0] == \"string\") when key is a String feels more like a side-effect of the String subscript operator (which I believe was non-standard until ECMAScript 5?)\nIn any case, thanks again! :)\n. Thanks!  I needed this for some experimental site-wide passes that I'm working on.\nWith this change, {'foo': 1} adds the two-element Array [ \"string\", \"foo\" ] to the AST, while {foo: 1} adds a String \"foo\".  \nWould it be safer to always use a two-element Array, and have {foo: 1} add something like {\"literal\", \"foo\"}?\nTesting if (key[0] == \"string\") when key is a String feels more like a side-effect of the String subscript operator (which I believe was non-standard until ECMAScript 5?)\nIn any case, thanks again! :)\n. ",
    "laverdet": "I agree it would probably be smarter to change the existing keys like you mentioned. @mishoo would love to see this land, let me know if you want to make the modifications mentioned above.\n. Aye. Not totally sure how to update the pull request, but 0e48c7db6f9579af34d07ed64bc5481b21ec75b2 fixes that easily.\n. There we go, added to pull request.\n. Thanks for the scrutiny :). This fixes the issue when no mangling takes place, and also takes care of the global leakage.\nThe try/catch was just an easy way to bail out of with_walkers() easily, but I replaced it with a function reassignment (read: monkey patch).\nRe: that variable it's actually not that, it's mangle_my_this_ref__; that is a local shortcut. I assumed no one would use mangle_my_this_ref__ in their source but went ahead and added a check just because.\n. idk it's a lot of legwork and you're a jerk if you're using that variable in your program.\n. That will fail in the case where you have a that referenced in a nested function. It'll go into the nested function, update that, and then when it exits back out to the upper function it will have the wrong reference. You'd have to maintain them on the stack for each function you enter. It's only 3 more lines to handle that but I still think they're just a jerk if they use that reference.\n. Interesting, I was not aware that this had been tried before. I did see gains in my code with and without gzip due to the bind() optimizations but for libraries which do not make use of the applicable bind() pattern it seems this would be harmful after gzip. That in mind, I may just take this walker and stick it in my own stack if common use of bind() in that way is uncommon with the community.\n. I agree it would probably be smarter to change the existing keys like you mentioned. @mishoo would love to see this land, let me know if you want to make the modifications mentioned above.\n. Aye. Not totally sure how to update the pull request, but 0e48c7db6f9579af34d07ed64bc5481b21ec75b2 fixes that easily.\n. There we go, added to pull request.\n. Thanks for the scrutiny :). This fixes the issue when no mangling takes place, and also takes care of the global leakage.\nThe try/catch was just an easy way to bail out of with_walkers() easily, but I replaced it with a function reassignment (read: monkey patch).\nRe: that variable it's actually not that, it's mangle_my_this_ref__; that is a local shortcut. I assumed no one would use mangle_my_this_ref__ in their source but went ahead and added a check just because.\n. idk it's a lot of legwork and you're a jerk if you're using that variable in your program.\n. That will fail in the case where you have a that referenced in a nested function. It'll go into the nested function, update that, and then when it exits back out to the upper function it will have the wrong reference. You'd have to maintain them on the stack for each function you enter. It's only 3 more lines to handle that but I still think they're just a jerk if they use that reference.\n. Interesting, I was not aware that this had been tried before. I did see gains in my code with and without gzip due to the bind() optimizations but for libraries which do not make use of the applicable bind() pattern it seems this would be harmful after gzip. That in mind, I may just take this walker and stick it in my own stack if common use of bind() in that way is uncommon with the community.\n. ",
    "curiousdannii": "Please provide evidence that it produces shorter files once gzipped.\n. Please provide evidence that it produces shorter files once gzipped.\n. ",
    "kennethkufluk": "Hmm. Yes, good point.  Wondered whether that next() would affect anything.\n. I think it's compatible with show_copyight.  Doesn't cause me errors with a few simple test cases.\n(Sorry for weird last commit message.  Forgot !s didn't work in commit msgs.)\n. @mal Hmm, good catch.\n. @mal I still think the license should be in the AST, to prevent loss & confusion during mangling.\nI guess I could add exceptions to the next, prev and peek methods?  Do you think that would work?\n. @mal Yes, I see the problem.\nI always knew that badly placed licenses would cause havoc.  You can put a comment pretty much anywhere.  Maybe we need to exclude badly-placed licenses.  But, hey, licenses are not hard to place.\nMaybe the solution is to simply not AST them if --no-licenses is enabled, solving the issue for those that don't care.\nAnd otherwise leave as-is - the licenses forming barriers between licensed blocks of code.\n. Could do.  Would that be better?\n. Hmm. Yes, good point.  Wondered whether that next() would affect anything.\n. I think it's compatible with show_copyight.  Doesn't cause me errors with a few simple test cases.\n(Sorry for weird last commit message.  Forgot !s didn't work in commit msgs.)\n. @mal Hmm, good catch.\n. @mal I still think the license should be in the AST, to prevent loss & confusion during mangling.\nI guess I could add exceptions to the next, prev and peek methods?  Do you think that would work?\n. @mal Yes, I see the problem.\nI always knew that badly placed licenses would cause havoc.  You can put a comment pretty much anywhere.  Maybe we need to exclude badly-placed licenses.  But, hey, licenses are not hard to place.\nMaybe the solution is to simply not AST them if --no-licenses is enabled, solving the issue for those that don't care.\nAnd otherwise leave as-is - the licenses forming barriers between licensed blocks of code.\n. Could do.  Would that be better?\n. ",
    "fat": "This might break the bin implementation which already extracts comments and then readds them.\nhttps://github.com/mishoo/UglifyJS/blob/master/bin/uglifyjs#L265\n. This might break the bin implementation which already extracts comments and then readds them.\nhttps://github.com/mishoo/UglifyJS/blob/master/bin/uglifyjs#L265\n. ",
    "cowboy": "A huge +1 for this functionality being added in!\n. @mal that makes sense, and is the behavior I'd expect. The most common use-case for preserving inline license comments assumes they are at the top of individual files concatenated together into a single script, in which case each sub-script will most likely be inside an IIFE anyways.\n. FWIW, keeping /*! ... */ comments is great, but it would be nice if there was also an option to keep all /* ... */ comments.\n. Adding complex rules that dictate where to-be-preserved comments need to be located might be overly complex. What if you just documented that comment nodes between statements that would otherwise be combined will prevent them from being combined?\n. @mal fair enough!\n. A huge +1 for this functionality being added in!\n. @mal that makes sense, and is the behavior I'd expect. The most common use-case for preserving inline license comments assumes they are at the top of individual files concatenated together into a single script, in which case each sub-script will most likely be inside an IIFE anyways.\n. FWIW, keeping /*! ... */ comments is great, but it would be nice if there was also an option to keep all /* ... */ comments.\n. Adding complex rules that dictate where to-be-preserved comments need to be located might be overly complex. What if you just documented that comment nodes between statements that would otherwise be combined will prevent them from being combined?\n. @mal fair enough!\n. ",
    "quaelin": "Another +1... I'm using @kennethkufluk's fork in the meantime (thanks!).\n. Another +1... I'm using @kennethkufluk's fork in the meantime (thanks!).\n. ",
    "xrstf": "Another +1 -- this makes UglifyJS more suitable for people wanting to use the \"official\" (1) way to embed their license.\n(1) jQuery does it, so it must be \"the right way\". ;-)\n. Another +1 -- this makes UglifyJS more suitable for people wanting to use the \"official\" (1) way to embed their license.\n(1) jQuery does it, so it must be \"the right way\". ;-)\n. ",
    "mal": "Unfortunately adding the license to the AST means that it breaks contextual minifications that look around using prev() and peek(), this is especially apparent when using --no-licenses mode.\nin.js\n``` js\n/! License 1 /\n/! Multiline\n    License 2\n/\nvar a=1;\n/! License 3 /\nvar b=1;\nvar a=1,b=1;\n```\nmishoo/master\nsh\n$ uglifyjs -nc in.js\njs\nvar a=1,b=1;\nkennethkufluk/master\nsh\n$ bin/uglifyjs -nc -nl in.js\njs\nvar a=1;var b=1;\nThe new license node prevents the code processing the var b from seeing that the previous node was var a and combining the two.\n. @cowboy I agree with the common use-case, however there's still some loss with IIFEs; consider:\njs\n/*! License 1 */\n(function(){var a=1;})();\n/*! License 2 */\n(function(){var b=1;})();\nmishoo/master\njs\n(function(){var a=1})(),function(){var a=1}();\nkennethkufluk/master\njs\n(function(){var a=1})();(function(){var a=1})();\n. @kennethkufluk In theory ignoring non-code AST nodes unless processing the node itself should resolve that particular problem, but there's other perils associated with having non-code items as first class nodes in the AST:\nFunction Hoisting\njs\n/*! License goes walk about with no IIFE */\nfunction a () {}\nvar b;\njs\nfunction a(){}/*! License goes walk about with no IIFE */var b;\nSequences\njs\nvar a=1,\n/*! Very suspiciously placed license comment kills the parser */\nb=1;\nsh\nDEBUG: Error\n    at new JS_Parse_Error (/home/mal/code/js/UglifyJS/lib/parse-js.js:260:22)\n    ...\n. In an ideal world I think we'd just keep the comments_before property while the AST gets manipulated, and then either output as many or as few comments as we like from gen_code. The problem is that it's easier said than done; all node properties get dropped almost every time the tree is walked. I think it's the scale of the refactor required that has made it more of a 2.0 feature in past discussions.\nFor now though @kennethkufluk's suggestion of ignoring weird license placements sounds like the best short term solution. Potential rules being something like: they must be in the toplevel immediately preceding an IIFE or function?\n. Alternatively; another, much simpler, solution that I imagine solves most use-cases (command line only) is to add documentation for, and make use of, the --make argument. It allows a JSON file to specify a set of files to be uglified, and uglifies them independently before concatenating the output. This means that the first comment in each file is preserved in place.\n. @cowboy Agreed, documentation > complex rules, but at a minimum weirdly placed comments should not be allowed to crash the parser.\n. This entire project has been superceeded by https://github.com/mishoo/UglifyJS2 ...\n. So it turns out that this was an upsettingly poor implementation of what is otherwise a decent idea (IMO). I'll submit an improved implementation a little later.\n. +1\n. @mishoo yup, sorry for all the requests; got to the right solution in the end!\n. @mishoo any pointers for getting this merged would be most welcome; I know it doesn't solve the comment/license situation completely, but it is a step up from what we have to help bridge the gap until there's a comprehensive solution/2.0.\n. Cleaning house.\n. Unfortunately adding the license to the AST means that it breaks contextual minifications that look around using prev() and peek(), this is especially apparent when using --no-licenses mode.\nin.js\n``` js\n/! License 1 /\n/! Multiline\n    License 2\n/\nvar a=1;\n/! License 3 /\nvar b=1;\nvar a=1,b=1;\n```\nmishoo/master\nsh\n$ uglifyjs -nc in.js\njs\nvar a=1,b=1;\nkennethkufluk/master\nsh\n$ bin/uglifyjs -nc -nl in.js\njs\nvar a=1;var b=1;\nThe new license node prevents the code processing the var b from seeing that the previous node was var a and combining the two.\n. @cowboy I agree with the common use-case, however there's still some loss with IIFEs; consider:\njs\n/*! License 1 */\n(function(){var a=1;})();\n/*! License 2 */\n(function(){var b=1;})();\nmishoo/master\njs\n(function(){var a=1})(),function(){var a=1}();\nkennethkufluk/master\njs\n(function(){var a=1})();(function(){var a=1})();\n. @kennethkufluk In theory ignoring non-code AST nodes unless processing the node itself should resolve that particular problem, but there's other perils associated with having non-code items as first class nodes in the AST:\nFunction Hoisting\njs\n/*! License goes walk about with no IIFE */\nfunction a () {}\nvar b;\njs\nfunction a(){}/*! License goes walk about with no IIFE */var b;\nSequences\njs\nvar a=1,\n/*! Very suspiciously placed license comment kills the parser */\nb=1;\nsh\nDEBUG: Error\n    at new JS_Parse_Error (/home/mal/code/js/UglifyJS/lib/parse-js.js:260:22)\n    ...\n. In an ideal world I think we'd just keep the comments_before property while the AST gets manipulated, and then either output as many or as few comments as we like from gen_code. The problem is that it's easier said than done; all node properties get dropped almost every time the tree is walked. I think it's the scale of the refactor required that has made it more of a 2.0 feature in past discussions.\nFor now though @kennethkufluk's suggestion of ignoring weird license placements sounds like the best short term solution. Potential rules being something like: they must be in the toplevel immediately preceding an IIFE or function?\n. Alternatively; another, much simpler, solution that I imagine solves most use-cases (command line only) is to add documentation for, and make use of, the --make argument. It allows a JSON file to specify a set of files to be uglified, and uglifies them independently before concatenating the output. This means that the first comment in each file is preserved in place.\n. @cowboy Agreed, documentation > complex rules, but at a minimum weirdly placed comments should not be allowed to crash the parser.\n. This entire project has been superceeded by https://github.com/mishoo/UglifyJS2 ...\n. So it turns out that this was an upsettingly poor implementation of what is otherwise a decent idea (IMO). I'll submit an improved implementation a little later.\n. +1\n. @mishoo yup, sorry for all the requests; got to the right solution in the end!\n. @mishoo any pointers for getting this merged would be most welcome; I know it doesn't solve the comment/license situation completely, but it is a step up from what we have to help bridge the gap until there's a comprehensive solution/2.0.\n. Cleaning house.\n. ",
    "apendua": "@mal In \"compiled\" version of jquery@2.0.3 they did this:\njavascript\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n  // ...\n});\nAt the same time, yuglify tried to hack uglify-js to prevent removing those comments. It all resulted in this funny problem\nhttps://github.com/yui/yuglify/issues/19\nWell, to be honest I don't think preserving comments can be done in a reasonable way without some insight into ast. I believe that doing it outside uglify-js will always produce some unexpected edge cases.\nIt's been three years. Do you guys plan to merge this PR someday?\n. @mal The examples you provided are not going to happen in real life scenarios. Really.\n. @mal Ah, ok ... thank you for the information!\n. @mal In \"compiled\" version of jquery@2.0.3 they did this:\njavascript\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n  // ...\n});\nAt the same time, yuglify tried to hack uglify-js to prevent removing those comments. It all resulted in this funny problem\nhttps://github.com/yui/yuglify/issues/19\nWell, to be honest I don't think preserving comments can be done in a reasonable way without some insight into ast. I believe that doing it outside uglify-js will always produce some unexpected edge cases.\nIt's been three years. Do you guys plan to merge this PR someday?\n. @mal The examples you provided are not going to happen in real life scenarios. Really.\n. @mal Ah, ok ... thank you for the information!\n. ",
    "peterbe": "Yeah, I got stuck here too. Simply switching to uglify-js (npm package name for UglifyJS2) solved the problem I had (...in django-pipeline). \n. Yeah, I got stuck here too. Simply switching to uglify-js (npm package name for UglifyJS2) solved the problem I had (...in django-pipeline). \n. ",
    "tamzinblake": "This one not getting accepted?  I was just coming here to open an issue for this if it wasn't already, and was surprised to see this pull request has been sitting here for 2 months.\n. This one not getting accepted?  I was just coming here to open an issue for this if it wasn't already, and was surprised to see this pull request has been sitting here for 2 months.\n. ",
    "FarSeeing": "Thanks for the explanation.\nAlso, 0/0 for Number.NaN seems good, made it.\n. Great!\nYou also can implement some more things (yeah, I am just too impudent to do it myself :smile:):\n- the same conversion for lastIndexOf (both for String.prototype and Array.prototype),\n- support the second (position) argument for indexOf and lastIndexOf (now ''.indexOf( '', 2 ) == -1 does not minifies to ''.indexOf('',2)<0),\n- maybe minify all indexOf === number to just indexOf == number\n. That's... WOW! Really amazing. I have nothing to add for this.\nFor further thoughts (and probably other commits):\n- string.search( regexp ) != -1\n- or string.match( regexp ) != null\n- or regexp.exec( string ) != null\nto regexp.test( string ), but only for binary regexps.\n. Thanks for the explanation.\nAlso, 0/0 for Number.NaN seems good, made it.\n. Great!\nYou also can implement some more things (yeah, I am just too impudent to do it myself :smile:):\n- the same conversion for lastIndexOf (both for String.prototype and Array.prototype),\n- support the second (position) argument for indexOf and lastIndexOf (now ''.indexOf( '', 2 ) == -1 does not minifies to ''.indexOf('',2)<0),\n- maybe minify all indexOf === number to just indexOf == number\n. That's... WOW! Really amazing. I have nothing to add for this.\nFor further thoughts (and probably other commits):\n- string.search( regexp ) != -1\n- or string.match( regexp ) != null\n- or regexp.exec( string ) != null\nto regexp.test( string ), but only for binary regexps.\n. ",
    "int3": "Hi @mishoo, any chance of this getting merged upstream? I have a project that depends on it, and I'd hate to make people install an almost-identical copy of Uglify just so they can build it.\n. Thank you!\n. Hi @mishoo, any chance of this getting merged upstream? I have a project that depends on it, and I'd hate to make people install an almost-identical copy of Uglify just so they can build it.\n. Thank you!\n. ",
    "paulirish": ":+1:\nSee also \"Compile-time defines\" in http://jeremyckahn.github.com/blog/2012/07/01/treating-javascript-like-a-30-year-old-language/\n. sweet!\n. :+1:\nSee also \"Compile-time defines\" in http://jeremyckahn.github.com/blog/2012/07/01/treating-javascript-like-a-30-year-old-language/\n. sweet!\n. ",
    "rvanvelzen": "While this commit does fix the issue, it also breaks #385, in that it reintroduces the parens. I am investigating the actual issue, won't be long.\n. @mishoo Is there a specific reason for S.regex_allowed being initially false? The tokenizer breaks when the first token is a regexp literal, which is what actually broke everything.\n. @RGustBardon: this is exactly what I found out. It already seemed a too easy fix.\n. @michaelficarra The list was based on jQuery, Prototype and Mootools. There are two basic things that most likely would never be minified: keywords and identifiers in dot-expressions. To generate a more weighted list it would be trivial to take thousands of scripts from various website and just count everything and generate the list again.\nI am currently unable to decide on whether implement a two-pass system for generating this list would be truly beneficial. I would not attempt it, since this weighted list does provide a few kilobytes more compression with gzip than the original list on a source tree of just about 3.5 MB. Every little bit counts.\n. @ralphholzmann That was the point I was trying to make, but expressing myself in English isn't always as easy as in Dutch. :-)\nBesides that: even this simple optimisation will have significant gains in all manner of projects. There are some small improvements that could be made, but most of those would only influence 0..9 in this list which are probably never used at all.\nOne extra gain could be checking the contents of strings as well. Those are not taken into account in this list.\n. @RGustBardon: since negate() should only be used in boolean contexts, this should not be relevant.\n. @RGustBardon I see it also propagates to other cases. I undid the commit, thanks.\n. I have added a test case, and will now fix all other tests that are failing because of removed statements.\n. If you use with you're a jerk. The information in scope.uses_with doesn't seem to be propagated properly which means that names won't be removed.\n. @RGustBardon: of course. I dislike getters and setters for this particular reason.\nOn eliminating expressions within sequences: yes, probably possible. Important condition is not to eliminate the final expression.\n. I assumed ast_squeeze_more was meant for actual unsafe transformations, of which it is impossible to statically detect if they are safe.\nHowever, unless expressing a regexp literal has side effects, these transformations are safe. Unless you're relying on something like function a() { /[a-z]/; } alert(a + '');, which would be absolutely stupid.\nShow me the unsafe parts and I'll change my mind. :-)\n. @RGustBardon thanks, hadn't noticed that one. Updated the unit test to reflect most changes.\n. @RGustBardon I cannot believe anyone in their right mind would write code like that.\n. It's funny how it's always the same\u2026 You think it's easy enough to just work from your master branch, and it turns out to be a lot more trouble. This is the last time I do anything from my master branch, since I'll have to rethink some stuff on this.\n. Undid all changes by destroying my repo and reforking.  Will return to this some other day. :)\n. javascript\n(1/0).valueOf();\n. @mishoo I definitely concur. Code generation has proven to be quite a hassle.\nI believe the actual fix shouldn't be that hard. Just add a walker that does about the same, like this:\n``` javascript\n        \"num\": function (num) {\n                if (!isFinite(num))\n                        return [ \"binary\", \"/\", num === 1 / 0\n                                ? [ \"num\", 1 ] : num === -1 / 0\n                                ? [ \"unary-prefix\", \"-\", [ \"num\", 1 ] ]\n                                : [ \"num\", 0 ], [ \"num\", 0 ] ];\n            return [ this[0], num ];\n    }\n\n```\n. Sorry, I can't really see what this should do. Please rebase onto master and send in a new PR.\n(Edit: disregard that, this project is no longer maintained)\n. While this commit does fix the issue, it also breaks #385, in that it reintroduces the parens. I am investigating the actual issue, won't be long.\n. @mishoo Is there a specific reason for S.regex_allowed being initially false? The tokenizer breaks when the first token is a regexp literal, which is what actually broke everything.\n. @RGustBardon: this is exactly what I found out. It already seemed a too easy fix.\n. @michaelficarra The list was based on jQuery, Prototype and Mootools. There are two basic things that most likely would never be minified: keywords and identifiers in dot-expressions. To generate a more weighted list it would be trivial to take thousands of scripts from various website and just count everything and generate the list again.\nI am currently unable to decide on whether implement a two-pass system for generating this list would be truly beneficial. I would not attempt it, since this weighted list does provide a few kilobytes more compression with gzip than the original list on a source tree of just about 3.5 MB. Every little bit counts.\n. @ralphholzmann That was the point I was trying to make, but expressing myself in English isn't always as easy as in Dutch. :-)\nBesides that: even this simple optimisation will have significant gains in all manner of projects. There are some small improvements that could be made, but most of those would only influence 0..9 in this list which are probably never used at all.\nOne extra gain could be checking the contents of strings as well. Those are not taken into account in this list.\n. @RGustBardon: since negate() should only be used in boolean contexts, this should not be relevant.\n. @RGustBardon I see it also propagates to other cases. I undid the commit, thanks.\n. I have added a test case, and will now fix all other tests that are failing because of removed statements.\n. If you use with you're a jerk. The information in scope.uses_with doesn't seem to be propagated properly which means that names won't be removed.\n. @RGustBardon: of course. I dislike getters and setters for this particular reason.\nOn eliminating expressions within sequences: yes, probably possible. Important condition is not to eliminate the final expression.\n. I assumed ast_squeeze_more was meant for actual unsafe transformations, of which it is impossible to statically detect if they are safe.\nHowever, unless expressing a regexp literal has side effects, these transformations are safe. Unless you're relying on something like function a() { /[a-z]/; } alert(a + '');, which would be absolutely stupid.\nShow me the unsafe parts and I'll change my mind. :-)\n. @RGustBardon thanks, hadn't noticed that one. Updated the unit test to reflect most changes.\n. @RGustBardon I cannot believe anyone in their right mind would write code like that.\n. It's funny how it's always the same\u2026 You think it's easy enough to just work from your master branch, and it turns out to be a lot more trouble. This is the last time I do anything from my master branch, since I'll have to rethink some stuff on this.\n. Undid all changes by destroying my repo and reforking.  Will return to this some other day. :)\n. javascript\n(1/0).valueOf();\n. @mishoo I definitely concur. Code generation has proven to be quite a hassle.\nI believe the actual fix shouldn't be that hard. Just add a walker that does about the same, like this:\n``` javascript\n        \"num\": function (num) {\n                if (!isFinite(num))\n                        return [ \"binary\", \"/\", num === 1 / 0\n                                ? [ \"num\", 1 ] : num === -1 / 0\n                                ? [ \"unary-prefix\", \"-\", [ \"num\", 1 ] ]\n                                : [ \"num\", 0 ], [ \"num\", 0 ] ];\n            return [ this[0], num ];\n    }\n\n```\n. Sorry, I can't really see what this should do. Please rebase onto master and send in a new PR.\n(Edit: disregard that, this project is no longer maintained)\n. ",
    "ralphholzmann": "This will likely help most projects gain extra gzip juice, however, to maximize the benefit from gzip, a more sophisticated \"two pass\" method would need to be implemented. First you'd have to minify the source once and determine what keywords and variables can't be munged. Then, using the list of \"unmungable\" keywords/strings/etc, you would then determine which characters in that list appear most frequently. Use this new list as your digits variable and do a second pass of the minifier over the code. This will yield a unique set of digits for each script being minified and will maximize the potential of gzip.\n. @michaelficarra This is why I propose making the list dynamic based on the script being compressed.\n. @rvanvelzen a generalized list of digits will never be more efficient than a two-pass analysis per script. So the question isn't whether it will be truly beneficial -- it will always be more beneficial -- it's a question of whether or not its worth it to implement.\n. This will likely help most projects gain extra gzip juice, however, to maximize the benefit from gzip, a more sophisticated \"two pass\" method would need to be implemented. First you'd have to minify the source once and determine what keywords and variables can't be munged. Then, using the list of \"unmungable\" keywords/strings/etc, you would then determine which characters in that list appear most frequently. Use this new list as your digits variable and do a second pass of the minifier over the code. This will yield a unique set of digits for each script being minified and will maximize the potential of gzip.\n. @michaelficarra This is why I propose making the list dynamic based on the script being compressed.\n. @rvanvelzen a generalized list of digits will never be more efficient than a two-pass analysis per script. So the question isn't whether it will be truly beneficial -- it will always be more beneficial -- it's a question of whether or not its worth it to implement.\n. ",
    "tonylukasavage": "If you force uglify to \"keep zeroes\" and always use double quotes, you can use its AST to parse and generate valid JSON.\n. If you force uglify to \"keep zeroes\" and always use double quotes, you can use its AST to parse and generate valid JSON.\n. ",
    "papandreou": "Doesn't matter for me anymore.\n. Doesn't matter for me anymore.\n. ",
    "chrisdone": "That's not how copyright works.\n. That's not how copyright works.\n. ",
    "abderrahmane-tj": "Any update on this ?\n. Any update on this ?\n. ",
    "michaelsanford": ":+1: \n. I didn't see it, @phadej ! I'll close this one.\n. :+1: \n. I didn't see it, @phadej ! I'll close this one.\n. ",
    "AdamHess": "+1 \n. +1 \n. ",
    "phadej": "This is merged in right place https://github.com/mishoo/UglifyJS2/commit/20542a37a88393393279ae031f8925efed1f4573\n. I have https://github.com/mishoo/UglifyJS/pull/517 quite similar PR. :) Yet seems that this repository is the wrong place.\nCould @mishoo disable issues and PR, as probably nothing is going to happen to them?\n. This is merged in right place https://github.com/mishoo/UglifyJS2/commit/20542a37a88393393279ae031f8925efed1f4573\n. I have https://github.com/mishoo/UglifyJS/pull/517 quite similar PR. :) Yet seems that this repository is the wrong place.\nCould @mishoo disable issues and PR, as probably nothing is going to happen to them?\n. ",
    "zhanhb": "I guess uglify won't fix this.\n. I guess uglify won't fix this.\n. ",
    "qacwnfq": "Any Idea when this will be merged?. Any Idea when this will be merged?. "
}