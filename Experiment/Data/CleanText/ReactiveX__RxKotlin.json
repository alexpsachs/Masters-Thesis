{
    "benjchristensen": "Bug filed at https://youtrack.jetbrains.com/issue/IDEA-130626\n. @quidryan Any idea what would cause this? It seems to be a dependency of Nebula that only gets triggered when importing RxKotlin. This doesn't happen with RxJava so I don't understand what is unique about RxKotlin.\n. Actually, forget my last comment, it happens with RxJava as well so this is not unique to RxKotlin.\n. We can copy over the new build/release config from RxJava in these locations:\n- https://github.com/ReactiveX/RxJava/tree/1.x/gradle\n- https://github.com/ReactiveX/RxJava/blob/1.x/.travis.yml\nThen I can update the .travis.yml file with the encrypted credentials for Bintray and Sonatype. Then you can build and release just via git tags via Travis. \n. I think it's ready to go. Let me know when the code is ready to release and I can do the first one so I can debug through any issues. \nWhat version number do you want for this, 1.0.0?\n. RxJava is at 1.0.8: https://github.com/ReactiveX/RxJava/releases\n. Trying to track the RxJava version would be difficult to do reliably as every patch release would require a release of RxKotlin. Also, that approach would fall apart the first time you need to release without RxJava having released. Or if you need to do a breaking change that bumps RxKotlin to 2.0. \nThe various projects are decoupled so they can have different lifecycles. \n. A release can go whenever wanted. @MarioAriasC should have the ability already. Just let me know if there is something not working or needing guidance if it is unclear. \nAnyone with commit privileges can tag the branch and it will trigger a build and release. The version for the file and Maven Central is the Git tag name. \n\n. You can look at the build information on Travis to see the issue. It failed with a branch config issue.\nhttps://travis-ci.org/ReactiveX/RxKotlin/builds/64004943\nTrying to resolve.\n. I added the necessary config to build.gradle and now the release works fine the way you did it. I deleted and re-added the tag to release. \nBuild: https://travis-ci.org/ReactiveX/RxKotlin/builds/65133450\nBintray: https://bintray.com/reactivex/RxJava/RxKotlin/0.22.11/view\nMaven Sync: https://bintray.com/reactivex/RxJava/RxKotlin/0.22.11/view#central\n. ",
    "MarioAriasC": "Working on that\n. Hi, I just merge a change for Kotlin M10, so you need to rebase yours and also check why Travis is failing on your PR\nThanks\n. Nice. \n. :+1: \n. @benjchristensen Thanks for the info, let me discuss it with the community \n@cy6erGn0m @orangy @abreslav @hhariri do we want this to version 1.0.0? Probably we want something to said that is compatible with version M11 and so on \n. The most reasonable solution is to use kotlin versions, so 0.11 for this release and so on\n. @benjchristensen If we want to use Kotlin versions, in this case 0.11 or M11, 0.11 will be considered and older version compared to 0.21.0? Better if we use M11?\nThanks\n. @cy6erGn0m @benjchristensen sounds good\n. I create this release https://github.com/ReactiveX/RxKotlin/releases/tag/v0.22.11 \nI don't know if I made it right. \n@benjchristensen Could you confirm me?\n. Done\n. https://github.com/ReactiveX/RxKotlin/pull/16 was merged. You need a rebase\n. @cy6erGn0m any other comments on this PR?\nA :+1: from me\n. We're working on that\nMeanwhile you could build it form source and will work\n. You could follow this task  https://github.com/ReactiveX/RxKotlin/issues/15\nIn theory everything is ready, but for some reason isn't being published.\nNow we'll update to M12\n. Done and with M12 compatibility \n. Thanks, let me check it \n. Today, in theory\n. I get this one before https://github.com/ReactiveX/RxKotlin/pull/20\nIs practically the same as yours. I'll merge it and let you know if you need to rebase it\n. Next weekend \n. Use 0.22.13\n. I'll merge it and deploy it at midnight UK time\n. In fact look like is working...\n. :+1: \n. Sorted\n. Could you provide some tests?\n. Every kotlin library needs new releases until we get stable ABI\nRxKotlin for 1.0 Beta will be released a couple of days after the official Kotlin 1.0 Beta release \n. The version already change for Beta 2.\nCould you update your PR?\nThanks\n. Need to resolve conflicts\n. :+1: \n. :+1: \n. Is this ready to merge?\n. ok\n. Is this ready to merge?\n. ok\n. Working on it\n. Fixed\nhttps://twitter.com/dh44t/status/695429427870601216\n. Already resolved \nhttps://github.com/ReactiveX/RxKotlin/releases/tag/v0.40.1\n. :+1: \n. :+1: \n. :+1: \n. Paisa, se la voy a pasar solo por ser compatriota \n:stuck_out_tongue_winking_eye: \nMentiras, esta muy bien\n:+1: \n. We're working on that, Travis is being a bad boy in the last week.\nBut the code as is on branch 0.x will work with Kotlin 1.0 and RxJava 1.1.1 if you want to build it for your self.\nWe'll publish a proper 1.0 version next week\n. Sorted, checkout version 0.55.0 https://github.com/ReactiveX/RxKotlin/releases/tag/v0.55.0\n. Is useful but...\nYou need to add tests for any PR\n. We're having problems with our build infrastructure, we're working on that\nMeanwhile you could try this one\nhttps://jitpack.io/#reactivex/rxkotlin/v0.50\n. Sorted https://github.com/ReactiveX/RxKotlin/releases/tag/v0.55.0\n. In our case RxKotlin is the project AND only module. AFAIK, and you should take it with a grain of salt, we need to have a module for RxKotlin and other for RxKotlinMath. Namely two modules in a project.\nThat will require deep changes on build.gradle \n. Also I dunno how it will work with Bintray (that actually is failing at this very moment)\n. I like the idea of having several RxKotlin* modules under ReactiveX/RxKotlin umbrella, it will promote Kotlin in general, I don't think that is impossible to sort it out just difficult.\nOnce we have the first one we could add more things   \nLet me sort out the whole \"BintrayGate\" and we could think on something...\n@cy6erGn0m ^^^ What do you think? \n. I sorted it out the \"BintrayGate\", we could start discussing this again\n. \ud83d\udc4d \n. Actually sounds quite right \n. Thanks\n. Try with a non extension function, maybe it could work, something like\nkotlin\nobservableDefer(x)\n. You'll need an explicit return type\n. Yes, we need to start working on that. \nWhat about supporting 1.*?\n. @ScottPierce currently we're working in a leadership transition, once is finished, works on 2.0 will be published (AFAIU there is already some advances). @cy6erGn0m Are you interested? You did a lot of clean up and put the library in good shape early on.\nThe maintainer should be a person with proved experience on both, Kotlin an Open source development.\n@JakeWharton agree. Maybe we should split the library in a core module and some utility modules with extras. We did have a discussion earlier but I didn't do any progress on that\n. What do you think @stepango ? \n. A few weeks ago I was speaking privately with @stepango and he accepts the leadership role over RxKotlin, Thank you. Your work is amazing, but there are people that are already using this.\nSo instead of deleting those extensions we could marked as deprecated and then we'll delete it in the next iteration.\nThat also will help people to understand the new API\nCould I raise a PR against your branch with the afore mentioned deprecations? \n. This one could be replaced by org.funktionale:funktionale-partials:1.0.0-final. ",
    "cy6erGn0m": "@letroll I believe you can close this issue as example was added. You also can find examples at SO such as http://stackoverflow.com/a/28959796\n. @MarioAriasC I believe it is implemented so we can close it\n. @MarioAriasC @benjchristensen So do you have idea when could it be released?\n. @MarioAriasC @benjchristensen  What about 0.22.11 ?\n. @MarioAriasC @benjchristensen It doesn't work: no release actually done\n. it would be great to get it in release #15 \n. You have to note that you generally don't need to create subscriber in this case. You can just do\nkotlin\nobservable.onError {.... } .subscribe { ... }\nSo you need this builder if you need to make subscriber and use it later and subscribe dynamically. In this case you will need to specify type anyway.\nHowever I believe it could be good to see this declarative builder too\n. With pull #16 subscribeWith could be implemented simply like this\nkotlin\npublic inline fun <T> Observable<T>.subscribeWith( body : FunctionSubscriber<T>.() -> FunctionSubscriber<T>) : Subscription {\n    return subscribe(subscriber<T>().body())\n}\n. @SalomonBrys I see, you will need dots in this case\n. I think we can go with it. Lets merge it and release then\n. It looks like you need\nkotlin\nfun <T> singleObservable(supplier: () -> T): Observable<T> =\n        deferredObservable { supplier().toSingletonObservable() }\nBtw I am not sure if it common enough to include it into the library \n. Looks good to me\n. @MarioAriasC AH I see, I didn't realize that there is already related pull request. It's ok to merge #21 instead of mine. \n. looks like take behaviour has changed. I guess it will fail without your changes too. We probably need to fix the test\n. @cbruegg i believe you can do it\n. Also I still see many warnings during compilation: it would be great to clean up all the occurrences \n. Failed test is\n`` kotlin\n    test funinfinite iterable should not hang or produce too many elements`() {\n        val generated = AtomicInteger()\n        kotlin.sequence { generated.incrementAndGet() }.toObservable().\n                take(100).\n                toList().\n                subscribe()\n    assertEquals(101, generated.get())\n}\n\n```\nLooks like take used to take more elements than needed but now it is fixed\n. looks good\n. good \n. ok\n. @MarioAriasC yes, it is\n. @MarioAriasC looks good to me\n. lgtm, @MarioAriasC ?\n. lgtm, @MarioAriasC ?\n. At least you can write something with it to ensure it compiles. So we will be sure it is possible to use it at least\n. @MarioAriasC any updates on this? users still can't use 0.50 neither via central nor jcenter \n. > They might help with readability\nThis is why they are here. Almost everything here is just to make code look better. \n. @MarioAriasC @thomasnield so, have you decided to transfer leadership finally?\n. @MarioAriasC   I just wanted a leader that is more Rx-experienced than me. I can take it if you don't have better candidates with both Kotlin and Rx experience\n. what is the idea of map { it as T } ? As far as I remember it will produce Observable<T!> rather than Observable<T>. Did you tried it?\n. wouldn't it look better completableOf { } instead of {}.toCompletable() ?\n. not sure it is good to have toSingle on every type everywhere. perhaps it is better to have singleOf(value) instead\n. ",
    "letroll": "Thank you very much\n. ",
    "orangy": "What is current version of RxJava? We probably want major/minor to match RxJava, and then use 3rd number to reflect Kotlin Milestone. E.g. if RxJava is 1.5, for M11 it would be 1.5.11\n. I see, makes sense. Then probably keep it at 0.11.* for M11, and when Kotlin releases, bump to 1.0?\n. I wonder if we can speed things up a little bit. If you don't have time/priority for releasing compatible Kotlin bindings for Rx, is it possible we can do it? \n. I strongly suggest against using extension functions on generic unbound types. They pollute code completion, slows down compiler. In this particular case it has also very generic name toSingle() which will be available on Sequence<T> for example, with a confusing meaning. \n. I don't see much value in using extension method here at all. singleOf is good enough. \n. ",
    "SalomonBrys": "Travis has failed because \"The command \"eval git clone --depth=50 git://github.com/ReactiveX/RxKotlin.git ReactiveX/RxKotlin\" failed 3 times.\" but this PR does pass all unit tests\n. Unfortunately not.\nThat was indeed my first try, but when using .onError {} .subscribe {}, RxJava will throw a OnErrorNotImplementedException in case of error because onError does not catch the error (only runs in case of error).\nThe correct syntax would be:\nkotlin\nobservable\n    .onErrorResumeNext {\n        it.printStackTrace()\n        /* Handle the error */\n        emptyObservable()\n    }\n    .subscribe {\n        /* Handle next value */\n    }\nThat is why I propose the syntax exposed in this PR ;)\n. @cy6erGn0m I don't think so since, even in #16, the setter function do not set the value of the current subscriber but create a new copied subscriber with the updated function\n. Done ;) (I did a merge, not a rebase)\n. Hi there. Any news on this PR?\n. ",
    "ScottPierce": "Is there an ETA on this?\n. Thanks for the update :-) :+1: \n. So I don't see any movement in this library pushing towards RxJava 2.0. Is anyone driving this?. For those following this thread, it looks like cold streams are planned for the Kotlin coroutines library, which would allow for stream apis that would be more familiar to someone coming from RxJava than coroutines. If done well, it might reduce / remove the need for something like this.. ",
    "tbruyelle": "I think I found how to write this correctly : \nkotlin\nfun <T> rxify(body: () -> T): Observable<T> = Observable.defer({ Observable.just(body()) })\n(I know the function name is terrible ^^)\n. ",
    "jmfayard": "I would have say \n``` kt\nObservable.from {\n     \"Helllo World!\"\n}\nfun  Observable.from(body: () -> T): Observable =\n        Observable.defer { Observable.just(body()) }\n```\nBut I have an error cannot access init, it is package * protected in Observable\n. ",
    "PaulWoitaschek": "With the latest releases of RxJava I think this can be closed. You can just use\nkotlin\nObservable.fromCallable { lib.method() }\n. ",
    "EddieRingle": "@MarioAriasC Thanks for merging! Can we expect a 0.22.12 release soon, then? :)\n. ",
    "JakeWharton": "Feel free to send a PR\nOn Wed, Sep 16, 2015 at 1:38 PM Gail Smith notifications@github.com wrote:\n\nCurrently using this library with in Android Studio 1.3.x and just updated\nAS Kotlin plugins to M13 (0.13.1513). Gradle build error states that this\nlibrary, RxKotlin-0.22.12.jar and funktionale-0.5.1d_M12.jar have an\nunsupported format. Any plans to update soon? Is there an ETA? Thank you.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/22.\n. Use version 0.40.1\n. kotlin\n@Test fun castExtension() {\n  val subject = BehaviorSubject<Any>()\n  val subscriber = TestSubscriber<String>()\n  subject.cast<String>().subscribe(subscriber)\n  subject.onNext(\"Hello\");\n  subscriber.assertValues(\"Hello\")\n}\n. To avoid putting the dependency on everyone using this library, it would\nhave to be another module under the RxKotlin project. This would let you\nchoose which extensions to use based on which of the Java projects you were\nusing.\n\nOn Wed, Mar 9, 2016, 4:25 AM Ron Suhodrev notifications@github.com wrote:\n\nHi,\nI really dislike the RxJavaMath library because it requires me to wrap my\nexisting observables.\nWith kotlin we can easily do this with extension methods.\nWith your permission, would love to add it to the library. This will\nentail a new RxJavaMath dependency though.\nWhat do you think?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/55.\n. Multi-modules should be relatively simple if that's the approach forward.\n\nOn Sat, Mar 19, 2016, 11:22 PM Mario Arias notifications@github.com wrote:\n\nI sorted it out the \"BintrayGate\", we could start discussing this again\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/55#issuecomment-198839192\n. > deferredObservable\n\nYou can already use defer { .. } with import rx.Observable.defer so :+1: to removing this.\n\nemptyObservable\n\nYou can use empty() with import rx.Observable.empty so :+1: to removing this.\n\nobservable\n\nThis just seem superfluous. Almost no one should be using create anyway. just, defer, fromCallable and fromAsync are all better choices that will prevent you from shooting yourself in the foot. :+1: to removing this.\n. You can already do fromCallable { .. } because of SAM conversion so why is this needed?\n. kotlin\nimport rx.Observable.fromCallable\ngets you that\n. The inclusion of this seems entirely superfluous. Completable.create isn't burdensome to write.. Let's use the major version to solve three problems with this library:\n- It's never had a stable release\n- It has no defined scope so it's historically been a random slew of\n  unrelated things.\n- It lacks internal consistency of what it does include.\nRight now I have a hard time seeing how someone could recommend its use vs.\njust copying out what you like/need.\nOn Sat, Oct 29, 2016, 12:59 PM Thomas Nield notifications@github.com\nwrote:\n\nRxJava2 is now released, so this probably should become a priority at some\npoint. I'm a bit overloaded with other initiatives right now otherwise I'd\ncontribute. Personally, I have to have RxJava-JDBC\nhttps://github.com/davidmoten/rxjava-jdbc ported over to RxJava2 before\nI even consider migrating. And then I have to migrate RxJavaFX\nhttps://github.com/ReactiveX/RxJavaFX and RxKotlinFX\nhttps://github.com/thomasnield/RxKotlinFX. There's quite a bit of work\nfor the Rx community to do.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/80#issuecomment-257102843,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEERD4BZE1FShCqEslVFNSfeb4mtxgks5q43t_gaJpZM4JtuBX\n.\n. I find it hard to justify an entire optional type in this library. The\nplatform type seems appropriate, and if you don't have Java 8 then you're\non your own.\n\nOn Tue, Jan 3, 2017 at 7:58 PM Thomas Nield notifications@github.com\nwrote:\n\nAfter a stable 1.0 release, the main priority of 2.0 should be coming up\nwith an Optional type, and creating nullable type interop and\nObservable> extension functions for operators.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/80#issuecomment-270269029,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEXByQTAFeDfRtIVJ7jPgDtfXH7i_ks5rOu7QgaJpZM4JtuBX\n.\n. Sorry I meant Java 8's Optional when i said \"platform type\"!\n\nOn Tue, Jan 3, 2017 at 8:13 PM Thomas Nield notifications@github.com\nwrote:\n\nBut the platform type won't emit if it is null, correct? I guess it makes\nsense that endeavor would something the user would implement on their side,\nwith Java 8, Guava, or whatever else.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/80#issuecomment-270271232,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEUCD2i4HmwWEe9458-ye110sFGFFks5rOvJKgaJpZM4JtuBX\n.\n. The package name must change along with the Maven coordinates to ensure that both can be used simultaneously.. Wow 2.x looks surprisingly good! Just did a quick review and the only thing that sticks out is the joinToString stuff which seems out of scope.. I am against all of those additions. I would even like to start a\ndiscussion about removing items from this library.\n\nOn Tue, Oct 25, 2016 at 3:55 PM MarcinMoskala notifications@github.com\nwrote:\n\nAlso big thanks, @MarioAriasC https://github.com/MarioAriasC I also use\nit in my project. But I also use lot's of own extensions and methods that\nmakes RxJava nice and simple.\nI fill that we can get more from Kotlin to improve RxJava. I have some\nfeatures and vision how this could work. I think that there should be a\ndevelop branch to allow discussion and consultations before adding features\nto master. I don't have a lot of experience in Open Source but I am using\nKotlin in production since Year and I ma writing book about it.\nSome examples of what I would like to add to this library. Of course we\nwill start a discussion before and create test:\nfun Observable.applySchedulers(): Observable =\nsubscribeOn(Schedulers.io())\n.unsubscribeOn(Schedulers.io())\n.observeOn(AndroidSchedulers.mainThread())\n// It is waiting for Kotlin to allow default lambdas in inline functions.\n// When it will be inline then it will be much quicker and better\n// because of no need for creating lambda functions which are not really\n// effective in Kotlin. They create new class for each new lambda method\nfun Observable.smartSubscribe(\nonStart: (() -> Unit)? = null,\nonHttpError: (HttpErrorWithBody) -> Unit = { e -> logError(e) },\nonNetworkError: (Throwable) -> Unit = { logError(it) },\nonFinish: (() -> Unit)? = null,\nonSuccess: (T) -> Unit = {}): Subscription =\naddStartFinishActions(onStart, onFinish)\n.subscribe(onSuccess, { onErrorImpl(it, onHttpError, onNetworkError) })\nfun Observable.addStartFinishActions(\nonStart: (() -> Unit)? = null,\nonFinish: (() -> Unit)? = null\n): Observable {\nonStart?.invoke()\nreturn doOnTerminate({ onFinish?.invoke() })\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/85#issuecomment-256157511,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEeW4AhrNbA5tgX6GAr_paI1Ufz6Lks5q3l7DgaJpZM4Kb_Se\n.\n. The scope of the library is already ill-defined. I would prefer those to be in a separate artifact than the core language adapter because there's no real bound on the number of mathematical functions that one could write. Just like we see now with people contributing any and all extension methods that have anything to do with the Rx it seems like the number would just grow and grow.. You cannot use non-public classes. They have historically and will in the\nfuture change in backwards-incompatible ways without warning.\n\nOn Wed, Mar 22, 2017 at 10:02 PM Chris Horner notifications@github.com\nwrote:\n\nI've also been thinking on how to deal with all the method overloads we\nneed to wrap. Take withLatestFrom() for example. Should we provide\nwrappers for the calls that take one, two, three, or four arguments? If\nthat's the case, should they be implemented as:\nfun  Observable.withLatestFrom(o1: ObservableSource, o2: ObservableSource, combiner: (T, T1, T2) -> R): Observable\n        = withLatestFrom(o1, o2, Function3(combiner))\nor:\nfun  Observable.withLatestFrom(o1: ObservableSource, o2: ObservableSource, combiner: (T, T1, T2) -> R): Observable\n        = withLatestFrom(arrayOf(o1, o2), Functions.toFunction(combiner))\nFunctions is a utility class inside of RxJava's internal package so I'm\nhesitant to use it, however it's what the first chunk of code ultimately\nexecutes. Does anyone have thoughts on this?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/103#issuecomment-288618155,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEVutu7wM4JPqjAeY1CJWp_3wZ7dpks5rofzUgaJpZM4MiBUk\n.\n. These seem better suited to side-effect operators, not part of the\nsubscription signature.\n\nOn Mon, Mar 20, 2017, 11:06 AM Marcin Moska\u0142a notifications@github.com\nwrote:\n\nThis it really useful. Example:\nsubscriptions += deleteEventApi.call(booking.id)\n        .applySchedulers()\n        .subscribeBy (\n                onStart = { view.progressBarVisibility = true },\n                onSuccess = { onBookingCancelled() },\n                onFinish = { view.progressBarVisibility = false }\n        )\nor\nsubscriptions += addEventApi.call(booking)\n        .applySchedulers()\n        .subscribeBy (\n                onStart = { view.showProgressBar() },\n                onSuccess = { showEventData(it) },\n                onFinish = { view.hideProgressBar() }\n        )\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/ReactiveX/RxKotlin/pull/105\nCommit Summary\n\nAdd onStart and onTerminate\nAdd order test\n\nFile Changes\n\nM src/main/kotlin/io/reactivex/rxkotlin/subscribers.kt\n   https://github.com/ReactiveX/RxKotlin/pull/105/files#diff-0 (32)\nA\n   src/test/kotlin/io/reactivex/rxkotlin/SubscribersFunctionsCallsOrderTests.kt\n   https://github.com/ReactiveX/RxKotlin/pull/105/files#diff-1 (167)\nM src/test/kotlin/io/reactivex/rxkotlin/SubscriptionTests.kt\n   https://github.com/ReactiveX/RxKotlin/pull/105/files#diff-2 (3)\n\nPatch Links:\n\nhttps://github.com/ReactiveX/RxKotlin/pull/105.patch\nhttps://github.com/ReactiveX/RxKotlin/pull/105.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/pull/105, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEU2Eb_MnN1kJo2XB7zbZ-xPCmYo5ks5rnrIYgaJpZM4Miuod\n.\n. Doesn't seem related to RxKotlin since it's a new operator. Should be a proposal on RxJava.. That's not a real version. You have to replace x.y.z with a real version.\n\nOn Sun, Mar 26, 2017, 4:18 PM hongjinbom notifications@github.com wrote:\n\nFailed to resolve: io.reactivex.rxjava:rxkotlin:x.y.z\nAndroid studio 2.3\nbuildToolsVersion: 25.0.2\ncompileSdkVersion 25\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/108, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEb_HgDryjoRjlpxnRQ06CUY4CNQHks5rpsf4gaJpZM4Mpktc\n.\n. It doesn't totally eliminate the benefit since it saves a single method\ncall which is non-zero time spent! But yeah it's mostly useless...\n\nOn Thu, Mar 30, 2017, 9:34 PM Stepan Goncharov notifications@github.com\nwrote:\n\nyou could use crossinline modifier like\n    = zipWith(other, BiFunction { t1, t2 -> zipper(t1, t2) })```\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/pull/109#issuecomment-290591541,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEYV6eiuuHOItUdRSaXHmuxcu2ml_ks5rrFg-gaJpZM4MvGyc\n.\n. More lightweight how?\n\nOn Sat, Apr 29, 2017, 8:25 AM Stepan Goncharov notifications@github.com\nwrote:\n\nI prefer rxKonan\ud83d\ude01 Pure kotlin reactive extensions implementation would\nbe more lightweight and could definitely take advantage from coroutines.\nAs an option, we could use https://github.com/akarnokd/RxJava3-preview as\na starting point, since it's already modular.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/115#issuecomment-298165895,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEfalIHGtRrQdFMY3cbqMeKsLW8O_ks5r0yxNgaJpZM4NKDx5\n.\n. Not quite sure why that's really different or inherently more lightweight\nthan a scheduler. On the JVM coroutines are backed by threads which loop on\na queue just like schedulers.\n\nOn Sun, Apr 30, 2017, 11:24 AM Thomas Nield notifications@github.com\nwrote:\n\n@stepango https://github.com/stepango @JakeWharton\nhttps://github.com/JakeWharton also lightweight in that a\ncoroutine-backed RxKotlin would use fibers instead of threads. Coroutines\nnaturally handle backpressure so we would not have any overhead for that as\nwell.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/115#issuecomment-298238461,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEWKFIKcfliHus8CQA0Oj7rOBSTObks5r1KejgaJpZM4NKDx5\n.\n. That prevents SAM conversion. They should be replaced with lambda types.\n\nOn Wed, May 10, 2017 at 10:23 PM Stepan Goncharov notifications@github.com\nwrote:\n\nMy first goal with https://github.com/stepango/RxKotlin3-preview is\nsolving #103 https://github.com/ReactiveX/RxKotlin/issues/103 by\nreplacing io.reactivex.functions. with kotlin.functions.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/115#issuecomment-300664625,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEYmyI7ULWkhSP4CPpAdIdC7BYk0fks5r4nEcgaJpZM4NKDx5\n.\n. This would be a binary incompatible change and it's a non-public API. You\ncan add this function to your own codebase where the use of internal APIs\nis much easier to manage. As a library this project cannot use internal\nAPIs.\n\nOn Sun, May 28, 2017, 1:24 PM Rory Kelly notifications@github.com wrote:\n\nChange implementation of\nfun Disposable.addTo(compositeDisposable: CompositeDisposable): Disposable\nto\nfun Disposable.addTo(compositeDisposable: DisposableContainer): Disposable\nThis would enable the use of custom DisposableContainers. The current\nimplementation limits use to CompositeDisposeables.\nFor example, on Android it is possible to build a DisposableContainer\nthat auto-disposes based on the Android lifecycle. However it is not\npossible to use observable.addTo(myCustomDisposeable)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/127, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEf5eAllmhvNeJFVqQz60SdW2ukTkks5r-a3ngaJpZM4NotFU\n.\n. DisposableContainer is not an RxJava public API. I would be supportive of adding an artifact with an overload that takes Duration for Java 8 users. The factory property that creates a Duration from 10.seconds does not belong in this project.. This is definitely possible with plain RxJava and is the intended behavior of this RxKotlin operator.. This seems of limited use. The reason RxJava omits type parameters is that the common case is combining streams of different types.. The map is wasteful to append since it's only to appease the type system.\nAn unsafe cast on the filter is enough.\n\nOn Thu, Feb 22, 2018 at 12:08 PM Igor Manushin notifications@github.com\nwrote:\n\nAdd method the same with in kotlin documentation -\nhttps://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-not-null.html\nfun  Observable.filterNotNull(): Observable (source)\nimplementation is in single line:\nfun  Observable.filterNotNull(): Observable (source) = filter { it != null }.map { it as T }\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/172, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEESJ4Wve9-f6SbGwMn21ZRCLGx8pNks5tXZ8DgaJpZM4SPqSa\n.\n. In practice this will be the exact same thing as the generic parameter will be widened to Any. For example, combineLatest(listOf(just(1), just(\"hey\")), values -> /* it's Array<Any> here */). Reification doesn't offer anything here.. It is the case. The best way to solve this would be overloads though.\n\nOn Wed, Mar 7, 2018 at 3:16 PM Thomas Nield notifications@github.com\nwrote:\n\nI think I reversed the order for that reason that passing one nameless\nparameter attached to the onSuccess(). Now if this isn't the case\nanymore, it needs to be investigated and possibly changed.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/174#issuecomment-371268046,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEUszAfs3i_w3tstpbUsUUSve6ykzks5tcD5HgaJpZM4SbDZ9\n.\n. Sure but then the other extensions are needlessly wide in the types they accept.\n\nI don't see any reason to not accept this PR for parity's sake alone. . Dupe of #127. If you update them, by the time there's a new release they'll probably both be out of date again. This project rarely releases. Also the versions are forward compatible so it really doesn't matter. People who care about what version of Kotlin and RxJava they're using are specifying dependencies on them to ensure the new version is used. It's infeasible for every library to release every time a dependency has a new version.. Yes\nOn Fri, Jun 15, 2018 at 9:21 AM Ashish Krishnan notifications@github.com\nwrote:\n\nSo, using the latest version of a dependency should override the version\nspecified in this project. Right?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/183#issuecomment-397618091,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEETh6R3WnPE4LH7Qw0TQ9LkegLA7dks5t87TugaJpZM4UpejL\n.\n. This is a binary-incompatible change. They're placed in the sections that they are relevant to instead of as noisy nonsense at the top that no one looks at and needlessly pushes the actual relevant content down even farther\u2013potentially below the fold on mobile.\n\n...but I don't have a strong opinion or anything.... Woo! I'm slowly converting the world over!\n(I don't even remember if I was involved in the argument for their positioning on this project or not.). Why does that belong here and not in the couroutine Rx library that's part\nof couroutines.\nOn Sun, Mar 3, 2019, 10:15 AM GuangGuang <notifications@github.com wrote:\n\nHello dev:\nI just want some \"rx-kotlin-coroutine\nhttps://github.com/hltj/kotlinx.coroutines-cn\" feature that like\nrxandroid\nhttps://github.com/ReactiveX/RxAndroid/blob/e58f44d8842c082698c1b5e3d367f805b95d8509/rxandroid/src/main/java/io/reactivex/android/schedulers/AndroidSchedulers.java#L46\neg:\npublic final class CoroutineSchedulers {\n/** A {@link Scheduler} which executes actions on {@code CoroutineScope}. */\n\npublic static Scheduler from(CoroutineScope stop) {\n\n    //...\n\n}\n\n\n\n /** A {@link Scheduler} which executes actions on {@code Dispatcher}. */\n\n public static Scheduler from(Dispatcher dispatcher) {\n\n    //...\n\n}\n\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/issues/211, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEVgB-d_Asovsb2-yjedIGLb-z1KPks5vS-cUgaJpZM4bbC9h\n.\n. What does this add over just an import of the static method directly from Observable?\n. I personally don't find that as a compelling argument. fromAsync by itself\noffers no description as to what you are actually even creating for it to\nbe a top-level function by itself. Besides, what you describe is an IDE\ndeficiency, not a language problem to be solved by adding a new function.\n\nAdditionally, by that logic there should also be top-level functions for\njust, from, concat, zip, etc. if no one wants to use imports which seems\nridiculous.\nOn Thu, Aug 18, 2016, 12:19 PM Ralph Bergmann notifications@github.com\nwrote:\n\nIn src/main/kotlin/rx/lang/kotlin/observables.kt\nhttps://github.com/ReactiveX/RxKotlin/pull/78#discussion_r75339969:\n\nimport rx.Observable\n import rx.Subscriber\n import rx.Subscription\n import rx.observables.BlockingObservable\nfun  emptyObservable() : Observable = Observable.empty()\n fun  observable(body : (s : Subscriber) -> Unit) : Observable = Observable.create(body)\n+fun  fromAsync(body: (s: AsyncEmitter) -> Unit, mode: AsyncEmitter.BackpressureMode): Observable = Observable.fromAsync(body, mode)\n\nI know you prefer static imports but then I have to remember this import\nrule because there is no help from the IDE to add this import.\nWith this method I have autocompletion from my IDE when I begin to enter\nfromAs.... It's just to make my work easier.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveX/RxKotlin/pull/78/files/253783be99b54149779b8d76cb57ab1e28959cf7#r75339969,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEYBUnEzKxfCwg0uBECVh46_tLhquks5qhIX3gaJpZM4JnpMR\n.\n. In RxAndroid we dropped nebula. It hurts more than it helps.. What's with all the added trailing whitespace?. Does the argument need an explicit type?. This shouldn't exist. The whole point of defer is the function is deferred to create an Observable. If you already have one there's no point in calling defer.. These two are a bit ridiculous. This should wrap in OnErrorNotImplementedException . \n",
    "cbruegg": "Now that's weird. My code changes shouldn't have caused any changes to the behaviour. Investigating..\nEdit: I've taken a look at the failed test. I might be wrong, but shouldn't generated.get() return 100?\ngenerated is initialized with the value 0. It is then incremented by one 100 times, so its final value should be 0 + 100 = 100.\n. Would it be ok to adapt the test within the scope of this PR? I could do it in that case.\n. @cy6erGn0m I don't see any warnings with the 07c7c88 commit anymore.\n. ",
    "akarnokd": "Hello. I'm not into Kotlin and I assume you use RxJava's take() operator. The take() operator has been changed a few months ago to not request too much. Could you tell me what the tests supposed to verify?\n. Thanks!\n. It is explained in the JavaDoc:\n\nNote on method signature: since Java doesn't allow creating a generic array with new T[], the implementation of this operator has to create an Object[] instead. Unfortunately, a Function<Integer[], R> passed to the method would trigger a ClassCastException.\n\nAs the apply method first tries to cast the Object[] into Integer[] which is not possible. I'd guess Kotlin has the same restrictions.. RxJava Schedulers use daemon threads so your application quits once the first range has been emitted. Use Thread.sleep(10000) to see there is repetition.. You have to block the main thread by some means.. FYI, the next releases of RxJava are due within two weeks:\n- 2.1.17 on July 23, 2018: https://github.com/ReactiveX/RxJava/issues/6089\n- 2.2.0 on July 31, 2018: https://github.com/ReactiveX/RxJava/issues/6092. This is what just does on its own, why defer a practically constant source? Besides, just allows nice optimizations in merge, flatMap, concatMap, switchMap etc.\n. ``` java\nvar x = calculate();\nobservableDefer(x);\n```\nWhen you call observableDefer, you already have the value x and the calculation is not deferred at all. What you want is something like Observable.fromCallable(Callable<T>):\n``` java\nObservable.fromCallable(() -> {\n    System.out.println(\"Deferred\");\n    return 1;\n});\n// when we get here, nothing is printed\n```\n. This is an internal interface and should not be depended upon outside RxJava.. ",
    "maarek": "Cannot resolve FunKTionale M13\nLooks like funktionale requries jcenter repository.\n. ",
    "kamoljan": "nice!\n. ",
    "Laimiux": "I've added a single test, let me know if you want more tests or you would like to change this current test. \nBy any chance you know, why in KotlinTests.kt, variable 'a' is of a ScriptAssertion type and not of an Observer? \n. No problem. Let me know if anything else is needed.\nCheers\nLaimonas\n. ",
    "fatlazycat": "Thanks\n. ",
    "damianw": "Closing because beta 4 has been out for a while\n. Closing because beta 4 has been out for a while\n. ",
    "zsxwing": "requireNoNulls, withIndex have similar issue as well.\n. Go ahead :) You can also fix requireNoNulls and withIndex as well. Just use the existing operators instead of lift.\n. Resolved by #39 \n. Mind sending a PR? Thanks!\n. This is incorrect. The returned Observable may be subscribed with multiple Subscribers.\n. Not. E.g.,\no2 = o1.withIndex()\no2.subscribe(s1)\no2.subscribe(s2)\nEach subscribe should use a new index. But in your current implementation, it shares the same index between different subscribes.\nI know nothing about Kotlin. But in RxJava, you can implement it using o.zipWith(Observable.range(0, Integer.MAX_VALUE)).\n. ",
    "dsvoronin": "i use this extensions func in my projects, works well, can PR\npublic fun <T : Any> Observable<T?>.filterNotNull(): Observable<T> = filter { it != null }.map { it as T }\n. @zsxwing i added test for multiple subscribers, and used range as you suggested\n@cy6erGn0m i removed rx map operator, and just unsafe casted it to Observable, it still works correctly, but maybe less hacky now. What do you think?\n. filter{it!=null} -> (we still have T?, but T in runtime because no null values will be passed) (compiler can't smart cast here, because kotlin is not aware of rx filter), so we need somehow  cast value ->\nmap {it as T} will give us T! , you're right, but it compiles correct, and we won't get runtime exceptions.\nSome kind of hack i know. Do you have better solution?\n. You speaking of thread safe access to index, right?\n. ok, i'll add test for multiple subscribers and fix it somehow. thanks for review!\n. ",
    "carlbenson": "Great, didn't realise. Thanks!\n. ",
    "pt2121": "Thanks!\n. OK. I will update it.\n. ",
    "caipivara": ":P \n. @thomasnield what do you mean by \"It has its own version numbering system loosely tied to RxJava\" ?. ",
    "MarioArias": ":+1: \n. This one should be updated to org.funktionale:funktionale-partials:1.0.0-final.. ",
    "mikehearn": "thanks!\n. ",
    "marcin-kozinski": "That's a great rule! :smiley: I wanted to add tests, but couldn't really think of anything useful... Since this is only a shorthand that just calls existing RxJava method. Would you consider useful to just check if the original method is called and if the arguments match?\n. Test added!\n. ",
    "ultimate-deej": "I have no idea on how to test this\n. @JakeWharton you read my mind\n. I believe these functions are here to to comply with standard Kotlin functions like emptyArray, emptyMap etc.\nSo they do add something kotlin specific, at least emptyObservable.\n\n. ",
    "rshah": "Thank you. I'm using it now.\n. Sorry for the noise, seems fixed after fixing the retrofit side, and change FunctionSubscriberModifier<Unit> to FunctionSubscriberModifier<Unit?>\n. ",
    "maxandron": "Should I structure the folders in a similar way to how https://github.com/square/retrofit is structured?\n(Put a folder named RxKotlinMath at the root of this repository?)\n. As I see it, the pro for multi-modules is that everything is in one place (easier to find for users) and the con is that discontinuing support for the module might be more messy than in a different project.\nIn my opinion though, making multiple rxkotlin modules is the best way\n. I see, thanks.\nI thought this library was adding kotlin specific readability helpers. These three methods could just as well be in the original RxJava api.\n. ",
    "thomasnield": "Maybe RxKotlinMath should be a separate project then...\n. FYI, I started an rxkotlin-math library. I plan on using this quite a bit so it should grow fairly quickly. \nhttps://github.com/thomasnield/rxkotlin-math\n. @stepango @maxandron not quite out Maven-wise but will be soon! . I agree with @JakeWharton here. Pretty much any function that is not an extension function should be removed. These resemble more syntactic saccharine than syntactic sugar. They offer minimal readability benefit and makes moving from RxJava to RxKotlin more convoluted, and many will keep using the RxJava factories anyway. \nBesides, if people want them that badly they can implement these functions themselves on their domain with little effort, to the point it is not even worth creating a library for. That's the great thing about Kotlin. You can create your own DSL for your needs. \n@stepango would you like me to put in a PR removing all these functions?. Sounds good.. concat_all() will be in the next release. . Cool, would you like me to make a PR? The only disadvantage is you can't enforce all arguments to be assigned at compile time.\n. I'll put in PR soon. Needed to confirm this is an okay pattern before I continue porting rxjava-extras to rxkotlin-extras. I'd prefer to follow any conventions established here.\n. I put in a PR. Maybe there is a way to have the generics be inferred, but I don't know how. Here is a DSL for the collect() operator. \n``` kotlin\nimport rx.Observable\nfun  Observable.collect(op: CollectDSL.() -> Unit): Observable {\n    val collectDSL = CollectDSL()\n    op.invoke(collectDSL)\n    return collect({collectDSL._stateFactory!!.invoke()}, {r,t -> collectDSL._collector!!.invoke(t,r)})\n}\nclass CollectDSL (\n    internal var _stateFactory: (() -> R)? = null,\n    internal var _collector: ((T,R) -> Unit)? = null\n) {\n    fun stateFactory(stateFactory: () -> R) {\n        _stateFactory = stateFactory\n    }\n    fun collector(collector: (T,R) -> Unit) {\n        _collector = collector\n    }\n}\n```\nAnd here is the usage. \n``` kotlin\nval source = Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\")\nsource.collect> {\n    stateFactory { HashSet() }\n    collector { str, set -> set += str  }\n}.subscribe { println(it) }\n```\nUnfortunately I have to specify the types for this new variant of collect(). Otherwise the compiler will  not be able to figure out the types. Does anybody have ideas to have the types be completely inferred? I'm not even sure if it is possible... \n. It would be ideal if this could be achieved. I don't know if there's some functional tricks that could be used, but I can't think of anything...\n``` kotlin\nval source = Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\")\nsource.collect {\n    stateFactory { HashSet() }\n    collector { str, set -> set += str  }\n}.subscribe { println(it) }\n``\n. My colleague @edvin proposed using named arguments to support inferring. I'm not sure which approach to use. Both are valid, but the latter would not be consistent withsubscribeWith()`. But it's cleaner. \n``` kotlin\n    val source = Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\")\nsource.collect(\n    stateFactory = { HashSet() }\n    collector = { str, set -> set += str  }\n).subscribe { println(it) }\n\n```\n. I think I'm going to go with the solution I posted previously by @edvin. I can't think of any cleaner way to do this. I'll continue my PR in this direction unless anybody has objections... \n``` kotlin\n    val source = Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\")\nsource.collect(\n    stateFactory = { HashSet() }\n    collector = { str, set -> set += str  }\n).subscribe { println(it) }\n\n```\n. Im going to abandon this initiative. Too much work and not enough benefit. Not even sure if it's technically feasible. . We decided to go the direction of not having standalone function factories. See #58. We decided to go the direction of not having standalone function factories. See #58. We decided to go the direction of not having standalone function factories. See https://github.com/ReactiveX/RxKotlin/issues/58. I agree.  We probably should support both 1.0 and 2.0 as long as 1.0 is supported. That could be a long time I imagine. \n. RxJava2 is now released, so this probably should become a priority at some point. I'm a bit overloaded with other initiatives right now otherwise I'd contribute. Personally, I have to have RxJava-JDBC ported over to RxJava2 before I even consider migrating. And then I have to migrate RxJavaFX and RxKotlinFX. There's quite a bit of work for the Rx community.\n. Btw, I guess we have a problem with nullable types and RxJava 2.0. I think you have to use a Guava/Java 8 Optional\nclass NullableCarrier<T>(val value: T?)\nfun <T> T?.carry() = NullableCarrier(this)\n. @JakeWharton I can live with minimizing the amount of functionality in this library. \n. After a stable 1.0 release, the main priority of 2.0 should be coming up with an Optional type, and creating nullable type interop and Observable<Optional<T>> extension functions for operators. . But the platform type won't emit if it is null, correct? I guess it makes sense that endeavor would be something the user would implement on their side, with Java 8, Guava, or whatever else.. Ah that makes sense now, okay I'll drop it then.. I agree that package convention would be better.. See #95 for 2.0 candidate codebase.. @JakeWharton Glad you like it! I pushed the joinToString() because I reduce emissions into a concatenation all the time. @stepango was initially questioning of the scope though as well, so if my personal needs are creeping in, I have no problem having it shot down.\nThe only merit I can give to it besides my anecdotal belief others might need it... it mirrors Kotlin collections and sequence's joinToString(). It seems appropriate and useful on the Rx side too.\nEither way, I don't mind if we rid it. . I had another idea to consider... how about an extension function that adds 5 days to each LocalDate emission?\nkotlin\nfun Observable<LocalDate>.addFiveDays() = map { it.plusDays(5) }\n(I keed, I keed). @JakeWharton In all seriousness, does that mean 'withIndex()' is out of scope too? One perspective we could maintain is asking whether an addition we make  is an official ReactiveX operator, rather than going rogue and augmenting our own. I have no problem sticking to that practice, but what does that mean for 'withIndex()'?. This is more or less solved using the mergeAll() extension function we added. \nhttps://github.com/ReactiveX/RxKotlin/blob/2.x/src/main/kotlin/io/reactivex/rxkotlin/operators.kt#L15\nFor instance, here is how I zip the letters of three strings with three corresponding numbers:\n```kotlin\nimport io.reactivex.Observable\nimport io.reactivex.functions.BiFunction\nimport io.reactivex.rxkotlin.mergeAll\nimport io.reactivex.rxkotlin.toObservable\nfun main(args: Array) {\nval source1 = Observable.just(\"Alpha\", \"Beta\", \"Gamma\")\nval source2 = Observable.range(1,3)\n\nval zipped = Observable.zip(source1, source2, BiFunction<String,Int,Observable<Pair<String,Int>>> { s, i ->\n    s.split(\"\").toObservable().filter { it != \"\" }.map { it to i } }\n)\n\nzipped.mergeAll().subscribe(::println)\n\n}\n```\nOUTPUT:\n(A, 1)\n(l, 1)\n(p, 1)\n(h, 1)\n(a, 1)\n(B, 2)\n(e, 2)\n(t, 2)\n(a, 2)\n(G, 3)\n(a, 3)\n(m, 3)\n(m, 3)\n(a, 3)\nI would prefer to keep these flatZip() functions out of this library though. They feel a bit niche and can easily be implemented on your own domain. \nThat's one of the great things about Kotlin. If a library doesn't have a specific  method you want, you can create an extension function on your side.\n. Considering we already updated dependencies I get we are good here. . Thanks @MarioAriasC for bringing this library to where it's at today. My team and I use it daily. \nI'll stay at the end of the line in terms of leadership candidacy, and it sounds like others are interested already. I'm busy already maintaining RxJavaFX and RxKotlinFX. I also have my full-time job and some O'Reilly projects. \nBut I'll do my best to be an active and contribution member of the community, and can take stewardship if others become too busy.\n. @MarcinMoskala You can always contribute too, and you certainly don't need to own the repository to do that : ) I cast my vote for @stepango since we need someone who has done some open-source projects, and it looks like he's done the less fun work of porting to RxJava2. A good maintainer has a mind for stability in my opinion, and is willing to do the non-sexy work. The community can always put in pull requests with innovations, and he/she can push back or accept it in alignment with the project's vision.\n. Alright let's grant collaboration rights to someone. I think @stepango is a good fit for ownership. I'd step up and do it but I'm swamped until Spring next year. I can help. \n. Excellent! Thanks @MarioAriasC. Hey @stepango, I will file some issues for some proposals. In the upcoming Packt Book Learning RxJava I'm writing, I have a chapter dedicated to Kotlin, and I'd like to cover RxKotlin as a library in a 1.0/2.0 release state if that's possible. To get a 1.0 release out, I think the main task is to eliminate some of the API's and make it more minimalist...\n. But a merge() is essentially what a flatMap() does,   just dynamically for an unlimited number of sources via emissions. These conventions are already used in RxPy  as well.  But I'll be open to revision if that's what others want. . I'm afraid I don't follow. The Observables are being emitted already within the Observable. No lambda arguments are needed for these extension functions.. Awesome! I'll take a look later.... I was thinking about that for a few days. Makes sense but it's too bad. Is there a way to present each action as a named parameter to subscribe()?. ```kotlin\nimport io.reactivex.Observable\nfun main(args: Array) {\nObservable.just(\"Alpha\", \"Beta\", \"Gamma\")\n        .subscribe(onNext = ::println, onComplete = { println(\"done\") })\n\n}\nfun  Observable.subscribe(onNext: ((T) -> Unit)? = null,\n                                onError: ((Throwable) -> Unit)? = null,\n                                onComplete: (() -> Unit)? = null) = subscribe(onNext, onError, onComplete)\n``. RxJava2 doesn't accept null anything it seems. I guess you can just create a hard observer in the implementation then.... @stepango is it possible you can merge what you have into 2.x? I'd like to start contributing to this and it might be easier to centralize it into the repository.. Make sense. I'll start a separate library.. I started putting a library together. https://github.com/thomasnield/rxkotlin-math. Shoot wrong branch. One moment.. Sounds like this was all implemented on your end @stepango. Thanks!. I'll take a look at this first thing tomorrow. It's getting late here in Texas.. I like it, especially the implementation ofsubscribeBy(). I wish there was another name for that but I can't think of anything better sincesubscribeWith()` is used by RxJava 2.0. I think the vision of making this as minimalist as possible is a good one. After all, Kotlin makes it easy for people to create their own extension functions for their own domain purposes.\nI did put in two comments of things I'm skeptical of and perhaps should be removed. I think this should be good to merge otherwise. If we can get a release as soon as possible, that would be swell. Then we can start working on RxKotlin 2.0.. @stepango is there anything else you are thinking about for 1.x?. Excellent! I'll go through this again in a few hours and then we can start a discussion on release. Then we can do 2.x next. . Ive only given thought on things to remove. I'll see if there are any useful things to add, but I'll shy from anything radical so we can get this out. . After I make those style changes in my last commit, of course, when I get home.. I tried to do a deployment but it does not seem to be triggering on a GitHub release. \nhttps://repo1.maven.org/maven2/io/reactivex/rxkotlin/\nI updated the README with instructions on how to do a JitPack build with Gradle/Maven. But we will need to figure out what is going wrong before we officially release 1.0. . Darn it my bad, I did it again. I think we were both making changes to the README. I'll fork that next time. . We should probably scrap the onCreate() example since it doesn't have much value anymore. I made changes to the README to be more current and focus on what the library emphasizes now. Let me know what you think.. I think we should move package convention from rx.lang.kotlin to io.reactivex.rxkotlin to match Maven coordinates. \nWe can do that last after we review and merge. . I'll figure out why tests are failing as well... . Okay, fixed all test issues. Feel free to take a look at this branch. After that, I will move to the new package convention, archive the old 2.x under \"2.x-old\", and create a new \"2x\". The package rename will make the conflicts not worthwhile to address, and therefore no good reason to merge. . Will do . What's funnier is it builds fine in Travis. \nhttps://travis-ci.org/ReactiveX/RxKotlin/builds/210790128\n. This issue seems to have gone away. Not sure why, but I'll close this now. . I am debating removing some of these operators that require a conversion to an Observable to work with an Observable operator.  mergeAllMaybes() is a definite since there is a flatMapMaybe(). But concatAllMaybes() might be pushing out of scope since there is no concatMapMaybe().  This also applies to Single and Completable.\n```kotlin\n/*\n * Concatenates the emissions of an Flowable>.\n /\nfun  Observable>.concatAllMaybes() = concatMap { it.toObservable() }\n/*\n * Concatenates the emissions of an Flowable>.\n /\nfun  Flowable>.concatAllMaybes() = concatMap { it.toFlowable() }\n/*\n * Emits the latest Maybe<T> emitted through an Flowable<Maybe<T>>.\n /\nfun  Observable>.switchLatestMaybe() = switchMap { it.toObservable() }\n/*\n * Emits the latest Maybe<T> emitted through an Flowable<Maybe<T>>.\n /\nfun  Flowable>.switchLatestMaybe() = switchMap { it.toFlowable() }\n``. Decided to rid those operators. You can easily do atoObservable()conversion within amap()before aconcatAll()orswitchLatest()`. . Yes this is something that everyone is working around. I believe JetBrains acknowledged the issue but I don't know how soon a fix will happen with the compiler. \nhttp://stackoverflow.com/q/42635968/1373258. I was thinking about this a lot today. I think it is definitely worth exploring. My recommendation is to start with only a few operators and we can play with them. If everyone feels good giving the greenlight and ensures there will be no major issues with extension function nuances, we can help implement the rest. \nI do wonder how long it will be before JetBrains resolves the issue. If it takes awhile this is probably a worthwhile effort to explore.. Feel free to put in a PR with a few common operators first. Then we will test it out and determine if it belongs in this project or a separate project. . One thing that's a shame is we cannot statically add extension functions. So we cannot fix static factories.\n```kotlin\n    @Test\n    fun rxExtensionTest() {\n        Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\",\"Epsilon\")\n                .publish()\n                .autoConnect(2)\n                .let {\n                    Single.zip(it.count(),it.toList()) { i,list -> i to list } // compile error\n                }.subscribeBy(onSuccess = ::println)\n    }\n@Test\nfun rxExtensionTest2() {\n    Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\",\"Epsilon\")\n            .publish()\n            .autoConnect(2)\n            .let {\n                it.count().zipWith(it.toList()) { i,list -> i to list } // okay\n            }.subscribeBy(onSuccess = ::println)\n}\n\nfun <T,X,R> Single<T>.zipWith(other: Single<X>, combiner: (T,X) -> R) =\n        zipWith(other, BiFunction<T,X,R> { t, x -> combiner.invoke(t,x) })\n\n``. Ugh, this initiative is going to be a pain. Trying to fixSingle#subscribe` and I can't resolve this compile error. There is a lot of these that are going to have to be defined. If someone does it successfully, they are owed a beer. \n```kotlin\n    @Test\n    fun rxExtensionTest2() {\n        Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\",\"Epsilon\")\n                .publish()\n                .autoConnect(2)\n                .let {\n                    it.count().zipWith(it.toList()) { i,list -> i to list }\n                }.subscribe(::println) // compile error\n    }\nfun <T> Single<T>.subscribe(onSuccess: (T) -> Unit) = subscribe( Consumer { onSuccess.invoke(it) })\n\nfun <T,X,R> Single<T>.zipWith(other: Single<X>, combiner: (T,X) -> R) =\n        zipWith(other, BiFunction<T,X,R> { t, x -> combiner.invoke(t,x) })\n\n``. @chris-horner I'm not crazy about the idea to use aliases. Ideally, when JB creates a fix for this lambda inference problem, the cutover should be as simple as removing theimport` at the top of each file where these extensions are being used. \n. For the record, I think this is the official issue on YouTrack:\nhttps://youtrack.jetbrains.com/issue/KT-14984\nI do hope this gets fixed sometime this year. Otherwise the burden is going to be on RxKotlin to get clever with this problem.. This looks like it is based on very old code,  like from the 0.x branch. . Okay,  this PR is not necessarily current then. The 1.x and 2.x branches reflect some major changes that occurred with this part of the API. \nYou can feel free to look at those and propose any changes : ). Hmm... I'm not sure about this. Although it can be useful for some cases, it feels out-of-scope because it deviates from ReactiveX conventions. The doOnSubscribe(), doFinally(), doOnTerminate(), etc... kind of fulfills this functionality already, and I don't know if we want to break Rx convention by putting these in the Observer/`Subscriber.  This project has taught us a high volume of innocent conveniences like this can shoot us in the foot, and make this library a Frankenstein's monster. \nBesides, you can always implement this on your own domain easily, but I don't think it has weight to be standardized. @stepango feel free to weigh in. I do appreciate the proposal though.\n. @JakeWharton agreed. I think merging this would embark us on another rabbit hole we already visited.\n@MarcinMoskala I think it is best to not tamper the subscription signature like Jake Wharton says. It could muddy the Rx idioms and make RxKotlin confusing, especially to Rx newcomers. I do appreciate the proposal though. I'll leave the floor open for awhile before closing. . Your link seems to be broken.... Interesting. I do something like this quite a bit within a flatMap(), concatMap(), or switchMap() to evaluate each emission and determine whatObservable to return.\nkotlin\n  Observable.just(true, false, true).flatMap { \n            if (it) \n                Observable.range(1,5)\n            else \n                Observable.empty()\n        }\nBut that wasn't really too hard to do in Kotlin. Java, maybe. At that point I might as well just use the approach above.Perhaps there might be value in the factory, but I personally don't know how many folks need it. Here is another example that really isn't too bad. Kotlin makes if expressions pretty easy already:\nkotlin\n        (if (myCondition)\n            Observable.range(1,5)\n        else\n            Observable.empty()\n        ).subscribe(::println)\n@stepango and @JakeWharton, what do you guys think?\n. @JakeWharton @oliveiradev I think to further clarify the scope of this project, if RxJava can effectively express the operator in Java (such as this one), then it should be proposed there first. But if RxJava cannot express it due to limitations of the Java language, then it might be candidate for RxKotlin (e.g. Observable<Observable<T>> extension operators like mergeAll()). \nSo I agree with @JakeWharton  on this. . For the record, 2.0.0 is the latest version if you are using the new io.reactivex.rxjava2 group id. Cool, so does this mean we can use the same signatures from a usage standpoint? Can the inline and crossinline enable that?. Ill take a look at this today. Sorry been quiet, trying to meet deadlines at work.. Looking at this now. Started building an application at work and this has been driving me crazy. I will help getting all the extensions in if this approach works.... Wow nice, that actually works. \n```kotlin\npackage io.reactivex.rxkotlin\nimport io.reactivex.Observable\nimport java.util.concurrent.TimeUnit\nfun main(args: Array) {\n    val source1 = Observable.interval(1, TimeUnit.SECONDS)\n    val source2 = Observable.interval(300, TimeUnit.MILLISECONDS)\nsource1.withLatestFrom(source2) { x,y -> x to y }\n        .subscribe(::println)\n\nThread.sleep(10000)\n\n}\n```\nI think I have an idea for the static factories. What if we were to create an ObservableKt and FlowableKt objects with zip(), combineLatest(), etc...? \n. @chris-horner excellent, let's move forward with this then. I propose moving everything related to SAM fixes to ObservableKt and FlowableKt, and have extensions reside next to the static factories. We may need to create SingleKt and MaybeKt as well. . @stepango where do you think we should put these development efforts? A separate branch in the main repository? Or work against Chris'?. I'm liking this ObservableKt approachs. Feels much cleaner than I thought it would be: \nkotlin\n val newSSIMData = ObservableKt.combineLatest(newSSIMFile.toObservable(), selectedDateRange) { ssim, dates ->\n        SSIMRecord.forSSIMFile(ssim)\n                .toList().subscribeOn(Schedulers.io())\n    }.switchMap { it.toObservable() }\n     .replay(1)\n     .autoConnect()\nHaving some trouble getting the Function3 overload of combineLatest() to compile: \n```kotlin\nobject ObservableKt {\n    inline fun  combineLatest(source1: Observable, source2: Observable, crossinline combineFunction: (T1,T2) -> R) =\n            Observable.combineLatest(source1, source2,\n                    BiFunction { t1, t2 -> combineFunction(t1,t2) })!!\ninline fun <T1,T2,T3,R> combineLatest(source1: Observable<out T1>, source2: Observable<out T2>, source3: Observable<out T3>,\n                                      crossinline combineFunction: (T1, T2, T3) -> R) =\n        Observable.combineLatest(source1, source2, source3, Function3<T1,T2,T3,R> { t1,t2,t3 -> combineFunction.invoke(t1,t2,t3) })!!\n\n}\n```\n. Got it, never mind. \n```kotlin\nobject ObservableKt {\n    inline fun  combineLatest(source1: Observable, source2: Observable, crossinline combineFunction: (T1,T2) -> R) =\n            Observable.combineLatest(source1, source2,\n                    BiFunction { t1, t2 -> combineFunction(t1,t2) })!!\ninline fun <T1,T2,T3,R> combineLatest(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, crossinline combineFunction: (T1,T2, T3) -> R) =\n        Observable.combineLatest(source1, source2,source3,\n                io.reactivex.functions.Function3<T1, T2, T3, R> { t1: T1, t2: T2, t3: T3 -> combineFunction(t1,t2, t3) })!!\n\n}\n```. I created a new branch and ported over @chris-horner's work and added some more operators. \nhttps://github.com/ReactiveX/RxKotlin/tree/sam-adapters\nPlease help and contribute anyone who wants to get involved. I will try to add more each day until it is done. . Closing in favor of https://github.com/ReactiveX/RxKotlin/pull/114. Yeah a few weeks back we discussed this at length in the #rx channel on Kotlin Slack. The conclusion we came to is not to force upon people a specific Optional implementation but rather just let people choose their own and create the wanted extension functions on their own domain. \nAFAIK, there is no idiomatic way to handle Optionals in RxKotlin that is worth standardizing until 1) Java 8+ is used everywhere or 2) RxJava is completely rewritten from scratch in Kotlin, which I don't think is going to happen. . Closing assuming this has been answered. If not please reopen.. We can put something towards the 1.x branch if you want. Fair enough. @elton2048 you should let RxJava call onComplete for you once the sequence terminates. There is absolutely no reason you should ever have to call it from onNext. Do you need some resources to demystify RxJava events? I can provide some.... I will look into Travis build errors later. For now, I see we need to create SAM adapters for the following operators, for ObservableKt, FlowableKt, MaybeKt, and SingleKt where applicable: \n\nObservableKt.combineLatest()\nObservableKt.zip()\nObservable#zipWith()\nObservable#withLatestFrom()\n\nThere might be some needed for flatMap() and concatMap() overloads as well. Please let me know if I am missing any others.\n. Not quite sure why the Kotlin compiler is not liking ObservableKt, FlowableKt, SingleKt, and MaybeKt. It says these are duplicate JVM classes. Looking through the .class files and I'm not quite sure if I see any duplicates. I really like those names and want them to work. I'd rather change what they are clashing with. \n\n. Renamed ObservableKt to Observables, FlowableKt to Flowables, etc... to resolve build issues at the moment. . My compiler struggled if I didn't.. I'll follow up this weekend on this.. @chris-horner Couldn't figure out the BiFunction not inferring correctly, but was able to clean up the others.. Yes, this is a discussion we recently started having on the #rx channel in Kotlin Slack. While we initially thought it would be impractical to do a pure Kotlin implementation due to the amount of work, Roman from JB enlightened us about how coroutines could be used to make an Rx implementation trivial.\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md\nI haven't dived into this deeply yet but from what he told us it sounds promising. It is definitely something we want to explore and we welcome any involvement in early discussions as well as implementation if we decided to go forward. . @stepango @JakeWharton also lightweight in that a coroutine-backed RxKotlin would use fibers instead of threads. Coroutines naturally handle backpressure so we would not have any overhead for that as well. . I agree, regardless there will at least be an easier to use, more maintainable Rx implementation in pure Kotlin. I'm kind of busy for the next week or two with kotlin-statistics and the Packt RxJava book. Im also shooting a Talking Kotlin episode with JetBrains on Kotlin for Data Science. After i get all that done, I will start looking at making an implementation.. Hmmm... interesting. Do you think that a fork will be the easiest approach? My intuition and research suggests that RxKotlin with a coroutine implementation may take a drastically different route as it doesn't need backpressure implemented. I may be experimenting from scratch just to see what emerges with that approach:\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md\n. Alright cool, let me know what you find and we will compare notes as we get some progress.. I have a POC in the works here. Need to figure out how to implement backpressure and cancellation https://github.com/thomasnield/rxkotlin-poc. So I talked to a number of folks to get an idea how hard it would be to make an RxKotlin implementation that would work on the JVM, JS, and Native. It's a lot to take on, and there's a lot of contingencies that need to take place. The coroutines library will need to be implemented for Kotlin JS and Native, which it sounds like JB has not even started exploring yet. This leaves this initiative largely in limbo. When those contingencies finally come into place, it will be quite a bit of work modularizing RxKotlin in a way that allows an implementation for each platform.\nThe only thing that could immediately be worked on then is RxKotlin for JVM, whose benefit is largely marginalized due to the issue above. RxJava 2 is benchmarked and optimized heavily already, and while it carries a few inconveniences being in Java, I believe the matter of using time and energy of eliminating those inconveniences with a pure implementation is debatable. If someone does want to pursue a JVM implementation now, it would be wise to modularize it to allow the other platforms once they are ready.\nIn summary, I believe it's too soon to start working on a pure RxKotlin implementation due to coroutines not yet existing on multiple platforms. If someone wants to work on it for the JVM, have at it. I may still tinker with my small POC but will likely not do anything more at the moment. If anybody has clever ideas or wants to show their experiments, please share with us. \nIn the interim, I'm going to focus on smaller, more attainable initiatives this year. . New article about this by @akarnokd \nhttps://akarnokd.blogspot.hu/2017/09/rewriting-rxjava-with-kotlin-coroutines.html. For the record, Jake Wharton has been doing a lot more experimentation on this front. It seems multi-platform efforts would be better directed there:\nhttps://github.com/JakeWharton/Reagent/\n. Yes, that was from RxKotlin 1.0. I just updated the README for RxKotlin 2.0 with the obsolete code you kindly pointed out. Thank you.. This is valid. We might need to put a blockingSubscribeBy() in 2.x. Thanks. . Thanks! Regarding OnErrorNotImplemented, I'm not sure that is a good question. Let me take a look later before we do the next release, and consider removing it in favor of the one available in RxJava.. Correction, parameters are named correctly. It's getting late. But the first issue remains.. If these are simply wrappers for the SAM issue, I don't think there's a huge need for unit tests. However, I will take a look at this and merge tomorrow. Thank you!. I'll be in San Diego all this week so I won't be doing any GitHub work until I get back. @stepango you dont have to wait for me so you can merge whenever. Might want to add a Pair extension for toMap() as well. Is there a combineLatestWith() natively with RxJava? I know there is a withLatestFrom() which is similar but only triggers from the invoked Observable.. Okay, i see there is a combineLatest() already in this library that I must have overlooked. I don't agree with it being there, even if it's name is changed to combineLatestWith(). I do think a factory overload for combineLatestWith in Observables and Flowables that yield Pair and Triple would be great though.. And again, the reason is because it does not exist in the original RxJava implementation as an operator, only a factory.. I went ahead and cherrypicked the ideas from this PR  to implement following:\nObservables#zip(): Pair<T1,T2>\nObservables#zip(): Triple<T1,T2,T3>\nObservables#combineLatest(): Pair<T1,T2>\nObservables#combineLatest(): Triple<T1,T2,T3>\nObservable.zipWith(): Pair<T1,T2>\nObservable.withLatestFrom(): Pair<T1,T2>\nI'm deprecating combineLatest() as an operator, and not going forward with combineLatestWith() although that would have been a more sensible name for it. \nFeel free to reopen this PR if I missed anything or you feel strongly about any of the above changes. . Thanks @JakeWharton . This will already be merged in #125. I'll leave this open though until we actually merge it. . Never mind on toObservable(). This only existed for Single, but I'm still going to deprecate it as it clashes with other toSingle() extensions. . I changed my mind, I see the merit of toMaybe() especially against nullable types. I'll leave in toSingle() as well. . This wasn't documented explicitly for RxKotlin, but we follow the same policy.. I am confused... can you not just specify the RxJava dependency you want on Gradle/Maven? . From my experience, the specified version of RxJava will be chosen (and override RxKotlin's) if you just explicitly specify it like this in Gradle/Maven:\ngroovy\ndependencies {\n    compile 'io.reactivex.rxjava2:rxjava:2.1.1'\n    compile 'io.reactivex.rxjava2:rxkotlin:2.1.0'\n}. No worries, that's a valid concern. Ill document that later.. We already have an addTo() I think that does this. If not, yes it should be added.. Just confirmed we do have this with the addTo() function. I'm going to close, but feel free to open again if I'm missing anything.. Interesting, but I'm contemplating if this is idiomatic. We've already got some extensions that do things likeObservables.zip(source1,source2) which returns an Observable<Pair<A,B>>. I think most folks are going to prefer that syntax. Thoughts?. Thank you for this. I ran into this issue a week ago and never followed up, but you beat me to it. . I'll look into this soon. Sorry I'm going to be a little in over my head the next two weeks.. I'm surprised we don't have these already. Rather than concatWhatever() or concat(), how about we just call all of themconcatAll()? I believe this is the convention from RxPy.\nWhile we are on this topic, I'm contemplating if we should extend switchMap() for Singles (switchMapSingle()), Completables (switchMapCompletable()) , and Maybes (switchMapMaybe()) because that is the road we are going on now.... I don't think this is optimal as this would deviate the ReactiveX standard operators, which is something we decided some time ago. While it is tempting to add every operator we can think of due to extension functions, such conveniences belong on one's personal domain.  \n. Please reopen if you still feel differently though. . I'm following up on this stuff this weekend. Yes, they both need to go away, all toMaybe() and toSingle() extensions.. @alexbirkett you can always implement it on your own domain. These extensions were highly problematic and clashed with other libraries that put toMaybe() and toSingle() on specific types.. Thanks @ajalt . Are we all good here? Or is this still a work-in-progress?. Okay, I'm going to start drafting up a release. Let's leave this for another release if it we want to still pursue it. Thanks guys. . Thanks.. Yes, RxJava2 does not support emitting null values and will immediately throw errors if it encounters them. \nThis means nullable types in Kotlin cannot be used as emissions, and you have to resort to Java 8 or Guava Optionals, or other wrappers for null values. \nThe only way this will be fixed is for a reactive implementation to be built in Kotlin from scratch, which is an ongoing discussion. . It is not tied to the Kotlin version. It has its own version numbering system loosely tied to RxJava.. Oh sorry I misunderstood. I'll take a look later.. @caipivara I fixed the description. RxKotlin 2.x corresponds to RxJava 2.x, but the x is not synchronized. . Yes, this would be an entirely new artifact targeting Java 8. However I can't prioritize such an initiative right now, so anyone else is welcome. . Agreed with @JakeWharton . It's not very often you would use a common type T but rather more often different types. Also it may cause confusing in the API when Any starts to pop up. Closing unless I get pushback. . I think I reversed the order for that reason that passing one nameless parameter attached to the onSuccess(). Now if this isn't the case anymore, it needs to be investigated and possibly changed. . @BoD Try this and you should see it works with the current setup:\nkotlin \nmySingle.subscribeBy { result -> println(result) }\n@JakeWharton and yes, overloads are probably the most effective way to fix this. Accepting PR's from anyone as I'm kind of busy right now. . I have a sense that this goes beyond the scope of RxKotlin. Such extension functions can be implemented on one's own domain if they are needed. . Sorry I completely skimmed through this too quickly. This makes sense. . @ansman can you resolve conflict and then I will merge? . Guys, I want to say book authors make so little on royalties it's rarely done for the money. We write them to help the community and legitimize a technology via a publisher, because we are passionate about the topic and the OSS work we contribute.\n. If you want to move the books to the bottom of the page, feel free to put in a PR. . I'm going to vote negative on this one. Not just because it looks weird, but because Observables/Flowables/Singles/Maybes are often used with a fluent style with chained calls, not one-step operator +-*/ calls. \n. Yeah we learned quickly in this project that some things implement should be on one's personal domain, not necessarily in a public library.. Sounds good. Can you put in a PR? . @akarnokd thanks for the heads up, I'll look at changes and see if it's worth waiting for.... I may promote this to a breaking release version 2.3.0, aligned with RxJava 2.2.0. \nI'm also trying to not let my OCD bother the fact RxKotlin and RxJava are not synchronized in release numbers, but they never have been anyway. . @bemusementpark affirmative, I'll try to do a release today.. Do we even manually invoke these functional types that often? I'm struggling to see practical use cases here. \nAlso, I don't see value in those toAction() extensions since SAM handling takes care of lambda conversion for us.. I'm not quite sure I understand the question. Why the compile error? . It's probably expecting an Observable instead of a Single, since that second example is dealing with an Observable chain. . @JakeWharton I'm thinking of bumping to a breaking release version anyway, and waiting for RxJava 2.2.0. . We break conventions. That's how we roll. (with Jake Wharton's blessing, of course). \nIn all seriousness, I agree with Jake. To add, I found a well-summarized code example at the top shows the intent of the library. \n. I kept looking for a timeline for this, did they announce any?. It looks like this is available as an experimental feature in Kotlin 1.3. Here is how to activate it: \nhttps://discuss.kotlinlang.org/t/new-type-inference-in-kotlin-1-3-0-rc-190/9914/2\n. It should be noted that all these extensions are likely to be deprecated anyway, with experimental new type inference in Kotlin 1.3\nhttps://youtube.com/watch?t=1447&v=MyljSWm0Y_k\nIll merge later.. Just merged. I think the reality is if Kotlin ever gets a reactive API, it is going to be completely from scratch and will not rely on the signatures of RxJava API. \nAlso, it will be a lot of work to create a stable multiplatform API. My hope is JetBrains will get involved in doing that. . feel free to reopen it. I'd like to upgrade Gradle and get off nebula. I still need to do that with RxJavaFX.. Because I think these functions masquerading as constructors are misleading. Maybe the serialized method makes sense though.. I'm not 100% sure what fold() accomplishes other than naming the parameters and giving an alternate name. Perhaps we should remove this?. Not quite sure about this one either. The onError() does not seem much different than doOnError().. I've been thinking about cast() and ofType() all day. It's a cool demonstration of Kotlin reification, but it kind of feels like a parlor trick with these extension functions. Honestly, it make usage somewhat mysterious and difficult to follow. I believe it is better to be explicit on what type you are ofType()-ing or cast()-ing to. I think we should remove both.\nkotlin\n    @Test\n    fun test() {\n        val strings: Observable<String> = \n            Observable.just(\"Alpha\", 1, \"Beta\").ofType() // ofType() to what?\n        strings.subscribe(::println)\n    }\n. I'm kind of torn on this again. Keep going back and forth. Okay let's keep it. . If we create such aliases to align with Kotlin operators, there is no reason not to alias skip() to drop(), skipWhile() to dropWhile(), and toMap() to associate(). This seems fine if we truly want to push Kotlin's conventions, and ReactiveX has a few aliases of its own (e.g. sample() and throttleLast()). But my concern is that folks will see these aliases as legitimate ReactiveX operators. When they go look up a marble diagram for drop(), they will not find one. It can make the operators a bit convoluted documentation-wise. \nPlus reduce() and fold() mean two different things in Kotlin sequences and collections (one has a seed and the other doesn't) which adds to the confusion since ReactiveX has reduce() do both. My personal sentiment is we keep Kotlin and Rx operators distinctly separate and follow ReactiveX's conventions, since after all this is a ReactiveX library. But if you think adopting the Kotlin naming conventions as aliases would be helpful, I won't resist that. . We'll revisit that idea if it makes sense later, or if there is significant demand for it despite our cautions.. Will do. . Okay Ill change that.. I propose removing combineLatestWith() since this is not natively available in RxJava. . ",
    "jakubkrolewski": "I don't think that the RxKotlin project should contain extensions to every possible RxJava* library. Instead, RxJava* libraries should provide Kotlin modules.\nSo in my opinion, this issue should be closed and an issues \"Add Kotlin module\" should be added to RxJavaMath.\nI think this is a similar approach that @JakeWharton used for the https://github.com/JakeWharton/RxBinding library. The code in Kotlin modules is generated automatically, so maybe this is also possible for RxJavaMath.\n. ",
    "stepango": "@maxandron rxKotlin not the best place for math extension. Since https://github.com/thomasnield/rxkotlin-math is out I think it's better to continue the discussion there.. Closed in favor of https://github.com/gradle/gradle-script-kotlin. @thomasnield I'll prefer to deprecate it first and remove it in one of the future releases. Agreed with @JakeWharton, @maxandron and @thomasnield. This functions will be removed in upcoming 1.x and 2.x along with some others. Feel free to reopen this issue for further discussion.. Outdated. Closing, check https://github.com/ReactiveX/RxKotlin/issues/58 for details. Working on it https://github.com/ReactiveX/RxKotlin/pull/87. Good point. I'll think about it. . @MarioAriasC Thanks for this great library! I used it a lot in my last two projects. And even ported 90% of it to RxJava2 for current one. And yeah, I'm interested!\n. @MarioAriasC I'm in!\n. @thomasnield totally agreed with you, first thing I'll focus is 1.0 release. Waiting for access rights to repo to make it happen.. @thomasnield thanks a lot. Porting subscribeWith was a good exercise but looks like i'll drop it from rxKotlin 2.x and rxKorlin 1.x as well. Probably release it as a separate artefact later.. @thomasnield that's exactly what I'm thinking about. The only problem is - the name of a function, ide will not auto-import it because of the name clash. subscribeWith is taken already and has different semantics in rxJava2. As an option, function could be named subscribeBy. Any ideas?. RxJava2 don't accept null params in subscribe(). @iNoles I know about import aliases, do you have some particular use case in mind?. @iNoles don't get it. What exactly do you mean? Any code examples?. @thomasnield was just about to do that. Finally, have some free time this weekend.. Looks good for me, I was not sure about subjects but yeah it pollutes auto-completion more than help to write more expressive code. Please take a look at https://github.com/ReactiveX/RxKotlin/pull/91. @thomasnield No more ideas for 1.0 yet. Feel free to merge this PR.. Thanks, @thomasnield. Sure, go ahead.. Updated readme a little bit https://github.com/ReactiveX/RxKotlin/pull/93. Closing. Thanks, @thomasnield looks good. I'll go through 1.0 and 2.0 RC once more to double check if anything is missed from the RC's.\nClosed https://github.com/ReactiveX/RxKotlin/pull/94. @thomasnield Check out this changes for the next RC. . Would be great to have this kind of extensions in rxKotlin. Feel free to make a PR. . As an experiment, I replaced all usages of io.reactivex.common.functions.* by kotlin.jvm.functions.* https://github.com/stepango/RxKotlin3-preview. As a result - no more SAM adapters in Kotlin code \ud83c\udf89 Any feedback highly appreciated.. Thanks for pull request but I agree with Jake and Thomas. There is no point to add onStart and onFinish in subscribeBy method. Because in no different from doOnSubscribe and doOnFinally. \nsubscriptions += addEventApi.call(booking)\n        .applySchedulers()\n        .doOnSubscribe { view.showProgressBar() }\n        .doFinally { view.hideProgressBar() }\n        .subscribeBy(onSuccess = { showEventData(it) }). Agreed with @JakeWharton here, useful operator in some cases but not related to rxKotlin.. What's your use case? Since callable produce only one item only toSingle and toMaybe fits well.. Looks good, but please mark all methods as inline.. you could use crossinline modifier like\ninline fun <T, U, R> Maybe<T>.zipWith(other: MaybeSource<out U>, crossinline zipper: (T, U) -> R): Maybe<R>\n        = zipWith(other, BiFunction { t1, t2 -> zipper(t1, t2) }). @thomasnield @chris-horner yeah idea sounds good, let's make a separate branch for it. I personally prefer to use Optional, for Android you could try kOptional or funKTionale's Option.. I'm afraid this extension should have a different name because it's ambiguous what method exactly are you trying to call. \nCompletable.andThen(CompletableSource) \nHave same signature from Kotlin's perspective. Both have SAM parameter and both are transformed to andThen(() -> T)\nDo you have a different name in mind? . Let me give you an example.\n1. Let's add your extension to a project\ninline fun Completable.andThen(action: () -> Completable) = andThen(action())\n2. Let's call Completable.complete().andThen { Completable.complete() } in some random file\n@eygraber what method would be called?\n. ```\nobservableFunction.subscribeBy( \n    onNext = { status ->\n        println(\"onNext\")\n    // Do the task in onComplete function\n    onComplete()\n},  \nonError = {},\nonComplete = ::onComplete\n\n)\nfun onComplete() = println(\"onComplete after onNext\")\n``\nWhy you could ever need to callonCompletetwice?. I preferrxKonan`\ud83d\ude01 Pure kotlin reactive extensions implementation would be more lightweight and could definitely take advantage from coroutines.\nAs an option, we could use https://github.com/akarnokd/RxJava3-preview as a starting point, since it's already modular.. Theoretically by using inline functions and Kotlin stdlib extension functions overall method count of library itself should be less than rxJava's equivalent.. Just started to play around RxJava3-preview(Basically it's just rxJava2 but separated to 4 modules). Finally, manage to replace Action by Function0. And all tests still pass \ud83d\udcaahttps://github.com/stepango/RxKotlin3-preview. Initially my plan was to make this implementation useful and than move internal implementation to Coroutines. . My first goal with https://github.com/stepango/RxKotlin3-preview is solving https://github.com/ReactiveX/RxKotlin/issues/103 by replacing io.reactivex.functions.* with kotlin.functions.*. No need to add more blocking api's for rxJava2. . Would be great to add some tests . @matwood just checking params ordering should be enough, I know it's not super useful, but I'll prefer to have it. @marcinsus pairZipper does not make any sense, you could just use ::Pair with one of rxKotlin's extension methods if you like\nAgreed with you on 1. Regarding 2nd - I think of it like a default zipper. On my latest project, I found that in 90% Pair/Triple all I needed from zip/combineLatest methods. . @marcinsus Observables.zip(Observable.just(1), Observable.just(1), ::Pair)\n. @marcinsus you are right about ::Pair looks like a bug that type inference does not work for method references if method has overload with same amount of params https://youtrack.jetbrains.com/issue/KT-18080. @thomasnield no, there is no combineLatestWith and withLatestFrom behave differently. I don't think it's necessary to rename combineLatest to combineLatestWith it could confuse people. LGTM\nThis approach was implemented when RxJava2 have no OnErrorNotImplementedException built in.. Looks good!\n@bmaslakov add extension for Iterable<Flowable> as well. Looks good!. Consider using Observable<Optional<String>> for this kind of cases.. you haven't disposed 2nd subscription\n.subscribe({\n                        ++num\n              ---->>>it.subscribe({\n                            log(\"window7\", \"\u7b2c${num}\u6b21\u8ba2\u9605\uff1a$it\")\n                        })\n                    }). @ansman could you provide few examples of cases you are talking about?. @ansman but this example is not correct from RxJava perspective * effectively mean Any? but potentially you can't have nulls in your stream.\nval maybe: Maybe<Any> = Maybe.just(\"foo\")\nval stringMaybe = maybe.ofType<String>()\nwill work just fine.. Guys from Kotlin announced Experimental mechanism for libraries same as for compiler experimental features. Probably we could use it to support new type inference. . Keep Don't . Any chance for nebula to work with gradle 3+?. kotlin.String -> String. Looks like default kotlin formatting settings in one of the last plugin releases.. Nope. Agreed, forgot to delete it before commit. yes. Reimplement using OnSubscribe* interfaces. remove (). Why remove subjects?. You are absolutely right. Don't see a point of this method either.. fold have same semantics as stdlib's https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html seems reasonable . agreed on you with that but \nval strings = \n            Observable.just(\"Alpha\", 1, \"Beta\").ofType<String>()\nMakes sence, it's up to develpoer to write a good code. Fair enough, now I see your point more clearly. You are right, let's remove it.. 1.1.2-2 is the latest one. avoid wildcard imports. code formatting in all file. why !!?. ",
    "svenjacobs": "@orangy Would be restricting toSingle() to primitive types be a better approach?\n. I thought since singleOf(T) already exists a delegating extension function on a generic type would not be such a problem since extension functions have to be explicitly imported.\n. @MarioAriasC Any news on this?\n. Closing this due to lack of feedback\n. ",
    "lenguyenthanh": "It doesn't work so I close this.\n. fun<T> observableDefer(x: T) = Observable.defer { Observable.just(x) }\nDoes it look good?\n. Thanks, I'll create a PR for this one.\n. Just to remove Observable.\n. Thanks man, I got this. Close again :D\n. IMO, we should keep supporting both 1.x and 2.x. We can versioning follow rxJava convention.\n. I don't want to calculate x right away so I use defer outside of just. Does my understanding correct?\n. Thanks man, it's extremely simple. I was stupid :D\n. ",
    "the4thfloor": "https://github.com/ReactiveX/RxKotlin/pull/74\n. I know you prefer static imports but then I have to remember this import rule because there is no help from the IDE to add this import.\nWith this method I have autocompletion from my IDE when I begin to enter fromAs.... It's just to make my work easier.\n. ",
    "chris-horner": "PR updated to use the new Observable.fromEmitter() in RxJava 1.1.10.\n. Some of this can be solved by creating extension functions such as\nkotlin\nfun <T1, T2, R> Observable<T1>.withLatestFrom(other: ObservableSource<T2>, combiner: (T1, T2) -> R): Observable<R>\n    = withLatestFrom(other, BiFunction { a, b -> combiner.invoke(a, b) })\nI'm happy to do some legwork and get a PR up, but is it in scope? I do like how RxKotlin has become much simpler. I think the removal of factory functions was a good idea, and getting around this issue would involve making several new factory functions. Perhaps it's its own library?. Hmm \ud83e\udd14. I'm not sure it's possible to fix Single#subscribe given that it can take both a Consumer and a BiConsumer.\nPerhaps the best approach is to introduce another extension function that aliases to subscribe(Consumer). Naming that function is really challenging though. successSubscribe? optimisticSubscribe? subscribeOrDie? subscribeForSuccess?\nkotlin\nfun <T> Single<T>.subscribeForSuccess(onSuccess: (T) -> Unit) = subscribe(Consumer(onSuccess))\nI mean, you can just have a named lambda argument\nkotlin\n.subscribe { result -> println(result) }\nbut it means you can't use method references. (Not to mention IntelliJ suggests you can quick-fix to a method reference when you actually can't).. I've also been thinking on how to deal with all the method overloads we need to wrap. Take withLatestFrom() for example. Should we provide wrappers for the calls that take one, two, three, or four arguments? If that's the case, should they be implemented as:\nkotlin\nfun <T, T1, T2, R> Observable<T>.withLatestFrom(o1: ObservableSource<T1>, o2: ObservableSource<T2>, combiner: (T, T1, T2) -> R): Observable<R>\n        = withLatestFrom(o1, o2, Function3(combiner))\nor:\nkotlin\nfun <T, T1, T2, R> Observable<T>.withLatestFrom(o1: ObservableSource<T1>, o2: ObservableSource<T2>, combiner: (T, T1, T2) -> R): Observable<R>\n        = withLatestFrom(arrayOf(o1, o2), Functions.toFunction(combiner))\nFunctions is a utility class inside of RxJava's internal package so I'm hesitant to use it, however it's what the first chunk of code ultimately executes. Does anyone have thoughts on this?. Unfortunately marking the functions as inline requires marking the lambda parameters as noinline, which I believe obviates the benefit?. Hmmm. Apparently not?\n\nAm I missing something?. Learnt new things about SAM adapters today! Changing to this style fixes the issue.\nkotlin\ninline fun <T, U, R> Observable<T>.withLatestFrom(other: ObservableSource<U>, crossinline combiner: (T, U) -> R): Observable<R>\n    = withLatestFrom(other, BiFunction<T, U, R> { t, u -> combiner.invoke(t, u)  })\nPR updated.. The ObservableKt approach may be our best bet for now. I like it more than defining some loose factory functions like zipObservables(). If KT-14984 is ever addressed then it's relatively easy for consumers to lop the Kt off the end of the object name and then they're using the official method.. Have a look at the methods I've defined that you've copied across. Function3, 4, and5all work without being fully qualified. Perhaps IntelliJ's not grabbing the correct import for you?. nit: I know people aren't often going to be reading this file, but I feelcombineris a nicer name thancombineFunction.. Any particular reason for the fully qualifiedFunction`s?. ",
    "aldoborrero": "Yeah, having covered both versions could be very helpful indeed. As @thomasnield said I'll gladly contribute.\n. ",
    "sorinirimies": "@ all so is there a plan to support rxJava 2.0? Thx.\n. ",
    "tadfisher": "Should the package name change to io.reactivex.kotlin?. ",
    "dajulia3": "would love to get this merged :) . ",
    "MarcinMoskala": "Actually we have\n(1..10).toObservable()\nhttps://github.com/ReactiveX/RxKotlin/blob/0.x/src/main/kotlin/rx/lang/kotlin/observables.kt\n. Also big thanks, @MarioAriasC I also use it in my project. But I also use lot's of own extensions and methods that makes RxJava nice and simple.\nI fill that we can get more from Kotlin to improve RxJava. I have some features and vision how this could work. I think that there should be a develop branch to allow discussion and consultations before adding features to master. I don't have a lot of experience in Open Source but I am using Kotlin in production since Year and I ma writing book about it. \nSome examples of what I would like to add to this library. Of course we will start a discussion before and create test:\n```\nfun  Observable.applySchedulers(): Observable =\n        subscribeOn(Schedulers.io())\n        .unsubscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n// It is waiting for Kotlin to allow default lambdas in inline functions. \n// When it will be inline then it will be much quicker and better \n// because of no need for creating lambda functions which are not really\n// effective in Kotlin. They create new class for each new lambda method\nfun  Observable.smartSubscribe(\n        onStart: (() -> Unit)? = null,\n        onHttpError: (HttpErrorWithBody) -> Unit = { e -> logError(e) },\n        onNetworkError: (Throwable) -> Unit = { logError(it) },\n        onFinish: (() -> Unit)? = null,\n        onSuccess: (T) -> Unit = {}): Subscription =\n        addStartFinishActions(onStart, onFinish)\n                .subscribe(onSuccess, { onErrorImpl(it, onHttpError, onNetworkError) })\nfun  Observable.addStartFinishActions(\n        onStart: (() -> Unit)? = null, \n        onFinish: (() -> Unit)? = null\n): Observable {\n    onStart?.invoke()\n    return doOnTerminate({ onFinish?.invoke() })\n}\n```\n. Still on branch 0.x. I already did. I am now writing tests.. ",
    "Ganet": "@MarioAriasC I use Kotlin and RxJava pretty much daily as part of my full time job, and I also would be happy to contribute, but I am 100% sure there are much better candidates out there with very good experience handling open source development.\n. ",
    "jackmalpo": "What's the status on RxJava 2 implementation? Is anyone actively working on it yet?. ",
    "pabl0rg": "@MarioAriasC So, do we have a new project leader?  It would be great to use the Kotlin lib with RxJava 2. ",
    "pwittchen": "\n@JakeWharton agree. Maybe we should split the library in a core module and some utility modules with extras. We did have a discussion earlier but I didn't do any progress on that\n\n@MarioAriasC Please note, it's general purpose library, so it could be used in different projects. E.g. for web and desktop apps. It can be used not only Android and not only fo HTTP requests and with networking. I like the direction of RxAndroid where the library was simplified. Only stuff, which is commonly used remained there and rest of the utilities were removed. I agree with @JakeWharton and RxKotlin should go in the same direction. This library should be kept as simple as possible and additional features and utilities can be provided as external, totally independent libraries like for RxAndroid.\nMoreover, I would keep RxKotlin dependent on RxJava1.x aside RxKotlin dependent on RxJava2.x (as a  separate module or a separate Git branch) like in original RxJava project, because people still use RxJava1.x and there are projects dependent on it, which hasn't been migrated to the newer version of RxJava yet.\nP.S. It's kinda off-topic there, but such discussion is IMO important.. ",
    "drothmaler": "I think flatten, flattenAll or simply flatMap would be a better name (instead of mergeAll).\nBecause mergeAll indicates (to me), that the merge operator would be used (instead of flatMap). Sorry, my mistake... I thought, that merge would act similar to zip (where one observable 'waits' for the other). I should have looked at the linked documentation more seriously. :-S \nBut than I still have another question: why didn't you just use Observable.merge(Observable) instead of flatMap? This way you could avoid the extra mapping lambda. \n(Same for switchLatest -> Observable.switchOnNext(Observable) and \nconcatAll -> Observable.concat(Observable)\n. Well all three extension function that you added are using a mapping lambda (that is simply returning it's input)... e.g. 'concatMap { it }' . ",
    "iNoles": "@stepango According to https://kotlinlang.org/docs/reference/packages.html, you can use alias for name clash such as like \"import bar.Bar as bBar // bBar stands for 'bar.Bar'\". @stepango I was thinking about to use rxjava as import alias. . ",
    "oliveiradev": "Sorry, I fix that.. Yes @thomasnield , me too use that way, after time I create this function: \n``` kotlin \ninline fun  Observable.ifThen(condition: Boolean, thenSource: () -> Observable<>, \n        elseSource: () -> Observable<>): Observable<*>\n             = if (condition) thenSource() else elseSource() . Make sense!. ",
    "Jeevuz": "Ah, yes, you are totally right! Thanks for explanation. I was just curious. \nDumb question closed :). ",
    "ghost": "oh.. sorry x.y.z. ",
    "piotrek1543": "Well, you need to change x.y.z with exact version. The latest one is 2.0.0-RC1, so\n      compile 'io.reactivex.rxjava:rxkotlin:2.0.0-RC1'\n\nCheers. I see that you're using twice the same object, what about extracting to variables or use Kotlin built function like with(list[0])?. ",
    "eygraber": "I have them both in a project, and there's no ambiguity. Am I missing something?. @stepango I was using rxjava 1 \ud83d\ude48. @thomasnield that might be helpful in general, but I've moved on to rxjava 2 already \ud83d\ude01. ",
    "DasBonkers": "I think it's more of a generic question rather than that he needs twice.. ",
    "elton2048": "@thomasnield You are right. The onComplete  call should be called in the function if using create() method to build Observable but not in the subscribe function. Thanks for that.. ",
    "moltendorf": "Whether or not it's better or worse off, with the projects I'm starting being as cross-platform/cross-environment (JVM/JS/Native) as possible (honestly still uncomfortable trying something like native and how that will muck with what kind of libraries I can build or share between code bases), and already tasting some of RxKotlin, I'll just throw my hat in to say that a pure Kotlin implementation would make me love this project even more; and knowing just how advanced I already sort-of feel in Kotlin I'd like to know how really advanced I am when I inspect this project's source code and progress. Anyway, just trying to steer this toward a: let's get it implemented. Thanks!. ",
    "yangwuan55": "I want use the rx at kotlin native.Any plan for this?\n. ",
    "hugadams": "TY. ",
    "matwood": "These were just the additional definitions to help with the SAM typing issue in Kotlin. I didn't see any tests for the one that was already there, and I assumed because they are not very testable. If you have an idea how to test these, I can implement them.. @stepango Parameter order tests added. I also cleaned up some formatting on the original commit.. ",
    "marcinsus": "As for me, a useful feature. \ud83d\udc4d. @stepango two things: \n1. This types of method should be also in other method like latestFrom etc.\n2. It is very nice to use but for me it is little inconsistent with base rxjava which requires zipper to connect two observable. I am not sure if we change this behaviour some rx users can be little confused.\nAnother way to archive it is create helper method something like:\nfun <T, U> pairZipper(): (T, U) -> Pair<T, U> = { first: T, second: U ->\n        first to second\n    }. @stepango are you sure ::Pair is possible? I had problem with type inference when i try refactor something like that :\nObservable.just(3) .zipWith(Observable.just(\"\"), { a, b -> a to b})\nAlso in my case the most of usage when zip 2 observable is create pair so for me default zipper is ok. I am not sure but maybe default parameter instead method will be ok?\n. @stepango yeah, Observables.zip (and similar object method) work without problem but extension method like zipWith method has name conflict with rxjava method and ::Pair does not work.. ",
    "RoryKelly": "Sorry this is probably a dumb question, I don't understand where am I using a non public api?\npublic interface DisposableContainer {...}\nor \nfun Disposable.addTo(compositeDisposable: CompositeDisposable): Disposable\nAre you talking about the Android Lifecycle functions? I'm talking about the new android.arch.lifecycle package and LifecycleObserver/LifecycleRegistry which are public classes. \n. Just noticed it's in the io.reactivex.internal package. I'm guessing that's why it's non public, closing the issue and pull request. . ",
    "r-antolin": "replace io.reactivex:rxkotlin:2.0.3  for io.reactivex.rxjava2:rxkotlin:2.0.3 as README said and it works!!! . ",
    "hkurokawa": "OK. Thanks.. ",
    "priyankvex": "But I can't swap in the latest RxJava version I guess. Will have to wait for new RxKotlin release. . I had that in mind, but defining RxJava version externally was not in the docs, so was wondering will it cause any side-effects. Sorry. :slightly_smiling_face: . ",
    "Edward608": "It is because your Success class takes the raw Response.data as its member.\nI will make the Success class into a Generic class Success, where T is your data's actual type, this way you can always get the exact type without manual casting.\nA feedback will be nice if it works.. Instead of Success<out T>, try Success<T>?. ",
    "shakil807g": "sealed class State\nobject Loading : State()\ndata class Error(val msg: String): State()\ndata class Success<out T>(val islocal :Boolean = false,val msg: String,val data: T?): State()\ni am using a state sealed class like this i am already using Success with generic data type for data member variable\n. ",
    "OrdonTeam": "Whole sealed class State have to be generic. These extensions also collide in such case:\nval toMaybe1: Maybe<Unit> = Single.just(Unit).toMaybe()\nval toMaybe2: Maybe<Observable<Unit>> = Observable.just(Unit).toMaybe(). One return@flatMap returns Observable<Boolean> second Observable<Exception>.\nBoth of them are Serializable.\nFix: You should use Observable.error<Boolean>.. Hi,\nI found a case where your solution for supporting LambdaConsumerIntrospection is not working.\nUnfortunately I have no idea how to fix that yet.\nHere are failing tests to prove that:\nhttps://github.com/ajalt/RxKotlin/pull/1/commits/9b8c2f77ca2a2197097f449f9cbb8a18ebecade7. subscribeBy with passed onComplete uses incorrect onError handler.. :+1:\nMy solution didn't require inlining. However I felt like it is nice feature to add any way.\nI'm still not convinced about passing default values and then using them just to compare inside if.\nAnyway this solution is sufficient.\n@thomasnield It is done now :). This is an error. You have changed blockingSubscribe with non blocking one.. This is an error. You have changed blockingSubscribe with non blocking one.. Fixed. Fixed. ",
    "chris-hatton": "Thanks for giving it consideration Thomas; I admit I hadn't realised the significance of the Observable<Pair<A,B>> in solving this same problem, until you pointed it out.   With this new information, I would agree my pull-request serves only to duplicate existing functionality and I am happy to withdraw it.. Even though you have used 'Observable.just(...)' to emit a single value, that result is still formally an 'Observable' which has a different API to 'Single'. Do not expect to mix both types interchangeably.\n\u5373\u4f7f\u60a8\u4f7f\u7528'Observable.just\uff08...\uff09'\u6765\u53d1\u51fa\u5355\u4e2a\u503c\uff0c\u8be5\u7ed3\u679c\u4ecd\u7136\u662f\u6b63\u5f0f\u7684'Observable'\uff0c\u5176\u5177\u6709\u4e0e'Single'\u4e0d\u540c\u7684API\u3002 \u4e0d\u8981\u6307\u671b\u4e24\u79cd\u7c7b\u578b\u53ef\u4ee5\u4e92\u6362\u3002. ",
    "bmaslakov": "Done.. Maybe it'd better to rename all .concatWhatever() methods to just .concat()? what do you think?. Great, concatAll() is the best. As far as I can see it is also used in RxJS and RxPHP.\nI've also forgotten about plain old Observable; fixed that.. Yes, you're right. Please reject the PR.. ",
    "onelaview": "It seems these 2 following extensions collide with each other.\nfun <T : Any> T?.toMaybe(): Maybe<T> = Maybe.create { s -> if (this != null) s.onSuccess(this); s.onComplete() }\nfun <T : Any> (() -> T).toMaybe(): Maybe<T> = Maybe.fromCallable(this)\nI'm unable to use the latter to apply .toMaybe() to a lambda so that it is the same as calling Maybe.fromCallable(lambda). Compiler always resolves it to the former extension.\nval myInt: Int? = null\n{ myInt }.toMaybe() // compiler resolves this to use the former extension function\n                    // i.e. it produces Maybe<() -> Int?>. ",
    "alexbirkett": "\ud83d\ude2d I loved .toSingle(). ",
    "ajalt": "You're right that the problem is due to type erasure.\nIf you check the bytecode, you can see that flow.ofType<List<Elem<Int>>> is compiled to float.ofType(List.class), since classes can't contain type parameters. \nThere's no way to do an instance check on the value of generic type parameters are runtime, and unfortunately there's nothing that this library can do to help.. Ok, I updated the PR to address the comments and rebased to fix merge conflicts. \nThis solution is similar to what @OrdonTeam proposed in ajalt/RxKotlin#2, but doesn't change the function signatures and doesn't require them to be inlined. \nThis is probably a little less future-proof than using the subscribe overloads, but we could combine the two approaches if that's a concern.\n. ",
    "KingAndroid": "rabbitMQ.initialize method will return boolean. ",
    "CristianMG": "everything is correct now, ignorance of kotlin thanks. ",
    "japplin": "These 2 lines of changes don't need 6 commits 1 would suffice for just the version update. Also, you probably don't need to touch the README.md file since your book was added in the repo and right now it's just adding a blank line which doesn't follow the style of the rest of the file.. ",
    "j796160836": "I refer these \nhttps://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling\nhttps://github.com/ReactiveX/RxJava/issues/5242\nhttps://github.com/ReactiveX/RxJava/issues/5099\nso I wrote this and get app stable\nRxJavaPlugins.setErrorHandler { e ->\n    when (e) {\n        is UndeliverableException -> {\n            // sallow that\n        }\n        else -> {\n            throw e\n        }\n    }\n}\nAm I doing right?. okay, thanks Taras. I will try to translate to pure Java code and ask again.. ",
    "TarasMazepa": "You should probably update RxJava dependency to the latest version (2.1.9). RxKotlin is only set of handy extension functions over RxJava and RxJava is providing you with actual functionality. Next time you will have any issues it is better to recreate your code with pure java and post ticket to RxJava github page - where more people will see your post and you will get better and quicker support :) . Thanks for doing this. Already forgot that I reported this issue :). ",
    "davidkraus": "Jep, you are right - also works in java. I think i had a litte bit a misconception of what ofType should do. \nBut thanks to Kotlin i can just define a additional function that does the job. Just not sure about the name though, ofSubType, ofTypeStrict, filterByType ...\nThanks for the fast response. ",
    "william198824": "thanks \ud83d\ude0a and how to dispose the 2nd subscription ? . ",
    "imanushin": "@JakeWharton , I found, that nulls are forbidden in the RX Java. Will close issue. ",
    "dmstocking": "Man you guys are fast lol.\n@JakeWharton I will admit it doesn't help when T is widened. My specific use case was using it like this. (I changed the name of some types)\nKotlin\ncombineLatest(viewModelRequests) { requests ->\n    val loading = request.any { it is Request.Loading }\n    val items = request.mapNotNull { it.successDataOrNull() }\n            .flatmap{ it } // the type of \"it\" is List<ListItemViewModel>\n    return@combineLatest ViewModel(loading, items)\n}\nI have an android recycler view that is populated from many sources and I combine them all as a list. It was easier then having the overload that took five observables. I basically had a list that I would unpack for combineLatest then immediately repack it back into a list.\n@akarnokd Kotlin does have the same restrictions for non inline methods. For inline methods, you can make the type reified this is basically like the compiler automatically adding a parameter Class<T> clazz to your method. This let me make the array, new T[], in Kotlin. This is how I sort of cheated around it in Kotlin. I then pass it to Java to do the array copy. I could see that the RxJava project didn't want to add a overload that used Class<T> clazz if it wasn't going to be used very often.. ",
    "BoD": "I'm sorry, I don't understand this sentence \"I think I reversed the order for that reason that passing one nameless parameter attached to the onSuccess().\". You are right, it works indeed, so the last part of what I wrote is incorrect.  I can't figure out right now what I did that made me think the single parameter was onError... Weird!. ",
    "grabstepango": "Don't think there is any problem here. Passing multiple lambdas in one function would any way benefits from named parameters.. ",
    "arekolek": "\nYou are right, it works indeed, so the last part of what I wrote is incorrect. I can't figure out right now what I did that made me think the single parameter was onError... Weird!\n\n@BoD  Because\nmySingle.subscribeBy { result -> println(result) }\n\nis not the same as\nmySingle.subscribeBy({ result -> println(result) })\n\n\nIn Kotlin, there is a convention that if the last parameter of a function accepts a function, a lambda expression that is passed as the corresponding argument can be placed outside the parentheses\n\nI thought the order of arguments of subscribeBy was intentional, because it's convenient to do stuff like:\nmySingle.subscribeBy(Timber::e) { result -> println(result) }.\n",
    "ansman": "The most obvious example that doesn't work is this:\nval maybe: Maybe<*> = Maybe.just(\"foo\")\nval stringMaybe = maybe.ofType<String>()\nYou can only cast Maybe to Maybe<*> if you don't want unchecked warnings so it would make sense to support them.\nAnd besides, it should be implemented like it is for Observable and Flowable which it currently isn't.. I'm sorry but this feels like an extremely bad reason for closing this. This does not add, change or remove functionally but rather fix something that is, in my opinion, broken.\nThe built in cast function works on all types of observables, including Observable<?>. Therefore it stands to reason that these extensions should too.. @thomasnield Thanks, fixed. ",
    "D4Muck": "I mean just a simple Single.just(\"test\").cast<CharSequence>() does not work...\nType mismatch: inferred type is Single<String> but Single<Any> was expected\nSo I would vote for this to get merged. ",
    "godzsa": "Oh I get it. But how do I make this loop forever in a reasonable way? I mean I don't think it is a nice solution to put it in a while(true){} loop, or Thread.sleep(1000000000000), etc.. ",
    "kles4enko": "Just check books author and person name who added these lines to the README...  Fun (not).\n. ",
    "DrewCarlson": "@kles4enko I really was not expecting that..\nFor reference, this is the pull request for it: https://github.com/ReactiveX/RxKotlin/pull/154\nMerged the same day with no conversation at all.  Seems odd to me that it was even considered.  People will take that section as a formal recommendation for those books which is an obvious problem for so many reasons.\nAt the very least turning it into a footnote with a disclaimer about not being officially supported or vetted would be the right thing to do.. ",
    "joshfriend": "I also added annotations to the extensions added in #185 that were missing them.. @stepango I think you can close this now that the PR is merged. ",
    "rynkowsg": "Cheers @JakeWharton . ",
    "aballano": "I'm closing this then, thanks for the feedback!\nFYI I included them into our project but renamed so they're more explicit\n```\ninfix fun  ObservableSource.concat(other: ObservableSource): Observable =\n      Observable.concat(this, other)\ninfix fun  ObservableSource.merge(other: ObservableSource): Observable =\n      Observable.merge(this, other)\n```\nAnd for the shake of context, my usecase: \npresenter.observeViewEvents(\n    initEvent.toObservable() merge cardClicked()\n).subscribeBy(...). ",
    "ashishkrishnan": "Does makes sense. @JakeWharton Anyways, major upgrades to the dependencies should be pulled in to get all the upstream bugfixes. Also, agreed with you on infeasibility of the maintainers to upgrade every single update. \n. So, using the latest version of a dependency should override the version specified in this project. Right?. ",
    "AdamSHurwitz": "I see the answer is yes. https://stackoverflow.com/questions/50937317/is-there-a-limit-to-the-number-of-observables-in-zip-method/50937413#50937392. ",
    "gildor": "\nThis can save a number of classes and methods in an Android application.\n\nI agree with this proposal. but not sure that it can help to save classes/methods, actually methods count will be increased (+2 methods). ",
    "bemusementpark": "Right. I figure those will be proguarded out if unused and if one of these are used more than once in a project, then we will be saving lambdas. The simplicity is more important.. 2.2.0 is out now!\nhttps://github.com/ReactiveX/RxJava/releases/tag/v2.2.0. ",
    "TWiStErRob": "Additionally these may be helpful:\nkotlin\ninline fun (() -> Unit).toAction() = Action0 { this() }\ninline fun <T> ((T) -> Unit).toAction() = Action1<T> { this(it) }\ninline fun <T, R> ((T) -> R).toFunc() = Func1<T, R> { this(it) }. Not in all cases, I'll show you examples when I get the chance. These all came from a need I had. We'll see if it makes sense.. ",
    "QiuChenly": "\u6709\u4e36\u4e1c\u897f\n\u8fd9\u4e0d\u662fSingle\u5417  Observable\u662f\u4ec0\u4e48\u9b3c. ",
    "Jacks0N23": "maybe update rxjava too?. ",
    "nbransby": "Ok was due to me not importing the extension - a little gotca..\nimport io.reactivex.rxkotlin.Observables.combineLatest\n. ",
    "krossovochkin": "Hi @thomasnield, I got your point, but have small question.\nIt is clear that this repo is mostly kotlin-wrapper around rxjava2.\nThough in the future I hope it will take some advantage of kotlin native to have pure-kotlin implementation.\nIn this case imho I think having more stable kotlin-public-API should be more important than relying on kotlin-java SAM interface.\nI know that all observable.kt, maybe.kt etc. are not really kotlin-specific, but why we can't define these extension files (observables.kt, et.c) as public API?.\nAnd if we remove these extension files later on (using kotlin 1.3) it sounds like we'll move closer to JVM instead of kotlin stuff.\nJust my humble opinion. Feel free to decide when/whether to merge it or not.\nThanks!. ",
    "joshuadeguzman": "Closing this PR. Found out that gradle-rxjava-project-plugin continuously causes the failure for not supporting Gradle 4.0+.. ",
    "worldsnas": "sorry for the mistake. reverted back the formatting. please let me know if anything else has problems. ",
    "Guang1234567": "@JakeWharton \nYou are right!  It is belong to kotlinx-coroutines-rx2.\nso close this issue.. ",
    "pakoito": "It's just a general idea. It could be polished to avoid gotchas such as awaitTerminalEvent() never returning.. ",
    "RivuChk": "Unintended commit? I prefer the previous formatting otherwise.. Unintended commit? I prefer the previous formatting otherwise.. Unintended commit? I prefer the previous formatting otherwise.. "
}