{
    "mdiep": "Thanks! \u2728 \n. I dig it. \ud83d\udc4d\ud83c\udffb\n. ReactiveSwift 1.0.0-alpha.1 has this fix.\n. There's no plan to back port this to RAC 4.x. It will be included with RAC 5.x since that depends on ReactiveSwift.\n. Yeah, the API renaming makes the transition pretty easy IMO.\n. Seems like people are mostly on board with making all the breaking changes now.\nIs everyone \ud83d\udc4d\ud83c\udffb on the change itself?\n. \ud83c\udf89 \n. Thanks!\n. Does Swift have a way to make the deprecations warnings instead of errors?\nAlso, FWIW, there's probably more churn to come. You're welcome to use the Swift 3 version now, but there will likely be more breaking changes.\n. If we do that, then we need to keep those around until 6.0. (Removing the deprecations or making them unavailable would be a breaking change.)\nThat's my only hesitation.\n. > I'd be happy if they went back to being errors on version 5.1\nUnfortunately, that breaks semantic versioning. If another project says it's compatible with 5.0, it could still use those operators, even though they create warnings. That project would then break if we moved them to errors in 5.1.\n. Can you add some documentation about how and when to update this and push it?\n. In the podspec is fine for now! We can rearrange at some point if we want to add more thorough release documentation. Thanks!\n. > I'm also happy to help with ongoing maintenance of the podspec.\nAwesome! Thanks. \ud83d\udc96\nIs there a way to verify the podspec as part of CI? At a minimum, verifying that it builds, but ideally would also run the tests.\n. Thanks @ashfurrow! Really appreciate your help on this!\n. Good catch! Thanks!\n. \u2728 \n. A podspec has already been added to the repo. https://github.com/ReactiveCocoa/ReactiveSwift/pull/14\n. I thought I'd release a 3.0.0-alpha.1 version sometime this week. Letting the dust settle and trying to review some other PRs before swinging back around.\n. I thought 3.0 would be nice since (a) it's the 3rd major API release of this code and (b) it nicely mirrors Swift 3.0.\n. > I'll also add that we may not always track Swift versions w/ this lib.\nTotally.\nI'm open to releasing as 1.0 if that's what people think is best.\n. I should be able to release an alpha version this weekend.\n. https://github.com/ReactiveCocoa/ReactiveSwift/releases/tag/1.0.0-alpha.1 \ud83c\udf89 \nIf you find something that should be covered in the release notes or migration guide, please open PR or leave a note here!\n. unsafeCocoaAction remains part of https://github.com/ReactiveCocoa/ReactiveCocoa since it's Cocoa specific.\n. ReactiveCocoa is now built on top of ReactiveSwift. All the cross-platform bits are in ReactiveSwift; all the Cocoa-specific bits are in ReactiveCocoa. So Action is in ReactiveSwift, but CocoaAction is in ReactiveCocoa.\n. > Ideally this could just be a convenience initialiser on Action\nDid you try defining it in an extension on ActionProtocol?\n. Yeah, I think adding an initializer to ActionProtocol would be fine. The point of the protocol is to make constrained extensions possible. I think that's preferable to adding another type.\n. I'd like to play around with it to understand it better and see if I can find a way to make it work in an extension. But that may mean it takes me a little longer to get to this PR.\n. This is still on my list!\nSorry for the delay. I'll try to get to it this week.\n. This looks great. Thanks for all the hard work on this, @sharplet!. I don't think that was intentional.. \ud83d\udc4d\ud83c\udffb\n. CocoaAction is a part of ReactiveCocoa, since it's Cocoa-specific.\nYou should include ReactiveCocoa as a dependency. \u263a\ufe0f \n. I think the confusion is that Rex is meant to go into ReactiveCocoa, not ReactiveSwift.\n. Thanks! These were really easy to miss in the Swift 3 conversion.\n. TBH, I'm not sure if there's a reason that one comes before the other. \ud83e\udd14\nI suspect that you'll sometimes want one order and sometimes want the other. So changing this would likely inflict pain on some users.\nIn this case, your isRegistered property does seem a little weird. Just looking at the events feels funny: it doesn't seem like that should be the source of truth. Presumably registering does something; it seems like the property should based on whatever that thing is.\n. What's the problem this is solving?\nI see you mentioned this from https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3210, but I don't see BindingTarget referenced anywhere in that PR.\n. It seems like cases like UIViewController.dismissAnimated would be better served by an Action\u2014since that already abstracts the idea of something that can be called to perform some task. If Action were made to conform to BindingTarget, that seems like it'd be a pretty natural extension of what we already have.\n. > We also have no conditional conformances which allows only Action where Error == NoError to be a binding target.\nI think we'd only need to verify that the input signal/producer/property has NoError\u2014it doesn't matter if the Action can error. I'm also not convinced that it matters that inputs would be ignored while the action is disabled.\nThis is perhaps most true, from RAC's perspective, if you could configure an Action to execute on the main queue.\nIt may not work out, but it seems like this approach is worth exploring? Perhaps in a separate PR?\n. > My only concern with this is that it makes Action.errors harder to use in the usual case in order to make this new case possible.\nI agree. I think we should expose this somehow, but I don't think we should make the ordinary case harder.\n. I just added #88 to the 1.0 milestone because #22 was in there. I think those are the last things that we need to resolve.\n. Sorry I forgot to do this last night. \ud83d\ude48\n. That makes sense. \ud83d\udc4d\ud83c\udffb\n. This seems pretty interesting to me.\nAre you still planning to work on tests for this?\n. I think we should stick with the view that Actions must be explicitly retained. I don't think they really make sense otherwise.\nIf you have an Action property on an object, you'll always want to return the same object so that it serializes correctly.\n. I just don't see standalone Actions being useful.\nYes, it protects against user error. But I don't think that's worth the added complexity. In the magnitude * reach test, I think it scores low areas. It's unlikely to have a large effect and unlikely to affect many people.\nAt the very least, I think we should leave things as they are now. We can reconsider for ReactiveSwift 2. But I'd like to focus for now on shipping the 1.0 release.\n. I think we could still make Action conform to BindingTargetProtocol and use it in RAC for dismissAnimated.\n. Awesome. Thanks!\n. I don't understand the issue is here. \ud83d\ude15 \nCan you try to explain again why consume is useless? It seems useful in #38.\n\nLet's say in ReactiveCocoa/ReactiveCocoa#3162: DynamicProperty passes through its underlying object's rac_lifetime instead of having its own. Moreover, it also overrides the <~ operator so that bindings act directly on the NSObject via KVC. This renders BindingTarget.consume useless, and in fact for any conforming types that overrides <~ it is useless.\n\nlifetime is part of BindingTargetProtocol. Why isn't that enough to do this?\n. That description helped a lot. Thank you! Now I understand what you're trying to do with the lifetimes of the various objects.\nI'll try to find some time this weekend to think about what the semantics should be so we can move forward.\n. I've commented in https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3162 and #38, but I don't think the throw-away proxy semantics are something we should adopt\u2014at least now for ReactiveSwift 1.0. So I think it makes sense to keep BindingTarget.consume.\n. I think those semantics are fine for BindingTarget since it was created specifically for those purpose. But I don't think they're the right semantics for the protocol.\n. We don't have a plan to support defer, but I'm definitely interested in providing some back pressure mechanisms. Would you be interested in putting together a proposal or PR? That'd be the best way to move something like this forward. Or even just putting together a survey of different back pressure mechanisms used across different reactive platforms.\n. Thanks! Missed these in the conversion.\n. I'll try to take a look in the next few days unless someone beats me to it.\nI did put #22 in the 1.0 milestone just now because I think that needs to be addressed.\n. Brilliant. Thanks @liscio!\n. @NachoSoto Did you want to take another look at this before we merge?\n. \ud83c\udf89 \n. I don't fully understand this part of the code yet, but .interrupted can propagate up the signal chain when something is disposed or interrupted.\n. > So, I say we either pull it, or come with some compelling real-world cases outside of UI code where this holds value.\nTBH, I'm not sure how much value Action itself has outside of UI code. It's primary benefits, like serialization, are mostly important in a long-lived process.\nBut I'll try to think of an example where it'd be useful.\n. > Do you think it's worth adding the Signal and SignalProducer overloads like I mentioned in #58\nI think we can go without them for now.\nMind merging master in? That should fix up the SwiftPM tests.\n. I think it makes sense as-is. failed is the event; error is the instance that initiates/describes it. An error causes the stream to fail.\n. I don't find .skip { \u2026 } to be worrisome. But we have left some of the startX methods with the old-style names for this reason.\nI'd rather us stick with the language conventions by default. If it proves to be a problem, we can consider changing it for RAC 6.\n. I'm going to close this, since there's no action to be taken. Feel free to open a new issue if you run into a case that seems confusing!\n. Thanks!\n. \ud83d\udc4e on this since it only works on Apple platforms.\nI don't want to make it easy for downstream libraries to accidentally break support for other platforms. This seems like it might be good for RAC though\u2014it could export ReactiveSwift and Result this way.\n. I think that organization should be discouraged. FRP is all about unidirectional data flow, so I don't think it makes sense to support cycles.. Do you think this is better than instructing people to run carthage bootstrap? If so, why?\n(Looking to educate myself, not arguing either way)\n. > Perhaps it would make more sense to update the instructions to recommend that.\nLet's go that route. \ud83d\udc4d As a user, I generally prefer that to running an opaque script.\n. This seems like a bug to me. \ud83d\ude10 \n. I'm not sure why this wasn't included in the Swift APIs.\nWhere are you using it in your project?\n. > The main reason being that IMO the same type shouldn't be used to represent both ends of the pipe, as it encourages users to expose too wide of a surface instead of only the \"read only view\".\nI definitely agree with this.\nBut that wouldn't preclude us from having a Pipe that conformed to ObserverProtocol and exposed a Signal (but didn't conform to SignalProtocol itself).\n. I think we also need to start limiting changes for ReactiveSwift 1.0.\n. I'm \ud83d\udc4e on doing this for 1.0\nI don't think it's an obvious improvement over what we have, and I'd like to focus on getting the release out the door.\n. This definitely limits the applicablility of Action. The question is whether the eliminated applications are useful and good, or whether this clarifies the role of actions.\n. > Unfortunately, personally speaking about my use of actions, I have a few cases where the input is dynamic, e.g. according to the value of a UISwitch\nYou could still achieve that.\nswift\nlet switch = UISwitch()\nlet property = Property<Bool>(value: false, then: switch.reactive.isOnValues)\nlet action = Action(input) { ... }\n. > Where the input Bool value is whether or not the presentation is animated\nCould you share a bit more about where the Bool value comes from?\n. That approach looks fine to me!\n. Do you have a particular use case in mind?\n. Does delay not do what you want?\n\nWhat is your main concern about adding such a method?\n\nWe'd like to not add operators without compelling use cases. Otherwise the framework gets rather large and it can become very hard to find the right operator.\n. Definitely late, but defer makes sense to me.. I don't think this makes a lot of sense to include. But TBH I always had mixed feelings about the Objective-C version.\n. Good catch!\n. Can you give a little more detail about what you're trying to do?\n. It seems like you should move the retries into the steps.\n``` swift\nlet step1: SignalProducer\nlet step2: (A) -> SignalProducer\nlet step3: (B) -> SignalProducer\nlet task = step1\n  .retry(upTo: 3)\n  .flatMap(.concat) { step2($0).retry(upTo: 3) }\n  .flatMap(.concat) { step3($0).retry(upTo: 3) }\nlet action = Action { _ in task }\n```\nWould that work?\n. In my snippet above, step3 will be retried automatically\u2014without restarting steps 1 or 2\u2014if it fails, reusing the value from step 2. It sounded like that was what you wanted.\nBut if you really want to replay all values, then you'd need a custom operator like that. I can't think of a better name for it, so I'd probably add it like that to your project until/unless a it solidifies into something more clear.. > I've been doing some thinking about introducing the notion of a caching policy, and I'd like to spitball a possible approach here. I think it would be possible to extend replayLazily to take an optional parameter policy:\nThat seems sensible to me. \ud83d\udc4d . Thanks for the PR!\nI think we can focus on ReactiveSwift here, without mentions of ReactiveCocoa. ReactiveCocoa doesn't need to duplicate the information here, but could link to it. Adding a page to RAC that explains DynamicProperty would probably be a good idea.. Thanks @iv-mexx! This is great. \u2728 . There isn't really anything to be done. It takes the time it takes. This larger does have a larger than average history, which might account for a slow initial clone.. You're welcome to investigate! If there's something that can be done, I'd definitely be in favor of doing it.. This is great stuff. Thank you for these documentation fixes!. This is because of how SignalProducer.init(value:) works. It sends the value immediately.\nIt goes something like this.\n\nCall starting\nCall SignalProducer to start\ninit(value:) sends a value (value) and then completes (completed)\n\n\nCall started. I think it'd be more surprising for started to not always fire.. Maybe this will help you make sense of it: the signal completed before it finished starting. . I'm pretty ambivalent about this. It's nice on the one hand\u2014I always prefer unnamed arguments when they're unambiguous\u2014but this initializer doesn't seem widely used, so it might be a little confusing.. I wish we could have unanimity here, but we do have consensus and\u2014more importantly\u2014the Swift API guidelines seem pretty clear on this point. So I'm going to go ahead and merge.. That example seems like it'd be better with sample(on:).\n\n```swift\nlet enabled1 = MutableProperty(true) \nlet enabled2 = MutableProperty(true) \nlet buttonTap: Signal<(), NoError> = ...\nSignalProducer\n    .combineLatest(enabled1.producer, enabled2.producer)\n    .sample(on: buttonTap)\n    .filter { $0 && $1 }\n    .observe { _ in print(\"hello\") }  // prints only when both enabled1 & enabled2 are true\n``. I definitely think thesample(from:)name is wrong. Similarities exist with thesample(on:)andsample(with:), but I think the defining characteristic ofsampleis that it'ssource.sample(_: trigger)`. The name totally trips me up.\nwithLatest seems like a much clearer name.\nBut your example still doesn't seem ideal. In particular, I wouldn't use items in its own definition.\n```\n/// Stores API response items.\nlet items = MutableProperty<[Item]>([])\nitems <~ urlTextField.reactive.text\n    .sample(on: buttonTap)\n    .map { APIRequest($1) }\n    .flatMap(.merge) { sendRequest($0) }\n    .reduce([]) { $1 + $0 }\nitems.signal\n    .observeValues { print(\"items updated: ($0)\") }\n``. I'm \ud83d\udc4d withwithLatest(from:).. Why isn'tNSErrorcorrect here? Isn't that what the Foundation API will have returned?. Yeah, but I'd probably frame it as[operator]Strategy`.. This looks fine to me, but I'd like to get some more eyes on it. @sharplet @NachoSoto . It looks like this comment was missed. Can you take a look at that?\nI'm starting to like the way this looks. \u2728 . This looks good to me. But since it's a very critical section of code, I'd like to get another set of eyes on it.. Doesn't look like we'll get another review, so let's \ud83d\udea2.. No, I think it's the first flattened signal to send an event.\n```swift\nlet (s1, o1) = Signal.pipe()\nlet (s2 o2) = Signal.pipe()\nlet (s3, o3) = Signal.pipe()\nSignal(values: s1, s2, s3)\n    .flatten(.first)\n   .observeValues { print($0) }\no3.send(value: 7) // s3 becomes the chosen signal and its values are used\n```\nIt makes sense to me as a possible strategy, but I'm not sure what you'd use it for.. The idea here makes sense: why create more signals than are needed? But I find the implementation here to be difficult to follow. I think we need to try to clarify/simplify the code before merging. I'll swing back around to this after we get 1.0 out (or at least until we get 1.0 PRs merged).. Trying to get to this. It's on my list \ud83d\ude05 . Sorry this one took so long! \ud83d\ude05 . I don't love this, but I think that's just because I don't love Swift's untyped error handling. \ud83d\ude43 . I'd still love to see an update to this.. I don't think it makes sense to add resource collection to Lifetime.\nWe have 3 jobs:\n\nCancellation\nCleanup\nLifetime\n\nI think cleanup is more closely related to cancellation than lifetime.. If you cancel a SignalProducer by disposing it's Disposable, what event is sent to its observers?\nInterrupted seems useful as a way to communicate intent.. That doesn't seem very user friendly to me. The current API seems much better\u2014at least for our users.. The tests need to be updated. Which is surprising to me because I thought these names were no longer part of the type. \ud83d\ude15 \nThis makes sense to me. \ud83d\udc4d But I'd like to see it with passing tests to verify that my assumptions about how it works are correct.. I'm okay with merging this as a last-minute fix for 1.0. Thoughts?. It seems to me that the issue here is that unsafeProducer isn't a sufficient model in the face of observe(on:). To rectify that, I think we need to come up with a better model for asking for the current value and observing future changes atomically (akin to MutableProperty.producer).\nI don't think this model is the one we're looking for. We should be looking for something that simplifies and removes the need for unsafeProducer. (Which sounds like a 2.0 task.)\nIt seems like that might require access to the Atomic. But I think it'd be good to take a step back, forget about observe(on:) for a moment, and find a way to rework Propertys to not require synchronous values from producer.. The idea definitely makes sense. It's reminiscent of #140. But it's hard to know for sure what this will look like.. I kinda like these both using the same name. They're really the same thing; it's just that one is mutable and the other immutable.\nPersonally, I think inner or disposable makes the most sense. Wrapped makes more sense to me as a generic type than wrapped does as an accessor.. Thanks!. Thanks! Documentation fixes like these are really great. \u2728 . Thanks!. Can we add a test for this?. I actually like the name as-is. The reality is that a Property or SignalProducer can be observed.. > SignalProducer cannot be observed. It produces a Signal that can be observed, aka start.\nEven if it can't be observed directly, it can be observed. At any rate, this method is clearly side-effecting, so it deserves a direct verb name. Something like add won't do it justice.\n\n\nCan we add a test for this?\n\nProbably not. There is no public or internal API to catch the number of observers.\n\nIf it's disposable that's getting leaked, we should be able to do a standard weak test where we verify that it gets cleared at the appropriate time?. Personally, I think observe is the better name. I think it's a very accurate description of the behavior. It's fundamentally the same thing as Signal's observe.\nIf we're concerned about people being confused by autocomplete, then I think we should add some documentation that will show up in the autocomplete.. Maybe?\nWhen considered as separate types, start* makes total sense for SignalProducer because it reinforces that it's starting it\u2014that you're not observing something already in progress.\nBut when creating something that bridges both hot and cold observables, we'll need to choose something that's not ideal for cold, not ideal for hot, or not ideal for either. I think it makes sense to stick with the hot terminology because it's the most natural and because it's weirder to use cold terminology with a hot observable..  \n\nMy original distaste for observe is based on passed an Observer instance without acknowledging the Observer itself.\n\nThat was based on the existing Signal method:\nswift\n    public func observe(_ observer: Observer) -> Disposable? {\nI can totally see where naming that parameter might be preferable. But I was just aiming for consistency with existing methods.. This should wait until we're actually ready to tag 1.0. Maybe I should be a part of that PR so we can also update the podspec?. I played around with this idea when I added BindingSourceProtocol, but it felt a little weird to me. \ud83d\ude15 Making consume a property didn't feel right.\nI'd be curious to hear what others think.. But why make it mutable? Why not make this a readonly, validated view of the property?. Thanks for all your work on this! Sorry I was so slow with reviews. \ud83d\ude48 . 1. Do we need to keep the blue logos around?\n\nThe Documentation and Join us on Slack ones seem like they should be darker or less pastel\u2014more like the Swift orange. (With white text if necessary.). The Observer isn't sending the events; you're sending the events to the Observer.\n\nAny API that uses a Signal but doesn't add an Observer implicitly adds an Observer.. I don't think anything needs to be done. I don't personally find this confusing.. Thanks!. > If that's the case, maybe we can remove the strategy from flatten when the value is a Sequence?\nYup, that makes sense to me. \ud83d\udc4d But it's too late to do it for 1.0. #198\n\nHowever, there's a constraint about the error type, Error == NoError, which is not defined on uncollect and removing it leads to an Ambiguous use of 'flatMap(:transform:)' which kind of makes sense since there are two versions of flatMap to accommodate both Error and NoError. I don't know if this was the reason behind this constraint but I don't see a reason to restrict this operator only for signals without errors.\n\nI agree. The ambiguous use error can be worked around by annotating the types inside the operator.\nswift\nextension SignalProtocol where Value: Sequence {\n    /// Flattens the `sequence` value sent by `signal` according to\n    /// the semantics of the given strategy.\n    public func flatten(_ strategy: FlattenStrategy) -> Signal<Value.Iterator.Element, Error> {\n        return self.flatMap(strategy) { SignalProducer<Value.Iterator.Element, Error>.init(values: $0) }\n    }\n}\nLet's do this in #198 as well.\nI'm not opposed to adding this functionality in 1.1 with the proviso that it would be removed in 2.0 in favor of flatten. (Since adding the operator can be done in a .x release as an additive change.). I'd definitely like to hear a concrete use case for groupBy. I know I've used something similar to that in the past, but I can't remember what for.. I think groupBy makes sense. It's a standard Rx operator, and it's not easy to build it yourself. \ud83d\udc4d. swift\nextension SignalProtocol where Value: Sequence {\n    /// Flattens the `sequence` value sent by `signal`.\n    public func flatten() -> Signal<Value.Iterator.Element, Error> {\n        return self.flatMap(.merge) {\n            return SignalProducer<Value.Iterator.Element, Error>.init(values: $0)\n        }\n    }\n}. Oops! Sorry @iv-mexx. I put this back on my todo list and will get to it this week.. I've been thinking about this quite a bit. The replaying of values makes me pretty uncomfortable, so I've felt a bit stuck and unsure how to resolve this.\nBut after thinking about it, I no longer think that groupBy makes sense as a built-in operator. \ud83d\ude1e It requires semantics that we've said we'd like to discourage (for good reason, I think). And the example can be resolved by introducing a class, which implies the correct semantics.\n```swift\nclass BluetoothManager {\n  private let allBeaconsSignal: Signal\nprivate var beacons: [(Int, Int): (Signal<, >, Signal<, >.Observer)]\n  public let beacons: Signal<(CLBeacon, Signal<, >), NoError>\n  private let observer: Signal<(CLBeacon, Signal<, _>), NoError>.Observer\ninit() {\n     // I'm not exactly sure how this should all work. I was working off the given example code,\n     // which is tightly focused on the groupBy. But this will hopefully communicate the idea,\n     // which is that the class is responsible for grouping values, notifying interested parties\n     // that new values have come in and giving them an opportunity to subscribe to events.\n     let (beacons, observer) = Signal<(CLBeacon, Signal), NoError>.pipe()\n     allBeaconsSignal.observeValues { beacon in\n       let identifier = (beacon.major, beacon.minor)\n       if beacons[identifier] == nil {\n         let (signal, observer) = Signal<, _>.pipe()\n         self.observer.send(value: (beacon, signal))\n       }\n     }\n  }\n}\n```\nBut if the rest of the core team feels that this does make sense to add, they can definitely override me. \ud83d\ude04 . I'd love to hear your thoughts @NachoSoto. I think the key point is that you observe a signal. So observe makes sense as the method name. That's clearest and it's a term of art.\nI don't think a named parameter is necessary either. If we did add a label, with or using seems most correct. But I think that draws attention away from the observe part of the name.. People seem pretty universally in favor of naming the parameter.\nLooking at the Swift stdlib, with seems like a better fit. (using is only used with encoding.)\nDoes anyone think we shouldn't name the parameter? Does anyone think it should be something other than with?. I'm curious: is there a reason that you are looking to do this? Do you have a case where you need a recursive lock?. Great catch! Would you be interested in opening a pull request to fix it?. Thanks for the PR!. Your signal producer is never completing, from the looks of it. You probably need to use take(during:) or dispose of disposable.. Oh, I'm sorry. Now I understand what you're describing.\nAIUI, Xcode's memory debugger reports false positives. That's what's happening here. It sees the intentional retain cycle and reports it as leaked memory. It doesn't know that the retain cycle is cleaned up later. I believe Instruments will yield different results.. \ud83e\udd18 . > While it is possible to perform the writeback asynchronously, it could result in windows of visible conflicting values that is hard to workaround.\nI believe that's still possible. Since you don't know what order the observers will be notified, an observer could be notified before one that overwrites it. It seems like we might need a different solution for this sort of thing.. Thanks for fixing this!. Thanks. \u2728 . It's really hard to evaluate this without any code that actually makes use of it. Is it used in one of the related PRs? If so, which should I look at?. Oof. That's tricky. I'm not sure which is right. But it seems like a 2.0 change if we make it.. Per #424, this has been resolved.. I really like the simplicity of exposing ended: Signal<(), NoError>. Clear, unambiguous, and does very little to expand the API. I also think we should prefer Signals to Disposables.\nIf we're concerned about the safety issue you mentioned, adding the terminated events to Observer seems like a fine approach.. I still prefer ended: Signal<(), NoError>.\nI can be \ud83d\udc4d to observeEnded if people find ended confusing.\nBut I'd prefer not to add attach or +=. I think that muddles the job of Lifetime\u2014which should be just to notify observers when the lifetime has ended. I don't think we should give Lifetime any knowledge of Disposable.. Yeah, so I think writing lifetime.observeEnded(disposable.dispose) is fine. I don't think it requires extra sugar that couples the two concepts.. I was hoping this would generate a little more discussion on the name.\nThis came from Rex, but I'm not sure the origins of the name and I'd like to get that right. Is there prior art for filterMap or for compactMap (which was mentioned above)?. * Swift stdlib has flatMap (it also has flatten :: [A?] -> [A])\n Rust has filter_map\n Ruby has compactMap (it also has compact :: [A?] -> [A])\n Haskell has mapMaybe\n Elm has List.filterMap\nI guess filterMap is the winner. Awesome! Sorry for the delay on this one.. I'm guessing amb is short for ambivalent?\nEdit: Nope, it's should for ambiguous. https://msdn.microsoft.com/en-us/library/hh211783(v=vs.103).aspx#Anchor_1. I think I like race.\nfirst conflicts with the instance method, but it's also a little ambiguous about whether it's the first signal to be sent or the first signal to send an event. I suppose you could also get confused with race like that\u2014but it seems a little more likely to direct you to the documentation.. # This is a breaking change because it adds a case to an existing enum.\nThis either needs to wait until we're ready for 2.0 on master or it needs to target a 2.0 branch.. @inamiy Would you mind resolving the conflicts here? I think this is ready to be merged to master for a 2.0 release.. > Sorry if I'm late commenting on this, but does this really add value? Isn't this equivalent to:\nDiscussion here last time you asked this. \ud83d\ude09 . Can you share the code that you're using for this?. I think the need here is a valid one. I think we should make it easy to turn non-reactive, synchronous code into reactive, asynchronous code.\nBut I'm not sold on the specifics of the API. It seems like the mechanism  for this should be exposed as an operator on Signal and SignalProducer. Then we can also add an operator to Property.\nI'm curious what you think of that and how you'd update the proposal to reflect that. I have another thought, but I want to see what you'd do there without the influence of it. \ud83d\ude04 . > Also, what are your thoughts on using just the name lens, as I implemented it in the PR? The lazy aspect is irrelevant outside of the implementation, and I think that it differs from a straight-up map operation because this is not really a transformation \"in spirit.\"\nI think the name lens will be confusing for people. It adds another concept\u2014and one that is increasingly heard of, but not necessarily understood. And I'm not sure it's a truly valid use without a setter.\nWhile this is different than map, it's not necessarily that different from filterMap (#232). So I'm wondering if it'd make sense to add this as something like lazyMap.. Waiting on @liscio's attempt at lazy or lazyMap as discussed in #239.. No worries! I just wanted to leave a note (1) so that I remembered the status of this PR and (2) to make sure we were one the same page. \u263a\ufe0f . I like this direction a lot. \u2728 \nAre you happy with it @liscio?. The tests don't compile on Linux. So this will need a little love.. I kinda wonder if this could be a map method on BindingTargetProtocol. \ud83e\udd14 . Want to give this a try as map? The test suite (and your code) should provide a decent test of whether it's a problem inference-wise.. In the code you posted above, you're blowing the stack.\nI'm not sure if that's the case in the other stack trace you posted.. 1.x should be Swift 3.0 and Swift 3.1 compliant. So it seems like we should be able to deprecate these things in a 1.x release.. Not sure what to do about the podspec error. I guess we should --allow-warnings?. I don't mind internal deprecation warnings\u2014so long as the next major release isn't far off.\nIf we really feel this is a pain, we could do it right before the last 1.x release.. Yeah, you'd need to skipRepeats on the Property.\n```swift\nlet (signal, observer) = Signal.pipe\nlet a: Foo // where Foo is Equatable and a value type\nlet property = Property(initial: a, then: signal).skipRepeats()\nproperty.signal.observe { foo in \n   print(foo)\n}\nobserver.send(value: a)\n``. Thanks! Really appreciate these sorts of PRs.. I _think_ the primary driver is thatNSError` isn't available on all platforms.. Good idea. \ud83d\udc4d \nLove that we can do this and maintain source compatibility.. What version are you using? The documentation should refer to git commands now. (And I don't see any remaining references to script/bootstrap locally.). I don't love either option, but this seems like an improvement. \ud83d\udc4d \nThis will need to deprecate the old version before it can be merged.. Can we add a test for this?. Thanks!. shakes fist L-valueeees!. In what scenarios does this arise?\nIf your producer never completes, then Action is going to be of limited use anyway. \ud83d\ude15 . I'm not sure that this is necessary.\nAs of Carthage 0.19, warnings are no longer passed through, so this should be a lot less necessary.\nBut I suppose this is probably okay for CocoaPods?. How did this not get merged earlier?! Sorry @eimantas!. Thank you for raising this and opening a PR! Removing these does seem like the correct thing to do IMO.. UIScheduler isn't quite a main queue scheduler. As @ikesyo pointed out, that exists as QueueScheduler.main. UIScheduler really is UI-specific\u2014that's the reason for its \"as soon as possible\" policy.\nI think the two options are to either leave it untouched or to move it into ReactiveCocoa. Truthfully, I don't know enough about Linux UI development to know whether it'd be useful. (Although I assume it'd be tied to a specific thread as well.). > I'd argue that the current UIScheduler is essentially QueueScheduler.main with a specific order-preserving optimization, which can be extended to QueueScheduler.\n\nSo perhaps we fold UIScheduler into QueueScheduler, heh?\n\nNo, I think that optimization changes the semantics, requiring it to be a separate scheduler.. I don't think ReactiveSwift needs to exclude anything UI-related. Bindings, e.g., are basically a UI feature.\nReactiveSwift shouldn't have anything that's platform-specific. That's where I think the line is.. This might be a good candidate for https://github.com/RACCommunity.. Do you anticipate adding more targets?. > I'm opening this issue for people who know better than I do to weigh in.\nWho's that? \ud83e\udd14 . Could this help with the ReactiveCocoa MapKit tests that occasionally leak/fail?. Exposing it sounds like a good first step. Then a few brave souls can try it out and report back before we make the switch. \ud83d\ude09 . Another possible implementation would be to add a configuration type.\nextension Action {\n  // These names are all terrible\n  enum SomeName {\n    case disabled // send disabled if already executing\n    case joined // send completed when the current execution ends\n    case buffered // execute after the current execution ends\n  }\n}\nBut I'm not sure we need this. Without strong demand for such behavior, I'd be very hesitant to add it.. I guess either way is fine with me. \ud83e\udd37\ud83c\udffc\u200d\u2642\ufe0f. I just rebuilt 1.1.0 and attached a binary release.\nAre you sure that it was 1.0? The version in Info.plist wasn't updated, so it still says 1.0. And the new 1.1 binary is the same size as the previous 1.1 binary, which is different than the size of the 1.0 binary. \ud83d\ude15 . I think this is just a relic of the past.\nThanks for the PR!. And static let concat = .merge(1)?. > Test cases for concurrent(limit: 0), which would queue all inner producers indefinitely until the outer producer terminates.\nI'm not sure that makes sense. Maybe we just add a precondition that count must be >0?. Looking at it, I'm not sure why this would cause any performance issues. The code is basically the same.\nBut I'm sure @andersio could run some benchmarks.. It looks like those tests don't compile on Linux.. I think it makes more sense to create a custom strategy type for Action that encompasses the use of both strategy and disablesWhenExecuting here. That seems like it'd be the easiest to understand\u2014I don't think all FlattenStrategys will make sense here (what would .race do?).. Yeah, I don't think we want this. I think it's best to minimize the exposure of replaying/buffering methods. Unless someone is asking for behavior like this with a really compelling use case, I'm \ud83d\udc4e to adding it.. It also erases the distinction between hot (Signals) and cold (SignalProducers) observables. These types of observables are often called warm. They make it difficult to reason about what will cause work to be performed. Experience has shown that it's usually best to model buffering explicitly in some form.\nThere's a lot of background in https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2639.. I don't really follow. I'd need to see more. \ud83d\ude15 . I'm open to the idea of it. But it depends on what the specifics look like. \u263a\ufe0f . A few notes:\n\n\nAs an additive API, this doesn't need to hold up a 2.0 release.\n\n\nI think the simpler (Error) -> SignalProducer<(), Error> variant is preferable.\n\n\nI don't think this needs to take a flatten strategy. It seems like the returned signal should have a take(first: 1) that prevents multiple retries from the same error.\n\n\nI don't think a recursive lock is going to be acceptable.\n\n\nDo you have a particular use case in mind for this? Or are you suggesting it because you find it interesting?. I wonder if we'd be better adding variants that cover those two cases. Those seem like the most common uses.\nThe first case would actually be really well suited to have some sort of timing function\u2014an enum that covered both a constant time and an exponential backoff with some sort of upper limit.. Thanks! \ud83d\ude05 . I'm \ud83d\udc4e on this.\n\n\nIt makes the Signal contract more complex, which is a problem for users. A simple contract is easier to understand and keep in mind.\n\n\nIt adds quite a bit of complexity to the implementation. I feel pretty strongly that we need to fight to maintain as simple an implementation as possible.\n\n\nI expect there to be very modest gains to be made from this. I expect that unobserved Signals made of stateless operators are relatively rare. I also expect that the vast majority of those that do exist don't consume much CPU time.\n\n\nI don't think this meets the complexity-to-performance ratio necessary for acceptance.. But conceptually, observers are reference types. So I think it makes sense for them to be a class.. > Does the reference semantics matter though? We can even replace it today with a generic typealias Event -> Void without breaking anything semantically, only syntactically.\nThat would still be reference semantics.\nReference semantics are not required by the Observer type, but it's still using reference semantics, so it makes sense to make the type itself have reference semantics. It communicates the intent more clearly to contributors and to users.. By reference semantics I mean has identity. (cf. the object/entity/value distinction in Domain-Driven Design.)\nA value type collection doesn't have identity, but its CoW buffer does. So it's consistent to use a class inside a struct in that case. But in this case, the CoW buffer is purely an implementation detail. The consumer has no knowledge of it because it's not exposed. The entirety of the public interface has value semantics.\nBut an Observer does have identity\u2014at least conceptually. I don't think of an observer as a value type that holds on to closures. I think of it as an object that responds to events.. I think we need to hold off on this until Linux can compile it.. This works:\n```swift\nextension SignalProducer where Value == Date, Error == NoError {\n    public static func timer(interval: DispatchTimeInterval, on scheduler: DateScheduler) -> SignalProducer {\n        return ReactiveSwift.timer(interval: interval, on: scheduler, leeway: interval * 0.1)\n    }\n}\n_ = SignalProducer.timer(interval: .seconds(5), on: QueueScheduler.main)\n```. I'm not totally sure what you're suggesting. \ud83d\ude15 \nProbably because I'm mostly unfamiliar with the generated docs.. I like it. \ud83d\udc4d . The current approach seems simplest to me. But we should definitely play around with it once a beta is available . I definitely think it makes sense to close this hole. I like that you split out #363\u2014that will make this diff more readable.\nI don't love the name DisposableCollector though. Collector makes me think of GC, which is a a little confusing in this context. We should think of a simpler name.\nWould it make sense to pass an inout [Disposable]?. DisposableSink, maybe? It's hard to come up with a good name for this.. > Sink sounds like a point of no return, while disposables are removable in our case\nBut they aren't removable inside the block? DisposableCollector and DisposableCollecting only have an add method. \ud83d\ude15 . \ud83e\udd26\u200d\u2642\ufe0f . I guess I'd lean towards DisposableBag. It seems like the least worst option.. The += operator you mentioned in #143 would call lifetime.observeEnded(disposable.dispose)?. I think I'm \ud83d\udc4d with Lifetime, but I do still think we shouldn't add +=.. @ReactiveCocoa/reactiveswift Any opinions on the passing a Lifetime to SignalProducer.init closures instead of a Disposable? This eliminates inappropriate disposals of the disposable from inside the closure.. Something like return self.flatMap(.merge, SignalProducer.init) seems a little weird to me, but I think I'm \ud83d\udc4d on this. \ud83d\ude15 \nOn the one hand, Swift's flatMap has an unnamed argument (and so does our flatMapError). On the other hand, this flatMap has 2 arguments.\nSince I don't think this is obviously the better option, I'd like to give @ReactiveCocoa/reactiveswift a chance to speak up in case anyone has an objection.. No objects, so I think this is good to go. Want to fix up the conflicts?\nI'm thinking that we should really make our deprecations file based on the version. So Deprecations+Removals-1.swift, Deprecations+Removals-2.swift, etc.. This is what I was thinking:\n```swift\nextension Signal {\n  func erased() -> Signal { \u2026 }\n}\nclass Combiner {\n  var startHandlers: [\u2026]\ninit(\n    signals: [Signal],\n    _ transform: @escaping (ContiguousArray) -> Composite\n  ) -> Signal {\n    // the code that was in make(count::), but also the code from add(:)\n  }\nconvenience init(\n    _ a: Signal,\n    _ b: Signal\n  ) -> Signal<(A, B>), Error> {\n    self.init([a.erased(), b.erased()]) { ($0[0] as! A, $0[1] as! B) }\n  }\n\u2026\n}\n```. Does this ambiguity cause problems in practice?\nIt's ambiguous for our test suite because we do this:\n```swift\nlet operation: () -> Result = {\n    operationRunTimes += 1\nreturn .success(\"OperationValue\")\n\n}\nSignalProducer.attempt(operation).start()\nSignalProducer.attempt(operation).start()\n```\nBut I think that's understandable.\nOrdinarily, you wouldn't use a SignalProducer like that\u2014you'd return it from some function which will add additional type information.\nThis is okay, for instance:\n```swift\nlet operation: () -> Result = {\n    operationRunTimes += 1\nreturn .success(\"OperationValue\")\n\n}\nfunc makeProducer() -> SignalProducer {\n    return .attempt(operation)\n}\nmakeProducer().start()\nmakeProducer().start()\n```. > But not if the Result has a type of AnyError\nI think we could add a 3rd overload to disambiguate that.\nswift\nextension SignalProducerProtocol where Error == AnyError {\n    public static func attempt(_ operation: @escaping () -> Result<Value, Error>) -> SignalProducer<Value, Error>\n}\nThat seems like the same thing we do for flatMap.. > so I guess we're getting compiled transitively?\nI was wondering that myself. ReactiveSwift.xcodeproj is in their project, so we must be.. I'm \ud83d\udc4e on this. I don't think we should add API for minor performance gains. take(during:) and take(until:) are more general and expressive; we should stick with them.. A small PR that demonstrates this with a single operator would probably helpful in evaluating this proposal.. More merge conflicts. \ud83d\ude1e . Thanks!. Those benchmarks don't seem like real-world usage. I would expect most bags to have <10 elements and nearly all to have <100 elements. Do you agree? If so, could you re-run your benchmark with realistic sizes?. Without a real world benchmark, I don't know how we can evaluate the performance of those two implementations and make an informed choice.. But these seem like very low overhead. Will having from 906ms to 452ms really make a difference when scrolling a collection/scroll view?\nIf not, we should consider the conciseness/maintainability of the code.. > A nil weak reference to a signal no longer means that the signal has been disposed of. on(disposed:) would become the only mean to assert this.\nI'll have to think about the impact of this.\n\nIf the generator observer deinitialises, it now triggers the automatic disposal since no event can be sent to the Signal from this point of time. Previously, it has no side-effect.\nIn other words, the rule of automatic disposal is now expanded to be (1) having no observer and having no external retain; OR (2) having the generator observer deinitialized\".\n\nCan you explain this a bit more? I haven't looked over the code, but I'm not sure when this would happen.. Can you add the external observers to your diagram above? I think that's the tricky piece to think about.\nWould it work to replace the self reference with an actual strong reference from the observer to the signal? That seems like it would maintain the existing semantics (which are conceptually simpler IMO) but also fix the tooling issues.\n\nA nil weak reference to a signal no longer means that the signal has been disposed of. on(disposed:) would become the only mean to assert this.\n\nI think it's preferable to not have this be the case, which is why I ask. But if this the only way to improve tooling interop, then I think it's worth it.. That test failure looks like it might be legit.. This is just #362?\nThat's fine to release as 1.1.2, but it can't be based off of master like this PR is\u2014or it will pick up lots of breaking changes.. > This is not based on master, but 1.1.1.\nApologies! I forgot that GitHub doesn't show you if the PR is behind the target branch. \ud83d\ude48 . I think I actually prefer the current structure. \ud83d\ude15 It makes it easy to view a summary of all the methods on Signal or SignalProducer*.\n*Except the flatten ones. But it's relatively easy to remember that they're in a separate file.. Nice. \ud83d\udc4d . I think Never reads fine. If that provides the same guarantee, I'd prefer it.. I believe this is resolved by #392. I don't see any other operators that could use Never.. @andersio ?. Can you leave a comment when/if this is ready for review?. > Change the Signal generator signature to (Observer, Lifetime) -> Void, so that it matches the style of SignalProducer.init.\nThis makes sense to me. (Although I did think about it for quite a while because I wasn't sure.)\n\nReplace pipe(disposable:) with a new variant of pipe returning a 3-tuple (input, output and lifetime).\n\nThis change seems less necessary and also orthogonal. I'm not convinced we should do this.\n\nUnfortunately, this is all too late for 2.0, so it will also need to be changed to be a non-breaking change (adding an init instead of changing it) or wait for 3.0.. 3.0 it is!\nHopefully we/I can be a little more prompt with 3.0. We could ship as soon as Xcode 9 / Swift 4 ship this fall.. This should be mentioned in the changelog, but otherwise it looks great. \ud83d\udc4d . Weird. I did not know that was a thing!. > Given that it makes the method signatures a little harder to read, I feel like I'm \ud83d\udc4e on this for now\nI agree. Let's do this when/if there's some benefit.. I think we literally just need the commits in master. So an empty merge commit that points to current master and 1.1.3 would suffice?. I think you want to do a git merge -s ours 1.1.3 from master.. >        ours\n\n      This resolves any number of heads, but the resulting tree of the merge is\n      always that of the current branch head, effectively ignoring all changes from\n      all other branches. It is meant to be used to supersede old development history\n      of side branches. Note that this is different from the -Xours option to the\n      recursive merge strategy.\n\n. Great idea. \ud83d\udc4d . \ud83d\udea2 . Moving lifetime to the rhs does't seem to help with readability either.\n\nI'll keep this in mind when I review #404 and then we can discuss more. We should definitely do something to improve things if we're going to be merge that PR.. I'm on board with an operator. This suggestion from @andersio seems like it might make sense:\nswift\ndisposable <~ lifetime. Okay:\n\nThere should be an operator\nIt should be (Lifetime, Disposable) -> Void\n\nMaybe we should go back to +=? Does anyone have a better suggestion?. > Could you add a job for the Swift 3 compatibility mode?\nI'm not sure how to do that, so I'd love to leave it for a separate PR.. This doesn't seem to me like it'd bring much benefit.. > Seems like according to the later rule\nIt does seem like that's the case. I don't especially like that though. \ud83d\ude15 . This would need to have conflicts resolved.. This isn't compiling. \ud83d\ude48 . Just needs a changelog entry or two.. It doesn't seem to have helped. \ud83d\ude48 . KeyPaths are the best thing ever. \ud83d\udc96 . I don't think these tests are actually going to run on CI right now. But since we've updated Nimble, we should be able to run swift test with Swift 4 on CI.. \ud83c\udf89 . Yup. I just learned that in a WWDC lab. \u263a\ufe0f . The tests need some more updates for Swift 4.. Ready!. How do you anticipate exposing this in RAC?. I don't love Decision, but no better options come to mind.. Having built something like this before (on the Obj-C APIs), I can say that it's definitely useful. So I'd definitely like to see something like this.\nBut I think it might be better to start this as an external project\u2014much like Rex. This is a purely additive API. Including it here will force it to maintain the same source compatibility as the rest of the project. Starting it elsewhere would let these APIs mature at their own pace. Once it matured, it could then be moved into ReactiveSwift.\n(I'd still be willing to review PRs on that codebase if desired.). > If we are not going to commit to it yet, we can either declare these as experimental, or maintaining a feature branch given its additive nature (very low chance of conflicts).\nThe problem with a feature branch is that it's hard for people to use it. So you can't get the same level of feedback about the APIs. Frameworks benefit from real world usage because it informs the design of the API.\n\nLet alone the very fact that ReactiveSwift in its fairly mature state doesn't have a high volume that could distract (or be distracted by) the collection effort.\n\nIt's not that I'm worried about distraction. If we want to make a breaking change to collection diffing, do we (1) wait for a breaking release of ReactiveSwift or (2) make the next release a major version so that the collection diffing can have a breaking change?\nNeither of those is a great option. (1) means that these APIs evolve more slowly than they could otherwise. (2) makes upgrading harder for everyone who uses the framework.\n\nGiven the scale of our community and my personal experience with ReactiveCollections, I am against evolving externally.\n\nI'm not entirely sure what this means or what your experience has been. But I think we could make these diffing APIs a more official API if that'd help. And maybe have a plan to migrate them into this repo after a certain amount of time or something.. I'll continue to review this, but it may take a little time for me to review and understand the difference pieces.. What's the motivation behind this? This is a reasonable thing to do, but without a strong use case, I'd rather not expand the API.. \ud83d\ude05 . \ud83d\udc4d for (1) though!. Somehow I missed that this was updated to only do (1). \ud83d\udea2 . > You can now use a state-property with a non-Void input type\nDo you find yourself actually wanting to do this?\nTBH I haven't used Action much (although I did use RACCommand). I'd envisioned that state would actually be the better model, since it's fully reactive. But I'm curious about how you're using it and would love to hear more.. Sounds good. This just needs a changelog entry. \ud83d\udc4d . There's not as easy way to do that.\nI think you'd need to:\n\nCreate two copies of the start signal\nFilter only began/ended values on one\nFilter only changed values on the other\nThrottle the values\nCombine the two signals\nScan the tuple of events to see what's changed and only forward the valid events. I'll review soon, but this is a great idea. \ud83d\udcaf. That makes sense to me. \ud83d\udc4d . I wouldn't call it a leak if something is holding on to the signal.. What are goToCheckInPage and goToLogInPage?. You could move the combine latest into the other signal\u2014even keeping the current structure.\n\n```swift\nlet checkIn = self\n    .viewDidLoadProperty.signal // No need to use merge for this\n    .map { AppEnvironment.current.currentUser != nil }\n    .combineLatest(with: self.checkInButtonTappedProperty.signal)\nself.goToCheckInPage = checkIn.filter { $0.0 }.ignoreValues()\nself.goToLogInPage = checkIn.filter { !$0.0 }.ignoreValues()\n```\nBut I think there are probably larger improvements that you could make to your architecture. You might want to take a look at using Action with your button (via ReactiveCocoa) if you haven't already done so.. I think which overload is most coming depends on how you reactive your code is. At work, we've been mostly been using startWithResult.\nMy opinion is that the unambiguous trailing closure syntax is useful for this method.. Would this act like filter, where it just drops events? Or would resuming restarting the producer?. This proposal isn't concrete enough to evaluate. But I think anything we'd add would probably take a signal producer as its argument\u2014one that sent true/false\u2014instead of two signals.. The documentation says:\n/// - warning: `interrupted` events on inner producers will be treated like\n    ///            `completed` events on inner producers.\nI think we should go by that. Both expects should be false.. Is this covered by CI?. Thanks! I don't think it's necessary to update the changelog.. Do you think this is still needed now that += is back?. \ud83e\udd18 . I'm \ud83d\udc4e on this. I don't think provides much value. The cells in your example can ignore the uninteresting properties; I don't think having access to them has any negative effect.. Could you provide a code example of how you're using it?. I'm not convinced that this is the best solution for connecting an actual to a cell view model. \ud83d\ude15 But I'd need to spend some time playing with a complete example to have a more informed opinion.. I'm not sure I see the value in this. I don't see why it'd be useful.. Awesome! Thanks for tackling this. \u2728\nWould you mind targeting this against the 1.x-maintenance branch instead? I think we should release this as a hot fix for 1.x so that people don't need to update to 2.x to use Xcode 9.. This is fantastic! Thanks.\nOnce CI is green, I'll merge, release a hot fix, and merge the change into master as well.. @andersio If you want to do a 1.x release and then merge it into master, go ahead. Otherwise I'll do it later tonight or in the morning when I have time.. This is looking good overall. \ud83d\udc4d \ud83d\udc4d . \ud83c\udf89 . I think that particular test is unstable. I've rerun those tests\u2014hopefully they'll pass this time.. Changes to type constraints always make me nervous because of the potential to change the type inference. \ud83d\ude48 . Would adding associatedtype Error = NoError directly on PropertyProtocol have the same effect?\nIf not, I'm \ud83d\udc4d on this.. Thanks for opening a PR!. Thanks for the PR! Sorry I've been slow reviewing. It's been a busy few weeks.\nThe Swift 4 linux build failed, but I think that's because it needs to be updated.. I don't understand what this adds. Could you elaborate? It seems like this would just increase conflicts and require more type annotations.. This breaks source compatibility, but maintains binary compatibility, correct?. I'm not a fan of disabling these. The CocoaPods test, in particular, is useful for catching issues since the spec needs to be kept in sync with the information in the Xcode files.\nAs a reviewer, these make my job easier.. Thanks for the pull request!. Awesome. Thanks for updating this!. Thanks!. If accepted, we'll want to add bridging initializers that take async blocks and convert them into SignalProducers. Do you see other implications?\nOn the whole, async/await doesn't seem very interesting to me.. 1. Can you add the sample code above as a test?\n\n\nDoes this affect the other take operators? (take(until:) and take(during:))\n\n\nDoes this affect other operators that send terminations? (sample(on:), timeout, etc.). Thanks for the explanation. That helped a lot. \ud83d\udc4d . \ud83d\udc4d . Nice work! \ud83d\udc4f \n. I'm liking this. \ud83d\udc4d . \ud83d\udc4d on the name change. I'm pretty ambivalent about this addition. \ud83d\ude15. Maybe it's time to reconsider adding a Single type of some sort. It seems like that's the real issue here: it's cumbersome to deal with a stream of n events when you know there will only be 1. #201 . Yeah, I think there are benefits to documentation/reasoning. Many common tasks could be represented as a observable of one value. It would be easy to have APIs to convert between them as well.\n\n\nThe biggest issue is coming up with a good name.. I think this requires a major version bump.. > While it is once said that recursive signals are wrong, unidirectional data flow is actually an example of proper use.\nI'd like to see more justification for why is useful and a good idea.. I don't think this is a great idea. But I'd be curious to hear what the rest of @ReactiveCocoa/reactiveswift thinks\nThis adds quite a bit of additional complexity. Granted, the patch isn't that large. But I'm concerned about the additional drains on maintainability. I'm also worried about more complex interactions that may we may not be taking into account here.\nOn top of that, I think loops like this are generally a bad idea. They make signal chains harder to reason about and more prone to bugs. I don't want to make bad ideas easy.\nBut my opinion on this is definitely influenced by my relative opinions of Elm and React-style architecture. Elm's model is quite a bit different and doesn't have these issues.. This seems conceptually similar to concat except that the queue/buffer isn't infinite.\nMaybe this?\nswift\npublic static func queue(limit: UInt) -> FlattenStrategy { \u2026 }. I think what you're seeing here is an intentional design change in the Swift version of ReactiveSwift. (Note that this question would really be more appropriate for https://github.com/ReactiveCocoa/ReactiveCocoa.)\nSwift ReactiveCocoa methods to observe UI elements intentionally do not send the initial value. This was done because your model should be the source of truth\u2014not the UI elements. So your model should specify the initial values here, not the UI elements.. Thanks for cleaning this out. \u2728 . Awesome! \u2728 . We believe these names match the Swift API Design Guidelines. Specifically this part:\n\nOtherwise, if the first argument forms part of a grammatical phrase, omit its label, appending any preceding words to the base name, e.g. x.addSubview(y)\n\nNote the Swift standard library might be gaining a filterMap method in Swift 5.. It doesn't make sense to me to add schedule(after: Date, action: () -> Void) to ImmediateScheduler or UIScheduler.. Would you mind breaking up this PR into a few smaller ones? This is pretty meaty, especially with the changes to SignalCore, which makes it difficult to review.. There looks to be a real test failure.. It may be missing this from Signal.send:\nswift\n            if event.isTerminating {\n                self.observers = nil\n            }. That was just my guess as to why the test was failing.. In #573, I don't see makeSynchronizing reused. Is the intent to make this reusable? Where will it be reused?. I'm not convinced that this is a win.\nWhen I look at this PR by itself, it definitely doesn't seem like an improve its own right. If it makes #573 easier, then it could be worth doing, so I think the question is whether we want to take the 2 PRs.\nWhen I look at #573, it looks very complex. I don't like the look of SynchronizationStrategy, and I'm not convinced that it's a net benefit to move all of those operators into event transforms. Maybe it'd be better to keep the separate code paths? Event transforms for simple transforms, Signal operators for more complicated ones.\nI guess it feels like there are 2 separate types of operators here. Treating them in the same, or mostly-same way, sounds appealing, but isn't necessarily very clean. We might be better off keeping two different approaches. The approach for the more complicated operators doesn't need to be what we have today, but I think something that uses distinct APIs might bring more clarity. . This doesn't really seem any clearer to me. \ud83d\ude15 . I think start makes more sense to me because it's similar to SignalProducer.start. It's easier for me to intuitively understand its role, even though the signature/specifics is a bit different.. Usually that's downstream from whatever the actual error was.. I'm curious why you found it awkward to use. Returning a Property<U?> seems like it might make more sense to me. You could always do property.filter(condition).map { $0 ?? initialValue }.\nIt does seem like either way would get painful if you were going to chain multiple things together:\nswift\nproperty\n    .filter(initial: 1, condition1)\n    .filter(initial: 1, condition2)\nIt'd be nice if we had could do something to propagate that through with some sentinel value. But I don't think that possible with the current APIs. \ud83e\udd14 . I think I'm on board with passing in the initial value like you have here. I don't see a truly better option.. Thanks @iv-mexx!. Have you tried reducing your problem to a shareable, reproducible sample? I don't see that you've done anything wrong, which makes me think the problem may be with the code you haven't shared.. That certainly sounds strange. I'm unsure what to think here. Hopefully a reproducible sample will make it more obvious.. This is supposed to be covered by CI. Any idea why it isn't?. Want to add this playground to CI too?. \ud83e\udd18 . In general, I think you're best off structuring your code to avoid these issues entirely. ReactiveSwift doesn't have anything to make this easy, and I'm not convinced that it should.\nBut it's tough to look at a small snippet of code and give good advice about how to change things to improve the situation.\nIn this case, I'd wonder if you should need to pass _chatDelete to chatsProvider. If you're calling chatsProvider.deleteChat, can't it know that it needs to reload the chats? You might still use a pipe to accomplish this, but it wouldn't be circular.. The current ReactiveSwift release works with Xcode 9.3 / Swift 4.1. It just has some warnings.. Do we want to maintain Xcode 9.2 / Swift 4.0.1 compatibility? As-is, this breaks compatibility (from changes I made) but retains some code for Swift <4.1. I'm not sure whether we should rip out the shims or add more in.. Good thing these will be synthesized soon!. Closing in favor of #593.. Did you follow the instructions?. Thanks for the pull request!\nI'm definitely \ud83d\udc4d on compactMap.\nBut I'm not sure we should rename skipNil to compact. While I do value consistency with the Swift stdlib, I value consistency within ReactiveSwift even more. I think our naming convention of skip* makes a lot of sense and makes things easier for beginners and experts alike.\nWhat does the rest of @ReactiveCocoa/reactiveswift think?. > Maybe we can get the discoverability benefits by adding empty implementations of compact() and compactMap() with fixits that suggest the correct name (and ideally hint as to why)?\n\ud83d\udc4d . When in doubt, keep adding type annotations. \u263a\ufe0f \nswift\nlet producer3: SignalProducer<Never, PresentableError> = producer1\n    .mapError({ (error: CustomError1) -> PresentableError in error })\n    .then(producer2.mapError({ (error: CustomError2) -> PresentableError in error }))\nerror: using 'PresentableError' as a concrete type conforming to protocol 'Error' is not supported\nlet producer3: SignalProducer<Never, PresentableError> = producer1\nThis is a Swift limitation.. > void(): I support this. I don\u2019t like that name in particular, but I\u2019m sure we can find a more precise one. In my codebase I have this as var voidValues: Signal<(), E> {}, but I don\u2019t love that name either.\nAgreed. I think we just need the right name. We've previously referred to Signal<(), E> as a trigger, so that might be a clue towards a good name.\nI've been wanting to add a func map<NewValue>(value: NewValue) -> Signal<NewValue, Error> to map to constant values. Maybe that'd be enough for this? .map(value: ())\n\nskipError: this has been suggested many times, but I\u2019m strongly against it.\n\nAgreed. \ud83d\udc4e \n\nmerge(with:): I have this same one in my codebase, so \ud83d\udc4d\n\n\ud83d\udc4d . > I'd overload map with it, or name it replaceValues(_ newValue: NewValue), not sure what I prefer.\nI like overloading because it aids in discoverability and makes the API surface smaller in some ways.\nI could see adding a skip(value:) too.. Could we provide an unavailable version that explains it while leaving the NoError version in tact?. Awesome! Thanks for adding this. \ud83e\udd18 . Wat! That does not seem like a valid use of trailing closure syntax. \ud83d\ude15 . Yes, about to file an issue.. https://bugs.swift.org/browse/SR-6989. This seems to specifically be an issue with the block { $0 as Int? }. This works fine:\n```swift\nlet (signal, observer) = Signal.pipe()\nlet mappedSignal = signal.map { Optional($0) }\n// // Cannot convert value of type 'Signal<(Int?) -> Int?, NoError>' to specified type 'Signal'\nlet expectedType: Signal = mappedSignal\n```\nSo depending on what response we get to SR-6989, I might favor leaving it as map(value:).. I'm in favor of ignoring it since (1) it only relates to specific closures, (2) it results in an error, not incorrect behavior, and (3) clients can work around it by adding explicit types.. I'm still in favor of leaving it as-is.. Thanks for your work on this! \ud83c\udf89 . Thanks for the PR! I always appreciate efforts to clean up the codebase.\nI don't think all of the changes are better, but there are some good things in here. \ud83d\udc4d . Thanks for this! Clean up is always appreciated!. Thanks for the PR!. I think we'd want tests that exercise each of these at least once\u2014for type inference if nothing else.\nI'm going go to leave this for @andersio to review since he'll be more much familiar with any traps here.. I don't think we're blocked my compiler regressions anymore. (They've given a workaround and said that it won't be fixed AIUI.). > Why must the Property be a class?\nIt's this bit:\n\nimplies the origin must have a unique identity\n\nFor something to be observable, it must have reference semantics. (Since values can't change in an observable way.) You can create a thin wrapper as a struct, but it's not a value in any meaningful sense since it'd be backed by an object that was providing identity.. Something like that was proposed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/547, but was never finished.. Those seem like reasonable default implementations. \ud83d\udc4d \nWhy are you making custom mutable property types?. Probably not hidden completely, since you might want to react to an interruption. But theoretically maybe sending interruptions should be hidden.. @manojmahapatra Could you provide a complete example that reproduces the issue?. I'll try to get to this in the next day or two. I think this cleaned up rather nicely. \ud83d\udc4f After the minor fixes noted above, we should be good to go.. Unfortunately, the linux build is failing on CI and I don't see why. \ud83d\ude10 . This will need a merge now that #605 has been merged.. Thanks @Qata!. I do think .signal is sometimes the correct thing to use, so I'd be hesitant to remove it, even though you can always use .producer.skip(first: 1).\nBut I do wonder if there are better names than .signal and .producer. \ud83e\udd14 \n\nIf we really mean to promote \"SignalProducer unless absolute necessary\", shouldn't our API design reflect that?\n\nI don't think we've ever said that, although producers are definitely far more common.\nI guess I do see room for improvement here, I just don't know what direction we should go with it. It might be time to reflect on the Signal/SignalProducer distinction on the whole and see if it can be improved.. This is really a question for https://github.com/ReactiveCocoa/ReactiveCocoa, which is where the Cocoa bindings live.\nReactiveCocoa doesn't currently have any bindings on CALayer. Someone would need to add them.. Not currently. Someone would need to add bindings for those to ReactiveCocoa.. I feel strongly that we should leave this constraint. (I also feel strongly that the Stdlib should have it for Result's error.). If Swift adds typed throws where the types don't need to conform to Error, then I'd support removing this constraint.. I think so. Especially since Result also has the Error constraint.. This might work better as a flag on sample(on:)?\nswift\nfunc sample(on sampler: Signal<(), NoError>, passValuesThrough: Bool = false) -> Signal<Value, Error>\nI'm not against including this functionality, but I don't think it warrants a new top-level operator.. > IMO the second version edges ahead of the first in clarity\nI agree there. But I think there's balance to be struck between \"this is clearest when reading\" and \"this adds the minimal overhead to the API\". We're at two ends of the spectrum right now and it'd be nice to find something in the middle.\nIf we're going to add a new base operator verb, then I think it should be something that's widely useful or has a number of useful variants. I'm not sure if this fits. \ud83e\udd14 . Definitely \ud83d\udc4d on the idea. Type inference is the only trouble spot, so tests are a good idea like @andersio mentioned.. Make take(through:)? Swift stdlib uses upTo: to mean not included, so I think that's out.. Oh, thanks! \ud83d\ude05 . Thanks for the PR! Sorry we've been slow to review it. \ud83d\ude48 \nThis needs also some tests and a changelog entry.. We've taken #642 instead. Thanks again for opening a PR!. .reactive comes from ReactiveCocoa. Are you using it? Have you imported it?. Makes sense. \ud83d\udc4d \nCan you add some tests and a changelog entry?. I know there's been some discussion of removing this requirement before. Can you share an example of a non-class type where you'd like to use it?. I'm not sure this is something that we want to support.\nReactive extensions only really make sense with a reference type. If you were trying to change a struct or enum, you'd have problems. I'm not sure if enabling other wrappers like this is worth it given that it might be confusing to users.\n@ReactiveCocoa/reactivecocoa?. > @mdiep is that the confusion you're thinking of? That users might make a binding target to a struct and then be confused that it doesn't mutate shared state?\nYup. . Check out flatMap and FlattenStrategy.. You're right that flatMap doesn't introduce concurrency. That's probably not what you'd want in most circumstances as certain producers might be required to run on certain schedulers.\nThe general idea is to run producers on different serials queues as necessary and then flatMaping them into a concurrent producer instead of using a concurrent queue. It's hard to give good guidance on this generally.. That would cause issues.. Eek! \ud83d\ude48 Good catch!. I like it. \ud83d\udc4d \ud83d\udc4d \nThis should be a lot clearer for most people.. Sorry for the delay on this. I was initially a bit confused, but this makes sense. Want to resolve the CHANGELOG conflict and merge?. Do you want to move the headers phase before the compile sources phase as part of this?. Side note: if you really want initial to be the initial value, you\u2019d need to send it before observing the signal. As is, there\u2019s a race condition between the two.\nThis doesn\u2019t seem any any better to me than SignalProducer(signal).prefix(value: initial). Is there a reason why you think this would be better?. Thanks!. We really need something that verifies that the SwiftPM, CocoaPods, and Carthage dependencies all match. \ud83e\udd14 . Seems like we could maybe write a tool that does this and run it as a CI test? It'd be applicable to basically all of the Swift open-source that I do.. You want the value from valueStream on the current run loop?\nThrottling on QueueScheduler.main will always delay the value to the next run loop. You'd need to use UIScheduler for the throttle to have values from valueStream not do a thread hop.. What scheduler is sampleStream on?. You shouldn't need the observe. If sampleStream has already sent a value, then the combineLatest should execute right away. I would verify the timing before/after the combineLatest with a .logEvents or .map to make sure that the throttle is sending a value when you expect.. This looks like a recursive signal problem.\nframe change -> send event -> change frame -> frame change -> send event\nEvents cannot be delivered recursively. The easy fix for this is to add a queue hop somewhere. But it probably means that your signal chains should be restructured. It's hard to give any feedback on that from just the backtrack.. When you send the recursive event on the signal, it tries to acquire the send lock and deadlocks. Ideally, we'd crash there with a nice error instead. Want to play around and see if that's possible?. What did you change that made it work?\nThese locks are intentionally not recursive. Changing it to a recursive lock should be the only thing that fixes it. But we don't want it to be recursive.. Thanks for opening a pull request, but I don't think we'd want these. Instead, you should use init(value:):\nswift\nSignalProducer(value: true). Can you use take(first:) or take(while:) or something instead?\nI'm not sure what exactly you're trying to accomplish, but it seems like you have a pretty roundabout approach.. Our original reasoning for using static functions and inits was that it better fits the Swift API design guidelines and the design of the standard library. I think that's still true, which is why I'd argue to keep that style. Apart from that, I don't really have an opinion.. That implementation doesn't look correct to me. I think you're going to send the wrong accumulator at times.\nAre you aware of any existing operators like this in any Rx libraries? (If not, could you do some research on this?). Some operators on SignalProducer could probably also return one of these instead of a SignalProducer. e.g. collect. > Now, would I like some added comfort provided by the compiler and/or type system to guarantee that my SignalProducers only ever emit a single value? Maybe\n\nIs it worth giving up the simplicity of having \"two base types\"[^1] that are vended by ReactiveSwift? I don't think so.\nIf folks are having trouble with explaining ReactiveSwift to teammates, it won't be any easier to also try and explain the subtleties of why you should instead use the Promise variant over a SignalProducer, how we bridge the two, etc.\nFrankly, if you really want Promise and Future, then it should just exist in a whole new type (and probably even a separate library) that offers exactly that. IMO, there is far too much (conceptual and implementation) baggage and overhead that comes with Signal{,Producer} to use it as the basis of the simpler Futures & Promises construct.\n\nI think it all depends on the specifics.\nYou raise some good concerns. But I think it's conceivable that this concept could be added in a way that actually makes ReactiveSwift clearer. It definitely needs to be considered holistically.\nI think the Signal/SignalProducer distinction is confusing for people. I'm not sure it's the best division of responsibilities. So personally, I've been questioning what the right divisions and names are. I think that's the real question here: have we found the right model, or does it need to adapt slightly?\nI agree that if this concept probably shouldn't be added if it can't be added in a way that clarifies the whole.. I do like the name Async quite a bit if we're not going to model promises/futures exactly.. What version of Swift are you using?\nMore context here: https://github.com/ReactiveCocoa/ReactiveSwift/pull/604. Note that the underlying issue, https://bugs.swift.org/browse/SR-6989, has been address in Swift. I'm not sure if it's in 4.1, but it will be fixed in 4.2.. > The Swift bug is still open, so I guess this wasn't fixed for 4.2?\nThe bug has been fixed. The ticket remains open because it's tracking the suggestion that trailing closure syntax should be disabled entirely for functions that don't explicitly take a function.. Sorry, but I'm unclear (1) what problem this solves and (2) how it solves it. Could you share a little more detail please?. Sorry it took me so long to look at this.\nUnfortunately, I don't think this makes sense to include in ReactiveSwift. We try to focus on reactive primitives, and I don't think this qualifies. I've been doing reactive programming for a while now, and I've never seen anyone do something like this.\nAs an aside, I think you might be able to find a better abstraction. In particular, from the limited code samples that you've shared, it looks like it might make more sense to have a Property<Store> instead of a Store with a Property\u2014or to create another type to serve as the thing being observed.. Thanks for the PR!\nI'm not sure we want to move to 4.2 right now. That'd be a breaking change and it has little benefit at the moment.. > It shouldn't be a breaking change though, unless we used anything exclusive to 4.2+ modes.\nI don't think it'll build in Xcode 9 if you've set the Swift version to 4.2.. I guess our CI disproves that. But it'd be an issue as soon as you tried to use a 4.2+ feature.. How are you seeing that this is a leak?\nDoes it still appear as a leak after that SignalProducer completes?\nReactiveSwift does some things that can result in false positives in Instruments.. I don't see any leaks with that snippet in Instruments.. Awesome! \ud83d\udc4d\ud83c\udffb\nI've wanted this for a while, but I had a hard time deciding on a name. materializeResults and dematerializeResults seem like good choices.. Can you clarify what behavior you want? An example might be helpful. I'm not sure what you're trying to achieve.. > maybe something like this:\nThat's what I'd do. \ud83d\udc4d Except I'd probably move showing/hiding into the flatMap(.concat).\n```swift\nenum Action {\n  case show\n  case hide\n}\no.producer()\n  .flatten()\n  .flatMap(.concat) { toast -> SignalProducer<(Action, Toast), NoError> in\n    SignalProducer(value: (.show, toast))\n      .contact(SignalProducer(value: (.hide, toast)).delay(toast.duration, on: QueueScheduler.main))\n  }\n  .observeValues { (action, toast) in\n    // show or hide toast\n  }\n``. You could use.sample(on: .timer(interval: 1, on: QueueScheduler.main)).skipRepeats(). Does that match what you're trying to do?.timeris defined onSignalProducer, so you'll need to be explicit and map the value to()`.. Nice! This is some good cleanup. Thanks for the PR!. > Is this how it should be and what's the reason behind receiving interrupted as a value?\nThis is the hint:\n[Dispose check] value VALUE 2018-10-25 06:32:57 +0000\n[Dispose check] value INTERRUPTED\nSee how both say that they're _value_s?\nYou're using materialize here:\nswift\n    func sync(_ interval: DispatchTimeInterval = .seconds(60), withLeeway leeway: DispatchTimeInterval = .seconds(30))\n        -> SignalProducer<Signal<NSDate, SyncError>.Event, NoError> {\n            return clockSignal(interval, leeway: leeway)\n                .promoteError(SyncError.self)\n                .flatMap(.concat) { [weak self] date -> SignalProducer<NSDate, SyncError> in\n                    guard let strongSelf = self else {\n                        return SignalProducer(error: SyncError.anyError)\n                    }\n                    return strongSelf.performSync(date)\n                }\n                .materialize()\n    }\nmaterialize turns interrupts into values:\nswift\n    /// Treats all Events from the input producer as plain values, allowing them\n    /// to be manipulated just like any other value.\n    ///\n    /// In other words, this brings Events \u201cinto the monad.\u201d\n    ///\n    /// - note: When a Completed or Failed event is received, the resulting\n    ///         producer will send the Event itself and then complete. When an\n    ///         `interrupted` event is received, the resulting producer will\n    ///         send the `Event` itself and then interrupt.\n    ///\n    /// - returns: A producer that sends events as its values.\n    public func materialize() -> SignalProducer<ProducedSignal.Event, NoError> {. I think this is by design. For one thing, setting inner can't return a value that indicates whether the value was set. The current behavior makes more sense to me.. What I mean is that adding a disposable to a CompositeDisposable is a failable operation. You call add and get back get back a Disposable? that tells you whether your disposable was added. Because SerialDisposable lets you assign to a property, it can't return a value that indicates whether your disposable was set as the inner disposable.. I've never run into a case where this would cause an issue. Have you seen problems from this?. Thanks for the PR!. > Semantically it is the right fix\nCan you elaborate on why you think this is the case? I shared some thoughts on #686, but I don't see why this is necessarily better or more correct.. We default to internal until and unless someone makes a compelling argument to make it public. That makes breaking changes less likely and prevents the API from growing too large.. Looks good! Thanks @anayini!. Thanks for the PR!. I think you want combineLatest, not sample. sample isn't going to send you the latest value\u2014it'll send you the value when the right side sends a value.. Since both sides of the sample or from the same producer, I don't think there's any guarantee about which will fire first. In the specific example you gave, you could do do placemarks.producer.map { ($0, $0.first) } instead.. No, I think what you have is the best way to write that.. Would you mind giving an example of what you'd use this for?. I'm not convinced that this is a worthwhile addition.\n\nIn my case, I want to map video stream's metadata to also emit ExtraFlag based on first \"playing metadata\" + that might get reset via metadata = nil:\n\nIt seems like you'd be better off adding a struct instead of a tuple and handling the mutation there.\n```swift\nstruct State {\n  var metadata: Metadata?\n  var extraFlag: Bool\n}\nlet upstream: Signal = ...\nlet downstream: Signal<(Metadata, ExtraFlag)?, NoError> =\n    upstream.scanMap(nil) { (state: State?, metadata: Metadata?) -> State in\n        guard let metadata = metadata else {\n            // metadata = nil as resetting state\n            return nil\n        }\n    guard let state = state else {\n        // 1st `metadata` as `state` if `metadata.isPlaying`, otherwise don't store state & send\n        return metadata.isPlaying ? State(metadata: metadata, extraFlag: false) : nil\n    }\n\n    // Non-first `metadata` comes here\n    var newState = state\n    newState.metadata = metadata // this would update the extra flag\n    return newState\n}\n\n```\n\nIn our codebase there is a common scenario to keep the first value and drop subsequent values until nil occurs, which currently implements as a scan plus a filterMap:\n\nI think this would be more clearly written with combinePrevious, since that's what you really care about:\nswift\nextension SignalProducer {\n    func firstUntilNil<U>(_ transform: @escaping (Value) -> U?) -> SignalProducer<U, Error> {\n        return self\n            .map(transform)\n            .combinePrevious(initial: nil)\n            .flatMap(.concat) { ((old, new)) in\n              return old == nil ? .init(value: new) : .empty\n            }\n            .skipNil()\n    }\n}. The accepted proposal is:\nswift\npublic enum Result<Success, Failure: Error> {\n  case success(Success)\n  case failure(Failure)\n}\n\ud83d\udcaf we should use this.\nantitypical/Result should also update to be a set of additions to the stdlib Result.. > The tricky bit is NoError which could have been a typealias to Never, had it been conformed to Error in stdlib.\nNever is conformed to Error now. \nhttps://github.com/apple/swift/pull/16857. > Assuming antitypical/Result would just be augmenting the stdlib Result since Swift 5, should we consider dropping antitypical/Result as a dependency?\nYes, I think so. \ud83d\udc4d . Thanks!. This seems like a fine thing to include. \ud83d\udc4d\ud83c\udffb (But I haven't given the code a thorough review.)\n. Want to fix up the Linux build first? I'm curious if that will have any impact on the code.. That's not a bad idea. Maybe a deprecated typealias? That would ease migration.. I dislike using producer and signal in the names like this. If you're looking to get an observable with the attributed string values, I don't think you should need to know upfront whether RAC exposes it as a Signal or as a Producer.\nThere's been discussion about bundling things like attributedStringValue and attributedStringValues into a single type (c.f. https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3463). That seems like a better solution to me. It should also be possible to build a property that provides this functionality. I can't remember if we've discussed that before.. > is there any reason why current api doesn't make use of them?\nI honestly don't remember. \ud83d\ude05 . Thanks! These are always hard to keep up to date as things move around.. The Xcode playgrounds that are in the repo are a very good resource for that.\n@eimantas has also written a book.. You should be able to do this:\nswift\ntextField.reactive.text <~ viewModel.userName\nviewModel.userName <~ textField.reactive.continuousTextValues\nNote that this uses ReactiveCocoa.. No, it's not: one needs to be the source of truth. This works with text fields (and other controls) because it doesn't update when the text field changes\u2014only when it's edited.\nBut you could share a property?. I think the deployment target of the macOS tests will need to be changed to 10.10 to match Quick/Nimble.. Awesome, thanks!. lol, no. Not sure what I was thinking here. \ud83d\ude06 \n. This one isn't optional.\n. Thinking about this more, I don't think this is safe.\nThe property's value could change between the enabled check and the time execute is called. If the value has switched back to nil, then this will assert.\nI think this will require some changes to apply and maybe a different initializer. I don't see how we can make the current approach work. (But I'd be happy to be wrong.)\n. I think this should be a separate -note: section. It doesn't actually makes sense here because ActionError.disabled never comes from the SignalProducer returned from apply().\n. Our style has been to not prefix private variables with an underscore unless there's a public variable with the same name.\n. You can return this from the modify directly instead of assigning to a var.\n. I'm still working through whether it's safe (trying to verify that it won't deadlock), but it's definitely easier to understand the code here now. \ud83d\udc4d\ud83c\udffb\n. Oh, you're right. I was thinking it was the signal returned from the execute closure. \ud83d\ude48 \n. I don't feel good about calling the executeClosure inside a lock. I think we need to find a different solution. \ud83d\ude15 \n. If we changed this initializer to this:\nswift\ninit<P: PropertyProtocol>(enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer<Output, ActionError<Error>>) where P.Value == Bool\nThen the execute closure could bail if required. This seems like it'd be a nice safety addition in general\u2014for cases when you would need make guarantees.\n\ud83e\udd14\n. The reason we started on this is so that this:\nswift\n    public init<P: PropertyProtocol, T>(input: P, _ execute: @escaping (T) -> SignalProducer<Output, Error>) where P.Value == T? {\n        self.init(enabledIf: input.map { $0 != nil }) {\n            execute(input.value!)\n        }\n    }\nCould guarantee that input.value was non-nil. I actually don't think the code as written solves even this.\n. I was think that this:\n``` swift\nprivate let executeClosure: (Input) -> SignalProducer>\n// new init that uses ActionError\npublic init(enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer>) where P.Value == Bool { \u2026 }\n// existing init\npublic init(enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer) where P.Value == Bool {\n    self.init(enabledIf: property) { return execute.promoteErrors(ActionError.ProducerError) }\n}\n```\nwould work.\n. It seems like it'd be easier to only #if/#else around the added dependencies.\nswift\nlet package = Package(\n    name: \"ReactiveSwift\",\n    dependencies: {\n        return [\n            .Package(url: \"https://github.com/antitypical/Result.git\", majorVersion: 3, minor: 0),\n        #if !os(macOS)\n            .Package(url: \"https://github.com/Quick/Nimble\", majorVersion: 5, minor: 0),\n            .Package(url: \"https://github.com/Quick/Quick\", majorVersion: 0, minor: 10),\n        #endif\n        }(),\n\u2026\n. We shouldn't be using the main thread: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2912.\nIt seems like this API shouldn't be using queues at all\u2014it should use schedulers. I don't know if that will have any affect on the issue at hand.\ncc @ikesyo \n. How about ReactiveType for this?\nI know it's a bit outside of the Swift norm, but I think it could work here.\n1. Reactive is the obvious choice, but the struct is Reactive. (Which I absolutely think is the right name.)\n2. ReactiveProtocol might be useful to apply to Reactive itself\n3. ReactiveType is meant to suggest that the type itself is reactive.\n. I think Reactant should be called Base instead. RxSwift did that, and I think it's the right call because it matches what the Swift standard library does for similar types. (c.f. LazySequence)\nAlso, I don't think Reactant needs to conform to ExtendedForReactiveness.\n. I feel a little torn about using rac in ReactiveSwift, but (1) I can't think of anything better and (2) it does seem nice to use the same thing everywhere since they'll lead to the same type anyway.\n. ReactiveExtensible? ReactiveEnabled?\n\nReactive* somehow sounds like implying non-conforming types of Reactive* are not reactive.\n\nIf you think of it as implying they're not Reactive, I think it works. \ud83d\ude15\n. To prevent name collisions in a slightly nicer way than using the rac_ prefix. (https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3049)\n. How so? This seems akin to Swift's LazySequence.\n. I could go either way.\n. This seems like it should take a Signal, not a Property. \ud83d\ude15 \nIt should be easy to go from the property to the signal, but it's not easy to go the other way.\n. You probably meant skipRepeats here, not uniqueValues?\nAlso, this should be formatted according to the RAC style.\n. I think this value should get sent outside of the Atomic's lock to prevent deadlock.\nEven though it's in a schedule block, that can execute synchronously if, e.g., you're on the main queue and you're using the UIScheduler.\nSame goes for the send below.\n. This could just be return self == .terminated.\n. The wording here is a little off. Should be something like this:\n\nIt is intended for extensions to types that are not owned by the module in order to prevent name collisions and return type ambiguity.\n. I still don't love this name. But I guess it's good enough for now. \ud83d\ude15\n. += doesn't makes sense to me since this doesn't alter lifetime.\n. Huh. I didn't think you could have a static and instance members with the same name. (Did that change in Swift at some point?)\n\nNicely done!\n. The release shield still points to RAC. \ud83d\ude33 \nCan you update that?\n. I don't think we need a link to the Obj-C API here. There's no reason for someone to end up here when looking for the Obj-C APIs.\n. This could probably be up by the other looking for \u2026? links.\n. the grand concept reads a little weird. I'd take out the word grand or write something like is an opinionated implementation of reactive programming.\n. We should continue to link to RxSwift, I think.\n. (1) seems like the right thing to me, although it's a tough call.\nThat seems like the least surprising thing, and most in line with other operators. (c.f. sample, which only completes when both signals have completed)\nWe should definitely add tests for this\u2014and probably for an interrupt on the signal as well.\n. I think we should get rid of the _, rename it to something like state, and accept that this is going to be a public initializer.\n. This could probably default to false instead of getting passed in.\n. nil, Optional, and SignalProducer should all be backtick-quoted here.\n. We should cache the value of userEnabled(value) and only call it when the value changes.\n. SignalProducer should be backtick-quoted.\n. I think we can remove this mention of ReactiveCocoa.. This appears to be a duplication of the more-complete example below.. This would need an error type until Swift 4 since we can't add conditional conformance when Error == NoError.. I think withLatest(_ samplee: Signal<U, NoError>) would be clearer.. This should be removed. We don't expose mixed operators like this. If someone wants to use a Signal with a SignalProducer, they need to convert the Signal to a SignalProducer.. This should also be removed.. Can this be implemented with sample(with:)?\nreturn samplee.sample(with: self).map { ($1, $0) }. Since it's generic over both sides, I think it makes sense to define it at the top level.. This is different from combineLatest since it only sends a new value when one of the signals changes. So it should have a different name.. SignalProducer isn't a class, which is why this isn't class bound.. I added a test for this in 1c339803382129ad53b5b9cfa0d74f1045629a0c.. The issue I'm nervous about is if I want to constrain the righthand side to be something else.\nswift\npublic func <~\n     <Target: BindingTargetProtocol>\n     (target: Target, source: FooSource) -> Disposable?\n     where Target.Value == FooSource.Value\n{\n    \u2026 // This would call to another <~\n}\nBut maybe that'd need to filter through the overload anyway?. I prefer the solution as-is because I know exactly how it will behave.\nThe effect is the same. So why not use the solution that we understand and know will work?. Would alive/terminating/terminated make more sense here?. This looks like it could remain inside the init.. This looks like it could still use the state.swap(nil), in which case status could remain part of the init.. It doesn't look like this is used anywhere? Let's remove it and then remove the underscore from the version we are using.. Should we still keep this and swap as part of AtomicProtocol?. Do we need this check here with the other check right below?\n(If so, I think that'd be helpful to document in the code.). Maybe observers and retaining could move into .alive as associated values?. Why is this a struct with an UnsafeMutablePointer instead of a class with a deinit?. Can you detail how this is done?. Does Swift guarantee that the read will be consistent in this case?. Now it looks like it'd be clearer to make this let terminatingEvent: Event<Value, Error>? and go make to a SignalState?. A nil state would mean terminated, a non-nil terminating event would mean terminating, and everything else would be active.\nHaving to states does still seem confusing.\nOtherwise maybe we should aim for a straightforward fix here and handle optimizations in a subsequent PR.. s/Transit/Transition/. s/transit/transition/. Could we split SignalStateSnapshot into 2 different classes?\n```swift\nprivate enum SignalState {\n    case alive(AliveState)\n    case terminating(TerminatingState)\n    case terminated\n}\nprivate final class AliveState {\n    let observers: Bag.Observer>\n    let retaining: Signal?\n}\nprivate final class TerminatingState {\n    let observers: Bag.Observer>\n    let event: Event\n}\n```\nAFAICS the terminating state doesn't need retaining and the alive state definitely doesn't need event. This would simplify things a bit, I think.. This function is only used like this:\nswift\nif let snapshot = signal.shouldReallyTerminate() {\n    for observer in snapshot.observers {\n        observer.action(snapshot.associated)\n    }\n}\nThat suggests that the code to notify observers should move into this function.\nIt probably also makes more sense as a block in init since it's only used there.. Can you format the - returns: to match the existing ones?\n- returns: The stat snapshot associated\u2026. Yup. \ud83d\udc4d . Do we know that this holds true for Linux as well?. It's small, but can we put these right after the other attempt and attemptMap?. I don't think unilateral is the right word here. Unidirectional, maybe?\nThe - should should be replaced by \u2014 here and below.. > stream of value s. RAC uses US English, so this should be program.. stream of value is repeated in the body text too. \ud83d\ude48 . Why is the first event not delivered on scheduler?. The implementation in https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3345 seems a lot simpler. \ud83d\ude15 . This makes sense. But I think it deserves a comment in the source explaining what's going on here.. Would it make more sense to add something similar to startWithSignal?\npublic func observe(_ handler: (Value, Signal<Value, NoError>) -> ())\nThen there wouldn't be so many requirements?. I really like having a playground page in a PR like this. That really helps demonstrate the idea. \ud83d\udc4f \nBut I think it'd be better to create something that approximates a real-life example. So create a faux reset password example or something.. Any similarities to Action aside, I don't think this concept should have Action in the name.. It doesn't seem like bidirectionality should be required for this. But a few real life examples in the playground would probably demonstrate what you had in mind.. This abstraction seems to add complexity without much benefit.. Link to [the team](https://github.com/orgs/ReactiveCocoa/teams/reactiveswift), maybe? Otherwise we can create a special _abuse_ team or something.. Can you add a comment here explaining whyUnsafeMutablePointeris used and linking to the thread?. Why a_-prefixed protocol?. Why let values be set in this direction? Bidirectionality adds a LOT of complexity, and I can only think of 1 instance where I've ever wanted something  like this.\n. This is a little ambiguous. Should be \"from the first input producer _to send an event_\".. This could really just be calledflatMap. (The Swift stdlib has this.) But maybe that's undesirable from a type inference perspective?. Likewise, I don't think this is an accurate description.. It seems a little weird to default this totrue. It might be better to default tofalseand check forinnerSignalComplete || active == nilinshouldComplete?. I didn't realize you could do this. TIL!. What should the behavior be if the outer signal receives a signal, completes, but the inner signal hasn't sent an event?. What do you think about keeping thedefer`s?\nRemoving them seems to have a very minor effect on the speed but makes mistakes more likely.. Is this still public?. Can you add a comment that explains this?\nAny time we choose the non-obvious route to get a speed boost, we should document it.. There's no way to know. \ud83d\ude43 . I don't actually think this is safe. email here isn't guaranteed to be the same one that passed the check on the line before. I think you need to read the value and the value portion together.. What's this doing here?. Can you document this a bit more explicitly? (i.e. explain what it means for a property to be composed.). s/editor/property/. s/an/a/. This variable deserves a comment. It's not immediately obvious what it does from the name.. Maybe something like isSettingInnerValue would be a better name? Describe what's happening\u2014not the effect.. s/an/a/. inner doesn't exist here. It seems like we should maybe require this? That seems very weird.. s/an/a/. s/an/a/. inner doesn't exist here. s/an/a/. s/an/a/. inner doesn't exist here. These could use documentation. How does this behave differently than:\nreturn producer.flatMap(.latest) { model in SignalProducer(value: getter(model)) }\n?\nI don't see how lazyValue: makes any difference here. The returned producer will always be started immediately, so these should be equivalent.. This could probably be:\npublic init(_ block: @escaping () -> Value)\nYou can think of it as a value preserving type conversion.\nI'm not sure whether that'd cause problems in practice. I think it's unlikely to cause conflicts.. Can you test that the signal actually sends a completed event?. Can you test that the signal sends the error?. This would should be the same as this?\nreturn producer\n    .observe(on: scheduler)\n    .flatMap(.latest) { model in SignalProducer(value: getter(model) }. I don't think we'd ever remove the label from init(value: ). So I kinda like the idea of a label-less initializer. (We could also add a variant that uses a completion handler, which would be handy.). The events are delivered to the flatMap on scheduler.\nThey do behave differently though\u2026 because cancellation happens on a different scheduler. Your way is probably better.. Is replaying values an essential part of group(by:)? This is my primary hesitation. In general, we try to discourage the use of replaying (which is why buffer was removed).\n(You could just as easily send the Signal and not send values on the Signal until it's been sent\u2014giving observers a chance to observe the signal.)\nIf you feel that it is, I'd love to see a larger code sample that demonstrates why.. .init not needed here and above. I think returning Signals instead of SignalProducers communicates the semantics.\nBut I think seeing an actual example of this operator will make it easier to see whether that's a viable change.. Typically I've done this by doing the equivalent of throttle(0, on: UIScheduler()).. s/lazyLens/lazyMap/. This reads like documentation for map, so it could use some cleanup.\nOf note:\n\n\nthat sends a new value each time this property's value changes isn't true. The point of the operator is that it doesn't guarantee a 1-to-1 mapping of input to output.\n\n\nIt doesn't communicate what makes this lazy.\n\n\nIt looks like the other instances of lazyMap have better documentation, so you may just need to copy that here.. Can you name these arguments? I think for documentation purposes that'll be a lot clearer.. This is pretty interesting, but it seems like we should consider this in a separate PR. I don't see any relation or dependency between the two? (Other than these were both originally part of your lens concept.). Indentation here is a bit wonky. Maybe add an important block that points out that there's not a 1-to-1 mapping between inputs and outputs?. Maybe rename model to value?\nThis line is a little dense, so I'd also break it up onto multiple lines.. Should we move this into MutablePropertyProtocol in 2.0?. Do you have a use case in mind for this?\nI think this maybe shouldn't return an Optional. You could still check isFailure if you didn't want failed values. This would simplify the code that handles dependencies, e.g.. It took me 5-10 minutes to understand what was happening here. We should add a comment here (and below) explaining why s.value is being set.. This would probably be better as a guard. (Same below.). Is there a reason that this is outside the init? If so, can you add a comment explaining why?. Indentation is off for this block.. How would that differentiate from the existing non-@autoclosure version?\nYou wouldn't want to always have a closure\u2014that creates the same problem, just in reverse.. I think the unnamed parameter best fits with the other unnamed lossless-type-converting inits that we already have.\nI'd also really like to add this variant:\nswift\npublic init<Value, Error>(_ block: @escaping ((Result<Value, Error>) -> Void) -> Void). This is a little awkward IMO. Maybe just name it case coerced?. Is this a required part of this change? We should stay away from unsupported attributes if at all possible.. Does this still require a separate target if it's in Swift?. Is assigning to a Bool an atomic operation? This write could happen concurrently with the read above. I think it needs to at least be in its own Atomic.. Is this enough to guarantee that producerState remains initialized until after both the read and the write?. This could probably surround just the producerState.setStarted() below?. Typo of repeatable here. Can we make this link to source for the main page of the playground?. I think it'd be good to make this language a little less strong. Ideal is very subjective. Maybe something like how to use Model-View-ViewModel to separate bindings from logic?. I don't think these names are an improvement over the current names.\n\n\nstate seems less accurate than input. I wouldn't say that this property describes the state of the Action. It's the inputs that are used\u2014consumed in a reactive way.\n\n\nworkProducer is a bit misleading because it's not a producer itself\u2014it's a closure that returns a producer. So I think execute is a preferable name here as well.. Can you add a comment that explains that?. This was added to provide a more specific variant for type inference? If so, can you add a // comment that documents that?\n\n\nIs this inference covered by a test case?. I prefer the static func attempt name for that reason. It also lends itself to RACformatting.\nswift\nSignalProducer\n    .attempt {\n        \u2026\n    }\n    .flatMap(.concat) {\n        \u2026\n    }\nIs renaming this an essential part of the PR? If not, could we move it off the protocol here and discuss the renaming in a separate PR?. I don't really like the attach a closure lede. Maybe something like Observe value events from self with the given closure?. I think the immediately preceding value is clearer here. I'm not sure consecutive predecessor makes sense.. I think Apply a failable operation is clearer here.\nInvoke a throwable action sounds way too imperative.\nc.f. the description of map from Swift:\n\nReturns an array containing the results of mapping the given closure over the sequence's elements.. I don't think accumulate (typoed) is the best description. The return value is the accumulator, but I don't think accumulate describes the operation itself.\n\nC.f. the Swift reduce description:\n\nReturns the result of combining the elements of the sequence using the given closure. I'm \ud83d\udc4d with state.\nI can't defend workProducer in this regard. But execute doesn't seem right either, since it doesn't really execute but returns something to be executed. workFactory, producerFactory or workCustomizer are possible alternatives.\n\nTrue, but I think most things that return SignalProducers are named this way. Look at the methods in Carthage or any of its dependencies, for example.. At this point, it doesn't seem like there's any point in using a timestamp. This could just use a counter? Bag requires mutual exclusion for cross-thread use anyway.. Sure\u2026 but if we still used a UInt64, then this would have the same domain. Using a counter would start at an earlier value. It would also only increment by 1 for each insertion\u2014instead of skipping values in the case of a timestamp. So using a counter would be less likely to overflow.. We should make this a struct\u2014not just a typealias. A type alias won't prevent someone from passing a random UInt64 to remove(using:). Tokens shouldn't be publicly instantiable.. Maybe call this nextToken?. I don't love using the term initialized. How about flipping the meaning and naming it hasEmptySignal?. It's very minor, but in cases like this, I'd put the cached property immediately before the uncached version.\n```swift\nprivate let action: (ContiguousArray) -> Void\nprivate var _isInitialized: Bool\nprivate var isInitialized: Bool { \u2026 }\n``. Trailing closure syntax?. Would it be better to use anOptional`?\nswift\nprivate var values: ContiguousArray<Any?>. Maybe add a computed property for this to aid readability? Or add a mutating func that returns a ContiguousArray<Any>? of the values to send?. values.indices?. This conditional is repeated in complete below. I think it'd be good to make this into a computed property.. Can we do this as part of init instead?\nI think each make below could become an init that calls a top-level make with the signals that it wants to start.. This seems like it would benefit from a struct. It's a bit large as a type.. Yeah. \ud83d\ude1e But until the type system is powerful enough, I don't mind some internal type erasure.. Can you add some documentation to these?. Can you add some documentation for this?. Could these be structured after lift instead?. This reads a little funny. Maybe rename to haveAllSentInitial or hasAllInitialValues?. Maybe rename this to areAllCompleted so it reads nicely in English?. Would you mind putting these over multiple lines? I think that makes them more readable.. I don't think this ! is safe. This could have been disposed between the above check and here.. I think the previous guard structure is preferable to disposable.flatMap to reduce the nesting by a level.. We could leave this as non-optional by returning a disposable that does nothing. I'm not sure which would be better. Is there a particular reason you decided to return an optional?. I don't think we actually need this materialize alias. I think we can do Result(attempt: try action()).. I'd like to see this use the same approach as Atomic to prevent unsafe accesses\u2014hiding value and lock behind locking APIs.. I think this can go away of appropriate methods are added to PropertyBox.. Just make this:\nswift\nfunc modify<Result>(\n    _ action: (inout Value) throws -> Result,\n    didSet (() -> Void)? = nil\n) rethrows -> Result {\n?. Can't observer.action be in the action block? It still happens inside the lock either way.. I'm not sure this is valid.\nThis:\n\nThe pointer argument to body is valid only for the lifetime of the closure. Do not escape it from the closure for later use.\n\nMakes me think that the whole construct may not be atomic.. But I'm not sure this is something we should rely on. \ud83d\ude15 \nThis is the danger of OSS: can you depend on undocumented implementation details?. I think all of the 1.0 unavailables can be removed at this point.. Do we need to support two different backings?\nIt's only used in one spot and it could be emulated by holding a reference to the token in an ActionDisposable.. I don't love setting an untested (in the real world) policy for only older Apple OSes.\nBecause this would affect a small portion of devices, it's hard to have confidence that it works well. I'd rather see us take a performance hit on older OS versions and not have a separate code path that's hard to test.. Doesn't this mean taking some performance hit? The SignalProducer adds extra work on top of the Signal.. I don't think default is a great name for this. We should find a name that describes the behavior.. I'm not sure that opening it up to concurrency is a good idea. That adds quite a bit of complexity.\nMaybe we should limit it to exclusive strategies to start?. This could use documentation.. \ud83d\udc4d to the typealias. This is still waiting on an interrupted test, right?. I think we should use signal instead of shell here and in the related methods. I think that's clearer.. The condition (state.observer.isEmpty && shellDeinitialized) should move into tryTerminateSilently. It's the always the same logic. (In the other case, we know that shellDeinitialized is true, but it doesn't hurt to explicitly check it.). Can you clarify that this comment only starts the disposal?. Can you add a comment here clarifying that this completes the disposal by removing the last strong reference to the core?. I think this a bit confusing as written. I think we should go with a more straightforward version that's self explanatory:\nswift\nif sendLock == nil {\n  if !self.sendLock.try() {\n    return .none\n  }\n  defer { self.sendLock.unlock() }\n}. Can you add to after try in this method and the one below? tryToCommitTermination. Maybe add a comment here to highlight that it's the other +1?. Why is isEnabled false if availability is enabledExecuting?. Can these be derived from actionState instead of duplicating that information in separate properties?. This default shouldn't be needed?. Can you make this a struct instead of a typealias?. This is really modeling two independent boolean states. Can we separate these and add them to ActionState individually? I think that will simplify the code a bit as well.. Can we make this lazy change in a separate PR? I'm not sold on it, and it's not essential to this PR.. I don't care for this implementation. I find this \"multiple implementation via a backing enum\" approach to be difficult to reason about.\nIf we kept SimpleDisposable and ActionDisposable, but made them private and added inits that exposed the functionality publicly, then I think I'd be onboard.. Can this be self.isExecuting = actionState.map { $0.isExecuting }?. This comment is describing what this line does. Can you update it to describe why it needs to be associated?. This is only called once. Maybe take the code out of the function?\n```swift\nlet state = actionState.modify { state in\n    ...\n}\nguard let state = state else {\n...\n``. ThisdidSetseem pointless. The function is only called here, right afternotifiesExecutionStateis set tofalse\u2014so it will always do nothing. It seem like bothdidSet()andnotifiesExecutionState` can be removed?. \ud83e\udd26\ud83c\udffc\u200d\u2642\ufe0f. I think the language was clearer before. Specifically this bit:\n\nwhere each invocation of start() will create a new underlying operation.. I guess this needs a merge from master?. I think this would be clearer as a typealias.\n\nswift\ntypealias Builder = () -> (signal: Signal<Value, Error>, didCreate: () -> Void, interruptHandle: Disposable)\nOr maybe a struct instead of a tuple for the return value:\nswift\nstruct Instance {\n  var signal: Signal<Value, Error>\n  var didCreate: () -> Void\n  var interruptHandle: Disposable\n}\nlet builder: () -> Instance. Basically: this could be return SignalProducer<U, F> { ... }.. Nimble doesn't build with Swift 4, so this only builds for now. \ud83d\ude1e . What's this for?. Why an OptionSet instead of an enum?. I think it does:\n\nInstead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes.\n\n(https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async?language=objc)\nI think you'd need a separate, empty barrier block.. Was this test also occasionally failing?. What's this?. It doesn't sound like conditional conformance is guaranteed in a Swift 4 release: https://twitter.com/jckarter/status/872211469856722944. Thanks! \ud83d\ude05 . Why use ManagedBufferPointer instead of an UnsafeMutablePointer? This seems more complex.. It's the \"abuse\" of ManagedBufferPointer here that concerns me. I'd like to see us pursue the more standard approach first and only switch to a more complex, unintended approach when/if we have benchmarks that show that show a measurable difference.. This seems like a poor imitation of a spin/unfair lock. I'd prefer to see us use Atomic like in #453\u2014at least to reestablish correctness. Afterwards we could consider an optimization like this.. The above documentation needs to be updated to reflect that the lock must be held to read the state.. Would it mess up anything if we always sent interrupted on deinit? I'm wondering if that'd be a better option.. The promise is only at the Signal level though. That wouldn't be broken.. which ties a `Disposable` to a `Lifetime` might be clearer. We should make this a struct like we did for FlattenStrategy.. Not sure if this should be public, but the documentation is definitely wrong.. Can we make this a protocol instead of a class? I have an aversion to inheritance.. Can we change this rule? By default SwiftLint enforces no trailing comma. I think we should enforce the trailing comma. This tends to make diffs more readable and merges easier since adding a line doesn't alter the previously last item in the array.. Instead of disabling it, you can actually require the comma by adding this at the top level:\ntrailing_comma:\n  mandatory_comma: true\nWould you mind doing that instead? Sorry that wasn't clear before. \ud83d\ude05 . Please add a test that tests hitting the uptown limit.. This isn't a very accurate description of the test. It's testing the retrying, not testing the limitation.. This indentation is off. The ReactiveSwift style is to have methods like this be indented one stop.. This indentation doesn't match the ReactiveSwift style. It should be indented like so:\nswift\nreturn flatMapError { error in\n        \u2026\n    }\n    .retry(upTo: count). Any particular reason for choosing this representation?\nThe other possibility is to do something like this:\nswift\npublic enum Change {\n    case insert(Int)\n    case remove(Int)\n    case move(from: Int, to: Int, mutated: Bool)\n    case mutate(Int)\n}\nNot saying one is better than the other. But curious as to your rationale.. I would definitely want to see more tests for the actual diffing algorithm.. This could probably be a Changeset.init.\nMoving all of that to a separate file\u2014to let this file focus on the reactive portion\u2014would probably be beneficial as well.. I don't love this. \ud83d\ude48 \nHave you measure this optimization? I wouldn't think that this would take up a significant portion of the runtime.. Why not include that reference? With COW I wouldn't think it'd be a real performance concern.. I recognize that you want this to be generic so that you can add support for nested collections, but I think it'd be better to remove this type parameter for the time being. I think it's usually best to wait to add something until you actually need it.. Can we verify that the error was sent as well?. Can you add some documentation for this?. I think an enum backing would be preferable. \ud83d\udc4d . I really dislike the name Product here.  Could we come up with something more specific?. builder here needs to be updated. This breaks the contract of Disposable by not changing isDisposed when you call dispose. It may be fine in practice, but this makes me very wary.\nI think we'd be better off bringing back the implementation of SimpleDisposable and using that instead.. How about calling this Instance?. Could we put all the arguments on their own line? \ud83d\ude48 \nswift\nreturn .init(\n    signal: transform(left.signal),\n    observerDidSetup: {\n        ...\n    },\n    ...\n)\nIt's minor, but I think it has readability benefits. (Including outdenting the block body.). I don't love adding more to Observer. \ud83d\ude15 . It's small, but the other inits case self.init(<core instance>).\nCan we update this one or the others to make them consistent?. I think this should be makeInstance() (or whatever we call the struct).. We could probably just call this GeneratorCore. We could probably call this TransformerCore or FlatMapCore.. Why not bring back SimpleDisposable? This still strikes me as a little weird.. receipt should be instance here. This line is duplicated in the 2.0.1 notes. \ud83d\ude48 . This seems like it should be called _send.. If this is used to create a Signal or SignalProducer and it is subsequently interrupted, it doesn't look like that interruption will propagate through to the scheduler here. (Unlike the previous implementation.). Since there's only one signal, all the strategies are functionally equivalent. The only difference is the performance characteristics.. I strongly dislike using map like this. map shouldn't be used for side effects. This is also not very clear IMO.\nI think we're better off with if let dispose = disposable?.dispose { lifetime.observeEnded(dispose) }.. Thanks for the explanation. That helped a lot. \ud83d\udc4d . The general idea makes sense, but this API may need some refinement. If nothing else, inner should probably have no name externally. But I'm not totally convinced that these should be inits.. serialDisposable seems like it might be unnecessary? I don't see how it has any effect since the upstream doesn't need to be disposed when it has errored.. This probably shouldn't say 2.x?. Since this one was only deprecated, it should stay until the next major version and become unavailable.. That could make sense. We could include debounce at the same time. All 3 are conceptually similar, but have a different strategy. I think our grouping of operators has been very successful and the existing debounce/throttle divide is very confusing.\nThe tricky bit is coming up with good names for the strategies. queue or buffer could work for the bottlenecked case. But how do you succinctly describe the existing throttle and dequeue? I like describing them as \"time since last value was received by self\" and \"time since last value was sent by self\", but those aren't succinct enough.\nRegardless, I think the bottlenecked name isn't good enough. It doesn't really capture the behavior of the operator (but it makes sense if you already understand what the operator does). I think we have the strongest argument for inclusion/acceptance when it fits into an existing name like throttle, but we have to find something that works.. The best I can think of would be:\n\n.queued\n.fromEarliest\n.fromLatest. \"should not emit concatenated error to a failed producer\"?. Why should this be 2 and not 1?\n\nI think this could use a comment in the code explaining the expectation.. Maybe describe this as \"synchronous start with asynchronous interruption\"?. I think throttle makes the most sense as an operator name. And I dislike throttle and debounce as strategy names because I can never remember which is which.. I think queue or queued is a good name.\nskipPrevious could apply to either throttle or debounce, so I'm not wild about it.. I would invert this guard. I think it reads weirdly. The common case (unblocked termination) should be what we're guarding.. This init doesn't have a disposables parameter. The line also seems incomplete.. I think we should remove this function, inlining it into the init. It's no longer safe to call this outside of sink above, so leaving it here risks future violations of the signal contract.. I think we still ought to have a test for this (and the SignalProducer variant below). Would you mind adding one?. I think we should call this map(value:) for consistency. This would match SignalProducer(value:), but it would also match things like skip(value:), filter(value:), which wouldn't make sense with to:. We could also conceivably add mapError(value:), map(error:) and other things.. I don't think this result should be discardable.  It's important that we check the result most of the time.. I prefer if over guard here. I think it communicates the intent more clearly.. Same here: I think if is clearer than guard.. I think d is fine here; we don't need a longer name.. Nice. \ud83d\udc4d . Same here. I prefer the if version.. Thinking about it a bit more, I dislike guard here because state.tryDispose() is effectful. guard strongly suggests a test that's free of effects IMO. I still think it should stay as if here and below.. In the spirit of #605, maybe there should be an option to forward the values first?. I'm very hesitant to introduce complete new operator names. I think our grouping of operators by base name has been very successful and would like for us to continue it.\nWhile this is similar to debounce/throttle, I'm not sure it's really throttling them. I don't think a throttle is always regular.\nI think this could fit under collect though.\nswift\nfunc collect(every interval: DispatchTimeInterval, on scheduler: DataScheduler) -> Signal<[Value], Error> {\ncollect serves as the base name for operators that go from A to [A].\nThoughts @ReactiveCocoa/reactiveswift?. action should be called outside of modify. I think this logic (repeated in throttle) should be extracted into a method on ThrottleState.. Interruptions are generally immediate. I think introducing a delay here might be a problem. (I also think it's generally unexpected that interrupting would send another value. If you've canceled the work, then you're not interested in any other results.)\n@andersio?. The are should be removed.\n\nSignalProducer.merge, SignalProducer.concat, SignalProducer.prefix, SignalProducer.then, SignalProducer.flatMapError Signal.flatMapError, Signal.withLatest and Property.init(initial:then:) now accept SignalProducerConvertible conforming types (#610, #611, kudos to @1028). Why do we need 2 versions of all these operators?. This needs to be updated.. Yeah, values should only be forwarded in the case of .completed.. We've standardized on skip for values that aren't sent. We should use that here.. I think we should name the interval parameter. Maybe every:?. I think this could be better written like so:\n\nswift\nlet currentValues = values.swap([])\nif !currentValues.isEmpty {\n    action(.value(currentValues))\n}. This should use trailing closure syntax.. This schedule call makes me a little uneasy. It's difficult to reason about how this will interact with the other scheduling call. (e.g. it's possible that the above schedule could run in-between this values.swap and this scheduler.schedule).\nI think we should solve this by removing this schedule and sending the complete through the top schedule. This would be best done by adding a CollectEveryState struct and putting that inside an Atomic instead of a Atomic<[Value]>.\nSomething like this:\n```swift\nstate CollectEveryState {\n    var skipEmpty: Bool\n    var values: [Value] = []\n    var isCompleted: Bool\nvar hasValues: Bool {\n   return !values.isEmpty || !skipEmpty\n}\n\nfunc collect() -> [Value]? {\n    if !hasValues {\n        return nil\n    }\n    defer { values.removeAll() }\n    return values\n}\n\n}\n```\nThat should clean up the implementation a bit too, which is nice.. I think this should probably be discardWhenCompleted (no s).. This if isn't needed. We can unconditionally assign nil.. I don't see how the s changes that.\nThe s seems inconsistent the base operator name and other operators. Since it's debounce, not debounces, I think discardWhenCompleted is more appropriate.. Yes, I think so. Otherwise the timer would continue firing.. Could we also rename values to state since we have to add the dispose call below?. Oh, let's make this discardWhenCompleted (no s) since we're doing that in #605 as well.. This s needs to be removed too. \ud83d\ude48 . Can we keep this name as provider since it's a public label?. There should be an empty line before the it here.. Can you also test the other variant of this method?. That works. \ud83d\udc4d . This should say dispose(), not terminate().. This still doesn't make sense. \ud83d\ude15 Maybe it should be should be able to use\u2026?. I think this should be SignalProducer.init(_: Promise<Value, Error>) instead.. We could just use Result for this.. I'm not sure we'd get any benefit from this protocol.. > Change suggestions do not seem to be available in this repo\nWeird. I don't see a setting for it.. This needs to be updated.. `Output` here doesn't mean anything. Should this be `U` or just output?. Same here about `Output`. NoError doesn't seem correct here. The documentation is pretty light on details, but the userInfo can contain NSFileHandleError, \"An NSNumber object containing an integer representing the UNIX-type error which occurred\".. Is this guaranteed to be present if an error occurred?. Can we update the deployment target of just the test target and leave the framework's deployment target at 10.9?. ",
    "NachoSoto": ":shipit: The test is perfect, and the implementation seems reasonable!\n. I feel like we're better off leaving breaking changes like this for a version after the initial one for ReactiveSwift. Otherwise it's going to make he transition even more painful.\n. Ship it then! I'm also on board.\n. Yay!\n. Awesome, thank you!\n. :shipit: thanks @ashfurrow!\nIt still pains me that deployment targets and dependency versions and stuff have to be duplicated here, but oh well!\n. I vote for 1.0 too.\n. Hmm is this to bring Rex to ReactiveSwift? If so I'm a big :-1::-1::-1:\n. It's not about the history, it's about bringing (part of?) Rex. What's the reasoning behind this?\nWhat logic did you follow to decide what to include in this PR?\n. Makes sense\n. Yup \ud83d\udc4d\n. The only reason all these extensions were SignalProducers is because they were bridged from RACSignal, where we couldn't determine if they were hot.\nI'm not too sure how this would be implemented, however, because we do need to remove the observer from NSNotificationCenter. Or maybe we can just rely on it being weak now?\n. Closures DO have reference semantics.\n. \ud83c\udf89 \n. Huh, I thought I ran the tests locally, my bad. Yay tests!\n. Did you see the Linux failure?\nerror: The dependency graph could not be satisfied (https://github.com/Quick/Nimble)\n. I don't think this is a good idea. I've seen this misused more often than not in RX frameworks.\nThe main reason being that IMO the same type shouldn't be used to represent both ends of the pipe, as it encourages users to expose too wide of a surface instead of only the \"read only view\".\n. I'm pretty sure that was the reason for not making the pipe method return just one object, but two, because they almost always belong to different owners and they have different purposes.\n. Serial execution is importan though. I don't remember the exact context, but RAC 2 had many problems as a consequence of that.\n. This public API is lacking documentation. I'm still unclear about what this accomplishes exactly.\n. Awesome!. Any chance you can add a test case for the actual hug you fixed? \ud83d\ude4f. Awesome. Awesome work!!. \ud83d\udc4d\nOn Sat, Nov 26, 2016 at 08:19 Anders Ha notifications@github.com wrote:\n\nI don't think Scheduler suits here. TestScheduler is synchronous, while\nQueueScheduler is serialising.\nI've shortened the time though. The post-termination event test case now\nstalls only for 0.125 seconds, while the concurrent interruption test case\nnow takes only 1000 iterations with 5 second timeout on the counter.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/125#issuecomment-263071903,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAp2KVKKmRwN3lmNRxaIyRCb2mOZTtimks5rCFwQgaJpZM4K8wRh\n.\n-- \nIgnacio Soto\n. Wouldn't that be equivalent to\nswift\nnestedSignal\n  .take(1)\n  .flatten(.Merge) // or anything else. I'm pretty busy these days and honestly can't think about the specifics in detail, but I'm 100% happy to see this implementation detail go away and simplify the API :) especially since most of us (I at least) were never confident with its nuances.. I'm also a big opponent of this idea (happy to explain why).. Sorry if I'm late commenting on this, but does this really add value? Isn't this equivalent to:\nswift\nsignal\n  .take(first: 1)\n  .flatten(anyStrategy). OMG lol, that's embarrassing @mdiep \ud83d\ude13 . Ship it then :D. That sounds like a bug to me.. Oh wait, never mind, I read this wrong. skipRepeats is only applied to the signal that's concatenated to the initial value. So this is working as expected.. You probably need to use Error instead of NSError.. Actually I misread the documentation, but I'm still not 100% sure either debounce or throttle will behave this way, so I guess this is a question now, not a feature request :P. Yeah, it does look like if the source signal terminates before the given interval, no more cached values are emitted. This is not documented, and I'm not sure if it's desired behavior. Either way, it would be nice to have an operator that doesn't behave this way.\nI looked at Rx's versions and they don't seem to have this either.. > Guess we should put it back, alongside an option. A discardsWhenTerminated parameter with a default of true, perhaps?\n\nThat makes sense to me \ud83d\udc4d Or maybe discardValuesAfterTermination.. I agree, let's at least expose it. I would vote for .workItem as the default though, but I'm possibly missing downsides as well.. Huh maybe I was just seeing https://github.com/Carthage/Carthage/issues/1836? But in pretty sure I wasn't. The dependency didn't get updated until I added --no-use-binaries.. Or change .merge to .merge(maxConcurrency: UInt) with static let merge: FlattenStrategy = .Merge(UInt.max).. As long as it's not less performance, merging (no pun intended) the implementations would be amazing.. Do we have a way to test for regressions in performance/memory in .concat?. +1, semantics are explicit as a class.. Can you check if this compiles with optimizations? I've seen several compiler bugs regarding nested generics with -O.\nUnless we already run tests in release mode (which IMO we should).. \ud83d\udc4c\ud83c\udffb. Actually looks like https://github.com/kickstarter/Kickstarter-ReactiveExtensions is already there, which depends on ReactiveSwift, so I guess we're getting compiled transitively?. Oh good point, totally.. Awesome! I imagine having tests run will be important too, specially with optimizations.. Do you have a benchmark to show what this accomplishes?. That sounds like a good idea! Sorry I missed this when you created it.. \ud83d\udc4c. Can you add a test to cover this automatic inference?. Can you elaborate on the \u201cwithout a major version bump\u201d thing? Is that in case users are switching over it?. Cool then I\u2019m on board after those 2 comments . That's the only idea I have so far too, but I'm sure we'll come up with more as it evolves.\nI'm sure it won't replace the need for ReactiveSwift, but I think I combination of both might simplify code. Error handling on the other hand is still going to suck most likely (due to untyped errors).. There is a reason: we want users to be 100% aware that the values emitted by triggers will be ignored, and do so explicitly.\nThanks for the PR though!. I guess Apple added a check for macOS too, you\u2019re right.. We don't want to encourage the use of such operator, which is why it's not included. We recommend always explicitly handling errors as necessary.. Even when it does support it, we should keep compatibility for both types of frameworks.. Also, we purposely avoid overloads with different labels to avoid ambiguities when calling these with trailing closure syntax.. Does this fix a bug? If so it might be worth adding a test. Otherwise doesn't seem worth rewriting the operator from scratch\u2026. @andersio yup, done!. Tested this on beta 2, tests still passing but the regression is still not fixed.. I can't believe we need this workaround: https://github.com/ReactiveCocoa/ReactiveSwift/pull/590/commits/5bcb5e7e11062255abd9567da9b8c543bbeed70e \ud83e\udd26\u200d\u2642\ufe0f . Interesting. Any chance you can provide a small test case for that? I can take a look, and maybe add it to the test suite.. What happens if you do:\nlet optionalFetch2: SignalProducer<UIImage?, NoError>  = fetchImage.map { $0 as UIImage? }. Ooooh yup, totally, it's related to #601, bad overload resolution :( Can you open an issue for that?\nThanks!. I'm away for a month and won't be able to continue working on this, somebody else please pick it up from here? \ud83d\ude0a. But this is infinite recursion?. OMG I'm blind, I just noticed the 3 ===... I'm going to add a comment instead.. Okay, added a comment.... > I think our naming convention of skip* makes a lot of sense and makes things easier for beginners and experts alike.\nAgreed. As opposed to the Array counterparts, in the case of \"streams\", it's actually skipping values over time.. Thanks, see #590.\n\nI realize you could close this as being fixed in the next Xcode beta, but any help on this would be appreciated by people currently having to use Xcode 9.3 beta now.\n\nAgreed, we should offer a workaround. Help appreciated!. - void(): I support this. I don\u2019t like that name in particular, but I\u2019m sure we can find a more precise one. In my codebase I have this as var voidValues: Signal<(), E> {}, but I don\u2019t love that name either.\n- skipError: this has been suggested many times, but I\u2019m strongly against it. It encourages bad practices by simply ignoring errors. Instead, each user should implement this as they see fit. For example, in my codebase I have logAndIgnoreErrors(), which is only exposed for Error: ReportableError (my own type), and it sends non-fatal errors to Crashlytics. Ignoring them without any consequence is a bad practice IMO.\n- merge(with:): I have this same one in my codebase, so \ud83d\udc4d . > I've been wanting to add a func map(value: NewValue) -> Signal to map to constant values. Maybe that'd be enough for this? .map(value: ())\nOooh yeah, I like that a lot better, a more general and useful operator :) I'd overload map with it, or name it  replaceValues(_ newValue: NewValue), not sure what I prefer.. Yeah this is by design. In fact I think the problem is that Swift is providing a bogus diagnostic, as usual.. I'm slightly confused why Rx would have Observables that follow RAII, but you can also do this with the lazy SignalProducer constructor.. I think eager evaluation is precisely what we want. If somebody needs lazy evaluation of the value they can make that explicit by using the closure variant.. \ud83c\udf89 . @mishagray realized that this produced a regression. I wrote a test case that reproduces it:\n```swift\nlet (signal, observer) = Signal.pipe()\nlet mappedSignal = signal.map { $0 as Int? }\n// Cannot convert value of type 'Signal<(Int?) -> Int?, NoError>' to specified type 'Signal'\nlet expectedType: Signal = mappedSignal\n```\nI'm sending a PR to fix this.. I'm proposing renaming this replacingValues(to:) to avoid the bad type inference due to the overload.. But Swift doesn't know that :(. Oh wait, I see what you're saying! That seems like a Swift bug then.. \n. Thanks!. This seems like a Swift bug btw:\n\n~~I believe @mdiep is filing a Jira?~~\n@mdiep filed a Jira: https://bugs.swift.org/browse/SR-6989.. Agreed, let's leave this open for now.. Whatever we do, it's important that we don't release a RAS update though, unless we work around it. Based on the discussion on the Jira so far, I'd be surprised it even gets fixed in Swift 4.1.. Although, if this only happens with that particular type of closure ({ $0 as Type?}), we might want to ignore it, since it's \"workaroundable\" for clients by giving it an explicit type?. Sounds good. I'll update the PR to keep the \"negative\" test so we can detect when (if?) this is fixed, and at least keep the behaviour documented.. That's a neat idea! Any chance you can add a few tests for this?. +1. To @mdiep's comment.. > Executed 737 tests, with 1 failure (0 unexpected) in 13.258 (13.323) seconds\n\ud83e\udd14. Oh I missed this. I started the process: #702. I'm excited to make ReactiveSwift dependency-free :). Nice \ud83d\udc4d . Oh that\u2019s right. I don\u2019t think it\u2019s worth changing at this time then.. Is ?? nil needed here?\n. This can be completed: observer.sendCompleted.\n. Perfect\n. If it's a nested optional I can see why it would be needed, but I'd solve that by declaring the type instead I think.\n. :+1:\n. This can be a constant.\n. Wait, why not just use .seconds(Int(interval)) now? This conversion is legacy from pre-Swift 3, but shouldn't be needed anymore.\n. Thanks for adding a test!\n. Maybe just\nswift\nproducer\n  .start()\n  .dispose()\n. If the crash happened with > 9 seconds, why not use 10 here to make sure this catches a potential regression? :)\n. Cool\n. Oh I forgot the parameter is a TimeInterval. Okay, then I think the right fix, which is not backwards compatible, but definitely best long term, is to change the parameter to take a DispatchTimeInterval. It's actually a much better API because it self-documents the magnitude. With these old APIs taking Doubles it's never clear whether it's seconds or what.\n. We can keep the original method and deprecate it, and point users to the new one.\n. Sounds perfect \ud83d\udc4d let's not deprecate it in this PR then.\n. Can you keep the formatting like it was for readability?\n. Can you put this as a comment on the code?\n. I think these implementation details shouldn't be here. Maybe we can make an internal class IntAtomic: AtomicProtocol, so that this class works evenly regardless of the actual type being used?\n. This type is too general, and it also has no guarantees of having value semantics.\n. What's the reason behind adding this extra level of indirection?\n. This would be better as a derived property instead of a function.\n. This is falling into one of the points I wanted to fix with this approach: potential overflows.\n. Awesome. Can you add the deprecations for all these?\n. This is an implementation detail of the tests, not the actual tests. For that reason, could you move it to the bottom of the file?\n. Wow...\n. Maybe move this somewhere else?\n. There has to be a way to actually create one in Linux :/\n. > which would add exhaustively checking.\nAnd fail to compile if one adds a new case, which is a good thing\n. Can you use self.base here to be explicit please? It took me a while to figure out where this value was coming from, because it's not in the current context.\n. Ditto\n. No, but the capture was correct! We don't need to hold a reference to self, only to base.\nI meant this:\nswift\nreturn SignalProducer { [base = self.base, weak object] observer, disposable in\n. This docstring doesn't add anything that's not already in the method signature \ud83d\ude05\nI fail to see a possible use case for these, could you give an example?\n. > But of course these can be eliminated if notifications(forName:object:) would terminate the returned signal if object has deinitialized.\nThat is actually the case: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2747.\n. Are\n. Signal \n. :+1:\n. We need another test similar to this one to verify that the signal is not freed if there are other observers.\n. \"observers\" is plural.\nYou could also say \"no observer is attached\".\n. I'm confused, why is this line added here too? Aren't we sending events twice now?\n. The ordering was on purpose, can you move value up again?\n. Thanks!\n. \ud83d\udc4f\n. This is a private API.\n. Does this artificially add 5 seconds to the test? If so, \ud83d\udc4e that's too high of a price to pay.. I agree repeat is better.. flatMapError is far more descriptive. catch is a well known word but it doesn't carry the extra information that this does, which draws a parallel with flatMap.. These names are meant to match the Result counterparts.. Oh this is great . What's this for?. The format we normally use is separating type and value: var events: [Event<Int, NoError>] = [].. No need to shorten this name (especially when sema has other meanings), just call if semaphore?. This failure would be impossible to read. Can you separate the 2 checks with an if? That way it's possible to see what was checked and what the expectation was.. Ditto . This is already checked in the condition.. That could use a comment then to make sure a future reader doesn't accidentally removed it.. Okay never mind then!. Nice test. I'm still not a fan of any of this because users are left to the expense of the type inference to determine which initializer to use, rather than being able to explicitly pick one.\nIf Swift's type inference and diagnostics were great I might not mind, but considering how poor they are, it's my opinion that this will bring more problems than benefit (in fact I can't think of any benefit other than conciseness, which is not necessarily an advantage).. Can you separate these changes in another commit?. But flatMap was never a correct name \ud83d\ude05 I think that would only lead to more confusion + ambiguity.. Can you add tests to verify errors and completion?. Any reason not make this an SignalProducer(value: ) overload that uses @autoclosure instead?. Unless you just do signal.filterMap(Int.init) to avoid the closure.. No, you can have an @autoclosure @escaping parameter. I guess it would have to have a different parameter name, you're right, but I think I would make the intention more clear.. As much as I agree with @mdiep about the semantics, in my experience having buffering in this operator (specifically RxJava's Observable#groupBy) has been valuable .. \ud83d\udc4e this would hide potential problems that might not be visible in debug.. Yikes, did you file this?. Why have this?. Maybe add attempt as a label? Having so many unnamed initializers leads to ambiguity.. Failure. Yikes :( it makes me sad that we lose type information here.. Awesome. Wait why is this overload necessary?. Ditto. I'm very much \ud83d\udc4e for that. Since when has RAC promoted brainless thinking? :P A user calling this operator when they shouldn't is likely an error and shouldn't be silenced IMO.. Oooh that's right, because it's not possible to do negative conditions on extensions. This is a great idea then \ud83d\udc4d. Ugh. LOVE IT.  Not saying I agree with this change, but if we merge it, it doesn\u2019t make sense to keep the Equatable conformance.. This doesn\u2019t need to be a derived property, why not keep a constant?. These I'm okay removing since there's so much duplicating. This doesn't seem like the best way to implement this, but I guess you can't do while !self.buffer.isEmpty cause you need to lock?. Thanks for these \ud83d\udc4d . Can you add this to SignalProducer too?. Normally I wouldn't mind this, but Xcode does not make it easy to find this documentation, so I'd keep it duplicated.. Can you implement this using lift as well?. Can you implement this using lift?. We should duplicate it in those too IMO (at least until SourceKit & CMD+Click actually works consistently in Xcode). For now can you keep these how they were?. Thanks for making this more complex now \ud83d\udc4d . You can do #if !swift(>=4.1).. \ud83d\udc4d . This is annoying, but I guess we have no alternative.. Nit: I would avoid this indentation to simplify the diff.. Ditto indentation.. I think you need this docstring next to the type so that it gets exposed to clients (and duplicated).. Please remove this FIXME since it's already addressed.. I think this makes sense, but I would probably name this _BasePropertyProtocol to indicate that it's not a type that's meant to be used outside the codebase (just like Swift's stdlib does when they hit language limitations), especially considering that we'll be removing this workaround when we drop Swift 4.0.x support.. This should be Result.producer, right?. You should check that the value was sent, and that it completed.. Be consistent here: either self for all or none.. \ud83d\udc4d. I'd say this is a regression. I use this very often, so it's unfortunate it doesn't compile anymore... I wonder if adding static var empty to the protocol would still allow this?. Oh that's right!! I'll get rid of NoError.. ",
    "craigzour": "@NachoSoto Is there any plan to release a new ReactiveCocoa version with this fix ? \n. @mdiep Yeah I noticed that but I wanted to know if we were going to have a ReactiveCocoa version (which targets XCode8 and Swift2.3) with this fix.\n. @mdiep Alright ! Thank you :)\n. ",
    "andersio": "This should be easily migrated by API renaming.\n. What about shortening the rest of send* to complete and interrupt?\n. We have staged it in 4.2.x if you are talking about startWithNext for producers with non-NoError error types. It is a bug and I don't see the strong rationale to drag it longer.\nIf you are talking about the rename PR, those can be handled well by the IDE as renamed APIs.\n. Just mark it as deprecated instead of unavailable. The compiler will issue a warning instead in this case.\n. You may wrap it a public version of it as Property.\n. > Is there any room for discussion on this? This is one area of ReactiveSwift that really is unfortunate and ends up bloating code and requiring a large amount of boilerplate.\nSure. But I thought the need of boilerplate should have been reduced by the introduction of property composition, hmm?\n\nThis could be solved pretty easily using a struct type for Property rather than a class type, I did this previously in RAC but can no longer do it with ReactiveSwift because PropertyProtocol now forces classes.\n\nNothing is resolved IMO. The given Property, wrapping a MutableProperty, does not really have value semantics. What should happen when you reference it by copying, while the encoded type is telling \"I am a value type\"?\nEdit: Of course alternatively, we may do CoW, so that each uniquely referenced copy has its own signal. But the problem is that CoW does not have a concept of ownership. So when a supposed owner of the property writes to a non-uniquely-referenced property that it supposedly own, it creates another copy instead, abandoning all its observers in the previous copy.\nEdit 2: All I can say is, while being able to model them using access control modifiers is great, we do not have the right primitives in the language to make it reliable (yet), while satisfying all the reasonable constraints that should be followed.\nEdit 3: Not sure if you have already known, but you may use lazy to define the public variant of a mutable property of yours.\nprivate(set) lazy var name: Property<String> = Property(self._name)\nprivate let _name = MutableProperty<String>(\"\")\n@NachoSoto might have a few words.\n\n\nOnly classes can conform to this protocol, because having a signal for changes over time implies the origin must have a unique identity.\n\nTo me this is enforcing an ideological barrier, there's an initialiser that takes a signal and thus you've already created API that breaks this theory that the source is unique.\n\nA property observing a signal or a producer is still unique, because the (produced) signal and the observation made to it is unique. It is not that it never has identity too, just that it was hidden in RAC 4.0, and it wasn't a huge problem since it is read-only after all.. Try to make ActionProtocol class bound, and see if your convenience initializer works?\n. Concrete same-type requirement would land in 3.1 though. If these can be converted without breaking the source, IMO it is okay to tolerate an exposed private API for a while, just like how stdlib does with all the underscores.\n. @sharplet Sure.. It would need to be retained even without this PR due to #117, unless we use Property(capturing:).. If you mean the history, @mdiep seems leaning to preserve the history when I last asked, so I worked it out. The option to squash and merge is still here, anyway.\nIf you mean merging the complete Rex into ReactiveSwift, it is definitely not. This PR has already thrown away irrelevant parts, like how @mdiep handled the repo split. The sources have been sorted before merging in.\n. The separation is solely based on the dependencies or its nature (Cocoa or ObjC, etc), as I thought it was about merging in everything from Rex. Perhaps I should focus on bringing the bindings and Cocoa extensions instead, and leave the operators alone.\n. There are quite a few bits in Rex that is not Cocoa specific, and is extending the core ReactiveSwift.\n. @mdiep It hasn't been adopted in that PR yet.\nLike how @sharplet said, this is primarily for wrapping a majority of properties in UIKit (WatchKit? AppKit?) components, which were said not to be KVO compliant. Since we can't safely make them emit changes, this means they should not be a Property at all.\nOn the other hand, it can also be used to wrap method calls like dismissAnimated, which should be write-only but not in the case of Rex for RAC 4.\n. @sharplet As far as I am aware, we need only two classes of properties for UIKit bindings:\n1. write-only for non-observable properties or method calls, e.g. UILabel.text, UIViewController.dismissAnimated, etc; and\n2. read-write, e.g. UITextField.text, UISwitch.on, etc.\nThe rest would be Signals, e.g. UIView.viewDidAppear(_:) or Reusable.prepareForReuse, which never have the concept of a current value.\nBindingTarget in this PR specifically targets the case 1, while case 2 (i.e. those complex cases you may have in your mind) would require a similar construct conforming MutablePropertyProtocol.\n. Yeah, but a potential issue is that a straightforward <~ towards an action would mean ignoring ActionError.disabled. We also have no conditional conformances which allows only Action where Error == NoError to be a binding target.\nI would still prefer BindingTarget for these cases, as they meant to have no errors, no feedbacks or output and generally an immediate effect.\n. @mdiep It matters if the action is asynchronous. But for the case of dismissAnimated specifically, it does not matter due to the main queue requirement.\n. Well, dismissAnimated is just a case inherited from the Rex codebase. If it can't be justified, it can always be removed.\nAs I might have reiterated, the primary intention of a \"write-only\" construct is to model properties like UILabel.text or UIView.isHidden which can never emit changes at all per the UIKit contract. In practice, we generally have no interests in observing, but only updating them to instruct the UI components to draw whatever we want.\nPerhaps you have confused it with UIControl subclasses or UITextView, eh? For observable properties of these \"interactive UI components\", I assume the \"feedback loop issues\" can be solved by stopping hijacking MutableProperty and giving them a real tailored implementation. But these are definitely not in the scope of this PR.\nP.S. As a reminder, binding operators are now hosted in BindingTarget, which just requires the target to be able to consume a value from a signal.\n. BindingTarget in action:\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/compare/rex...rex-landing?expand=1\n. The observer can be removed in the generator disposable of the signal, which would be disposed of when the signal has no observers and is not retained.\n. Implemented in #64.\n. Action is stateful with its serialisation of execution, which means it cannot pass through a supplied Lifetime like the proposed BindingTarget or the proposed changes to DynamicProperty.\nSo for Cocoa extensions, it has to be retained & unqiued like the current use of MutableProperty in Rex.\nFor example:\n```\nextension UIViewController {\n    public var rac_dismiss: Action {\n        return associateOnce(&dismissKey) {\n            return Action(enabledIf: ...) { ... }\n        }\n    }\n}\n/// The binding would be teared down once rac_dismiss deinitializes.\nvc.rac_dismiss <~ producer\n```\nTests are WIP.\n. It is also possible to make Action be able to wrap an arbitrary Lifetime. Say rac_dismissAnimated: Action<...> can wrap the view controller's lifetime, so that bindings towards the action can still be teared down even if somehow the action is being retained.\n. About the ability to \"pass through\" an arbitrary lifetime, there are two possible design choices:\n1. Allow Action to be a throwaway. (CURRENT IMPL)\nThis overrides <~, and establishes a binding with no references to self but only the internal states of an action. Therefore, bindings are compile-time safe. For example, even if an API consumer somehow forgets to retain an Action, the bindings would always work regardless.\nOn the other hand, it might \"encourage\" to use Action as a throwaway, but well... we could do this today too.\n2. Bindings are valid only if Action is explicitly retained as long as the lifetime.\nThis uses the default impl. of <~. Therefore, bindings are NOT compile-time safe, since the Action is allowed to deinitialize ahead of the end of lifetime due to various reasons.\nBut it (wishfully) forces users to consider the need of uniquing.\n\nBindingTarget for method calls as a comparison:\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/pull/3210/files/15d37dd66dcd61db20f1f5a9d85d6aeb39c977e8#diff-fca460a6f442d46d6932528639e341bbR53\n. Yeah, either way they should be uniqued by the owner by convention. It is just a matter of a prove of static correctness & the expectation of the binding semantics. \nActions may optionally wrap a lifetime, so that the destruction of bindings towards them when using in an extension would not be unintentionally disturbed by accidental retainments. (like the reason why Lifetime.Token was born.)\nIf Action wraps a lifetime that outlives it, I would expect the bindings towards it to be aligned with the wrapped lifetime, despite the fact that in practice Action would be explicitly retained by the owner of the wrapped lifetime. This is what the current implementation with its custom <~ does.\nOwner             ------------|\nAction            --|\nAction (internal) ------------|\nBinding           ------------|\nIf we remove the custom <~ though, while again in practice it does not matter, a boundary case of active bindings towards a gone consumer is possible on paper.\n```\nOwner             ------------|\nAction            --|\nAction (internal) --|\nBinding           ------------|\n                 ^^^^^^^^^^\n      the window of failed expectation\n\n```\nSo the real question is - even though it doesn't matter in practice - if we should reopen the hole that was closed for static correctness. A pretty silly question with an obvious answer of NO, I supposed.\n(TL;DR: a justification of the custom <~ and the producerFactory thingy.)\n. Yeah, I guess we can leave dismissAnimated as is for now - it wouldn't be a source breaking change even if we decide to swap in an Action later.\n. I am not sure if what you guys would prefer:\n1. Easy conformance: just consume(_:). But for those overriding <~(Self, Signal), consume(_:) is useless but still needs to be implemented. (Currently in master)\n2. Forcing all conforming types to implement their own <~(Self, Signal). (This PR)\n. The latest commit restores the use of concrete types of signals and producers in the BindingTargetProtocol extensions and requirements, since the protocols of these are just used for constraining the extensions. They can be removed once concrete same-type requirements are allowed in Swift (ref: the Completing Generic manifesto\nP.S. Bug filed: https://bugs.swift.org/browse/SR-2785. Until this is resolved, BindingTarget cannot name its type parameter as Value.\n. @mdiep The default implementation of <~ holds a weak reference to self, and calls consume for every new value. This is probably the only use of consume.\nIn the case of DynamicProperty of https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3162, The goal is to make DynamicProperty \"throw-away\" proxy. The strong reference to DynamicProperty by the underlying object is removed, while having the property passed through the lifetime of its underlying object.\nIn other words, self the DynamicProperty could deinitialise before the binding ends, thus stopping the values from propagating. Therefore, DynamicProperty overrides <~ and establishes bindings that acts directly on the object via KVC, bypassing self.consume(_:) entirely (which may not be available at all time as said).\nThis is the reason why I consider consume useless shall any overriding of <~ happens.\nIn #38, it is useful. But we could also allow Action to operate like a BindingTarget. That means it take an arbitrary Lifetime, and is allowed to deinitialize before its bindings are gone.\nIn this case, it may need a treatment like the DynamicProperty PR, since the taken lifetime may outlive the Action itself. That's said this characteristic might never be exploited in practice, since Action is stateful with all of its event signals.\nEDIT: #38 has been updated to implement the idea above, with a test case to show it in action.\n. The \"throw-away\" semantic is used by BindingTarget (the class) in the sense that the stateless binding target needn't be retained & uniqued.\n. SignalProducer?\n. If you don't mind, would you please provide a more concrete context or examples of the obstacles you are facing? Otherwise, it would be hard to understand what you are looking for.\nYour original question on RxSwift.deferred does already have an answer: it works in a similar semantic as SignalProducer as a type. It defers the creation of the signal until it is started, and creates a signal for each start attempts, thus being called \"producer\".\nhttp://reactivex.io/documentation/operators/defer.html\n. Oops. I used to think the queue length is shared across all instances of UIScheduler. It turns out to be not.\n. Hmm, my second thought strikes me that the reactivity is a bad choice (the intensity of it being reactive, which is irrelevant here). Better keep it as Reactive.\n. A started SignalProducer is allowed to be interrupted in the observer it is started with. Since we serialise events using sendLock, such use would deadlock unless it is treated specially (and it is).\n. A code snippet to illustrate this if you are interested.\n```\nlet (signal, observer) = Signal.pipe()\nvar disposable: Disposable?\ndisposable = SignalProducer(signal: signal)\n    .startWithValues { _ in\n        print(disposable)\n        disposable?.dispose()\n    }\nobserver.send(value: 1)\n```\nThe value event is pushed to the produced signal, causing a disposal of the producer. Since by default everything is synchronous, if we do not treat interrupt specially, we would stuck at attempting to lock sendLock again within the critical section of sendLock (the value event).\n. Oh, yeah. Thank you for catching this.\n. Second thought:\nWhile closures themselves do not have a concept of identity in Swift, every subscription to the Signal is unique in the context of Signal, even if the underlying action is the same. This should be enough to justify it being a class.\n. @sharplet I mean the reverse of this. initial can be simply .resumed. Starting shouldThrottle.producer would always give the current value of the property synchronously, so there is no need to grab it twice.\n. :shipit:. The event was intentionally (re)named failed as being one of the terminating event. Though I agree we should take a second look at the consistency.\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/pull/2505\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/pull/2360\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/pull/2349\n. @liscio I just roll this out to gather initial opinions.\nFor composition, I am not aware of any within the code base. For the disposable & the completion action attachment though, it could trim down some boilerplates. e.g.\ndisposable += object.reactive.lifetime.ended.observeCompleted(disposable.dispose)\nThe lifetime ended signal is known to emit only a completed event. So IMO it is appropriate to give a concise and safe-ish shorthand, in the sense that all other kinds of events are meaningless w.r.t. ended. These can even be exposed on NSObject.reactive.\n```\ndisposable += object.reactive.observeEnded(disposable.dispose)\n// Overload that takes a Disposable.\ndisposable += object.reactive.observeEnded(disposable)\n``\n. How isskip(until:)that takes a condition different fromskip(while:)?\n. @NachoSoto True. I almost forgot thatBindingTargetcould be asynchronous, which would break this completely. Perhaps I should see if it can be done by extendingBindingTargetinstead.\n. The flatten operator should be applied before the retrieval, since values are sent in the start handler.\n.DynamicProperty` belongs to ReactiveCocoa, since it is Cocoa specific.\nTo observe KVO changes, ReactiveCocoa now provides a plain and simple NSObject.reactive.values(forKeyPath:), in addition to DynamicProperty. As for bindings, ReactiveCocoa now includes a comprehensive set of reactive extensions to AppKit and UIKit components, accessible via .reactive.\nPlease check https://github.com/ReactiveCocoa/ReactiveCocoa/ for more information.\n. DynamicProperty is parameterized in 5.0. Specialize it with the expected type.\nAlternatively, use the new reactive extensions.\n```\nDynamicProperty(object: nameLabel, keyPath: \"text\") <~ viewModel.name.producer\nnameLabel.reactive.text <~ viewModel.name.producer\n``\n. IsValueof yourtitlenon-optional? You need to deal with the optionality oftextValues. You can dooptional <~ (optional | non-optional), but nevernon-optional <~ optional`.\nP.S. It would be great to have Cocoa related questions in ReactiveCocoa instead. ;)\n. @_exported is a stdlib implementation detail so far, and was said to break code completion. Moreover, the largest consumer of RAS so far is RAC, which can re-export via headers. Perhaps we should limit it to RAC first, until Swift has an official reexporting mechanics?\n. We may explore the possibility of doing this in RAC's module map though.\n. Edit: Here is the draft of the readme for ReactiveSwift 1.0.0 with the updated example. Hope it helps.\n\nThe readme in ReactiveSwift hasn't been updated yet.\nWe offer Cocoa extensions separately in ReactiveCocoa that are built on top of ReactiveSwift. If you include ReactiveCocoa with the tag 5.0.0-alpha.3, you can do this instead:\ntextField.reactive.textValues\ntextField.reactive.continuousTextValues\nSee ReactiveCocoa for more information.\n. Thanks for catching these. \ud83d\ude38 \n. @mdiep Comments were addressed. \ud83d\ude38 \n. It seems you are having an infinite feedback loop. undoCurrentAction is being called when undoEnabled changes, while undoEnabled is bound to accept values from action.undoable, which is being modified in undoCurrentAction.\n. Is it limited to a specific strategy? That's said It shouldn't happen though... the inner producer is supposed to be interrupted by the outer's interruption.\n. @NachoSoto It seems RACScheduler had once allowed concurrent execution, but no longer did. That's said we can still accomplish a similar semantic by creating an internal serial queue that targets any arbitrary queue supplied.\n. Tried to prototype it and it wasn't quite ideal. The creation and the retrieval of the RAC internal serial queue need extra synchronisation that adds overhead on every scheduling attempt.\n. signal.observe(on: ConcurrentScheduler()) would result in a Signal which delivers values in indeterministic order. But it would be an intentional use of concurrent queues, and other than this I was not aware of any context in ReactiveSwift which might oppose such use.. Disposing the cancel disposable of a produced signal is guaranteed to have interrupted emitted, should the signal not have been terminated.\nIn other words, adding the observer disposable to the outer disposable is redundant - there is no point to detach from a known-to-be terminated signal.\nMoreover, the iteration order is an implementation detail of Bag that should not be depended on unless absolutely necessary, as Bag by contract is an unordered collection.\n. @ikesyo Would you mind to have a look at why Linux PM test fails? It says toEventually is missing, but it seems the package config of Nimble is fine.\n. ~~Linux test error would be fixed by #81.~~\n. @ikesyo I found that 5.0.0 wrapped the async matchers in something like #if _runtime(objc), which seems to be the cause. Had been removed in 5.1.1 though.\n. Let's say you have a source producer. One way I can think of is:\nSignalProducer(value: source)\n    .delay(1.0, on: UIScheduler())\n    .times(Int.max)\n    .flatten(.latest)\n    .replayLazily(upTo: 1)\n. @mfclarke Hmm, after a second thought, the replayLazily is not in the right place, causing repeated work instead of the intended caching behavior. See the updated snippet. Sorry about the mistake.\nNote that it works fine only if one value is cached.\n. Yeah, it does not invalidate the cached value upon expiry, and have subscriptions after the expiry to wait for the new value. It just starts a request upon expiry so that eventually the cached value is updated.\nMaybe it is worth to have something like replayLazily(upTo:timeout:).\n. Not aiming for 1.0 though. But yeah, it isn't great.\n. This makes Actions operate on immutable snapshots of the input, and aligns better with the spirits of FP.\nThe downside is, as you might have implied, that it is less ideal as a bridge to the imperative world.\n\nEdit:\nMoreover, this might limit the applicability of Action, I'd say. Say if we have an action that is expected to be one-to-one in input and output, are we supposed to guarantee the order of apply and the input source among multiple clients?\ne.g.\n```\n// Thread 1\ncoordinator.nextOpenToken.value = tokenA\ncoordinator.open.apply().startWithFailed { error in\n    // prompt user about the error.\n}\n// Thread 2\ncoordinator.nextOpenToken.value = tokenB\ncoordinator.open.apply() .startWithFailed { error in\n    // prompt user about the error.\n}\n``\n. ~~One question though - wouldapplycapture the input at its call time, or wouldapply` return a producer that operates on the current value when it starts?~~\n~~In the later case, apply might not necessary return a producer, but start the execution immediately, since we no longer need to inject the input as what apply meant to do.~~\n(It seems to be starting immediately as apply was said to be bindable to trigger signals)\n\nI don't know how to describe it precisely. Just trying my best.\nWhat's eliminated are those having multiple input sources competing for execution.\nThe entire bloc of a form UI can be treated as the sole and only input source of the view model. So Action in the proposal for view models in such cases is perfectly fine.\nBut for the example I put above*, there are multiple concurrent clients that want to execute the action with the value they proposed. With this proposal, there is no definitive way to:\n1. ensure atomicity of input-then-execution, as clients could overwrite each other's input; and\n2. differentiate their results from each other, via the producer returned by the old apply.\nThe proposal axes these semantics, in order to eliminate the race condition between the execution closure and the enabling state. But the said race condition is probably relevant to just UI programming, as I feel the use of it in the model layer (or anything outside the VM-View bindings) would most likely be a plain stored boolean.\nNonetheless, the proposed API does feel better for UI programming IMO. There is no better alternative either, assuming thread containment is always off the table.\n\n* That is an action, hosted in the app coordinator, to handle opening of a new document (window). That's said I could instead turn it back being imperative, and move the action (which now calls the imperative version when executed) to the view model to fit this new semantic of Action.\n. @mdiep He wants to delay the producer starting side effect. delay postpones only the sending of value and completed. Though, as shown in the link to Rex, it is just a shorthand of .prefix(SignalProducer.empty.delay(1.0, on: UIScheduler())).\n. Thanks for catching these. \ud83d\ude38 \n. If you obtain a reference to the produced signal, it does turn nil after completion.\nThis is caused by a caveat of Swift's ref-counting implementation: while the object is deinitialized after its last strong reference is ceased, the object would not be freed until all its weak references have been touched.\nIf you do not retain the cancel disposable, which indirectly holds a weak reference to the signal, Instruments would no longer catch this leak.\n\nhttps://github.com/apple/swift/blob/master/docs/weak.rst#implementation\n(Despite not being updated post-1.0, Swift's ref counting still works this way)\nHowever, it does have a very important downside: since the system cannot clear all the references, it is impossible to actually deallocate an object that is still weakly-referenced (although it can be finalized). Instead, the system must wait for all the weak references to at least be accessed. We call this \"husk leaking\".\n. Instruments caught a leak. But the signal is freed after accessing the weak signal property (which gives you a nil), or when self deinitializes.\n\nweak var signal: Signal<(), NoError>?\n    @IBAction func buttonTouchedUpInside(_ sender: Any) {\n       SignalProducer<(), NoError>.empty.startWithSignal { signal, _ \n           self.signal = signal\n       }\n    }\nNo leak was caught.\n@IBAction func buttonTouchedUpInside(_ sender: Any) {\n       SignalProducer<(), NoError>.empty.startWithCompleted {}\n    }\nInstruments caught a leak, but the signal should be freed after the disposable is thrown away.\nvar disposable: Disposable?\n    @IBAction func buttonTouchedUpInside(_ sender: Any) {\n       disposable = SignalProducer<(), NoError>.empty.startWithCompleted {}\n    }\n. It turns a method reference into a weakly reference one, as simple as that. Say you might wanna do observeValues(self.update(_:_:)) but with self being weakly captured. In this case, you have to fallback to call it in full signature instead of partial application.\nWith weakify, you can weakify the method reference by weakify(self, { $0.update }) before partially applying it.\nNot something that is life and death. Just a FP-ish sugar that improves the substitution of rac_liftSelector in Swift.\nobjc\n[self rac_liftSelector:@selector(update:and:) withSignals:signal1, signal2, nil];\nis more or less\nswift\nSignal.combineLatest([signal1, signal2])\n    .take(during: reactive.lifetime)\n    .observeValues(self.update)\nexcept for the fact that the subscription made by rac_liftSelector does not strongly reference self. The Swift one does as the reference self.update strongly captures self, and this renders the take(during:) useless & possibly causes reference cycles.\n. Perhaps a direct counterpart to rac_liftSelector is a better take in expressivity, hmm.\n@NachoSoto \n. That is just one tidbit of the implementation, if you mean SignalState retaining the Signal. It would still be released when it gets a termination event.\n. We swap out, dispose of the generator disposable and throw away the SignalState when a termination event is received.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Signal.swift#L80\n. Yes, unless you detach the observer.\nThis actually falls into the caveat of this design: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2959#issuecomment-236131149.\n. In general, Signals should be terminated.\nEven in the case where they don't, they are usually a derived \"view\" from something that's really permanent, and can be disposed of when no observers remain, e.g. NotificationCenter.default and a signal of Notification derived from it.\n. I won't comment on any other implementations. But I'd suggest you modelling the expected behavior in different circumstances as test cases. That would definitely help the iterative process, and it was how ReactiveSwift ended up with the current implementation.\n. An issue that looked for the (almost, time-based though) same thing: https://github.com/ReactiveCocoa/ReactiveSwift/issues/83\n. It seems the prominent need here is a mean to \"fail gracefully\" by invalidating the cached values and restarting the producer. Composing withretry(upTo:) can do the later but not the former.\nIt is like how #83 asked for a producer that invalidates the cached image upon a timeout event, and restarts the wrapped producer.\nI'd say we may introduce a specialized replayLazily overload for something like Error == ReplayCacheInvalidation. #83 would be made possible by using timeout, and for this issue a mapError or flatMapError to ReplayCacheInvalidation.\n. As I might have mentioned, a separated operator might not be necessary. Since for both your case and #83 the requirement is ~~replaying~~ invalidation & restarting on failure, we may provide a overload that acts differently with a specific instance of error.\n```swift\n// current behaviour, and the default value\nproducer.replayLazily(upTo: Int.max)\n// behaviour described in this issue\nproducer\n    .mapError { _ in ReplayCacheInvalidation() }\n    .replayLazily(upTo: Int.max)\n// behaviour described in #83\n// (The producer is not of NoError error type.)\nproducer\n    .mapError { _ in ReplayCacheInvalidation() }\n    .timeout(10.0, raising: ReplayCacheInvalidation(), on: UIScheduler())\n    .replayLazily(upTo: Int.max)\n```\nFor this overload, upon receiving failure, it purges the cached values - so that new observers do not see the old values - and restarts the producer.\nEdit: Expanded a bit on the code snippet for #83.. swift\nCocoaAction(action) { _ in (textFieldUserName.text, textFieldPassword.text) }\nwould do.. Action is like a serial queue of a preassigned, fixed work, defined by the execute closure in its initializer.\nYou call apply to make a unit of work that is customized for the input to apply. Then you may start the unit of work (the returned producer from apply) and get notified of anything about it.\nYou should return a producer that does work with regard to the input. Note that the work can be asynchronous.\n// SignalProducer<Output, Error>\n    return SignalProducer<Bool, NoError> { observer, disposable in\n        observer.send(value: authManager.isValid(username, password))\n        observer.sendCompleted()\n    }. Yeah.. Fixed in https://github.com/ReactiveCocoa/ReactiveSwift/commit/b3361c2bdad52c6f9488de5879cde5a0545e4bd6. Thank you for having it caught.\n\ud83d\ude38 \n. It seems natural to host them in ReactiveSwift. Perhaps we could turn them into links in ReactiveCocoa, hmm?\n. You can map the value to Any?. Custom generic types in Swift are invariant, so Signal<String, NoError> is not a subtype of Signal<Any?, NoError>.\nBut may I ask what you are trying to accomplish? You can have a composed signal Signal<(Any?, String> of the two using combineLatest(with:), which is strong-typed.. If you do s1.combineLatest(with: s2), or Signal.combineLatest(s1, s2), it gives you a signal that emits tuples, i.e. Signal<(String, Any?), NoError>.. > Formal question: Is there a way to make the return signature match w/e Signal.combineLatest() returns?\nAs said, Signal<U, NoError> is not a subtype of Signal<Any?, NoError>. You can map it as Any? though, but when you retrieve it you need the full type signature.\n\nMy initial solution was to return an array of Signals which would then be used as Signal.combineLatest(array) elsewhere, but the strong typing is preventing that.\n\nIf you have such tremendous amount of state with fields that are distinct, you can always consider packing them in a struct and take advantage of Swift's partial application.\n```swift\n// Struct\nstruct FormState {\n    let name: String?\n    let age: String?\n    let occupation: String?\n    let city: String?\n// Implicit internal memberwise initializer.\n\n}\n// This gives a Signal<(String?, String?, String?, String?), NoError>.\nSignal.combineLatest(nameField.reactive.continuousTextValues,\n                     ageField.reactive.continuousTextValues,\n                     occupationField.reactive.continuousTextValues,\n                     cityField.reactive.continuousTextValues)\n    .map(FormState.init)\n// If you prefer named tuple:\ntypealias FormState = (a: String?, b: String?, c: String?, d: String?)\n[...].map { $0 as FormState }\n. Swift's generic system is still growing. Generic covariance is limited to only the standard library types at this moment.. If we prefer the natural order, adding `_: Void = ()` as the last parameter would prevent the use of trailing closure.. I don't feel it is frequently used enough to justify a sea of shorthands like how `start` or `observe` does. So leaving it as it was in 4.x seems fine.. Added in https://github.com/ReactiveCocoa/ReactiveSwift/pull/106/commits/f6266580970e68837a40c342d09e5c59dc777ff1. Though you might have already seen [a bunch of test cases](https://github.com/ReactiveCocoa/ReactiveSwift/pull/106/files) that failed and needed a change because of the fix.. RAC 4.0: The signal is alive until a termination event or a user interruption.\nRAS 1.0: The signal deinitializes upon exiting the closure scope.swift\nproducer.startWithSignal { _ in }\n```\nmaster: The produced signal deinitializes, but the associated composite disposable is left untouched. So d is not disposed upon exiting the closure scope, despite disposed being true.\n lift-fix:   The produced signal is asked to dispose of also the composite disposable. So d is disposed upon exiting the closure scope.\nswift\nlet d = SimpleDisposable()\nvar disposed = false\nSignalProducer { _, pd in pd += d }\n    .on(disposed: { disposed = true })\n    .startWithSignal { _ in }\nSignal is retained. Nothing has changed.\nswift\nvar signal: Signal!\nproducer.startWithSignal { signal = $0 } \nSignal has one or more active observers. Nothing has changed.\nswift\nproducer.startWithSignal { $0.observe { _ in } }. DisposablePerfTests.swift\nA short synthetic test.\n| 1000000 iterations of disposal* | -Onone | -Owholemodule |\n| -----| ------- | --------- |\n| Lock-free, macOS | 0.017 sec (4%) | 0.013 sec (5%) |\n| Lock-free, iOS | 0.022 sec (4%) | 0.018 sec (2%) |\n| Atomic, macOS | 0.267 sec (4%) | 0.234 sec (2%) |\n| Atomic, iOS | 0.259 sec (9%) | 0.279 sec# (18%) |\n| Speedup, macOS | 15.1x | 18.0x |\n| Speedup, iOS | 11.6x | 15.5x# |\nmacOS: 2.4 GHz Intel Core i5-4258U, macOS 10.12.1, Xcode 8.1\niOS: iPhone SE\n* dispose() of the old SimpleDisposable is emulated as swap(true).\n# Somehow it is slower.... I've factored out the lock-free logic, and wrapped it with a finite state machine-ish interface. ~~It should be at least reusable in Signal for handling interruption.~~ (Edit: #123 removed the lock)\nIt is a little bit faster too, with the inlining annotation in place. With the same test and configuration, it completes in 0.010 sec (10%).\n* Transitions are represented as protocol extensions. Tried tuples and type parameter, but both have a nontrivial cost at runtime.. Comparison across branches. The test case is sort of simulating a fast scrolling table view, which gets a bunch of composed properties (2 signals per transform) rebinding agains the cells.\nmaster: 1.164 sec (3%)\nAtomic #124: 1.081 sec (2%)\nThis PR: 0.995 sec (2%)\n```swift\n    func testProducerStart() {\n        let property = MutableProperty(1).map { $0 + 1 }.map { $0 + 1 }.map { $0 + 1 }\n        let token = Lifetime.Token()\n        let lifetime = Lifetime(token)\n    var i = 0\n    let target = BindingTarget(lifetime: lifetime, setter: { i = $0 })\n\n    measure {\n        for i in 0 ..< 10000 {\n            let d = target <~ property\n            d.dispose()\n        }\n    }\n}\n\n``. Hmm, probably notEvent. We do not expect to have multiple conforming type. . ~~Hmm, it is broken when falling back toAtomic.~~ Fixed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/112/commits/8043833a7aad84af91c600f9f511f3c03f210b80.. Looking for a simpler solution..started` is invoked after the starting side effect is done. So you would exhibit the same behaviour in any producer that sends events synchronously in the start handler.\n@mdiep Perhaps started should not be invoked if the produced signal is terminated in the start handler. Any thoughts?. Yes in order, but it need not be immediate.\n\nstarted is invoked after the starting side effect is done.\n\nLook at the signature of SignalProducer.init(_:). It accepts a startHandler that is passed an observer. This means events can be sent as part of the starting side effect. started just indicates the side effect has completed, and it is invoked after startWithSignal (which in turn invokes the start handler) returns.\nNote that starting is the good old started in RAC 4.x.. Should we group the producer specific operators together?. Oh, never mind. It seems only retry falls into this category.. @sharplet Yeah, it does seem better. It would be a better default when generalised existentials eventually land in Swift, and we have the existential initializer deprecated.. Should we mark AnyProperty(_:) renamed to Property(capturing:) instead? Or mark it as deprecated and tell the user there are two variants (no auto-fixit) instead?\n@ReactiveCocoa/reactiveswift . Hmm... the unavailable annotation of AnyProperty the type has a higher precedence than ~~Property~~ any of its methods... So annotating init does not translate into anything.. We probably can't do any better. So perhaps we should just let it be. \ud83d\ude48 . I'd argue that the variable names usually have conveyed that they are signals, e.g. SignalProducer(signal: usernameSignal), SignalProducer(signal: occupationValues), which makes the signal label look redundant. Labeled initializer is also used only when it comes to type narrowing, although in our case we need them to prevent conflict with values: ... and friends too.. TBH I haven't used it in my projects with all the stuff we have introduced since 4.2.0. The last time I've ever used it is probably in our codebase. As you might have seen in the diff, the label doesn't feel like adding clarity at all but verbosity. Though ~~maybe if we rename~~ had the the label been named ~~to~~ forwarding it would have made a better sense.\npublic convenience init(initial: Value, then signal: Signal<Value, NoError>) {\n -      self.init(unsafeProducer: SignalProducer(signal: signal).prefix(value: initial),\n +      self.init(unsafeProducer: SignalProducer(signal).prefix(value: initial),\n                  capturing: [])\n    }. In a short discussion with @sharplet, we came up with a more generalised idea of dropping the label for all initializers that take a sequence.\nThe argument was:\n\nDo we need to distinguish it here (the variants of initializer) though? Both are conceptually (taking) a sequence, and results in a producer that emits a sequence of values.\nIt has to be distinguished, IMO, only if it would result in different behavior, or has loss of information e.g. type narrowing. Moreover, at the call site, one should already have known what it is when it comes to type conversion or initialization. Otherwise, garbage in garbage out (?).\n\nSumming up with @sharplet's words:\n\nYeah I'd agree with that. You could say that these convert a time-based sequence of events to a SignalProducer, where the Sequence version is immediate and the Signal version is streamed.\n\nSo the PR has been updated with two SignalProducer(_:) overloads, one taking a Signal and another taking Sequence.\nNot sure if we should count the vararg initializer as one though.. The hole @sharplet caught is fixed using do...catch. defer would bump the time up by ~20% due to it being closure based.\nP.S. In master, RecursiveAtomic.didSetObserver is called when an error is thrown. Looks like a bug.. Hmm. It won't restore automatically. But making it restoring on throw doesn't make sense in performance for the common use cases either. Maybe it should be left as is.. Related: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20161205/004147.html\n\nJoe Groff jgroff at apple.com\nIf you apply them to memory you allocated manually with malloc/free on UnsafeMutablePointer's allocation methods, then yeah, they should work as they do in C. That's the safest way to use these functions today. Passing a Swift var inout to one of these functions does not guarantee that accesses to that var will maintain atomicity, since there may be bridging or reabstracting conversions happening under the hood.\n. I don't think Scheduler suits here. TestScheduler is synchronous, while QueueScheduler is serialising.\n\nI've tuned them down though. The post-termination event test case now stalls only for 0.125 seconds, while the concurrent interruption test case now takes only 1000 iterations with 5 second timeout on the counter.. (Just made to demonstrate the failure. Further changes will be made in #123.). (Nit)\n```swift\n// Button taps with (the) latest continuous text values.\nbuttonTaps.withLatest(textField.reactive.continuousTextValues)\n// Button taps with (the) latest (one) from (the) continuous text values\nbuttonTaps.withLatest(from: textField.reactive.continuousTextValues)\n```. Travis CI has had a huge backlog in Mac jobs since a day or two ago.. > Are there any ramifications for existing code that might start signals as a side effect in on() or some other operator?\nIf you mean starting producers, I don't see it would cause harm. \nEdit: Recursive event sending was not allowed since the very beginning. So other than this, the side effects are still executing within the same giant protected section, in the very same order, unless ~~asynchronous~~ operators that involves multiple signals are used.\nIf you mean observing any Signal along the chain, the observer bag is CoW on insertion or removal.\n\nWhat would happen to recursive event sending that currently results in a deadlock \u2014 anything?\n\nObviously, the unlocked mode would grant a hole for recursive event sending. But our stance should remain unchanged. ~~One way we could do this is allowing lock elision only in release builds~~ (Edit: though I'd prefer to have it in debug builds, and we could simply declare it unsupported and \"don't call us when you crashed\".)\nAs for recursive interrupted handling, since we are just dealing with Signals here, the only source of interrupted events would be the upstream, i.e. no difference from other events.\nEdit: It is a different story to have SignalProducer's lock elided, but we should leave it to another PR.. @NachoSoto Has to be part of the public API, or otherwise RAC can't use ~~them~~ it.\nEdit: Having said that, RAC APIs may still enjoy the benefits as users apply more and more operators. But it feels sad (?) to me not to have RAC covered too.\nEdit 2: There is a middle ground though: obscurity. We can export this API to ~~a submodule~~ an enum namespace, say ReactiveSwift.UtterlyUnsafe.. Renamed a few stuff according to @sharplet's suggestions, and had four operators joined their lock-elided friends in https://github.com/ReactiveCocoa/ReactiveSwift/pull/129/commits/1dd6d5f44df51e295f2a9124d623bac411f5b236.. A note on the recursive interrupted handling:\nAFAIU, it is made for SignalProducer specifically. However, as we are not addressing SignalProducer yet, it is simply assumed to never happen with inherited serialization, since interrupted is only sent on the Signal the producer created, which still uses the default serialization.\n```\n lock\n observers ---> lock\n                observers ---> elidedLock\n                               observers    ---> lock\n                                                 observers    ---> elidedLock\n                                                                   observers    ---> ...\n                                                                   elidedUnlock\n                                                 unlock       <---/\n                               elidedUnlock <---/\n                unlock    <---/\n unlock    <---/\n\nSOURCE    |   PRODUCER   |   LIFTED MAP    |    PRODUCER     |   LIFTED MAP    | ...\n\n\nSources can be:\n 1. Properties\n 2. SignalProducer(signal:)\n 3. SignalProducer(_:) (not necessarily serialised.)\n```\nEdit: Updated the ASCII diagrams. The unlocks are misplaced. \ud83d\ude48 \nEdit 2: Added the missing \"Source\" column.. @NachoSoto Maybe I should have phrased it better: It can for sure be private to ReactiveSwift.\nI just want to figure out a middle ground for RAC if it makes sense. If \"internal\" through obscurity (like stdlib) is still considered exposing the implementation, there is probably no other way to expose this to RAC based on my understanding.\nEdit: For example:\nswift\npublic enum __WhenWeDoNotHaveSubmodulesThisHappens {\n    public static func __makeInheritlySerializedSignal<Value, Error: Swift.Error>(\n        _ generator: @escaping (Observer<Value, Error>) -> Disposable?\n    ) -> Signal<Value, Error> {\n        return ReactiveSwift.Signal(serialization: .inherit, generator)\n    }\n}. @NachoSoto Hmm, I actually thought of a counter argument to keeping it private: while most users would not care, users - including depending libraries like ReactiveCocoa - who want custom operators or have all possible means to optimize should be given the tools.\nIf what you worry is having it ~~as part of the normal overload~~ showing up in code completion, as mentioned we could export it in an separate enum namespace.. Benchmark Source\nEnvironment: macOS Sierra 10.12.1, i5 4258U, Xcode 8.1, -Owholemodule\nComparing against master.\nTableView Scrolling Simulation\nProducer heavy, Produced signals send only 1 value.\n+2% (7%)\nSend 10000 values to 1 observer.\n+9% (10%)\nSend 10000 values to 8 observers.\n+12% (5%)\nSend 10000 values to 1 produced signal.\n+4% (8%)\nSend 10000 values to 8 produced signals.\n+6% (3%). Blocked by #137.. The SignalSerialization enum is replaced with an option set, since I expect #163 would need a similar way to customise the Signal. ~~The APIs are also promoted back to be public, primarily for depending frameworks and users writing custom operators.~~\n~~Note that as a default attribute set is provided, Signal.init and Signal.pipe shows up in autocomplete as two overloads.~~. Rolled back to be an internal API, and rebased on master. The benefit of opening it up for the sourcing signals in RAC is trivial and not a priority, since the primary concern is cutting the overhead of deep signal composition.. Benchmark source.\nTest body\n```swift\n        let property = MutableProperty((0, 0, 0, 0))\n        let composed = { property.map { ($0.1, $0.3) }.combinePrevious((-1, -1)) }()\n        //let (signal, observer) = Signal<(Int, Int, Int, Int), NoError>.pipe()\n        //let composed = signal.map { ($0.1, $0.3) }.combinePrevious((-1, -1))\n    withExtendedLifetime(composed) {\n        _measureAndStart(times: 1_000_000, label: label) {\n            let value = 1\n            //observer.send(value: (value, value, value, value))\n            property.value = (value, value, value, value)\n        }\n    }\n\n```\nResult\n1000000 iterations, -Owmo, i5 6260U\n``\n// Signal,observer.send(value:)`\n@testNonatomic(): avg 1570 ns; min 1343 ns\n@testNormal(): avg 1644 ns; min 1422 ns\n// MutableProperty, property.value.set\n@testNonatomic(): avg 5402 ns; min 4656 ns\n@testNormal(): avg 5578 ns; min 4797 ns\n```\nThe locking overhead is around 5-7% per observer call-out.\nFor the narrower gap in properties, it is likely due to not having lifting optimization (#140) in place, which elides the serialising, relaying Signal of lifted operators for the concurrent interruption, and allows serialisation and interruption to be inherited from upstreams. Recall that composed properties use SignalProducer at its core.. > The thread safety is already hard to reason about without adding an additional level of complexity.\nThe annotation in this PR is built on top of the premises of the Signal contract, saying all Signals must be synchronous (by default) and serialized.\nIf a synchronous operator derives a Signal from one single upstream, the derived Signal is already implicitly serialized \u2014 like a synchronous call tree that starts within a critical section. The keywords are synchronous and single upstream, which are fairly explicit IMO.. Closed since this becomes trivial with an upcoming higher-level SignalProducer optimisation branch.. As we do not have a stable release yet, you would need to refer to the Swift 3 version by tag.\nhttps://github.com/ReactiveCocoa/ReactiveSwift#cocoapods\nNote that ReactiveCocoa hasn't been updated for ReactiveSwift 1.0.0-alpha.4 yet. So if you want to use ReactiveCocoa too, just include ReactiveCocoa and CocoaPods would fetch the dependencies for you.\nhttps://github.com/ReactiveCocoa/ReactiveCocoa#cocoapods. So if another Strategy ~~is to be~~ would be made, should it follow this to be [verb]Strategy?. Not sure if it is related: https://github.com/ReactiveCocoa/ReactiveSwift/issues/92#issuecomment-259833507.\n~~But this should not be happening if the binding is truly the last weak reference to the MutableProperty at all, since the deinitializer is called whenever the strong refCount drops to 0. Weak references affect only the deallocation.~~\nWell, it seems there is a possibility that the closure's weak retain has won the race against the last strong release. So the deinitialization happened in the sendLock.\nhttps://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h#L265. ~~NSRecursiveLock unfortunately seems the easiest solution to this race condition. Handling completed like interrupted is like opening Pandora's box, racing with Swift's deallocation routines concurrently, and having malloc broken or polluted somehow.~~\nGot something up... Seemed like it was suffering from corrupted state before.... ~~It is probably missing a memory barrier for it to work on ARMv8. Gonna run tests on an iPhone to ensure things are right.~~. ~~The takeaway is that up till now Swift has no memory model. So whatever synchronization we do, including pthread_mutex_*, is depending on the undefined behavior of the compiler. Well, unless the entire routine from acquiring to releasing the lock is written in C/C++, e.g. libdispatch.~~\n~~(\u251b\u2727\u0414\u2727))\u251b\u5f61\u253b\u2501\u253b~~\n~~Though in practice, the Swift compiler does not appear to reorder stuff against C function calls, and more importantly consecutive writes under -Owholemodule.~~\nThe rant above was a note on the previous attempt with explicit memory fences between terminationEvent and terminationState.\n\nIn the latest commit https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/4ea7537fe185a751c00b718ed498b46564c15d64, these variables are packed as an immutable object before being assigned to terminationState. The states in this form are this easier to deal with in the threading design, since it is just an 8-byte reference that can now be atomically synchronized against sendLock.\nIf it was unpacked, acquire/release fences and trust in compiler (see the rant) would be critical to ensure terminationEvent is always written before terminationState at runtime, so that concurrent readers would see both values together.. It seems the Swift compiler in Linux has started to impose some resilience rules.. In https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/1a3cb9267728e41d3ccf6b1901a8e9d2eb31914f:\n\nTwo pieces of mutable states now become one. Swift enum is amazing. \ud83c\udf70\nHaving states as stored properties seems a little bit faster, probably due to locality and/or less ARC calls.\n\nMight need a little bikeshedding on the naming of the enum cases though. ~~Or maybe we should name the enum Signal\ud83d\udea6 (Signal.\ud83d\udea6 in 3.1)instead, since Swift is an opinionated emoji language, uhuh?~~ \ud83d\udc7b. (Checking howenum` behaves in 32-bit platforms). Hmm caught a few missing bits. The latest commit https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/1681a4444d15fb0cff4a39dc0dd014d9791442b2 is the updated version with proper documentation.. Just in case these would be missed:\nOn Read-Copy-Update and the atomicity of reads to Signal.state.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/137#discussion_r90780060\nOn SignalState being laid out as a tagged pointer.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/137#discussion_r90787077\nOn why the wrapping of SignalState helps.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/137#discussion_r90780687. I have refactored the code a bit. Hope it helps the code explaining itself.. Addressed in ~~https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/56862278084e0501013c0302f168440b9f6c8392~~ https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/b55fe6a49bde34e726134e48005dabf2da5c38dd. \u2615\ufe0f. Implemented in #233.. Blocked by #137.. ~~It seems intermediate signals do not get interrupted events but are disposed of directly. Fixing.~~ Fixed.. Not in a hurry. Gotta think of a better explanation to all this. :coffee:. > I think we need to try to clarify/simplify the code before merging. \nI do hope to figure out a way to unify both \"modes\" to burn down the giant switch in the binary lift. But I have my hands busy on other stuff right now. \ud83d\udc1d. Heh, it turns out to be quite straightforward. \ud83d\ude48 . Updated and polished.. Note that this addressed #227, since now downstreams are interrupted by upstreams. IOW interrupted would now respect the async operators applied.. It is unintentional, but does it need to be corrected? bridgedAction is actually the rare case IMO, while generally the state property is something that is composed from properties owned by your view model (or view controller if one uses MVC).. Note that with #117, only MutableProperty and existentials would be benefited from this.. @mdiep The cleanup for producers does not differentiate between cancellation and termination. The collected resources are disposed of when the signal is terminated regardless how it terminates. \nSo it is actually a synonym of observing the termination of a Signal, just without affecting the Signal's lifetime like how a normal observer does.. Hmm, you raise a valid point for observers relying on a terminal event to clean up resources. In the proposal, no events would be sent, because no work that yields event has been committed. The same also applies to observing a terminated Signal (it also returns a nil tho).\n~~Seems like we should leave the public API as is \u2014 just refactoring. Sorry @NachoSoto, it seems it gonna stay. But at least now we found it useful (?).~~\nEdit: Other alternatives that could be a step backward:\n\nAdd observeDisposed (or Lifetime) to Signal. Only available in startWithSignal though.\non(disposed:).\nMeld interrupted into failed: Introduce ProducerError<E> like ActionError<E>.\nUse ProducerEvent<U, E> with ProducerObserver<U, E> \u2014 ehm...\n\nEdit: Though having an interrupted event in parallel to completed and failed would definitely be safer for those stateful observers that assert multiple kinds of events, because the switch requires it to be handled.. Regardless of removing it or not, I think it would still be nice to refactor it by establishing an explicit reversed channel, which can be reused for #163. Then ideally we'd still achieve the goal on one less Signals.\nI have a wild idea on how to hide it completely from the public API, but I haven't got the time to iterate on it yet.. It seems making SignalProducer<U, E> take Observer<U, FailureContext<E>> in start(_:) would not be a bad option. We can still have all the shorthands and the type signature intact, while for those who supplies a full observer, it would be a difference from:\n```swift\ncase .interrupted:\n    // cleanup\ncase let .failed(error):\n    // handle error\n    // cleanup\n```\nto:\nswift\ncase let .failure(context):\n    if let error = context.error {\n        // handle error\n    }\n    // context.isInterrupted: Bool\n    // cleanup. Have the same feel after skimming through the codebase again. Anyway, the refactoring gonna be done in #163.. Here is a temporary docset:\nhttps://andersio.github.io/docs/Protocols/SignalProducerProtocol.html. If you just need one value, use take(first: 1). Or if you'd like the exact semantic without an intermediate disposable:\nswift\nproducer.startWithSignal { signal, disposable in\n    signal.observeValues { disposable.dispose() }\n}\nThough I am not quite sure about what you would like to achieve though. If you give more information on how it is used and how it is expected to behave, we might be able to give better suggestions.. You would need ReactiveCocoa too. Note that it is a Signal (hot), not a SignalProducer (cold).\nswift\n// Assuming `firstField` is `UILabel`.\nfirstField.reactive.text <~ firstTextField.reactive.continuousTextValues\n    .take(until: self.reactive.prepareForReuse)\n    .skipNil()\n    .skipRepeats()\n    .skip(1). Action is one of the ways. For example: Action is capable of generating outputs specific for an invocation with an input.. We have limited resources. Right now the focus is on rolling out a stable ReactiveSwift release, and then one for ReactiveCocoa.\nThere is a rough plan on delegate interception (ReactiveCocoa #3333) which would allow these extensions.\nAs for data sources though, they are performance critical and not quite a native citizen in the reactive world. My personal stance is that these should not be included, but rather abstracted away with reactive collections. We are making some progress, but I do not expect it to be in the mainline anytime soon (hopefully when Swift 4 arrives).. Delegate interception is in fact staging, albeit the reality that we are low on engineering time and review bandwidth.\nWe also plan to offer collection diffing (as a new framework) and collection binding (in RAC). The diffing part is staging in ReactiveCollections, while the binding part is pretty much still a WIP.. Adding labels to tuples is addictive and straightforward. If it gets merged before #137 then it would be in 1.0.\nIntroducing a new type is however breaking, and I'd prefer to leave that to 2.0, which is just a few months away anyway.\n147 . Seems like this would be a 2.0 thing then.. @mdiep Updated in https://github.com/ReactiveCocoa/ReactiveSwift/pull/157/commits/216fa6ecb0f638a3ead9aad4af0d53a53c062410.\nAn alternative is to allow composed properties to define different producers for composition and public use. But it is quite a complexity, and I am not sure if anything other than observe(on:) would use it.. Hmm, but it won't be safe if people treat the producer as if it is SignalProducer.observe(on:), and use implicitly protected resources with it.\nIt seems either we accept the compromised solution in https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3345 and drop this PR, or we have to blown up the complexity.. Contents moved to #161.. Implemented by #351.. (It would even be great if a Signal operator is made instead, and have lifted variants for SignalProducer and finally Property.). LGTM otherwise. Thank you for your work. \ud83d\ude38 . @sharplet Let's say we have:\n```swift\nvar commits = Commit\nlatestCommitProducer\n    .observe(on: backgroundScheduler)\n    .observe(commits.append)\nlatestCommitProperty\n    .observe(on: backgroundScheduler)\n    .producer\n    .observe(commits.append)\n```\nIt would be fine for the SignalProducer, as all the events are forwarded to backgroundScheduler even if they are emitted by the start handler.\nBut for this version of property observe(on:), the initial value is replayed synchronously. In other words, the observer is invoked concurrently w.r.t. backgroundScheduler.. @sharplet Schedulers are serial. Edit: There is no concurrent scheduler in ReactiveSwift. Even if you create a scheduler from a concurrent queue, QueueScheduler would serialise the submissions it received.. https://github.com/ReactiveCocoa/ReactiveSwift/pull/161/commits/5ae85c6d5805f7b516cf3c84e4f0b928dd54680f now enforces the initial value to be replayed on the specified scheduler.\nThis is done by allowing composed properties to specify a \"persona\" for its publicly accessible producer, while the \"raw\" replaying producer would still be kept internally for property composition.\nMoreover, properties derived from such property would inherit the persona, aligning with the behavior of its Signal and SignalProducer counterpart.\n\nThe replayed value would still be synchronously delivered in https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3345 with observe(on:), since UIScheduler would elide the queue dispatch anyway.. Can't say I disagree on that. AFAICT it would require PropertyProtocol to have a new requirement to expose its locking mechanism, e.g. withValue would do it implicitly.. As shown in the error message, you are dealing with Signals. What you should use is observe or its shorthands observe(Values|Results|Completed|Failed).\nstart is a notion of SignalProducer that works like observe but meant more than that. We have a short summary with examples that describes the differences between Signal and SignalProducer.\nP.S. In ReactiveSwift 1.0, we changed the NotificationCenter extension to return Signal instead of SignalProducer. That's why you got this error. :). Sadly, after a second thought, the adaptivity cannot be propagated in all cases, as we have many operators being stateful and events should not be dropped at all for them.\nOnly stateless operators like map and mapError can take advantage of this, and fortunately it still covers all the said use cases.. @mdiep Reverted to inner.. Hmm, apparently there is a race condition between the cache updating and the producer start handler.. Doesn't feel like there is any more option. In the end, everything is just value + signal, so as producer which implicitly protects the replay and the observer attachment with the same lock.\n~~Edit: To address all race conditions, perhaps we'd have to either integrate the replay mechanics into Signal, or use ReplayState directly in Property. It is hard to tackle them without direct access to their locks and stuff.~~\nEdit: NVM, AFAICT this is the only new race condition due to the use of value + signal, and was patched by bringing back replayLazily which is built with this kind of races in mind.\nThat's said integrating replaying into Signal might still worth a try.. Close for now. Gonna go through it again when #182, #129 and #140 have all landed.. Have you updated ReactiveCocoa to 5.0.0-alpha.5? This had been updated for RAS 1.0 RC2 in 5.0.0-alpha.5.. Edit: Expanded a bit.\nComposed properties or Property in general do not own its lifetime, but rather a view to what it is derived from, akin to transformed Signals. This was a breaking change in ReactiveSwift 1.0 that followed the formulation of property composition.\nYou would see the same behaviour with Property.init(_:), while the original capturing initializer has been renamed to Property(capturing:).. Property(capturing:) is the only exception, and it is expected to be gone eventually with generalised existential (Swift 4?).. Did that after answering you. \ud83d\ude05\n173\n. You are using a version that is too old for Xcode 8.\nIf you are using Swift 3, specify ~> 5.0 or 5.0.0-alpha.5. If you intend to stay with Swift 2.x, specify ~> 4.2 and set \"Use Legacy Swift version\" in your project's build settings to YES.. This doesn't seem the only leak though.... Based on the API guidelines, it should be add(_:during:) though.. It seems there are some edgy cases in the binding model that haven't been caught. Our primitives themselves aren't leaking.. > I actually like the name as-is. The reality is that a Property or SignalProducer can be observed.\nSignalProducer cannot be observed. It produces a Signal that can be observed, aka start. It fits Property, but then observe and start have a different semantic in Property where the binding is using start.\n\nCan we add a test for this?\n\nProbably not. There is no public or internal API to catch the number of observers.. > If it's disposable that's getting leaked, we should be able to do a standard weak test where we verify that it gets cleared at the appropriate time?\nTrue without this fix, where the Lifetime observation shares the same disposable that is returned. But this fix internalised it with take(during:).\nWe may setup some burning tests that compares memory before and after the burning though.. > Even if it can't be observed directly, it can be observed. At any rate, this method is clearly side-effecting, so it deserves a direct verb name. Something like add won't do it justice.\nI am not disagreeing with that. Just that observe has an established meaning that does not belong to at least the domain of SignalProducer \u2014 we have start as the MVP there. Now imagine an entry in code completion shows up with observe.... With that analogy though, shouldn't we eventually rename start* to observe*? They are semantically equivalent to observe(_:during:), except the later requiring a Lifetime.. Not a bad compromise. Though I'd still hope to see <~ gets melded back into protocols eventually so that it'd become invisible.. @liscio It is a compromise with the compiler and language limitation.\nIdeally we can drop the named variant with <~ that comes with a different signature: (Observer, Lifetime) <~ Source instead of the top-level Target <~ Source, which (bonus point) addresses the customisation issue @mdiep once worried about.\nBut when I attempt to implement it, it is really a shithole... Apparently something is wrong with the type checker with operators (edit: when handling operator requirements). Though they are apparently fixed in Swift 3.1. So we may revisit these in 2.0, perhaps.. Well 90% of the time Swift is nice. The shitstorm hits only when building abstractions with stupid diagnostics that do not help at all, and limitations in the generic system that you'd wish Swift 4 to come earlier than later. \ud83d\ude48. Ah. I opened this because I thought CocoaPods would fetch RCs with ~> 1.0 like Carthage. But it turns out to be not.. Maybe name it with a noun, heh? ~~blackHoleForValues, perhaps.~~. We can revisit it later. I feel that two-way binding might affect how it gonna shape.. A second thought though: All of these proposed constructs look representable by Action. Perhaps extending Action would be a better take, hmm?\nBut we would need a different type e.g. ActionProperty that caches the latest value and do things synchronously only. isExecuting and isEnabled are also not necessary in some cases. Not sure how much logic can be reused.\nComposability is also a concern.. It is one of its use cases. But Action in general is a serialised worker that can have an internal state, and when fired it executes on a snapshot of the state, together with an arbitrary input.\nSee the example in the README.. ~~A gist to illustrate the viability. I can think of various juicy ways to compose with wrapper based approach, esp. with conditional conformances. Not sure how the Action based variant can be composed though.~~\nEdit: ... Apparently we can make them operator based one. Just that it requires some protocol magic to handle the errors correctly. Here is a new gist with a refined prototype.\n```swift\nlet username = MutableProperty(\"\")\n    .validating { $0.characters.count >= 3 ? .success() : .failure(\"At least three characters.\") }\n    .validating { usernameRegex.test($0) ? .success() : .failure(\"Contains invalid characters.\") }\nusername.validations.observeValues { result in\n    print(\"(result)\")\n}\nusername.value = \"\ud83e\udd14\"\nusername.value = \"\ud83d\ude17\ud83d\ude17\ud83d\ude17\"\n```\nSo validations and transformations can be operator based, and shares the same type (ActionProperty).\n~~Though I think we might still need a Bidirectional<> for bidirectional bindings.~~. Gonna rewrite.. The playground has been updated with interactive elements.\n\ud83c\udf84\nEdit: It is hosted now in a separated playground, since the CI would validate ReactiveSwift.playground on the Mac, while the playground is written with UIKit.. It seems there has to be a way to specify relationships too... say a validateLatest(with:).\nIn the playground example, emailConfirmation depends on email. But emailConfirmation would not flip to be valid if we match email with it, just another way round.. Summary of changes\n\nRenamed to PropertyEditor.\nConformance to ComposableMutablePropertyProtocol is dropped. It is still a binding source and a binding target though.\nThe failable setter is now ~~PropertyEditor.try~~PropertyEditor.attemptSet.\nCommitted values are now exposed through ~~PropertyEditor.commited~~PropertyEditor.committed.\nThe latest validation result is now available through PropertyEditor.result.\n[try]Reverse instead of [attempt]Backward.. All comments were addressed. :). @mdiep \n\n(Made huge edit.)\n\nLike I mentioned above, I don't understand why this is bidirectional. At the very least, it seems like we'd want both a unidirectional and bidirectional version of this (I'd bet most validations are simple) in which case it makes sense to start with the simple, unidirectional version.\n(And now that I think about it, the one case I have done a bidirectional binding would have been better served by a simple bidirectional binding and two separate validations.)\n\nCan't say I disagree. The main driver behind this design is map(forward:tryReverse:) after all.\n\nWhy let values be set in this direction? Bidirectionality adds a LOT of complexity, and I can only think of 1 instance where I've ever wanted something like this.\n\nPropertyEditor is not a construct that involves bidirectional synchronization. It is just a \"failable\", mutable and transformed view to root mutable property, and it merely blocks invalid values on the write path from propagating to the backing \"root\" property. It also has the ability to map values in both directions, but at the end of the day, it is just a view.\nMore importantly, it isolates validation failed values from committed values. If it is implemented as a validating observer that reverts the change, the reversal would be visible to all peer observers bound to the property, including the UI control which itself initiated the failed value. IOW the control would be stuck.. @liscio It wasn't required to be handled though. The substituted state is just an aggregate of the proposed value, the substituted value, and an optional error context. Each pieces of them can very well be ignored at one's will.\nNote that https://github.com/ReactiveCocoa/ReactiveSwift/pull/182/commits/09022641487305ed17b92824455967d98dcc776e has introduced the notion to replace a failed value with a predefined value.. > Do we need to keep the blue logos around?\nRemoved.\n\nThe Documentation and Join us on Slack ones seem like they should be darker or less pastel\u2014more like the Swift orange. (With white text if necessary.)\n\nI'd prefer them to be more pastel though, for contrasting with the logo that is already heavy in color.. I can see it being confusing, but both are an act of observation, flowing in the same direction. In the code documentation, we call the Signal's Observer an event emitter.. @mdiep \nWould it help if we make a subclass of Observer for the event emitter (that overrides nothing)? Observer can have everything marked final, so the difference would only be the encoded type.. When you observe a Signal, you create an Observer to react to the events.\nWhen you create a Signal, a prepared Observer is given to you, and it reacts to the events you sent to it (multicasting in Signal's case).\nLike how it was said, both are an act of observation, just that they are on different sides of the one-way pipe.. I have tried to reproduce it in playground, and it seems fine.\n```swift\nenum NetworkError: Error {\n    init?(cocoa: AnyError) {\n        return nil\n    }\n}\nlet urlReq = URLRequest(url: URL(string: \"x-ras://\")!)\nfunc parseResponse(_ value: (Data, URLResponse)) -> SignalProducer {\n    return SignalProducer.empty\n}\nURLSession.shared.reactive.data(with: urlReq)\n    .flatMap(.latest, transform: parseResponse)\n    .mapError { NetworkError(cocoa: $0)! }\n    .observe(on: UIScheduler())\nprint(\"Hello\")\n. @alperswift\nfunc parseResponse(data: Data, response: URLResponse) -> SignalProducer {\n```\nNamed one works too, hmm.. @doozMen Could you be more specific about what you have a problem with?. Would you mind to provide a reduced use case for groupBy? New operators are definitely welcomed, but it'd be better if it is justified to solve an apparent generic use case.\nbuffer(upTo:) can be mimicked by:\nswift\nlet (signal, observer) = Signal<U, Error>.pipe()\nlet producer = SignalProducer(signal).replayLazily(upTo: n)\nproducer.start().dispose(). uncollect already exists as an overload of flatten, by the way.. Yep. IMO it doesn't matter when the inner sequence is immediate.. I'd like to see if it could bring additional compile time guarantee over SignalProducer. AFAIK there is no way (and no plan) to have an attribute to guarantee that a closure can only be invoked once. So in the end, in terms of the static API contract it could very well be an equivalent of SignalProducer.\nA new type also adds more overloads to our lifting-based operator model, and the maintenance cost has to be considered too.. ping @NachoSoto \ud83d\ude38 . It looks more like an issue due to the two start handlers being invoked in a sequential order. At the Signal level, it is correct.. combineLatest uses liftLeft. So in the failing one, the 2-element sequence would start first.. It think it is worth mentioning in the documentation that combineLatest picks only the latest value emitted by the start handler of the LHS producer.. The source of the problem is the guarantee of a property's producer always emitting the latest value, even if it has been deinitialized.\nIn these failing test cases:\n\nThe flattened property is retained till the end of the scope, and it retains its replaying producer.\nAs the replaying producer was made to retain the upstream producer in startHandler, this means ultimately the outer MutableProperty producer is retained too.\nThe MutableProperty producer retains the Atomic storage, which retains the last property being sent.\n\nThis also explains why latest doesn't fail \u2014 the flattened property has deinitialized immediately after use.\nWith source capturing removed, the new Property contract is that downstream observers should not have any influence on the upstream's lifetime. So it doesn't seem to have a workaround, other than keeping self only when it is absolutely necessary. . The PR in its current form would allow failure of any error types being silently absorbed by replayLazily, regardless of being intentional or not.\nWe had made observeValues only available when Error == NoError in 4.2 despite the fact that people often intentionally ignore the error. I don't think we should make an exception here.\nI still think an overload constrained to a special error type could be a way forward. In theory it would be composable like anything else as invalidation would just mean sending failed, and it would require errors to be explicitly handled.. observe is an established term of art since the ObjC days, so as start since 3.0. I don't think we'd ever gonna change them.\nAdding a preposition as label should be fairly enough to clarify the intent, and form grammatical phrases at the a use site (Strive for Fluent Usage, Swift API Guidelines).\nwith: is also a contender.. @ReactiveCocoa/reactiveswift Hmm should we make a decision on this? It seems observe(with:) already got 5 votes. I think we can also give start one if we are to pursue a label.. Reentrant lock has a fundamentally different semantic, and I am not fond of having both under the same type to be use interchangeably. Places that actually need reentrant locks are very limited either, so this is why it wasn't part of the public API.\n+1 on pthread_mutex in release build. I think we should use NSLock in PosixThreadMutex for debug builds, heh, so that deadlocks would not be a silent halt.. ~~As a side note, I am eyeing for recursive writes in MutableProperty to enable bidirectional bindings, which requires entrance counting (that isn't needed by Atomic at all).~~ Personally I'd wish to see RecursiveAtomic to be gone, since MutableProperty is the only place the codebase ever needed it. May as well inline it back and dodge all the closure overheads.. The involved entities have been significantly changed lately, esp with the introduction of the adaptive Lock. MutableProperty had also adopted a recursive pthread mutex. If you still feel that a recursive Atomic is necessary, feel free to bring it up again. . @brow Would you mind to resolve the conflict?. > I believe that's still possible. Since you don't know what order the observers will be notified, an observer could be notified before one that overwrites it. It seems like we might need a different solution for this sort of thing.\nAs written in the draft of the bidirectional binding model, the order among multiple downstreams is not guaranteed.\nWhat would be guaranteed is that whenever a downstream enqueues a piece of work to the upstream scheduler, e.g. a button tap triggers an Action, that reads a two-way bound property, the work always sees a conflict resolved value that happens after all the writes of that scheduler before the point of enqueue. IOW, it can also be preceded by writes from other downstreams, but still the value would be conflict-resolved.\nThis is exactly the place that requires recursive writeback. On a per-observer basis, if the conflict resolved value is written back asynchronously (upstream self-enqueue), we cannot guarantee that the same downstream hasn't enqueued anything to the upstream that precedes the writeback block. IOW, it might see the unsolved value.\nRef: The bidirectional branch.. (Prototyping an alternative approach). Can be renamed to retry(upTo:interval:on:).. WIP. Not pushed yet. I will give you a heads up when it is done.. @inamiy When the lifetime has already terminated.. @mdiep #143 might have a stake in this, if it is still on the table. #143 also touches on where += might make sense, though it is purely sugar.. I don't quite see the problem here. We can just treat a fire-exactly-once Disposable as a termination observer. They are all a () -> Void sink anyway.... The deprecation of ended is reverted, while observeEnded is documented as the preferred API unless composition is needed.. The context & use site of the strategy & the operator are different enough not to be confusing IMO.. The PR should target master-next in this case, hmm?. No, your snippet takes only one inner signal and flattens it. race accepts any arbitrary amount of inner signals, flattens the first one that sends events, and disposes of the rest.. Reopen to trigger CI.. ~~Specifically for bidirectional binding, a prototype is ready at bidirectional branch, though it still needs to be overhauled for some feedbacks I've collected.~~. You would need to introduce a protocol that Foo conforms to, so as to constrain the type parameter.. It is a language limitation. You cannot parameterize an extension at this moment.. It had a place in the Swift Core Team Doug Gregor's Generic Manifesto.. Yes.. I was thinking of potential prefetching support in ReactiveCollections lately. Apparently both https://github.com/RACCommunity/ReactiveCollections/issues/29 and this issue calls for a real lazy property type. I have outlined a crude idea in https://github.com/RACCommunity/ReactiveCollections/issues/29.. Would it being a BindingTarget initializer be better for the task?. I think the problem is that BindingTargetProtocol is write-only, and you do not get the chance to atomically RMW the content. If you buff the protocol up, then it would become effectively PropertyProtocol.. Well, if we are committed to BindingTarget, we may alter BindingTargetProtocol to work with just a concrete BindingTarget (and perhaps drop the class bound).. The particular use in OP can be replaced by a more generic solution based on the Smart Key Path.\nThat said a closure version could still be valuable. It can have a signature of (P, @escaping (inout P.Value, U) -> Void) -> BindingTarget<U> where P: ComposableMutableProeprtyProtocol.. Thanks for catching this.. It is part of the ReactiveSwift 2.0 initiative of removing unnecessary protocols that ultimately serve as only a workaround to the lack of concrete same-type requirements. Since:\n\nthe major version would be bumped to 2.0;\nwe cannot deprecate it in 1.x;\nUsers may choose to say at 1.x; and\nthis would not hit the majority of users, and even for those who define custom operators, it is just a matter of renaming;\n\nI don't feel the need of deprecation.. This is not source compatible since the definition has changed. Even if it is kept intact, the real problem is that we cannot do this with SignalProtocol and SignalProducerProtocol, while ideally we might want to do all these in one batch. Once we transfer the default implementations to the concrete type, existing external extensions to these two protocols would lose accesses to all those operators, unless we make trampolines.\nAnother issue would be the deprecation warnings in our codebases that cannot be suppressed, should we still have any extensions to these deprecated entities.. If it is just marking it ~~unavailable~~ deprecated, it should be okay for a point release. Just that for other protocols, specifically SignalProtocol and SignalProducerProtocol, AFAIU our codebase would get tons of deprecation warnings on the protocol extensions that cannot be suppressed.. I think recursive constraint is not relevant here, but parameterized extensions. ~~Sadly, it seems the 2.0 plan has to be scrapped then.~~ An alternative plan is to move everything except those that cannot (flattening, optionalize, etc), while keeping the protocols. Then we leave the remaining work to RAS 3.0. This way, we still have all operators hosted in the concrete type. That's said there is no guarantee that we would have parameterized extensions in Swift 4.0.. Hmm, perhaps.\nBy the way, I have a branch with producer operators converted, e.g.\nswift\nextension SignalProducer where Value: _SignalProducerProtocol, Error == Value.Error {\nBut it got hit by an issue in overloading somehow specific to concrete type extensions, and it so far affects attempt and then.\nBug Report: https://bugs.swift.org/browse/SR-3873. @sharplet Oops, it still appears in the build log.\nhttps://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/199639595#L826. Tried -suppress-warnings in https://github.com/ReactiveCocoa/ReactiveSwift/pull/254/commits/6eb9671d858c80c7458ee1f9917e6cd3e9e21ddb and it works.. @sharplet With #272 merged, could you please rebase it on master and strip the swift(>=3.1) constraint of the deprecation?. @inamiy @mdiep Rename it to action, perhaps?. @inamiy It is possible to pack an Observer<Value, NoError> in BindingTarget. But I am not quite sure if it is useful in practice.. The patch is rebased on master, and is now source compatible with 1.0.. ~~https://github.com/ReactiveCocoa/ReactiveSwift/pull/254/commits/6eb9671d858c80c7458ee1f9917e6cd3e9e21ddb~~ #272 suppresses the deprecation warnings when building with Carthage and Xcode in release config.. Swift 3.0 bridges NSError to a couple of concrete Error types if possible. Ideally, if existentials (protocol types) are self-conforming, we could use Error itself in signals directly when multiple error types have to be covered. But it wasn't the case (yet), so we have to wrap the error.\n@mdiep ~~I do wonder if the signature should use URLError instead. Does URLSessionDataTask throw any error not in the URL domain?~~ Never mind, it seems it would throw at least POSIXError in some circumstances.. @mdiep Lifetime.makeLifetime is not part of any release.. I already grepped the project. It doesn't seem there is anything else other than those in https://github.com/ReactiveCocoa/ReactiveSwift/pull/260/commits/f7cfc7f33f46eb08c3f3652a4b10ee476c081105.. Whoops.. https://travis-ci.org/ReactiveCocoa/ReactiveSwift/builds/204064960\nCI has passed, but somehow it wasn't shown here.. The theoretical contention window is too small that even brute forcing doesn't seem to be able to reveal it. It happens after the validating property has returned from the setter of inner, but before isSettingInnerValue is flipped back to false. During this window, if inner is updated by another party, the new value would not be evaluated by the validator due to an asserted isSettingInnerValue. So validated.value would not agree with validated.result in this case.\nI am still attempting to roll a failing test case, but it doesn't seem highly possible unlike previous cases which have ways to inject delays.. Heh. This is fun. The Linux build fails because of this.. @sharplet Addressed both in code and in the commit. The implementation has been updated too.. The same thing happens to MutableProperty too. I'd say it is not worth the effort though.. It feels like we should wait for the language to solve it, since the semantics of the public API are not the fault.. Interrupting current work upon deinitialization sounds reasonable. It also doesn't change the fact that the work spawned by the producer can always choose not to response to the interruption. So it would not disrupt the use of Action involving acts like persistence.\nThe scoped question lies in what semantic you expect the isolated apply producer would have.\nEdit: TBH in the end I think treating Action like a serial queue would be easier to rationalise. This means such case should be \"permitted\", since work retains the queue until it is completed. ~~But this would also require \"corrections\" in Action since it is inconsistent currently AFAIU.~~. ~~The current semantic of Action is that:~~\n~~1. If Action deinitializes, Action.events and Action.disabledErrors would complete regardless of whether there is work executing.~~\n~~2. The isolated apply producer, however, is not interrupted, and can still receive events from the executing work.~~\n~~This means observations made through Action would not observe events that are captured by the isolated apply producer in this boundary case.~~\n~~Edit: As mentioned above, the quick fix is to give Action a DispatchQueue-like semantic, which any pending work would cause the queue to be retained. However, this would also permit the thing @sharplet mentioned, although~~ whether it is worth guarding for is debatable. IMO it is like the caveat of the new Signal lifetime semantic in RAS 1.0.\nEdit: Completely missed that self is captured by the execution signal. So Action already has a DispatchQueue-ish semantic.. The main goal of Action is wrapping a ~~reusable~~ repeatable unit of work after all. An endless piece of work is not its primary concern, so guarding for it seems adding no value.. Ideally the compiler should be able to inline these without the attribute, since they are in an internal declaration. However it wasn't the case back in Swift 3.0, specifically IIRC there is an overhead wrt protocol witness table.\nSo it is okay to remove them if the compiler complains about it.. I'd argue that the current UIScheduler is essentially QueueScheduler.main with a specific order-preserving optimization, which can be extended to QueueScheduler.\nSo perhaps we fold UIScheduler into QueueScheduler, heh?\nEdit: That's said UIScheduler allows enqueues to jump the queue when multiple instances are used. The order is preserved only with regard to an instance of Scheduler.. Let's take GTK+ as an example, it still has a \"main thread\" requirement.\nhttps://developer.gnome.org/gdk3/stable/gdk3-Threads.html. > main queue is the main thread on these platforms but that does not necessarily apply to others.\nAs long as libdispatch and Foundation are still part of Swift, apparently libdispatch assumes the main queue is associated with the main runloop or the main thread, and main runloop is still a thing in the Swift Foundation. So after all, it is fair to assume that the main queue would be associated with the main event loop of the application, regardless of platforms.\nIMO perhaps renaming to MainScheduler would do the job, as like how @mdiep said it wasn't quite qualified as a queue due to the FIFO jumping nature.\n\nI disagree mainly because UI is almost entirely platform-specific and many projects do not have any kind of interface\n\nInteractive CLI tools, hmm?. The proposed await does not give a clear indication of which value should be captured, while as @ikesyo said it can be done by introducing throwing versions of first and last (as a shorthand of operator()?.dematerialize()) instead of a free function.. One thing you might want to keep in mind is that semaphores are not eligible of resolution of priority inversion, so as these semaphore-fuelled blocking operations in general. IOW they are not always safe on all Cocoa platforms.. The point is that Signal is a thread aware construct that accepts events from any threads, so the implementation of blocking is limited to semaphores or DispatchGroup (which is still semaphore at its core).\nSo due to how Darwin schedules threads, blocking execution to wait for another thread with these primitives does not guarantee forward progress. It is not a problem if you are sure that everything involving is at the same QoS class.\nA native async-await construct in the language, however, might not suffer from the same problem. But this is out of what ReactiveSwift can offer.. See #282.. Close together with #282.. ~~Experimenting tricks to slash a couple of nanoseconds and move stuff into the Swift world. \ud83c\udf83~~. Since the C part is not going anywhere, it might as well be reverted back to a full C implementation with annotated header for Swift.\nWhen I disassemble the lock method written in Swift, somehow the Swift compiler has injected a lot of instructions with unclear purpose other than the os_unfair_* calls and the enum tag checking/unpacking. C is after all more predictable.. Close for now. It doesn't seem to carry a substantial benefit for the complexity it brought to the project. It would probably be better to wait until the language can properly express it.. master already resolved it, and we will release ~~3.1~~ 1.1 soon.. 1.1.0 has been released. \ud83d\ude01. It seems Nimble causes the watchOS test to fail somehow.. It was documented before the revision. Guess we should put it back, alongside an option. A discardsWhenTerminated parameter with a default of true, perhaps?\nhttps://github.com/ReactiveCocoa/ReactiveSwift/commit/5f7109d57306f9204030172f3e8b6df37b1e5f1a#diff-09166f905ad1f830ac2dc91f2663c1a5L1728. @Qata Sure. \ud83d\udc4d . https://github.com/apple/swift-corelibs-libdispatch/blob/master/dispatch/queue.h#L537\nhttps://github.com/apple/swift-corelibs-libdispatch/blob/master/dispatch/queue.h#L563\n* The global concurrent queues have the DISPATCH_AUTORELEASE_FREQUENCY_NEVER\n* behavior. Manually created dispatch queues use\n* DISPATCH_AUTORELEASE_FREQUENCY_INHERIT by default.\n\nEdit: DISPATCH_AUTORELEASE_FREQUENCY_NEVER does not mean the autorelease objects are not being released. The threads backing the dispatch queues still have their own autorelease pool, and since GCD reuses threads, the autorelease pool is not guaranteed to be drained right away after the submitted block is done.\nSo .workItem makes sense in minimising the memory footprint. But note that it affects Objective-C objects only. Swift does not have the concept of autorelease pool.. Possibly?. Guess we should fix the existing script then.\n\ud83d\ude48 . Removed for now.. Result.AnyError would help in this case. It is an existential wrapper that stores any values that conform to Error.\nP.S. In the future (no ETA), when Swift existentials are self-conforming, AnyError can be deprecated in favor of just Error.. I'd call it  thebound or concurrent strategy. \ud83d\ude42. Implemented in #298.. There are four strategies for now: concat, exclusive, latest ~~and replay~~. ~~That said I am not quite sure about the implementation for now... Meant to use flatten but found it a bit of a hack to fit in.~~. @arnopoulos I do not have time to move this forward in the foreseeable future. \ud83d\ude1e. Not being actively worked on.. Many \u201cabuse\u201d buffer(0) when a Signal is the more appropriate choice, while some use cases of buffer(1) have already been covered by properties.\nThat\u2019s said I personally found buffering/replaying can be useful in some circumstances, e.g. deferring push notifications until the async re-authentication has completed.. Simply speaking, we may drop the need of CocoaAction and make things to read more natural when a transform from the control to the action input is involved. The proposal is introducing a \"action binding source\" kind of thing, which can be refined/mapped before binding e.g. UIButton -> UIControlState.. I have been thinking about this (with two-way bindings) lately, and apparently this would be better coupled with ReactiveCocoa.. There is one single internal property overseeing the state. So if you indirectly pipe isExecuting into the Action as the user-controled availability, it deadlocks.\nCould you share what you want to achieve, so that we may perhaps figure out an alternative?. One alternative I can think of is having both of them covered by the same Action, and differentiate the course of action by the input (e.g. an enum) instead. Then you can avoid this kind of slippery feedback loops.\ne.g.\n```swift\nacceptButton.reactive.pressed = CocoaAction(viewModel.submit) { _ in .accept }\ndeclineButton.reactive.pressed = CocoaAction(viewModel.submit) { _ in .delice }\nsubmit = Action(...) { course in\n    switch course {\n        case .accept: return acceptProducer()\n        case .decline: return declineProducer()\n    }\n}\n```\n\nMaybe we can allow that code, but somehow avoid deadlocking?\n\nIt is a general problem of (signal) recursion. IMO it should be covered because it is handy in some cases, but on the other hand it should be discouraged because reasoning it and implementing it correctly are hard.. I agree that some problems meant to be addressed by this are rather trivial in performance. Even if we do try to mitigate them, it can be done less complicated with recent changes.. controlEvents(_:) is a Signal emitting a reference to the UIButton upon the subscribed control events. You need to transform it to a Signal of Int, e.g. with map, before you can bind it to a MutableProperty<Int>.. You would need a new type that tracks the changes, something like ReactiveArray in ReactiveCollections. Another way is diffing  array \"snapshots\", say with IGListDiff in IGListKit.. Please use ReactiveSwift 1.1.0+.. Does the reference semantics matter though? We can even replace it today with a generic typealias Event<Value, Error> -> Void without breaking anything semantically, only syntactically.\nThe Observer wrapper is just delegating calls to its stored reference, and such act does not require any form of identity. Moreover, neither we store extra context that requires an identity (even if we do, the context can be a reference type), nor does observe(_:) care about the identity.. Though the point I've been trying to make is that the line should be whether the identity is needed, but not whether one uses reference semantic.\nAt its core, it is just an immutable collection of captures (values or references) plus a function pointer, which makes no difference from an immutable collection of references.\nYes, the context is reference counted behind the scene, but so as value type collections with their CoW buffers. The common theme between these two is the identity of their managed values not being the main concern, and the reference semantic is just an optimisation exploiting the immutability.. > A value type collection doesn't have identity, but its CoW buffer does.\nNot just the CoW buffer, but also the fact that they can contain references. They exercise value semantics over the references.. Something fun happened. When I (finally) did a synthetic benchmark on this, class-based observers are certainly faster, likely due to less copying during iteration (one vs two pointers). So this nullified my argument, because I once thought struct would perform better due to being stored in-place.\nTL;DR Next time I should profile first before making a point. Sorry for wasting the bandwidth on this. \ud83d\ude05. Closing this issue as agreed in https://github.com/RACCommunity/ReactiveCollections/pull/38 that ReactiveSwift should have no part in the collection binding effort.. It does with both -O and WMO. Tests passed too. That said the compiler segfaults on Linux.\n\ud83d\ude48. Guess we can work it around specifically for controlEvents(for:).. Type inference do not work if it is made as an extension to SignalProducer. If the concern of discovery is primarily in autocompletion, rather than documentation, these do not show up in the list at all, unless the type parameters are specified.\n```swift\nextension SignalProducer where Value == Date, Error == NoError {\n    public init(interval: DispatchTimeInterval, on scheduler: DateScheduler) {\n        self = timer(interval: interval, on: scheduler, leeway: interval * 0.1)\n    }\n}\nextension SignalProducer {\n    public static func timer(interval: DispatchTimeInterval, on scheduler: DateScheduler) -> SignalProducer {\n        return ReactiveSwift.timer(interval: interval, on: scheduler, leeway: interval * 0.1)\n    }\n}\nfunc test() {\n    let scheduler: DateScheduler! = nil\n    _ = SignalProducer(interval: .seconds(1), on: scheduler)\n//  _ = SignalProducer(interval: .seconds(1), on: scheduler)\n    _ = SignalProducer.timer(interval: .seconds(1), on: scheduler)\n//  _ = SignalProducer.timer(interval: .seconds(1), on: scheduler)\n}\n```\nIMO DateScheduler is a fair place to host it, since the timer is controlled by it.. @mdiep I have customized Jazzy to generate better docs for RAS and RAC, and looking for comments on the changes.\n\nMethods are now grouped by the extension constraints. Say skipNil is under Value: OptionalProtocol.\n\nNow: http://reactivecocoa.io/reactiveswift/docs/latest/Classes/Signal.html\n   New: https://andersio.github.io/ras-1.1.1/Classes/Signal.html\nBut since OptionalProtocol is more like an implementation detail until we have parametric extensions, the constraint is substituted by its parametric form <U> Value == U?. SignalProtocol, SignalProducerProtocol and EventProtocol are all substituted similarly.\nThe downside of grouping by constraints is obviously breaking the code-based organisation.\nOne possible alternative/complement is having all extension methods specifying its constraint in its name. So instead of skipNil() in the list, it would be shown as skipNil() where <U> Value == U?\n\n\nReactive extensions now get their own separate pages on a per-type basis, instead of all showing up under Reactive.\nNow: http://reactivecocoa.io/reactiveswift/docs/latest/Structs/Reactive.html\nNew: https://andersio.github.io/ras-1.1.1/Reactive%20Extensions/NotificationCenter.html\nYou can also check how the RAC docs would look: https://andersio.github.io/rac-5.0.3/.\nOne thing I am not sure about is whether these should show up as specialised Reactive, or just their base name e.g. Reactive<UIView> vs UIView.\nThe navigation does give them special treatment, i.e. \"Reactive Extension\". But however in Dash they show up in the tables of content as \"Extension\", since Dash doesn't allow custom entity type.\n. If you mean maintaining computed properties on Reactive as the current approach, it could read the simplest. But if we can have a generic solution that is close in legibility, it would considerably reduce our API surface.\n\n\nThe main drivers behind our current design (IIRC) were discoverability and type safety over KVC string key paths after all. Smart Key Path helps address the second, while the first one remains to be seen.. Implemented by https://github.com/ReactiveCocoa/ReactiveSwift/pull/440 and https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3489.. > Would it make sense to pass an inout [Disposable]?\nSwift doesn't seem happy about this.\n\n\nWe should think of a simpler name.\n\nDisposables? DisposableBag?. Sink sounds like a point of no return, while disposables are removable in our case. Collection on the other hand sounds weird since it cannot be traversed. That's why I picked Collector.\nLifetime can be used here too (proposed originally in #143), if it makes sense to you.\n\nThe cleanup for producers does not differentiate between cancellation and termination. The collected resources are disposed of when the signal is terminated regardless how it terminates.\nSo it (adding a disposable to the producer disposable) is actually a synonym of observing the termination of a Signal, just without affecting the Signal's lifetime like how a normal observer would be.. add returns a handle to remove them from the collection though.. Lifetime?. Yeah, but it isn't essential. += can be obsoleted in favour of observeEnded if we go after the Lifetime way.\n\nI proposed adding += to Lifetime in #229, but @sharplet and you weren't fond of it.. += and add taking a Disposable? are added to Lifetime to assist migration. These are marked as deprecated.. A side note: we may unify Signal.init under the same pattern.\nswift\nlet signal = Signal { observer, lifetime in\n    let disposable = self.observe { ... }\n    if let d = disposable { lifetime.observeEnded(d) }\n}. @nalexn \nThe producer doesn't get to complete. It is interrupted immediately. The problem here is that the piece of async work is always going to execute, because it is not bound to the Lifetime.\nobserver.sendCompleted in this code path is effectively a no-op, because at that point the produced Signal has been terminated due to the interruption.\nA slightly tweaked snippet to illustrate this:\n```swift\nlet mySignalProducer = SignalProducer { observer, lifetime in\n    lifetime.observeEnded {\n        print(\"> lifetime ended\")\n    }\n// MARK: A\nQueueScheduler.main.schedule {\n\n// MARK: B\n// lifetime += QueueScheduler.main.schedule {\n    print(\"> complete?\")\n    observer.sendCompleted()\n}\n\n}\nlet disposable = mySignalProducer\n    .logEvents()\n    .start()\ndisposable.dispose()\n```\nOutput:\n```\n[] starting fileName: ReactiveSwift.playground, functionName: __lldb_expr_19, lineNumber: 34\n[] started fileName: ReactiveSwift.playground, functionName: __lldb_expr_19, lineNumber: 34\n[] interrupted fileName: ReactiveSwift.playground, functionName: __lldb_expr_19, lineNumber: 34\n[] terminated fileName: ReactiveSwift.playground, functionName: __lldb_expr_19, lineNumber: 34\n[] disposed fileName: ReactiveSwift.playground, functionName: __lldb_expr_19, lineNumber: 34\n\nlifetime ended\ncomplete?\n```\n\nNow comment A and uncomment B. > complete? would be gone.. lifetime.hasEnded being false during the course is the expected behavior. The starting side effect runs synchronously when one invokes start(), and the produced Signal is being disposed of only after start() returns.. If you wish to be able to cancel it immediately and synchronously, you would have to adopt operators like take(until:) (with a producer) or take(during:), which would be able to terminate the produced Signal prior to the starting side effect being triggered.\ne.g. Try to apply take(until: SignalProducer(value: ())), and you should be able to observe lifetime.hasEnded being true in the starting side effect.. Note that this also means that the decision to cancel has to be made before start() given the synchronous scenario.. skip(while:)\n\nDo not forward any values from self until predicate returns false, at which point the returned signal behaves exactly like signal.\n\nYou should use filter instead.. It means, given self.skip(while: shouldContinue), that no value from self would be forwarded until shouldContinue returns false. Then from that point, all the values would be forwarded, regardless of the results of the shouldContinue.\nIt is a one-time toggling.\nhttp://reactivex.io/documentation/operators/skipwhile.html. Rebased.. Signal does not support sending values recursively, only terminal events. So doing:\nswift\n.flatMapError { error -> SignalProducer<Int, NoError> in\n       observer.send(value: 0)\nis bound to deadlock. Consider using ValidatingProperty which is specifically built for this purpose. If you need a quick start, check the ReactiveSwift-UIExamples.playground.. P.S. I think ValidatorOutput.coerced would fit this case. But one caveat is that ValidatingProperty considers coerced a valid value. So when determining whether the validation passes, you might need to interpret property.results differently (e.g. is success or (is coerced and has valid value), other than using the convenience instance properties.. The UI Example playground would be one.\n. Addressed all comments.. @mdiep https://github.com/ReactiveCocoa/ReactiveSwift/pull/345/commits/6ee1fe723f77e0f3c4978585c172ead1ef50045b probably still doesn't do what you asked, but it further encapsulates the unsafe implementation details in one place.\nI have no idea how to make nested calls possible, but I don't think it could be more compact than packing by hand as it is now.. Managed to find a way. But we would have to pull back repack in TupleExtensions.swift. It also takes 2n - 3 function calls for a n-arity operator to pack its results. This would cause unnecessary copying across the function call boundaries, since the compiler does not have magic to flatten ((...T), U) to (...T, U), and we have to manually un- and repack the tuples.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/345/commits/6ee1fe723f77e0f3c4978585c172ead1ef50045b (this PR) packs the tuple in one call regardless of the arity, since it is hardcoded. It is also space efficient, since the transform is a thin closure and does not need to capture closure references to repack stuff.\nIMO nesting isn't worth it.\n```swift\nstruct Builder {\n    private let count: Int\n    private let transform: (ContiguousArray) -> Composite\nfunc append<U, NewComposite>(_ signal: S<U, E>, _ pack: @escaping (Composite, Any) -> NewComposite) -> Builder<NewComposite, E> {\n    let transform = self.transform\n    let count = self.count \n    return .init(count: count + 1) { pack(transform($0), $0[count]) }\n}\n\n}\nlet _: Builder<(A, B, C, D, E), E> = Builder<(A, B), E>(a, b)\n    .append(c) { ($0.0, $0.1, $1 as! C) } // or use repack.\n    .append(d) { ($0.0, $0.1, $0.2, $1 as! D) } // or use repack.\n    .append(e) { ($0.0, $0.1, $0.2, $0.3, $1 as! E) } // or use repack.\n```. I feel like https://github.com/ReactiveCocoa/ReactiveSwift/pull/345/commits/6ee1fe723f77e0f3c4978585c172ead1ef50045b is pretty close, except for not being in the same place.\nswift\nextension Signal {\n    private convenience init<Strategy, A, B, C, D>(_ strategy: Strategy.Type, _ a: Signal<A, Error>, _ b: Signal<B, Error>, _ c: Signal<C, Error>, _ d: Signal<D, Error>) where Value == (A, B, C, D), Strategy: SignalAggregateStrategy {\n        self.init(AggregateBuilder<Strategy>().add(a).add(b).add(c).add(d)) {\n            return ($0[0] as! A, $0[1] as! B, $0[2] as! C, $0[3] as! D)\n        }\n    }\n}. The type checker works in this context:\nswift\nfunc attempt(_ operation: @escaping () -> Result<String, NSError>) -> SignalProducer<(), NSError> {\n    return SignalProducer.attempt(operation)\n        .on(started: { started += 1 })\n        .map { _ in }\n}\nBut not if the Result has a type of AnyError:\nswift\nfunc attempt2(_ operation: @escaping () -> Result<String, AnyError>) -> SignalProducer<(), AnyError> {\n    return SignalProducer.attempt(operation) // Ambiguous use of `attempt`.\n        .on(started: { started += 1 })\n        .map { _ in () }\n}. The problem is that the type checker can infer Value to be Result<Value, Error>, or Value inside the Result. Both are valid to form the return type, which is now ambiguous. This overload does not solve the ambiguity.. As a side note (mentioned on Slack), there is a workaround for attempt to work without ambiguity:\nswift\npublic protocol _AnyError {}\nextension AnyError: _AnyError {}\nextension SignalProducer where Value: _AnyError { ... }. ReactiveCocoa is not included though.. Opened PR: https://github.com/apple/swift-source-compat-suite/pull/12. The initial list does not include any tests though, only builds.. Merged.. Implemented in #351.. Swift does not define a memory model yet, and does not guarantee C memory semantics except for unsafe memory primitives that guarantee interoperability with C. Signal.state assumes the presence of C memory semantics, and the pointer-size enum must be packed before being stored for atomicity.\nSo these are kind of a precaution, since if the Swift compiler breaks this somehow, it could corrupt in a concurrent environment.\nRelated: #137 \n// The storage of the state.\n//\n// Since Swift stored property accesses do not guarantee atomicity due to possible\n// compiler-generated conversions and reabstractions, a manual allocation via\n// `UnsafeMutablePointer` is made to ensure C-like memory semantics.\n//\n// Related: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20161205/004147.html\nThat said I have emailed to ask if withUnsafeMutablePointer on a final stored property can achieve the same effect. Apparently with optimisation flags the generated code is ideal, but I am not sure about the behaviour with no optimisation due to Swift's default semantic of inout.\nGonna investigate further before reopening this.. (Paranoid mode: OFF)\nJust checked the generated source of debug builds in Swift 3.1. It does generate a pointer size store with the packed pointer, and is probably safe from changes given that enums with only pointer payloads are given a special treatment. So apparently this is unnecessary.. Hmm perhaps we can call ExpressibleBySignalProducer Observable instead. :see_no_evil:. I think the problem in general is that extension Signal: SignalProducerConvertible or extension Signal: SignalProducerRepresentable is kinda ambiguous because of the lack of perposition. The protocol here is also a one-way ticket.. Hmmmmmmm. True.. @mdiep The removal of SignalProtocol and SignalProducerProtocol was an oversight of mine and has been reverted, since they are still useful until we have parameterised extensions. e.g. ReactiveCollections use it to constrain generic delta producers for collection view bindings.. It is just the changelog. \ud83d\ude97. Using Property and MutablePropertywould always send the current value. What is self.birthdayDate?. Since you mentioned Core Data, using DynamicProperty or producer(forKeyPath:) does not fire a fault.\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/pull/3309. It should not be necessary. When you bind a property to another, the current value is guaranteed to propagate immediately.\nOf course except when birthdayDate is (derived from) a DynamicProperty, and is sourcing from an NSManagedObject.. Not really. What I mean is if self.birthdayDate is a MutableProperty or Property, <~ should write the current value immediately as the binding is established. Since you use map, it should not change the guarantee at all.\n```swift\nlet date = MutableProperty(Date())\nlet age = MutableProperty(\"\")\nage <~ date.map { date in \"(date)\" }\nprint(age.value) // PRINT: The current date.\n``. If what you do is likebirthdayDate <~ managedObject.reactive.producer(forKeyPath: ...), wrap it withmanagedObject.{will|did}AccessValue(forKey: nil)`.\nYou can also copy the extension in https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3309, which is better since it filters all the nils emitted by KVO when the object is a fault, and when it is being turned into a fault.. |Item|bag-refactor|master|\n|---|---|---|\n| Copying, 32768 elements | 0.034 ms | ~0.626 ms |\n| Iteration, 1 element | 10 ms | 13 ms |\n| Iteration, 128 elements | 407 ms | 794 ms |\n| Insertion, 100000 elements | 19 ms | 30 ms |\n| Fast Path Removal, 32768 elements | 30 ms | 20 ms |\n| Worst Case Removal, 32768 elements | 304 ms | 24258 ms |\n| Signal Delivery, 16 observers, 100000 events | 119 ms | 195 ms |\n| Worse Case Observer Detaching, 128 observers | ~0.7 ms | >1 ms |\nBenchmark Source\ni5 6360U, Xcode 8.3.2, Compiled with -Owholemodule.. @mdiep The rewritten benchmark. It is either operations on 1 or 8 reference-counted elements/observers, running for 2 million samples. Compiled with -Owholemodule.\nbag-refactor\n@testAverageRemoval(): avg 9863 ns; min 8663 ns\n@testCopying(): avg 1683 ns; min 1452 ns\n@testDisposableDetachment(): avg 33346 ns; min 29684 ns\n@testFastPathRemoval(): avg 8831 ns; min 7653 ns\n@testInsertion(): avg 6118 ns; min 5299 ns\n@testIteration(): avg 452 ns; min 393 ns\n@testIterationOfOne(): avg 155 ns; min 122 ns\n@testSignalDelivery(): avg 749 ns; min 651 ns\nmaster\n@testAverageRemoval(): avg 9476 ns; min 8332 ns\n@testCopying(): avg 1315 ns; min 1145 ns\n@testDisposableDetachment(): avg 27795 ns; min 24664 ns\n@testFastPathRemoval(): avg 7781 ns; min 6696 ns\n@testInsertion(): avg 6199 ns; min 5234 ns\n@testIteration(): avg 906 ns; min 797 ns\n@testIterationOfOne(): avg 189 ns; min 159 ns\n@testSignalDelivery(): avg 1151 ns; min 988 ns\nIterations are no doubt faster even at small element count \u2014 this alone is enough to justify the PR IMO. Insertions are not leading significantly here, despite showing a huge gap in the original benchmark with large iteration count above.\nRemovals and copying are slower, and the assumption is that https://github.com/ReactiveCocoa/ReactiveSwift/pull/354/commits/d6e525f42c5e8ebeb52a7507614395098f0516af leads to more work for these two operations. That said these are just one-time occurrence for every observation, and way less important than the iteration performance.. Iteration alone is already fairly relevant, if one considers the multiplicative effect in composed signal graphs. Edit: For sure it is negligible in low-frequency paths, but then in high speed scrolling it is increasingly relevant with the amount of signals that were pulled by the collection/scroll view.. I considered it qualifying both conciseness and speediness, after removing the opaque token type and the binary search. Pretty clean and straightforward, isn't it? :)\nStepping aside from any claim in performance, the core of the PR is replacing the object token with a UInt64 token. Could we at least agree on getting rid of a bunch of retains and releases per element being a plus?\n\nBut these seem like very low overhead. Will having from 906ms to 452ms really make a difference when scrolling a collection/scroll view?\n\nI can't say it makes a difference on iOS given the practical amount of information expected to fit in the screen real estate with a reasonable scrolling speed. But together with cuts here and there, they could stack up to a considerable portion of CPU time, say on Mac when one has a dense collection view. Moreover, it isn't too bad to save some joules, is it?\n\nP.S. I am not sure how common one would use Signal.merge with hundreds of inner signals. But say if this example has inner signals come and go quickly in a random pattern, binary search in remove(using:) beyond a certain threshold might help.. \nThe rule of active observers keeping the Signal alive remains unchanged, but the means to achieve it has changed:\n\n\nIn 1.x, it is done via the self reference in AliveState. The self reference is cleared when the observer bag is emptied, which triggers the deinitialization that leads to the disposal of the generator disposable.\n\nBag emptied => Clear last strong +1 => Signal deinit => Disposal\n\n\n\nIn this PR, the self reference is replaced by the strong +1 of the generator observer. It is assumed to be retained by the owner or the upstream. For derived signals, it is also assumed that the generator disposable would be responsible of removing the generator observer from the upstreams (as it is used to be).\n\n\nThe Signal.Core disposes of its generator disposable when shellDeinitialized is asserted and the observer bag is emptied. This would indirectly leads the upstream, if any, to remove the generator observer from its bag. As the generator observer eventually deinitializes, the last strong +1 on the Signal.Core ceases.\n* Bag emptied & Shell deinitialized => Disposal => Last strong +1 gone => `Signal.Core` deinit\n\n\n\nIn other words, the rule of automatic disposal is now expanded to be (1) having no observer and having no external retain; OR (2) having the generator observer deinitialized\".\n\nCan you explain this a bit more? I haven't looked over the code, but I'm not sure when this would happen.\n\nThis change does not affect operators, since they have their generator observer retained by the upstream signals. Only the explicit, non-composition uses of Signal.init and Signal.pipe would be affected.\nSay we have a pipe and we have observed it:\nswift\nfunc scope() {\n    let (signal, observer) = Signal.pipe()\n    signal.observe { _ in }\n}\nIn 1.x, the self reference asserted by the sole active observer would keep the Signal alive.\nWith this PR, the Signal.Core would lose all both of its retains as scope() returns, so the signal would dispose of itself. This is a new but IMO logical behaviour, given that the missing generator observer means no event can be further sent statically.\nWe may consider emitting interrupted since there are still active observers in this case. But for now it is silent.. > Would it work to replace the self reference with an actual strong reference from the observer to the signal? That seems like it would maintain the existing semantics (which are conceptually simpler IMO) but also fix the tooling issues.\nIt does not solve the issue of deliberate retain cycle being caught with the current implementation.\nSpecifically, if an observer now holds a strong reference to the Signal, it forms a legit retain cycle. We cannot break the cycle with a weak reference from the Signal to the observers, as the Signal retaining observers is pragmatic.\n------------               --------------                --------\n |          |               | endObserve |                |      |\n |          | <~~ weak ~~~  | disposable | <== strong === |      |\n |          |               --------------                |      | ... downstream(s)\n | Upstream |                ------------                 |      |\n | Core     | === strong ==> | Observer |  === strong ==> | Core |\n ------------ ===\\\\          ------------                 -------- ===\\\\\n                  \\\\         ------------------              ^^        \\\\\n                   \\\\        | Signal (shell) | === strong ==//         \\\\\n                    \\\\       ------------------                          \\\\\n                    || strong                                            || strong\n                    vv                                                   vv\n            -------------------                                 -------------------\n            | Other observers |                                 | Other observers |\n            -------------------                                 -------------------. A side note: I have tried many tricks, hoping to trick the memory debugger not to recognise the retain cycle. But none of these works.\n\n\nA Unmanaged pointer.\n\n\nA UnsafeMutablePointer pointer.\n\n\nAn OpaquePointer.\n\n\nStoring a UnsafeMutablePointer as a raw Int.\n\n\nStoring a UnsafeMutablePointer as a raw Int that is right shifted by 1 bit.\n    This does \"break\" the retain cycle in the debugger, but the debugger still considers it a leak.. MutableProperty should not deadlock occasionally fails on single-core CI. \ud83d\ude48. What you want is probably flatMap(.latest). The concat strategy does not start forwarding from the next enqueued signal, until the current one has terminated.. You can capture the provider with the producer in any way you like, e.g. on(disposed: { _ = provider }).. 1. The Action uses init(input:) (to be renamed as init(state:)), and it requires the Action not taking any input from external callers i.e. Action<(), _, _>.\n\n\nvalidatedEmail is a property of validated email or nil. That means if everything in the form is validated \u2014 that is, emailConfirmation passes validation and termsAccepted is asserted \u2014 it would emit the validated email. Otherwise, it would be nil.\nIt is used in conjunction with init(input:) so that the Action is disabled when the property is nil.\n\n\nAn updated version, if it helps.. This is not based on master, but 1.1.1.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/compare/1.1.1...hotfix-1.1.2. It was an artefact of the binding implementation. SignalProducer.observe(_:during:) has been removed in #359 as part of the next major release (2.0). Thank you for bringing this up anyway. \ud83d\ude3a . The main theme of 2.0 is cleaning up the APIs here and there. If you encounter other APIs that seem inconsistent or not making sense at all, feel free to bring it up. \ud83d\ude38 . I guess it'd be better to follow Apple's suit.. Thanks. \ud83d\ude38 . /cc @ReactiveCocoa/reactiveswift . (Didn't feel the extraction of operators helped). We can use Never.. Hmm, NoValue reads better though. Moreover, Never for now is just intended for return types, and it is not yet a real bottom type.. Never is just NoError (uninhabited type) with a bit compiler sugar AFAIK.. flatMapError could use Never. \ud83d\ude42 e.g.\nswift\nSignalProducer<Never, E1>.flatMapError -> SignalProducer<U, E2>\nWe can also add an equivalent of promoteError for Never.. ~~Ah, and a new overload of startWith* and observe* that returns a Result<(), Error> (completed or failed).~~\nJust found that the conventional start is enough by asserting event.error.. I am not quite sure about initialiser vs operator at this point, but I do see the value of Action composition.. I am personally interested in operators (or initializers?) transforming or trivialising input, output and error, and I think these could help impose encapsulation. Let's see how we can push this forward.. Property received 0\nSkip-Repeats property received 0\nSetting new value for property: 3\nSkip-Repeats property received 3\nProperty received 3\nNothing seems wrong.. The Signal contract does not guarantee observers to be ordered with regard to each other. That said the implementation calls out the observers in observation order.\nIn this case, skipRepeatsProperty is the first observer to property, followed by the observer with print to property. So any observer to skipRepeatsProperty would get called first.. Note that the latest Swift 3 compatible release is 1.1.3.. Looks like the playground could be out of date if you are working with master.. @mdiep Sadly as a new init it would be ambiguous given the tuple splat behaviour. The only option not to wait for 3.0 is exposing it as static function.. Merge it for now.. Yep. Note that #301 is also relevant.\nIt does look interesting to me, esp. Action(first:then:). But it would also be great if you may share how these fit into your needs, since sometimes there could be alternatives that also make sense.. @brow Yeah. @ikesyo has also talked about it. Feel free to start a PR if you want. \ud83d\ude38. No apparent benefit for now. Ideally this would allow the compiler to \"see through\" the interface and perform specialisation. But it doesn't because we do not have cross-module optimisation (yet).\nAuto-promotion of existentials to generic parameters is one of the ABI stability items, btw.. The problem is that the inconsistent direction. <~ is used to have the observer as LHS and the source as RHS. lifetime <~ disposable is the inverse of this.. Implemented in #482.. Could you add a job for the Swift 3 compatibility mode?. (Unrelated to the PR) The lost of implicit 1-tuple destructing makes me wonder if we need to introduce sth like combineLatestMap or zipMap. \ud83e\udd26\u200d\u2642\ufe0f. You can treat it as a neat shorthand like prefix(value:) kind of stuff.\nSay then one got a bunch of composition:\nswift\nproducer\n    .flatMap(.once, workA)\n    .flatMap(.once, workB)\n    .flatMap(.once, workC)\n    .flatMap(.once, workD)\nIt looks much more intuitive than:\nswift\nproducer\n    .take(first: 1).flatMap(.latest, workA)\n    .take(first: 1).flatMap(.latest, workB)\n    .take(first: 1).flatMap(.latest, workC)\n    .take(first: 1).flatMap(.latest, workD)\nIt is true that such strategy is practically useless if we for sure know at runtime producer would send one value. But stronger constraints are always nice to have if it is general enough IMO, and I believe flatMap just for once is pretty common.\nSaving a signal for the strong take(first: 1) assert could count as a side benefit.. @mdiep I think once has a leverage if it would propagate any interrupted event from inner signal. I actually ran into a complicated issue caused by mimicking once using existing flatten operators which do not propagate interrupted.. It is especially important if we do treat interrupted being more than downstream cancellation. In my case, it is a custom take(until:) like operator that conditionally cancels network requests. With latest and concurrent applied after the custom operator, it just completes when it isn't supposed to be.. Well apparently take(first: 1).flatMap(.race) can achieve the expected semantic for a once strategy.. Heh, leaving it as is is probably the best solution after a second thought. We could still add sth like apply(_:disabledError:) -> SignalProducer<Output, Error> though. \ud83d\ude42. I think it needs better error message to tell that ignoring the error message would trap at runtime & also fill in the blanks for fatalError.. @mdiep Please check. The error message are written in reduced written register btw, following the swift stdlib style.. Eww.. IIRC I tried to remove them, but Swift 3.1 complains about it.. (Irrelevant to this PR) I hope the Swift gurus manage to get key path decomposition into 4.0. With it we can make MutableProperty capable of doing automatic KVO. \n\ud83d\ude40\ud83d\ude40\ud83d\ude40\ud83d\ude40\ud83d\ude40\ud83d\ude40\ud83d\ude40 . https://github.com/apple/swift-evolution/blob/master/proposals/0151-package-manager-swift-language-compatibility-version.md\nLooks like this is the way for a 3.2 build. . Instead of changing apply() to apply(()), we should fix it by adding an overload for Input == Void.. AFAIK no.. RAC would provide convenience init that fills the lifetime with lifetime(of: object). This in turn allows us to implement #331 in RAC to replace all explicit BindingTargets. \nThat said, it needs to take in consideration with the <~> initiative, since we might want to do it with value and action bindables too.\n. Note that ValidatorOutput is renamed to be Decision.. ~~Note that PropertyProtocol.diff is disabled for Swift 3.2/4.0 due to a compiler bug with Xcode 8.3.3. It can be reenabled as soon as Xcode 9 is available.~~. Working on adapting the diffing algorithm for two-level nested collections, but it shouldn't block this.. @mdiep Given the scale of our community and my personal experience with ReactiveCollections, I am against evolving externally. If we are not going to commit to it yet, we can either declare these as experimental, or maintaining a feature branch given its additive nature (very low chance of conflicts).\nLet alone the very fact that ReactiveSwift in its fairly mature state doesn't have a high volume that could distract (or be distracted by) the collection effort.\nIt can be reasonably done in smaller pieces alongside the mainline development. #322 proposed a series of small steps to achieve this very goal of collection support.. ICYMI: https://github.com/ReactiveCocoa/ReactiveSwift/pull/444#discussion_r129304837. > The problem with a feature branch is that it's hard for people to use it. So you can't get the same level of feedback about the APIs. Frameworks benefit from real world usage because it informs the design of the API.\nNeither would a split help IMO. No spotlight, low volume, and most users are not going to use something that isn't mature. Let alone making contribution. That's what ReactiveCollections ends up to be (regardless of its focus).\nWe can always make staging releases alongside the mainline releases and pre-releases, which effectively gives us the same result.\n\nIt's not that I'm worried about distraction. If we want to make a breaking change to collection diffing, do we (1) wait for a breaking release of ReactiveSwift or (2) make the next release a major version so that the collection diffing can have a breaking change?\nNeither of those is a great option. (1) means that these APIs evolve more slowly than they could otherwise. (2) makes upgrading harder for everyone who uses the framework.\n\nNot that I disagree with the rationale.\nBut let's say even if we fast forward it and drop it into 2.1 today, I'd argue that the risk for needing a breaking change is low, because this particular domain is well-established with well-understood premier use cases.. To be transferred back to ReactiveCollections.. https://github.com/RACCommunity/ReactiveCollections/pull/34. \ud83e\udd14\nHaven't considered optionals. That said we can use this just for combinePrevious(), and keeping the original combinePrevious(initial:) so that combinePrevious(nil) would work as is.\n\nsince this can be replicated with skip(first: 1)\n\nNot quite if you consider how many extra hops needed for U to U? to (U?, U?) to (U, U) (probably less with a filterMap, but still).. @sharplet Thanks for pointing out the previous discussion. My responses to @NachoSoto's arguments:\n\nOne of the combinePrevious implementation is not implemented in terms of the other.\n\nBoth share the same implementation in this PR.\n\nThis operator is redundant: the existing combinePrevious is more general. You can accomplish the same thing by doing something like producer.combinePrevious(nil).skip(1).\n\nFrom Signal<U, E> to precisely Signal<(U, U), E> with the current combinePrevious, one has to jump through multiple hops:\nswift\nvalues // Signal<U, E>\n    .optionalize() // Signal<U?, E>\n    .combinePrevious(nil) // Signal<(U?, U?), E>\n    .filterMap { $0.0 != nil && $0.1 != nil ? ($0.0!, $0.1!) : nil } // Signal<(U, U), E>\nwhich is hardly sane. Moreover, as shown in this PR, combinePrevious() with an optional initial value is actually the most general version, as it backs the original combinePrevious(_:) in a generic context by exploiting the fact that optionality of Value is opaque.. Reentrancy of MutableProperty is supported only for reads. So whenever an observer of a MutableProperty writes to the property synchronously, it deadlocks.\nFor the code snippet at the beginning specifically, the actions <~ actions.signal[...] is apparently an infinite feedback loop, since MutableProperty does not deduplicate values \u2014 it sends an event whenever you call the setter.\nFor the Redex feedback path from the UI back to the store, I'd recommend to avoid Property and use Action (if you need mutual exclusion) or just plain Signal like how @brow suggested. Apparently, the user interaction just needs to be pushed to the store (where the state is owned). So storing it is likely unnecessary.. No performance difference is measured.. Not ready yet... There is a mysterious race that was once fixed with the current lock-free design that I cannot wrap my head around.. In the codebase I'm working on, this is a recurring issue in our interactive view models (e.g. forms), requiring us to specify the closure input type explicitly to get the unwrapping overload.. Speed stat\nSource (the Signal version), x86-64, i5 6250U\nNote: ARMv8 might have a slightly different characteristics.\n```\n// this branch\n@test(): avg 1725 ns; min 1449 ns\n// this branch without the atomic counter tracking pending state updates\n// (always lock on observer read)\n@test(): avg 1900 ns; min 1613 ns\n// (locking also on terminating check)\n@test(): avg 3054 ns; min 2514 ns\n// master\n@test(): avg 1260 ns; min 1039 ns\n// #453\n@test(): avg 2376 ns; min 2045 ns\n```\nHmm, investigating the mysterious bump.. It turns out that locking on the hot path with https://github.com/ReactiveCocoa/ReactiveSwift/pull/456/commits/1ad25242a10f355805b369fb707374f5023070cb is less harmful than undoing the inlining of updateLock and the state storage, or the solution I initially pushed.\n\ud83e\udd26\u200d\u2642\ufe0f\n+281 \u2212192 vs +9 -6.\n@test(): avg 1350 ns; min 1104 ns\nKudos to os_unfair_lock.. Since both reads and writes now are locked in all circumstances, the two state box types can be removed. This pushes the overhead down to the current level.\n\ud83e\udd26\u200d\u2642\ufe0f\n@test(): avg 1276 ns; min 1045 ns\n@test(): avg 1249 ns; min 1043 ns\n@test(): avg 1250 ns; min 1043 ns\n@test(): avg 1229 ns; min 1043 ns\n@test(): avg 1269 ns; min 1039 ns\n@test(): avg 1244 ns; min 1051 ns. (Fun fact: Swift 4 runs everything slower by ~100ns.). True. This sounds a more scalable approach, in the sense that we may also assert a dispatchPrecondition with it & reuse it for all cases.. Yes, that was the reason @mdiep blocked the race strategy (#233) from merging into 1.1.x to be semver compliant.\nEven if extensible versioned enum (note: library evolution) eventually lands in Swift, FlattenStrategy is meant to be consumed internally, so the opaqueness introduced here should not be an issue.. @mdiep Sadly, it would be still kind of a minuscule leak (the signal and the core), but at least the observers and disposables are released.. Implemented.. Thanks!. @liscio results maps value to Result.success and failed to Result.failure.. It doesn't appear to be the case.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Flatten.swift#L692. Apparently the documented semantic is first to send an event wins the race. So the implementation is right.. @mdiep No because the command didn\u2019t work back when the playground was introduced.. Not being actively worked on.. Hey, thanks for catching these! \ud83d\ude38 . It looks natural, but .bind(to:) is kinda misleading in the context. I would suggest dispose(when:).. I think it is a reasonable mental model. If you don't specify anything, it is disposed of immediately. If you specify whenEnded, it is disposed of at a certain point in the future.. It is not as simple as ignoring. If I need to expose the full Action, the cell VMs need to be parameterised with Output and Error.. Say given a cell view model:\nswift\nfinal class ActionCellViewModel: FormComponent {\n        let isPressed: ActionInput<()>\n}\nwith a form view model:\n```swift\nfinal class ProfileViewModel {\n    enum Event {\n        case showConfirmation(TransactionDetails)\n        case showAlert(AlertDescription)\n    }\nlet events: Signal<Event, NoError>\nlet eventsObserver: Signal<Event, NoError>.Observer\nlet formComponents: [FormComponent]\nlet submit: Action<(), Event, NoError>\n\ninit() {\n    submit = Action(...) { ... }\n\n    // Pipe the action results to the VM event bus.\n    submit.values.observe(eventsObserver)\n\n    // Define the form.\n    formComponents = [ActionCellViewModel(isPressed: submit.input)]\n}\n\n}\n```\nWithout ActionInput, currently we are forced to define Action<U, Never, NoError> (where U is usually ()) for anything bound with UI controls, or wrap one as such if the entity doesn't own the Action.\nIn the former case, that isn't particularly bad, but we are forced to pull in side effects to capture/transform the results. For example, in the code snippet above, eventsObserver would have to be called in the body of the Action if it is defined as Action<U, Never, NoError>.\nIn the later case, ActionError.disabled of the inner Action is just dropped when it isn't supposed to be, because of the limitation of the Action API (or otherwise it has to be Action<U, Never, ActionError<NoError>>).. To put it in another way, this is a BindingTarget that can tell if it is enabled or not.. Close it for now. I assume the ability to ignore output (Never) and transforming error would be a more generalised solution. In the end, what I'd like to achieve is that any arbitrary Action can be represented as Action<U, Never, NoError> for the purpose of binding. \ud83e\udd14. I just realised while this was on my queue, I had managed to find some other sensible ways to avoid retrying Actions. So it shouldn't be upstreamed at all. Close it for now. \ud83e\udd26\u200d\u2642\ufe0f . Thanks for catching these. \ud83d\ude05 . This is not ready though. It needs way more changes so that not only direct observation to constant SignalProducers is benefited. \ud83d\ude15 . Some interesting numbers:\n```\n@testSequence(): avg 15598 ns; min 14388 ns\n@testFlatMapSequence(): avg 152921 ns; min 137964 ns\n@testValue(): avg 660 ns; min 591 ns\n@testFlatMapValue(): avg 54609 ns; min 49320 ns\n``testFlatMapSequenceis basicallytestSequencebut in the form of[2, 4, 8, 16].flatMap { repeat 1 for $0 times }`.\n:/. Heh, the compiler gets stuck.. @mdiep \nFor SignalProducer(value:), the allocation of a non-atomic SimpleDisposable contributes a ~30% overhead w/ WMO.\n@testValue(): avg 546 ns; min 475 ns\n@testValue(): avg 388 ns; min 325 ns\n```swift\ninternal final class _SimpleDisposable: Disposable {\n    var isDisposed = false\nfunc dispose() {\n    isDisposed = true\n}\n\n}\n```. The cost of sequence backed producers is slightly up with the implementation being corrected in https://github.com/ReactiveCocoa/ReactiveSwift/pull/487/commits/56131fc38db512af012515c80c750d5308cc582f, but the difference is trivial given its scale.\nThe comparison in UnsafeAtomicState.is has been relaxed too to help with the sequence backed producers. The barrier is redundant with tryTransition already issuing one. The CAS is redundant because the read is already atomic on all supported platforms.\nAll other constant producers still use NopDisposable.\n@testEventTransformingCoreMapFilter(): avg 6091 ns; min 5250 ns\n@testSequence(): avg 13277 ns; min 11720 ns\n@testValue(): avg 369 ns; min 317 ns. Could you please update also the Darwin snapshot?. These are unfortunately deliberate. Swift doesn't provide means for library developers to do only public deprecations.\nHowever, if you are using the latest version of ReactiveCocoa 5.x and ReactiveSwift 1.x, the warnings should have been suppressed when building via CocoaPods and Carthage.. It doesn\u2019t need to be in changelog, since it is not relevant to the public API.. No idea. \ud83d\udc81\u200d\u2642\ufe0f. master and default type for Error:\n\nThis branch:\n\nIt seems somehow the problem isn't severe in master now. But I did manage to blow it up to minutes in #444 when dealing with some compiler nonsenses. \ud83d\ude48 . I am not convinced that it is source breaking.. blocking imperative operators can be turned into async methods?. With the same test from #487, the overhead has increased slightly on the explicit map-then-filter test by ~800ns, which adds 13% CPU time.\nThat said I expect the overhead to be constant regardless of the depth of transformation, as mentioned in the PR description. Moreover, the significant speedup over lifted operators is still maintained.\nThe constant producer test has also been affected, likely due to the change with SignalProducerCore.start.\n@testEventTransformingCoreMapFilter(): avg 6824 ns; min 6010 ns\n@testSequence(): avg 13235 ns; min 11770 ns\n@testValue(): avg 417 ns; min 361 ns. > 1. Can you add the sample code above as a test?\nIt is a reduced form of an existing test case \"should evaluate lazily\", which uses SignalProducer.init(value:), repeat, take(first:) and single.\n\nDoes this affect the other take operators? (take(until:) and take(during:))\n\nOnly take(first:) is changed for now. So no for the two listed cases, but yes for any operator that uses take(first:) e.g. single.\nThe additional machinery is to further enforce on TransformerCore the API contracts we have. Specifically:\n\nNo event should be delivered after a terminal event has been sent; and\n(Implicit) Termination leads to disposal of the upstreams (if any) immediately.\n\nIt works for the four pilot operators (map et al) without enforcing these contracts, because these do not involve transformation on the event kind. take(first:) however involves a potential value to value plus completed transformation.\n\nDoes this affect other operators that send terminations? (sample(on:), timeout, etc.)\n\nNo. This change is specific to TransformerCore. An operator is untouched unless it is backed by TransformerCore, or it depends on a TransformerCore operator.\nSo far: map, mapError, filter, filterMap and take(first:).. cc @liscio . It appears that async operators are eligible for TransformerCore too, since TransformerCore does not rely on synchronous return values, and the Scheduler contract guarantees serial execution.. The official word is uninhabited. \ud83d\ude48 . @sharplet @mdiep . @mdiep I think now it has a case of performance, despite not practically relevant, in the sense that the take-once constraint enables simpler implementation. \ud83d\ude1b\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/516/commits/8cccb07dd3565f3994d99067749a5ec882a60d64#diff-c949eaeac664030204497a79420aaef3R866. I am not quite convinced to have it as a dedicated type, since there is barely a compile time advantage AFAICT. From the static enforcement PoV, Single cannot do better than SignalProducer since it is impossible to statically guarantee an escaping closure to be invoked only once.\nTo facilitate it, we would also have to replicate the entire API of SignalProducer given the lack of HKT. In the end, all we gain for all these work and on going maintenance are probably just a strategy-less flatMap, perhaps a specialised input observer API that accepts value or error, and a dedicated type name that benefits from a doc PoV. Dynamic enforcement in debug builds could also be a feature.\n. > a dedicated type name that benefits from a doc PoV\nI guess this alone could be the primary driver though, since that's also how the division between Signal and SignalProducer started despite having minimal distinction at static time.. Thanks for catching it! \ud83d\ude42. I am not sure if ignoreError ever exists in the mainline. You probably got it from Rex.\nignoreError is essentially a convenience of:\nswift\nproducer.flatMapError { _ in SignalProducer<U, NoError>.empty }\n. Does it consistently happen with all the use of startWithResult? :|. It does look more like a Swift issue than a RAS specific one. I recommend creating a reduced test case and submit it to bugs.swift.org instead. \ud83d\ude15 . \ud83e\udd14 ping @ReactiveCocoa/reactiveswift . We can bump straight to 3.0 if this is a huge concern.. Dropping startWithSignal could fail #563. Might need to expose the core's start in a way, so that the upstreams get to be disposed of prior to the starting side effect (akin to startWithSignal).. Please provide the stack trace or a reproducible test case if possible. . I realize that this effectively turns Signal into a queue-drain model for all cases. Perhaps this should be an opt-in behavior.. > I'd like to see more justification for why is useful and a good idea.\nA unidirectional data flow akin to Elm, RxFeedback or ReactiveFeedback usually comprises of three components:\n\nThe current state\nA reducer computing the new state from the current state and a message.\nMultiple observers of the current state that emit messages conditionally.\n\n,--------------------------------------------------,\n   |                                                  |\n   `--> ,---------, Sn+1     ,-------------------,    |\n        | REDUCER | ---*---> | FEEDBACKS/UPDATES | ---'\nSn ,--> '---------'    |     '-------------------' Msg/Event\n   |                   |\n   '-------------------'\nTo implement it using Signal in ReactiveSwift, as a feedback loop exists, it is prone to deadlock because the feedback path could be triggered synchronously, effectively constituting a recursion in value delivery which Signal prohibits.\n```swift\nlet reducer: (State, Event) -> State\nlet feedbacks: [(Signal) -> Signal]\nlet (stateRelay, stateRelayObserver) = Signal.pipe()\n// Construct the Feedback <-> Reducer feedback loop.\nSignal.merge(feedbacks.map { $0(stateRelay) })\n    .scan(into: initialState, reducer)\n    .observe(stateRelayObserver)\n// Bootstrap the system.\nstateRelayObserver.send(value: initialState)\n```\nIt is possible to mitigate all potentials of deadlock by forcing all feedback paths to be asynchronous. But I think we could offer something better than that, and stick to the \"synchronous by default\" principle of ours.. ~~I think we might be able to approach this in a more general form without explicitly adding recursive delivery to Signal. But I need to validate the idea first.~~. It doesn't seem to solve the issue completely. For it to work consistently, the queue-drain strategy needs to be enabled in all nodes of the cyclic Signal graph.. Seems like the test has failed to be built on Linux.\n/home/travis/build/ReactiveCocoa/ReactiveSwift/Tests/ReactiveSwiftTests/FoundationExtensionsSpec.swift:102:59: error: cannot invoke 'equal' with an argument list of type '(DispatchTimeInterval)'\n expect(DispatchTimeInterval.seconds(Int.max) * 10).to(equal(DispatchTimeInterval.never))\n ^\n/home/travis/build/ReactiveCocoa/ReactiveSwift/Tests/ReactiveSwiftTests/FoundationExtensionsSpec.swift:102:59: note: overloads for 'equal' exist with these partially matching parameter lists: (T?), ([T : C]?), ([T]?), ([T?]), (Set<T>?)\n expect(DispatchTimeInterval.seconds(Int.max) * 10).to(equal(DispatchTimeInterval.never))\n ^. Thank you for your work. \ud83d\ude38 . @soxjke That's an intermittent issue. Restarted the test. :(. I assume it could be related to priority inversion and the restricted concurrency. :s. It is possible that the playground sources have not been updated to Swift 4.0. I will check ASAP.. Thanks for the PR! \ud83d\ude38 . It seems throttle is the best fit verb for this, just that it throttles by progress rather than a minimum time interval.. I think it was unintentional. I do not see any reason for it to deviate from the inherited configuration from jspahrsummers/xcconfigs, which has it being -Os.. As for needing -fprofile-instr-generate, IIRC we disabled code coverage because of App Store submission issue. Though apparently Carthage 0.26 has formally addressed the issue. Perhaps we can now reenable it.. Hi, please check 3.0 which should have addressed both issues raised here (#553).. @ikesyo I am not quite sure how Carthage support would be broken. The end product being yielded is still a framework bundle, isn\u2019t it? If I read correctly, the only thing lacking is having Carthage overriding MACH_O_TYPE, which is just a nice to have.. Whoops. Thought the support has already been merged. \ud83d\ude48. Resolved by #557. Thanks for reporting the outdated docs. \ud83d\ude38 . Overloading does not work well with multi-line closures due to type inference limitations. So these overloads of the same base name are going to clash very often unless one specified the label.\nThat\u2019s said, as far as I am aware, this is valid:\nswift\nproducer.start(values:) { _ in }\nICYMI there is a new method in Swift 4 called Dictionary.mapValues. We are more or less aligned with stdlib on how to deal with name conflicts.. I forgot to remove the label. These are actually valid test cases written for a bug I thought to be existing, and they fail probably because of limited concurrency on CI. \ud83d\ude05 . Included as part of #534 and addressed the comments there.. Thank you. \ud83d\ude38 . Which version in particular?. I tried to reproduce it on RAC 7.0.1 but the Memory Graph Debugger isn't reporting any leak, and my memory hoarding test VC goes away as normal. So it would be better if there is more information.\nWhat is the type of someView? Did you use any other framework that could possibly do ObjC swizzling? It appears that the only difference between the two snippets would be the implicit use of reactive.lifetime.. /cc @ReactiveCocoa/reactiveswift . @mdiep Done as #575.. startWithValues is available only when Error == NoError. So you would have to handle the error using flatMapError, or subscribe using start() or startWithResult() which would inform you about any error encountered.. On the other hand, it doesn't seem flatten() would be applicable in the case presented by the code snippets, since it appears that ModelType would be neither a sequence, a signal nor a producer.\nTwo simple examples:\n``swift\n// Flattening\nlet producerOfProducers: SignalProducer<SignalProducer<Int>, NoError>, NoError>\n//flattenedisSignalProducer`.\nlet flattened = producerOfProducers.flatten(.latest)\n// Map-then-flatten\nlet user: SignalProducer\n// username is SignalProducer<String, NoError>.\nlet username = user.flatMap(.latest) { (user: User) -> SignalProducer in\n    return user.username.producer\n}\n``. I have made the observer bag cleaning aDisposable, sinceself.sendin this case would be running inside the send lock.. It is here. In a nutshell, we wrap the output sink withmakeSynchronizing`, before applying the event transformation to create the input sink.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/573/files#diff-ceb9f0d4c919bbf25ca4e3c8b7036b8bR254. Hmm, something is off.. Fixed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/575/commits/6b252d3866e309be9c8fc53fd36d2a4a44d9678a with refinements in the test case.  \nIt appears that given sufficient execution resource, the issue would consistently be surfaced even w/o large number of iterations. So I just set the iteration count to 20.. <~ is supposed to weakly reference both ends, and be ton down when the lifetime of either ends has ended. Observer alone cannot satisfy these requirements, so it wasn\u2019t added initially.\nWe may consider allowing bindings towards a pipe yielded by Signal.pipe though.. @mdiep I've inlined the now diverged code paths in Signal.Observer into Signal.flatMapEvent and TransformerCore alongside the (refined) documentation. Hopefully it would make it clearer. I've also updated the changelog.. Is it the naming/signature, or is it syntactically the same mess in your opinion? I thought ~we have limited design space for~ this kind of \"create a graph and run it later\" problems usually have a similar API.. I have rerun the Linux instance a few times, and it seems fine as compared to develop which has a high chance of failure.. @NachoSoto Done in https://github.com/ReactiveCocoa/ReactiveSwift/pull/581/commits/c8e3a8cecdaf958f1f70f0d85fce80f17060bd76.\nThe majority of async operators forward all events to the specified scheduler, and the downstream initiated interrupted event has been respecting the ~specified~ closest scheduler in the path* since 2.0. So the lazyMap here is aligned to them for consistency.\n* Edit: So that one won't get a surprise of interrupted not being delivered on the designated scheduler, in the case of an observer accessing queue confined resources. e.g.\n```swift\nlet disposable = producer\n    .observe(on: scheduler)\n    .start(observerAccessingResourcesConfinedToTheSchedulerAbove)\nDispatchQueue.global(qos: .userInitiative).asyncAfter(wallTime: .now() + .seconds(10)) {\n    disposable.disposed() // In 1.0 & earlier, this would cause an immediate\n                 // interrupted event on this global concurrent queue.\n}\n```. I agree that this is not the expected behavior, since disposables are generally not supposed to exercise side effect unless being explicitly disposed of.\nApparently QueueScheduler would need to retain all timer sources it created.. Relying on GCD is preferred, because the ad hoc recursive version would accumulate the actual scheduling delay.. A private wrapper for DispatchSourceTimer would work. The hash value & the equality can be derived from the object identity with ObjectIdentifier and ===.. Hmm\nReactiveSwiftTests.SchedulerSpec\n  QueueScheduler__on_a_given_queue__should_repeatedly_run_actions_after_a_given_date_when_the_disposable_is_not_retained, expected to eventually equal <3>, got <4>. CI has limited concurrency (1 logical processor IIRC).. As a side note though, we often deal with streams of things we do not own (a la non instantiatable). In those cases optionality is a must, and we could do it in two ways:\n\n\nhaving operators to output Property<U?>.\n    swift\n    let resource: Property<UniqueResource>\n    resource.filter { $0.hasExpired } // Property<UniqueResource?>\n\n\napply map to optionalise, and having these operators working on opaque Value with mandatory initial value. i.e. this PR.\n    swift\n    let resource: Property<UniqueResource>\n    resource\n        .map(Optional.init)\n        .filter(initial: nil) { $0.hasExpired } // Property<UniqueResource?>\n\n\nGoing after (1) hampers simple use cases, when there is an obvious initial value, e.g. some sort of flag derived from the content.\nMeanwhile, despite (2) hampering cases with mandatory optionality in favour of simple uses, it is also IMO more explicit.. Have you observed the Signal you composed? If the chain ends with map, the composed Signal would deinitialise at the end of the scope.. Sorry for the late response. I will look into it before the weekend. The way you use it does seem normal to me.. I did reproduce it with an iPhone 8. Investigating. \ud83d\ude1e . Unfortunately my hands are bit tight in the past few weeks. I plan to to pick up the trails in the weekend. \ud83d\ude1e . The weird thing is, now that I have time, I wasn't able to reproduce it on an iPhone 8 with iOS 11.2.5 like I did back in Jan. \ud83d\ude15 . I guess I would try to turn the example app into a stress test and see how it performs.. The stress testing version which stops when it detects a discrepancy. Do you still happen to have an iOS 11.1 device at your hand?. ~~Hmm, I did manage to narrow it down & it happens only when QueueScheduler is involved in the API manager.~~ Turns out it is the tests not being correct. :p. Sounds like a corrupted build. :s. CI probably didn't verify the UI Example playground, but only the primary playground.. The where clauses for Error in Property.swift can be removed presumably.. @ikesyo any plan to release Result with Swift 4.1 soon?. I am for supporting only Swift 4.1 given that we are going to bump the major version anyway.. I am against both. compact makes sense in terms of space & mass, ~but time cannot be compacted~.\nMore precisely, the semantic is different: Collection.compactMap shrinks the size of the collection in the spatial domain, while Observable.filterMap simply drops the item in the time domain.. > In that cases, disposables will disposed in order from the beginning, so higher performance maybe expected if not to use reversed().\n~~Is the case still hold if you more or less randomise the removal?~~ Anyway I think it is fine to drop reversed() given the apparent gap & the reality that a Bag growing beyond two digits is a pretty fringe case.. ping @NachoSoto . ~~Perhaps this could be mitigated by adding a map overload that takes (Value) -> U? for now.~~ cc @mdiep @NachoSoto \nEdit: No it doesn't work.. I do have to pose an objection to ignoring the issue, because giving explicit types is unergonomic for composition.\nI would suggest a sad compromise of renaming this to mapToValue(_:). for now, and reintroduce map(value:) once SR-6989 is fixed.. @Qata It is source compatible but binary incompatible due to how default arguments are implemented.. It should be fine. We are going to do a major release anyway since #610 strictly speaking is API breaking. cc @ReactiveCocoa/reactiveswift . The performance gain is likely due to the special status of the Standard Library regarding cross-module optimisation. Only if you write the test as part of the ReactiveSwift module & the gain is maintained, then it can be concluded as an improvement.\nIt also leaks an implementation detail of Bag.. Apparently a wrapper struct around IndexingIterator<ContiguousArray<Element>> is as performant as using it directly with -O -whole-module-optimization based on a quick synthetic benchmark.\nSo I would prefer this to leaking the ContiguousArray iterator which is an implementation detail.. You could still replace the internal of Bag.Iterator with ContiguousArray<Element>.Iterator though. There is still an apparent gain with less code.. > Did you intend ContiguousArray.Iterator's wrapper struct like this?\nYes\n\nIt's about the same performance with using ContiguousArray.Iterator directly in ReactiveSwift module, but it got worse in cross-module.\n\nPerformance of external use is not a primary concern of any primitive we offer in RAS, because it is a well acknowledged issue with a solution materialising in Swift 5.\n\nIn addition, I also benchmarked the following Iterator.\n\nWe are not committed to use any compiler private attribute at this point. These attributes will show up in Swift 5 as part of the official language spec AFAIK, so until then.... Yes, this is something missed in #351. I believe there are a few missed operators too.. @ra1028 Yes, except for Action which is rather pointless to use SignalProducerConvertible.. LGTM otherwise.. It is an acknowledge issue (#590), and we are kinda blocked by compiler regressions as far as I am aware.. If the intention is just to support bindings, property.reactive[\\.name] <~ stream already works, just that it is part of ReactiveCocoa AFAICR.\nIt can be a retaining view with a custom binding target implementation. There was a very similar proposal before for DynamicProperty. https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3162. I don't see much of a concern for a view to strongly retain its backing property.. > In this expression, unless something retains the view, the whole binding will immediately complete.\nThe view can supply a manual binding target \u2014 it has the access to the backing property to derive a binding target from it, instead of relying on the default implementation.. If it is meant to be an existential wrapper, it should be strong after all as to align with the semantics of generalised existential when it lands in Swift eventually. i.e. let temperature: MutablePropertyProtocol where Value == Decimal should be semantically equivalent to let temperature: AnyMutableProperty<Decimal>.\nProperty.init isn't meant to be such. Property.init(capturing:) is, and it is meant to be transitional since we assumed that generalised existential was going to land in Swift 3.x. It didn't work out though.. I'd like to add that having views to retain its base object is not quite a rare pattern. The Standard Library slices use the same semantic.\nTBH I would be in favour of ditching Property.init(_:) to undo the confusing precedence, if the eventual goal is to replace Property<Value> with a generic type alias to the PropertyProtocol existential.\nAlternatively, we could redesign our property types as a class cluster (e.g. the KeyPath cluster). Then we would be able to enjoy the subtyping relationships in today's Swift.. The original plan was that ComposableMutablePropertyProtocol might replace MutablePropertyProtocol eventually, but the work hasn't been done/tried.. The primary purpose of interrupted is materialising a cancellation, i.e. as a cancellation carrier being emitted from the roots of a SignalProducer graph. In this regard, interrupted does what it is meant to do, while having some diverging semantics from failed to facilitate resource management in specific operators.\nSo if you want a definitive error propagation, failed is usually the better choice.. @NachoSoto Do you mean +1 to  @mdiep or +1 to the thread? \ud83d\ude1b . Feel free to open a PR in both repos. :). This appears to be a specialised (Publish)Subject from which we have moved away since the swing to Swift. I understand the ergonomic aspect of this, and admittedly I had been utilising Action in a similar manner, i.e. Action<Void, Never, NoError>. But I personally would stand by the argument of not encouraging this from an API surface perspective, and hence not incorporating this as part of the framework.\nIf you find creating multiple pipes a bit of a boilerplate, grouping the events as an enum and having a signal of events could potentially be a way out.. With Swift 4.1, I wonder if having Optional conditionally conforming to BindingTargetProvider makes better sense.. The (premature?) optimisation side of me has a little problem with this adding 16B overhead plus (at least) two objects per Observer. This is a convenience I\u2019d be hestitate to make, especially in the light of the idea that Observer should not have its own lifetime. Observer is destined to be owned by someone that has a \u201cprimary\u201d lifetime \u2014 either a Signal for receiving events, or the sender for pushing out events.\nI would argue a majority of cases can already be satisfied by start* or observe* plus a strong Observer-captured method reference. This is more explicit in the sense of capturing, and on the contrary, <~ is meant to weakly reference both ends.\nIf this convenience is strongly desired, my proposed alternative would be a special overload for self.reactive[\\.myObserver] <~ myProducer, which has all the information needed to construct a binding that doesn\u2019t violate any assumption made above, and doesn\u2019t carry the overhead introduced by this branch. Though the downside is this being exclusive to ReactiveExtensionsProvider until we can extend AnyObject (maybe never).. @Marcocanc I think the approach in https://github.com/ReactiveCocoa/ReactiveSwift/pull/635#issuecomment-387016433 is fair. :). > That users might make a binding target to a struct and then be confused that it doesn't mutate shared state?\nThis is unlikely to happen since BindingTarget does not support inout reference. So if the host is value type, mutations attempted in the closure would be blocked by the compiler (unless the enclosing declaration has the mutating modifier).\nEither way, this is a semantic error that IMO we shouldn't account for.. Four test cases involving both value & error type inference are added but commented out, as they were expected to be working, but the type checker isn't capable of doing so. . For simplicity's sake, IMO we should just explore using Foundation locks as the fallback, but we should also keep in mind that with the existing implementation the Swift compiler would devirtualize the subclass vtable dispatch at all call sites. So we should at least ensure that this still happens after swapping in the Foundation locks.. Just had a look and it doesn't seem possible to move to Foundation locks, since the optimisation AFAIK is applicable only to class clusters, and we can't possibly make NS(Recursive)Lock ~~conform to~~ inherit from ReactiveSwift.Lock.. Just found out that on Darwin 11 was EDEADLK and 35 was EAGAIN, i.e. swapped wrt the Linux counterparts. Although it still doesn't make any sense. \ud83e\udd26\u200d\u2642\ufe0f . ExpressibleByBooleanLiteral could be an alternative, but I am not sure if this is a good idea.. The behavior is correct. You should keep in mind that SignalProducer is lazy, in the sense that everything is setup only when it is actually started.\nIn this specific case, the concat semantic is that its RHS starts only after its LHS completes. Therefore, every work you derive from the () value using flatMap happens before the interrupted producer is started, including the termination of signal via a completed event.\nSo now when the interrupted producer gets to start, the signal has already terminated, and take(until: signal) becomes a no-op.. I see the value in such operator. But we'd need a more cautious thought on whether any strategy other than concat and latest is applicable.\nFor example, with merge, one could have multiple work derived from the accumulator at time t running. When any of them updates the accumulator at time t+1, it makes other outstanding work sort of stale, and in turn potentially causes silent incorrect accumulation.. My personal stance is that we should have a cold entity, that isn't named Promise for sure to avoid confusion.\nI am sure that the warm behaviour of Promise is preferable in some cases, but having it cold by default allows us to: (1) have it stayed cold without needing another entity \u2014 a compact API is one of our strength; and (2) a cold entity can wrap warm semantics pretty intuitively (hello, replay operators!).\nAs for naming, there is a dissent around \"inheriting\" the name Single from Rx (by @mdiep, @sharplet and part of @andersio). That's the reason why names like Promise and Future are thrown around albeit not making much sense if we go after cold semantics.\nAfter days of thoughts the best I can come up with is OneShot<T, E>. :p. ReactiveSwift at a conceptual level is centred around Signal, which is refined by SignalProducer that is in turn further refined by Property. So we\u2019ve already established a three/four level hierarchy for years that kinda qualifies for progressive disclosure. A cold stream of one (should we go after this path) adds a second refinement to SignalProducer, but it doesn\u2019t break the basis of conceptual model formed around Signal.\nI cannot dispute that it might in the end be a cognitive overload that offers little value over SignalProducer, other than one not having to choose parameters for several operators in the \u201cI know this gonna be a stream of one\u201d scenario. Especially, #516 makes the bar very high for it to be valuable no doubt.\nWhile @mdiep raised a good point in the need of reviewing the very basis before we proceed to extend the framework, \u201cstream of one\u201d is IMO orthogonal to that discussion, since this particular refinement is valid regardless of the base, which should remain by default  multi-value with explicit termination.. @liscio It seems you might have been mistaken here. The scope of \u201cstream of one\u201d has never been dead set on a warm Promise primitive.\nThis issue nominated a cold stream of one construct that is akin to Rx Single, and I think that\u2019s what most of us have in mind. As mentioned, the \u201cwarm\u201d start-immediately and replaying nature of Promise could more or less be covered by a replay operator on a cold construct.\nSpeaking of my own stance, I have no intention to expand the API surface to support another style of async API. The acceptance criteria for me would be a familiar but refined API similar to SignalProducer, and if it is cold, it should not be called Promise in any case absolutely. Most importantly, the most valuable thing we\u2019d have on it is just parameter-less flatMap to faciliate a Promise \u201cthen\u201d style composition. But this can be also exposed as flatMap(.once) without introducing a new construct.. > @liscio:\n\nNow, I have no idea why you think that Async or any other Future-like construct needs to communicate whether it is warm or cold?\n\nAs @mdiep mentioned the need of reviewing our base (Signal/SignalProducer), I tried to gather my thoughts around it. It turns out that my arguments followed this very same path of logic (link to a manifesto).\nIt does pose an interesting doubt on whether a separate Single type would offer substantial value after all. Looking at the Single type in the same manner as in the manifesto:\n\n\nFrom an API consumer perspective, it has no difference from SignalProducer at static time. \nSingle promises only to notify its observer once at runtime. At static time, the guarantee can be no stronger than any other async construct (i.e. maybe invoked multiple times), because this is the nature of scope-escaping closure/callback patterns in general. In other words, Introducing a new type that provides no extra astatic time guarantee seems dubious.\n\n\nFrom an API producer perspective, it does in theory provide a more concise set of API. A notable example is that flatMap would be strategy-less, and a few operators would be dropped since they no longer make sense given the runtime contract of only one event. \nBut since it barely has any effect on expressivity of intent, it becomes a question of whether mere brevity should be weighed against a considerably larger API surface (which incurs maintenance cost), plus zero extra static guarantee.\n\n\n(These are akin to the questions I had asked in #201.). Thanks for catching this. \ud83d\ude38 . Unlike Swift 4.1 with conditional conformance, the 4.2 mode doesn't seem to offer any new language feature which the library can take advantage of. Given that Swift 4.1 mode interoperates with Swift 4.2 mode, I agree with @mdiep that it is not very urgent to move.\nIt shouldn't be a breaking change though, unless we used anything exclusive to 4.2+ modes.. @mdiep This PR doesn\u2019t change the semantic of SerialDisposable disposing of any inner disposable set after itself had been disposed of.\nI would consider #686 a bug in the sense that the inner disposable has been disposed of, but the storage still retains a strong reference to the disposed inner.\nCompositeDisposable does not hold reference to any inner beyond its disposal. ScopedDisposable does, but its nature is different from these two mutable disposables.\nAllowing the inner to be retained is also inconsistent with dispose(), which clears the inner disposable. I think it makes sense to say inner == nil && isDisposed should always hold.. The same semantic can be achieved by creating a global stored AnyDisposable and then disposing of it.. Looks nice! Could we have this documented please?. Maybe scanMap? There has no precedence but the operation is closely related to scan. \ud83e\udd14\ncc @ReactiveCocoa/reactiveswift. Can we also see if scan can be implemented with this operator by composing the transform? . In our codebase there is a common scenario to keep the first value and drop subsequent values until nil occurs, which currently implements as a scan plus a filterMap:\nswift\nextension SignalProducer {\n    func firstUntilNil<U>(_ transform: @escaping (Value) -> U?) -> SignalProducer<U, Error> {\n        return self\n            .scan(into: (true, nil)) { (current: inout (isPreviouslyNil: Bool, lastOutput: U?), newValue: Value) in\n                switch transform(newValue) {\n                case let .some(value) where current.isPreviouslyNil:\n                    current = (isPreviouslyNil: false, lastOutput: value)\n                case .some:\n                    current = (isPreviouslyNil: false, lastOutput: nil)\n                case .none:\n                    current = (isPreviouslyNil: true, lastOutput: nil)\n                }\n            }\n            .filterMap { $0.lastOutput }\n    }\n}\nwhich could be made better by scanMap in the sense that the operator no longer needs to keep a copy of the output just to make the compiler & the operator happy:\nswift\nextension SignalProducer {\n    func firstUntilNil<U>(_ transform: @escaping (Value) -> U?) -> SignalProducer<U, Error> {\n        return self\n            .scanMap(into: true) { (isPreviouslyNil: inout Bool, newValue: Value) -> U? in\n                switch transform(newValue) {\n                case let .some(value) where isPreviouslyNil:\n                    isPreviouslyNil = false\n                    return value\n                case .some:\n                    return nil\n                case .none:\n                    isPreviouslyNil = true\n                    return nil\n                }\n            }\n            .skipNil()\n    }\n}. > I think this would be more clearly written with combinePrevious, since that's what you really care about\nI'd expect an operator to hold just the minimal viable state for doing its business. So using combinePrevious or skipRepeats would mean that the latest value is held despite not needed for the anticipated semantic, which might not be desirable sometimes.\nThe operator here is apparently also a more general form which some other operators like combinePrevious and skipRepeats can be built on top of, now with only a transform. Probably not a spectacular reduction in codebase though.. The tricky bit is NoError which could have been a typealias to Never, had it been conformed to Error in stdlib.. Argh! That\u2019s brilliant. Missed that part from the SE proposal.. Assuming antitypical/Result would just be augmenting the stdlib Result since Swift 5, should we consider dropping antitypical/Result as a dependency?\nRAS depends on NoError, the structural definition of Result and ResultProtocol. The former two can be sourced from the stdlib since Swift 5. The last one is used only for extension constraint for dematerialize(), which can be re-declared in RAS, and later replaced by parameterised extension when it lands.. @mdiep Do we not want to keep NoError as a typealias?. CI for Xcode 9.4 can be removed.. Bag is not optimised for insertion and removal performance and arbitrarily large number of elements. It aims at best performance for a small number of elements, while providing an index-agnostic token for later removal. This is because RAS primitives rarely have more than 1 observer, and even for those having arbitrarily large number of observers, it is hard to imagine the need for frequent attachment and detachment.\nIf you set the stage to be low 2 digits of elements, the smaller the amount of elements the more the Array based implementation would do better than Dictionary.. I don\u2019t recall any change with huge impact being made that needs to be staged. So IMO going straight for 5.0 is fine.. Done.\n. An existential wrapper retains what it is wrapping, isn't it?\n. Removed.\n. Renamed to BindingTargetProtocol and BindingTarget.\n. Changed this to init(setter:lifetime:on:).\n. Hmm...  after a second thought, in its current state, it is actually a problem for cases like DynamicProperty. It wouldn't work if it is nested either, e.g. BindingTarget(BindingTarget(MutableProperty(1))).\n. I have removed it, since it isn't needed now for the Rex merger.\nAnyway, implementing this correctly would probably require type erasing via inheritance and runtime type check, especially for the <~ requirement.\n. let hasStartedExecution: Bool = self.state.modify { ... } should do. The executeClosure need not be moved inside the critical section.\n. This is the only working combination in Swift 3.0 GM I've found so far.\n. It is fine, though I wonder if you can access atomic_* from C++ atomics?\n. Assuming https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3162 get a pass, DynamicProperty would have its own <~ implementation. This as the default implementation is only useful if we keep the current easy-to-leak-because-of-the-stealth-retain DynamicProperty.\n. We just need to evaluate it once for all invocations of the closure. It is also used in the Rex PR per an idea from @mdiep.\n. Well it would still fix it, since the block would be dispatched asynchronously afterwards. It seems it is right not to jump the queue this way too. Just that BindingTarget would become asynchronous by default.\n. This was expect(value) == 1 as the binding target was guaranteed to be synchronous before.\n. Yeah, you are right. I just meant for this particular initializer async is the default (with limited reentrancy from UIScheduler).\nThat's said this is born to serve the UIKit/AppKit extensions in the first place, which means these could become synchronous-at-best-effort.\n\nThere was once a debate on whether or not we should do implicit dispatch. Though unlike Propertys, BindingTarget is just meant to be the last mile of the binding journey.\n. It was Reactive and Reactivity (eww) before, but I changed it to ExtendedForReactiveness because Reactive* somehow sounds like implying non-conforming types of Reactive* are not reactive. Hmm.\n. Changed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/51/commits/c555058645d9d9fe2dc961227bdaa6bb353a6698.\n. ExtendedAsReactant? We have precedents like ExpressibleAsStringLiteral.\nP.S. ReactiveProtocol is likely unnecessary. The base could never be value type, and classes can easily be constrained via inheritance clause.\n. We care about just the reference it holds, and the proxy itself does not need an identity. It still has value semantics (on the reference itself), albeit not being a \"full\" or \"pure\" value type in some sense.\n\n~~(This makes me wonder why I somehow shipped a commit turning Observer into a class. Hmm. It seems to be an artefact of an earlier revision of the PR. Maybe it should be reverted too.)~~\n. ReactiveExtensionProviding. :p\n. If we value clarify over brevity - which is what the Swift API guideline prefers - then yes, reactive is a sensible choice.\n. I think we'd rather treat all extension methods and properties as a single bloc under reactive.\n. Ouch, passive voice. Fixed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/51/commits/5987edf3f5a153269118da17be47656f657536d8.\n. Done in https://github.com/ReactiveCocoa/ReactiveSwift/pull/51/commits/046c65192655576c1cbd0ecb95d66ffe776f5d20.\n. Changed.\n. Observing notifications from NotificationCenter posted by another object.\nNotificationCenter.default.reactive\n    .notifications(forName: .Name, object: object)\n    .take(during: object.reactive.lifetime.or(self.reactive.lifetime))\n    // ...\nAn example here too.\nBut of course these can be eliminated if notifications(forName:object:) would terminate the returned signal if object has deinitialized.\n. We are talking about two different cases here. It does interrupt if the object has deinitialized  at its start time. But it never stops once it is started except for explicit disposal.\n. Shouldn'tno observers be singular?\n. There is a return below as an early out.\n. This initial check seems unnecessary, since shouldThrottle.producer below would emit the current value.\n. @sharplet Hmm, may I ask what's the specific reason to retain it? I don't think the resulting signal should own shouldThrottle in any way.\nWhat if it terminates the resulting signal when shouldThrottle completes, gaining the take(during:) semantic?\n. An observation to the push-based Signal should not have any effect on the event stream. If we treat operator as specialised observations, and Propertys as specialised Signals with stronger guarantees, by the logic a signal operator that takes a Property should not cause any side effect on its sources.\nNow retaining the property violates this, as the retainment influences the termination of the stream (the property) that is supposed to just be observed.\nIIRC this would be the first ever signal operator that has a side effect upon the upstream signal if merged.\nAction is a different story, since it is not a stream of value itself, but a state machine that owns a few streams.\n\nRegardless of the current behaviour, are you saying that if shouldThrottle completes, the returned signal should or should not also complete?\n\nEither would do, but completing with shouldThrottle's completion sounds a fit. Say for a Swift equivalent of ReactiveViewModel, I think it makes sense to have these throttled signals gone together with the supplied shouldThrottle property (which is owned by the view model).\n. Nice! The underscore label of the designated initializer can be stripped now, can't it? Like how in #88 Matt's proposed API takes any arbitrary isEnabled predicate.\n. BindingTarget is a concrete type. Maybe \n\nbinding target, represented by BindingTargetProtocol\n\ninstead?\nMoreover, MutableProperty is not the only property type that can be a target, since it inherits the capability from MutablePropertyProtocol. I'd prefer to say:\n\nAll mutable property types are inherently a binding target.\n. This should not be changed. We use SignalProtocol only to constraint the extensions, since we can't use same-type requirements in concrete type extensions yet. A signal is always the concrete type Signal.. Ditto.. Ditto.. Ditto.. Line 132 has a broken link. May you help fix it please?. [Nit] Should the headers be more consistent? Perhaps the three below should use backticks too.. Push. \ud83d\ude38 . Push. \ud83d\ude38 . Push. \ud83d\ude38 . ~~That is intentional IIRC. All composed properties derived from a property is considered just a reduced/transformed view of that property, so that the behaviour is in line with existentials which retain the wrapped property (like the one in your example).~~\n\nThat's said it might be worth discussing if the source capturing should be dropped. It could be an oversight (especially with the arguments I made in https://github.com/ReactiveCocoa/ReactiveSwift/pull/58#discussion_r88503964... ehm), since in https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2922 @mdiep and I focused just on how signal and producer should behave.\nEdit: Edited many times.\nEdit 2: It seems the capturing is originated from https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2788. The argument to capture was different though, and it was actually invalidated by https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2922...\nEdit 3: Opened a PR. https://github.com/ReactiveCocoa/ReactiveSwift/pull/117. Space after colon.. Hmm, this is an oversight. Thanks for catching this.. TIL. Seems UnsafeMutablePointer is enough.\n\nInstances must be aligned to MemoryLayout\\<Pointee>.alignment, i.e. (UnsafePointer\\<Int8>(self) - nil) % MemoryLayout\\<Pointee>.alignment == 0. Removed.. According to the memory model, it has to be first initialised before being used too. Addressed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/124/commits/974663c308911d2dc156dd07f38d15f7d3cf0ef7.. Under the new signal lifetime semantic, a signal is kept alive only if it is retained or has active observers. So the observer is added to extend the signal's lifetime indefinitely for the termination event outside the closure scope, or otherwise the signal would dispose of itself upon exiting the closure.\n\nThe fixed bug is kinda related too - a produced signal would dispose of itself when it is not retained and not observed. But then the associated producer disposable would not follow.. It could be a false negative - since it is read outside the sendLock, it might race against the next event sender which might flip terminated to true. So we have to check it again once we acquire the lock.. I guess we'd need a set of coding guidelines then. Just did a search and found quite a few of [U]() \ud83d\ude48 . This is not true with starting. \ud83d\ude38 \nEdit: Got pointed to the wrong line. heh. I mean this line.. Ehm, sorry if I confused you. I mean the headers should be changed in line with the changes to the links in https://github.com/ReactiveCocoa/ReactiveSwift/pull/110/commits/6147f7f82f8195718c98c6fea9e8f2b1c8e81046.. RAC -> ReactiveSwift throughout the document.. We can have outputs printed before the producer has started. But no output is ever printed until the producer is started, yeah. Hmm, it should be fine, just that it might be a confusing point for beginners.. https://github.com/ReactiveCocoa/ReactiveSwift/pull/123/commits/7a73f824e4d4a8830e5095bd388b21c631c60c40\nAdded before merging. :tada:. #117 is merged. ~~Now this is the last stop before RC1 (hopefully). :tada:~~. Perhaps just two notes (shouldThrottle + termination behavior), or no notes at all?. Kind of.. Could this be defined in an extension to BindingTargetProtocol?. Followed FlattenStrategy to use imperative verbs.. Signal.observe returns an optional.. Does inputStrategy or serializeStrategy make sense to you?. Sometimes I do wonder if FlattenStrategy should be FlatteningStrategy instead.... Alternative: combineLatest(from:).\nEdit: IMO with is not directional, but from implies a direction.. Should it be a class bound protocol?\nEdit: Unless we might conform collection types to BindingSourceProtocol too, and implicitly lift them as producers, this should be a class bound protocol.. Please update the documentation.. Ditto.. Typo: evenst.. [Nit] \"already terminated\" sounds more accurate.. This seems unused.. This should not be removed. It is intentionally overridden to capture setter directly, so that self need not be retained and/or uniqued by its parent. The default implementation weakly captures the target, so the binding would be invalid if the target is not retained.\n(Seems like it wasn't covered in the spec.). This is for producer though. We have a ~~couple of~~ few cold -> hot -> cold producer operators.. Oops, overlooked that. \ud83d\ude48 . We do not have hot + cold -> hot except for flattening operators though. Only on SignalProducer we have overloads that take Signals directly.. It is not illegal. Just that hot -> cold -> hot doesn't seem something very commonly used, except for flattening operators (Signal<SignalProducer, E>).. withLatest(_:) should be fine.\nswift\nwithLatest(textField.reactive.continuousTextValues)\nreads like \"with latest text values\" to me. Edit: That's said the from label would give a stronger implication of \"with the latest (one) from\".. IIRC Swift would always pick the overload with the most specific matching constraint. So instead of a dynamic check, you might as well define: \nswift\n@discardableResult\n  public func <~\n    <Value, Source: BindingSourceProtocol>\n    (target: BindingTarget<Value>, source: Source) -> Disposable?\n    where Source.Value == Value, Source.Error == NoError\nThough the alternative is still having it defined in the protocol, and overriding it in BindingTarget.\n(Not sure how it's going to behave if one is global while another is in the type.). I am not sure about the behavior. But there seems no point to assume the need of custom binding logic for varying types of sources.\nThough I believe if you define it in the protocol, the matching priority would likely be given to the target.. Nope. \ud83d\ude39. > Having states as stored properties seems a little bit faster, probably due to improved locality and/or less ARC calls.\nEdit: The difference is consistently ranging from 0% (property binding) to 9% (Signal synthetic) worse for different test cases in my benchmark runs.. Ditto.. It is now swapped out before disposal in https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/63a7e0d28db724191a6a2254458f5dbe91f0f196, so no check is needed.. The performance is much worse due to the need to query the protocol witness table, even with the @inline(__always) annotation. I have rerun my benchmarks and it is still the case.\nI am actually thinking of removing AtomicProtocol, hmm...\n\nEmbed PosixThreadMutex into Atomic.\n0.179 sec (4%)\nImplement value and swap in Atomic.\n0.149 sec (4%). Renamed.. It'd better stay signal, since it has more than just values but also termination events.. These trampolines are made as liftLeft and liftRight cannot be included in SignalProducerProtocol (except the unary lift). Having said that, these trampolines can be removed when Swift 3.1 lands, should we drop the protocol in favour of concrete same-type requirements.. The check within the protected section guarantees that synchronous recursive termination event is immediate. (Edit:) If we just check after the protected section, the synchronous recursive termination event would have to compete with other concurrent senders.\n\nThe check after releasing sendLock is a safeguard for concurrent termination event that is missed by the protected section. Related PR: #112 \nWill add a note in the code.. Yeah, unfolding the state (back) into observers and retaining would help. Probably not in this PR though, but in #139 which really touches this piece.. Nice ~~idea~~ catch. Implemented in ~~https://github.com/ReactiveCocoa/ReactiveSwift/pull/137/commits/ecab87173d8d1f436848f439e3058bdf895e368d~~. :tada:\nNote that I have pulled in Read-Copy-Update from #139 to avoid introducing locks.\nEdit: It performs better than #139 too, since reading status and the observer bag is now done in one shot.\nSwift Enum never lets us down. \ud83d\ude0d . It is usually used with an apparent owner. So defining it as a struct gives the flexibility to have it embedded in the containing type, should it be a stored property, and have one less pointer to chase.\n\nDrop precondition in favour of if-fatalError.\n0.188 sec (2%)\nEmbed PosixThreadMutex into Atomic.\n0.179 sec (4%). The double checking is to free the normal event delivery from having to acquire statusLock, by exploiting wait-free reading of read-copy-update.\n\nConcurrent senders perform a relaxed read from status, and enter the termination handling routine only if they see terminating. However, as the read is relaxed and some other may have already handled it and bumped the status to terminated, a second check is performed after acquiring statusLock.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/137/files/1681a4444d15fb0cff4a39dc0dd014d9791442b2..b53e796e30008856fab537b0d86e4672176d08d2#diff-09166f905ad1f830ac2dc91f2663c1a5R159. (Packed) object references are simply tagged pointers that are naturally aligned. Both ARM and x86 guarantees the atomicity of these reads and writes. The Swift compiler also respects alignments when laying out structs and classes.\n~~statusLock~~ updateLock is introduced to serialise modifications, as the state updates cannot be expressed in atomic RMW instructions.. I make a little snippet of MemoryLayout, and run them in the iPhone simulator (i386) and an iOS template app (both 32-bit and 64-bit builds) on iPhone SE.\nWhile AArch32 is not exactly the same as ARMv7, they are backwards compatible. Edit: On 32-bit platforms, there are at least 2 bits for packing (i.e. 4  enum cases).. Relying on just a reference is a significant regression, since now it has to load the reference and then load terminationEvent for all terminating checks in all cases.\nThe enum is a tagged pointer, and checking for \"terminating\" is just done by comparing the packed tag bits. So it saves a load for every terminating check (note: 2 per value event) when the signal is alive.\nMoreover, alongside the performance, the enum communicates the intent better too:\nif signal.state?.terminationEvent != nil { ... }\nif case .terminating = state { ... }\nEdit: I'd rename SignalStatus to SignalState, and SignalState to SignalStateSnapshot. Anyway, if you prefer to, I can revert the branch to the approved state and leave these stuff to a separate PR. But I do not feel this is necessary, as we may figure out better names instead.. You can also disassemble using LLDB to verify this. For example on ARMv8, you would see:\n->  0x103005b24 <+528>:  ldr    x25, [x20, #32]\n    0x103005b28 <+532>:  lsr    x8, x25, #62\n    0x103005b2c <+536>:  cbnz   x8, 0x103005be8           ; <+724> at Signal.swift:169\nx20 = 0x00000001712649c0\nwith x20 being the reference to signal, which is an aligned pointer, and the offset to state being 32 bytes. The tagged pointer is read in one aligned atomic load, and then it is being shifted to the right by 62 bits to retrieve the tag bits. Finally it would be followed by a comparison and/or a conditional branching op.\nAs long as the Swift compiler does not screw up in laying out types and the Swift runtime does not screw up in allocation, the read is a relaxed atomic read.. The code snippet:\n```swift\npublic final class Test2 {}\nenum TestEnum {\n    case b(Test2)\n    case c(Test2)\n    case a\n}\nif arch(arm) || arch(i386)\nprint(\"arm or x86 32-bit\")\nprint(\"(MemoryLayout>.size)\")\nprint(\"(MemoryLayout>.stride)\")\nprint(\"(MemoryLayout>.alignment)\")\nendif\n```\nSwift can pack up to four cases with an object reference payload (or up to three cases if there are one or more no-payload cases) into a 32-bit reference.\nIn SignalState, if two more cases with an object reference payload are added, the size would spill to 5 bytes.. Related:\nhttps://github.com/apple/swift/blob/master/include/swift/ABI/System.h\n```\n/***** i386 *******/\n// Heap objects are pointer-aligned, so the low two bits are unused.\ndefine SWIFT_ABI_I386_SWIFT_SPARE_BITS_MASK 0x00000003U\n/***** arm ********/\n// Heap objects are pointer-aligned, so the low two bits are unused.\ndefine SWIFT_ABI_ARM_SWIFT_SPARE_BITS_MASK 0x00000003U\n```\nhttps://github.com/apple/swift/blob/master/lib/IRGen/ExtraInhabitants.cpp\nhttps://github.com/apple/swift/blob/master/lib/IRGen/GenEnum.cpp#L2765. I guess this needs a rename too, hmm?\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Atomic.swift#L27. These should be less confusing once we have them nested in Swift 3.1, e.g. Signal<U, E>.State.Alive.. The Swift ABI defines this, regardless of OSes. You would always have the lowest 2 bits available for packing on 32-bit platforms anyway, due to the 4-byte minimum alignment.. 2 bits are enough for 4 with-reference cases, or 3 with-reference cases plus 2^30 ~~(or 2^30? not quite sure)~~ no-payload cases.. It doesn't feel like the type checker could ever cause any chaos here though.\nSignalProducer is a discrete time sequence, while Sequence is immediate. This means we would likely never conform SignalProducer to Sequence, or in other words the two signatures would never collide in any sense.. Caught another \ud83d\ude48 . ~~It is part of the test case.~~ action is set to nil below to test if the property is really retained by the Action.. These properties and methods should be public. Please make a new line for the return statement too. :). Ditto.. Ditto.. It'd be better with lift instead.. Ditto.. Property(unsafeProducer:) requires the initial value to be synchronously delivered, so as to maintain the always-having-one-value guarantee of Property.. But it has to send the initial value twice, which is unpleasant.. Though it does look a bit weird to have the producer not consistently delivering to the scheduler. Perhaps lift shouldn't be used.. This would fail without the fix.\nRelated Bug Report: https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3350. If you meant the list of requirements up top, they all have been the case since MutableProperty is introduced. Just that they were only defined in the PropertySpec, but not textually in the protocol doc.. negated perhaps. It is not a boolean but a container of booleans, and properties should be named as nouns whenever possible.. Please follow the documentation guidelines. \ud83d\ude38 \nswift\n    /// Start the producer, then block, waiting for the last value.\n    ///\n    /// When a single value or error is sent, the returned `Result` will\n    /// represent those cases. However, when no values are sent, `nil` will be\n    /// returned.\n    ///\n    /// - returns: Result when single `value` or `failed` event is received.\n    ///            `nil` when no events are received.\n    public func last() -> Result<Value, Error>? {\n        return take(last: 1).single()\n    }. Please add overloads for both and and or that take a Signal.. Ditto.. https://gist.github.com/andersio/8f0ae67255b959e227aabb4944fa5b6d. Generally speaking, it allows a particular value in the view layer to be decoupled from its view model layer type, akin to NSValueTransformer.. It is essential for thread safety, as far as I am concern. We need to run the validation logic within the root properties' protection, so that the whole thing is an atomic unit of work.\nEdit: Otherwise, the action closures may race against the cache updates originated from the root mutable property.\n-------------------                        -----------------\n|                 | -- new from source --> | |   Cache   | | -- .... -->\n| MutableProperty |                        | ---------------             \n|     (source)    | <- validated result -- | | Validator | | <- .... ---\n-------------------                        -----------------\n    ^ ^ ^ ^ ^ ^\n concurrent writers\n~~Even if the validation might not need this,~~ the two-way binding mediator would need it to ensure data consistency.\nIf what you mean complexity is not wrapping modify directly, it is actually in a pretty close to the case of the state property in Action, which can't be typed (but Any). Here we just wrapped the locking ability, and exploit reentrancy of MutableProperty to get the job done.. Suggestions are always welcomed. Not good at picking names. \ud83d\ude48. A reversed transform is required for mutable map.\nLet's say if you have ActionProperty<Int, NoError> mapped to ActionProperty<String, NoError>, if you perform a mutation through the later one, the operator needs to know how to map String back to Int.\nEdit: Note that the regular read-only map is still available.. A blank comment line between them, please?. A whitespace between /// and Combines. Same for lines below.. A documentation in this form:\n/// Create a producer that computes a logical AND between the latest values of `self`\n    /// and `signal`.\n    ///\n    /// - parameters:\n    ///   - signal: Signal to be combined with `self`.\n    ///\n    /// - returns: A producer that emits the logical AND results.\nshould be applied to all variants (signal/producer/property).. What should be filled in here?. This can be disposed.. [Nit] For multi-line modifications, it'd be better to use named parameter.. You can dodge the need of an optional by using:\nswift\nlet group: Signal<Value, Error>.Observer = groups.modify { groups in. [Nit] Blank line before the pattern.. The start disposable should be added to the producer disposable.. It doesn't seem necessary to specialise it. Is it a workaround to the compiler's weirdness or something?. Please wrap test cases in it.. Seems like start that takes an event action would be nicer here.. These should be checked immediately after the disposal.. It would be great if there are specialized test cases than one giant one. At least this single test case apparently did not catch the undisposed upstreams, caused by this line.\nSay we could use a few test cases on how the inner producers behaves with regard to an outer terminal event, and keep this test case focusing on values.. Perhaps one per terminal event, hmm?. I think asserting just the specific event is enough. The Signal contract guarantees only one would ever be sent. If multiple terminal events are sent, this would be a fault in the Signal basics and should have been caught somewhere else.. I mean if you really need to write SignalProducer<(Key, SignalProducer<Value, Error>), Error> when the type parameters can be inferred.. [Nit] A blank line please. \ud83d\ude4f. [Nit] This close bracket could be aligned better.. By the API convention though, it should be group(by:). Would the parameter be better named classifier or something?. We already have skip(while:) and take(while:) working in this way.. s/error/failed/. I don't feel the need to rename it. \ud83e\udd14 . replayLazily retains self only when it is not ever started. Once it is started, it throws the start handler (which retained self) away. This is why there is a start of type Atomic<(() -> Void)?>. The behaviour \u2014 at least for the default policy \u2014 should not be changed if you are targeting 1.x.\n(Edit: Though it is a new behaviour in 1.0 IIRC. Before, it behaves like how this PR does.). It seems all these could be flattened into one event action.. IMO an eager release of the start handler should be done whenever it is possible.. Underscored as it is expected to be gone in Swift 3.1.. Oh, one more thing: may you please use liftLeft to be consistent with combineLatest?. Ditto.. Hmm. kind of. The playground takes a liveView of UIView only. So unless a UIWindow is used, the VC hierarchy won't work.. s/emmit/emit/. It semantically does not matter in this case. But for view models in collection views, you might prefer classes to structs, as when passing it around the ARC side effects happen on just the view model reference, not every single property of the struct.\nBut in the end, profile before optimization. :). > The thing that feels \"weird\" about PropertyEditor, though is that it behaves just like a property. So if I have a variable like emailEditor then it'd be weird to ask for emailEditor.value or emailEditor.producer.\nThese are more like \"committed + persisted\" values. But since we can't rename conformances... hmm, it ends up like this. That's said it might be more appropriate if it does not conform to MutablePropertyProtocol at all, given that it has different semantics than a normal mutable property.. Oops.. It refers to the redundant <()> type parameter in the inheritance clause below. Without it weird things happen.. Expected to be removed in Swift 3.1 with concrete same-type requirement.. The less indirection the better.. Every Signal means a couple more calls and locking, though we are gradually slashing a microsecond here and there.\nIt is not like a complex algorithm that does benefit from reusing implementations anyway.... Though it is hardly a problem when working with iOS. My obsession has started only because of the super high-speed scrolling in an NSTableView with many visible items.\n\ud83c\udf83. How likely are we to change this again though? It ~~are~~ is one of the pieces that perhaps would never be altered otherwise.. ~~Atomic.swap is. RecursiveAtomic.swap isn't.~~ Fixed.\n. Well, it is generally called pthread anyway... So let's make it a bit shorter.... Consider a form field that requires at least three characters. Initially it has to be invalid.. Perhaps this can wait until ComposableMutablePropertyProtocol in #182 lands. hmm?. Well, it shouldn't be hard. A SerialDisposable would do the job. In reality though, it probably wouldn't ever do you a favour, unless you really have a high traffic. But then you might want to throttle your signal or look for back pressure operators, I guess?. I'd think so.. It just makes it easier to get a valid value during composition without case switching, akin to Result.value.. Capturing only other.result but not other.. Indentation is off here. . Heh. Corrected it but forgot to push.. Since it cannot be suppressed anyway, we may deprecate it for 3.0.x too.. This would happen when building through Carthage in Swift 3.1 anyway... https://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/201869272#L821. As mentioned in AliveState:\n\nA self-retaining reference [of the signal]. It is set when there are one or more active observers.. This is not strictly necessary, since snapshot is guaranteed to live till the end of the scope. But it serves a documentation purpose, ~~and would be optimised away by the compiler IIRC~~.. The deadlock happens as the observer disposable releases the closure { _ in viewModel } here without releasing the mapped signal's updateLock first. The deinitialization triggers the propagation of terminal event of the Action, which eventually hits the mapped signal.. This (and stuff below) could use an article, and perhaps should it be in passive voice?\ns/Action/The action/. Since mutableResult might change as a result of value events from inner, we need to block modifications of inner until the validator is done.. The point is to hide warnings regardless of users' preferences, since ideally the warnings are relevant to us the maintainers only.. Perhaps should the buffering be an option?. ~~Could try to move the rest of the stuff.~~ Though as a side note, these C stuff are introduced to dodge compiler enforced #available runtime checks in lock() and unlock().\n\nos_unfair_lock is available only on macOS 10.12+, iOS 10.0+, tvOS 10.0+ and watchOS 3.0+, and our minimum deployment targets are lower than these.. No. Gonna remove it.. I think it is not possible to move the rest of the C stuff to Swift though.\nAs shown by the disassembly, all uses of the _ras_* function pointers in Swift are being resolved to the real function (or nil) at link time, e.g.\n0x104ebe2df <+95>:  jmp    0x104ec4e8a               ; symbol stub for: os_unfair_lock_lock\nwas observed in the Swift UnsafeUnfairLock.lock disassembly.\nHowever, if written in Swift, the compiler would enforce availability on any os_unfair_* references. Circumventing it in Swift would require lazily initialised variable that would not be resolvable at link time. This induces extra runtime overhead on every function call.\nUntil SR-4079 is resolved, or we move the minimum target up to iOS 10 and Sierra, dropping down to C is likely inevitable.. This is added to test how it compiles and runs on macOS 10.11.. A missing space between : and The.. One does not intentionally create a handle though... Perhaps should it be phrased as \"add returns a handle\" instead?. @mdiep \n\n(You could just as easily send the Signal and not send values on the Signal until it's been sent\u2014giving observers a chance to observe the signal.)\n\nWhile this is the ideal case, it seems the buffering is essential, say when using with flatten(.concat), which can delay the establishment of the observation.\nEdit: I'd suggest to annotate it with warnings for the potential of indefinite buffering, and perhaps offer a non-buffering variant.\nEdit: If we have to find a middle ground, perhaps the emitted inner producers should buffer until & only replay values at the first time it started (future work: a configurable #?). Subsequent starts would be invalid and emit interrupted. This should satisfy the common use cases, e.g. @iv-mexx's example, which do not retain and repeatedly start the inner producers.. Yes. Its lifetime is limited by the closure or the while loop body scope, whichever is longer.. True,. Yep.\nhttps://bugs.swift.org/browse/SR-4436\nhttps://bugs.swift.org/browse/SR-3873. For the ambiguity of then, my wild guess is that in concrete extensions, the compiler picks overloads among signatures with generic parameters resolved but no information about their original form. So the more specific overloads are ranked the same as the most generic overload.. Is it possible to make these not run for every event? They just need to be run once after all.. Please name the arguments for multi-line closures.. Ditto.. Ditto.. > I wouldn't say that this property describes the state of the Action. It's the inputs that are used\u2014consumed in a reactive way.\nThe point is though the term input is already bound to the external input from the caller-facing apply() since it is also part of the type name. So calling this input leads to two interpretations of the same term, which do not seem nice for documentation purpose.\nAfter all, this work all derived from a question of \"why is it the input when Input is Void\".\nMoreover, it is just a more specific version of init(state:enabledIf:_:), and the semantic hasn't really changed. If this shouldn't be called state, why should the most generic version be in terms of consistency?\nIf state is not the right choice, how about external input vs internal input?\n\nworkProducer is a bit misleading because it's not a producer itself\u2014it's a closure that returns a producer. So I think execute is a preferable name here as well.\n\nI can't defend workProducer in this regard. But execute doesn't seem right either, since it doesn't really execute but returns something to be executed. workFactory, producerFactory or workCustomizer are possible alternatives.. Not having this leads to infinite self recursion in the new overloads, given how Swift selects an overload for a given name.. A test case was added specifically for this set of overloads, and it doesn't appear to be ambiguous. Apparently having the return type as Self helps mitigate the ambiguity that would otherwise arise when you put these two static attempt in a concrete type extension, like SR-4436.\nMoreover, it is expected to be primarily called with trailing closures anyway, and a label can't help in this regard.. It is. I will open a separate PR for it then.\n\nThis coincidentally dodged the return type ambiguity of SignalProducer.Type.attempt, which somehow managed to get through as a protocol extension [but not as a concrete type extension].. The point of a timestamp here is that the monotonic clock never overflows because the processor is going to break down way way before this happens...\n\nI avoided monotonic counter because it was the original Bag implementation ICYMI. Somehow it was worried that the monotonic counter would overflow, so a reference-type RemovalToken was born to allow \"reindexing\" when it overflows.\nThat said like the 64-bit monotonic clock, the overflow practically can never happen unless we got 100% uptime for 100+ years running a tick per clock cycle at 4 GHz, yet a typical load-inc-store is gonna take >3 clock cycles. So it is up to us to do it on our own, or rely on the platform libraries, libdispatch in this case.. Yeah, true.. The shared aggregator interface uses (ContiguousArray<Any>) -> Void, since zip does not need the optionality.. Collection.indices holds a strong reference to the collection, and is not recommended if you gonna do in-place mutation.. It follows the precedence of Signal.observe, and the fact that CompositeDisposable.add accepts Disposable?.. Ah, I thought the trailing closure would be in conflict. But I just realize didSet can be moved as the first. \ud83d\ude1b. It would violate access exclusivity because of the \"de jure\" copy-in, copy-out semantic of inout being in conflict with the guarantee of property observers always seeing the latest value. . Ah, MutableProperty.modify needs to be changed too.. I did check the compiler source and generated object code in #342. The compiler differentiates kinds of variable storage, and maps them into different access semantics. The most relevant access semantic to this is DirectToStorage. On top of this, withUnsafeMutablePointer is just the unsafe form of the inout model.\n\nIOW as long as it is stored property that is statically dispatched or a variable, it is atomic.. I don't see this bit being dropped in the foreseeable future. It is essential, well-known part of the inout model since Swift 1.0. Better yet, Swift is OSS, so you can also say that the compiler source code already serves as the documentation, and we would always know ahead if anything could break it.\n\ud83d\ude05 . These are no longer necessary, since SourceKit has auto-suggestion that covers capitalisation.. This extension is removed since somehow the compiler cannot resolve extension Signal.Observer in this particular file. The sendNext and sendError deprecated symbols can be reintroduced later.. I can't see how ActionDisposable can emulate it. But I think it can be backed by just CompositeDisposable.. This isn't new though. Signal<Signal> flatten overloads and (self: SignalProducer, other: Signal) -> SignalProducer binary operators are all implemented by lifting the inner/rhs Signals to SignalProducer in 1.x.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Flatten.swift#L291\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Flatten.swift#L256\nFor flatten operators, the shared implementation is based on Signal<SignalProducer>.. This can be shortened to Signal<Value, NewError>.Event.. signalDisposable doesn't seem necessary.\ndisposable would be disposed of when the created Signal terminates, which in turn disposes of the observer handle anyway.. Could you please test also sending interrupted, and whether the value is really delivered when sending: .value(...) is used?. For this specific case, we need to parameterise Signal.Event anyway, so the type alias doesn't seem helping at all.. In general, SignalProducer is forever intertwined with Signal anyway, so IMO such typealias of Event or say Observer do not seem valuable.. Hmm, it is a legit race if we guarantee that the value sent by timeout must be followed by completed. You might want to use SerialDisposable for signalDisposable then, since statically the scheduled block may run before the store of the observer handle.\nEdit: The race window could be exposed sleeping in observers for value events, and let self pipe values concurrently. But since we now use os_unfair_lock, there is no reliable order to attack it.. This should work.\n```swift\nreturn Signal { observer in\n    let disposable = SerialDisposable()\ndisposable.inner = self.observe { event in\n    // Guarantee that no further event would be delivered as we emit\n    // the timeout event sequence.\n    guard !disposable.isDisposed else { return }\n    observer.action(event)\n}\n\nlet d2 = scheduler.schedule(after: date) {\n    disposable.dispose()\n    observer.action(event)\n\n    if !event.isTerminating {\n        observer.sendCompleted()\n    }\n}\n\nreturn ActionDisposable { disposable.dispose(); d2?.dispose() }\n\n}\n``.Actions are disabled when executing.. There are eight combinations in total, and only four need to be acted on.. The signal ofActionStateis deliberately ignored, sinceSignal` doesn't support recursion with value events. \nactionState deadlocks when one does isEnabled <~ isExecuting and both are derived from it, i.e. the current implementation.. The problem is that isEnabled and isExecuting are not independent. They together form a finite state machine, and IMO named cases are easier to understand than a switch with tuples of booleans.. Changed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/400/commits/4acaf81a54c9da4940b8484cf745f73ae3fd14d7 anyway.. Reverted in https://github.com/ReactiveCocoa/ReactiveSwift/pull/400/commits/4acaf81a54c9da4940b8484cf745f73ae3fd14d7.. Done in https://github.com/ReactiveCocoa/ReactiveSwift/pull/400/commits/4acaf81a54c9da4940b8484cf745f73ae3fd14d7.. In https://github.com/ReactiveCocoa/ReactiveSwift/pull/400/commits/4acaf81a54c9da4940b8484cf745f73ae3fd14d7, the read-only isEnabled is once again derived since we are permitting only state <~ isExecuting here, where state is the state of the Action that flips its availability (isEnabled).. It isn't necessary, just that it allows one adds promoteError to everything in a brute force manner, while not yielding extra Signals in cases with the identical error types. Say if you do:\nswift\nSignalProducer<Int, CocoaError>.combineLatest(\n    SignalProducer<Int, CocoaError>.empty.promoteError(),\n    SignalProducer<Int, NoError>.empty.promoteError()\n)\nThe resulting Signal graph would be equivalent to:\nswift\nSignalProducer<Int, CocoaError>.combineLatest(\n    SignalProducer<Int, CocoaError>.empty,\n    SignalProducer<Int, NoError>.empty.promoteError()\n). Perhaps I should be more careful about my wordings. The overload does not add any capability, and is just a fast path when the compiler knows Self.Error is the Error of the return producer.\nSay SignalProducer<Int, CocoaError>.empty.promoteError(CocoaError.self).. True. That does sound better.. The point of giving it its own backing is that isExecuting calls out to the observers outside the signal of actionState, so that when actionState is modified reactively & synchronously it doesn't deadlock.\nHowever, it does seem violating exclusivity of access so it might need a change anyway. We might need to add guards in MutableProperty to prevent nested modifications too, or rely on the dynamic endorcement in Swift 4.. notifiesExecutionState is set to true when the current execution attempt succeeds and starts. didSet is invoked after the trailing closure modifying actionState.. Ah, I forgot to revert this hack for benchmarking purpose. \ud83e\udd26\u200d\u2642\ufe0f. It limits the concurrency, but AFAIKT does not affect the assertion here which was about the mitigated data race between the two blocks, not across iterations.. Yes.. Ugh, you are right.. Just a bunch of test cases to verify these combinations would emit the error message. Moving them to the spec would flood the IDE with warnings, so I just commented them out. \ud83e\udd26\u200d\u2642\ufe0f . Well plans are always subject to change. Let's stick to 4.x for now.. The only change is that schedule that is done immediately no longer returns a disposable, aligning to the semantic of ImmediateScheduler. Per the Scheduler contract, it is wrong to assume schedule would always return a cancellation token anyway.\nFor async, the behaviour is the same.. Argh, you catch a flaw I've made.. It was there before. It is basically how we implement cancellation with GCD (and NSOperation).\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/439/commits/04b4ddf4500a2f93dcbef286ace2d899c0918621#diff-f045af08e7f58fd005590d376ccd1215L141. It is a result of an aggressive action, while status is passive state of a matter. Output is still a choice, but it felt too generic for me. We can also revert to ValidatorOutput.. One less level of pointer chasing at runtime, while working around Swift's lack of guarantee in memory location.\nManagedBufferPointer has the flexibility to allocate memory as part of the instance, while guaranteed to hand a stable pointer offset from self. So instead of storing a reference to the lock somewhere in the heap, UnfairLock and PthreadLock now stores the lock itself.\nStoring the lock inline isn't particularly rare in the C/C++ domain e.g. WTF::Lock, while here being bound to the lack of compiler guarantees we cannot make any assumption on & references to stored properties of self. So we kinda \"abuse\" ManagedBufferPointer to achieve this despite it being intended for custom CoW collections.\nWhile the difference in locking performance alone might be trivial, given how fine grained locks are used in RAS and by RAS users, I think it is still worth to pursue, esp. overhead on the dynamic memory allocator.. This is not a lock, but a custom atomic increment/decrement that is aware of the special -1 case. To some extent it is just a simple ARC clone.\nUnlike a spin lock, forward progress is guaranteed even with priority inversion (even if that would mean cache line ping-pong).. > I'd prefer to see us use Atomic like in #453\u2014at least to reestablish correctness. Afterwards we could consider an optimization like this.\nTo be fair, the Signal core itself is already an Atomic and acts like one for all writes, just with the storage and the lock inlined.\nupdateState(_:) is just a synonym of modify(_:).. Both the terminal path and the value path run this at the end.. tryToCommitTermination already locks the state to check if it is terminating or not. So the locking here is pointless.. This is resurrected because acquiring the spinlock is consistently & considerably faster than calling tryToCommitTermination() on my machine (>5% per observer callout). \ud83e\udd26\u200d\u2642\ufe0f. It would mess up the promise of no event being sent after any terminal event, unless we track termimation per observer. In general attached observers do not need auto interruption.\nDetaching an observer could use an interrupted event though.. IMO Observer is part of the Signal contract.\nIt also breaks the useful guarantee of terminal events being sent at most once, that would potentially break things e.g. cleaning up resource twice, triggering cancellation code after successful completion.. Since we don't have generalised existential for now, we would need a type-erased wrapper if we use protocol.\nIn the end, it would be similar to what SignalProducerCore is doing here.. Yep that was removed during the iteration when #494 is represented in the form of Snapshot<[Snapshot]>. But at this point I think it is okay to put it back in.. #494 uses it for its SectionedChangeset.. This heterogeneous representation is not a nice format to consume..\nSay if you are interested in only a specific kind of operations at a time, you are forced to parse all of the changes again and again. It is even worse if you need anything more than enumeration.\nIt is also worth noting the implicit order between all these offsets (pre-deletion & post-insertion). In the event of blindly enumerating it, a heterogeneous array promises the order, while Changeset makes it explicit and shifts the responsibility to the user.\nIn event of a high volume of changes that aren't moves, we would also have 50% of memory wasted. But the difference is trivial in the grand scheme of things (singe digit KiB for <1000 changes).\nMoreover, these information can all be prepared by the diffing algorithm as standalone index sets with no extra cost.\nIt is not that relevant for UITableView and UICollectionView, since they cache the indices within their batch update calls. But in general, I think it is better to pack it in a reasonably easy-to-use format, that shouldn't require observers to transform it before consumption.\n494 is one of the example of how it is used outside the collection views. Notice how the individual index sets are enumerated and tested.\nLast but not least, IndexSet is the out-of-the-box, sorted collection for this purpose. ;). Not yet. But you can be assured that the bounds check are gone, which would be there otherwise due to optimisers being able to eliminate/mitigate bounds checking only for concrete Array types. :p. Agreed.. Instead of inheritance, it can also be implemented with an enum backing (what Foundation Data uses).\nhttps://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/Data.swift. Hmm, I just realised that EventTransformingCore relies on the inheritance to erase generic parameters. So unless we ditch EventTransformingCore, an enum backing cannot sufficiently represent all these. :thinking:. Can we treat it as disposed then? It still makes sense for its use case.. This is a shared disposable for constant producers that practically would never be disposed of, because they terminate before the disposable is returned.\nWhen I iterate on the design, benchmark shows allocation contributes considerable overhead over NopDisposable.shared (which uses swift_once). I could check again to see if the numbers are still high though.. Sadly, we have to retain observers marked with interruptsOnDeinit, and retaining it using a thunk adds an overhead to all calls to the observer, as opposed to an 8 byte storage for a reference. :|\n```swift\n// @testEventTransformingCoreMapFilter(): avg 6091 ns; min 5250 ns\nself.action = transform(observer.action)\nself.wrapped = observer\n// @testEventTransformingCoreMapFilter(): avg 6238 ns; min 5402 ns\nself.action = transform { observer.action($0) }\n``. This is the current behaviour which was part of the operator lifting change (#140), although onlyobserve(on:)` was mentioned in the release note. The related issue was #227.\n\ninterrupted now respects observe(on:). (#140)\nWhen a produced Signal is interrupted, if observe(on:) is the last applied operator, interrupted would now be delivered on the Scheduler passed to observe(on:) just like other events.\n\nThere are two directions of propagation involved here:\n\n\nBackward disposals to the upstream leaves.\n    This is generally immediate. Note that Signals created by lifted operators are not disposed of directly, but upon receiving interrupted. \n\n\nForward delivery of interrupted.\n    This respects any async operators along the path, e.g. observe(on:), throttle and debounce which forwards all events on the specified scheduler.. Disposals: ** <------------------ D1\n                                  ** <--------------------------- D2\nEvents:    P1 -> map -> filter -> P2 -> map -> take -> observe -> P3\n\n\nDisposing of D2 causes produced signal P2 to emit interrupted immediately (in general). The map-take-observe chain would then receive interrupted. P3 would not observe interrupted immediately, but the asynchrony and the serial event order are respected.. We do not have a case for performance here yet, just the room for optimization.\n\nSince there's only one signal, all the strategies are functionally equivalent. \n\nrace propagates interrupted from the inner stream to the flattened stream. The other strategies do not.. Hmm, so the strategy is more or less relevant. race gives the closest semantic to then (which is essentially flatMapCompleted).. Oh, I just realised I might have read your question wrong. But the stuff above is still relevant.\n\nit doesn't look like that interruption will propagate through to the scheduler here.\n\nThe interruption of an event transform is always an interrupted event emitted by an upstream. In the implementation of throttle, all terminal events are scheduled to the given scheduler.\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/512/files/87592cd3f0968f35af8bd23f07cc02263ffad675#diff-c949eaeac664030204497a79420aaef3R724\nLet's say if we interrupt a started SignalProducer(signal).throttle(...), the interruption is triggered on the produced signal, but not throttle which is now an event transform. The produced signal then sends out an interrupted event, which would be received by throttle.. There are occasions of redundant constraints being kept. For example, removing this would cause the associated type inference of mutable property types to fail.. These are removed basically because PropertyProtocol is now constrained with Error == NoError. They were once added because of build time issues.. lifetime += disposable should work, and I have already replaced most of them.. Please start the line with 1... I thought this is Equatable based, and the stdlib floating point types already imply IEEE 754 compliant equality for ==.\nEdit: Could you elaborate on why this has come up in your mind?\n\nmakes people get inside Nimble and look for necessary overload to make sure whether expression is not false-positive.. == are the fluent conveniences of the matchers that are meant to help reduce the verbosity AFAIK. It could be confusing for Swift newcomers with C family language background, but IMO it does make sense given equality and inequality in Swift are implemented as operators, with compile time overloading & type safety guarding for the problems you may otherwise encounter.. This is a dup line actually and should be removed. \ud83d\ude05 . On top of locking, the signal needs to be alive before we proceed to deliver the value.. Does it need to be an optional? An empty array seems to be semantically equivalent to nil in this case.. Indentation is one level deeper than it should be.. It seems that it is similar to throttle, just that it queues all instead of just the latest occurrence. I wonder if we should extend throttle to have a ThrottleStrategy instead.. \"should not concat the error\", perhaps?. \u201cshould not concat a subsequent error if the earlier producer has failed\u201d?. Please place let before the case name. The RAS codebase has a convention of having value binding pattern indicator \"globally\" regardless of the number of bound values. \ud83d\ude3a . The base name makes sense, since it is more than just time shifting. delay could fall under this too.. I would prefer to have the strategy first though, akin to flatMap.. Hmm, what about throttle as the base name, and skipPrevious, deferLatest and all as the strategies?. It is quite hard to be concise without bringing in new verbs. Like grace, silence, coalescing+distancing, etc.\n\nIt does make me wonder if we express them in combinations though. Say .distance(.all) being the bottleneck strategy proposed here, while .distance(.latest) being the current throttle. debounce can be .silence(.latest), and .silence(.all) would be effectively defer.. I was talking about distance and silence as strategy names with throttle as the base name.. You might scope the scheduling call in a function, so that the disposable is guaranteed to be deinitialised.. It'd probably be better off as two separate test cases. One for cancellation, while another for not retaining the disposable.. You may use Atomic. I'd prefer Set which fits the scenario here (insert/removal only).. Please add the PR no & your handle.. You may replace this with fail(\"message\").. For the cancellation test, I'd wait for 1.5-2x the interval after resuming the queue so that the test case could actually fail.. Please use ObjectIdentifier(value).hashValue. The Dispatch protocol hierarchies do not inherit from NSObjectProtocol on platforms w/o ObjC interop. . Could we weakify self here?. This should be disposable2. The macOS CI seems failing because of this.. IIRC expect uses @autoclosure, so it is already implicitly captured.. Ditto for @autoclosure.. [Nit] New property operator: filter. \ud83d\ude1b . Remove .init.. Perhaps this?\n\nResult now interoperates with SignalProducer n-ary operators as a constant producer.. [Nit] Could you replace i with index?. underestimatedCount is not guaranteed to equal the exact number of elements. We should derive this from the ContiguousArray constructed from elements.. The returned Boolean indicates whether the caller is the one uniquely transitioned the state, which is critical to most use cases.. > SignalProducer.merge now accepts any combination of SignalProducerConvertible conforming types.. U can be replaced by Replacement.Value.. Ditto.. Ditto. NewError can be replaced by Replacement.Error too.. Why is there a new variant?. F can be replaced by Inner.Error.. Ditto.. Ditto.. Property.init(initial:then:).. @ra1028 I think it is a reasonable solution & should be applied to existing operators anticipating SignalProducerConvertible too. Contextual lookup plays an important role in expressivity.\n\nThat's said, please try if a default implementation of static var empty: SignalProducer<Value, Error> on the protocol works.. It is not just .empty but also .init and generic expressions which is handful when contextual lookup & type inference work. So yes.. -> Disposable?.. Perhaps this? cc @ReactiveCocoa/reactiveswift \n\nTransform the error to NoError beforehand, or use startWithResult instead. Ditto. [Nit] Whitespace. [Nit] Whitespace. [Nit] Indentation.. [Nit] Indentation.. Could we specify discardsWhenTerminated: true here explicitly?. Ditto.. The test case group above should be renamed likewise, and perhaps:\ndiscarding the latest value when terminated. > if there is no pending value. I agree, and failed should follow suit since by contract failures behave like exceptions and propagate immediately.. > If you've canceled the work, then you're not interested in any other results.\n\nThe same applies to failed IMO. If the stream has failed, I don't think emitting the pending value would make any difference.. > debounce now offers an opt-in behaviour to preserve the pending value when the signal or producer completes. You may enable it by specifying discardsWhenCompleted as false.. /pendingDate/previousDate/. /termination/completion/. Use spaces instead of tabs for comments.. Use spaces instead of tabs for comments.. Use spaces instead of tabs for comments.. To disambiguate when contextual lookup is used with these operators. Context: https://github.com/ReactiveCocoa/ReactiveSwift/pull/611#discussion_r170457763\nIdeally there should be a way of saying Next by default would be SignalProducer, for example. But there wasn't so the only option is relying on overloading.. d is disposed already as part of the lifetime observer, so repeating it here is not necessary.. I am not quite convinced, because usually there is an owner whose lifetime the binding target can use.. Input Observers have to be owned by someone, and IMO it should be that someone who uses its own lifetime to create the binding target for the pipe.\nWe could have a convenience that takes a lifetime to create a binding target though.. This strongly captures self by the way, which goes against the contract of <~.. The Action is not validating the state though. It is accepting validated results. Perhaps validated as the label instead?. Why is it not right though? Given an email address for example, Action(validated: email) looks fine for me. That\u2019s said if we have to be more explicit, it could be validValuesFrom: or predicating if a gerund is preferred.. @ReactiveCocoa/reactiveswift @mdiep @Marcocanc Any second opinion?. This changes the semantic. This overload was supposed to be the primary one, and the removed one here should have been implemented in terms of that.\nEdit: Dropping down to PropertyProtocol leads to only successfully validated values from other being considered, while the intended semantic is to propagate any proposed value (regardless of its validation outcome) so that live validations are always reacting to any user interaction made.. I guess at this point we should just treat EAGAIN as EBUSY. Just found this issue: https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3598.. The weirdest thing is that based on the libpthread implementation only the recursive lock can return EAGAIN, and it holds for implementations since El Capitan GM. All the reported issues do not seem to involve properties which are the only thing using recursive locks in ReactiveSwift.. We need to check isDisposed again after swapping, since self could be disposed of in parallel during the process, racing against https://github.com/ReactiveCocoa/ReactiveSwift/pull/688/files#diff-7056bb5d45375e26f2eeb3adeabac16bR373.. Change suggestions do not seem to be available in this repo.\nEssentially, we need to do this after the swapping in the else path:\nif isDisposed {\n    _inner.swap(nil)?.dispose()\n}\nBecause dispose() can be called in parallel to inner = new on different threads. Depending on the order observed by the system memory, it could yield a boundary case where isDisposed is true but the inner disposable is left untouched. The conflicting path may \n\nI always thought that such operations should not be done in a multi-threading fashion, so it will be the users responsibility to serialize correctly.\n\nDisposables have always meant to be thread safe, despite us not explicitly having written this as part of the contract.. FIFO order needs to be maintained in recursive scheduling scenarios. Those recursively scheduled actions should not jump all the previously enqueued ASAP actions, if we adhere to the semantics established with UIScheduler.. ",
    "neilpa": "I would also think it's better to batch up all the possible churn (even if it's slightly more) than spreading it out into multiple changes.\n. I think we should start at 1.0 since this is a new library even though it's based on the existing RAC code.\n. I don't have a strong opinion either way. I'll also add that we may not always track Swift versions w/ this lib.\n. Yea, the idea I was to extract the Cocoa-specific bindings and use that as a new baseline for a Swift-centric Reactive Cocoa. The rest of Rex was mostly experimental operators that were ports from other Objective-C projects of mine. Those are probably too specific to be included in ReactiveSwift.\n. It's been a couple years since I've tested it, but we noticed similar lag on larger iOS scroll views with deep signal chains. Hence why I went with the direct implementation here originally.. typo amits. I think so, otherwise consumers could miss events without realizing it. Hence why I erred on the side of buffering. I could be convinced otherwise, but I'm not sure how to best communicate those semantics at the operator level.. ",
    "liscio": "I'll add my vote to the \"break everything now rather than later\" pile. Seeing how it's already a huge job to port the growing codebase that I have to swift 3, I might as well get all this renaming handled together in one shot. \ud83d\ude1b \n. > I thought I'd release a 3.0.0-alpha.1 version sometime this week.\n@mdiep Any reason it wouldn't be a 1.0.0-alpha.1? Is it following the mindset that 1.0.0 was effectively the \"swifty bits\" of RAC 3, putting us at the 3rd major API release?\n. Yikes. dismissAnimated was a MutableProperty?  That's smellier than the Objective-C 2.0 anti-pattern of calling methods that don't take parameters using dot notation\u2026\n@andersio I'm not sure I fully understand the need for any write-only properties, to be honest. Do you have any examples where you'd need to \"bind\" something to a dismissAnimated call?\nAlso, your example of a UILabel doesn't quite work as a write-only ~~binding~~ property. It would still have to be a MutableProperty because there is an underlying value in the control that has a \"current value,\" and does still change (albeit for different reasons.)\nEdit: Sorry\u2014I mixed up my terminology between binding & property above. We definitely need to continue distinguishing between a \"binding target\" and a source of changes. I'm still not even sold on the idea that a control should expose a MutableProperty, because of the \"feedback loop issues\" that carries along with it.\n. > BindingTarget in action:\nSeeing it in use is very helpful, thanks! I much prefer this model to the MutableProperty values that get bound at runtime using objc_setAssociatedObject.\n. > We probably need an extension like this:\nShould we not instead remove the use of Date entirely in favour of DispatchTime? I never did like using {NS,}Date to represent a point in time\u2026\nThe usage gets much nicer, too. Compare using Date().addingDispatchTimeInterval(.milliseconds(300)) vs. .now() + .milliseconds(300), for example.\n. I've gone ahead and done much of the work already here for a whole-hog replacement of Date and TimeInterval: https://github.com/ReactiveCocoa/ReactiveSwift/compare/master...liscio:cl-dispatchwalltime\nUnfortunately, it appears that DispatchWallTime (and DispatchTime, but we don't want to base our scheduler on that) is busted in the Swift standard library. I filed a bug (SR-2807) to track the issues I encountered. Specifically, the crash when comparing two DispatchWallTimes is going to block progress.\n. I've also gone ahead and opened #48 with the approach that was originally proposed, since it's not practical to expect the above issue to get corrected in time for 1.0.\n. This latest change addresses the formatting, as well as passing the target along in the DispatchQueue initializer.\n. > Easy conformance: just consume(:). But for those overriding <~(Self, Signal), consume(:) is useless but still needs to be implemented. (Currently in master)\nI like the idea of easy conformance, however with the introduction of BindingTarget I think that this point is moot. We should drive API users to expose a BindingTarget class instance rather than e.g. declaring BindingTargetProtocol conformance directly on their types, so the # of additions of conforming types will be small once all this work is complete.\n\nForcing all conforming types to implement their own <~(Self, Signal). (This PR)\n\nThe downside here is that we may lose the centralized documentation for the <~ operator in the IDE. (I hope I'm not the only person that command-clicks on custom operators in Xcode?)\nBut this is a very small downside. The indexer barely works most of the time for me, anyway\u2026\n. > The latest commit restores the use of concrete types of signals and producers in the BindingTargetProtocol extensions and requirements, since the protocols of these are just used for constraining the extensions.\nYes! I was trying to achieve this myself and could not get it to work out because I was going about it all wrong. I was trying to declare an associated type that represented the incoming signal, but then that limited my ability to have >1 type of incoming source (i.e. both signals and producers.)\n. @gkaimakas This is something I hope to address in the UI programming guidelines PR that's open against ReactiveCocoa right now, however there's definitely a case to be made for making a non-UI version that can be referenced as a part of that guide.\nFrankly it's difficult to find the \"right answers\" for a few specific cases (Property vs SignalProducer use, etc.) but the ones you specify are pretty easy to explain.\n. @NachoSoto I'm pretty sure I addressed everything you pointed out. Let me know if I missed anything (or created any new issues.) Removing [WIP] tag\u2026\n. @NachoSoto Everything look OK to you for this to go in? \nAny others want to take a look? @mdiep, @andersio? The related issue (#33) is the last item on the 1.0 milestone.\n. I'm not loving this idea at all, as I think we're heading down the wrong path if we continue trying to force properties onto controls. More on this here: https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3229#issuecomment-251395000\n. @mdiep one that I came up with myself was a \"bridge to the imperative world\" similar to the following:\n``` swift\nfinal class SomeDatabaseThingy {\n    // Something that performs a flush of the underlying database on a successful fetch\n    let flushAction: Action \nlet fetchOperation: SignalProducer<SomeValue?, NoError>\n\nfunc doAFetch() {\n    fetchOperation.startWithSignal { signal, _ in\n        // Something that stores the fetchOperation result in the database\n        someProperty <~ signal\n        flushAction <~ signal.map { $0 != nil }\n    }\n}\n\n}\n```\nThe alternative, of course, would be to use .on(next:) to call the database's flush operation. This is likely not a great example of usage, but it was all I could come up with. :)\n. I think that it makes more sense to simply discourage things like dismissAnimated() being wrapped in actions rather than taking away this potentially useful feature. \nI'm closing this one out so we don't have to waste any more cycles on it\u2026\n. Yeah, originally when I started out I was weary of the <~ operator because it seemed strange. However, as @kaybutter raised it's difficult to express directionality without the operator\u2014especially because bindings are (and will be for a long time) unidirectional.\nWe expect that new users will at least have some initial familiarity with the API (via the README, etc.) by the time they've started working with the framework so I'm not concerned that the operator will be completely foreign.\n. Is there somewhere in ReactiveSwift / ReactiveCocoa that would benefit from these convenience methods? \nI think it'd be helpful if the PR also included some improved internal implementations that take advantage of these, if that's the case.\n. @mdiep At the moment I use it in places where I'd have used RACSubject in the past. For instance, I have a \"view controller configuration\" protocol that vends a SignalProducer<UIViewController,NSError> whenever a cell is selected. \nIt's not appropriate to store a mutable property containing SignalProducer<UIViewController,NSError>, but sending values to a Subject makes more sense. When the view controller is loaded/ready, it just sits and watches for that view controller to be pushed.\nWhen this originally surfaced, @andersio and I were speaking about the common \"table view cell configuration\" pattern where we'd often just store properties containing the model values to be displayed, however we found that this might actually be a better solution\u2014there's no additional storage required as the values are simply piped through to the destination UI components.\nI don't use it in this way (yet), but it's on my list to investigate in the future as it seemed like a good idea to avoid building too many layers of storage.\nUnit tests would be a lot nicer as well, because we use the pipe() pattern a lot there for testing. \nThe drawback of using an Observer (or Pipe) over the pipe() tuple is the ability to split the visibility of the two items. For instance, the observer could be made private, and the signal public.\n. @NachoSoto \n\nI've seen this misused more often than not in RX frameworks.\n\nCould you elaborate a little bit on this misuse, and how we get around it in the current design? \nThis might help us to offer a path (and good explanation) to those that might wonder how to achieve what they did using RACSubject in the past.\n. I almost feel like it'd make more sense to have Signal.pipe() just return a new type (like Pipe) that works similarly to a RACSubject stand-in.\nIt'd just be a struct that holds input and output, or signal and observer, but we could take it further and have it conform to the right protocols so it'd behave like the old RACSubject so we can use operators with it directly. \ud83d\ude1b. Changes look good, but I agree that the naming is unfortunate. I initially wondered why observe had to be changed everywhere and then realized my misunderstanding.\nWith that said, what are your thoughts on addObserver(_:during:)?. @mdiep My original distaste for observe is based on passed an Observer instance without acknowledging the Observer itself.\nMaybe observe(with:during:) is the compromise? In fact, I'd prefer if most of the commonly-used trailing closure methods would name the observer/closure that is passed in, so it reads better in the cases where an instance is used instead.\nFor example, if we had a signal's pipe somewhere, just called pipe for simplicity:\nswift\nsomeSignal.observe(pipe, during: some.lifetime)\nsomeSignal.observe(using: pipe, during: some.lifetime) // reads better, IMO\n(And forgive me if we've had this discussion before re: the other methods like observeValues(_:) vs observeValues(using:). Brain might as well be applesauce at this point\u2026)\n. > But when I attempt to implement it, it is really a shithole... Apparently something is wrong with the type checker with operators. Though they are apparently fixed in Swift 3.1. So we could revisit these in 2.0.\nA major reason why I gave up and wrote a lot of the new Capo 3.5 stuff in straight-up Objective-C. So much time that I didn't have to waste chasing down the \"how to do this\", \"is it the compiler\", \"is it me\", or \"is it the API?\" issues. It's amazing how much nicer life is with a compiler and tools that work!\n(But now I'm back to writing more swift3 code and hating life again. Don't worry\u2026 \ud83d\ude04). That's the trouble I have, personally. I spend far too much time in the 10%. ;)\nI don't want to give the impression that I dislike the language, or working with it. It's just that when I'm in a time crunch, I can't have my tools adding 20-40% overhead in added compile times, time spent spinning my wheels tracking down unhelpful error messages, etc.\nAnyway, this isn't the place to gripe about swift! \ud83d\ude4a . @RuiAAPeres Mutability is not the same as editing, necessarily. In this case, PropertyEditor is a \"thing that makes edits to a property,\" often on behalf of the user. I'd be totally on your side if we had went with EditableProperty instead, which would apply to your logic more closely. (That would read like \"property that is able to be edited\" rather than \"editor of properties.\")\nIf it makes you feel any better, AppKit uses a similar naming to represent an editor in the NSEditor protocol. In the case of NSEditor, you can think of it as managing/reporting the editing state of the representedObject in a view controller, or the objectValue in a control.\nWhat we have here is quite different than NSEditor, and it wraps up the following concepts from AppKit:\n\nNSValueTransformer\nProperty Validation\n\nI think the above bits combine well into a \"thing that is making/managing/watching edits on a property.\". > @liscio are you happy with the changes?\n@RuiAAPeres Do I ever seem happy with changes? ;)\n@andersio and I spoke briefly on the Slack about whether Error is appropriate for the replaced value case, or if instead that scenario should be eliminated in favor of the API user supplying their own Value that allows for replacement. But the discussion didn't really result in anything constructive (my fault\u2014been swamped.)\nMy worry specifically was that appending to the \"Error Space\" isn't going to work if you consider that suddenly you need to handle that kind of error everywhere something can go wrong (even though this represents that you've just worked around the error, and it's no longer a problem.)\nSo, yeah\u2014I think the replacement case might have to get backed out after all, and I'll have to think on an alternative for that scenario. Maybe mapping errors through another adapter that \"massages\" bad values is a better approach. (Not part of this PR/construct, though\u2014it might have to exist simply as a \"recipe\" in the future.). > The substituted state is just an aggregate of the proposed value, the substituted value, and an optional error context.\n@andersio While the error is optional, it shares the same Error type as the .error case which is what I am feeling strange about. If you choose to replace the value, the context supplied with that replacement must be the same kind of error as an actual failure.\nI don't know that this is actually a problem or not, so I think for the interest of pushing this forward I'll say that making the error optional is probably a good compromise for now. We can adjust this later on if we find it troublesome in practice.\nOther than @mdiep's pending documentation requests I should be good for this going in.. I don't see the value of having a new type to represent this.\nAs a consumer of an API like ReactiveSwift, I think it's nice and compact to think in terms of the two major constructs (Signal and SignalProducer). If you wanted to represent something like a Future using a Single, then I'd argue a SignalProducer makes far more sense because the caller is in control of kicking off the process that results in the value they are looking for. The same goes for SignalProducer.init(value:) or SignalProducer.init(error:)\u2014it nicely captures the narrow scope of the created producer.\nFurthermore, if the caller of an API vending a Signal{,Producer} is concerned about ensuring they only get a single value, then take(1) is a succinct way to assert exactly that in the code.\nPerhaps a few examples of ReactiveSwift (pseudo-)code that'd be improved by Single would help sway my current \ud83d\udc4e attitude towards this. :). > I don't think a named parameter is necessary either. If we did add a label, with or using seems most correct. But I think that draws attention away from the observe part of the name.\n@mdiep The trouble, though, is the most likely variable naming to follow as illustrated above. observe(observer) is far less readable than observe(using: observer). Those that supply a trailing closure won't need to worry about the label\u2026\nAlso, FWIW we talked about this briefly here: https://github.com/ReactiveCocoa/ReactiveSwift/pull/178#issuecomment-268997170\n@yoching I really like observed(by:) except for the fact that you don't get a Signal out as a result. I think that's not going to work because it doesn't follow the API naming conventions.. My trouble with with is the fact that it's the same word that is dropped from Objective-C API when imported by Swift. I prefer using because it's a verb rather than a preposition. Unfortunately, as @mdiep points out, using is rarely found in existing ObjC API so I'm OK with with.\n(Random thought: If Observer was an honest-to-goodness object (one that could have methods of its own) then the solution would be obvious: we'd add Observer.observe(_ signal: Signal<Value,Error>) and all would make sense. I find it hard to find the inverse of that language\u2014getObserved(by:) is beyond awkward, and again, observed(by:) won't work for API guideline reasons.). What you've pasted is not a great approach as it requires capturing state from outside the signal graph. Unfortunately, these \"bounce-back edits\" are a difficult problem we've been trying to find a nice solution for.\n(Also, on another note, I'd recommend against using continuousStringValues as in your UI example animation above. There's no need to have every digit propagate back into the model like that, and instead you want to take the values only when the user's done editing.). I should clarify. Filtering on distinct values is not the solution to the problem we're having (which is recursive / looping signal flows). You pasted code which attempts to accomplish the same thing as what you propose in your own words:\n\nThe proposition is to add a special binding operator that would update the the value only if it differs from the current.\n\nAnd then, you continue:\n\nThe new api is great and making this feature part of the core would be simply awesome, not to mention that it would solve the problem.\n\nSuch a filter would provide a band-aid solution rather than solve the actual problem, and I don't think that it's a direction we're looking to pursue.\nAs for your specific example of a preference pane, I think that you'd be better served by a distinct ViewModel-like object that acts as the \"referee\" for these changes. It could expose separate SignalProducers and BindingTargets for each of the properties you can modify and view.\nThen, even better is that you can make sure you're avoiding any of these weird loops/etc in unit tests before you hook up the view to it.\nBut I'd even rewind further and reconsider whether it's even necessary to monitor the user defaults for changes to begin with. I usually implement all my UserDefaults settings as \"write-through\". That is, all user-supplied changes are written into UserDefaults. Then, when model objects are first initialized I set their defaults using the ones that were last stored in UserDefaults.\nThis obviously doesn't work well if you have >1 place to modify these defaults as stored in the UserDefaults system, and need to obtain the current value. But I'd argue that such a setup is probably not a good idea anyway\u2014UserDefaults should not serve as part of your model layer. :). Side note: The example code above makes reference to a ViewModelProtocol. There's not much to it, so here it is: \n``` swift\nprotocol ViewModelProtocol {\n    associatedtype Model\n    var model: MutableProperty { get }\n}\nextension ViewModelProtocol {\n    func bind(to model: Model) {\n        self.model.value = model\n    }\n}\n```\nLooks pretty minimal, but if you build a generic data source for a table or collection view, then you can easily combine the above to create a default implementation for configuring your cells. Something like:\n``` swift\nprotocol ReactiveBindingViewType {\n    associatedtype ViewModel\n    var viewModel: ViewModel { get }\n}\n// Imagine a MyFancyDataSource with Cell and Model associatedtypes\nextension MyFancyDataSource where Cell: ReactiveBindingViewType, Cell.ViewModel: ViewModelProtocol, Cell.ViewModel == Model {\n  func configure(cell: Cell, at indexPath: IndexPath) {\n    cell.viewModel.bind(to: self.item(at: indexPath))\n  }\n}\n```\nI don't quite use it in this way myself, but it's been handy.. @iv-mexx Yes, your interpretation is correct. Here's an excerpt where the UI binding is actually done. The HeaderTableViewCell is a very simple superclass that only really defines the @IBOutlets.\n``` swift\nclass AlbumItemTableViewCell: HeaderTableViewCell, ReactiveBindingViewType {\n    var viewModel = AlbumViewModel()\noverride static var nib: UINib? {\n    return UINib(nibName: \"AlbumItemCell\", bundle: nil)\n}\n\noverride func awakeFromNib() {\n    super.awakeFromNib()\n\n    let resetImage = SignalProducer(reactive.trigger(for: #selector(self.prepareForReuse)).map { nil as UIImage? })\n\n    primaryLabel.reactive.text <~ viewModel.title\n    secondaryLabel.reactive.text <~ viewModel.albumArtist\n    tertiaryLabel.reactive.text <~ viewModel.trackText\n    albumImageView.reactive.image <~ SignalProducer([resetImage, viewModel.artwork]).flatten(.merge)\n\n    if let blurImageView = self.backgroundView as? UIImageView {\n        blurImageView.reactive.image <~ SignalProducer([resetImage, viewModel.blurredArtwork]).flatten(.merge)\n    }\n}\n\n}\n```\nSo there's almost nothing in the view/cell classes themselves, as you can see. The only \"trickiness\" here is my use of a resetImage signal that clears the UIImageView when prepareForReuse is called.\nRegarding your question about a lazy() operator, it's not really the same because the value evaluation must be performed when the signal is started.. > I think the need here is a valid one. I think we should make it easy to turn non-reactive, synchronous code into reactive, asynchronous code.\nThat's the primary motivation to use RAS to begin with. For me, anyway. :)\n\nBut I'm not sold on the specifics of the API. It seems like the mechanism for this should be exposed as an operator on Signal and SignalProducer. Then we can also add an operator to Property.\n\nI suppose this could be grafted onto Signal (or perhaps SignalProtocol?) as well, since it's really just a wrapper for a specialized case of flatMap(.latest), anyway.\nThe only remaining question I have is whether it's equally as valuable in those scenarios, and whether there'd be some (minor) harm in adding confusion. Specifically, throwing lens out there onto the Signal family might cause folks to misuse (or over-use) it where they could/should be using map instead.\nBut maybe it's not such a bad thing, in reality. Best practices will (eventually) emerge\u2026\n\nI'm curious what you think of that and how you'd update the proposal to reflect that. I have another thought, but I want to see what you'd do there without the influence of it. \ud83d\ude04\n\nI think it's a fine idea, but I'm curious about what your other thought is.\nAlso, what are your thoughts on using just the name lens, as I implemented it in the PR? The lazy aspect is irrelevant outside of the implementation, and I think that it differs from a straight-up map operation because this is not really a transformation \"in spirit.\". > I think the name lens will be confusing for people. It adds another concept\u2014and one that is increasingly heard of, but not necessarily understood.\nI agree, though one could argue the same for flatten and map. But yeah\u2014lens is still a pretty \"fringe\" concept.\n\nAnd I'm not sure it's a truly valid use without a setter.\n\nI added a setter in the associated PR, but it makes most sense when lens is attached to the {Mutable,}Property pair.\nThe lens terminology definitely works best when it's associated with the Property types, as it currently stands right now.\n\nWhile this is different than map, it's not necessarily that different from filterMap (#232). So I'm wondering if it'd make sense to add this as something like lazyMap.\n\nlazyMap might work here as an alternate name, but then it re-raises the question that @iv-mexx had about whether lazy could be generalized somehow for other uses. I'll see if I can come up with something, but who knows.. This idea (kind of) died in favour of more targeted operators for now. #240 was merged with the read side, and #241 may serve as the write side, if it succeeds.. I have also just now added the writing side as well in the PR, because it was far too tempting.\nUsing lenses for reading and writing isn't appropriate for all situations, but it's certainly useful when transacting using value types, and you wish to offer a way to set individual properties on a struct. For example:\n``` swift\nlet exportedImageSize: MutableProperty(.zero)\nlet width: BindingTarget = exportedImageSize.lens { return CGSize(width: $1, height: $0.height) }\nlet height: BindingTarget = exportedImageSize.lens { return CGSize(width: $0.width, height: $1) }\nwidth <~ widthTextField.reactive.stringValues\nheight <~ heightTextField.reactive.stringValues\n```\nPersonally, this would un-complicate a few spots in my own code where I achieve something similar to the above by taking two discrete width/height properties that I'm forced to combine into a size elsewhere. Now the CGSize value is the true source of truth, rather than a composed view of separate width/height properties.. @mdiep I've got them set up locally but things got a little strange when I was trying to build out some tests and things weren't working out as expected. Hopefully it won't be much longer 'til I get my confusion worked out.. I added to the anticipated questions above, and made a number of changes to the code in response to feedback.\nI also added some additional tests, and cleaned up the ones that were there.. @mdiep Yeah, I think that things are shaping up fairly well with this. I'll have to modify some of my own usage patterns to figure out how to mix and match these ideas nicely, because a \"do-everything\" lens method may not be possible.\nI really did want to wrap up the ViewModel pattern in a way that was more uniform, where we craft the lenses we want in the view model without much fussing about the constructs used underneath to achieve the pattern. But with Swift 3.1 that need will completely go away!\nWhy? Because now we can do some really interesting things that get us closer to a clean pattern exposing our model object's properties in the viewModel. For example:\n``` swift\nextension Reactive where Base: MutableProperty  {\n    var titleValues: SignalProducer {\n        return base.producer.map { $0?.title ?? \"\" }\n    }\nvar albumArtistValues: SignalProducer<String, NoError> {\n    return base.producer.map { $0?.albumArtist ?? \"\" }\n}\n\n}\n```\nSo now the need to repeat ourselves when \"lensing\" our model objects goes away in the view model. The \"lens\" can be defined once on a specialized extension of MutableProperty and then binding targets can be created in a similar way.\nI guess this is a really long way of saying that I'm OK with dropping the lens as a function in favour of exposing effective tools for implementing lens as a pattern.. @mdiep I addressed your comments, and in addition to pulling bindingTarget (to be opened in a separate PR) I have also pulled lazyMap from PropertyProtocol because it felt incongruent to the rest of the Property API that returned Property instances.. Oops. I fixed that Linux build issue earlier, but pushed the change over to the bindingTarget branch. Should be all good once this build completes.. @mdiep That's what I was originally thinking when I was first driven to write this. It just might be the right way to solve the problem.\nEven cooler would be a .flatMap-like operator. What the hell even is that, you might ask?\n``` swift\n// Imagine Person is a class that exposes a BindingTarget of its own\nlet changingPerson = MutableProperty(/ ... /)\nlet target = changingPerson.flatMap { return $0?.reactive.firstName ?? .null }\ntarget <~ firstNameTextField.reactive.text\n```\nIn the above example, consider a user's selection in a master/detail interface where they can choose a Person from a list. The selection change effectively causes the target of the binding to change.\n(Also, a .null binding target would have to exist as a similar construct as piping output to /dev/null in concept, for when there is no target at the other end.)\nI can't even begin to imagine how it'd work under the hood, though. Mostly because I've not given this idea much thought.. Here's another Swift init method that specifies the default value as .inherit, FWIW:\nhttps://github.com/apple/swift/blob/5accebf556f40ea104a7440ff0353f9e4f7f1ac2/stdlib/public/SDK/Dispatch/Queue.swift#L146\nSetting .workItem as the default would certainly be a big help for folks like me with large, mixed codebases, however I don't know whether it's worth applying this in blanket form without first understanding the consequences.\nI'd vote for exposing the parameter (as we did with target recently) and perhaps defaulting to .inherit (as the default queues currently do). Then, we can adjust & audit the internal spots where queues are created. That, or default to .workItem and see if it blows anything up first.\nBut I think Apple chose to leave it as .inherit for a reason. Perhaps it leads to performance or other issues? \ud83e\udd37\u200d\u2642\ufe0f . @sharplet is it equally common for you to use alternatives to startWithValues(_:)?\nI feel like the trailing closure version of start defaulting to take values seems sensible, and using labels for the rest of the options.\nHowever, I'm not sure how you'd mix the results: parameter with the values: parameter in a single start() function as above, @andersio. For instance, does this make much sense?\n``` swift\nsomeProducer.start(values: { value in\n  // do something with value\n},\nresults: { result in\n  // do something with value on .success\n})\n// do both closures execute above on every value?\n```\nAlso, if we were able to pick a single \"trailing closure winner\" for both the NoError and \"not NoError\" cases (if the latter is even possible to specify), then it would make sense that start(_:) takes the result: closure when Error is not NoError, and the value: closure otherwise.\n. @andersio I'm assuming you mean the SWIFT_4 job? Is what I did in d7eb8bc sufficient?\n. I've been thinking about parallel operations + ReactiveSwift a lot over the years, and the only solution I've come up with (but have yet to exercise in a major way) involves an array of inner SignalProducers that ultimately dispatch their work to a collection of schedulers. Almost like a thread pool, but managed differently.\nAs far as your issue with start() running on the main queue, @jjoelson: you must be careful to use the correct construct when building your SignalProducer. A while ago in #240 I introduced the initializer variant that eventually became public init(_ action: @escaping () -> Value) to solve this exact issue.\nUsing that with start(on: Scheduler) should allow you to create a signal producer that invokes its start method on a given scheduler rather than at the point of creation. Using lazyMap gives you a similar construct in the case where that operator makes more sense.\nThis approach is especially useful because you can cancel the returned SignalProducer before the action ever executes on its target dispatch queue. This eliminates a great deal of \"thread explosion\" errors that I've encountered before I had this construct available to me.. > The idea of creating my own pseudo thread pool with a collection of schedulers each backed by a serial GCD DispatchQueue seems like reinventing the wheel. GCD already has concurrent queues that do this way better and it would be great to figure out a way to take advantage of that in RAS code.\nIt does seem that way, but in the end you still have to perform some kind of management of your threads, work items, or whatever. Dispatch will happily let you create and schedule many more concurrent work items than there are CPUs/threads on your system, so unless you build your own pooling/management mechanism then you're going to encounter issues in many circumstances.\n\nRxSwift has concurrent schedulers, so you can just call subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) which is very easy for end users.\n\nSure, it's easy for end users to shoot themselves in the foot. \ud83d\ude04 \nAnyway, we have start(on:) as well as observe(on:)\u2014same thing, but separated. \nCombining those with a small collection of serial queues could give you a reasonable concurrency system without having to resort to concurrent queues. The system will happily parallelize the execution of the blocks on separate serial queues, which is a far better construct than just dumping work onto a concurrent queue and hoping that the system does the right thing.\nWhat's your application/example, anyway? This is harder to discuss without a concrete sample of what you're trying to do.. > The case I'm thinking of here is any kind of CPU-bound task. For example, imagine some kind of image processing that takes 1 second per image. If you have 90 images to process, it will take about a minute and a half to complete if performed serially. But on a multi-core system you can potentially finish much faster.\nI get what you're saying, but just want to point out that\u2014unless you have a very complex front-end that feeds already-loaded images into RAM\u2014most commonly-performed image processing is I/O bound. This leads to a massive creation of new threads when performed on a concurrent queue. See below for a sample of this exact issue.\n\n[\u2026] a concurrent queue will generally be smart about deciding how many tasks to start simultaneously in order to maximize performance\n\nNope. They're not even a little bit smart about that once you introduce I/O. In fact, they would happily lock up your system in this scenario. See \"Extra Info\" below.\n\nWith respect to using a group of serial queues as a \"thread pool\", the documentation explicitly recommends against that\n\nIt recommends against creating large numbers of them, sure. But 6-10? Not that big a deal, and less of a problem if they all target the same destination queue. At any rate, let's just address the major problem with concurrent queues, which is their effectively-unbounded nature of operation.\n\nSo it's not clear to me why allowing users to easily dump tasks onto a concurrent DispatchQueue like with subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) is shooting themselves in the foot, but as I said, my knowledge of GCD is limited.\n\nCheck out the following repository: ConcurrentTest. It demonstrates exactly the problem that is caused by \"allowing users to easily dump tasks onto a concurrent DispatchQueue.\"\nRun it once to completion just to see it work. Then, change goCrazyWithThreads = true in main.swift and run it again\u2014execution should halt. Pause the debugger, and look at how many threads got created. This is precisely the problem I am speaking about.\nWhile I think that it'd be nice to have a concurrent scheduler type for certain circumstances, I think they would introduce far more problems than they solve. If someone's trying to wrap their head around reactive programming, we don't want to have them introduce issues that appear to be deadlocks but are actually caused by an explosion of threads due to a fundamental misunderstanding of how dispatch queues actually work.\nSo for now, if you're looking to do long-ish running concurrent work then the way I demonstrate it in ConcurrentTest is probably a good place to start.\nExtra Info\nThis article from Mike Ash also covers this issue very well. Note that in the article he employs a semaphore to help cap the # of threads that get created by the system.\nIn ReactiveSwift, we can use the .concurrent flattening strategy to achieve something very similar, as demonstrated by my ConcurrentTest project.. @sharplet is correct that concurrentPerform will behave much more smartly than just firing blocks at a background queue. You can ask it to charge through thousands of iterations, and even when I/O is involved it won't blow up on you.\nHowever, its utility is limited to scenarios where you have a fixed data set to process. For instance, while scrolling by in a collection or table view, you might want to send thumbnail images to process concurrently in the background (and you especially want to cancel their operation when the cells scroll out of view.\nTreat concurrentPerform (and its underlying, dispatch_apply) as the equivalent to a for loop. You have access to a prepared set of data that you wish to process in parallel, all at once.\nJust keep the following in mind:\n\n\nExecute your concurrentPerform blocks on a serial queue. The same explosions can still occur if you just toss batches of concurrentPerform calls onto the global queue.\n\n\nThere's no easy way to cancel their work once they're started.\n\n\nThey're not cheap to create, so make sure the work you schedule is substantial enough to warrant parallelizing in this way (e.g. don't just multiply pairs of numbers together.). I still don't really see the point of this, sorry.\n\n\nA SignalProducer can already be used in places where you might instead use a Future or Promise. I have built dozens of async APIs that effectively use SignalProducer in place of Future<Value,Result> without having to take(last: 1), or use once(). That's because all my Future-style SignalProducers are defined to provide a single value and have a fixed lifetime.\nI am currently wrapping up some work in an API that uses Futures heavily (Vapor+NIO), and I use SignalProducer internally in my controllers/etc because I'm much more comfortable with that construct and its concise error handling.\nI also use SignalProducer in APIs that \"terminate\" with straightforward Delegate patterns:\nlet theProducer = internalController.someOperationWithParameters(/* ... */)\ntheProducer.startWithResult { [weak self] result in\n  switch result {\n    case .success(let value):\n      self?.delegate?.didReceiveValue(value, in: self)\n    case .success(let error):\n      self?.delegate?.didFailWithError(error, in: self)\n  }\n}\nNow, would I like some added comfort provided by the compiler and/or type system to guarantee that my SignalProducers only ever emit a single value? Maybe\nIs it worth giving up the simplicity of having \"two base types\"[^1] that are vended by ReactiveSwift? I don't think so.\nIf folks are having trouble with explaining ReactiveSwift to teammates, it won't be any easier to also try and explain the subtleties of why you should instead use the Promise variant over a SignalProducer, how we bridge the two, etc.\nFrankly, if you really want Promise<Value, Error> and Future<Value, Error>, then it should just exist in a whole new type (and probably even a separate library) that offers exactly that. IMO, there is far too much (conceptual and implementation) baggage and overhead that comes with Signal{,Producer} to use it as the basis of the simpler Futures & Promises construct.\n\n[1] Sorry, Action\u2014I rarely think of, or use you\u2026. I can definitely envision a future (heh) where someone comes up with an adequate way to abstract a \"one-shot, asynchronous operation\" atop RAS' constructs, but I don't think that wrapping SignalProducer and calling it Promise or Future is the way to go about it.\nUsing a different approach, what about starting with something that aims to replace both the SignalProducer's error-prone construction as well as its one-shot result?\nFor instance, consider a type called Async<Value,Error>, with the following wrapper:\n`` swift\nfinal class Async<Value, Error> {\n  init(_ action: (Promise<Value, Error>, Lifetime) -> Void) {\n    // Construct a normal SignalProducer, and use a new type,Promiseto wrap thesend` API.\n    // Then, call action() inside the SignalProducer's constructor with the wrapper\n  }\n// This type serves only to wrap the send API on Signal.Observer.\n  // Expectation could also be used instead of Promise to avoid confusion?\n  struct Promise {\n    func succeed(with value: Value) {\n      // call send(value:) and sendCompleted() on underlying producer\n    }\n    func fail(error: Error) {\n      // call send(value:) and sendCompleted() on underlying producer\n    }\n  }\nfunc await() -> Result {\n    // basically just invokes startWithResult on the underlying producer\n  }\n}\n```\nUsage would look something like this:\n``` swift\nfunc doSomethingNetworky() -> Async {\n  return Async { promise, lifetime in\n    callSomeAsyncNetworkApi() { \n      if theCallSucceeded { networkStringValue in\n        promise.succeed(with: networkStringValue)\n      } else {\n        promise.fail(error: SomeNetworkError.someError)\n      }\n    }\n  }\n}\nlet networkResult = doSomethingNetworky().await()\n```\nAnd of course we could add the requisite then, map, and so on APIs.\nBecause they still rely on an underlying SignalProducer, much of the existing code in the attached prototype would probably still apply. \nThoughts?. @leonid-s-usov Sorry, I was operating under a more \"complete\" Promise definition that also includes a Future type. Something more like what's defined in swift-nio: https://github.com/apple/swift-nio/blob/d31f4a249a2c7eef373f044e781b2f89f7e5e64d/Sources/NIO/EventLoopFuture.swift#L150.\nMy preference is not to stomp on the Promise and Future naming because I don't think that anything that's been proposed so far is \"sufficiently Promise-like\".\nAnyway, @andersio it's clear that I'm not quite following the purpose, which is why I'm grasping at straws to understand the \"big picture\" value of this type. When you name your prototype Promise, you should not be overly surprised when we're going to expect it to behave like whatever Promise library/definition we've encountered in the past\u2026 \ud83d\ude04\nThe true test would be to see how this type\u2014however it is named\u2014improves the readability/usability of ReactiveCocoa's extension on URLSession, the collect operation as suggested by @mdiep, and so on.\nGiving us a handful of demonstrations of where it improves the call site / clarity will go a long way to help us understand what the ultimate goal is.. @leonid-s-usov Yep, totally subjective, and I should probably not have used the word \"complete\".\nThe reason that it makes more sense to me is that\u2014at the call site\u2014you see that you are getting a value of a particular type in the Future. In contrast, one could argue that the alternative is that the function is returning a Promise to return that value (in the future). In both cases, you're still getting something that will \"resolve in the future\", hence my preference for Future as the \"key type\".\nFrom there, it follows that\u2014in order to return/create a Future\u2014it makes sense to create a Promise that you will then fulfill within the context of the function (whether it happens as a result of an async call, or immediately, doesn't really matter.)\nAt any rate, this is obviously something that's interpreted in many ways, as the wikipedia page for this topic is quite dense.\nNow, I have no idea why you think that Async or any other Future-like construct needs to communicate whether it is warm or cold? Why on earth would that matter if what we're trying to do is build something that is designed to (always) return a value/error in the future, and be easier to understand?\nOne thing you left out in your \"calling by its name\" is the fact that Value is right there in its generic parameters: ReactiveSwift.Async<Value, Error>. In actual use, it'd be ReactiveSwift.Async<Int, SomeError>, or Async<String,SomeError>, etc.\nAnyway, this is way off-course from the original discussion now because this issue is not really trying to build a Future/Promise type, but rather a replacement for Rx's Single. While I agree that Single / Signal might be easy to transpose while typing, I think that the strength of the meaning of Single outweighs that issue.. @leonid-s-usov You're helping to strengthen my original comment of, \"I still don't really see the point of this.\" \ud83d\ude04 \nHere's what I'm gathering (roughly) from the bulk of this thread\u2026\nWe want a producer that returns only a single value, or an error.\nWell, we have take(first: 1), take(last: 1) for that. Or, you create a SignalProducer in a way that explicitly sends a single value and completes immediately after.\nWe want to get the value, similar to how Future or Promise works\nWe offer single(), last(), and first() to perform those functions, the latter two combining the above concept with single.\nWe want to distinguish hot vs cold\nOK, we have Signal vs SignalProducer.\nWe want control over the operations\nThis is why we have so many variations of take, start(on:), observe(on:), and so forth.\nWe want a nice type to encapsulate a special case of the above\nThis is proving to be very hard to achieve, because there doesn't appear to be a winning special case that contains the most desirable combination of the above.. @leonid-s-usov We're effectively on the same page. When I said, \"We want a nice type,\" I meant it in a way that's equivalent to \"We want code clarity[\u2026]\"\nRegarding your \"semantically incorrect\" example, I am not sure you provided enough context to explain where the problem is. For instance, I see all three of the below as having a similar meaning:\nswift\nfunc getMessages(userId: String) -> SignalProducer<[Message], ApiError>\nfunc getMessages(userId: String) -> Task<[Message], ApiError>\nfunc getMessages(userId: String) -> () -> [Message]\nI read any of the above as, \"give me a way to execute getMessages in a deferred manner.\" Whether you have to call start() to begin the process, or startWithResult(), or last() to get the value at that point is a detail of the underlying API.\nMaybe I'm missing something about how the returned producer is \"hooked up\" elsewhere to pass values along?\nRegarding a new flattenMap strategy, I think that's a separate issue. If we get a new type that provides clarity, then we shouldn't need alternative strategies for the existing types.. It seemed so\u2026out of place. :)\nI can restore it though, since that seems to be the preference.\n. Why would we implement this on MutableProperty and not as an extension to MutablePropertyProtocol? Wouldn't that give us the <~ implementation on DynamicProperty \"for free\"?\n. Ah yes, makes sense. Thanks!\n. What if we instead did this, and killed the Bool variable?\nif queue == DispatchQueue.main && Thread.isMainThread {\nThat, or s/usesMainQueue/onMainQueue so it communicates the intent a little more clearly. I know I'm splitting hairs here, but nobody's really using the main queue.\n. Count me in for a strong \ud83d\udc4e on any strange/uncommon words like Reactant, Reactivity, Reactiveness because I feel they are forced adjectives. Reactive itself is an adjective, so there's no need to push it further.\nI'll throw another few ideas out: ReactiveExtensionsHosting, ReactiveExtensionsProtocol, ExtendedForReactiveSwift, ExposesReactiveBindings, ExposesReactiveExtensions. I can go on all day\u2026 \ud83d\ude04 \n. Why not reactive? Consider usage:\n```\n// \"Give me rac notifications for\u2026\"\nNSNotificationCenter.default.rac.notifications(forName:\n// \"Give me rac data with\u2026\"\nsomeURLSession.rac.data(with:\n// \"Give me reactive notifications for\u2026\"\nNSNotificationCenter.default.reactive.notifications(forName:\n// \"Give me reactive data with\u2026\"\nsomeURLSession.reactive.data(with:\n```\nThe latter feels more readable/sensical to me.\n. s/Reactivity/Reactive/ to match the rest of the changes.\n. Just a little nit: Should it be ReactiveExtensionsProvider (i.e. the plural) instead, since there are often more than one extension being provided?\n. @andersio Sorry, I just meant that the collection of e.g. stringValue, isEnabled, etc. forces the plural. Not that we'd have a \"sibling\" for reactive.\n. @NachoSoto would you keep the asTimeInterval name? I've not seen precedent for this pattern yet outside of Apple's use of cgColor (i.e. using the type name itself) except it'd be strange to call a DispatchTimeInterval method called timeInterval. \ud83d\ude1b \n. @NachoSoto So this is only used internally to \"scale down\" a time interval. Specifically it's used only to scale intervals to 10% of their original value for the default leeway parameter.\nBut you are correct. If seconds is over ~200,000, 10% is 2000, and hence we end up with ~2billion which will overflow a signed integer on 32-bit platforms (of which there aren't really any more for much longer, anyway\u2026)\nBut I'm pretty sure that even 200k seconds is going to be a rarely (if ever) specified interval for our APIs.\nOne of the tests I plan to add is to find this tipping point.\n. I added them all in the \"deprecations bucket file.\"\n. I think that if you want to match \"high priority\" you should consider using the .userInteractive QoS instead. Doubt it really matters in a synthetic benchmark/test like this, but the asymmetry stood out to me. :). didFail would be a better name for this, or isFailure if you really want to match the case label.. Love the functionality, but not the name.\nI don't sense anything that feels like a \"transaction\" when reading examples of using the class. Instead, I think that something like PropertyEditor, or the previously used EditableProperty, might better explain what the class does. Also, I find that the mixing of a \"forward map\" and transform (i.e. the init parameters vs the map(forward:backward:)) is a little confusing.\nThe thing that feels \"weird\" about PropertyEditor, though is that it behaves just like a property. So if I have a variable like emailEditor then it'd be weird to ask for emailEditor.value or emailEditor.producer.\nAnother idea that sprung up just now is a {Mutable,}PropertyTransformer, or maybe even MutablePropertyAdapter (with the former being my preferred of the two.) Those would tie in nicely with the transformation nomenclature that's used in places.. If we changed the name from TransactionalProperty to PropertyEditor, and call the \"value transformers\" as they are, we could instead use this sort of signature:\nswift\npublic func editor<U>(\n    transform: @escaping (Value) -> U,\n    reverseTransform: @escaping (U) -> Value\n) -> PropertyEditor<U, NoError> {\n    return PropertyEditor(self, transform: transform) { proposedInput in\n        return .success(reverseTransform(proposedInput))\n    }\n}\nOr, if we use the PropertyTransformer naming, this could be:\nswift\npublic func valueTransformer<U>(\n    forward: @escaping (Value) -> U,\n    reverse: @escaping (U) -> Value\n) -> PropertyEditor<U, NoError> {\n    return PropertyTransformer(self, transform: forward) { proposedInput in\n        return .success(reverse(proposedInput))\n    }\n}\nI used reverse since it better matches the NSValueTransformer conventions. Also, something about reverse sounds more correct than backward to me for some reason.\nThoughts?. Nit: \"committed\" has two 't's :). I think attemptSet()(or if you don't mind the verbosity, attemptToSet(value newValue: Value) might be more appropriate here. The same applies elsewhere\u2014I think I prefer attempt to try seeing how this has little/nothing to do with Swift exceptions.\n(My distaste for try here is exacerbated by the fact that you also have actual uses of Swift's try keyword in the same file.). I have no idea what the comment means. Maybe an example, or explain what the \"type parameter\" is in this case?. Both the variable name and comment leave me confused after reading. I can only tell from usage that rootBox appears to guard accesses/changes to the originating property.. Either this is supposed to be called validations, or the comment for commited (sic) needs to be updated. I think it's probably just the latter.\nAssuming it stays result I would suggest the comment reads:\n/// The result of the last attempted edit on the underlying property\n(Unless my understanding is broken, of course.). Unless I'm missing the point, this might instead read:\n\nAn object that manages edits to an underlying MutableProperty using a setter action that can (optionally) validate proposed values.. I'm not sure I understand this section fully. Are you suggesting that a change in the underlying property might cause a failure to then get reported? The test cases appear to suggest this is the case, but the comment here is not so helpful.\n\nPerhaps an inline, simple example would be helpful, similar to what we see all over the standard library comments.. s/value/committed/\ns/validations/result/. I'm not a huge fan of this pattern for returning an error. Would it not make more sense to return a Result here? This would also give the validator an opportunity to modify the attempted value coming in.\nCode would look like:\nswift\nemail = MutableValidatingProperty<String, FormError>(\"\") { input, error in\n    guard input.hasSuffix(\"@reactivecocoa.io\") else { return .failure(.invalidEmail) }\n    return .success(input)\n}\nOr, if we want to mess with the value and save the user a bit of time:\nemail = MutableValidatingProperty<String, FormError>(\"\") { input, error in\n    if input.isAlreadyPerfect {\n        return .success(input)\n    } else if !input.passesSomeArbitraryBadCharacterTestsAndCantBeFixed {\n        return .failure(.invalidEmail)\n    } else {\n        let cleanInput = input.removingAllSuffixesAndWhitespace\n        return .success(cleanInput + \"@reactivecocoa.io\")\n}\nValidation in Cocoa works in this way, where the validateValue:forKeyPath: call is given an in-out pointer so you can manipulate the value. I use this pattern myself in FuzzMeasure when a user enters a value outside of an accepted range of values rather than barking at them with errors.\nNow, it would be really nice if this API could somehow also allow a third, \"Input was invalid but here is a new, valid value that I replaced the user's entry with\" state. This ability is missing with the existing Cocoa behavior. It doesn't allow me to easily detect when the user's input was overridden so I could call attention to it in my UI. The user just sees the value flip to something different when the commit the edit on a text field right now.\nBut I suppose that's as easy as wrapping the Value itself in a new enum, so probably already possible using what you've proposed here.\nFor example:\nswift\nemail = MutableValidatingProperty<UserInput<String>, FormError>(\"\") { input, error in\n    if input.isAlreadyPerfect {\n        return .success(.unmodified(input))\n    } else if !input.passesSomeArbitraryBadCharacterTestsAndCantBeFixed {\n        return .failure(.invalidEmail)\n    } else {\n        let cleanInput = input.removingAllSuffixesAndWhitespace\n        return .success(.modified(cleanInput + \"@reactivecocoa.io\", \"Hey, we fixed that for you.\"))\n}\nThen, elsewhere in your code you'd just watch for those modified values and update the UI to call attention to the helpful messages.\nThoughts?. The test I added merely intended to demonstrate the following:\n\nBefore the signal is started, the getter has not been evaluated\nWhen the signal is started, but the getter's queue hasn't scheduled the getter for execution, the getter has still not been evaluated\nOnce the getter's queue is scheduled, the setter will have run, and the value will have been delivered\n\nI'm probably missing the false positive here, but I think the synchronous execution of the scheduler is a benefit for the specific (simple!) test case I had in mind. Namely, \"will the getter get scheduled at all, rather than executing immediately when the SignalProducer is started..\"\nNow, what you're proposing could help write another test case I wasn't feeling well-equipped to write, which is, \"the getter should execute on the specific scheduler/thread that is specified\".\nLet me know what I might have misinterpreted.. It could, yes. But it's not really holding up the behavior right now.\nIf #182 goes in first, I'll definitely merge & apply to that. If #182 continues to take a while, I'm OK with a separate PR that moves this to that protocol.. @mdiep In the non-scheduled start variation, I don't think there's a difference as you've found.. It would certainly cut down on verbosity. I'll see how it goes.. The only potential conflict would be if the init(value:) variant went away, because then there'd be confusion between () -> Value and Value itself, forcing closures to always get evaluated (if the compiler wasn't going to balk at the similarity.). @mdiep I don't think that works in quite the same way, but does it make much of a difference?\nAccording to the docs, what you've pasted above would deliver all the events from the inner signal on the specified scheduler. The start(on:) variant would only evaluate the getter on the scheduler. Because there's only one event getting sent, I'm not sure it really matters all that much.. @mdiep I don't think that works in quite the same way, but it passes the tests both ways.\nAccording to the docs, what you've pasted above would deliver all the events from the inner signal on the specified scheduler. The start(on:) variant would only evaluate the getter on the scheduler. Because there's only one event getting sent, I'm not sure it really matters all that much. Thoughts?. @andersio this test result that was a little unexpected. I had hoped that advancing the scheduler would only have sent the final \"ghost\" value, but it's clear now that the binding target's queue has to batch up its incoming setter invocations.\nA .flatMap(.latest) equivalent on the setter side (i.e. switching to the newest scheduled setter call) might be worth exploring since it only ever makes sense to accept the last-set value. Effectively, each value event arriving on the bound signal would have to wipe out all the scheduled setter blocks on its queue and replace with the latest one.\n(Yes, I know\u2014easier said than done.). This is a tricky thing in general, but \"the receiver\" is difficult to use as a noun in concert with \"sending and receiving\" values.\n\"The receiver\" is Objective-C terminology where an object \"receives\" a message, but now we're \"calling functions on\" objects. Had Swift instead used mesg rather than func then I'd be more OK with this old terminology. But I digress!\nYou might be able to safely use this wording instead:\n/// Returns a signal that sends values exactly, or less frequently than, `interval` seconds \n/// apart, forwarding values on the given `scheduler`.\n///\n/// That is, the returned signal does not send a value until at least `interval` seconds have\n/// passed since it last sent a value.. Similar change to above:\n/// Returns a signal that sends values only when `interval` seconds have elapsed \n/// since this signal has last sent a value.\n///\n/// If this signal always sends values more frequently than `interval` seconds, then the \n/// returned signal will never send any values. \n///\n/// - seealso: `throttle`\nIf we ever get the Jazzy stuff online in html form, then we can specify a URL with the seealso.. You should probably call action() here, right? ;). @NachoSoto In a nutshell, @autoclosure implies @noescape, and hence we lose out on the ability to defer execution.. @NachoSoto Interesting. I wonder, though, whether we'd still have an issue where the compiler wants to forcefully optimize a passed-in value as being evaluated immediately.\nFor example, consider the case of SignalProducer(value: callAFunction()) versus the SignalProducer({ callAFunction() }) construct. Would the former be turned into an immediately evaluated variant if the braces are omitted, versus being evaluated lazily? \nThat seems a little subtle/delicate from a usage standpoint\u2026 But yeah\u2014having the lazyValue: as I originally built it might be a good tiebreaker?. ",
    "chrishulbert": "I'd be happy if they went back to being errors on version 5.1 - just that migrating a codebase from swift 2 to 3 is a nightmare, and updating all my 'startWithNext' is just making it that much harder. Up to you guys, i'm sure you've got your reasons. Thanks for the great project.\n. ",
    "sharplet": "I think adding CocoaPods support makes a lot of sense, especially given the discussion on https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3000.\n. I also don't have strong feelings, but I think 1.0 makes a lot of sense \ud83d\udc4d \n. I did think about defining it on ActionProtocol, but in order to define a convenience initialiser in a protocol extension, the protocol itself would have to define a designated (required?) initialiser. Moving the initialiser to the protocol didn't feel like the right tradeoff to me, but interested to hear your thoughts.\n. Ok, so I tried moving it to an ActionProtocol extension, which almost worked (but didn't): 1341fdba055dc9f60fbe79468b96d0831019d18e.\nFWIW, I don't mind the idea of making ActionProtocol more abstract. The main use-case for me is the ability to constrain one or more of the associated types to be a concrete type. Three type parameters kind of makes Action unwieldy to use sometimes, and perhaps makes it unfriendly to beginners.\nAlso, just off the top of my head, you could conceivably introduce another implementation that enables concurrent execution of the inner signal producers, or one that cancels an executing producer when executed (i.e., the \"merge\" and \"latest\" flatten strategies).\nJust some ideas!\n. I did try that at one point, but it's not valid to define a convenience init in a protocol extension.\nHowever ultimately the error isn't that you can't define the error, it's Swift choosing the wrong initialiser at the call site. I think it's to do with the way where clauses affect type checking.\n. @ikesyo Of course! I accidentally deleted the variant where P.Value == T.\nWell, now that it works as expected, I've squashed those changes into the original commit. For now we can achieve this purely with ActionProtocol.\n. @mdiep I managed to work out a way to introduce an unambiguous overload, so that we can safely unwrap the optional. However I couldn't work out a way to do so without leaking implementation details, so I'd appreciate your input on the solution I came up with.\nIMO, given the current limitations of extensions of generic types and the need to use protocol extensions, I think it would ultimately be a cleaner API today to implement this as PropertyAction. It may have to duplicate some logic in Action, but we probably wouldn't have to leak implementation details.\nHaving said that, I think this version of the API would work out just fine in practice, so I ultimately don't mind which way we go. And I'm prepared to admit there might be an even cleaner way to refactor this without leaking implementation details!\n. I think I've managed to make the input property thread-safe with https://github.com/ReactiveCocoa/ReactiveSwift/pull/22/commits/fea3dc61596a6f3c5a6e38eddfc4884b59e30608!\nRelated discussion: https://github.com/ReactiveCocoa/ReactiveSwift/issues/88#issuecomment-261449006\n. @andersio In order not to block this PR any further, how do you feel about submitting your proposed changes as a separate PR after this is merged?. @mdiep I've addressed your feedback, thanks! Hopefully good to go once we're green.. \ud83d\udcd7 \ud83c\udf4f \ud83d\udc9a :shipit: . Confirmed, that was unintentional. I experimented with a fix for that but shelved it until #117 was closed.. Some context is here: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3210#pullrequestreview-1197439\nMany bindable properties provided by Rex are write-only, despite using MutableProperty which should be read-write. My understanding is that the goal of this PR is to provide a first-class way to provide a write-only bindings. IMO that's a useful feature on its own, although in the case of the Rex bindings it might ultimately be more useful (if more complex) to provide proper MutableProperties with the expected semantics.\n. My only concern with this is that it makes Action.errors harder to use in the usual case in order to make this new case possible.\nWhat if we made the change non-breaking by introducing a separate Signal<(), NoError> that sends an event whenever the action is executed while disabled? That would achieve the same use case described in https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2882 without adding complexity.\n. There are also no tests yet, which I'm planning to rectify. I should be able to cover the main semantics, although I don't trust I can write tests to verify this code is thread-safe.\n. Ok, I think I've addressed everyone's feedback, thank you! I've also pushed some tests.\n@mdiep Do you think it's worth adding the Signal and SignalProducer overloads like I mentioned in https://github.com/ReactiveCocoa/ReactiveSwift/pull/58#discussion_r82393681?\n. And we're green \ud83d\udc4d \n. @andersio Is this kind of thing what you had in mind? I'm trying to work out how to safely get the initial value, and also not miss any changes to shouldThrottle...\n``` diff\ndiff --git a/Sources/Signal.swift b/Sources/Signal.swift\nindex cb3adbf..941bf79 100644\n--- a/Sources/Signal.swift\n+++ b/Sources/Signal.swift\n@@ -1515,7 +1515,8 @@ extension SignalProtocol {\n        where P.Value == Bool\n    {\n        return Signal { observer in\n-           let initial: ThrottleWhileState = shouldThrottle.value ? .throttled(nil) : .resumed\n+           let shouldThrottleProducer = shouldThrottle.producer.replayLazily(upTo: Int.max)\n+           let initial: ThrottleWhileState = shouldThrottleProducer.first()!.value! ? .throttled(nil) : .resumed\n            let state = Atomic(initial)\n            let schedulerDisposable = SerialDisposable()\n@@ -1523,7 +1524,8 @@ extension SignalProtocol {\n            disposable += schedulerDisposable\n            disposable += { _ = shouldThrottle }\n\ndisposable += shouldThrottle.producer\ndisposable += shouldThrottleProducer\n.skip(first: 1)\n                .skipRepeats()\n                .startWithValues { shouldThrottle in\n                    let valueToSend = state.modify { state -> Value? in\n``\n. Oh, that totally clears things up. Fixed in https://github.com/ReactiveCocoa/ReactiveSwift/pull/58/commits/f757e53e1492b55cd9f0100a7b03ac324c2fa40d (and rebased).\n. That should be everything, please take a look at the latest 2 commits!. Streamlined to 3 notes in the doc comments.. Green \ud83d\udc4d . :tada:. I have a similar branch on RAC, but there's a big problem: these modular imports don't appear work for operator declarations. So if you onlyimport ReactiveCocoaand then go to use<~, you'll still be confused as to why it won't compile, and you need toimport ReactiveSwift` anyway.\n\nThe only workaround I'm aware of for RAC would be to somehow include the source for the operator definitions, effectively duplicating it. Argo employed this strategy with Runes for a while, but recently reverted it due to issues with CocoaPods' support for submodules.\n. Thanks for contributing! I also just realised that the instructions mention running script/bootstrap, which doesn't actually exist anymore. I'll have to fix that up \ud83d\ude05 \n. No I probably wouldn't say this is better or worse. I think if users have Carthage installed then that's great, but having an alternative for those who may not want to go install it makes sense to me.\n. You're right, that might be simpler. Perhaps it would make more sense to update the instructions to recommend that.\n. Removed all references to script/bootstrap in favour of git submodule update --init.. I don't know how widely-used Action is. To me, it feels harder to use than it should be (in the sense that it's super useful and things that are super useful should also be easy to use).\nHere's what I get out of it:\n- Serialisation: I know that when the action's producer is executing, it is the only one executing. I can trust that side effects won't be executed more than I expect.\n- Command-Query Separation: Signal producers execute their side effects for every observer, and so it can become quite difficult to reason about what side effects will occur, and when. Actions give me a way to separate the work to be done from observing the progress or effect of that work.\nOn the other hand, there's a really great symmetry between these two type signatures:\n``` swift\nlet execute: (Input) -> SignalProducer\nlet task: Action\ntask = Action(execute)\n```\nI wonder if there's two different concepts here? And maybe one could be composed from the other?\nI'm still trying to think this through...\n. So it seems clear that there's some value to both ideas: a) Action having an Input type, and b) Action being able to observe some external state in a thread-safe way.\nEarlier on in #22 I had an idea to make (b) happen, but never got it to work. This conversation inspired me to take another crack at it, and I think I've got it: https://github.com/ReactiveCocoa/ReactiveSwift/pull/22/commits/fea3dc61596a6f3c5a6e38eddfc4884b59e30608.\n@mdiep's original example can now work, with only a slight change to preserve the Input parameter:\n``` swift\nclass LoginViewModel {\n    let username = Property()\n    let password = Property()\n    let action: Action<(), Void, LoginError> // input type is still part of the type\ninit() {\n    let form = Property.combineLatest(username, password)\n\n    // this is still a little messy, but I think we can\n    // layer some nicer convenience initialisers on top of this API\n    action = Action(_internalState: input, enabledIf: { !$0.isEmpty && !$1.isEmpty }) { (username, password), _ in\n      \u2026\n    }\n}\n\n}\n// elsewhere\nloginViewModel.action.apply()\n``\n. You should already be able to do that by conforming toReactiveExtensionProviding` on your class.\n. I made a similar proposal with https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2880. I think the majority of use cases I had for the feature are covered by simple binding targets.\nThis could still be a really useful feature, but I don't think it's necessary for 1.0.\n. The idea is basically to create a state machine, where an action will restart from the last point it failed:\n``` swift\nlet step1: SignalProducer\nlet step2: (A) -> SignalProducer\nlet step3: (B) -> SignalProducer\nlet task = step1\n  .replaySuccessLazily() // don't love this name\n  .flatMap(.concat, transform: step2)\n  .replaySuccessLazily()\n  .flatMap(.concat, transform: step3)\n  .replaySuccessLazily()\nlet action = Action { _ in task }\n``\n. I don't thinkretry()does what I want here, because it retries the producer automatically. What I'm after is a way to have a producer replay values and completion on start, but if the multicasted producer has failed then the cached events should be discarded and it should be like starting the producer for the first time.. I'll be honest, I'm a little daunted by the complexity ofreplayLazily`, and the idea of largely duplicating that in a new operator (or multiple!).\nI've been doing some thinking about introducing the notion of a caching policy, and I'd like to spitball a possible approach here. I think it would be possible to extend replayLazily to take an optional parameter policy:\n```swift\n// current behaviour, and the default value\nreplayLazily(upTo: Int.max, policy: .alwaysReplay)\n// behaviour described in this issue\nreplayLazily(upTo: Int.max, policy: .replayCompleted)\n// behaviour described in #83\nreplayLazily(upTo: Int.max, policy: .timeout(after: .seconds(1), on: QueueScheduler()))\n```\nThe policy would be defined something like this: \n```swift\nenum ReplayAction {\n  case replay\n  case invalidate\n}\n/// A function that allows responding to any event by invalidating the cache asynchronously\nstruct ReplayCachePolicy {\n  let action: (_ event: Event) -> SignalProducer\n}\nextension ReplayCachePolicy {\n  static var alwaysReplay: ReplayCachePolicy {\n    return .init { _ in\n      SignalProducer(value: .replay)\n    }\n  }\nstatic func timeout(after interval: DispatchTimeInterval, on scheduler: DateScheduler) -> ReplayCachePolicy {\n    return .init { event in\n      guard event.isTerminating else {\n        return SignalProducer(value: .replay)\n      }\n  return SignalProducer(value: .invalidate)\n    .delay(interval, on: scheduler)\n}\n\n}\nstatic var replayCompleted: ReplayCachePolicy {\n    return .init { event in\n      switch event {\n      case .value, .completed:\n        return SignalProducer(value: .replay)\n      case .failed .interrupted:\n        return SignalProducer(value: .invalidate)\n      }\n    }\n  }\n}\n```\nThen, when starting the multicasted, replayed producer, observe the cache policy events something like this:\nswift\nmulticastedSignal\n  .materialize()\n  .flatMap(.merge) { policy.action($0).take(first: 1) }\n  .filter { $0 == .invalidate }\n  .take(first: 1)\n  .observeValues { _ in\n    // ensure replay state is reset, so that next time the producer is started, the underlying producer will be restarted instead of replayed\n  }\nWhat do you think? Would something like this be an appropriate change? Does it belong in a separate operator? Is it not worth the additional complexity?. Ok, so the main use I have for the existential initialiser is this pattern:\n```swift\nprivate let _foo: MutableProperty\nvar foo: Property {\n  return Property(_foo)\n}\n```\nI kind of feel like this initialiser should not retain the underlying property by default. Then, to opt into capturing semantics, you could have:\nswift\nreturn Property(capturing: _foo)\nWhat do you think?. I've seen some fixits  that provide multiple alternatives (unfortunately can't recall which, specifically) \u2014 maybe that's worth exploring?. Most of the time I use this initialiser to compose a signal with other producers, or to use producer-specific operators on it. This means that it's usually part of some kind of operator chain, where a mess of keywords, operators and other syntax can make things dense and hard to parse. I personally find that the signal: label doesn't add much other than redundancy, which for me reduces clarity / increases visual noise.. But, it would be good to show some real examples of how this changes code at the point of use.. > Not sure if we should count the vararg initializer as one though.\nI'd recommend avoiding that ambiguity if we can.. I'd like to add that the discussion was informed specifically by this section of the API design guidelines.. Do you have an example with more meaningful names than sourceSignal and state? I think that would help to demonstrate the readability benefits.. And with the recent improvements to Action, you can take a different approach without any mutable state:\n```swift\nlet url = Property(initial: nil, then: urlTextField.reactive.text)\n// Only enabled when input url is non-nil\nlet submit: Action<(), [Item], Error> = Action(input: url) { url in\n  // url is the current value when the button is tapped\n  let request = APIRequest(url)\n  return sendRequest(request)\n}\n// bind button to submit action:\n//   - button is disabled while executing\n//   - button is disabled if input is invalid\nbutton.reactive.pressed = CocoaAction(submit)\nlet items = Property(\n  initial: [],\n  then: submit.values.scan([]) { $1 + $0 }\n)\nitems.signal\n  .observeValues { print(\"items updated: ($0)\") }\n// you can also handle errors gracefully by observing submit.errors\n```. > Placing it at topmost of the data flow (receiver) is more readable.\nNow that you phrase it in terms of data flow, I see your point. This flows pretty well for me at the point of use:\nswift\nitems <~ buttonTap\n  .withLatest(from: textField.reactive.continuousTextValues)\n  .flatMap(.latest) { api.getItems($1) }\n  // etc.. I agree, and think withLatest(from:) clarifies what \"latest\" refers to: the latest value from the signal.. \\o/. Is there a way we can provide a deprecation warning for this change? I'm unsure what the impact of this change would be on code expecting NSError.. Looks good. It's bridged as Error, so I think it makes us a better Swift 3 citizen to preserve that as accurately as possible.. Yep hoping to get back to it skon. I went ahead and pushed 06a2d53 to group the different overloads together. If you'd prefer not to reorganise, let me know and I'll revert that change.. The change was unintentional, and I think surprising. My vote is for restoring the previous behaviour.. In general I think I agree with that direction. This particular change has the advantage of being non-breaking\u2014however, if we'd like to go down the road of adding a real type for this concept, it may make sense to break it for 1.0. Thoughts, @ReactiveCocoa/reactiveswift?. I've pushed a fix for the tests.\n\nI thought these names were no longer part of the type\n\nWhat I found was that if I removed labels from the Pipe typealias, things compiled as expected (i.e., the labelled and unlabelled versions of the tuple were treated as compatible). So the error we were seeing appears to result from assigning a labelled tuple to a differently-labelled tuple.\nSo this change will break any clients who've used a typealias to add their own labels to this tuple.. My guess is that this will have a low impact in practice, so I'm in board with including it for 1.0.. Can you explain what's unsafe about it?. Even if the events aren't serialised by the scheduler, they should still be synchronised by the send mutex shouldn't they? I'd like to understand what the potential issues are, and what precisely you mean by \"queue contained resources\".. In that example, even using backgroundScheduler doesn't prevent concurrency, because it may be a concurrent dispatch queue. Unless I'm missing something, it doesn't seem like there's anything inherently less safe about this than the SignalProducer version?. Works for me \ud83d\udc4d. What is the type of the parseResponse function? Given the first error message, I'm guessing that function may still be using NSError instead of AnyError.. Ok, so because flatMap can't change the error type, you'll need map the AnyError from reactive.dataTask() into a NetworkError before you can call parseResponse. Something like this might work:\nswift\nreturn URLSession.shared.reactive\n  .dataTask(with: request)\n  .mapError { NetworkError.fromError($0.error) }\n  .flatMap(.latest, transform: parseResponse)\nAlso, is parseResponse synchronous or asynchronous? If it's synchronous, it would be simpler to have it return Result<T, NetworkError>, and then use attemptMap like this:\nswift\nreturn URLSession.shared.reactive\n  .dataTask(with: request)\n  .mapError { NetworkError.fromError($0.error) }\n  .attemptMap(parseResponse). So I believe the issue is a race in https://github.com/ReactiveCocoa/ReactiveSwift/blob/a458a5a754a2fe87ec16cb669f6beb5ecdf0fd02/Sources/Signal.swift#L903-L904:\nswift\ndisposable += self.observeWithStates(signalState, otherState, lock, observer)\ndisposable += other.observeWithStates(otherState, signalState, lock, observer)\nThe two streams aren't serialized with respect to each other, so when the first is observed, if there are multiple synchronous events, they are lost before the second observation is started.. I'm starting to wonder if there is a sensible order for two synchronous streams of events. For example:\nswift\nlet a = SignalProducer([1, 2])\nlet b = SignalProducer([1, 2, 3])\na.combineLatest(with: b)\nNormally it's time that decides the way events should be interleaved. But for two synchronous streams, time isn't a factor. If the events will be delivered synchronously, would it make sense to zip the events while they are delivered synchronously? But that muddies the semantics of combineLatest.. If I rewrite the test like so, it passes:\n```swift\nit(\"should combine synchronous events\") {\n    var values: [String] = []\nSignalProducer<Int, NoError>([1])\n    .combineLatest(with: SignalProducer([1, 2]))\n    .startWithValues { a, b in\n        values.append(\"\\(a)-\\(b)\")\n    }\n\nexpect(values) == [\"1-1\", \"1-2\"]\n\n}\n``. I'm going to close this for now, now that I understand how ordering affects the semantics ofcombineLatest. In the particular case I was working on, flipping the order of the producers does resolve my problem.. I've pushed d7b6686bba9a5f939ee926e3f7e82e7789630344 to show where I'm currently going with the replay cache policy idea. Once CI completes, it should hopefully show that 6cab6a3bde2c92a8fd589828bd765785e03594ab is the minimal change that breaks the composedPropertylifetime behaviours, and d7b6686bba9a5f939ee926e3f7e82e7789630344 adds support for retrying after failure but without breaking the existing tests forreplayLazily(). This is still very much a work in progress, as I got fairly set back by the property lifetime stuff and haven't tested the new stuff yet..withworks for me.. Thanks for the report! I've opened #221 which should fix this issue.. I think I'm \ud83d\udc4d  onattachandobserveEnded, although I thinkattachcould use a more descriptive name. But I think adding+=would be a step backwards in terms of clarity.. I tend to agree with @stephencelis (https://github.com/ReactiveCocoa/ReactiveSwift/pull/232#discussion_r96555572). I personally don't mind that the standard library reusesflatMapfor this purpose, and for that reason I would lean slightly towards following the precedent it establishes. But on the other hand, every overload offlatMapthat ReactiveSwift provides currently accepts aFlattenStrategy, and it's possible that this overload could increase the cognitive burden of understandingflatMap. For that reason my vote is forfilterMap.. What does \"amb\" actually mean? I personally feel it would be better to have a more intention-revealing name, and link back to the equivalent Rx version.. It's probably not the most intention-revealing code, but you could use something along the lines offoo.materialize().then(next)`.. > we cannot deprecate it in 1.x\nI don't believe this is true. I haven't experimented with it yet, but it seems to me it should be possible. I'll get back to you.\n\nthis would not hit the majority of users, and even for those who define custom operators, it is just a matter of renaming\n\nIf we include SignalProtocol and SignalProducerProtocol the likelihood of affecting more users seems higher. It's also possible that users might be writing generic functions that use these protocols as constraints. Granted, the percentage is still probably small.\nStill, I remain convinced that it's reasonable to provide deprecation warnings before removing an API. Aggressively breaking public API without first deprecating is a trend that I'd like to see the Swift community move away from.. I opened https://github.com/ReactiveCocoa/ReactiveSwift/pull/248 as a concrete example for discussion.. Although I just realised something: given that 3.1 is supposed to be source-compatible with 3.0, I think we should be able to just slap the deprecation warning on and not duplicate anything?? I'll take a look at how to get Swift 3.1 to compile in 3.0 mode.... I've just pushed a change which removes the duplication.. I now believe this should work just fine for our other *Protocols, too. I'll do some more experimenting tomorrow.. > ... suitable for inclusion in the next minor release\nBecause the deprecation warning only shows for Swift >= 3.1, this could now go into a patch release.. Interesting, I didn't see that warning in my tests. I'll try with a different Xcode version and see if it comes up (I was using the 8.3 beta).. @available(swift, ...) is only, ahem, available, in Swift 3.1: https://github.com/apple/swift-evolution/blob/master/proposals/0141-available-by-swift-version.md. I'll have to nut out how to handle this properly under semver. Though if this is just going to emit a warning when compiling ReactiveSwift and not in user code, it might be fine to ignore it.. Yeah, we don't have to keep the incompatible changes, this should probably just be the deprecation. As the implementations have no longer moved, I'm not sure I see why we can't do this with the other protocols?. I also just realised that it's not going to be possible to remove SignalProtocol and SignalProducerProtocol until we get recursive constraints in extensions (used for the flatten operator), which won't land until at least the Swift 4 timeframe. I don't think it would make sense to add a deprecation warning for these protocols until we have a version of that feature we can test with.\nSo, the current state of this PR:\n\nOn Swift 3.1, this change emits deprecation warnings for all uses of ActionProtocol\nOn Swift 3.0.x, this change emits an \"invalid platform\" warning in ReactiveSwift, but doesn't emit any warnings in calling code.\n\nIt's a shame that there's no way to suppress the deprecation warnings for uses internal to ReactiveSwift, and they're a little annoying. But I don't think I mind that for the sake of users. @ReactiveCocoa/reactiveswift I'd love to hear your thoughts on the matter of warnings internal to this codebase. It doesn't bother me, but I totally understand if others feel differently.. Maybe both? This definitely fails under Swift 3.1 with a recursive constraint error:\nswift\n// Flatten.swift\nextension Signal where Value == Signal .... Yeah, I feel like that's better than introducing deprecation warnings into consuming projects unnecessarily.\n\nOn Feb 15, 2017, at 1:30 PM, Anders Ha notifications@github.com wrote:\n@andersio commented on this pull request.\nIn Sources/Action.swift https://github.com/ReactiveCocoa/ReactiveSwift/pull/248:\n\n@@ -207,6 +207,7 @@ private struct ActionState {\n }\n\n/// A protocol used to constraint Action initializers.\n+@available(swift, deprecated: 3.1, message: \"This protocol is no longer necessary and will be removed in a future version of ReactiveSwift. Use Action directly instead.\")\nThis would happen when building through Carthage. https://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/201869272#L821 https://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/201869272#L821\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/ReactiveCocoa/ReactiveSwift/pull/248, or mute the thread https://github.com/notifications/unsubscribe-auth/AAJA5m3xaTumCRyRyoREIgcgk9Gx88GAks5rc0RDgaJpZM4L3YjH.\n\n\n. @ninjudd Like the host of other cases in Swift where it's encouraged to use bridged native types, NSError got the same treatment in SE-0112. Unfortunately, that proposal landed after WWDC 2016 (but still in time to be included in Swift 3), and as a result there's not a lot of documentation out there for the functionality.\nAs a result, there should actually be very little occasion to use NSError directly. AnyError is a workaround, as @andersio mentioned, for a limitation of Swift which prevents Signal<T, Error> from being valid. The idiomatic way to work with AnyError is to grab the var error: Error value it wraps, and then use pattern matching on specific error types like URLError, CocoaError, POSIXError, et al.. On the grounds of \"omit needless words\" this seems like a good change. I was initially concerned about just using \"make\" because of ambiguity using leading dot syntax. But now that I think about it, leading dot syntax isn't possible in this case because the method returns a tuple, so \ud83d\udc4d from me.\nThe documentation will need to be updated too. Might be worth just grepping the project for any use of makeLifetime.. @andersio Will you be able to update the docs and examples for this too?. The README and Framework Overview both have references to makeLifetime.. Well, it already has a lifetime, so there's that.. This seems similar to how FlattenStrategy is used. It also reminds me of RACCommand's concurrent execution mode. Thoughts on modelling this after FlattenStrategy and adding a new case called reject (or maybedisable, etc.) for the current behaviour?. FWIW this is something I've reached for in the past too (specifically the buffering/concat behaviour).. Left a comment on https://github.com/ReactiveCocoa/ReactiveSwift/pull/351#issuecomment-304308268 about naming.. I think SignalProducerConvertible would be a better name. In the stdlib, ExpressibleBy* represents a function from a specific type of literal to one of many concrete types that literal could represent. To me, ExpressibleBySignalProducer implies that you would see a SignalProducer in the source code, which would convert to some other type. What we want is the reverse: convert from any number of concrete types to SignalProducer.. I don't think a preposition is necessary though? I think it's pretty clear in your example what is convertible to a SignalProducer, in the same way that it's clear what can be converted to a string when you conform to CustomStringConvertible.. What's the benefit of this change?. Given that it makes the method signatures a little harder to read, I feel like I'm \ud83d\udc4e on this for now. I'm pretty happy with +=, and was kinda sad to see it go. I do agree we should have a method on Disposable (a la. RxSwift's disposed(by: disposeBag)).. Happy to wait for #436 and rebase.. or #437 \ud83d\ude02 . Ready to go \ud83d\udc4d . For reference, some previous discussion on this general idea: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2632. Right, transitive dependencies, of course. What a bummer.. Oh, thanks for reviewing this again! It was on my list, but I apparently also forget that I already updated this. \ud83d\ude05 . > > You can now use a state-property with a non-Void input type\n\nDo you find yourself actually wanting to do this?\n\nThe discussion on slack that these changes arose out of was specifically about using a UIViewController as the input to an action: I've experienced lots of cases where an asynchronous operation involves presenting some kind of modal UI, and it's a pretty common pattern in UIKit.\nThe main advantage of this change is the increased composability (wrapping/unwrapping, custom validation logic, input type) and progressive disclosure (start with a simple Void action, add state, then validation).. This could probably use some documentation with examples at some point, but for now the changelog is updated \ud83d\udc4d . IMO it feels like unnecessary churn unless there's a clear benefit. Being able to unambiguously use trailing closure syntax is pretty important to me, and could be to many of our users.. I don't know, I probably couldn't pin down \"equally common\". However, I think I tend to use plain old start() most, and handle side effects elsewhere, for example with Property, Action, or bindings.. FWIW, this kind of thing should be possible with throttle(while:on:). ReactiveCocoa doesn't yet have a high-level convenience property that maps view appearing/disappearing events to true/false, but that should be reasonably straightforward to construct.. What about dispose(atEndOf: lifetime)?. See also http://forums.swift.org/t/more-consistent-function-types/9765/1. I'm a little torn on this. I really like the idea of aligning with the standard library where possible, but when I read signal.compact() it feels kind of meaningless in comparison to signal.skipNil(). Now that I'm thinking about it, signal.compactMap() also reads strangely to me. I think I prefer our current names.\nHowever, the types are similar and may very well be what some new users reach for when they compare working with a stream of optional values to working with a Sequence or Collection of them. Maybe we can get the discoverability benefits by adding empty implementations of compact() and compactMap() with fixits that suggest the correct name (and ideally hint as to why)?. > How do you attach the lifetime of a SignalProducer to the lifetime of another one, either Signal or SignalProducer?\nI'd use the take(until:) operator for this.. Interesting: on the left hand side of <~ you want (the semantics of) BindingTarget, and on the right, Property. This feels kind of lens-y to me \u2014 maybe we need a kind of mutable property (it's a protocol, right?) that is just a view into another, rather than owning its own storage?. How's this for a start? This is specifically not retaining the base property, so that it has the same lifetime.\n```swift\nfinal class MutablePropertyView: MutablePropertyProtocol {\n    typealias Value = Derived\nlet lifetime: Lifetime\nlet producer: SignalProducer<Derived, NoError>\nlet signal: Signal<Derived, NoError>\n\nprivate weak var base: MutableProperty<Base>?\nprivate let cache: Property<Derived>\nprivate let keyPath: WritableKeyPath<Base, Derived>\n\ninit(base: MutableProperty<Base>, keyPath: WritableKeyPath<Base, Derived>) {\n    self.base = base\n    self.keyPath = keyPath\n\n    cache = base.map(keyPath)\n    lifetime = base.lifetime\n    producer = cache.producer\n    signal = cache.signal\n\n    base.lifetime.observeEnded { _ = self }\n}\n\nvar value: Derived {\n    get { return cache.value }\n    set { base?.modify { $0[keyPath: keyPath] = newValue } }\n}\n\n}\nextension MutableProperty {\n    subscript(keyPath: WritableKeyPath) -> MutablePropertyView {\n        return MutablePropertyView(base: self, keyPath: keyPath)\n    }\n}\n```\nI'm not sure I have the bandwidth to drive the implementation this, but I had need for something like this in my current project so thought I'd share in case someone wants to work on it.. So I tried a version where the view retains the base property, but that causes problems with this kind of thing:\nswift\nproperty[\\.name] <~ someBindingSource\nIn this expression, unless something retains the view, the whole binding will immediately complete. So in my example above, the base property retains the view until the end if its lifetime. If you then make the view strongly reference the base property, you have a leak. I haven't figured out a way to break this cycle yet.\nSo, it's possible to conform MutablePropertyProtocol and weakly reference the base property, because if the reference is nil you can just discard updates. This makes sense, because the view doesn't own the storage. However, ComposableMutableProperty is another thing: in order to implement modify(), you have to execute the closure, which gets difficult if your reference to the underlying storage has gone away and you don't have a value to pass in.. Ok, I figured out how to get it to conform to ComposableMutablePropertyProtocol: https://gist.github.com/sharplet/4f23ac034d94c0e94b476d8a4ca5565c.. I should probably just open a PR with what I have at this point, so we can more easily discuss the finer points of the implementation.. > The view can supply a manual binding target \u2014 it has the access to the backing property to derive a binding target from it, instead of relying on the default implementation.\nOk, so I think I understand what you mean now: the view retains the base property, but the binding target does not, so when the view immediately is deallocated, the binding target continues with the same lifetime as the base property.\nHowever, I quickly discovered in my use case that I wanted the ability to keep these views around, and created a type-erased wrapper:\nswift\nlet username: AnyMutableProperty<String> = AnyMutableProperty(user[\\.name)\nThis is really useful, but definitely complicates the object graph. Given the precedent of Property(mutableProperty) not capturing its underlying property, I found that I initially expected an AnyMutableProperty wrapper to behave the same way. But it's not clear to me what the ownership semantics should be, and I'd want to be careful that we don't make it too easy to leak memory. Do you have any thoughts on how this could work?. > Why are you making custom mutable property types?\nIt cut down on some boilerplate while I've been experimenting with ideas for #613.. A code example would definitely help, thanks!. @kean IMO, the \"cold\" aspect of Property.producer is that the initial value you get will be different based on when it is started. This is kind of subtle though, and different SignalProducers can always exhibit different levels of coldness.\nThe way I think of it is that SignalProducer is not a guarantee of coldness, it is just capable of exhibiting cold semantics \u2014 in addition to hot semantics (e.g., a SignalProducer(signal) that just observes the underlying hot signal when started). The guarantee works in the other direction: Signal is a guarantee that you have hot semantics, and there are no implicit side effects to observing one.\nRegarding the cold or hotness of Property \u2014 yes, if you have a Property<T>, assume it's always hot. It will continue to change regardless of observers. However, a function A -> Property<B> (if it produces a new Property every time it's invoked) can potentially model a \"cold\" property that is the result of its input.. I think futureValues is a good name for signal \u2014 with that, how about renaming producer to just values? I think the behaviour of \"current and future values\" is a sensible & useful default, so giving it a shorter and more accessible name makes sense.. So here's an example from my app that using each version:\n```swift\nsearchOrigin.sample(on: refreshed, passThroughValues: true)\nsearchOrigin.resample(on: refreshed)\n```\nThe first reads to me as two distinct actions: \"sample on refreshed\" (stops emitting the original values), then \"pass through values\" (undo that and start passing through values again). The second is more like \"give me the values, and resample on refresh\".\nI don't think it's a very strong argument, but IMO the second version edges ahead of the first in clarity.. Let's say you start with two mutable properties, one for the unfiltered array, and another for the current filter:\nswift\nlet items: MutableProperty<[Foo]> = // ...\nlet filter = MutableProperty(\"\")\nYou can use the binding operator to connect your search bar to your filter property:\nswift\nfilter <~ searchBar.reactive.textValues.map { $0 ?? \"\" }\nThen you can compose these two properties together to produce a new property of filtered results:\nswift\nlet filteredItems = items.combineLatest(with: filter).map { items, filterText -> [Foo] in\n  if filterText.isEmpty {\n    return items\n  } else {\n    return items.filter { $0.localizedStandardContains(filterText) }\n  }\n}\n// add .skipRepeats() if your items are Equatable\nBinding filteredItems to your table view can be achieved by implementing your data source methods to access filteredItems, and then adding one additional binding to trigger reloadData when the filtered items change:\nswift\ntableView.reactive.reloadData <~ filteredItems.signal.map { _ in } // Signal<(), NoError> that fires whenever the property changes\nThis may not quite compile as-is, but hopefully that gives you enough to get started.. I have had this particular use case before when writing extensions for Kingfisher, which uses a .kf extension provider for its UIKit wrapper functionality. The value returned from .kf is a class, which explains why I didn't have this limitation.\nI'm not currently opposed to loosening the restriction, although as you say it doesn't make a lot of sense for binding targets. @mdiep is that the confusion you're thinking of? That users might make a binding target to a struct and then be confused that it doesn't mutate shared state?. The recommended way to parallelise work in the case you're describing is actually not to use a concurrent queue, but rather to use DispatchQueue.concurrentPerform(). The problem with using a concurrent queue is that it is actually unbounded parallelism, meaning that GCD will potentially allocate so many threads that your system locks up. DispatchQueue.concurrentPerform() solves this by scheduling work smartly based on the available resources on your system.\nIt might be really nice if concurrent queues also worked that way, essentially giving you a load balancing strategy to avoid overloading the system with threads. But I'm not a parallelism expert \u2014 it probably really depends on your workload as to whether this would actually be faster than a high-priority serial queue.. You might be able to try signal.throttle(while: property.negate()).. Yeah, throttle(while:) will drop everything but the most recent event.\nHere's a quick sketch of how I would compose this out of existing operators:\n```swift\nenum MyEvent {\n  case foo(Foo)\n  case enabledChanged(Bool)\n}\nstruct MyState {\n  var foo: Foo?\nvar isEnabled: Bool {\n    didSet {\n      if !isEnabled {\n        foo = nil\n      }\n    }\n  }\nstatic let initial = MyState(foo: nil, isEnabled: true)\n}\nlet fooEvents = foo.map(MyEvent.foo)\nlet enabledChanged = isEnabled.map(MyEvent.enabledChanged)\nlet fooWhileEnabled = SignalProducer\n  .merge([fooEvents, enabledChanged])\n  .scan(into: MyState.initial) { state, event in\n    switch event {\n    case let .foo(foo):\n      state.foo = foo\n    case let .enabledChanged(isEnabled):\n      state.isEnabled = isEnabled\n    }\n  }\n  .filterMap { $0.foo }\n```\nSo the key things are:\n\nCreate some kind of Event enum to convert all your inputs to the same type;\nUse scan() to combine incoming events into some kind of state value;\nUse filterMap() to drop states that you don't want, and keep states that you do.\n\nIt should be straight-forward to generalise the MyEvent and MyState types into generics so that this operation is reusable for different types.. This is a gotcha of ARC that applies outside of ReactiveSwift as well (including in Objective-C). Here's something similar to your example using NotificationCenter:\nswift\n// (1)\nself.observation = NotificationCenter.default.addObserver(forName: Foo.notification, object: nil, queue: nil) { notification in\n  let uuid = notification.userInfo?[Foo.uuidKey] as? UUID\n  // (2)\n  uuid.flatMap { [unowned self] in\n    completionHandler(self.planes[$0])\n  }\n}\nThe main thing to note here is that when the [unowned self] capture list is evaluated, self is in the context of the first closure, (1). This creates a strong reference to self in the outer closure, in order to make the unowned reference in the inner closure, (2). This is effectively what the capture list does:\nswift\nunowned let self = self // on the rhs, self is strong\nuuid.flatMap { self.planes[$0] }\nHopefully that clears up where the strong reference is coming from.. Note: I plan to add tests for this as well, but wanted to open this up for discussion about the API itself. For example: using run loop based concurrency might not be what we want, because it doesn\u2019t compose well with GCD outside of the main queue. So something DispatchIO based could solve the same problem, and make use of QueueScheduler instead.. (I already have some proof-of-concept level code for a DispatchIO wrapper, but it\u2019s far more complex.). All the CFunLoop stuff isn't compiling on Linux. I'll have to do some investigation there.. Thanks, please take your time!. So I started trying to get RunLoopScheduler to compile on Linux, and ran into a couple of issues.\nThe first is that Timer isn\u2019t toll-free bridged on Linux right now, and there\u2019s no access to the underlying CFRunLoopTimer object, so we\u2019d essentially have to reimplement the Timer class to get this to compile.\nThe second is that background file reading isn\u2019t even implemented yet! \ud83d\ude05 I\u2019ve pushed commit c7bc699 that disables this feature on Linux, in order to get things compiling.. I initially tried to use func apply() -> SignalProducer here, but Swift complained about this not matching the signature of apply as defined in ActionProtocol. The workaround was to at least provide a default value of (), but this still feels like a bug to me.\n. Good catch! Also fixed up some weird tab vs. space problems Xcode inserted for me.\n. What do you think about https://github.com/ReactiveCocoa/ReactiveSwift/pull/22/commits/07ea7e7c18c04c19275e3ddcb3dc1e2bde9bc47e? It synchronises checking for isEnabled and calling executeClosure, so I think should solve this particular problem.\nIt feels like there could be a more fundamental refactoring of Action that would remove the need for force-unwrapping (like you were hinting at), but this is the smallest change I could think of.\n. I was actually having trouble reasoning about whether changes to isExecuting and userEnabled were truly atomic, so I resolved that by unifying the two properties in a single struct that can be modified atomically via MutableProperty. See 25a3024.\n. I think this is going to retain target.\n. What do you think about dropping the word \"pseudo\"? To me it makes it sound like this isn't a \"real\" binding target, even though it's as real as any other binding target (and arguably purer).\n. Have we considered any other names than AnyBindingTarget? I can see from the initialiser below that this can be used as a type-erased wrapper, but I'm not sure that's its primary purpose. Given that this is perfectly useful as just a pure sink for a binding, what about calling it BindingSink or Sink or even just BindingTarget (the latter implying a rename of the protocol to BindingTargetProtocol)?\nI'm not necessarily opposed to the name, just thought I'd throw some alternatives out there :)\n. Any reason not to allow any old queue to be passed here instead of tying this to the main queue?\n. Hmm, I suppose? But given that we're referencing target.lifetime, I was assuming we wouldn't want to extend the lifetime by also retaining target. I don't know what the correct semantic is.\n. However, if I have a text field, and a binding target that sets its text property, retaining the binding target is not the same as retaining the text field. So I think you're right, the important thing is that the binding target doesn't affect the lifetime of the subject of that binding.\n. I tried making this change (having the execute closure return SignalProducer<Output, ActionError<Error>>), but I couldn't figure out a nice way to make the API work without breaking the existing use case.\nHowever, I tried making the return value an optional signal producer, which seems to work nicely: https://github.com/ReactiveCocoa/ReactiveSwift/commit/c8791b7a75123e4885262b7da5cdbc5f7bb8668f. \nThere's something still wrong to me about this though. I think if we want to truly prove this is safe, we need to make checking the enabled state and grabbing the input value an atomic operation, which means moving the input property into ActionState somehow...\n. I really like the idea of making ActionState more powerful by allowing it to carry an optional value, but I can't think of a way to achieve that without leaking implementation details out via ActionProtocol.\nThat is, I'd like to make a private initialiser, but because ActionProtocol.init(input:_:) is in a protocol extension it has to call a public initialiser. Starting to wonder whether the only way to make this safe & atomic is to reintroduce PropertyAction, so it can redefine isEnabled in terms of input while still providing atomic access to the current value.\n. It wouldn't be \"by default\" though, would it? If you use the designated initialiser you can still create a synchronous binding, but if you use the onScheduler: form it will most likely be async (since UIScheduler is meant to skip asynchronous dispatch if possible, right?).\n. The problem is that the only difference between the two initialisers is the return type of execute: this makes trailing closures with inferred return types ambiguous, and I don't think forcing users to always explicitly annotate the return type is a good idea.\n. How about ReactiveExtensionProvider? I think that describes the role well.\n. Stylistically, this could also become a switch statement if you prefer, which would add exhaustively checking.\n. Fixed.\n. Made this change in e2dd0901a461bab7f95baf34ab6d42b0b59701de, let me know what you think.\n. Hmm, I think I kinda see it the other way. If this was implemented in terms of Signal, we'd have to pick a default starting state for the throttle, probably .resumed so that events are passed through. Using Property means we don't have to make that assumption.\nFrom a slightly different perspective, Property is more powerful than Signal in that you could implement a signal-based overload of this method by composing it with an initial value and calling through to the property-based implementation.\nI pushed 4dcd2bfc92dad2e0f022606a1dc79b86e58d3a96 to demonstrate what I mean. If you think those overloads would be useful I'll add some docs and merge those changes in here.\n. Good call! I've pushed 58e5bed. I ended up having a single return nil after the conditional block, but if everyone prefers this style (a return at every branch) I can change it.\n. \ud83d\udc4d \n. I've moved the let outside \ud83d\udc4d \n\nYou don't need to unwrap the bound value with ? since the return type is Value?\n\nWhile that's technically true, I think there's value in being precise with exactly the conditions where this branch should be followed. The idea is that we should only send value event if a value was actually throttled, and I feel like this version communicates that more clearly. What do you think?\n. Yeah I've seen other libraries use this and was experimenting. Reverted.\n. In my mind it's the same reason that Action captures a strong reference to its enabledIf property. So to me it seems convenient, not having to maintain an extra strong reference to that property.\nBut that doesn't help me to understand what the problem with that strong reference is.\n\nWhat if it terminates the resulting signal when shouldThrottle completes, gaining the take(during:) semantic?\n\nRegardless of the current behaviour, are you saying that if shouldThrottle completes, the returned signal should or should not also complete? I think it would make sense to add some tests for these semantics so it's clear what we want the behaviour to be.\n. It seems to me like the options are:\n1. When shouldThrottle completes, the signal may get stuck in the throttled state (i.e., whichever state was last)\n2. When shouldThrottle completes, the state gets switched back to .resumed\n3. When shouldThrottle completes, the signal completes\n(2) feels plain wrong to me, which makes it a toss-up between (1) and (3). So I feel like it comes down to which option is more surprising, and which option is easier to see/debug. For that reason I'm leaning towards tying the lifetime of the returned signal to the lifetime of shouldThrottle.\n@mdiep What do you think?\n. Or anyone else who's been involved in the thread of course! \ud83d\ude05 \n. This keeps a strong reference to shouldThrottle for SignalProducers. @andersio does this need to change as well?. The first thing I tried was to wrap shouldThrottle in an existential:\nswift\nlet shouldThrottle = Property(shouldThrottle)\nreturn lift { $0.throttle(while: shouldThrottle, on: scheduler) }\nBut that also increases the lifetime of the underlying property. Is there any way to capture a reference to this property that won't extend its lifetime? It looks like composing properties fundamentally alters the lifetime of the source property, extending it to be the union of all transitive property lifetimes. Is that intentional?. Without defer, if try action(&_value) throws, the lock will never be unlocked.. I think we should bring back defer here too.. I think of using a raw pointer here it might make sense to use mutex.deinitialize(1) and mutex.deallocate(1)? I'm not super familiar with the new pointer APIs though.. You can omit let error here, and in the other catch blocks.. Is the closure type annotation necessary here?. https://developer.apple.com/reference/swift/unsafemutablepointer/2295090-deallocate:\n\nPrecondition: The memory is not initialized.\n\nThis is what made me think that perhaps we should be calling mutex.deinitialize() first.. Just wanted to note that reflecting doesn't feel quite right to me, though I haven't been able to come up with a suitable alternative yet.. Is 4 notes excessive? \ud83d\ude05 . This could be shortened to lock?.lock(). This could be shortened to return lock?.try() ?? true. This could be shortened to lock?.unlock(). What do you think about just naming this lock()?. What do you think about just naming this tryLock()?. What do you think about just naming this unlock()?. I think this should be a named parameter.. I think this should be a named parameter.. I'm not sure about the naming \u2014 how about this?\n```swift\npublic enum SignalSerialization {\n  case mutex\n  case inherit\n}\nSignal(serialization: .mutex) { observer in\n  // ...\n}\nSignal.pipe(serialization: .inherit)\n``. This comment will need to be updated when the name is finalised.. This comment will need to be updated too.. FWIW, I still think this case would read better as an imperative:Signal(serialization: .inherit). This should read \"torn down\". Why an optional Disposable?. I think we've lost too much meaning now at the point of use. It's no longer clear what's being inherited.. I'd sayserializationStrategy`.\nHowever, I'm still partial to serialization: .default and serialization: .inherit. What do you think?. ...with declaration: init(serialization strategy: SerializationStrategy, ...).. Does this really need to be wrapped onto a new line?. I think we can reword this without the \"special snowflake\" comment now.. I think this would read better as \"A signal whose latest value...\". What do you think about renaming the local variable to values from signal? I like the direction of naming the signal to describe its values, rather than just restating that it's a signal (which we know from the types).. Likewise, what do you think about naming this values internally?. And this also could remain values.. It makes sense to me to keep the values: label here.. I think having both state and status feels confusing. It's unclear to me whether they're two related concepts and should be together, or two independent concepts and perhaps could be named more descriptively?. I think \"futures/promises\" would read better than \"futures, promises\". This line is triggering a \"variable is written to but never read\" warning. Mind changing this to a let constant? Probably doesn't need to be optional either.. Fair enough.. The existing operators are in the middle of an unconstrained protocol extension, whereas these are in a protocol extension where Error == NoError. Do you want me move the existing operators so that these can all go together?. It's hard to say for sure without some concrete examples, but I wonder if this operator might read better as negated?. Yeah, I was going for consistency with the rest of the file.. It's a nitpick, but do you think we can make this change without reindenting the file? It makes the diff a little hard to follow, and there's no shared setup/teardown code.. I'm planning to respond properly to this, but in the meantime I spotted a theoretical false positive in this test. What do you think about this change? https://github.com/ReactiveCocoa/ReactiveSwift/commit/840bf6a2dbab3ff98f49ab47b69a93c594bd90ae. > \"the getter should execute on the specific scheduler/thread that is specified\"\nYeah, that's exactly what I was trying to verify. I agree that in this case having a simpler test is better, but I admit I got caught up in trying to solve the problem of verifying that execution occurs on the expected queue/scheduler. \ud83d\ude1b\nI believe that code does what it says on the tin (and is thread-safe), so if you think it's valuable to include it feel free to use it as inspiration. Some of those details deserve to be factored out into some kind of test helper anyway, so that the test itself can be higher level.. How about \"until both inputs complete\"?. I'm not so sure: currently it only generates a warning inside ReactiveSwift, so I like the idea that it won't generate any warnings for consumers.. Does this still need to be @testable?. What is retaining here? This line reads a little weirdly to me, I wonder if we can improve the name.. Thoughts on extracting this to a local newState so we can remove the awkward formatting over two lines?. Could this be moved to env?. What do you think about extracting a helper at the top level for this, say an isSwiftPackagerManagerTest computed property?. It's a bummer that this uses both #if os and @available :(. oops. I briefly considered introducing a typealias to allow SignalProducer<Value, NewError>.Event \u2014 what do you think about that approach?. I think there could be a race condition between sending a value and sending the completed event, where another event on the underlying signal could be sent:\n// scheduled timeout\n|--------------------A->|\n// underlying signal\n|---------------------B------------->\n// returned signal\n|--------------------AB>|\nBut I couldn't think of a test for it. Any ideas? Does this look like a real issue to you?. There's another test that covers the .value case.. I was thinking more for consistency: in Signal we can just reference Event, but in SignalProducer we need to use ProducedSignal.Event. I was thinking that\ntypealias Event = ProducedSignal.Event\nwould allow for consistency across the two types.. Yes. And the race condition: @andersio I could use a hand there, I'm not sure I follow your suggestions.. indentation looks off here. Is this a change in behaviour? Should there be a new test for this?. Specifically though, why was an explicit check of the disposable added?. How would you feel about Status?. Should this read \"Value is uninhabitable\"?. I think this should also be \"uninhabitable\".. I think this is implicitly making a strong reference to self here. Might need a weak reference to ensure the binding doesn't keep the observer alive?. Are you saying another lifetime should be passed in when initialising the observer?. The label validated: doesn't quite read right to me. What do you all think about validatedState: instead? I think if we're not going to try and make it read as a phrase, then using a noun to label the parameter makes sense.. (Ok time to see how much of my high school linguistics I can remember!) The question in my mind is still \"validated what?\" I think it's leaving subject implicit: yes, the email is validated, but we already knew that from its type \u2014 saying so with the label feels redundant to me. Saying validated state makes it clearer that the email (which is validated) is playing the role of the action's state.\nFor me this seems to fall under the Include all the words needed to avoid ambiguity principle in the API Design Guidelines. Specifically, it seems like a subject/object ambiguity.\n(As an aside, I already apparently violated a guideline in the first place by using unwrapping: to form a phrase using the base name of an initialiser.)\n\nOne further idea: in practice we're still unwrapping the validated state values with this overload. How about the label unwrappingValidated:? I'm not really too attached to my reasoning above given we're already in a grammatical grey-area, and I like how it connects this new initialiser to the very similar unwrapping: initialiser. Thoughts?. I think this makes sense \ud83d\udc4d . So we were using it as a regular optional anyway? Huh.. This should probably check the current run loop to avoid the thread hop if possible.. Yeah, I've since seen how UIScheduler prevents recursive scheduling. I guess I can copy that technique here?. I\u2019ve been thinking about this more today, and I think that because of CFRunLoopRun() and friends, we\u2019ll have to use a different technique, because callers can always recursively run the run loop out of our control.\nI think we might be able to maintain some thread-local state that tracks whether we\u2019re already running inside RunLoopScheduler, and then potentially reschedule if that\u2019s already the case?\nBut again, the problem is this call tree:\nRunLoopScheduler.schedule(_:)         // (1) sets thread-local flag\n    CFRunLoopRun()                    // (2) potentially spins indefinitely\n        RunLoopScheduler.schedule(_:) // (3) we'll never be able to schedule unless we call CFRunLoopStop(_:)?\nAnother alternative may be to simply not provide any guarantees: if you\u2019re opting into run loop scheduling, be aware of the pitfalls of recursively spinning the run loop.. Thanks for digging that up. I recall doing a search in the docs for error handling info at some point, but didn't find this!. ",
    "ashfurrow": "Wonderful, expect something later today.\n. Sure thing, where would be the best place to put that? I can leave comments in the podspec itself if you like. \n. Ok, added some docs. I'm also happy to help with ongoing maintenance of the podspec.\n. Sure, I ran pod lib lint locally, I'll add that to the CI script. \n. Aww yeah, passed on CI! \n. It looks like this was fixed by #48 (good job!). Is the 1.0 milestone up to date? This is the only open issue left in it at the moment. \n. Fantastic work! Was going to do this this morning, glad someone beat me to it :smile: \n. No worries, feel free to @ me in if I can ever be of help. \n. ",
    "nikita-leonov": "Thanks, @ashfurrow. I am ready to provide help on maintaining Podspec. I am from time to time missing some RAC releases, so please mention me if Podspec is lagging behind and I will jump in. \n. Thanks, sounds reasonable. Do I understand it right that ReactiveCocoa will be only Cocoa-specific, while ReactveSwift will be its Swift based foundation? As a result, there will be no two Action classes in both ReactiveSwift and ReactiveCococa code-bases. \n. ",
    "ikesyo": "Thanks for reporting the issue! This is definitely a bug.\n\nRecommend changing the signature of the extension init to have a named argument, or even remove it? I'm not sure what the need for the extension init is, given that the normal init is fully generic already.\n\nScopedDisposable has the generic parameter of ScopedDisposable<InnerDisposable: Disposable>, but we can't pass an instance of Disposable protocol type itself because of the limitation of Swift generics. To initialize a ScopedDisposable we needed the new AnyDisposable and pass an instance of it. With the initializer we could write the code:\nswift\nlet d: Disposable = SimpleDisposable()\n// `scoped` is `ScopedDisposable<AnyDisposable>`.\n// We can't use `ScopedDisposable<Disposable>` in current Swift.\nlet scoped = ScopedDisposable(d)\n. I've submitted the fix: #23.\n. Property type would be what you want:\n``` swift\nclass Object {\n  private let _property: MutableProperty\n  func sideEffects() {\n    _property.value = newValue()\n  }\n// Returns a read-only property that wraps an underlying property.\n  var property: Property {\n    return Property(_property)\n  }\n}\n``\n. Let's make it sure that we use1.0.0` for the tag to avoid this: https://github.com/Carthage/Commandant/issues/75 \ud83d\ude4f \n. I will push the first alpha release to CocoaPods Trunk once #35 is merged.\n. https://github.com/ReactiveCocoa/ReactiveSwift/issues/20#issuecomment-249349961: ReactiveSwift 1.0.0-alpha.1 is now on CocoaPods Trunk\n``` bash\n$ pod trunk info ReactiveSwift\nReactiveSwift\n    - Versions:\n      - 1.0.0-alpha.1 (2016-09-24 11:53:35 UTC)\n    - Owners:\n      - Syo Ikeda <...>\n      - Ash Furrow <...>\n      - Nikita Leonov <...>\n``\n. 1341fdba055dc9f60fbe79468b96d0831019d18e: To meet the requirement ofpublic init(input: P, _ execute: @escaping (T) -> SignalProducer) where P.Value == T?, you needlet input = MutableProperty(0)instead oflet input = MutableProperty(0).\n. Looks like thestate property: Stateparameter of the new initializer must be kept alive outside an initialized action: https://github.com/ReactiveCocoa/ReactiveObjCBridge/pull/10#issuecomment-264860959. Is that an intentional behavior change? Formerly the given property is captured by the action byprivate let isUserEnabled: Property.. You might not get the submodules recursively. Wouldgit submodule update --init --recursiveorcarthage checkoutin/Path/To/ReactiveCocoa-masterhelp?\n. Those are **extensions** and should not be the core ReactiveSwift API I think. If they are included in this repo, there is no difference for the users whether it is a core API or an extension.\n. Thanks for your thoughts. I addedpublic let disabledErrors: Signal<(), NoError>` instead.\n. We probably need an extension like this:\nswift\nextension Date {\n    internal func addingDispatchTimeInterval(_ interval: DispatchTimeInterval) -> Date {\n        switch interval {\n        case let .seconds(s): ...\n        case let .milliseconds(ms): ...\n        ...\n        }\n    }\n}\n. This is a duplicate of https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3197. See that issue and https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3210 for the details.\n. And also #8.\n. Some Signal.merge() tests are failing \ud83d\ude31 \n. We can't use Nimble v5.1.0 in SwiftPM because of this: https://github.com/Quick/Quick/blob/v0.10.0/Package.swift#L9 \ud83d\ude05 \nClosing this for now.\n. I prefer just using git submodule update --init --recursive, that does not require installing Carthage.\n. @andersio Carthage/Checkouts/Nimble submodule would not be related to SwiftPM integration unfortunately. I will take a look at the failure.\n. @andersio That is the reason I checked out a specific commit in .travis.yml: https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/.travis.yml#L85 (#47). See #68 too (I'm waiting a new release of Quick).\n. :shipit: \n. FYI the rationale behind the change: https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2750. > Is there a way we can provide a deprecation warning for this change?\nSomething like this? \ud83d\ude09 \n\n. That is a UIKit extension so defined in separate ReactiveCocoa framework.. Yes.. Please see ReactiveCocoa's README: https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md#what-is-reactivecocoa. CI has paased :ship: . Not Error, but AnyError.. URLSession.reactive.data now returns SignalProducer<(Data, URLResponse), AnyError> ( as I said above) so you should change the return type of your function to SignalProducer<(Data, URLResponse), AnyError> as well.. The file is originally for swiftenv, not for CocoaPods.. The underlying problem is that valid SWIFT_VERSION build setting value is different per Xcode versions:\n\nXcode 8.0: 3.0\nXcode 8.1: 3.0 or 3.0.1\nXcode 8.2: Backed to 3.0 (can't use 3.0.2)\n\nI think this should be addressed on CocoaPods or CocoaDocs side.. Not public, but @_versioned internal properties should work.. MainQueueScheduler seems confusing as we have QueueScheduler.main.. Question: What is the value, is it the first or last value of the producer?\nI'm not a fan of the syntax and I think that first(), last(), single() and wait() operators should be used selectively.. > They cannot be used with try / catch.\nResult has dematerialize function for try / catch: https://github.com/antitypical/Result/blob/3.1.0/Result/Result.swift#L42. Hmm that is affected by https://github.com/Carthage/Carthage/issues/1792.. \ud83d\ude1e http://blog.cocoapods.org/CocoaDocs-Documentation-Sunsetting/. I've just experienced a weirdness due to this and the attemptMap overloads: https://github.com/mdiep/Tentacle/pull/86#issuecomment-317451932.. FYI I suffered this again in Carthage: https://github.com/Carthage/Carthage/pull/2077.. Closing this due to inactivity.. How about this?\nlet producer: SignalProducer<MyOutput, ActionError<APIRequestError>>\nif add.isEnabled.value {\n    producer = add.apply(input)\n} else {\n    producer = remove.apply(input)\n}\nreturn producer.flatMapError { error in\n    switch error {\n    case .disabled: return .empty\n    case let .producerFailed(inner): return SignalProducer(error: inner)\n    }\n}. Recently done.. Ah that makes sense.. I'm sorry, it's ready now. \ud83d\ude4f . Looks like you use Xcode 8.2 but current master requires Xcode 8.3 (Swift 3.1).. Coming from https://github.com/Carthage/ReactiveTask/pull/97/files#r125483012 and \ud83d\udc4d for some sort of operator or something like Disposable.bind(to: Lifetime) (over Lifetime.attach).. This will be difficult to read / understand and will not be natural:\nswift\nstderrAggregated\n    .then(stdoutAggregated)\n    .map(TaskEvent.success)\n    .start(observer) <~ lifetime\nThe following (placing a lifetime on LHS) is preferable for me (as a natural replacement of += operator):\nswift\nlifetime <~ stderrAggregated\n    .then(stdoutAggregated)\n    .map(TaskEvent.success)\n    .start(observer). Thank you! :shipit: . Could you please update ReactiveCocoa to the latest 5.0.4 release (and ReactiveSwift to 1.1) first? The version you use is too old (early development version of RAC 5).. > having a more standard variable name that can be used across different projects\n:-1: for that. I intentionally used a project-specific variable to avoid pulling test dependencies of dependencies.. Hmm using the same word dispose may be a bit confusing:\nswift\nproducer.start().dispose()\n// versus\nproducer.start().dispose(when: lifetime). whenEnded sounds good (over just when).. I'm happy with += so withdraw this.. To disambiguate something like this:\n```swift\nlet producer1 = SignalProducer(value: \"\")\n    .flatMap(.concat) { str -> SignalProducer in .empty }\nlet producer2 = SignalProducer([\"\", \"\"])\n    .flatMap(.concat) { str -> SignalProducer in .empty }\n```\n. Hmm this isn't compatible with Swift 3.1. Closing.. This reduces warnings, merging.. :shipit: . Will this be shipped as a part of ReactiveSwift 2.1? I'm not confident that if it is okay to drop Xcode 8.3 / Swift 3.1 support in the minor release.. Carthage does not fully support static frameworks, so this would break Carthage support. See https://github.com/Carthage/Carthage/issues/1379 and https://github.com/Carthage/Carthage/pull/1935.. Carthage now builds only dynamic frameworks, not static ones: https://github.com/Carthage/Carthage/blob/a3573d94f97458473b2d8ae0282cd6d34e9908a2/Source/CarthageKit/Xcode.swift#L277-L279. See the CI job, no frameworks were built: https://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/300898609. @andersio Sorry for the delay, Result 4.0 has been released \ud83d\udea2 \nhttps://github.com/antitypical/Result/releases/tag/4.0.0. Closing this due to inactivity.. I\u2019m not sure about .using, but Signal.just and Signal.error would be nonsense since there is no observers at the time of creation / sending the events. Maybe what you want is SignalProducer.init(value:) and SignalProducer.init(error:).. If one uses the method with method reference, the addition of a default argument would break that usages (theoretically).. This should be able to be closed now.. Closing this due to inactivity.. Because Swift.Error now conforms to itself in Swift 5, can we close this?\nhttps://github.com/apple/swift/pull/21073. > Do you want to move the headers phase before the compile sources phase as part of this?\nAddressed in eb2bae1!. Danger will be a candidate.. https://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/392975283#L1448-L1451\n```\nTest Case '-[ReactiveSwiftTests.PropertySpec MutableProperty, should not deadlock]' started.\n/Users/travis/build/ReactiveCocoa/ReactiveSwift/Tests/ReactiveSwiftTests/PropertySpec.swift:302: error: -[ReactiveSwiftTests.PropertySpec MutableProperty, should not deadlock] : failed - Waited more than 1.0 second\nTest Case '-[ReactiveSwiftTests.PropertySpec MutableProperty, should not deadlock]' failed (1.363 seconds).\n``. Let's restart.. Maybe you'll need to writeimport CoreFoundationexplicitly (which will not be exported throughFoundation` module).. Ref: https://github.com/ReactiveCocoa/ReactiveSwift/issues/696. Okay we need Quick and Nimble updates first.\n\nhttps://github.com/Quick/Quick/pull/831\nhttps://github.com/Quick/Nimble/issues/623. To match with the Xcode project.\n. apply() returns a  producer of SignalProducer<Output, ActionError<Error>> and the producer sends ActionError.disabled if the action is still exectuing. Am I misunderstanding?\n. You may mean the execute closure of init.\n. This is required for NSEC_PER_SEC (https://github.com/Quick/Nimble/pull/343).\n. I'm not sure if this is a right way. Please advise me if there is a better way to implement the functionality on Linux. \ud83d\ude4f \n. I'm not so sure how does it look like... \ud83e\udd14 \n. https://github.com/ReactiveCocoa/ReactiveSwift/pull/43#discussion_r81200895\n. as NSArray cast does not work on Linux.\n. Unfortunately conditional compilation like that does not work, each conditional block must have valid expressions:\n\nReactiveCocoa/ReactiveSwift/Package.swift:8:9: error: expected expression in container literal\n        #if !os(macOS)\n        ^\nReactiveCocoa/ReactiveSwift/Package.swift:7:99: error: expected ',' separator\n            .Package(url: \"https://github.com/antitypical/Result.git\", majorVersion: 3, minor: 0),\n                                                                                                  ^\n                                                                                                  ,\nReactiveCocoa/ReactiveSwift/Package.swift:7:99: error: expected ']' in container literal expression\n            .Package(url: \"https://github.com/antitypical/Result.git\", majorVersion: 3, minor: 0),\n                                                                                                  ^\nReactiveCocoa/ReactiveSwift/Package.swift:6:16: note: to match this opening '['\n        return [\n               ^\nReactiveCocoa/ReactiveSwift/Package.swift:9:14: error: unexpected platform condition (expected 'os', 'arch', or 'swift')\n            .Package(url: \"https://github.com/Quick/Nimble\", majorVersion: 5, minor: 0),\n             ^\nReactiveCocoa/ReactiveSwift/Package.swift:9:88: error: extra tokens following conditional compilation directive\n            .Package(url: \"https://github.com/Quick/Nimble\", majorVersion: 5, minor: 0),\n                                                                                       ^\nReactiveCocoa/ReactiveSwift/Package.swift:9:88: error: expected expression\n            .Package(url: \"https://github.com/Quick/Nimble\", majorVersion: 5, minor: 0),\n                                                                                       ^\nReactiveCocoa/ReactiveSwift/Package.swift:12:9: error: expected expression\n        ]\n        ^\nReactiveCocoa/ReactiveSwift/Package.swift:13:6: error: expected ',' separator\n    }(),\n     ^\n     ,\nReactiveCocoa/ReactiveSwift/Package.swift:13:6: error: unnamed argument #3 must precede argument 'dependencies'\n    }(),\n~~~~~^\n()\nCan't parse Package.swift manifest file because it contains invalid format. Fix Package.swift file format and try again.\nerror: invalidManifestFormat\n. That requires explicit Equatable conformance of ThrottleWhileState since case throttled has an associated value.\n. The returned value from an action of Atomic.modify is not a new value for the Atomic instance since https://github.com/ReactiveCocoa/ReactiveCocoa/pull/2984. So this should be written as follows:\n``` swift\nlet valueToSend = state.modify { state -> Value? in\n    guard !state.isTerminated else { return nil }\nif shouldThrottle {\n    state = .throttled(nil)\n    return nil\n} else {\n    state = .resumed\n    if case let .throttled(value) = state {\n        return value\n    } else {\n        return nil\n    }\n}\n\n}\n```\n. Same as https://github.com/ReactiveCocoa/ReactiveSwift/pull/58/files#r82397528:\n``` swift\nlet eventToSend = state.modify { state -> Event? in\n    switch event {\n    case let .value(value):\n        switch state {\n        case .throttled:\n            state = .throttled(value)\n            return nil\n        case .resumed:\n            return event\n        case .terminated:\n            return nil\n        }\ncase .completed, .interrupted, .failed:\n    state = .terminated\n    return event\n}\n\n}\n```\n. > I ended up having a single return nil after the conditional block\n\ud83d\udc4d \n. You don't need to unwrap the bound value with ? since the return type is Value?: case .throttled(let value).\n. We should consistently place let right after the case: if case let .throttled(value).\n. Same as https://github.com/ReactiveCocoa/ReactiveSwift/pull/58/files#r82402862.\n. Could return the original event here?\n. Should this be reverted too?. Warnings can be silenced by using inhibit_all_warnings! in Podfile at users side, so I'm not confident if this is really needed.. I'd rather run swift build without the test dependencies so I added the env variable to swift test explicitly.. Hm only this doesn't work. \ud83e\udd14 . https://github.com/ReactiveCocoa/ReactiveSwift/pull/496#discussion_r129294400\nThis is not fully addressed yet.\nswift\nreturn flatMapError { error in\n        \u2026\n    }\n    .retry(upTo: count). Please indent the two lines above as well.. This should be just 4.0.. Oh overlooked that \ud83d\ude48. Addressed in 0a378cb. Could you please remove those white space changes?. You can use the initializer here: https://github.com/ReactiveCocoa/ReactiveSwift/blob/55ac251953f0d0fe0076d7b7a5b9a3c2b9c382bb/Sources/SignalProducer.swift#L156. The capture of the compiler error\n. The following overload will be used instead after this removal: https://github.com/ReactiveCocoa/ReactiveSwift/blob/7c25bc2e284ba54a8d81d3843a59cdd933c8f823/Sources/ValidatingProperty.swift#L128-L132. So what should be done here to avoid the compilation error instead of the removal? @andersio. Feel free pushing your changes on this branch.. NoError can be replaced by Never.\n\nhttps://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md\nhttps://github.com/apple/swift/pull/16857. I'll address that.. Fixed in 8bdcc81.. \n",
    "gkaimakas": "Cocoapods support? That's cool! Thanks!\n. @mdiep This is quite confusing. I have observed the same behaviour on MutableProperty. Shouldn't started fire after starting?. Would it make any sense to drop all the start / observe closures and only have a single start() / observe() function? \nThen the work of observing the events, values, errors etc could be done with the on operator.\nWhen I started using ReactiveCocoa I thought that that was the use of the on operator.\nSwift\nproducer\n    .on(value: { })\n    .on(error: { })\n    .on(result: { })\n    .start()\nseemed more appropriate at the time.. ",
    "zats": "Oh, thanks a lot @andersio and @ikesyo! Sorry for the beginner's questions \ud83d\ude42 \n. ",
    "robertjpayne": "@andersio  @ikesyo Is there any room for discussion on this? This is one area of ReactiveSwift that really is unfortunate and ends up bloating code and requiring a large amount of boilerplate. \nI'd argue most properties are going to be read-only by default outside of the owner.\nThis could be solved pretty easily using a struct type for Property rather than a class type, I did this previously in RAC but can no longer do it with ReactiveSwift because PropertyProtocol now forces classes.\nin RAC:\n```\nstruct Property: PropertyType {\nvar value: Value {\n    get {\n        return self.mutableProperty.value\n    }\n    set {\n        self.mutableProperty.value = newValue\n    }\n}\n\nprivate let mutableProperty: MutableProperty<Value>\n\ninit(_ value: Value) {\n    self.mutableProperty = MutableProperty(value)\n}\n\nvar producer: SignalProducer<Value, NoError> {\n    return self.mutableProperty.producer\n}\n\nvar signal: Signal<Value, NoError> {\n    return self.mutableProperty.signal\n}\n\n}\n```\nand then\nprivate(set) var name = Property<String>(\"Robert\")\nWas there a large amount of rationale around PropertyProtocol forcing classes now? I see the comment at the top of the file:\n\nOnly classes can conform to this protocol, because having a signal for changes over time implies the origin must have a unique identity.\n\nTo me this is enforcing an ideological barrier, there's an initialiser that takes a signal and thus you've already created API that breaks this theory that the source is unique?. EDIT: Ignore me, this is a pretty bad implementation. It's much easier to implement SchedulerProtocol for simple backgrounding via start(on:)\n@NachoSoto do you have any more info about why QueueScheduler's need to be serial? I quite frequently have \"background\" tasks and I just found out that a single QueueScheduler prevents any sort of concurrent execution.\nI'm working around this right now by creating a pool of QueueScheduler's and round robin the operators onto them.\nIt just seems less than ideal\u2026\n```\nextension QueueScheduler {\n    static var concurrent: QueueScheduler {\n        // a single QueueScheduler enforces serial FIFO execution of scheduled blocks. To allow for concurrent execution\n        // we instead use a pool of QueueSchedulers and rotate them as they are accessed\n        return self.concurrentSchedulers.modify { schedulers in\n            let scheduler = schedulers.removeFirst()\n            schedulers.append(scheduler)\n            return scheduler\n        }\n    }\nprivate static var concurrentSchedulers = Atomic<[QueueScheduler]>([\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\"),\n    QueueScheduler(qos: .default, name: \"concurrent\")\n])\n\n}\n``. Ah I see the extension and constraint forScopedDisposable()`. ",
    "mhuusko5": "Might today be release day for the new architecture/components? I have a couple projects building/working fine with ReactiveSwift/ObjC/Cocoa/ObjCBridge together comfortably, and would love to see even just some alpha tags (ReactiveSwift 1.0.0-alpha.1, ReactiveObjC 1.0.0-alpha.1, ReactiveCocoa 5.0.0-alpha.1, ReactiveObjCBridge 1.0.0-alpha.1?) pushed, if people are comfortable with that.\n. Good point!! That's not so good of an example for my compiler ambiguity concern then.\nNevertheless my concern still stands (and this is towards Swift 3 naming, not anything ReactiveSwift has done specifically/wrong) that is the while portion of the func skip(while condition: () -> Bool) is important (it is; it's what indicates you should be return true for skips, not false like a hypothetical skip(until:) func), then allowing for the use of .skip { .. } is counter to that API importance; it's unclear at the call site.\nReturning to skipWhile(_ condition: () -> Bool) would be the clearest, but probably (not sure the conventions had these cases in mind) against Swift 3 naming conventions.\nChanging to skip(while condition: () -> Bool, _: _ = true) on the other hand would only permit usage as .skip(while: { .. }). A personal preference, but I feel unlikely to garner support. \n. ",
    "chrisdhaan": "Any update when a tagged release may exist for this? Hoping to get the Reactive framework into a new project but need support for Swift 3.0\n. Awesome! Super excited! Love this framework.\n. ",
    "RuiAAPeres": "@mdiep awesome work! On the notes it reads:\n\nSignals complete when they have no observers and there are strong references to them\n\nShouldn't it be \"and there are no strong references\"\n. Ah I see, nevermind my comment. \n. Closing due to inactivity. If you are still interested in discussing this, please open a new Issue with your purpose (or a set of links with different approaches for the mechanism). . This is really interesting. Thanks @andersio. \u2764\ufe0f \n. Closing this due to inactivity. . @inamiy any progress on this? \ud83d\ude0a. It feels to me, I might be wrong, that an Action is normally used between the UI and the ViewModel and tied to an user action (most of the times a tap on a UIButton). . Love this PR and themap(forward:backward:) is just beautiful. Thanks @andersio. . When I think about the namePropertyEditor my mind goes like this:\neditor -> being able to be edited -> mutable -> MutableProperty?\nNot really keen on this one.. Because I am not a native english speaker, I am not too precious about this, but in any case:\n\nIn this case, PropertyEditor is a \"thing that makes edits to a property,\"\nThat would read like \"property that is able to be edited\" rather than \"editor of properties.\"\n\nI find these very similar. \nFrom this PR, I am able to get some context on the why this is called as it is. I am unsure a person who is used to Property and MutableProperty would.\n\nAppKit uses a similar naming to represent an editor in the NSEditor protocol. In the case of NSEditor, you can think of it as managing/reporting the editing state of the representedObject in a view controller, or the objectValue in a control.\n\nGood background. \ud83d\udc4d I think @andersio reasoning makes sense:\n\n+/// An editor that monitor, validates and commits changes to its root property.\n. LGTM. \ud83d\udc4d Great job as usual @andersio. \ud83d\ude0a. @liscio are you happy with the changes?. \ud83d\udc4d  . ping @NachoSoto \ud83d\ude1b . > observe is an established term of art since the ObjC days, so as start since 3.0. I don't think we'd ever gonna change them.\n\nThat's true, but on the other hand I liked these both:\nswift\nsignal.register(observer)\nsignal.subscribe(observer) \nThe with: label is probably a good mid ground. . I think this boils down to taste. I do like some well thought custom operators, although I am sure a lot of people don't. I am personally \ud83d\udc4d for this.. If no one opposes this PR, could we merge it? . Did a quick search, Rust seems to have it: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map. @NachoSoto \ud83d\udc4d. > (I personally feel race is a better name)\nflatten(.\ud83d\ude97). Could it be called simply .amb? From a discoverability point of view, it would be easier (searching for Functional Reactive Programming amb would yield the right sort of information). For people that already know the .amb operator the name would be fine as well.\n. Closing this due to inactivity. . Ah I see https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Property.swift#L535,\nmakes sense. Thanks @mdiep and @NachoSoto. \ud83d\udc4d. Closing this due to inactivity. . Why?. Closing this due to inactivity. @andersio you are free to make a PR with the once implementation that we are using in our codebase (at babylon health) . Closing this due to inactivity.. This is a great idea, although I would like to see the same arguments used when I proposed this (#201) and got shot down. :) ( cc  @NachoSoto and @liscio ). . tl;dr: Making another lib that leverages RAS underneath and implements the Promises A+ spec could be something I could do. \nHi @leonid-s-usov thank you for your input, we appreciate feedback regarding how users take advantage of ReactiveSwift and how we can enhance their experience while doing so. \nRegarding your specific use case:\n``swift\nrequest.then { map($0) }.then { consume($0) }.catch { ... }\n/// versus\n.flattenMap(.Latest /.Merge? .Concat?/) { map($0) }.startWithResult { ... }\n```\nIt's important to notice a couple of things:\n\nReactiveSwift already supports the then operator, which might make sense for your specific use case. \nCatch can be included as a convenient/sugar for a flatMapError. \nThe mention of Merge? and Concact? leads me to believe (apologies if this is not accurate), that you are unfamiliar which their use case and in what situation one would make more sense than the other. For what you are trying to achieve, the .latest would be the intended one. This could be extended, like catch into a convenience method of your own. \n\nAs for the general idea of Promises, I don't think the inclusion of .once would sort your problems. I do believe, on the other hand, that another repository/library could help you achieve that. I am ok on doing that, since I don't believe it's a lot of work.  \n. I think the way forward then would be open an issue here. Curious enough someone had a simillar idea https://github.com/RACCommunity/contributors/issues/8. > Now, I have no idea why you think that Async or any other Future-like construct needs to communicate whether it is warm or cold?\n\ud83d\udcaf . Need to spend some time on this, but my initial feeling is that I don't fully agree with this direction. \nI assumed the goal was to abstract a SignalProducer via another Layer (Promise). If you make it comply with the SignalProducerConvertible protocol, I don't see any advantage on this extra layer. . > It's strange that this simple compliance is changing your attitude. It's pure convenience.\nIn any case, one may always want to convert a \"OneShot\" entity to a SignalProducer, so why not manifest this with the \"Convertible\" interface?\nThe goal of having a Promise is to hide the apparent \"complexity\" of a SignalProducer/Signal behind an easy to digest API. From the moment you add SignalProducerConvertible, you are opening the pandora box, so the big advantage (simplicity) is lost. I fear I have completely misunderstood your intentions/ambitions/motivations with this new entity (which for the record, is completely fine). \nIt would be interesting to see how many people, besides you, would be interest in using it like that. I think this is a case of less is more and fundamentally why initially I was onboard on this new entity.\n. : UIViewController. Did you miss the inheritance on purpose? . Also, what is the reasoning behind making the ViewModel a class? (I am quite curious, since I struggled with this decision). On the description you explain it's equivalent to flatMap(.latest), but internally you are using race. Which one is true? . you mean downstream? . ",
    "justinmakaila": "\ud83d\udc4d I didn't realize how the separation from RAC to RAS happened; makes total sense. Thanks!\n. ",
    "SparrowBlaze": "It wouldn't build at all (got errors not warnings) when the submodules weren't there, so I put them in manually... I can confirm that the files are indeed there, and Xcode doesn't deny that, it just says it can't open them. Maybe I should just wipe it and go learn git...\n. Well, it works now. So much for a dedicated Frameworks folder for my other projects... heh\n. ",
    "pteasima": "Thanks for the answer. You are right that the registration flow here is weird (its still a prototype app, normally we would get back something like a token). However, this is not the first time I have encountered this problem. I generally dont like to do sideEffects in the producer returned from an action, and prefer doing this by binding against the .values or .events.map { //....\nMy general feeling is that if the producer \"wraps\" the action logic inside it, then there should be no more work done after the producer sends a terminating event (not even the internal \"send the same event on the action's observer\" work). However, I agree that its a breaking change which could cause trouble, so Im closing this.\n. ",
    "taquitos": "Yey! \n. I think that would prevent people from being able to specify like 0.250 seconds\n. True dat, I thought it was > 9, but it's actually > 2 that causes issues. Will update title.\n. yeah, great point. \n. I love the idea, I started working through what that would take, and we have a few options. If we deprecate this function, there are A LOT of places that will need further deprecations and significant changes as we roll out the newer API including DispatchTimeInterval instead of TimeInterval\nHow do you feel about keeping this change to milliseconds, deprecating this function, and then creating an issue to adjust all the other functions that rely on this now deprecated API? (I can add the deprecated attribute, and then we can merge this, so that when somebody has more time they can update the other functions)\n. ",
    "emojiface": "Hey, @ikesyo, thanks for the response. I'm trying to add ReactiveObjC and ReactiveObjCBridge using CocoaPods, is this supported, or would I need to clone ReactiveSwift, add the two submodules, and drag into Xcode manually?\n. ",
    "SethCody": "xcodebuild: WARNING: Unable to open project file '/Users/sethyin/\u6211\u7684\u5de5\u7a0b/HuiTing/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/sethyin/\u6211\u7684\u5de5\u7a0b/HuiTing/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.\n. ",
    "samidalouche": "using stream1.concat(...) with a SignalProducer will start the SignalProducer before the client actually gets to consume the stream1 entirely, which is useless in the context of backpressure (that can be used to implement paging of infinite resources in the case of a slow consumer)\n. Let's say that I have an HTTP API that provides a virtually unlimited amount of data through paging.\nThe basic use case is that I would like to provide a SignalProducer that will provide all the elements from the HTTP API. However, let's say that the consumer of the SignalProducer is much slower than the fetching of the HTTP API (and that it runs in a different scheduler). What will happen with ReactiveSwift is that an unbounded buffer of elements will accumulate until it exhausts all the memory.\nWhat I would love to see is any way in ReactiveSwift to circumvent this issue and make the producer as slow as the consumer. Does that make sense?\n. I don't feel comfortable enough with ReactiveSwift's codebase to put together a concrete proposal, but I can gather a summary of the different back pressure mechanisms used across the various reactive platforms so that it can serve as a a start for the discussions. \n. ",
    "lukaskubanek": "@andersio This is such a great idea!\n. ",
    "kAzec": "Oh, thanks, now I see.\n. Understood. And also under the following condition which may be more common:\nswift\nsignalProducer\n    .startWithSignal { signal, interrupter in\n        signal.observe { event in\n            // ...\n            interrupter.dispose()\n        }\n    }\n. ",
    "kaybutter": "The operator does express a direction though. The arrow tells you what goes where. The word \"bind\" doesn't really express a direction, even though the method probably won't setup a two-way binding. \ud83e\udd14\n. It should also be noted that in most cases the shorthands work better with Xcode's autocompletion. The .on(...) method autocompletes all the parameters even if I only need one or two and I then have to go and delete all the parameters I don't want. It's not a huge problem but then again I don't use .on as much as I use the start methods. \ud83e\udd14 . ",
    "inamiy": "Thanks for references.\nI still find the naming inconsistency in Observer.swift#L78-L104 (\"send\" should be followed by event name), but it might be an exception for argument label case.\nAnyway, this is too trivial issue to discuss, so I will close.\n. > \n\nswift\npipe.output.filterMap { $0 == .a ? Event.b : nil }.observe(pipe.input)\n\nNice example :) \nI also think this kind of data-flow should be accepted, i.e. let's use recursive lock.. ### FYI\n\nQueue-drain model without RecursiveLock: https://github.com/ReactiveCocoa/ReactiveSwift/pull/540\nIMO interesting approach, but impl is quite complicated so I still prefer simple RecursiveLock\n\n\nRxSwift impl: Rx.swift#L89-L122\nUses RecursiveLock\nfatalError with friendly message when #if DEBUG\nPrints warning message at console when non-DEBUG\n\n\n\nSince detecting cyclic dependency is hard in general and requires a lot of runtime test, I prefer the approach RxSwift is taking: prompt a message and use RecursiveLock.\nAnd IMO \"discouraged\" only works when the problem is predictable and preventable beforehand.\nBut as far as I see many unexpected deadlock examples here, I would say the problem is overall \"unpredictable\".\nAlso, without reentrancy, I think many other potential operators e.g. #308 retryWhen can't be implemented in ReactiveSwift (unless explicitly using scheduler to move on to async).. Also related: https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2949\n. Thanks for catch!\nIt seems reversing compositeDisposable += ... also works well (so that self producer's signal is safely interrupted before signal.on(...).observe(observer)'s disposable is being disposed.\nswift\n        return SignalProducer { observer, compositeDisposable in\n            // ...\n            self.startWithSignal { signal, disposable in\n                compositeDisposable += signal.on(...).observe(observer)\n                compositeDisposable += disposable\n. @andersio I see. Thanks for explanation. LGTM!\n. @sharplet \nButton with \"2 enabled flags\" can be a good example:\n```swift\nlet enabled1 = MutableProperty(true) \nlet enabled2 = MutableProperty(true) \nlet buttonTap: Signal<(), NoError> = ...\nbuttonTap\n    .sample(from: enabled1.producer)\n    .sample(from: enabled2.producer)  // this signal is Signal<((Void, Bool), Bool), NoError>\n    .filter { $0.1 && $1 }\n    .observe { _ in print(\"hello\") }  // prints only when both enabled1 & enabled2 are true\n```\nI think this is hard to implement if only existing sample(with:) is allowed to use.. @mdiep \nOh, your code works very nice \ud83d\ude05\nHow about asynchronously fetching 2 states, i.e. sample(with:).flatMap().sample(with:)?\n```swift\n/// Stores API response items.\nlet items = MutableProperty<[Item]>([])\nitems <~ buttonTap\n    .sample(from: urlTextField.reactive.text)\n    .map { APIRequest($1) }\n    .flatMap(.merge) { sendRequest($0) }\n    .sample(from: items.producer)\n    .map { $1 + [$0.item] }\nitems.signal\n    .observeValues { print(\"items updated: ($0)\") }\n``. Anyway, the dominant signal of above cases isbuttonTapwhich is what I mean bysourceSignal(triggering signal). Placing it at topmost of the data flow (receiver) is more readable.. @mdiep \nRenaming towithLatest(_:)is good to me too.\nIt's a cousin ofsample(with:)`, but not just a flipped version anymore.\nBy the way, your code has difficulty when items.value is updated elsewhere other than buttonTap.\nreduce causes unnecessary extra state inside.\n@sharplet\nSame here, scan is unnecessary internal state. \n(and Action is overkill for just achieving map { ($0, stateProperty.value) }). OK, it seems 2:2 now, but I can go for withLatest(from:) too.\nIf no other votes, I will rename it again later.\n(BTW, is travis dead? Test is not working...). Great! Renaming is done in 95bd754, and previous test has finally passed.. One example would be func timeout that can be re-implemented like this:\nswift\npublic func timeout(after interval: TimeInterval, raising error: Error, on scheduler: DateSchedulerProtocol) -> SignalProducer<Value, Error> {\n    return SignalProducer(values: [\n        self, \n        SignalProducer(error: error).delayError(interval, on: scheduler)\n    ]).flatten(.first)\n}\n// NOTE: `delayError` doesn't exist yet. @RuiAAPeres Not yet, but I will tackle on this soon :). I'm +1 for not exposing ended: Signal<(), NoError>.\nIt's hard to grasp from the type that only ended.observeCompleted { ... } will work.\nBut I don't get why disposable is needed as an argument of func attach.\nI think just plain () -> () is sufficient.\n(lifetime.observeEnded seems enough to take () -> (), and maybe attach is overkill)\nAlso, I don't think Observer(terminated:) is necessary because end only does sendCompleted.\n(Is there any chance of sendInterrupted or others?)\nP.S. I think Signal<Never, NoError> describes a bit better than Signal<(), NoError>.. @andersio \nAh, you are right. Lifetime may sendInterrupted.\nAnd with #143, I got the idea of func attach.. (Build failure seems unrelated)\nI also don't know what amb actually means, so I'm +1 for either .first or .race.\n.race is more descriptive (used in RxPHP?), but .first is also good name in contrast to .latest.. OK, I will rename to .race.. In 9630f9f, I had to fix .completed behavior because scenario like https://github.com/ReactiveCocoa/ReactiveSwift/issues/138#issuecomment-264353079 will complete immediately and this would be totally useless.\nTo fix that, I had to restore additional state var innerSignalComplete: Bool = true, and this flag basically checks the existence of at least one signal been started (doesn't care about value emission).\nNew .completed behavior of SignalProducer.flatten(.race)\n\nIf outer producer completes before any inner producer is created, complete immediately.\nIf outer producer completes after inner producer is created, complete after inner producer is completed.\nIf inner producer completes, complete after outer producer is completed.. Rebase done in 76d457e \ud83d\ude09  (but CI alive?)\n. I think MutableProperty should not conform to BindingTargetProtocol anymore because of new bindTarget(setter:) in this PR.\n\nIn addition, my rough local test proved that we don't need to use if let target = target as? BindingTarget<Target.Value> (which I found awkward) in func <~, i.e.\n``diff\ndiff --git Sources/UnidirectionalBinding.swift Sources/UnidirectionalBinding.swift\nindex 8cc005cd..c43fcff6 100644\n--- Sources/UnidirectionalBinding.swift\n+++ Sources/UnidirectionalBinding.swift\n@@ -91,19 +91,26 @@ public func <~\n    (target: Target, source: Source) -> Disposable?\n    where Source.Value == Target.Value, Source.Error == NoError\n {\n    // Alter the semantics ofBindingTargetto not require it to be retained.\n    // This is done here--and not in a separate function--so that all variants\n    // of<~` can get this behavior.\n    let observer: Observer\n-   if let target = target as? BindingTarget {\n-       observer = Observer(value: { [setter = target.setter] in setter($0) })\n-   } else {\n-       observer = Observer(value: { [weak target] in target?.consume($0) })\n-   }\n+   observer = Observer(value: { target.consume($0) }) // NOTE: strong capture!\nreturn source.observe(observer, during: target.lifetime)\n\n}\n ```\nAbove code will require users to call property.bindingTarget(setter: { $0.1 }) <~ producer instead of property <~ producer though.\n(Helper methods may solve this issue). LGTM! How about removing func consume and just use public let consume: (Value) -> Void?. @andersio\nFrom your comment (with analogy to Observer.action), I found interesting that Observer can also conform to BindingTargetProvider with an infinite lifetime given.\nMaybe wanna try this idea in this PR or next?\nAnd with above taken into consideration, I thought func send(value:) could be another option.\nBut, I also think action is OK.. @andersio Hm, maybe it was too much unnecessary abstraction \ud83d\ude36. FlattenStrategy_concurrent__should_asynchronously_merge_up_to_the_stated_limit__buffer_any_subsequent_producers_and_dequeue_them_in_the_submission_order, expected to equal <[0, 1, 2, 3]>, got <[0]>\nCI error seems unrelated to this PR.. @mdiep \nUse cases will be:\n1. Delaying retry (as I just showed example on top comment)\n2. Conditional retry based on error (e.g. retry only when error has status code XXX...)\n\nI don't think this needs to take a flatten strategy\n\nSounds simpler! I will just use .merge then \ud83d\ude09 \nIf we go with (1), I also need error counting to stop retrying forever, so below code might be better: \n```swift\npublic func retry(upTo count: Int, when: @escaping (Error) -> SignalProducer<(), Error>) -> SignalProducer {\n    precondition(count >= 0)\nif count == 0 {\n    return producer\n} else {\n    return flatMapError { error in\n        return when(error).flatMap(.merge) {\n            return self.producer.retry(upTo: count - 1, when: when)\n        }\n    }\n}\n\n}\n```\n. @mdiep \nAdding variants sounds friendly, but for exponential backoff, I guess it will require additional state inside which will make (1)'s implementation more complicated.\nOn the other hand, if we go with (2), we can use scan to count errors and handle exponential delay calculation (and probably many more).\nSo... Though I wasn't aware of (2)'s powerfulness on the first place, I'm leaning toward (2) now \ud83e\udd14 . Updated the code to track current master branch.\nSignature became simpler as follows, but still, PthreadLock(recursive: true) is required to avoid the crash in test cases.\nswift\nfunc retry(when: ((Signal<Error, NoError>) -> Signal<(), Error>) -> SignalProducer<Value, Error>. Sorry, actually this is not race but rather FlattenStrategy.first a.k.a. flatMapFirst.. Right, case throttle sounds better name \ud83d\ude04. @mdiep\nInteresting!\nSince static let concat = FlattenStrategy(kind: .concurrent(limit: 1)), it should probably be improved like this:\nswift\npublic static func concurrent(limit: UInt, queueCount: UInt) -> FlattenStrategy\nso that more flexible flattening e.g. limit = 10 && queueCount = 5 will be possible (though I don't know who will ever use this!).. @andersio \nThanks! Updated doc in 1058068.. ### Alternative names to consider\n\n\nmapAccumulate / accumulate\n\noriginally from mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)\n\n\n\ntraverse \n\noriginally from traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\n\n\n\nmealy\n\noriginally from Mealy Machine, or Data.Machine.Mealy unfoldMealy has similarity. I personally like scanMap too \ud83d\udc4d \nI want to hear more opinions on this before renaming.. > Can we also see if scan can be implemented with this operator by composing the transform?\n\n\n\nDone in 6bca910 !\nAlso renamed the method to scanMap in 6a465c3 .\nNow two methods look more close to each other.\n. In my case, I want to map video stream's metadata to also emit ExtraFlag based on first \"playing metadata\" + that might get reset via metadata = nil:\n```swift\ntypealias State = Metadata? // PlayingMetadata\ntypealias ExtraFlag = Bool\nlet upstream: Signal = ...\nlet downstream: Signal<(Metadata, ExtraFlag)?, NoError> =\n    upstream.scanMap(nil) { (state: State?, metadata: Metadata?) -> (State?, (Metadata, ExtraFlag)?) in\n    guard let metadata = metadata else {\n        // `metadata = nil` as resetting state\n        return (nil /* reset state */ , nil /* no metadata nor extra flag */ )\n    }\n\n    guard let state = state else {\n        // 1st `metadata` as `state` if `metadata.isPlaying`, otherwise don't store state & send\n        return metadata.isPlaying ? (metadata, (metadata, false)) : (nil, nil)\n    }\n\n    // Non-first `metadata` comes here\n    switch state {\n        case .playingMetadata1:\n            return (state /* no change */, (metadata, false))\n        case .playingMetadata2:\n            return (state /* no change */,  (metadata, true)) // special flag attached\n    }\n\n}\n\n```\nIn this complicated scenario, state is often tweaked via upstream's value, but emits different output than Metadata? that depends on internal state.\nP.S.\nBTW, you can rewrite scanMap with scan, but State becomes messy and not efficient:\n```swift\n// RxSwift example\npublic func scanMap(\n    into initial: State,\n    _ f: @escaping (inout State, E) -> Output\n    ) -> Observable {\nreturn self\n    .scan(into: (initial, Optional<Output>.none), accumulator: { tuple, element in\n        let output = f(&tuple.0, element)\n        tuple.1 = output\n    })\n    .flatMap { tuple -> Observable<Output> in\n        if let output = tuple.1 {\n            return .just(output)\n        } else {\n            return .empty()\n        }\n    }\n\n}\n```. ff3851a https://travis-ci.org/ReactiveCocoa/ReactiveSwift/builds/469555480\nCI build error seems unrelated.. > I'd expect an operator to hold just the minimal viable state for doing its business.\nYes! This is the whole goal of making this simplest API by clearly separating the incoming value, internal state, and outgoing value.\nTo simplify more, this discussion is no more than:\nswift\n.scan((state, nil)) { /* complicated code because of caching output */ }\n.filterMap { $0.1 }\n// or any caching operator + flatMap\nV.S.\nswift\n.scanMap(state) { /* simpler code */ }\nas mentioned earlier, and it's verbose to implement the former code.\nThough readability might degrade a little by using this operator only, I think it is much better than caching ~~unused value~~ value that doesn't need to be. . Updated to track current master branch.\n@andersio Can you review this PR?. I'm still wondering if .first is really a proper term to use for this operator since it makes us confuse a lot with .race and also SignalProducer.first.\nAny thoughts on this?. This PR is ready to review, but requires write permission to move on (\"Ready for review\" button doesn't appear in my screen):\nhttps://github.blog/changelog/2019-03-08-expand-ready-for-review-permissions-for-draft-pull-requests/. To achieve the simplest map { ($0, stateProperty.value) } alternative as possible, I think returning signal should not get interfered with any of samplee's terminal events.\nsample(with:), on the other hand, will wait for both sampler and samplee's .completed to finally emit its .completed, so this PR is not just a flipped sample(with:).\nFor comparison, in RxSwift, samplee's .completed is ignored but .failed is forwarded.\n(As a side note, I have restricted samplee's error type as NoError only for now, allowing a future extension to also support samplee with non-NoError types when decision (ignore or forward error) is settled.). We already have mixed operators like:\n- combineLatest<U>(with other: SignalProducer<U, Error>)\n- combineLatest<U>(with other: Signal<U, Error>)\n- flatMap<U>(Value -> SignalProducer<U, Error>)\n- flatMap<U>(Value -> Signal<U, Error>)\nI think there are also needs for withLatest(signal) case too.. Is it illegal to have different type for the argument? \nI think hot -> T -> hot or cold -> T -> cold keeps the same structure, and it's good enough. \n(This is probably the \"endofunctor\" thing in category theory after the partial application of T, though arguments are often flipped in Swift.). I prefer withLatest(_:) because \"with\" sounds like a small addition to the main stream, and receiver remains as the first class that also implies the rank direction. \nMaybe withLatest(from:) can be a compromise, but I think we don't need this \"from\".. Fixed in 9580123.. Updated comments in cf6c4eb.. Updated comments in cf6c4eb.. Thanks for this catch! I could remove this redundant flag now in 819550f.. I haven't written the test yet, but I think the result should be the same as:\nit(\"should complete when the outer signal completes before sending any signals\").\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/233/files#diff-9cd786f9e52e786771d96cf8c42d3befR1481\nNew test will be: it(\"should complete when the outer signal completes before inner signals send any event\").. (I will also update ambiguous test titles too). Done in 1b83292.. Done in 1b83292.. Done in cbca7339.. Done in cbca7339.. Done in cbca7339.. ",
    "tuzaiz": "Thanks for @andersio answer, but how could I fix the code like this?\nDynamicProperty(object: nameLabel, keyPath: \"text\") <~ viewModel.name.producer\n. Yeah~ it works. Thank you!! One more question please.\nHow could I bind text value of textField to property?\nI tried this but it shows Ambiguous reference to member 'textValues'\nself.viewModel.title <~ self.titleField.reactive.textValues\n. Thank you @andersio , you're really a lifesaver. And sorry, I don't really realize the diff between ReactiveSwift and ReactiveCocoa, now I understand much more. :)\n. ",
    "codyrobb": "After setting a breakpoint on _NSLockError(), it looks like it is line 66 in Signal.swift causing the lock and eventual breakdown.\nThis is one of my first bigger stabs at RAC4 after coming from RAC2.X. I might be misusing some things. Please let me know!\n. Another note: I am using ReactiveCocoa 4.2.2, but this seemed to be a better place to post the issue as it appeared you guys were trying to get the Swift API oriented issues over here.\nIf I need to move this just let me know.\n. Hmmm... interesting.... The root of the problem appears to be this code:\nswift\n        viewModel.undoEnabled.producer.startWithNext { [unowned self] enabled in\n            if enabled {\n                self.viewModel.undoCurrentAction()\n            }\n        }\nIf I do this:\nswift\nviewModel.undoEnabled.producer.startWithNext { [unowned self] enabled in\n    if enabled {\n        // undoPressed simply calls viewModel.undoCurrentAction()\n        self.navigationItem.rightBarButtonItem =\n            UIBarButtonItem(title: \"UNDO\", style: .Plain, target: self, action: #selector(self.undoPressed))\n    } else {\n        self.navigationItem.rightBarButtonItem = nil\n    }\n}\nEverything works fine. Can anyone elaborate on this? \n. ",
    "chuganzy": "This is just a simple example (actually leaking), but as you can see it is not infinite loop, so I feel it makes more sense to make Lock recursive.\n```swift\nenum Event {\n    case a\n    case b\n}\nlet pipe = Signal.pipe()\npipe.output.filterMap { $0 == .a ? Event.b : nil }.observe(pipe.input)\npipe.output.observeValues { event in\n    print(\"value: (event)\")\n}\npipe.input.send(value: .a) // deadlock\n```\nWhat do you think? @andersio @mdiep \nRelated PR that makes Lock recursive https://github.com/ReactiveCocoa/ReactiveSwift/pull/308\nEspecially when we use RAS with RAC, all events are pretty much UI driven, and sometimes UIKit causes this case unexpectedly.. Let me give you more concrete example:\n```swift\nclass View {\n    enum Event {\n        case textChanged(text: String)\n        case buttonPressed\n    }\n    private let eventIO = Signal.pipe() // or view model\n    private let textField = UITextField()\n    private let button = UIButton()\nprivate func bind() {\n    textField.reactive.continuousTextValues\n        .map { Event.textChanged(text: $0) }\n        .observe(eventIO.input)\n    button.reactive.controlEvents(.touchUpInside)\n        .map { _ in Event.buttonPressed }\n        .observe(eventIO.input)\n}\n\nfunc observe(action: @escaping (Event) -> Void) {\n    eventIO.output.observeValues {\n        action($0)\n    }\n}\n\n}\nclass ViewController {\n    let someView = View()\nprivate func bind() {\n    someView.observe { [weak self] event in\n        switch event {\n            case .textChanged(let text): \n                // do something\n            case .buttonPressed:\n                // do something that eventually invoke below\n                self?.view.endEditing(false)\n        }\n    }\n}\n\n}\n```\nWhen it invokes self?.view.endEditing(false) (or just call textField.resignFirstResponder()) UIKit sometimes sends UITextView.textDidChangeNotification (custom keyboard is related I am assuming) so continuousTextValues sends new value, and that ends up with deadlock. This kind of things can easily happen (ex: Apple changes the event cycle) and it's too risky to make it deadlock and forcing app to crash.\nI do understand pipe.output.filterMap { $0 == .a ? Event.b : nil }.observe(pipe.input) kind of cases should be discouraged though, it actually happens in UI world easily (and sometimes unexpectedly), and I do not see the reason to force them to crash while it works.\nWhat do you think?. @mdiep @andersio Can we start from reopening this issue? We might be able to gather more opinions.. Agree with this change. Ref: https://github.com/ReactiveCocoa/ReactiveSwift/issues/74#issuecomment-472686906. ",
    "dcaunt": "Yes, it would make sense to update the playground instructions to match the README, which changed in 745d6d498f8bda9a3ccb0dd896bd40f99f74407d\n. Do you think there is any value in adding some or all of the content in this file to the playground?. fromJSONString\n. dependency -> dependencies ?\n. dependency -> dependencies ?\n. declaractive -> declarative and fundementally -> fundamentally\n. ",
    "Qata": "@liscio We get around the misuse by decoupling the input and output into separate types. This allows us to model things in a cleaner way (a consumer that only needs to subscribe to the output can be passed solely the output, for example).\nBy changing the API to bring back Subject, we'd be recoupling the input/output and robbing ourselves of the control we have now.. @andersio @NachoSoto Considering how old this is, might be time to close it?. ping @NachoSoto \ud83c\udf8a. observe(with:) seems clearer to me as well. @andersio Would it be welcome if I picked up this issue and created an implementation?. @andersio This can now be closed. I'm a fan of this addition, the app I most use ReactiveSwift with has a lot of cases that'd benefit from this readability. \nI've had to do a workshop to explain why all of our single value streams use .latest.. @minuscorp take(until: signal.then(.empty)). Solves #287 . @ikesyo is this API breaking? The default parameter should just make it additive. . @andersio Comments addressed. @andersio Comments have been addressed.. I didn't because there isn't any current conformance tests at all, but I can.. @NachoSoto Tests added.. @NachoSoto Amended tests to address comments.. @andersio Amended. Ah that looks quite different though. You could actually implement that function with this one and flatMap I think. . @mdiep Issues addressed \ud83d\udc4d . @andersio Could you have a look when you have time. @andersio Done \ud83d\udc4d . +1, failing with arbitrary data structures would be more helpful in a lot of circumstances.. Will do, but perhaps that should now be deprecated in favour of using the protocol?. Done \ud83d\udc4d . Well technically I'm testing SignalProducer.init(_ base:) as well but I can call it Result.producer.. Oh yep I forgot to say that bikeshedding the name is very welcome, I have no attachments to the one I chose. . Good point!. So in the case of .interrupted and .failed it should send the values immediately followed immediately by the events? Or should it discard anyway and we rename the parameter to discardsWhenCompleted?. After looking into this I can't find a way to make it work consistently, given:\nWhen you complete the Signal when you'd expect is for it to still delay up to the supplied interval, and only then deliver the values followed immediately by a completed event. \nIn the event of interrupted or failed, you'd need to forward those events immediately, so the values would also need to be delivered immediately. \nThis would probably create tricky behaviour for a lot of people consuming this function, since you'd expect values to be delivered exactly interval apart (or a multiple of interval if you're ignoring when empty).\nSo should it only not discard in the case of .completed?. I feel like that gives the implication that it will always discard something. Might be worth bikeshedding.. @mdiep Done \ud83d\udc4d . @mdiep Should I call d.dispose() manually here?. ",
    "mfclarke": "I knew there was a nice way to do it. Thanks @andersio\n. Actually, unfortunately neither solution works (the first one or the updated one). To check it, I'm doing this (with DataFetcher being a mock that takes 1 second to return dummy data):\n```\nlet lazyWithCacheExpiry = SignalProducer(value: DataFetcher.fetch())\n    .delay(1.0, on: QueueScheduler.main)\n    .times(Int.max)\n    .flatten(.latest)\n    .replayLazily(upTo: 1)\nprint(\"Starting producer 3 times - all 3 logs should happen once after 1s\")\nlazyWithCacheExpiry.startWithValues { data in\n    print(\"1st returned: (data)\")\n}\nlazyWithCacheExpiry.startWithValues { data in\n    print(\"2nd returned: (data)\")\n}\nlazyWithCacheExpiry.startWithValues { data in\n    print(\"3rd returned: (data)\")\n}\nDispatchQueue.main.asyncAfter(deadline: .now() + 10) {\n    print(\"-------------\")\n    print(\"Get data after cache expiry - should do second fetch\")\n    lazyWithCacheExpiry.startWithValues { data in\n        print(\"Returned: (data)\")\n    }\n}\n```\nI also have a print in my mock fetcher to verify it only fetches once.\nI get this output:\nStarting producer 3 times\nThen this repeats a random number of times, from DataFetcher.fetch (from 2 to ~10):\nPerforming fetch\nEventually we get:\n1st returned: [\"a\": 1]\n2nd returned: [\"a\": 1]\n3rd returned: [\"a\": 1]\nWhich will then repeat every 1s.\nAlways 10s after running this appears:\n```\nGet data after cache expiry - should do second fetch\n```\nImmediately followed by:\nReturned: [\"a\": 1]\nWhat I think I need after considering your approach is 2 producers. One doing the work with replayLazily assigned to one var and another that is started when the owner object is created which replaces the replayLazily producer every n seconds using delay and times. The downside to this approach though is if the replayLazily var is used in another context, for example with a .on. This will never get replaced, since it's already been copied.\n. Ahh I see. That would be kind of cool to have a replayLazily(upTo:timeout:). I'd be more than happy to code it up if it's something you guys would like to have? I might need a little bit of hand holding because I haven't been using RAC that long, but would love to have a shot at it!\nHere's where I've landed with the issue though:\n```\nclass DataProvider {\nvar producer = DataProvider.buildProducer()\nprivate var replacerDisposable: Disposable?\n\ninit(withExpiryInterval expiryInterval: TimeInterval) {\n    replacerDisposable = QueueScheduler.main.schedule(after: Date(), interval: expiryInterval) { [weak self] in\n        self?.producer = DataProvider.buildProducer()\n    }\n}\n\nprivate static func buildProducer() -> SignalProducer<MyData, MyFetchError> {\n    return DataFetcher.fetch().replayLazily(upTo: 1)\n}\n\n}\n```\nIt's neat enough for my purposes, and doesn't leak state so that's a plus.\n. Thanks @andersio and @mdiep, this is much clearer now \ud83d\udc4d . Unfortunately this issue persists with Xcode 9.2. The cause now is code coverage being enabled on the framework scheme's test action \ud83d\ude2e\nA workaround is to create and share a dedicated tests scheme with coverage enabled, so the framework scheme can have this option disabled.\nThough a real solution might be to somehow override this setting in the scheme while running libtool. More of an issue for the Carthage repo perhaps?. @andersio good point, I can definitely see that being a problem.\n@mdiep yes, it's highly likely that this isn't totally correct! The code above works well enough for my specific use case, but hasn't been fleshed out and tested for general use yet.\nI also couldn't find anything in Rx when I was searching for something like this. \nPerhaps I generalised too quickly on this one? It works great for single network requests per scan. I added in a flag to skip accumulator repeats, to avoid the closure being called before the accumulator has updated.\nI'll bet there's a better way to do this, though it doesn't come to mind at the moment.. Just a thought: modifying the accumulator to be an array of values will help to alleviate some of these issues:\n```\nfunc flatScan(_ strategy: FlattenStrategy, initialResult: U, nextPartialResult: @escaping ([U], Value) -> SignalProducer) -> Signal {\n  var accumulator = [initialResult]\nreturn self\n      .map { (accumulator, $0) }\n      .flatMap(strategy) { nextPartialResult($0, $1) }\n      .on(value: { accumulator += [$0] })\n}\n```\nThen it's the responsibility of the caller to determine what values to keep, throw away, sum etc.. ",
    "dmcrodrigues": "Action is a concept super useful and powerful to me especially, when used at UI layer.\n\nBut this does require (1) removing the input type from Action and (2) removing the input parameter from apply(). (2) could be especially problematic, depending on how people are currently using Action. But in the standard bind-this-action-to-a-button case, this model seems like it would be simpler.\n\n@mdiep I like how your proposal aims for immutability which is definitely a good thing. Unfortunately, personally speaking about my use of actions, I have a few cases where the input is dynamic, e.g. according to the value of a UISwitch, and others where my enabledIf property is not related at all with my input. \nBut doing a more philosophical analysis, can we really avoid this kind of bad usage? I mean, this definetly makes it more harder but it's still possible to ignore the input and access a shared state while defining the executing block (which can be the body of a SignalProducer).\nBut I'm still reflecting about this, it's definitely not an easy one.\n. For this kind of use cases I think a Action+CocoaAction approach its the best option because it handles both validation and execution of the task.\n``` swift\nlet textFieldUsernameSignal = textFieldUserName.reactive.continuousTextValues\nlet textFieldPasswordSignal = textFieldPassword.reactive.continuousTextValues\nlet validator = Signal.combineLatest(textFieldUsernameSignal, textFieldPasswordSignal)\n    .map { username, password in\n        return username?.characters.count ?? 0 > 0 && password?.characters.count ?? 0 > 0\n}\nlet enabledIf = Property(initial: false, then: validator)\nlet action = Action<(String?, String?), Void, NoError>(enabledIf: enabledIf) { username, password in\n    // Return a signal producer to perform the side effect...\n}\nnavigationItem.rightBarButtonItem.reactive.pressed = CocoaAction(action, input: (textFieldUserName.text, textFieldPassword.text))\n```\n. @NachoSoto this was discussed on Slack today and I opened a PR to discuss what should we do.. I thought about that and it's definitely another option but with some quirks.\n\nClosure parameter prior to parameters with default arguments will not be treated as a trailing closure\n\nA warning is raised as expected but can we ignore it?\n\nDespite of having a default value, Xcode will ask us a value for our (unnamed) last parameter which I think is far from desirable and can introduce some confusion about the why and what it really means.. Regarding uncollect an almost equivalent is flatten available in ReactiveSwift for both Signal and SignalProducer. However, there's a constraint about the error type, Error == NoError, which is not defined on uncollect and removing it leads to an Ambiguous use of 'flatMap(:transform:)' which kind of makes sense since there are two versions of flatMap to accommodate both Error and NoError. I don't know if this was the reason behind this constraint but I don't see a reason to restrict this operator only for signals without errors.\nAlso, since we are talking about flatten as an alternative to uncollect, I'm having some difficulty to understand how relevant a strategy is to flatten a sequence, between picking latest, merge, or concat there's any difference?. @andersio If that's the case, maybe we can remove the strategy from flatten when the value is a Sequence? Introduces unnecessary confusion around the usage of the operator and can be misleading.. @ynnckcmprnl as a side note, by usingSignalProducer(values: appointments) you can avoid uncollect, internally the producer will flatten your sequence by emitting each element.. > UIScheduler really is UI-specific\nThat's exactly my main concern, why should we have anything UI-specific here? ReactiveSwift should be all about streams of values over time and leave anything UI-specific for other projects like we have in ReactiveCocoa. \n\nLet's take GTK+ as an example, it still has a \"main thread\" requirement.\n\nEven considering this I don't know if we can assume the same policies of iOS and macOS apply to GTK+ so I'm not sure we can reuse UIScheduler on Linux and even if we can that does not seem a strong reason to have something UI-specific in ReactiveSwift at least from my point of view.. > I don't think ReactiveSwift needs to exclude anything UI-related.\nI disagree mainly because UI is almost entirely platform-specific and many projects do not have any kind of interface, e.g. frameworks, command line tools like Carthage for example, so this kind of scheduler will not only be redundant for many but may also introduce unnecessary confusion.\n\nReactiveSwift shouldn't have anything that's platform-specific.\n\nAnd in the end, that's exactly what UIScheduler is because is tightly coupled to iOS and macOS even without referring to UIKit and AppKit, main queue is the main thread on these platforms but that does not necessarily apply to others.. Because NOT is implemented as a function, you can pass it directly: self.map(!). ",
    "erichoracek": "We use the RAC2 equivalent of Action (RACCommand) extensively in our ReactiveObjC codebase, so I think I can speak to our usage of RACCommand's enabled property and how we tend to use it in practice.\nIn cases where an Action's enabled-ness depends exclusively on its inputs, a pattern like the proposed makes total sense. We have definitely been frustrated by the fact that the state that changes the enabled-ness of an Action is not read at the same time that the apply() closure of the action is invoked (and thus can introduce inconsistencies).\nHowever, this use is not the only way that we use Action. In our codebase, approximately 2 of every 3 Actions use input values. As a specific example from our codebase, say that we have an Action that presents a modal when apply() is invoked. The action has the following signature:\nswift\nAction<Bool, ModalViewModel>\nWhere the input Bool value is whether or not the presentation is animated, and the apply SignalProducer sends values of type ModalViewModel for the view model backing the presentation. Additionally, this Action is enabled when the presentation can occur, and disabled for the entirety of the presentation (until the modal is dismissed).\nIn this case, if the input type was removed, there would be no way for a consumer (such as a button) to indicate whether or not the presentation would be animated. Additionally, the enabled-ness of this Action does not depend on its inputs, which (as far as I can tell) is incompatible with the proposed changes to action.\nFollowing from the above, perhaps this behavior could be built in a way where it is available as an option when creating Actions, but is not the only way to work with them (somewhat like #22). Throwing out the ability for Action to have an InputType would (in my mind) be a much greater loss than the current frustration of having to deal with enabled-ness of Actions not necessarily being in sync with invocations of apply().\n. Sure\u2014the Bool value can come from a number of places:\n- The UIViewController that consumes the view model can decide to perform an animated presentation, and executes the Action with true (in the case of a cell or button being tapped)\n- Within the view model itself, if a presentation is triggered as a side-effect of another action.\n- A consumer of the view model that wants to perform a presentation non-animatedly (in the case of a deep link that synchronously creates a stack of presented modals at launch-time)\n. ",
    "guidomb": "Well actually I have a few. The project I am working on requires a lot of communication with external devices over Bluetooth. There are several async processes that must be triggered sequentially. In some case you have to wait for x amount of time between two steps. In those cases I've been using deferred. What is your main concern about adding such a method? \n. The reason I didn''t use delay is that there are side effects that need to happen after x amount of time and those side effects are executed when the producer is started. As far as I know delay delays events but starts the producer right away. Am I correct?\n. ",
    "calebd": "Oh cool I totally missed that. Thanks!\n. Not sure what you mean. This pr is the result of running git merge 1.1.3 on while master.. Sounds good to me.. ",
    "emuye": "@andersio Thanks for responding so quicky. Can you show me the code for seeing the reference go to nil after completion?\n. ",
    "cloutiertyler": "Specifically I am confused about is this. Each signal maintains a reference to itself via its SignalState if there is at least one observer added to the signal. So basically if I had a function like:\n``` swift\nfunc f() {\n    let (signal, observer) = Signal.pipe()\n    signal.observeNext { next in print(next) }\nobserver.sendNext(\"a\")\n\n}\nf()\n```\nwouldn't I be leaking signal after calling f, since it has a reference to its itself?\n. Could you point me to where the Signal is released when a terminating event is sent through? It would have to break this retain cycle, right?\n. Ah I see, that's a neat trick. I would still have the leak in the above example though since no interrupt, nor other terminating signal, was sent, correct?\n. Oh, awesome, thanks for the link! That's very helpful. I'm not sure there is any other way to do it really. I have been playing around with making this to get a better understanding of FRP and ReactiveCocoa and to play around with different possible APIs. I ended up with basically the same solution although it looks slightly different and mine will definitely leak if there is no terminating event even if there are no observers on the signal. You can see what I did here.\n. Actually I lied, it's not quite the same. In the case above, with my implementation the Signal would be properly deallocated since I don't care whether or not there are any observers on the Signal. Since no one holds a reference to input observer after f(), and the input observer holds the only strong reference to the Signal, there is no cycle and the Signal will be dealloc'd. Not sure of the full ramifications of a design like this are, but in this specific case something like it wouldn't leak.\n. ",
    "gbrhaz": "@andersio  What is ReplayCacheInvalidation and how does it invalidate the cache on failures?. ",
    "Arcanfel": "Alright, I gave it a couple more shots and this is what I came up with:\n```\n// bind view model to UI first\ntextFieldUserName.reactive.text <~ viewModel.username\ntextFieldPassword.reactive.text <~ viewModel.password\n// bind UI to view model\nviewModel.username <~ textFieldUserName.reactive.continuousTextValues\n    .map { $0!.trimmingCharacters(in: .whitespacesAndNewlines) }\nviewModel.password <~ textFieldPassword.reactive.continuousTextValues\n    .map { $0!.trimmingCharacters(in: .whitespacesAndNewlines) }\nnavigationItem.rightBarButtonItem?.isEnabled = false\nnavigationItem.rightBarButtonItem!.reactive.isEnabled <~ Property.combineLatest(viewModel.username, viewModel.password)\n    .map { !$0.isEmpty && !$1.isEmpty }.signal.observe(on: UIScheduler())\n```\nThe only problem appears in making a signal work with rightBarButtonItem. When ViewController shows up on screen, .map { !$0.isEmpty && !$1.isEmpty } is getting called and the result is false (which is correct), but the button remains active anyway. Entering values in textfields yields expected behaviour. \n. ",
    "EvilNOP": "@dmcrodrigues \nDid you notice that:\nswift\n/// Initialize a CocoaAction that invokes the given Action with the given\n/// constant.\n///\n/// - parameters:\n///   - action: The Action.\n///   - input: The constant value as the input to the action.\npublic convenience init<Input, Output, Error>(_ action: Action<Input, Output, Error>, input: Input) {\n    self.init(action, { _ in input })\n}\nThe input of the CocoaAction is constant, so your following code:\nswift\nnavigationItem.rightBarButtonItem.reactive.pressed = CocoaAction(action, input: (textFieldUserName.text, textFieldPassword.text))\nwon't work, cuz textFieldUserName.text and textFieldPassword.text would both be empty string at first which means:\n```swift\nlet action = Action<(String?, String?), Void, NoError>(enabledIf: enabledIf) {\n    username, password in\n}\n```\nusername and password also empty.. @andersio Cool stuff!. swift\n/// Initializes an action that will be conditionally enabled, and creates a\n/// SignalProducer for each input.\n///\n/// - parameters:\n///   - enabledIf: Boolean property that shows whether the action is\n///                enabled.\n///   - execute: A closure that returns the signal producer returned by\n///              calling `apply(Input)` on the action.\npublic init<P: PropertyProtocol>(enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer<Output, Error>) where P.Value == Bool\nQ1: A closure that returns the signal producer returned by calling apply(Input) on the action, what does it mean? Should I call the apply method? And in what kink of condition call the apply?\nQ2: What kind of SignalProducer should I return?\nLet's say that there's two text fields (one for username, the other for password), and a sign in button.\nWhen the user clicked sign in button which will do some checking, then , return a Bool indicate that whether successfully sign in.\nI've already typing some code:\n```swift\nlet signUpActiveSignal = Signal.combineLatest(validUsernameSignal, validPasswordSignal).map {\n    (isValidUsername, isValidPassword) in\n return isValidUsername && isValidPassword\n\n}\nlet signInButtonEnabledProperty = Property(initial: false, then: signUpActiveSignal)\nlet action = Action<(String, String), Bool, NoError>(enabledIf: signInButtonEnabledProperty) {\n    (username, password) in\nreturn ?\n\n}\nsignInButton.reactive.pressed = CocoaAction(action) {\n    _ in\n(self.usernameTextField.text!, self.passwordTextField.text!)\n\n}\n```\nCould somebody help me fix the blank in Action initialization?. So now I have this:\n```swift\nlet action = Action<(String, String), Bool, NoError>(enabledIf: signInButtonEnabledProperty) {\n    (username, password) in\nreturn SignalProducer<Bool, NoError> { observer, disposable in\n    observer.send(value: authManager.isValid(username, password))\n    observer.sendCompleted()\n}\n\n}\n```\nHow do I know whether the user sign in successfully?\nIt's that?\n```swift\naction.values.observeValues {\n    success in\nif success {\n    print(\"Successfully sign in.\")\n\n}\n```. thx\ud83d\ude04\ud83d\ude04\nOn Sat, 26 Nov 2016 at 11:11 PM Anders Ha notifications@github.com wrote:\n\nYeah.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/ReactiveCocoa/ReactiveSwift/issues/99#issuecomment-263068324,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ARRq5A3YwMXdiDrhkPNT1bgYfRDkPpENks5rCEw0gaJpZM4K06hc\n.\n. \n",
    "idelfonsog2": "\ntextFieldPassword.reactive.text <~ viewModel.password\nviewModel.password <~ textFieldPassword.reactive.text\n\nwhat is exactly happening here? What's the type of viewModel.password?. ",
    "iv-mexx": "\nIt seems natural to host them in ReactiveSwift. Perhaps we could turn them into links in ReactiveCocoa, hmm?\n\nI agree that the documentation for things implemented in ReactiveSwift should be hosted in ReactiveSwift. \nOn that note, I've just noticed that DynamicProperty is not in ReactiveSwift but in ReactiveCocoa, so I removed the mention from the FrameworkOverview.\nStill not sure if the Documentation in ReactiveCocoa should just link back to ReactiveSwift or be complete, maybe I'll just try both and see how it feels.... Alright, @mdiep I've addressed your comments. Thanks! I'll probably look into the documentation some more soon. @andersio So, for Event, Property, and Scheduler, its still correct to refer to them as ...Protocol, right?. Alright, I've change that for Event as well (to just say Event). Hm, which operators do you have in mind?\nAppart from that, I've just seen seen this line from the introduction again: \n\nThis document will use the term \u201cevent stream\u201d when dealing with concepts that\napply to both Signal and SignalProducer.\n\nIt seems that this is not consistently followed in the document, I'll take another look at it.. > Should we group the producer specific operators together?\nNow that \"event stream\" is used for every operator that applies to Signal as well as SignalProducer, only retry is left that is specific to SignalProducer.. In one of our projects we're using groupBy the following way:\nWe're tracking bluetooth beacons. Due to some limitations, all our beacons have the same UUID. We use the beacons major- and minor version to identify the beacon. \nWe have a small wrapper that encapsulates all the beacon tracking API and exposes to us, simplified for the sake of the example, a Signal<CLBeacon, NoError>\nWhen monitoring for beacons, we are 'in range' as long as there is at least one beacon with our UUID visible, but there might actually be several different beacons at the same time, or we might move from one beacon to one with overlapping region.\nWe are really interested in each beacon individually, but we have a signal of all beacons. Here, we use groupBy to separate this on signal into a separate signal for each individual beacon.\n```\nlet allBeaconsSignal: Signal\nallBeaconsSignal       \n    .groupBy { beacon in return (beacon.major, beacon.minor) }\n    .flatMap(.merge) { indidivualBeaconSignal in \n        // Do work with the signal for an individual beacon\n    }\n```\n(Sorry for mistakes in the code, this example is just quickly typed here, in our app this is still written in ObjC \ud83d\ude38 )\nActually, I have already ported groupBy from REX to Reactive Swift 1.0 (alpha 3) / Swift 3.0, I could try to bring this over to ReactiveSwift instead. . @andersio all done \ud83d\ude03 . @mdiep ping. Sorry, this is not directly related to this proposal, but more general about your architecture.\nAt first I did not fully understand how you were using AlbumViewModel, but as I was writing this, I began to understand. \n\nYour UITableViewCell / UICollectionViewCell has a AlbumViewModel (as per the ReactiveBindingViewType protocol).\nWhen a cell is reused, you just update the ViewModel's model property (via bind as per the ViewModelProtocol).\nI guess the cell's attributes are bound via self.titleLabel.reactive.text <~ self.viewModel.title once at the setup of the cell\nIf the user scrolls so fast that a new viewModel is bound to a specific cell even before the (lazy) values of the previous viewModel have been evaluated, these are cancelled \n\nIs this summary correct?\nIf so, I've learned something new and now I'm feeling like I've been doing this wrong the whole time \ud83d\ude06 \nThanks!. Just an Idea:\nI would expect there to be something similar to e.g. Property.map\nWould it somehow be possible to implement lazy with a Signature like this:  \n```\nextension PropertyProtocol {\n    func lazy() -> Property {\n        // ???\n    }\nfunc lazy(on scheduler: SchedulerProtocol) -> Property<Value> {\n    // ???\n}\n\n}\n```\nI would expect to use it in the ViewModel like this:\n```\nfinal class AlbumViewModel : ViewModelProtocol {\n    let title: Property\n    let albumArtist: Property\n    let trackText: Property\n    let artwork: Property\n    let blurredArtwork: Property\nlet model = MutableProperty<AlbumType?>(nil)\n\ninit() {\n    title = model.lazy().map { $0?.title ?? \"\" }\n    albumArtist = model.lazy().map { $0?.albumArtist ?? \"\" }\n    trackText = model.lazy().map { $0?.trackCount ?? 0 }.map(AlbumViewModel.textForTrackCount)\n    artwork = model.lazy(on: artworkScheduler).map { $0?.artwork }.replayLazily(upTo: 1)\n    blurredArtwork = artwork.flatMap(.latest) { image in return SignalProducer<UIImage?, NoError>(lazyValue: { image?.applyLightEffect() }) }\n}\n\nprivate let artworkScheduler = QueueScheduler(qos: .userInitiated)\n\nfileprivate static func textForTrackCount(_ count: Int) -> String {\n    if count == 1 {\n        return NSLocalizedString( \"1 Song\", comment: \"Album detail text, singular\" )\n    } else {\n        return String.localizedStringWithFormat(NSLocalizedString( \"%d Songs\", comment: \"Album detail text, multiple\"), count)\n    }\n}\n\n}\n```\n. I think what you're looking for is the take(untilReplacement) operator which will take the first signal until the first value on the second signal and then send the values of the second signal:\n```\nlet state: Signal = p.flatMap(.latest) { _ in\n    return s1.take(untilReplacement: s2)\n}\n```. > I had considered having these lifted to output optionals, but apparently that would be nasty to consume.\nI had considered that as well at first, but  it was indeed awkward to use. . \"Awkward\" may be the wrong word for it. \nBasically, it feels strange to me to introduce an optional, when \"just\" the initial value is missing, something that I have to deal with regardless of the filter operator already:\nI often have (Mutable) properties that will always have a value, but a first \"valid\" value is not available at initialization. Since the value will not change back to nil, using an optional fells wrong and is often tedious down the line, so I have to find a suitable initial value anyway, e.g. empty string, empty array, ...\nNow using a filter operator on such a property feels pretty similar. Sure, there are now more cases where a value might not be passed on so the property might keep the initial value longer / for ever, but once a value passes through, it does not change back to nil anymore. And since I had to choose a suitable (non-optional) initial value for the initial property, I can use the same initial value for the filter operator.\n\nIt'd be nice if we had could do something to propagate that through with some sentinel value.\n\nThis would be really great in my described use case but goes way over my head implementation wise \ud83d\ude06 \n\nYou could always do property.filter(condition).map { $0 ?? initialValue }.\n\nYeah,i f you think filter outputting an optional is the correct to go than I have no problem with doing that. In the case @andersio mentioned that might be the better option anyway.... \ud83d\udc4d . Oh right, I created the more complex example for uniqueValues first and then decided to use the same sequence for skipRepeats as well to better illustrate the difference. \nI'll clean up the simple example.. \ud83d\udc4d . Alright \u2705 . \u2705 . \u2705 . \u2705 . Oh my, missed that in #101, but fixed it now \ud83d\udc4d . \ud83d\udc4d . Do you mean to say \"push\" instead of \"propagate\"?. \u2705 . Oh sure, fixed it as well as some more broken links. Done \ud83d\udc4d . You are talking about this line: \n\nNote that nothing will be printed until producer is started (possibly somewhere else).\n\nright?\nSorry, I'm not sure what you mean exactly. I've tried this example in a Playground\n```\nlet signalProducer = SignalProducer(value: 1)\nlet producer = signalProducer\n    .on(starting: {\n        print(\"Starting\")\n    }, started: {\n        print(\"Started\")\n    }, event: { event in\n        print(\"Event: (event)\")\n    }, value: { value in\n        print(\"Value: (value)\")\n    }, failed: { error in\n        print(\"Failed: (error)\")\n    }, completed: {\n        print(\"Completed\")\n    }, interrupted: {\n        print(\"Interrupted\")\n    }, terminated: {\n        print(\"Terminated\")\n    }, disposed: {\n        print(\"Disposed\")\n    })\nprint(\"---\")\nproducer.start()\nprint(\"---\")\n```\nAnd it behaved as expected and as the line says (\"nothing is printed until the producer is started\"):\n```\nStarting\nEvent: VALUE 1\nValue: 1\nEvent: COMPLETED\nCompleted\nTerminated\nDisposed\nStarted\n\n```\n\ud83e\udd14 . Mhm, are you referring to #115 ?. woops. yeah right, i've split this up into 2 separated cases and extended them to check the lifetime of the inner producers - now the cases catch the disposal issue you've found!. alright! \ud83d\udc4d . sure. done. nice, didn't know about this! . I'm afraid I don't know what exactly you mean.. fixed. ok \ud83d\udc4d . Sure I can do that. \nShould we check for all events that only this event is sent (e.g. when sending completed, also check that interrupted was not received), or can we trust that when completed is received, interrupted can not be received?. I've tried that for a short moment, but on the call site that would then look like producer.group { ... } instead of producer.groupBy { ... }when using trailing closure syntax. \nNot sure if thats a problem though.... Alright! \ud83d\udc4d . Oh that line. Yeah that works without explicit annotations \ud83d\udc4d . Alright. I've posted an example how we use the groupBy in a project in the Issue: https://github.com/ReactiveCocoa/ReactiveSwift/issues/197#issuecomment-269752875. If I'm reading this correctly, RxJS is using Hot Observables for the groups (via refCount). \ud83d\udc4d . \ud83d\udc4d . ",
    "AndrewSB": "It would make sense if the initial clone was slow, but why would that make the checkout so long as well?\nI feel as if it has to be doing something more than just a git checkout, since the repo has already been fetched through carthage.\nRxSwift, for example, which has about 1/4 the commits this repo does takes about 2 seconds to process it's checkout on my machine.. I'll give it a look @mdiep, I'll let you know if I find something!. ",
    "MaximusMcCann": "Just want to run a validate method whenever any form field signal triggers.  We have a lot of fields so I aggregate them in different methods, but I can't get the return type correct :/ \n```\nfunc __section1Sigs() -> Signal<, > { // Tried func __sigs() -> Signal {\n  let (s1, observer1) = Signal.pipe()\n  let (s2, observer2) = Signal.pipe()\nreturn Signal.combineLatest(s1, s2)\n}\n```\nCannot convert value of type 'Signal<Any?, NoError>' (aka 'Signal<Optional<Any>, NoError>') to expected argument type 'Signal<_, _>'. I have this gross solution:\nEXAMPLE\n```\nfunc __sigs() -> (sig: Signal, os: [Any]) {\n  let (s1, o1) = Signal.pipe() // In actual code I have 10+ signals in each method\n  let (s2, o2) = Signal.pipe()\nlet (s, o) = Signal.pipe()\n  Signal.combineLatest(s1, s2).observeValues{ _ in\n    o.send(value: \"anything\") // gross hack\n  }\nreturn (sig: s, os: [o1, o2])\n}\nlet a: (sig: Signal, os: [Any]) = __sigs()\na.sig.observeValues { (things: Any?) in\n  print(\"work\")\n}\nlet o1 = a.os.first! as! Observer\nlet o2 = a.os[1] as! Observer\no1.send(value: \"ao\") \no2.send(value: \"ao\") // Just triggers the above to print \"work\"\no2.send(value: \"ao\")\n```\nMore realistic code:\n```\n  fileprivate final func __investmentOptionSigs() -> Signal {\n    let s1: Signal =  specialBtn.reactive.values(forKeyPath: \"isSelected\").startSignal()\n    let s2: Signal = tf2.reactive.continuousTextValues\n    let s3: Signal = tf3.reactive.continuousTextValues\n    let s4: Signal = tf4.reactive.continuousTextValues\n    let s5: Signal = tf5.reactive.continuousTextValues\n    let s6: Signal = tf6.reactive.continuousTextValues\n    let s7: Signal = tf7.reactive.continuousTextValues\nlet (s, o) = Signal<Any?, NoError>.pipe()\nSignal.combineLatest(s1, s2, s3, s4, s5, s6, s7).observeValues { _ in\n  o.send(value: \"trigger\")\n}\nreturn s\n\n}\n```\nReally want to have the return be: return Signal.combineLatest(s1, s2, s3, s4, s5, s6, s7)\n... I have many more than 7 signals. Formal question:  Is there a way to make the return signature match w/e Signal.combineLatest() returns?  \nMy initial solution was to return an array of Signals which would then be used as Signal.combineLatest(array) elsewhere, but the strong typing is preventing that.. Appreciate the help @andersio!  I'm going to map all values to Any?.  \nJust feels weird since all objects are already Any.... ",
    "alper": "Excellent! Thanks.. That is:\nfunc parseResponse(_ data: Data, response: URLResponse) -> SignalProducer<JSON, NetworkError> {\nNetworkError is a subclass of Error.. Oddly enough I changed it to a map instead of a flatMap and that at least made the compiler happy:\nreturn URLSession.shared.reactive.data(with: request as URLRequest)\n      .map { (d, u) -> JSON in\n        // TODO fix\n        return JSON(data: d)\n      }\n      .mapError { (e) -> NetworkError in\n        return NetworkError.badRequest\n      }\n      .observe(on: UIScheduler())\nI'll try your both suggestions.. Your first sample turns into something like this:\nreturn URLSession.shared.reactive.data(with: request as URLRequest)\n        .mapError { NetworkError.fromError($0.error as NSError?) }\n        .flatMap(.latest, transform: parseResponse)\n        .observe(on: UIScheduler())\nand then the compiler complains with:\nIn argument type '(Data, URLResponse) -> SignalProducer<JSON, AnyError>', 'SignalProducer<JSON, AnyError>' does not conform to expected type 'PropertyProtocol'. Thanks @andersio I guess the error and the signature change of parseResponse to a single parameter (my old one had two\u2026) did the trick. And thankfully this is the resolution of a pretty long dead end during the swift 3 conversion of a project.. You're right\u2026\nI have no idea what was going wrong all this time and SourceKit was so slow and unstable that it's hard to work with it. Thanks a lot!. Oh sorry, you are right and I was behind. Thanks!. Ok. So this is in 1.1.5? My ReactiveCocoa 5.0.4 does not seem to depend on it so I added the pod separately and that works.. ",
    "roodkcab": "@andersio startWithSignal is exactly what I want! Thank u so much!. ",
    "snap9": "@andersio Thanks, that could work. Is there a particular reason for why an Action based extension/subclass for UITableView (for replicating the delegate and data source) haven't been added to ReactiveCocoa? It feels like this would be a common thing people would want. All I see for UITableView in ReactiveCocoa is a hook to reloadData. Your thoughts? Thanks again.. @andersio Hello, do you have any new updates/news/thoughts on delegate interception, data sources, and/or reactive collections? Thanks mate.. ",
    "cristianames92": "I'll add test cases for this tomorrow. @andersio all the comments are resolved or responded. Do you mind to take a look at it?. @andersio hope you enjoyed Christmas if you celebrate it. I want to tell you that i just add the changes that you've requested.. @andersio The new requests have been done.. @andersio I've made the last changes you request and merged the changes in master.. @andersio The fixes are done. @sharplet I think not is more conventional than negated as you are using propositional logic.. ",
    "maximbilan": "Thanks.. ",
    "oronbz": "@mdiep done. ",
    "gavrix": "Ok, so I see that was intentional.\nOut of curiosity, don't you think it may be confusing that given declaration let p: Property<String> the producer p.producer may or may not complete depending on how that property was created? The type doesn't define full semantics of that thing. This reminds me of of RACSignal was split into Signal and SignalProducer so that type can clearly describe the semantics of the stream.\nHave you considered splitting composed Property into separate type to avoid that confusion?\n. ok I see then.\nBut then, I believe PropertyType needs to be updated too.\n```\npublic protocol PropertyProtocol: class, BindingSourceProtocol {\n    associatedtype Value\n/// The current value of the property.\nvar value: Value { get }\n\n/// The values producer of the property.\n///\n/// It produces a signal that sends the property's current value,\n/// followed by all changes over time. It completes when the property\n/// has deinitialized, or has no further change.\nvar producer: SignalProducer<Value, NoError> { get }\n\n/// A signal that will send the property's changes over time. It\n/// completes when the property has deinitialized, or has no further\n/// change.\nvar signal: Signal<Value, NoError> { get }\n\n}\n```\nThe docs are wrong and misleading.. Ah, good. I added comment there. \nThank you for clarifying this to me! It's been a while since I last looked into sources, lost some context of what was changing.. Property docs are out of sync too.\n/// A producer for Signals that will send the property's current\n    /// value, followed by all changes over time, then complete when the\n    /// property has deinitialized or has no further changes.\n    public var producer: SignalProducer<Value, NoError> {\n        return _producer()\n    }. ",
    "sigmonky": "Thanks for the quick response. Updated as follows\n```\nuse_frameworks!\nsource 'https://github.com/CocoaPods/Specs.git'\ntarget :reactiveprototype do\n    pod 'ReactiveCocoa', '5.0.0-alpha.5'\nend \n````\nstill getting the same compile error\nAm on Cocoapods 1.0.1. Could that be the issue?. After upgrading to Cocoapods 1.1.1, my app is now building. I also had a legion of problems with expired Ruby certs that I had to resolve. Have also installed Ruby 2.2.2p95. Cocoapods 1.1.1 requires at least Ruby 2.2.1. \nI would recommend adding this information to the installation documentation. It will save people alot of grief.. ",
    "doozMen": "@andersio why is the error init needed? It works for me but I cannot wrap my head around it.. ",
    "ynnckcmprnl": "I have used the groupBy & uncollect methods to group appointments per day for display in a UICollectionView, though there might be more elegant/shorter ways to achieve this.\nswift\nSignalProducer(value: appointments)  \n   .uncollect()  \n   .groupBy { appointment in  \n      appointment.begin.stripTime()  \n    }  \n   .map { $0.1.collect() }\n   .flatten(.Concat)\n   .collect()\n}. ",
    "NinoScript": "I'm really interested in why this may not be a good idea. @NachoSoto ?. ",
    "yoching": "I have same feelings about the misleading of the naming.\nI always convert in my head\nfrom\nsignal.observe(observer)\nto\nsignal.observed(by: observer). ",
    "Huanqiang": "@ikesyo This means that I have to introduce ReactiveCocoa???\n. thank you @ikesyo . @ikesyo\nand could you  tell me the relationship between reactiveswift and reativecocoa\u3002\nreactiveCocoa  is just an extension of UI\uff1f\uff1f\uff1f\uff1f\n. ",
    "shyamala-tj": "@Huanqiang me too facing the same issue.Do I need to add both ReactiveSwift and ReactiveCocoa framework to resolve the same?. ",
    "oinsider": "Hi @mdiep I just updated the example code. I dispose the signal on the instance deinitialization. Anyway, the  2-node cycles appear right after the initialization of the view models.\nThanks! . Oh, ok that has a lot of sense! thanks for your answer @mdiep \u00a0\ud83d\ude00. ",
    "IanLuo": "thanks, it works.. ",
    "ianbytchek": "Typing from the memory, roughly looks like this. When property is updated it immediately sends a signal and updates the textfield with just typed in value.\n```swift\nlet property: DynamicProperty = DynamicProperty(object: defaults, keyPath: \"foo\")\ntextfield.reactive.stringValue <~ property.producer\n    .skipNil()\n    .filter({ String($0) != textfield.stringValue })\n    .map({ String($0) })\nproperty <~ textfield.reactive.stringValues\n```. I wouldn't call it approach, it's a simplified example to illustrate a specific issue with current binding operator and rationalise new binding operator that will check value uniqueness before assigning it.\n\nUnfortunately, these \"bounce-back edits\" are a difficult problem we've been trying to find a nice solution for.\n\nI've been using the such checks for ages, it works great, but adds a lot of boilerplate code and some overhead. The new api is great and making this feature part of the core would be simply awesome, not to mention that it would solve the problem. . Thanks for a detailed write up and good points. I understand that this solution isn't a universal answer to deadlocking and you obviously know more about the problem\u00a0\u2013 it's an interesting case and I feel it's important to differentiate between situations here, yet it seems these are considered all the same. I'm not stating this is the true answer to all of it, but it's worth looking at the problem from a different perspective. Consider the following.\nMajority of deadlock situations involve bi-directional binding of some sort, e.g., between properties or properties and ui state. Those are easily discoverable and easy to solve with some kind of uniqueness-based filtering. It's easier with UI, because it sends signals on actions, not on property updates, but other stuff, like managed objects or user defaults \u2013 they don't.\nOther situations implement per-case logic, they are more complex and rare \u2013 solutions here are unique to that logic and any attempt to provide standard anti-deadlocking will probably interfere with that logic. The only solution here is to raise an exception, like already happens. Sending an observable deadlock error might also do some good and allow to handle it at runtime.\nSecond case is where developers should worry about the implementation and explicitly handle deadlocks, not in first one. The first case is a little like child-parent management, when child can be added to parent and child's parent can be set to a different value \u2013 parent much check that it doesn't contain the element being added and child much check parent is different when changing it.\nWith regards to the actual solution adding filter is not a suggested approach, it should be similar to UnidirectionalBinding.swift#L98-L102:\nswift\nif let target = target as? BindingTarget<Target.Value> {\n    observer = Observer(value: { [getter = target.getter, setter = target.setter] in \n        if $0 != getter() {\n            setter($0)\n        }\n    })\n} else {\n    // This part trickier\u2026\n}\nObviously BindingTarget doesn't have getter, so this isn't as simple as adding a few lines. It's even more problematic with BindingTargetProtocol in general. Introduction of new BidirectionalBindingTarget and BidirectionalBindingSource protocols would help to keep these concerns separate and provide the missing getter functionality, the new operator <~~ would operate exclusively upon these protocols. That's my two cents.. Wouldn't it be a little unuseful in a real life situation? I'm trying to figure out if this is a language limitation or not. Swift bug tracker has a lot of generic-related issues, perhaps this is one of them?. Continues at https://bugs.swift.org/browse/SR-3716.. This one?. Just remembered when came across this on SO!\nswift\nextension Reactive\n{\n    public func foo<T>() -> Signal<T, NoError> where Base: MyGeneric<T> {\n        // \u2026\n    }\n}. Love how with every post here I end up learning a bunch of new information! \ud83d\ude04 Agree with everything, thanks for detailed feedback!. Have a related issue going on in #704 where trying to find the best way to consolidate related property bindings, signals and producers. The current mutable property model doesn't look very appealing and I'm trying to understand a couple of things.\nAs a concept properties sound great. However, in practice ReactiveCocoa doesn't use them at all where they would fit naturally and reverts to binding targets, signals and producers instead, which cause naming inconsistencies (discussed here and here). \nI find it rather strange to have a specific tool in the framework, but instead use three other tools to do the job it's designed to do\u2026 Do you think having lighter properties which don't require being retained would help breaking this \"tradition\"?\nMy second questions is related. Why must the Property be a class? I don't fully understand how signal affect this: https://github.com/ReactiveCocoa/ReactiveSwift/blob/2a4ffea000e59f382b910bf68392b2f7fd20f8b7/Sources/Property.swift#L14-L16\nMy guess is that this was designed upon retaining the value and not considering that this can be a wrapper or proxy. E.g., it can be composited of an KeyPath existing and signal and be a lightweight struct, like here. Not the universal use case, but the same can be done with @objc dynamic properties, especially when https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3491 gets merged.. Doesn't it depend on how you look at the observable though? It doesn't need to be when it's acting as a \"reactive\" proxy for AnyObject's property and not storing the actual value. A broad example using KeyPath (the same could be done with getter/setter blocks, not sure why\u2026):\n```swift\nstruct PropertyProxy: BindingSource, BindingTargetProvider\n{\n    init(_ base: Base, _ keyPath: ReferenceWritableKeyPath, _ signal: Signal) {\n        self.base = base\n        self.keyPath = keyPath\n        self.signal = signal\n    }\nlet base: Base\nlet keyPath: ReferenceWritableKeyPath<Base, Value>\nlet signal: Signal<Value, NoError>\nvar lifetime: Lifetime { return Lifetime.of(self.base) }\nvar producer: SignalProducer<Value, NoError> { return self.signal.producer.prefix(value: self.value) }\nvar bindingTarget: BindingTarget<Value> { return self.base.reactive[self.keyPath] }\n\nvar value: Value {\n    get { return self.base[keyPath: self.keyPath] }\n    nonmutating set { self.base[keyPath: self.keyPath] = newValue }\n}\n\n}\n```\nAgain, this is not to say that this is how things must be, but feels like a great approach to KeyPath properties with minimal initialization and it would be great if PropertyProtocol extensions were compatible with it.\nSimply dropping AnyObject conformance wouldn't work, instead, could we have a common base protocol for these stuff? Maybe have protocol Bindable: BindingSource, BindingTargetProvider to provide things like map, etc.?. > \ud83d\udc4a me if I'm missing the obvious\u2026\nArgh, this moment again! Now I know new old methods \u2013 couple more years and I'll learn how to use the framework\u2026 and thanks for the side note!. That's what I thought. And queuing does help indeed. But why doesn't it crash? The above stack trace is from debugger when I pause execution, not a crash report.. PthreadLock uses normal type mutex, which is evil, not recommended and causes the issue (checked & confirmed):\nswift\npthread_mutexattr_settype(attr, Int32(recursive ? PTHREAD_MUTEX_RECURSIVE : PTHREAD_MUTEX_NORMAL))\n\nPTHREAD_MUTEX_NORMAL\nThis type of mutex does not detect deadlock. A thread attempting to relock this mutex without first unlocking it will deadlock. Attempting to unlock a mutex locked by a different thread results in undefined behaviour. Attempting to unlock an unlocked mutex results in undefined behaviour.\nPTHREAD_MUTEX_ERRORCHECK\nThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it will return with an error. A thread attempting to unlock a mutex which another thread has locked will return with an error. A thread attempting to unlock an unlocked mutex will return with an error.\n\nThere's a comment above that, which probably explains why PTHREAD_MUTEX_NORMAL was chosen over PTHREAD_MUTEX_ERRORCHECK:\nswift\n// Darwin pthread for 32-bit ARM somehow returns `EAGAIN` when\n// using `trylock` on a `PTHREAD_MUTEX_ERRORCHECK` mutex.\n\nEAGAIN\nThe mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.\n\nSo, if it fails then perhaps it should. I tend to use NSLock when need to fallback in pre-10.12 times. It is based on the same POSIX Threads, so you're reinventing the wheel there and facing the consequences. The performance is only a tiny fraction better judging by the most optimistic benchmark. Given that 10.11 will be 3 versions behind master in a couple of months I suggest letting the natural selection do it's job and replace PthreadLock with NSLock. Can send a PR if you're happy with the above?\nP. S. The issue might be with DEBUG in the above condition \u2013 not sure what's the purpose of it in the given context, but everything said still applies.\n. My suggestion is to use Apple-provided NSLock and NSRecursiveLock for the minority of platforms not supporting unfair locking \u2013 this will simplify the codebase and solve the EAGAIN & EBUSY part. If you're eager to keep the raw POSIX Threads then we should review this condition and specifically DEBUG flag \u2013 it seems to me like it shouldn't be there. Removing it makes things straight in 10.11.. DEBUG compiler flag from here:\n``swift\n// Darwin pthread for 32-bit ARM somehow returnsEAGAINwhen\n// usingtrylockon aPTHREAD_MUTEX_ERRORCHECK` mutex.\nif DEBUG && !arch(arm)\npthread_mutexattr_settype(attr, Int32(recursive ? PTHREAD_MUTEX_RECURSIVE : PTHREAD_MUTEX_ERRORCHECK))\nelse\npthread_mutexattr_settype(attr, Int32(recursive ? PTHREAD_MUTEX_RECURSIVE : PTHREAD_MUTEX_NORMAL))\nendif\n``. Good points. I recall using properties awhile ago but something didn't work out, so I abandoned that idea. I'll look into this again, but is there any reason why current api doesn't make use of them? It seems like a perfect candidate for cases likeattributedString`, etc.. That only makes it more intriguing! \ud83d\ude10 @andersio You did a lot of work around https://github.com/ReactiveCocoa/ReactiveCocoa/pull/3463, perhaps you remember why properties are not preferred to binding targets and signals?. After migrating a project to use properties in attempt to consolidate separate bindings, signals and producers, the answer why they aren't first citizens seems obvious: \n\nThe receiver must store the the property, especially true for mutable properties, which implies altering the code structure and increasing the complexity.\nMutable properties are a good solution for also handling atomic values, but up to the point until it needs to be integrated with an existing solution in place, which quickly turns into a mess.\nThe easy integration into existing code with existing property handling features (willSet, didSet) implies (of course not in all cases) duplicating a property to provide the reactive features, which feels like shooting self in the foot.\nEven providing a regular non-mutable property in reactive extension feels awkward due to the fact that it's a class, not a struct, which it doesn't need to be for the concept (more on this below) and considering the performance implications with reported 50,000,000\u2026 \ud83d\ude33 initialization time difference.\n\nThe fact that ReactiveCocoa doesn't use properties in extensions where they fit organically is a little hypocritical. I propose to consider adding new lightweight proxying property types,  which would take care of three simple tasks: \n\nProvide signal\nProvide producer\nProvide binding target (if mutable)\n\nIt would differ from existing implementation by not storing the value and not being concerned with the thread safety. This would also allow to use struct over class and provide reactive property behaviour as extension-only feature without the need to store them in the Reactive base object.\nThe implementation I experimented with is based around Swift KeyPath:\n```swift\npublic struct KeyPathProperty: BindingSource, BindingTargetProvider {\n    public init(_ target: Target, _ keyPath: ReferenceWritableKeyPath, _ signal: Signal) {\n        self.target = target\n        self.keyPath = keyPath\n        self.signal = signal\n    }\npublic let target: Target\npublic let keyPath: ReferenceWritableKeyPath<Target, Value>\npublic let signal: Signal<Value, NoError>\npublic var producer: SignalProducer<Value, NoError> { return signal.producer.prefix(value: self.value) }\n\npublic var value: Value {\n    get { return self.target[keyPath: self.keyPath] }\n    set { self.target[keyPath: self.keyPath] = newValue }\n}\n\npublic var bindingTarget: BindingTarget<Value> {\n    return BindingTarget(lifetime: Lifetime.of(self.target)) { [weak target, keyPath] value in target?[keyPath: keyPath] = value }\n}\n\n}\nextension Reactive where Base: Foo {\n    internal var myProperty: KeyPathProperty { \n        return KeyPathProperty(self.base, . myProperty, self.base.pipe.myProperty.output)\n    }\n}\n```\n@mdiep What do you think?\n. ",
    "fritzgerald": "here is the solution I found that allow to create computed properties and not pollute the reactive namespace.\n```\nclass GenericView: UIView { }\nextension GenericView {\n  struct Reactive {\n    let base: GenericView\nfileprivate init(_ base: GenericView<T>) {\n  self.base = base\n}\n\n}\nvar reactive: Reactive {\n    return Reactive(self)\n  }\n}\nextension GenericView.Reactive {\n  var reactiveComponent: Observable {\n    ...\n  }\n}\n```. ",
    "ninjudd": "I tried that too. With this code:\nswift\nfunc send(request: URLRequest) -> SignalProducer<(Data, URLResponse), Error> {\n    return SignalProducer({ observer, disposable in\n        let signal = self.session.reactive.data(with: request)\n        disposable.add(signal.start(observer))\n    })\n}\nI get the following error:\n\nUsing 'Error' as a concrete type conforming to protocol 'Error' is not supported. And with this code:\n\nswift\nfunc send<Error>(request: URLRequest) -> SignalProducer<(Data, URLResponse), Error> {\n    return SignalProducer({ observer, disposable in\n        let signal = self.session.reactive.data(with: request)\n        disposable.add(signal.start(observer))\n    })\n}\nI get this error:\n\nCannot invoke 'start' with an argument list of type '(Observer<(Data, URLResponse), Error>)'. I have to say, AnyError completely confuses me. Is there a good resource to better understand when to use AnyError and why it is preferable to NSError?\n\nShould I be replacing every single SignalProducer<_, NSError> with SignalProducer<_, AnyError>?. ",
    "eimantas": "Pushed some more updates including requested changes.. No worries! I managed to forget about this PR myself .). New line's missing after the heading.. New line's missing after the heading.. ",
    "ChristopherRogers": "Changing value to internal will allow it to build, since the access level is the same as the methods accessing it. However, it seems like it's more important to keep this property hidden to prevent being directly accessed by accident.. ",
    "larryonoff": "@ikesyo it's a good argument, but first(), last(), single() and wait(), are very specific operators and return Result. They cannot be used with try / catch. \nSo I have two ideas about this:\n 1. Introduce operators like first() / last(), but for try / catch.\n 2. Rename these operators to something like away / async. But I'm not sure that it's good, because doesn't provide similar semantics yet.. Thank you for mentioning!\nLook how weird it will look like.\n```\nlet producer: SignalProducer\ndo {\n   // 1. await version\n   guard let value = try await(producer) else {\n      return\n   }\n// 2. already existing version\n   guard let value = try producer.first()?.dematerialize() else {\n      return\n   }\n} catch let error as Error {\n   print(error)\n} catch { }\n``. @mdiep RACCommunity is a great idea! I just wanted to discuss this with community to define some base API.. @andersio you're absolutely correct! what about\n*awaitFirst*awaitLast. @andersio very good notice. I'm a bit stuck after this :)awaitmay just block execution.. I'm closing this issue since I'm not sure that my proposal is good now.. @andersio thank you very much. It works!. @mdiep the accepted signature 1-by-1 toantitypical/Result`. This's really great. Result already updated for Swift 5.0, see antitypical/Result#278. I think it can just be extensions in ReactiveSwift without Result dependency.. @NachoSoto great to see pilots here :). ",
    "DarkDirectX": "Thank you!). ",
    "NicholasTD07": "No problem. :). ",
    "arnopoulos": "I'm working on a project where we're trying to prevent the user from spamming the server and this would be very helpful. Are there any updates on the progress of this?. @andersio That's too bad because this definitely could be a useful feature. If I had a deeper understanding of the underlying architecture of ReactiveSwift, I would try to help out. @sharplet I thought that throttle just delays the execution of events? If so, I think what I need is a debounce(while:) of filter(while:). @sharplet That worked! Thanks for your help.. @mdiep Sorry about the delayed response. This solves a mutual exclusion problem with Lifetime.Token and simplifies creating custom life cycles. Take the following example:\n```\nprotocol Items {\n    //Things an item would need\n}\nclass Store {\n    private var (lifetime, token): (Lifetime?, Lifetime.Token?)\n    var items: Property<[Items]>! {\n        didSet {\n            if token != nil {\n                open()\n            }\n        }\n    }\nfunc open() {\n    let (lifetime, token) = Lifetime.make()\n    self.lifetime = lifetime\n    self.token = token\n\n    items.producer.take(during: lifetime).startWithValues { (items) in\n        //Do something here\n    }\n}\n\nfunc close() {\n    token = nil\n}\n\n}\n```\nThe example is simple but it shows the mutual exclusion problem and some of the problems with manual life cycle management. The first is because of potential user error and (intentional) improper access control a consumer of Store could hold a strong reference to Lifetime.Token. In addition there isn't a single code path to guarantee that your reactive components are going to be started. For example, in the example you could imagine that Store could have another function that opens at a specific time open(at time: Date). In that function you can imagine that a user could forget to start the items signal producer which can be an issue.\nWhat I'm proposing is something to the effect of this:\n```\nclass Store {\n    lazy var lifecycle: Lifecycle = {\n        let lifecycle = Lifecycle()\n        lifecycle.lifetime.producer.startWithValues { [weak self] lifetime in\n            self?.items.producer.take(during: lifetime).startWithValues { items in\n                //Do something here\n            }\n        }\n        return lifecycle\n    }()\n    var items: Property<[Items]>! {\n        didSet {\n            lifecycle.updateIfValid()\n        }\n    }\nfunc open() {\n    lifecycle.update()\n}\n\nfunc close() {\n    lifecycle.invalidate()\n}\n\n}\n```\nIn addition this makes the open(at time: Date) example relatively trivial to implement:\n```\nclass Store {\n    private var timer: Timer?\n    lazy var lifecycle: Lifecycle = {\n        let lifecycle = Lifecycle()\n        lifecycle.lifetime.producer.startWithValues { [weak self] lifetime in\n            self?.items.producer.take(during: lifetime).startWithValues { items in\n                //Do something here\n            }\n        }\n        return lifecycle\n    }()\n    var items: Property<[Items]>! {\n        didSet {\n            lifecycle.updateIfValid()\n        }\n    }\nfunc open() {\n    timer?.invalidate()\n    lifecycle.update()\n}\n\n@available(OSX 10.12, *)\nfunc open(at date: Date) {\n    timer = Timer(fire: date, interval: 1.0, repeats: false) { [weak self] timer in\n        self?.lifecycle.update()\n    }\n}\n\nfunc close() {\n    lifecycle.invalidate()\n}\n\n}\n```\nAnother place where I and the team I work on end up using this a lot is in UI logic specifically, view controllers and reusable views such as table/collection cells.. @mdiep Have you had time to look over this PR again?. @mdiep Have you had time to look over this PR again?. ",
    "ataibarkai": "is this feature addition still on hold for the foreseeable future?. ",
    "AlexanderKaraberov": "@mdiep @andersio \n\nI think it's best to minimize the exposure of replaying/buffering methods\n\nCould you please elaborate on this? Or if this has been already explained or discussed somewhere then point me to that resource. I tried to search in the repo issues and comments any explanation of why SignalProducer.buffer was removed and why replay/buffering is discouraged but with no luck...\nI don't really see any drawbacks of those but maybe I'm not able to see the whole picture or lack some experience (e.g. RxJava contains buffer).. @andersio I would rather say that it consistently happens with all the ReactiveSwift functions which use Result and yes - it consistently happens with all the use of startWithResult as well. Just to double-check I tested that Result library is loaded and I can use it in the same function which calls startWithResult without any problems. Wild guess: it has something to do with the dynamic lib (as I said this issue is happened only in iOS 8 and 9). If I do jump to definition i see this:\npublic func startWithResult(_ action: @escaping (Result.Result<Value, Error>) -> Swift.Void) -> Disposable\nwhich looks odd, because all other definitions use Result and not Result.Result, e.g. SignalProducer where Error == Result.NoError, but as I said it might be a long shot and I could be wrong.. @andersio  I performed more tests. Yes this consistently happens during all the usages of startWithResult in different places when I try to print() value or po it in the LLDB. Even when I create a SignalProducer in one view controller and then pass it to another one and then from there call startWithResult, behaviour is the same: EXC_BAD_ACCESS in _swift_getClass and error in LLDB.. ",
    "almassapargali": "So those two actions eventually get bound to two buttons accept | decline. And if user presses accept, I want decline be disabled while accepting in progress.. Personally I think ReactiveSwift should provide a way to allow only one of multiple actions at a time, and they way I coded it looks totally ok from developers perspective (imho). Maybe we can allow that code, but somehow avoid deadlocking?. Wow, great idea, how I missed that. Thank you very much, it really eliminates need for other action and property. I think I should close this one since it really led me to more complex implementation, and now after some thinking, I see the proper way to solve\n\nprovide a way to allow only one of multiple actions at a time\n\nwould be one Action with enum as state or input.. ",
    "jjoelson": "Just jumping in here as a non-contributer: as someone who has gotten quite used to the current approach, (2) and (4) are very legible. If continuity is a priority then it makes sense to me to reuse reactive. . Is there any reason it couldn't be ~> to imply the opposite observer/source relationship as <~?\nI also think += would be fine, as what else would you be adding to a Lifetime but something to be disposed when it ends?. I noticed that TestScheduler implements it \"recursively\" in terms of schedule(after:action:):\n```\nprivate func schedule(after date: Date, interval: DispatchTimeInterval, disposable: SerialDisposable, action: @escaping () -> Void) {\n    precondition(interval.timeInterval >= 0)\ndisposable.inner = schedule(after: date) { [unowned self] in\n    action()\n    self.schedule(after: date.addingTimeInterval(interval), interval: interval, disposable: disposable, action: action)\n}\n\n}\npublic func schedule(after date: Date, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .seconds(0), action: @escaping () -> Void) -> Disposable? {\n    let disposable = SerialDisposable()\n    schedule(after: date, interval: interval, disposable: disposable, action: action)\n    return disposable\n}\n``\nCould this work forQueueScheduler` as well? It would obviate the need to use and store timers at all.. Good point. I will submit a pull request to keep a collection of active timers, sometime in the next few days.. I think I see the bug, but strange that it\u2019s not failing on my machine. I guess there\u2019s a race condition where the expectation sees that it got incremented to 3 and succeeds before it gets incremented that last time. \nI will fix when I get back to my PC. . Is there a test still failing on Linux? I'm having a tough time understanding the log.. OK, I found the error on Linux:\n/home/travis/build/ReactiveCocoa/ReactiveSwift/Sources/Scheduler.swift:185:10: error: cannot invoke initializer for type 'ObjectIdentifier' with an argument list of type '(DispatchSourceTimer)'\n                return ObjectIdentifier(value).hashValue\n                       ^\n/home/travis/build/ReactiveCocoa/ReactiveSwift/Sources/Scheduler.swift:185:10: note: overloads for 'ObjectIdentifier' exist with these partially matching parameter lists: (AnyObject), (Any.Type)\n                return ObjectIdentifier(value).hashValue\n                       ^\n/home/travis/build/ReactiveCocoa/ReactiveSwift/Sources/Scheduler.swift:193:20: error: binary operator '===' cannot be applied to two 'DispatchSourceTimer' operands\n                return lhs.value === rhs.value\n                       ~~~~~~~~~ ^   ~~~~~~~~~\n/home/travis/build/ReactiveCocoa/ReactiveSwift/Sources/Scheduler.swift:193:20: note: overloads for '===' exist with these partially matching parameter lists: (AnyObject?, AnyObject?), (NSNull?, NSNull?), (AnyClass, AnyClass)\n                return lhs.value === rhs.value\nWill fix when I get home tonight.. Stumped by this one:\n```\n2018-01-02 23:49:31.857 xcodebuild[2551:9128] Error 2018-01-02 23:49:31.857 xcodebuild[2551:9128] Error Domain=IDETestOperationsObserverErrorDomain Code=6 \"Early unexpected exit, operation never finished bootstrapping - no restart will be attempted\" UserInfo={NSLocalizedDescription=Early unexpected exit, operation never finished bootstrapping - no restart will be attempted}\n TEST EXECUTE FAILED \n``. Seems to be working now. Judging by [this Stackoverflow thread](https://stackoverflow.com/a/36217200/642233), that's an error that can occur randomly. . Another (possibly stupid) idea would be to have the new property always start with the current value of the existing property and then filter all subsequent values. I think this would make the operator pretty seamless to use in most cases, though it might make it too easy to make a mistake. . I tried to implement equality this way initially but [had to change it](https://github.com/ReactiveCocoa/ReactiveSwift/pull/584/commits/7911a7366c4c585207186305c7be08d00eac6471) because it seemsDispatchSourceTimerdoesn\u2019t inherit fromNSObjectProtocolon Linux.. How so? I was basically trying to implementHashable` based on the wrapper's identity, as described in this blog post.\nI know it's weird that it doesn't use the wrapped DispatchSourceTimer but I couldn't think of a way to make that work on Linux.. In order to discourage users from ignoring errors, observeValues is only defined for NoError Signals. You might want to take a look at observeResult which has the same signature as observeValues except it's closure takes a Result<Value, Error> that you can switch over in order to handle errors.. I think I agree with @mdiep that it might make sense to change the names. signal and producer really mean futureValues and currentAndFutureValues, and if those were the names then no one would ever be confused as to which they ought to use in any given situation.\nIt's true that currentAndFutureValues needs to be a SignalProducer rather than a Signal for reasons that would be obvious to anyone if they were implementing it. But it's a bit strange to name the property producer and expect users to work backwards and figure out that that probably means it sends the current value when started.. flatMap let's you control how a series of asynchronous producers are started, but that seems different from actually scheduling parallel CPU work. I'm envisioning a scenario where I have a bunch of producers who's startHandlers perform synchronous long-running CPU bound work. As far as I know, flatMap just starts incoming producers synchronously regardless of the FlattenStrategy, and it's left up to the producer to determine how it's work is actually scheduled. \nWhat I'm talking about is something like start(on:) which controls the actual execution of the startHandler , except there doesn't appear to be any concurrent Scheduler to use there.. @mdiep, would it make sense to manually have producers start work on a concurrent GCD queue, bypassing the RAS Scheduler abstraction entirely? E.g.:\n```swift\nextension SignalProducer {\n    func start(on queue: DispatchQueue) {\n        return SignalProducer { observer, lifetime in\n            queue.async {\n            lifetime += self.start(observer)\n        }\n    }\n    }\n}\nlet input: Signal = ...\ninput\n    .flatMap(.merge) { str in\n        return getProducer(str)\n            .start(on: DispatchQueue.global(qos: .userInitiated))\n    }\n    .observeValues { val in\n        // Do something\n    }\n```\nOr would this mess things up internally with respect to serial event delivery?. The idea of creating my own pseudo thread pool with a collection of schedulers each backed by a serial GCD DispatchQueue seems like reinventing the wheel. GCD already has concurrent queues that do this way better and it would be great to figure out a way to take advantage of that in RAS code.\nRxSwift has concurrent schedulers, so you can just call subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) which is very easy for end users. Could something similar work in RAS if the user was forced to provide a Scheduler on which events could be sent serially? I.e. would it be possible to safely implement an operator with this signature:\nswift\nextension SignalProducer {\n    func start(on queue: DispatchQueue, observeOn scheduler: Scheduler) {\n        ...\n    }\n}. The case I'm thinking of here is any kind of CPU-bound task. For example, imagine some kind of image processing that takes 1 second per image. If you have 90 images to process, it will take about a minute and a half to complete if performed serially. But on a multi-core system you can potentially finish much faster.\nMy understanding of GCD, which is admittedly fairly limited, is that ensuring that tasks get assigned to threads efficiently is one of its fundamental purposes, and that a concurrent queue will generally be smart about deciding how many tasks to start simultaneously in order to maximize performance.\nWith respect to using a group of serial queues as a \"thread pool\", the documentation explicitly recommends against that:\n\nYou can create any number of serial queues for your application but should avoid creating large numbers of serial queues solely as a means to execute as many tasks simultaneously as you can. If you want to execute large numbers of tasks concurrently, submit them to one of the global concurrent queues. When creating serial queues, try to identify a purpose for each queue, such as protecting a resource or synchronizing some key behavior of your application.\n\nSo it's not clear to me why allowing users to easily dump tasks onto a concurrent DispatchQueue like with subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) is shooting themselves in the foot, but as I said, my knowledge of GCD is limited.. @sharplet, that's very good to know, thanks.. @liscio, thanks for that example, I think a concurrent queue in conjunction with the concurrent flatten strategy is exactly what I'm looking for. I also think your explanation for why there's no built-in operator to execute a producer's work on a concurrent queue makes perfect sense. You'd almost have to build it into a FlattenStrategy to ensure that it was never misused. . In #668, it seems the example would look almost exactly the same with a SignalProducer except the need to provide a flatten strategy is gone, on has been renamed when, and start has been renamed await.  Isn't a major goal of a framework like ReactiveSwift to have a common vocabulary of types and operators that can represent streams of values over time? Bracketing off a particular subset of use cases and changing all of the names seems counter to the mission as I understand it.\nThe ability to have flatMap without a flatten strategy is a real gain, and I'd like to understand what other improvements like that can be had by introducing a new type to represent a single value stream. Apart from things like that, I think the public API for this new type ought to look as much like SignalProducer as possible. . DispatchSourceTimer isn't Hashable, so I think it would have to be an NSMutableSet. Is that an improvement over using a Swift array?. ",
    "nalexn": "It seems like this change has broken the ability to interrupt the running RequestProducer via disposing of the Disposable, in a way that original CompositeDisposable would immediately propagate cancellation, while lifetime seems to not reflect the disposing of the Disposable:\nswift\nlet mySignalProducer = SignalProducer<Void, NoError> { observer, lifetime in\n      lifetime.observeEnded {\n        print(\"> lifetime ended\")\n      }\n      async ... {\n          print(\"> completed\")\n          observer.sendCompleted()\n      }\n}\nlet disposable = mySignalProducer.start()\nprint(\"> started\")\ndisposable.dispose()\nprint(\"> disposed\")\nSo the log for the example above would look like this:\n```\n\nstarted\ndisposed\ncompleted\nlifetime ended\n```\nSo the lifetime inside the ResponseProducer's init closure remains alive until Producer completes.\n\nI should mention this worked differently in ReactiveSwift v1.*, where SignalProducer would be interrupted immediately upon disposing.... @andersio thank you for the explanation, now I understand it better.\nIs that possible to bound the piece of work to the lifetime without appealing to closure in a scheduler (basically how to do the same but syncronously)? It looks like unless I bound other disposable to the lifetime it'll disregard the fact of disposing as lifetime.hasEnded is still false even after calling dispose(). Yep, that totally makes sense. Thank you. I can confirm we're using Swift 4.1. Waiting for the public release of Swift 4.2 then. In the meanwhile, had to introduce a temporary replacement for the map:\nswift\npublic extension PropertyProtocol {\n  func mapTo<U>(_ transform: @escaping (Self.Value) -> U) -> ReactiveSwift.Property<U> {\n    return map(transform)\n  }\n}. ",
    "JyggalagIRL": "Thanks, @andersio !\nI'm neither familiar with RAC nor good at English. In documents it says Do not forward any values from self until predicate returns false, which I understand skip(while: { string in string == nil }) behaves the same as skipNil(). Have I a got some mistakes in my understanding of skip(while:), could you explain more about it?. It is a one-time toggling., got it!\nThanks again @andersio , you helped me a lot!. Thanks for your help!. OK, I'll try it out.\nBTW, RAC's documents seems to be too \"abstractive\" for me to understand. I'm currently adopting RAC's pattern hardly by viewing code in some open source projects (e.g. kickstarter/ios-oss). @andersio Where do you suggest that I can get some best practices (in using RAC's types and operators) from?. ",
    "mbrandonw": "Ha, looks like it! Only thing is it would be just testing the reactiveswift sha we're pinned to so it might still be nice to have them target your master?. ",
    "asDButcher": "@andersio My problem is I need to manually assign the initial value by swap method, the observer(MutableProperty) only get updates after the value of self.birthdayDate changed, but I need it update once when init.. @andersio Alright, then what I need to do is use DynamicProperty instead of MutableProperty?. @andersio The self.birthdayDate is a MutableProperty and it will accepting value from NSManagedObject, now I know the problem, thanks.. ",
    "alex-chan": "I found the reason: provider has been destroyed after the function called, so as SignalProducer. any suggestion how to make the lifetime of SignalProducer longer?. Well, thank you! it works. ",
    "tikitu": "Typechecks and my tests pass! Thanks @ikesyo, and I'm learning by studying this too. If you want SO cred I'll happily accept this as an answer over there too.\nIf I understand correctly, this assumes the .disabled case will never occur. Just for interest I wonder if this is (multithreading-)guaranteed, or just very unlikely?. I think I can answer my own question: if add is enabled when we call apply() but disabled by the time we call start(), we'll hit the .disabled case: in that case I think we'll report success (no values, but .completed) on the outer Action, instead of the disabled we should be getting. It's good enough for me, but I still wonder if there's a way to do this \"properly\" -- possibly not, as I guess it would require access to private internals of Action.. And for completeness: I ended up with the following, which I think improves slightly on the correctness of the original solution (by checking if add.isEnabled at start() time as well as apply() time). (It does double apply() work, but that shouldn't trigger side-effects I believe. Avoidable with @autoclosure I expect, if it worries you.) Drive-by readers please note I'm no expert, so write your own test cases.\nfunc firstEnabledAction<Input, Output, Err>(\n    _ first: Action<Input, Output, Err>,\n    _ second: Action<Input, Output, Err>) -> Action<Input, Output, Err> {\n    func whenDisabled(_ producer: SignalProducer<Output, ActionError<Err>>,\n                      fallBackTo fallback: SignalProducer<Output, Err>) -> SignalProducer<Output, Err> {\n        return producer.flatMapError {\n            switch $0 {\n            case .disabled:\n                return fallback\n            case .producerFailed(let inner):\n                return SignalProducer(error: inner)\n            }\n        }\n    }\n    return Action(enabledIf: first.isEnabled.or(second.isEnabled)) { input in\n        return whenDisabled(first.apply(input), \n                            fallBackTo: whenDisabled(second.apply(input), \n                                                     fallBackTo: .empty))\n    }\n}\n\n. Whoah, quick response! Thanks, I'm glad the problem is going away (and I definitely should take a look at the plans for 2.0, sounds interesting).. Good enough for me! I'll try to put together a PR this week: even if it's not accepted, I hope it will be useful to work through a concrete use case.. @andersio I think this is ready for you to take a look: I don't expect it to merge as is, but I hope it prompts fruitful discussion.\nI made use of the following internals that I couldn't have reached from an out-of-file extension:\n Action.executeClosure (to get SignalProducer<Output, Error> instead of SignalProducer<Output, ActionError<Error>>).\n Action.state to update the outer Action with any update to the inner ones.\n ActionState.isEnabled: this isn't strictly necessary, since one could use Action.isEnabled instead, but it's tidier to ask the inner states directly, since we're using them to synchronise updates.\n ActionState.isExecuting to ask whether the inner states are executing: I extended this to allow outer.isExecuting to depend directly on the inner states (so that running an inner Action can mark the outer one as executing) as well as on the outer Action being run directly. Again, reading this isn't strictly necessary (because we could use Action.isExecuting) but writing into it is.. Oops, and I only now see #400: definitely relevant, although I don't understand the consequences 100% yet.. Funny, Action(first:then:) is the one I added only because it seems obvious to me (actions are function-like, so surely somebody will want to compose them?) -- I don't have a concrete use case myself.\nMy use case for Action(either:or:) is similar to #309; I'm guessing I could apply a similar refactoring to your suggestion there. I have a button that triggers either \"add a favstar\" or \"remove the favstar\": those were distinct Actions but I think combining them as you suggested in #309 will be an improvement: thanks!\nThe use case for Action(enabledIf:wrapping:) is: I already have an Action that does the right thing, but I want to disable it in more cases. This is a recurring pattern for me. I write a service like \"make an authenticated network request and parse the result\" as an Action<URL, SomeOutputType, NetworkError> which is enabled when it has authentication credentials. Then often I want to wrap some additional model-level or even view-level conditions around it: enabled only if some model object, or even some view-model, allows it. (Concrete example of the second: the underlying action is \"send a message\", and it's reused and wrapped into \"resend a failed message\" which is only enabled when the view-model records that a send attempt has already been made and has failed.) It's always possible to push this logic down into the underlying Action, of course, but I'd prefer to use small, compositional building blocks.. The only piece of internal structure that I had to expose is hooking into Action.isExecuting. I think a tidier abstraction would expose more though.. ",
    "cstars135": "Property received 3\nSkip-Repeats property received 3\nwhy not this order ?  I don't get it.. ",
    "Tibbs": "@andersio and @ikesyo Thank you for your help. It is much better now but still fails with the following error:\nPlayground execution failed: error: /var/folders/y4/3xk57cbn7f3927lr9jjrt9hm0000gr/T/./lldb/1768/playground11.swift:4:8: error: no such module 'ValidatingProperty_PageSources'\nimport ValidatingProperty_PageSources\n. ",
    "plivesey": "Is there a workaround for this? I'm using Xcode 8.3.2. I tried on master and got:\nerror: no such module 'Result'\nI then tried reverting back to 1.1.3: $ git checkout 1.1.3. I'm still getting the same error.. ",
    "MattNewberry": "@plivesey I had this same problem as well... I eventually discovered you must open the playground from within ReactiveSwift.xcworkspace, rather than opening ReactiveSwift.playground directly. . ",
    "n8gray": "FYI, I had the error: no such module 'ValidatingProperty_PageSources' problem with the ReactiveSwift-UIExamples playground and fixed it by adding import Foundation at the top of FormView.swift.\n. ",
    "abhikp": "+1 tol @n8gray . ",
    "devSC": "I clone the lastest project then have the error: /var/folders/p3/3ypxc_bd6wb761_tllb4qldc0000gn/T/playground27-60762a..swift:4:8: error: no such module 'ValidatingProperty_PageSources'\nimport ValidatingProperty_PageSources problem when i use Xcode 9.0.1 how can i fix this?. ",
    "samwize": "I had build errors in UIKitExtensions.swift. Looks like Signal has deprecated it's old init. I change the code to as follows:\nextension Reactive where Base: UISwitch {\n    public var isOnValues: Signal<Bool, NoError> {\n        return Signal { observer, lifetime in\n            let target = CocoaTarget { observer.send(value: ($0 as! UISwitch).isOn) }\n            base.addTarget(target, action: #selector(target.execute), for: .valueChanged)\n//            return AnyDisposable { _ = target }\n        }\n    }\n}\nChange similarly for UITextField extension too. Build ReactiveSwift again (make sure without errors) and playground should run.. Fixed the problem. Check https://github.com/ReactiveCocoa/ReactiveSwift/issues/403#issuecomment-356863058. ",
    "brow": "\nShould it be promote(_:) though?\n\nSignalProducer<Never, FooError> is sometimes useful, so maybe it will eventually be desirable for ReactiveSwift to define a promoteValues along with promoteError? I've done that in my project.. Is there a reason you need state to be MutableProperty instead of Property? If not, then how about...\n```swift\n  func reducer(state: State, action: Action) -> State {\n    // ...\n  }\nlet actions = MutableProperty(nil)\n  let initialState = State()\n  let state: Property = Property(\n    initial: initialState,\n    then: actions.signal\n      .skipNil()\n      .scan(initialState, reducer))\n. Fleshing that out with effects:swift\n  func reducer(state: State, action: Action) -> State {\n    // ...\n  }\nfunc effect(state: State, action: Action) -> Effect {\n     // ...\n  }\nlet actions = MutableProperty(nil)\nstruct ScanState {\n    let state: State\n    let effect: Effect?\n  }\nlet initialState = ScanState(\n    state: State(),\n    effect: nil)\nlet scanState: Property = Property(\n    initial: initialState,\n    then: actions.signal\n      .skipNil()\n      .scan(initialState) { scanState, action in\n        ScanState(\n          state: reducer(\n            state: scanState.state,\n            action: action),\n          effect: effect(\n            state: scanState.state,\n            action: action))\n      })\nlet state = scanState.map { $0.state }\n  let effects = scanState\n    .map { $0.effect }\n    .producer\n    .skipNil()\n``. Ah, yep, my suggestion is tangential to your deadlock problem since it doesn't give an alternative way of feedingeventsback intoactions`.\nI can't explain off the top of my head how your actions binding is leading to deadlock, but if I were trying this from scratch I'd avoid the MutableProperty and the self-binding altogether by doing something like this:\n```swift\n  typealias Effect = SignalProducer\nfunc reducer(state: State, action: Action) -> State {\n    // Implement me\n    return state\n  }\nfunc effect(state: State, action: Action) -> Effect {\n    // Implment me\n    return .empty\n  }\nlet (actions, actionsSink) = Signal.pipe()\nstruct ScanState {\n    let state: State\n    let effect: Effect\n  }\nlet initialState = ScanState(\n    state: State(),\n    effect: .empty)\nlet scanState: Property = Property(\n    initial: initialState,\n    then: actions.scan(initialState) { scanState, action in\n      ScanState(\n        state: reducer(\n          state: scanState.state,\n          action: action),\n        effect: effect(\n          state: scanState.state,\n          action: action))\n    })\nlet state = scanState.map { $0.state }\nscanState\n    .producer\n    .flatMap(.merge) { $0.effect }\n    .observe(actionsSink, during: lifetime)\n``\nYou can then useactionsSink.send(value:)to kick off an action imperatively.. Given that we're definingtypealias Effect = SignalProducer, it seems like you could accomplish (2) just by sending multiple values (Action`s) on the produced signal over time. Is that right?\nAs for (1), is there a meaningful difference between (a) an Action that produces multiple Effects and (b) an Action that produces a single Effect that sends multiple Actions?. You can shorten .map { _ in return } to .map { _ in } for convenience \ud83d\udc81. Instead of\u2026\nswift\nmyProducer.flatMapCompleted { replacementProducer(getInput()) }\nHow about\u2026\nswift\nmyProducer\n  .then(SignalProducer(getInput))\n  .flatMap(.latest, replacementProducer)\nThis uses SignalProducer.init(_ action:), which \"creates a producer for a Signal that immediately sends one value, then completes\". The value is constructed lazily using action, which has type () -> Value. . That line alone does not imply a retain cycle. Where in your code is this line?\nWhy is the explicit self. required? Is this inside an escaping closure?. Why do you suspect that this line is responsible for the retain cycle?. Ah, thanks for the details. I cannot think of a case where replacing\nswift\nobservation += self.viewModel.someViewIsHidden.producer.startWithValues { [weak self] isHidden in\nself?.someView.isHidden = isHidden\n}\nwith \nswift\nself.someView.reactive.isHidden <~ self.viewModel.someViewIsHidden.producer.map { $0 }\nshould cause self to be retained. Perhaps someone else has ideas?. Is x.void() equivalent to x.map { _ in }? What are the advantages of writing the former instead of the latter?\n\ud83d\udc4e skipError\n\ud83d\udc4d merge(with:). Yes, this is intended:\n\nMost operators will propagate interruption immediately, but there are some exceptions. For example, the flattening operators will ignore interrupted events that occur on the inner producers, since the cancellation of an inner operation should not necessarily cancel the larger unit of work.\n\nAlthough it is not explicitly stated in the documentation, I believe interrupted is intended specifically for ramifying cancellations that result from the disposal of a signal or producer, not for modeling domain-specific notions of cancellation.\nCould your cancellation be modeled as a failure or completion?. @MithunMadhav1112 You can add also an extension like this in your own target:\nswift\nextension Reactive where Base: CALayer {\n  public var borderColor: BindingTarget<CGColor?> {\n    return makeBindingTarget { $0.borderColor = $1 }\n  }\n}\nAnd then you can write:\nswift\nsomeLabel.layer.reactive.borderColor <~ something. How are you using MutableProperty<()>? I am curious because I have none of those in my codebase, in view models or elsewhere.. Ah, thanks for the example. In my own projects, I do something like:\nswift\n//ViewModel.swift\nprotocol ViewModelInputs {\n    var viewDidAppear: () -> () { get }\n}\n// ViewController.swift\nself.reactive.viewDidAppear.observeValues(viewModel.viewDidAppear)\n(I'm assuming your reactive.viewDidAppear is a convenience method for reactive.trigger(for: #selector(viewDidAppear)).)\nIs that equivalent? Do you see one form as preferable to the other?. Possibly relevant: https://github.com/ReactiveCocoa/ReactiveSwift/issues/78. Are you aware of SignalProducer.flatMapError? That can swallow an error and replace it with a new producer, which can send zero, one, or many values.. Relevant: https://github.com/ReactiveCocoa/ReactiveSwift/pull/508 and https://github.com/ReactiveCocoa/ReactiveSwift/pull/538.\n@andersio said:\n\npthread_mutex_trylock somehow returns EAGAIN on 32-bit ARM devices when the mutex is configured to be error checking. It should either succeed or return EBUSY according to the documentation.\n\nMy reading of the documentation is the same: that EAGAIN should only be returned for recursive locks (ones with mutex type PTHREAD_MUTEX_RECURSIVE). But I think you are suggesting that we could remove that assumption and treat EAGAIN as equivalent to EBUSY?. One thing I'd appreciate about the free functions is that they'd autocomplete in Xcode.\nSince .init(value:\u2026 doesn't autocomplete, I usually type SignalProducer.init, and then sometime later have to comb through my code and delete the extraneous \"SignalProducer\" (if I even remember to).. I'm curious about this, too!\n\nI was just going to implement my own tapSignal extension for UIBarButtonItem\n\nAre you aware of Reactive<UIBarButtonItem>.pressed?. Neat, I hadn't heard of these forums before. What benefits do you envision from this project having a forum on swift.org in addition to its existing GH Issues and Slack channel?\nI found this general answer to that question:\n\n\u2026this category is here as a service to Swift projects that want an established forum for project-specific discussion. By hosting discussion here on the main Swift forums, you make participating in your project more approachable for people who are already engaged in the Swift community, and of course you avoid a lot of the pain of hosting a forum yourself. But having discussions here is also a great way of introducing more people to your project: someone visiting these forums for a completely different reason might start exploring and find your project's topics in this category, or they might see your posts in the front page's recent activity list.\n\nhttps://forums.swift.org/t/introducing-your-project/12861. For questions, we've historically encouraged people to use GH Issues with the \"question\" tag, and I know that some ReactiveSwift contributors answer questions under the \"reactive-swift\" tag on Stack Overflow. I only answer questions occasionally, so maybe someone else can testify to whether that's working well or not.. \ud83d\udc4d I removed this line and another one like it.. It looks like EAGAIN will be silently allowed when DEBUG, but will lead to an assertion failure when !DEBUG.\nI wonder if it should be the other way around? I usually set DEBUG in builds where I want more assertions.. ",
    "leonid-s-usov": "People, I think you are here talking about pure beautiful \".then\" semantics of a Promise. Anything else will look awkward.\nWhere are promises? Why is it not a part of this amazing library??. I am already desperate.. monitoring the topic in general for more than 6 months already. I very much need pure promises in my code base, cause dealing with Signals and SignalProducers is just not OK.\nJust request.then { map($0) }.then { consume($0) }.catch { ... }. Isn't this beautiful? Definitely better than .flattenMap(.Latest /*.Merge? .Concat?*/) { map($0) }.startWithResult { ... } And not that hard, as well - at least for minimal support.\n10 time already have I almost added PromiseKit or some other promise library just for the sake of that code clarity, but every time decided not to, since putting another library which essentially does the same thing but with different syntax is something I can't afford.\nGenerally would be great to fully support the Promises A+ specs, but starting with something simple but robust and part of the core library covered by tests - that would be amazing!. Looks awkward, but maybe we could introduce here PromiseProducer which is cold ~and subject to replayLazily()~ ? Because Promise should be warm - well, if we are going for that name. Hopefully we are. You know, the one having .then() method ...\nEdit: sorry about the replayLazily() above, it's not relevant here. I was thinking about \"retry\" semantics when added that note. tl;dr: I would be happy to help with the Promises A+ layer over RAS. \nTo be honest, it still takes me a minute every time I get to choose between the latest, merge and concat, usually after some time of working on other, not reactive parts of my code. But I do know the difference and can always deduce the correct value eventually. I am actually using .latest for the situations.\nMy problem is that whenever I am trying to reinvent this Promise.then wheel with pure ReactiveSwift, neither of the values feel natural, because in this case I am not expecting to have multiple mapped producers! \nAnd, reviewing the code of my colleagues I can see all three strategies (well, mostly two, the .latest and .merge) being used, and all of the variants actually working.\nThe actual .then operator is very much not what I need in the cases: it doesn't map the value of the signal it's applied to. This renders to two major problems: it doesn't receive the value as a parameter and it is required to have the same value type as the signal it's applied to. Actually I don't remember a single place where this operator was useful to me (just a side note, nothing personal).\nI am actually having this task on my todo - implement a wrapper for ReactiveSwift having the Promise semantics. But you know, before getting there (which would be a fun task for sure) I was hoping that someone already did that or at least was planning to.\nHowever I thought that such layer, if implemented \"from within\" RAS, could benefit from access to the internals of Signals and SingalProducers. Well, this is just a guess, I haven't yet actually played with this.\nLastly, I am not sure what you meant by \n\nI don't think the inclusion of .once would sort your problems\n\nI think it actually would be one step closer as that would give me (and anyone else) a special flatten strategy for the \"promise chaining\" use case, maybe even with some assertions to guard the \"single event\" expectation. It would be just disappointing to me because this route doesn't look like anything which would lead to the promises API\nSo, I'm totally for any initiative into the direction of having a well tested and concise Promise-like API on top of RAS. I've seen PromiseKit actually created a testing environment where they run the original JS A+ test suite on their implementation, isn't that cool?!. OMG thanks much!. I still see how any implementation would benefit from .once flatten strategy. What about a Promisor? Or Promiser... ;)\nStill I can't easily get away from the kind of warm object which would actually hold the signal, and then eventually the result of the operation until the end of its lifetime. I mean, if we only have the cold one shot, then one would need to use some other layers to pass this eventual result on to consumers, if we want that the work is done on the background while we are sending the \"yet to be prepared\" result promise to all the interested parties. To me that's one of the important reasons to search for the kind of interface.\nLet's be specific and take a simple example of a network request. I have some function inside some MyAPI class, called getRecentMessages(userId: String, limit: Int). If that one returns a cold OneShot object, then probably I'd need to change this method to\nfunc configureGetMessagesWithParameters(userId: String, limit: Int) -> OneShot<[Messages], APIError>\n\nWhat would my code look like?\nlet request  = MyAPI().configureGetRecentMessagesWithParameters(userId: user.id, limit: 100)\nrequest.executeWithResult { ... }\n\nWell, this is not anything better than what I can achieve with SignalProducer today.\nBut let's say we can now flatmap it nicer\nlet loginAndGetMessages = MyAPI()\n    .configureLogin(username: \"peter\", password: \"pan123\")\n    .then {  MyAPI().configureGetMessagesWithParameters(userId: $0.id, limit: 100) }\nloginAndGetMessages.executeWithResult { ... }\n\nFor that only... I'd be better off with the .once flatten strategy and that's it. \nIf we are for some actual development around this, I'd want to get rid of these ugly \"configure\" methods. I want to call\nlet user = MyAPI().login(username: \"peter\", password: \"pan123\")\nlet messages = user.then { MyAPI().getRecentMessages(userId: $0.id, limit: 10) }\nuser.thenOnScheduler(UIScheduler()) { [weak self] in self?.updateUser($0) }\n\nDid you notice? I have used the user \"promise\" twice, but I didn't want it to login twice. So, how do we achieve this with a cold entity only?\nI would agree that a cold entity can bring many useful things but we'd still have to have some promise-like thing that this cold entity resolves to. Just like SignalProducer resolves to Signal, this Promisor should make a Promise. Or whatever we call those things.. Maybe, it's not the cold object that we are lacking, but rather this Promise-like container which accepts a SignalProducer or a Signal in constructor, keeps the internal state of whether it has ever received the value or not, and supports the \"then\" semantics? Because, all the higher level tricks around replays and stuff can simply be done on the passed-in SignalProducers.\nAs its second task, the object may give the users some syntactic sugar to conveniently create a promise with a setup function which doesn't receive an observer, but rather some resolve callback.\nQuite what the guys at OMsignal did in their ReactiveFuturesKit. Just don't pay too much attention to the class names there, the Promise they have used is very misleading. Their actual 'OneShot' class is the Future. Some highlights taken from Future.swift:\n\nthe essence: \nself.futureProducer = signalProducer.take(first: 1).replayLazily(upTo: 1)\nthe reason we are on this thread (note the strategy used): \nlet transformedProducer = self.futureProducer.flatMap(FlattenStrategy.concat) { ...\n    . IMO Single, being a nice name on its own, would be a nightmare to spot between Signals in my interfaces..... @mluisbrown \nRegarding your example, could you please address the following questions / concerns I have risen above:\nHow does Single manifest its \"coldness\"? \nWhen exactly does the action behind loadUser actually \"fire\", with loadUser representing a cold entity?\nImplicitly inside .then implementation? \nOr are you missing some .execute(onError: {...}) at the end?\nthe proper convention to the naming of methods which would return Single\n(should it be .getUserLoader(...) -> Single<User, Error>\nhow would I reuse the results of the loadUser to also update my UI once it's loaded, without actually logging in / loading again?. @liscio, I think you did a great job at bringing the discussion back to the topic. Given the title of this issue, I would agree with you that there doesn't seem to be much benefit from having another cold entity acting mostly like SignalProducer. \n\nI personally came here in search of a solution to places where Promise semantics would make much more sense than returning SignalProducers\n\nAs you, I'm dealing with the existing capabilities of RAS just fine, but to me it does feel awkward to have my APIs and many other interfaces named and treated like someGetOperationWithParameters, which has to be started and replayed where necessary\nAnother place where I felt uncomfortable is the flatMap(.latest).  I really regret now that .once FlattenStrategy pull request was closed, as that would be the efficient and unambiguous way to chain single event producers. \nHowever the same could be achieved with some other syntax, like by defining a separate operator  chain (or chainFirst or chainSingle), which BTW we do have in our other project as an extension.\n\nSo, I was here to bring Promise into RAS, but you might be right, and this could be a wrong approach. And if not that, then what else would the \"stream of one event\" be which is not already a SignalProducer?\nI will however invest some time into exploring whether there's some nice way of \"terminating\" a Signal(Producer) with a Promise-like Thenable entity, in a concise and unambiguous fashion.\n. @liscio working on something pretty close to that, but I disagree with two things:\n\nYou suggest wrapping a SignalProducer with a class called Async, then you suggest adding then, map and so on - effectively making it behave and quack like Promise - but you still insist that it's not the way to go\nYour use of Promise here is misleading, because Promise is a Thenable in the first place, and you only use it as a struct to hold the resolve and reject methods.\n\nBut in general I feel more or less on the same page. Let me just clear up these nasty type errors and I'll show a preview of what I mean.. OK people, please check out this draft #664\nInspired by PromiseKit\nSome highlights:\nstruct Promise<Value, Error: Swift.Error>: Thenable, SignalProducerConvertible {\n\n```\nextension SignalProducer {\n    func makePromise() -> Promise {\n        return Promise(producer: self)\n    }\n}\nfunc add28(to term: Int) -> Promise {\n    return Promise { fulfil, _ in\n        fulfil(term + 28)\n        return AnyDisposable()\n    }\n}\nlet answer = SignalProducer(value: 14)\n    .makePromise()\n    .then { add28(to: $0) }\nanswer.await { (result) in\n    print(result)\n}\n```\n```\n\nfulfilled(42)\n```. @andersio \nAlthough I can definitely see some points around having a Single-like specialisation of SignalProducer, I still think that it should go together with its warm Promise-like counterpart. \nRxJava has Single.toFuture()\nCorrect me if I'm wrong, but RxSwift doesn't have too many goodies around Single, it's just throwing if the underlying observable is not keeping the \"single value\" contract, which IMO is just not enough to add the class to the API in the RAS case.\n\nBTW, what do you think about ValueProducer and Value for the one shot specialised SignalProducer and Signal, having the Value actually behave like Promise?. Async tells nothing of whether it's a cold or warm entity. Also, it lacks the subject. If it was at least AsyncValue\nAnd here again, I think that AsyncValueProducer and AsyncValue pattern could be well fitting the RAS type family\nBut, following the Property class name I personally like the simple Value and ValueProducer. Cause the async nature is kind of assumed if we consider the fully qualified name of ReactiveSwift.Value(Producer). @liscio \n\n@leonid-s-usov Sorry, I was operating under a more \"complete\" Promise definition that also includes a Future type. Something more like what's defined in swift-nio: https://github.com/apple/swift-nio/blob/d31f4a249a2c7eef373f044e781b2f89f7e5e64d/Sources/NIO/EventLoopFuture.swift#L150.\n\nWell ok, another implementation which decided on such term usage (which I find less complete). Splitting roles between \"Future\" and \"Promise\" this way is not something I personally can get along with, but that's subjective, of course.\nI believe it's totally incorrect, since Promise and Future are different names for the same concept, and whether one or another is chosen, it should be an entity providing all features: the await/chain interface and the resolve interface.. @liscio \nI totally follow the motivation behind both Future and Promise, what I'm actually against is mixing them in one implementation. Historically both of these were designed as fully independent concepts so I tend to stick to that... But enough of that.\nReactiveSwift.Async<Int, SomeError> is cool, agreed. \nHowever ReactiveSwift.AsyncValue<Customer, NetworkError> isn't that bad as well, IMO\nWell, the question about the cold / hot nature of the entity has been risen above, and not originally by myself. If you followed this from the beginning I was all for the warm entity - that is, the one where the operation starts behind the scenes and we can just consume the result.\nHowever, following comments from @andersio I agree that it would be great to have control - when needed - over when the background operation actually starts, and that would be pretty much in line with the current interplay between SignalProducer and Signal. This clarity is actually stated as one of the major concepts behind RAS, so I don't quite understand why you say its so unimportant. Hope that it's not just because of the naming.\nAnd Single... c'mon, I believe we can do better than that. We all seem to agree here that having this kind of functionality in RAS is a good thing, but I'd avoid such clash in class names, especially given that RAS has so few of the core classes for now.\n. I think you are missing some points, let me continue your list\nWe want code clarity when the returned producer will only fire once or fail\nThere is no way to achieve this today. Interfaces are either semantically incorrect\nfunc getMessages(userId: String) -> SignalProducer<[Message], ApiError>\n...\napi.getMessages(userId: \"123\").start()   // why start??\nor ugly\nfunc configureGetMessages(withUserId userId: String) -> SignalProducer<[Message], ApiError>     // (x_x)\n...\nlet messageGetter = api.configureGetMessages(withUserId: \"123\")  \nmessageGetter.start()\nWe want a clearer (and more efficient) flattenMap strategy when chaining streams of single value\nThe \"correct\" answer to this today is to use flattenMap(.latest) { ... } which is counterintuitive when you are thinking about single value streams\nWe  (well, at least myself, a user of RAS) want a promise like functionality to avoid adding another library; to have interoperability between the provided promise and SignalProducer/Signal to utilise convenience functions and natively convert between interfaces within one framework\nWell, a lot has been said about this one. Even a Promise draft.\nWe want other single value oriented operators, which would be more efficient, readable and safe for this common use case of real life reactive programming\n(@andersio please help me here)\n. Well, my point is that all of the methods above should have been called \nfunc messagesGetter(forUserId: String) -> ...\n\nwhich would make my OCD happy and I would know that whatever value returned is a \"generator\" which must be activated before any values are to be expected\nIn contrast, what I would love to have is \nfunc getMessages(userId: String) -> Async<[Messages], ApiError>\n\nwhere the returned value actually represents the result - but in this case, an asynchronous one. Or maybe, by the time we got to check it, the result could already be there. Or, it was returned from cache and can be used straight.. > Regarding a new flattenMap strategy, I think that's a separate issue. If we get a new type that provides clarity, then we shouldn't need alternative strategies for the existing types.\nIt used to be a separate issue, but was closed in favour of this one. @andersio So it looks like few people already agree that from the api consumer perspective a simple cold Single type alone will not be worth the trouble, even if we take into the consideration some added benefits to the api producer.\nHowever IMO it will make much more sense if it will come with its warm promise-like counterpart. For the sake of this message let me temporarily pin the names: what you previously referred to as \"cold Single\" i'll call AsyncValueProducer and its warm counterpart (with benefits like caching the value and Promise semantics) - an AsyncValue\nWith these in place we can focus on using the AsyncValue in cases where a simple asynchronous api response is needed (or similar tasks), and AsyncValueProducer may be used to receive a number of things which are served cold: replay and retry and probably something else I can't remember now.\n. I wonder what this silence means.\nMaybe this topic should be re-launched from scratch in a new issue, with some summary of this discussion like the one we had few messages above?\nCause I doubt there will be anyone with enough courage to go through all 40 verbose comments.\nWDYT?. Please check out the new issue #667. I really hope it will facilitate the resolution of this thread - whatever the final decision will be.. There's another POC implementation I've posted in #668 . Anyone?. @jjoelson thanks for the feedback. \nIf you don't mind, let's continue this discussion in #667 . That is a new issue I have created as an essence of this thread, and it has a convenient list of all properties of the potential new API. I will copy this comment there.\nI would agree with on/when, but start / await have different meaning in terms of the expected number of invocations. Also, await has a side effect of actually starting the producer if called on an instance of AsyncValueProducer, but doesn't start anything if called on AsyncValue.\nHaving that said, personally I'm not married to any naming. My only strict criteria is that I believe if we choose to change something we need to be consistent and not create a mixture of patterns. \nI think that if there is any functional difference in otherwise similar methods, these methods should be named differently. . @RuiAAPeres WDYT?. The SignalProducerConvertible is there to be able to use all those convenience functions defined to accept objects adopting this protocol. At the end of the day, the Promise is built on top of a producer and can easily become one for the sake of polymorphism.\nIt's strange that this simple compliance is changing your attitude. It's pure convenience. \nIn any case, one may always want to convert a \"OneShot\" entity to a SignalProducer, so why not manifest this with the \"Convertible\" interface?. Sorry, I still can't see what it changes. How can the fact that Promise is convertible back to SignalProducer compromise its simplistic API?\nLet's for a moment remove this compliance. Do you agree that there should be a way to create a SignalProducer out of a Promise, given that these two are part of the same framework? Just like you have this ability with Signal and Property, both can be rendered into a SignalProducer.\nIf yes, then that's it, you take a Promise, convert it to a SignalProducer and you have the same pandora box. So what is different if there is no explicit conformance to SignalProducerConvertible?\nI mean.. I don't really mind consider removing that protocol, I just want to understand. And it's a pity to hear that you \"completely misunderstood my original intention\", cause I feel like I have achieved exactly what I wanted. I have a promise now, I can construct it from scratch or convert a SignalProducer to it, I have the promise-like behavior and there's nothing that stops me from even implementing the Promises A+ (apart from the time, of course)\n. See a POC implementation at #668 \nUsage highlights\n```\nvar seed = 0\nlet seedProducer = SignalProducer { obs, _ in\n    obs.send(value: seed)\n}\nlet value = AsyncValueProducer(seedProducer)\n    .map {\n        // try changing the below between AsyncValue and AsyncValueProducer\n        AsyncValueProducer($0 + 10)\n    }\n    .when(ready: { print(\"resolved with value ($0)\") })\nprint(\"incrementing seed\")\nseed += 1\nprint(\"awaiting result\")\n    value.await(notify: { print(\"await notified with ($0)\") })\n```\n. @jjoelson wrote:\n\nIn #668, it seems the example would look almost exactly the same with a SignalProducer except the need to provide a flatten strategy is gone, on has been renamed when, and start has been renamed await. Isn't a major goal of a framework like ReactiveSwift to have a common vocabulary of types and operators that can represent streams of values over time? Bracketing off a particular subset of use cases and changing all of the names seems counter to the mission as I understand it.\nThe ability to have flatMap without a flatten strategy is a real gain, and I'd like to understand what other improvements like that can be had by introducing a new type to represent a single value stream. Apart from things like that, I think the public API for this new type ought to look as much like SignalProducer as possible.\n\nI would agree with on / when, but start / await have different meaning in terms of the expected number of the callback invocations. Also, await has a side effect of actually starting the producer if called on an instance of AsyncValueProducer, but doesn't start anything if called on AsyncValue.\nHaving that said, personally I'm not married to any naming. My only strict criteria is that I believe if we choose to change something we need to be consistent and not create a mixture of patterns.\nI think that if there is any functional difference in otherwise similar methods, these methods should be named differently.. Well that was my intention in the first place, but then I couldn't work around the case with nil error.\nThat's actually a questionable decision to store it this way, other implementations chose to wrap a user error into additional error enum like\nenum PromiseError: Error {\n     case nested(error)\n     case interrupted\n}\nIn this case standard Result would do. I'm open for suggestions here - including an option to fatalError the case of interrupted / empty source producer. Which is of course not something I'd agree for ;). Yeah.. I just snatched it from PromiseKit, after reading the specs which refer to  Thenable as something separate from the Promise itself. Technically, there could be thin auxiliary classes implementing the protocol directly, without the overhead of the full Promise . Yeah, agreed. state can be made fileprivate and an extension for SignalProducer could be defined. Also it would be cleaner to make this a let property cause there's no reason in creating a new signal producer for every caller . done. I have refactored the code, and now Thenable is a type-erased ThenableType, which allows for a number of nice optimisations. ",
    "stevegomez17": "Removw blocked label.. ",
    "alexpopov": "I tried adding a buffer, \u00e0 la \nactions.signal\n//    .delay(1, on: QueueScheduler.main)\n    .withLatest(from: state.producer)\n    .flatMap(.latest, transform: effector(for:state\u30c4\n//  push to buffer in next step\n    .observeValues { [weak self] in self?.actionBufferInput.send(value: $0) }\nactions <~ actionBufferOutput // wrap buffer back around.\nBut this still seems to circularly lock everything up.\nI also tried sending to the buffer inside of the side-effecty on operator, to no avail. . This looks very good, thank you\u2014I'm new to ReactiveSwift, and even with RxSwift wasn't very good at thinking reactively. \nState does not have to be a MutableProperty, though the locking I observed seems to have come from action <~ action (which does make sense. \nI will try this in my code tomorrow, hopefully it will avoid the circular locking I observed; even if it doesn't, it is quite a bit clearer. \n(I'm sorry this turned into a Stack Overflow-style discussion) . @andersio you're right that State doesn't necessarily need to be stored\u2014though I'm not sure how I'll handle something like UITableViewDataSource methods without it, but I can deal with that later. \nI converted everything to Signals and actions <~ actions.signal[\u2026] continues to deadlock. Note that it's not infinite recursion in the stack; as long as the effector's input is mutually exclusive with its output it will not recurse that way, but it does seem like it still locks recursively. \n```swift\nactions\n    .skipNil()\n    .map(reducer(for:))\n    .scan(State(), { $1($0) })\n    .observe(stateSink)\nactions\n    .skipNil()\n    .withLatest(from: stateProducer)\n    .flatMap(.merge, transform: effector(for:state:))\n    .observe(actionSink)\n```\nHowever, one work-around (that isn't as hacky as an arbitrary delay) is if I send Actions produced by an Effector into the actionSink async (\u00e0 la DispatchQueue.main.async { actionSink.send(value: action) } it circumvents the synchronous, circular locking. I think this might be the best I'll be able to get.\nFor some extra info, this is where the deadlock happens, in Signal.init(observer:):\nswift\nsignal.sendLock.lock() // line 199 \n// Start of the main protected section.\n@brow, I also looked into bundling Effects with State; it's a good idea, but has two issues (unless I'm misunderstanding something):\n  1. It limits the design to one Effect per Action. This can be an issue since a single action may cause multiple Effects such as analytics calls and loading data.\n  2. It does not seem to allow asynchronous effects producing multiple actions over their lifetime; uploadPhoto could produce periodic progressUpdate actions followed by an uploadComplete action, which update the State and consequently the UI over the course of the effect.\nHowever, using Property instead of MutableProperty is great, I will do just that. \nThanks for all the help; the locking is by design and I don't think there's another way around this issue. Unless there's anything further, I feel that this issue can be closed. . Ah, I actually misunderstood the last 4 lines of your code; you are correct, that would work. I only realized after I had implemented it the same way myself. Thanks! . ",
    "applehawk": "In this case, Cartfile:\n\ngithub \"mylifeasdog/Facebook-SDK-Swift\" \"master\"\ngithub \"johnsundell/unbox\"\ngithub \"johnsundell/wrap\"\ngithub \"antitypical/Result\"\ngithub \"Swinject/Swinject\" \"2.0.0\"\ngithub \"Alamofire/Alamofire\" ~> 4.0.1\ngithub \"stripe/stripe-ios\" ~> 10.0\ngithub \"soffes/SAMKeychain\" == 1.5.2\ngithub \"onevcat/Kingfisher\" == 3.1.4\ngithub \"Skyscanner/SkyFloatingLabelTextField\"\ngithub \"ReactiveCocoa/ReactiveCocoa\" == 5.0.4\ngithub \"ReactiveCocoa/ReactiveSwift\" == 1.1\n\nmy Cartfile.resolved:\n\ngithub \"Alamofire/Alamofire\" \"4.4.0\"\ngithub \"BoltsFramework/Bolts-ObjC\" \"1.8.4\"\ngithub \"Quick/Nimble\" \"v7.0.1\"\ngithub \"Quick/Quick\" \"v1.1.0\"\ngithub \"ReactiveCocoa/ReactiveCocoa\" \"5.0.4\"\ngithub \"ReactiveCocoa/ReactiveSwift\" \"1.1.0\"\ngithub \"Skyscanner/SkyFloatingLabelTextField\" \"v3.1.0\"\ngithub \"Swinject/Swinject\" \"2.0.0\"\ngithub \"adomanico/facebook-ios-sdk\" \"830cc8eff7c3d4615bd4d6a8cad238bf9f17bdb5\"\ngithub \"antitypical/Result\" \"3.2.3\"\ngithub \"facebook/ios-snapshot-test-case\" \"2.1.4\"\ngithub \"johnsundell/unbox\" \"2.5.0\"\ngithub \"johnsundell/wrap\" \"2.1.1\"\ngithub \"mylifeasdog/Facebook-SDK-Swift\" \"fed643b634bfe204b65840728c0eb4868ceab21a\"\ngithub \"onevcat/Kingfisher\" \"3.1.4\"\ngithub \"soffes/SAMKeychain\" \"v1.5.2\"\ngithub \"stripe/stripe-ios\" \"v10.1.0\"\n\nAnd this is works fine! Thanks... Something wrong with Carthage I think. ",
    "gerfarfel": "Thanks for our thoughts on this. The problem with throttling just the changed values is that they can be delayed and end up showing up out of sequence with the begin/end values. I'm sure I can find a reasonable way to work around this issue, but I wanted to makes sure I wasn't missing an obviously better way to do it.. ",
    "soxjke": "I would not use Atomic for this case. Atomic will definitely fix ThreadSanitizer issues. On other hand, it's also a part of testable unit so additional complexity is added due to testing part of solution by another part of solution.\nWhile it might be good for descriptive purposes of how certain ReactiveSwift API's behave under particular test implications, I would generally change this to some kind of tests without side-effect.\nTo disclose my thought in a little bit more detailed view, let's take a closer look on what's tested here:\n1. The subject-under-test is a Signal and its contract to deliver completed event to its subscribers when its observer.sendCompleted() is called.\n2. To test this, the side effect of modifying local variable isCompleted is introduced.\n3. What we are testing now: our newly introduced side effect is applied, thus Signal's contract is executed\n4. What should we test here: the actual Signal's contract to call a closure passed to observeCompleted. For this purpose, we can pass some decorated closure to observeCompleted to verify it was called (with some retval, args, count etc.)\nThe example approach I'm suggesting is https://github.com/soxjke/Redux-ReactiveSwift/blob/master/Redux-ReactiveSwift/Tests/StoreSpec.swift#L74\nIt uses custom-made CallSpy within it: https://github.com/soxjke/Redux-ReactiveSwift/blob/master/Redux-ReactiveSwift/Tests/CallSpy.swift\nI can prepare a test PR fixing some Thread Sanitizer issues using this approach if it fits into ReactiveSwift unit testing strategy.. Thanks! I'll give it a try during upcoming week.. Coming up with linux fix \ud83d\udc4d . @andersio\nI'm starting to receive\nTest Case 'XCTestCase.MutableProperty, should not deadlock' started at 2017-10-23 08:37:59.778\nfor Linux build from Travis. Could you probably advice because I'm a bit stuck with what's going on with it.... @andersio thanks!\nI opened #544 to keep track on it. Probably, I'll run vagrant on a local machine to simulate this over weekend.\nOther than that, do you see any changes needed more for this PR?. @NachoSoto Sure, I've made overall feature history prettification and dropped also two \"Update CHANGELOG.MD\" commits as well. Hope Linux tests will succeed this time :). Probably need to re-run tests again, https://travis-ci.org/ReactiveCocoa/ReactiveSwift/jobs/291677337 suffers from the same failure as #544. @andersio also if you don't mind I suggest changes to 3 particular test case expressions within this file. From my point of view, expect.to.equal syntax explicitly expresses expectation of equality when == operator makes people get inside Nimble and look for necessary overload to make sure whether expression is not false-positive.. Sure, the idea is following:\nUsing any kind of spec + expectation/matchers framework: (Kiwi, Specta/Expecta, Quick/Nimble) I expect the following pseudo-syntax line for test assertion:\nexpect(inspectable-expression) -> kind-of-expectation(to/notTo, eventually, eventuallyBeforeTimingOutAfter..) -> matcher-expression\nAll of mentioned above frameworks provide us with some DSL to set test expectations, so as a developer I expect an expectation (sorry for tautology) to be set using DSL. With Expecta I can write expect(someInt) == 0, and it won't warn me because I can compare returned object with 0 in Objective-C. But the test flow will be wrong, because it won't verify this against any matcher. Instead I should write expect(someInt).to.equal(0), which is correct in terms of its DSL.\nSeeing expect((-DispatchTimeInterval.never).timeInterval) == Double.infinity in Swift makes me find whether its valid DSL syntax first. I get to https://github.com/Quick/Nimble/blob/master/Sources/Nimble/Matchers/Equal.swift#L172 and find that there's an implementation of == operator which makes lhs.to(equal(rhs) that I expected in the first place.\nMaybe my confusion is connected with unsafe Objective-C background, where equality comparisons could be done mistakingly with reference arithmetics, and we should disregard it, however I would still wonder why to use operator == over matcher syntax for particular equality case. Especially, if this operator is implemented by calling matcher syntax.. No problem, bringing == syntax back. I don't have that strong opinion regarding this readability case, so knowing that's just a convenience matcher makes me fine with this approach. Also, I've checked Nimble matchers README and they show using operator == for equality matcher and === for identity matcher. Thus this point might be considered resolved?. ",
    "KimSmitth": "@mdiep  Just two signal with noValue: \nvar goToCheckInPage: Signal<(), NoError>\nvar goToLogInPage: Signal<(), NoError>. Got it! Thanks!. ",
    "Unihilator": "Will give an example.. SignalProducer1() starts his job.. then the second one SignalProducer2 starting.. And in that moment we are switching to another VC. Then we can do two options: to cancel SP2 and wait for until: signal to retry SP2.. or we completing SP2 and waiting until: signal to resume signals queue.. ",
    "benasher44": "This is the case as of Xcode 9b3 (tested in Swift 3 mode).. ",
    "stephencelis": "Sure thing! One sec, gotta clone/cherry-pick.. Done! No CHANGELOG.md on that branch. I imagine that'll get tackled when merging back into master?. Is it ReactiveSwift policy to test internal properties? Happy to tack on another commit here but wanted to unblock folks who are maintaining a Swift 3.2 branch of their apps.. @jakeadams The fact that you can't really negate .never is gonna make for a very strange test \ud83d\ude05. Ah-ha! Fixing that test found a bug! fatalError on this line:\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/FoundationExtensions.swift#L96\nAdded assertions, fixed those tests, fixed the bug. Everything look good?. Looks like Travis is still running against Xcode 9 beta 2, which is causing some failures. Tests pass locally.. Seems like it could be useful utility operator! Could we chain map and skipNil here instead, or am I missing something?. @andersio Performance-wise?. Ah, I'd say reusing implementations is generally a nice benefit of FP \ud83d\ude04 Though I understand wanting to minimize locking, etc.. The Sequence.flatMap overload you're referring to (which removes nil values after transformation) is a weird one: it doesn't behave as flatMap should according to general FP laws/expectations, and it should probably be renamed compactMap. While I see creating parity with the standard library appealing, I'd rather keep things a bit more predictable within the functional expectations of FRP.. Totally! That's what I was trying to communicate \ud83d\ude05\nI wish Apple would rename the confusing standard library version to compactMap. Too late for an evolution proposal?. ",
    "jakeatoms": "I think some additional specs are in order. See FoundationExtensionsSpec. Additionally, I think the tests under this expectation are testing the wrong thing and can be fixed:\nhttps://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Tests/ReactiveSwiftTests/FoundationExtensionsSpec.swift#L108\nThey are testing negating the Double .timeInterval rather than negation of DispatchTimeInterval. Those properties already have test coverage (though one actually does not, in reality). I think adding test cases for the code change is the better way to ensure that folks are unblocked. . Thanks @stephencelis! I'm looking forward to this getting released.. ",
    "keitaito": "@andersio No problem, thank you so much for your big contribution too!. ",
    "ghost": "Oops. Apologies. I forgot to map on self.canDoThisAction's producer - i.e. I did this\nswift\ncanDoThisAction <~ SignalProducer.combineLatest(producer1, producer2, producer3).map { ... }\ninstead of this\nswift\ncanDoThisAction <~ SignalProducer.combineLatest(producer1, producer2, producer3).producer.map { ... }. ",
    "erwald": "I suspected as much. Fixed!. Not quite sure why the Linux build fails \u2013 it seems Test Case 'XCTestCase.MutableProperty, should not deadlock' started at 18:02:17.226 does, in fact, deadlock.\nBut I'm not sure how this PR could affect that. Are the tests sometimes unstable, by any chance?. Makes sense. I added the exception and reinserted the commas.. Ah-ha! Done and done.. ",
    "akashivskyy": "I'm curious \u2013 why is this an error only when building with SPM?. ",
    "tjnet": "I updated pull request. Any thoughts? \nPlease review in your free time.. Sorry for my late reply.. I deeply appreciate your review and feedback! \ud83d\ude04 \n. Thank you for your review so much! I 'll add test! . Thank you for your review ! I 'll fix . \ud83d\ude04 . I added a test that tests hitting the upto limit.\nplease see \nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/496/files#diff-9cd786f9e52e786771d96cf8c42d3befR2018. I fixed indentation.. I see. I updated description of the test. \ud83d\ude04 . I fixed indentation \ud83d\ude04 . Oh, sorry.. I 'll fix soon! . Thank you for your review and feedback. I sent pull request again. Is this correct?\n7a5b7b9. I got it.\nI 'll try to add testing of error and update CHANGELOG.\nthanks! \ud83d\ude04 . >Can we verify that the error was sent as well?\nI added test. How about this commit https://github.com/ReactiveCocoa/ReactiveSwift/pull/496/commits/73d2d4d50018252e37b4d6aff287f75af9ee0572 ?. ",
    "aehlke": "Ahh yes I must have, got it - thanks!\nI did see some references to ignoreError in ReactiveCocoa's history which is why I hadn't suspected Rex, e.g. https://github.com/ReactiveCocoa/ReactiveCocoa/commit/8c502a601cb9e9207eb389fc292a9a7a02e7d4ba\n@NachoSoto I've found it useful when I have multiple things consuming a signal where one of them takes care of errors and another doesn't need to. I get not wanting to broadly encourage it though.. ",
    "Burgestrand": "It looks like the one failed build could have been a random failure, but since I don't have write access to the repository I can't trigger a rebuild in Travis.. ",
    "czgarrett": "I'm getting the same thing.  Any update on this?. ",
    "clintzyb": "Thanks for your answer!  I got it.. ",
    "github-user32": "No worries. Thanks for the quick fix!. ",
    "nmccann": "@NachoSoto good test suggestion! Will add that shortly.. Agreed this has been a point of confusion for me recently. I\u2019ve been migrating some code to ReactiveSwift (previously was Obj-C code using ReactiveObjC) and have been trying to make increased use of chaining operators to made my code more concise, but am dealing with a library that enforces thread safety (Realm) and this has made parallelization difficult.\nIn my case even if I start a SignalProducer on a background scheduler, it seems that some operators in the chain use revert to the main thread. And using observe(on:) gets the events delivered on the right thread but some of my chained operators create SignalProducers and these revert to the main thread for some reason.\nWith ReactiveObjC I made heavy (and perhaps incorrect) usage of the currentScheduler to accomplish what I\u2019m trying to accomplish now.\nUltimately I just have a number of tasks that are each independent and should thus run concurrently but it\u2019s important that within a given task they remain on the same scheduler (or more specifically the same thread when dealing with Realm, although I understand GCD can\u2019t enforce that). \nSimilar to @jjoelson I\u2019ve found the documentation to be lacking on this topic, and would appreciate any guidance that could be provided.\nThanks,\nNoah. I'm not quite sure of the wording of this expectation. Thoughts?. I feel like that contradicts the earlier expectation - unless the reader looks at the implementation. However in my usage of Quick, I try to write expectations that could stand-alone without the implementation and still make sense.. Thank you for the help @andersio and @mdiep - I've settled on an alternative that I'm happy with.. ",
    "benji-bou": "Hey brow, \nOh yes, I did not think about building an extra layer of SignalProducer\nIt works perfectly. \nThank you \nBest. ",
    "artursDerkintis": "It's basically in a function without any closures or anything. Just plainly attaching UI to data.\n. I was debuting the code and it in Visual Memory Graph it showed that the owner ViewController is not being released and new ones are created (its like details screen for Table View). \nSo I pinpointed the issue to that line. \nAlso once I replaced that particular line with this:\nobservation += self.viewModel.someViewIsHidden.producer.startWithValues { [weak self] isHidden in\nself?.someView.isHidden = isHidden\n}\nit wasn't leaking anymore and it worked as expected.\nP.S. the observation is CompositeDisposable\nLet me know if something is unclear.\n. Well I was thinking that there's no way it could leak either, but I was wrong. . It turned out to be a problem in other place in code. Closing this. ",
    "ABeard89": "As I suspected, I just don't understand SignalProducers. I'm having a really hard time thinking reactively, especially with so little up-to-date ReactiveSwift reading material.\nI'll keep reading your examples until they click.\nThanks a bunch!. Oh wow! That\u2019s much simpler than I thought it\u2019d be. Didn\u2019t know take(untilReplacement:) was a thing, but that makes perfect sense.\nThanks a lot for your help! This was driving me nuts.. I\u2019ll try to reduce it to something reproducible.\nAs for unshared code, is there any area of the surrounding code that you think might be suspect? For example, the method for grabbing a random data item? Or perhaps what happens in the mapping closure that isn\u2019t even called?\nThe fact that it only happens sometimes (and so rarely), screams \u201crace condition\u201d to me, but I\u2019m not sure where to go from there. Also, one more fact that makes me think race condition is that this problem never happens on the simulator. It only ever happens when running on a real device.. Edit: Nevermind on this. Updated the iPhoneX, and the bug still occurs. If it's a race condition, then my architecture is likely bad. I'll try to clean up the coordinator / view model initialization flow and tighten up the configuration timing and then post again.\nPossibly a dumb question: could the iOS version play any part in this?\nThe reason I ask is the problem device is my company's iPhoneX running iOS 11.1.\nWhile I can't reproduce the problem using the 11.1 simulator, I also can't reproduce the problem on an iPhone 7 running 11.2.1.\nSo, as far as I can tell, it's either:\n1. A bug in the very low levels of iOS 11.1\nor\n2. A race condition that doesn't appear on the iPhone7 because it isn't as fast as the iPhoneX\nBefore I ask for permission to update the iPhoneX's software, is an iOS 11.1 bug a possibility?. Yes, it\u2019s bound to a MutableProperty stored as an i-var in a view model. The view controller has a strong reference to the view model.\nThe closure that isn\u2019t called simply maps the zipped tuple to a struct for the MutableProperty.. There\u2019s one other fact that I think is interesting. This very signal is triggered by two separate events:\n1. On a pull to refresh event in a collection view\n2. On viewDidAppear for the initial load\nI\u2019ve discovered that case 1 never ever fails. 2 is the problem case. Both cases simply call a method on the view model to start that signal. Since it\u2019s the same view model method, I can\u2019t imagine how the two cases could behave differently.. ~~What makes this so bizarre is I can't reproduce the problem on anything but an actual iPhoneX running iOS11. This problem doesn't appear on any simulator or any other device or iOS version.~~ (Replicated on iPhone7 iOS11)\nAnd since the problem only appears on the initial load of a main view controller, I basically have to just kill the app and restart it (or build/run with Xcode) on the device over and over again, which is a pain in the neck. And even then, it only appears about 5% of the time, so I have to restart the app about 20 times before the problem appears again.\nIt's just so weird. The composed signal never dies, but the inner SignalProducer's Observer fails to send the Value?\nIf I use the SignalProducers individually, the problem never occurs, but if I zip them together, then it's a problem. I also tried to use combineLatest as an alternative to zip, but that didn't stop the problem. And again, if I don't delay the SignalProducers in the ApiManager (to simulate network latency), then it seems ok.\nWith this type of bug, I can never be sure if something fixes the problem or simply makes it more rare.. I've tried to create a sample app to demonstrate the problem with a simple label in a view (rather than a collection view, like my app uses), but that app never shows the problem. So, I'm kinda stuck. I'm not sure where to go from here.\nWhat do you recommend we do about this? Should we close this for now and reopen if I can find a simple reproducible case?. I actually did make some progress on this. I made a sample app to help reproduce the problem. It uses a couple coordinator objects, like my app does. I left out the view models to help keep it simple and instead just did that stuff in the view controller itself.\nI put it on my github account: https://github.com/ABeard89/RASIssueTest\nThere's not much too it, just a simple label on the screen the says \"Loading...\" and then a composed signal like above changes it to \"Loaded!\".\nWhen the zipped signal fails, the screen just says \"Loading...\" and will never switch to \"Loaded!\"\nThe bug appearance rate is very low on my iPhone7\u2013less than 2%. But on the iPhoneX, it's higher. I tested repeatedly starting it with the build/run with Xcode method, and it shows up around every 10-20th time, rate of about 5-10%.\nI really hope it shows up with you. The appearance rate is low, but I swear to god it happens over here, and it's even shown up on my iPhone7 a couple times. Even if it doesn't happen with you, maybe you can tell me what I've done wrong.. No big rush on my end. Let me know if you want me to do anything.. I don't have any 11.1 devices anymore. We updates ours to 11.2. Although, I think iOS version was a red herring, since I've seen the error on iOS 9, 10, and 11 (even on 11.2) and on several different devices.. As a side note, thanks for working on this. I'm sure you do this in your spare time.\nI've since gotten a full API for my app, so I don't depend on a fix for the issue, but I'm curious to see where this leads.. The weird thing about reproducing it was it seemed to go through phases of happening very frequently to phases of almost never happening at all. But of course, maybe that's just statistically natural.. I noticed that when I removed the delay via QueueScheduler in the API manager I was never able to reproduce it. So, I was beginning to suspect that it was some kind of dispatch issue, which is far above my ability to debug.. A strange thing happened just now. It makes me think that this problem might not be in ReactiveSwift, but rather somewhere much deeper, like GCD or the Swift compiler or Xcode.\nHere's what I saw that makes me think this:\nTL;DR: Closure passed to UIKit started not being called, but then started being called again, for no reason.\nI was working on another part of my app where I'm observing signals from a view model.\nHere's a snippet of that\nprivate func listen(to viewModel: MenuViewModel) {    \n    viewModel.outputs.openPurchaseHistoryScreen\n        .take(duringLifetimeOf: self)\n        .observeValues { [unowned self] in\n            self.closeMenu() { [unowned self] in\n                self.delegate?.openPurchaseHistory()\n            }\n    }\n\n    viewModel.outputs.openCouponScreen\n        .take(duringLifetimeOf: self)\n        .observeValues { [unowned self] url in\n            self.closeMenu() { [unowned self] in\n                self.delegate?.openCoupon(url)\n            }\n    }\n\n    viewModel.outputs.openViewHistory\n        .take(duringLifetimeOf: self)\n        .observeValues { [unowned self] in\n            self.closeMenu() { [unowned self] in\n                self.delegate?.openViewHistory()\n            }\n    }\n}\n\nThis section hasn't changed in ages. This is the exact code currently on the App Store.\nThe strange thing was that in my debug builds, suddenly the last closure calling self.delegate?.openViewHistory() simply wasn't being called.\ncloseMenu was called. The menu even properly closed, but the closure wasn't called.\nI'm not sure why. I followed the closure all the way to UIViewController.dismiss(animated:completion:). The closure existed as far as I could track it, but it simply wasn't called.\nI tried cleaning the build folder, restarting Xcode, and building on another device; but nothing changed.\nWhat did work was simply changing the order of the observations in the method. (e.g. openViewHistory before openCouponScreen)\nThen every closure was called as expected, but when I put them back to their original order, the problem started happening again.\nIt simply looked like when the openViewHistory observation was last in the method, the closure passed to closeMenu just wasn't be called.\nI tried several experiments to no effect, then tried building again with the original code, and then everything magically started working again!\nThe code from when it wasn't working and when it was working are exactly the same code. But something made it either get built differently or called differently, I'm not sure which.\nHave you ever heard of anything like this? Do you think this might be related?. (I accidentally closed this just now. My mistake. Just ignore that.). Even after cleaning and building on different devices multiple times?\nIf so, thanks, Xcode... ugh. @mdiep The Swift bug is still open, so I guess this wasn't fixed for 4.2?\nWhile we wait for a Swift fix, is there a recommended workaround?. > The bug has been fixed. The ticket remains open because it's tracking the suggestion that trailing closure syntax should be disabled entirely for functions that don't explicitly take a function.\nOh, I thought I still had the problem when I tested with 4.2. My bad!. ",
    "w-k-s": "Fixed by observing on QueueScheduler.main instead of UIScheduler(). ",
    "EvgenyMatviyenko": "Yes, it makes sense to move chatDelete to chatsProvider in this example. But there are some cases when it isn't possible to avoid this.. ",
    "mishagray": "I'm seeing an issue with swift 4.1 compability and this PR:\nhttps://github.com/ReactiveCocoa/ReactiveSwift/pull/601\nBasically.. all of my my 'signal.map {  Int($0) }` is now resolving to a SignalProducer with a value that is a closure, and when I click on 'map' it resolves to the new map method from https://github.com/ReactiveCocoa/ReactiveSwift/pull/601\nNot sure how it behaves in swift 4.0, but swift 4.1 has issues.  Not sure if this is just a bug in 9.3 beta 2.  . ```\n    let fetchImage = SignalProducer(value: UIImage())\n    let optionalFetch = fetchImage.map { $0 as UIImage? }\nassert(optionalFetch is SignalProducer<UIImage?, NoError>, \"did I get the right type?\")\n\n\nlet optionalFetch1: SignalProducer<UIImage?, NoError>  = fetchImage.map { $0 as UIImage? }\nlet optionalFetch2: SignalProducer<(UIImage?) -> UIImage?, NoError>  = fetchImage.map { $0 as UIImage? }\n\n```\nSo in swift 4.0 ... optionalFetch will be the expected type SignalProducer<UIImage?, NoError>.    In swift 4.1 ... we get SignalProducer<(UIImage?) -> UIImage?, NoError>\nBoth of the 'optionalFetch1' and 'optionalFetch2' lines compile successfully in swift 4.1. Ah... so this isn't NOT related to swift 4.1.   I wrote that code above and got the same warning error on assertion line 'Cast from 'SignalProducer<(UIImage?) -> UIImage?, NoError>' to unrelated type 'SignalProducer' always fails' \nEvery line compiles in swift 4.0/swift 4.1.   I could just open this as in issue against https://github.com/ReactiveCocoa/ReactiveSwift/pull/601.   Since it's not actually realted to 4.1.\nI just first saw it in my swift 4.1 branch, but I think it's unrelated to swift 4.1\n. This PR breaks some of my existing 'map' code.\n```\n        // I have a Signal Producer of UIImage values\n    let fetchImage = SignalProducer(value: UIImage())\n    // optionalFetch SHOULD resolve as  SignalProducer<UIImage?, NoError>\nlet optionalFetch = fetchImage.map { $0 as UIImage? }\n\nassert(optionalFetch is SignalProducer<UIImage?, NoError>, \"did I get the right type?\") \n    // The line above actually gives the compiler warning: \"Cast from 'SignalProducer<(UIImage?) -> UIImage?, NoError>' to unrelated type 'SignalProducer<UIImage?, NoError>' always fails\"\nassert(!(optionalFetch is SignalProducer<(UIImage?) -> UIImage?, NoError>), \"did I get the wrong type?\")\n   // line above generates compiler warning: \"'is' test is always true\"\n\n   // Defining the type seems to get the compiler to 'pick' the right version of 'map'.   But this kind of ugly.\nlet optionalFetch1: SignalProducer<UIImage?, NoError>  = fetchImage.map { $0 as UIImage? }\nlet optionalFetch2: SignalProducer<(UIImage?) -> UIImage?, NoError>  = fetchImage.map { $0 as UIImage? }\n    assert(optionalFetch1 is SignalProducer<UIImage?, NoError>, \"did I get the right type?\")\n\n```. Not sure this was working as intended..\nGonna close this for now until I investigate more. . agreed.... yeah... I checked other places to see if we wanted to 'indent' around a #if... and it's not consistent.  I think you indent inside a class/struct definition, but idk.  I DID try and match the style here!. So I thought using some intermediate 'base' protocol would help reduce the difference between swift 4.0 and swift 4.1.  But it introduces a new public protocol name.  Not sure if this adds complexity or reduces it in the whole scope of things.\nPersonally I code go either way (new base Protocol, or an uglier #if/#endif.\nSince this is the more 'radical' answer I push it here for your consideration...\n. ",
    "mbuchetics": "What's the current status now that Xcode 9.3 and Swift 4.1 are officially released?. ",
    "gunterhager": "Interesting. You're right, i've just tested it. It seems to work with Xcode 9.4/Swift 4.1.1 beta, too. Used to fail with older Xcode 9.3 betas.. ",
    "WangMing00": "Please help me!. ",
    "ra1028": "Thanks for the feedback.\nI think it would be better to simply deemed event stream as sequence.\nDifferences in naming with Swift stdlib compromise the intuitiveness of the API.. > I think our naming convention of skip* makes a lot of sense and makes things easier for beginners and experts alike.\nskipNil applies optional-binding to values of the stream, but other skip* operators are convenience methods only to skip values by conditions.\nI think they are different.. Should I revert compact() to skipNil() ?\nWhat does the rest of @ReactiveCocoa/reactiveswift think about compactMap ?. > Maybe we can get the discoverability benefits by adding empty implementations of compact() and compactMap() with fixits that suggest the correct name (and ideally hint as to why)?\nIs that something like below?\nswift\nextension Signal {\n    @available(*, unavailable, message: \"Use filterMap(_:) instead.\")\n    public func compactMap<U>(_ transform: @escaping (Value) -> U?) -> Signal<U, Error> {\n        fatalError()\n    }\n}\nHmm, I feel not makes sense it...\nAlmost everyone seems not to agreed, so I'll close this proposal.\nThanks for the all feedbacks:+1:. Thanks.\nmap(value:) or map(to:) is seems better than void() :+1:\n\nIt encourages bad practices by simply ignoring errors. Instead, each user should implement this as they see fit\n\nYeah, definitely.\nIt's convenient, but might be better not to implement.\nmerge (with:) seems to be :+1: for majority.. > Is x.void() equivalent to x.map { _ in }? What are the advantages of writing the former instead of the latter?\nI think it makes sense for readability.\nIt's similar to relation between filterMap(_ :) and skipNil(). I added tests. Oh... \ud83d\ude47 . @andersio \nSorry, my test was lacked\ud83d\ude47 \nThat's a awesome optimization.\nI reverted it to use Iterator.\nAnd I have the one more proposal.\nI've suspected the necessity of reversed() in this line.\nI think that Disposable is disposed by CompositeDisposable(mostly Lifetime) in many cases.\nIn that cases, disposables will disposed in order from the beginning, so higher performance maybe expected if not to use reversed().\nI demonstrated it with a simple benchmark such as below.\n```swift\nfunc testRemovingByCompositeDisposable() {\n    let count = 10_000\nmeasure {\n    var bag = Bag<Int>()\n    let disposable = CompositeDisposable()\n\n    for i in 0..<count {\n        let token = bag.insert(i)\n        disposable += { bag.remove(using: token) }\n    }\n\n    XCTAssertEqual(bag.count, count)\n\n    disposable.dispose()\n\n    XCTAssertEqual(bag.count, 0)\n}\n\n}\n```\nIn this case, it has improved about 3x.\n\nAlso, I demonstrated that using first(where:) does not affect performance by the tests such as below.\n```swift\nfunc testRemoving() {\n    let count = 10_000\nmeasure {\n    var bag = Bag<Int>()\n    var tokens = ContiguousArray<Bag<Int>.Token>()\n    tokens.reserveCapacity(count)\n\n    for i in 0..<count {\n        let token = bag.insert(i)\n        tokens.append(token)\n    }\n\n    XCTAssertEqual(bag.count, count)\n\n\n    for token in tokens {\n        bag.remove(using: token)\n    }\n\n    XCTAssertEqual(bag.count, 0)\n}\n\n}\nfunc testIteration() {\n    let count = 10_000_000\n    var bag = Bag()\nfor i in 0..<count {\n    bag.insert(i)\n}\n\nXCTAssertEqual(bag.count, count)\n\nmeasure {\n    var trash = [Int]()\n    trash.reserveCapacity(count)\n\n    for i in bag {\n        trash.append(i)\n    }\n\n    XCTAssertEqual(bag.count, count)\n    XCTAssertEqual(trash.count, count)\n}\n\n}\n```\n. @andersio \nThanks\ud83d\udc4d  It's already reflected.. Thanks @NachoSoto.\n\nSo depending on what response we get to SR-6989, I might favor leaving it as map(value:).\n\nI Agreed.\nBut, If you will rename it, I think repace(value:) is better.. Thanks @andersio \nI defined the following method in ReactiveSwift/Bag.swift and benchmarked again.\n```swift\npublic extension Bag where Element == Int {\n    mutating func iterationTest() -> [Int] {\n        var trash = Int\n        trash.reserveCapacity(count)\n    for i in self {\n        trash.append(i)\n    }\n\n    return trash\n}\n\n}\n```\nBenchmark:\n```swift\nfunc testIteration() {\n    let count = 10_000_000\n    var bag = Bag()\n    for i in 0..<count {\n        bag.insert(i)\n    }\n    measure {\n        let trash = bag.iterationTest()\n        XCTAssertEqual(trash.count, count)\n    }\n}\nfunc testIteration2() {\n    let count = 10_000_000\n    var bag = Bag()\n    for i in 0..<count {\n        bag.insert(i)\n    }\n    measure {\n        var trash = Int\n        trash.reserveCapacity(count)\n    for i in bag {\n        trash.append(i)\n    }\n\n    XCTAssertEqual(trash.count, count)\n}\n\n}\n```\nResult(-Owholemodule):\n\nResult(-Onone):\n\nThe reason why it got worse performance with -Onone, maybe related to optimizations of inlining, specialization and witness table in SIL.. got it.\nthanks for reviews @andersio . oops I misunderstood.\nwill do.. @andersio \nDid you intend ContiguousArray<Element>.Iterator's wrapper struct like this?\n```swift\npublic struct Iterator: IteratorProtocol {\n    private var base: ContiguousArray.Iterator\nfileprivate init(_ base: ContiguousArray<Element>.Iterator) {\n    self.base = base\n}\n\npublic mutating func next() -> Element? {\n    return base.next()\n}\n\n}\n```\nI benchmarked the same for it.\nResult:\n\nIt's about the same performance with using ContiguousArray<Element>.Iterator directly in ReactiveSwift module, but it got worse in cross-module.\nIf ignore performance on cross-module, make Bag to internal struct is might be better.\nIn addition, I also benchmarked the following Iterator.\n```swift\npublic struct Iterator: IteratorProtocol {\n    @_versioned\n    internal private(set) var base: ContiguousArray.Iterator\nfileprivate init(_ base: ContiguousArray<Element>.Iterator) {\n    self.base = base\n}\n\n@inline(__always)\npublic mutating func next() -> Element? {\n    return base.next()\n}\n\n}\n``\nResult:\n<img width=\"264\" alt=\"screen shot 2018-02-24 at 3 53 36\" src=\"https://user-images.githubusercontent.com/7347118/36612450-036844ce-191a-11e8-885b-a10ced025445.png\">\nIt performant as same as usingContiguousArray.Iteratordirectly.\nApparently the difference in performance due to inlining.\nIt's not leaking an implementation detail, and better performance, but I doesn't recommended to use@_versioned internal`.\nWhat do you think about these results?. OK, I'll implement wrapper struct around IndexingIterator \ud83d\udc4d . @andersio \nIs that these operators and initializers?\nSignalProducer.concat, SignalProducer.prefix, SignalProducer.flatMapError, Signal.flatMapError, Signal.withLatest, SignalProducer.then, Property.init(initial:values:), Action.init(state:enableIf:execute:), Action.init(state:execute:), Action.init(enableIf:execute:), Action.init(unwrapping:execute:), Action.init(execute:). @andersio \nok\nwill make a PR separately.. @andersio \nAmended \ud83d\udc4d . @mdiep @andersio \nI added tests for check able to use contextual lookup.. e.g, want to use reactive extension for another extension host.\nDo we need to restrict to class type?\n```swift\npublic protocol ExtensionsProvider: class {}\npublic extension ExtensionsProvider {\n    var extensions: Extension {\n        return Extension(self)\n    }\nstatic var extensions: Extension<Self>.Type {\n    return Extension<Self>.self\n}\n\n}\npublic struct Extension {\n    public let base: Base\nfileprivate init(_ base: Base) {\n    self.base = base\n}\n\n}\nextension UIView: ExtensionsProvider {}\npublic extension Extension where Base: UIView {\n    func fooString() -> String {\n        return \"foo\"\n    }\n}\nextension Extension: ReactiveExtensionsProvider {}\npublic extension Reactive where Base == Extension {\n    func fooString() -> SignalProducer {\n        return SignalProducer(value: base.fooString())\n    }\n}\n```. > Either way, this is a semantic error that IMO we shouldn't account for.\nAgreed.\n@mdiep \nHow about?. oh, I forgot\nwill add it.. hmm, I was according to zip, combineLatest operator, though should revert?. done \ud83d\udc4d . gotcha, will revert them:+1:\nWrite the doc for zip andcombineLatest, will too much lines.\nI think there are pros and cons, so not to write now.. done \ud83d\udc4c . \ud83d\udc4d . will do.\nelements is used as a parameter name, so I'll addself to all.. Ah, true.. Amended:+1:. tryDispose() is a method for transitioning the state of Disposable and thinks that the result is a supplementary thing.\nHow is it?. Hmm, disagreed.\nBy returning asap, would be clarify the intention of do nothing if already disposed.. I prefer guard.\nHowever, swap may be better to useif.. I don't prefer to give meaningless variable names like d, but if the RAS naming conventions are prefer d, I'll follow it.. > By returning asap, the intention of do nothing if already disposed would be clarified.\nThis also.. Probably because the type became ambiguous than before.\nIn the test, 4 errors occur including this line.. Do you mean adding static var empty to the SignalProducerConvertible?\nI think it can't be resolved without a contextual types\ud83d\ude22 . @NachoSoto \nOne of solution is to overload SignalProducer.flatMapError as below.\nBut I don't prefer this.\n```swift\npublic func flatMapError(_ transform: @escaping (Error) -> Inner) -> SignalProducer where Inner.Value == Value {\n    return flatMapError { transform($0).producer }\n}\npublic func flatMapError(_ transform: @escaping (Error) -> SignalProducer) -> SignalProducer {\n    return SignalProducer { observer, lifetime in\n        let serialDisposable = SerialDisposable()\n        lifetime += serialDisposable\n    self.startWithSignal { signal, signalDisposable in\n    serialDisposable.inner = signalDisposable\n\n    _ = signal.observeFlatMapError(transform, observer, serialDisposable)\n    }\n}\n\n}\n. Got it \ud83d\udc4d . @andersio \nSuch protocol works to occur errors like the below.swift\nextension SignalProducerConvertible {\n    /// A producer for a Signal that immediately completes without sending any values.\n    public static var empty: SignalProducer {\n        return .empty\n    }\n}\n```\n\nTherefore, I'll overload existing operators anticipating SignalProducerConvertible.. I added an overloaded operator to flatMap andflatMapError for contextual lookup.\nIs it also necessary for other operators that will passed SignalProducerConvertible?\nIMO, there aren't many cases to pass empty directly like below.\nswift\nproducer.then(.empty). @andersio \ndone \ud83d\udc4d . @mdiep \nSorry for the late response.\nDone:+1:. ",
    "danielaRiesgo": "Yeah, I know about observeResults but the error I think is not good. I think in the previous versions you got a warning saying you should better use observeResult, but know it just tells you that there is ambiguity for signals that don't even match yours. It's strange.. ",
    "minuscorp": "You're right, I missed that the SignalProducer already has this behavior! So.. maybe we're only missing the .using operator?\nAbout the .using operator, is used rarely but it is extremely useful, as reaches a very concrete objective, explained deeply in here, it creates an observable that:\n\nThe Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates.. How do you attach the lifetime of a SignalProducer to the lifetime of another one, either Signal or SignalProducer?. take(until:) completes the attached Signal or SignalProducer upon .next or .completed events are sent from the parent resource, so I think it not covers the behavior.. No need to add anything then! \ud83d\ude04. \n",
    "zintus": "With all this in mind, are there valid use cases for modelling anything high level with interrupted event?\nTheoretically speaking, should interrupted be hidden from library users, while kept as implementation detail?. @andersio \nThanks a lot for timely response!\nYour explanation helps alot, thanks for clarification. With that in mind, does following snippet of code makes sense to you? Are there any ways to simplify this?\nIntention is to start inner producer (inside flatMap) every time there is chance that we succeed doing work (in the snippet role of such source of information carried out by .never). And terminate such process after first inner producer that completes/fails.\n```\nlet guardian = MutableProperty(true)\nlet interrupted = SignalProducer<(), NoError>.never\n    .take(until: guardian.producer.filter { !$0 }.map { _ in () })\nlet op = SignalProducer<(), NoError>(value: ())\n    .concat(interrupted)\n    .flatMap(.latest) { value -> SignalProducer<(), NoError> in\n        return SignalProducer(value: value)\n            .on(terminated: {\n                guardian.value = false\n            })\n    }\n    .logEvents()\n_ = op.collect().first()\n``.take(first: 1)` works really well if inner signal sends one value before completion (which is accidentally exactly my case)\nBut how solve this in general case? My code above was attempt to do flatMap(.latest) which completes once inner signal complete.  . Anyway, original question is sorted out, thanks for help! \ud83c\udf89. ",
    "manojmahapatra": "protocol ObservableFeatureSource {\n    var futureFeatureChanges: Signal<AnyFeature, NoError> { get }\n}\n```\nextension FeatureManager: ReactiveExtensionsProvider {}\nextension Reactive where Base: FeatureManager {\n    func monitorFeatureChanges(for feature: ApplicationFeature) -> Signal, NoError> {\n        let observableSources = FeatureManager.shared.sources\n            .flatMap { ($0 as? ObservableFeatureSource)?.futureFeatureChanges }\n        return Signal.merge(observableSources)\n            .filterMap { $0 == feature ? feature : nil }\n    }\n}\n```\nfinal class Example: NSObject {\n   static let shared = Example()\n    private override init() {\n        super.init()\n        FeatureManager.shared.reactive\n            .monitorFeatureChanges(for: .someFeature)\n            .observe(on: UIScheduler())\n            .take(duringLifetimeOf: self)\n            .observeValues({ _ in\n                debugPrint(\"print something\")\n            })\n    }\n}\n@sharplet let me know if this helps, thanks!\nPS: The same code works at other places, where it's not subclassed from NSObject.\n. sorry for the late update @mdiep. It turned out to be an internal issue and that's why the events were not triggering. closing this issue now. . ",
    "kean": "Hey! I'm new to ReactiveSwift, but I have some experience with RxSwift. I found this issue when I was looking for a reason why Property has both signal and signalProducer.\nWhat I find confusing is not the fact that Property offers signal (which kinda makes sense - you can read its initial value and the immediately subscribe to the new values, but it won't work correctly in a multithreaded environment though). What I find confusing is that Property exposes signalProducer.\nIsn't the point of SignalProducer to represent cold sequences which you start when subscribing to them (e.g. network requests, something that has side-effects)? This doesn't seem to be what's happening here. The Property always seems to be hot, even if backed by a SignalProducer (it gets started immediately upon properties' initialization if I'm not misunderstanding something). Isn't a Signal a better way to represent Properties?. @sharplet Thanks for clarifying some of those points! The Property - as you seem to agree - can always be considered hot, so it seems like a missed opportunity to fall back to SignalProducer and lose the guarantee of hotness when working with properties (which seems to happen a lot in our project!). But I understand your point about modelling replay behaviour as SignalProducer - subscribing to it does make the property emit a value (but no side effects).. ",
    "MithunMadhav1112": "So there is no way to alter CALayer properties when using ReactiveCocoa ? \n. ",
    "freak4pc": "Hey just FYI - these deprecations are coming from within Nimble itself. This isn't an issue with ReactiveSwift, so I'd close it personally:]. ",
    "Marcocanc": "@brow for example when there's a button press. It's used extensively in the Kickstarter App and I started using it since it takes less code than creating a Signal pipe.\nExample for binding viewDidAppear with Trigger :\nswift\n//ViewModel.swift\nprotocol ViewModelInputs {\n    var viewDidAppear: Trigger { get }\n}\n// ViewController.swift\nviewModel.inputs.viewDidAppear <~ self.reactive.viewDidAppear. Sure that works too, but I try to stay fully reactive when binding my ViewModels and ViewControllers, since most inputs will result in an output.. @mdiep Will do, but there's still an ongoing discussion about which lifetime to use. ~(Unfortunately I buried it by making another commit)~ I removed the commit for the sake of visibility :). I had two main motivations for this PR:\n1. When binding ViewModels that use Observers as inputs it's not very nice to have two ways of binding (<~ operator for outputs and observe* for inputs). With the binding operator the target will be on the left, whereas with observe it will be on the right.\n\nI use MVVM for UICollectionViewCells extensively. In that case I want the observer to only receive values and no terminating events (otherwise the ViewModel's pipe would break whenever the cell is reused since the binding is disposed)\n\n@andersio Here's another approach:\nswift\nextension Signal.Observer {\n    public static func <~\n        <Source: BindingSource>\n        (observer: Signal<Value, Error>.Observer, source: Source) -> Disposable?\n        where Source.Value == Value, Source.Error == NoError\n    {\n        return source.producer.start { [weak observer] in\n            switch $0 {\n            case .value(let val):\n                observer?.send(value: val)\n            default: break\n            }\n        }\n    }\n}. @andersio I have updated the PR with the proposed approach \ud83d\ude0a Sorry it took me so long. I simply copied the one from unwrapping and adjusted it to work with the ValidatingProperty. Is that ok?. I reverted the commit that fixes that in order to un-hide the discussion that was going on. Will change it again if/when we decide how to proceed with this PR.. ",
    "Ankit-Aggarwal": "@andersio : Agree with you, appended extension. :). ",
    "thundercatchris": "Hi, thanks for your help. I think Im getting somewhere with this now. But I'm getting an error \n\" Value of type 'UISearchBar' has no member 'reactive' \"\n\"Value of type 'UITableView' has no member 'reactive'\"\n```\n  let searchController = UISearchController(searchResultsController: nil)\n    @IBOutlet weak var tableView: UITableView!\n    var products = MutableProperty<[Product]>([])\n    let filter = MutableProperty(\"\")\nvar ref: DatabaseReference!\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    tableView.delegate = self\n    tableView.dataSource = self\n\n    searchController.searchResultsUpdater = self\n    searchController.hidesNavigationBarDuringPresentation = false\n    searchController.dimsBackgroundDuringPresentation = false\n    searchController.searchBar.sizeToFit()\n    self.tableView.tableHeaderView = searchController.searchBar\n\n    filter <~ searchController.searchBar.reactive.textValues.map { $0 ?? \"\" }\n\n    let filteredItems = products.combineLatest(with: filter).map { products, filterText -> [Product] in\n        if filterText.isEmpty {\n            return products\n        } else {\n            return products.filter { $0.name!.localizedStandardContains(filterText) }\n        }\n    }\n\ntableView.reactive.reloadData <~ filteredItems.signal.map { _ in }\n\n```\n@sharplet are you able to help please?. Hi yes I imported it and thought it was working, but I had made a mistake with the path I was installing it to. Please ignore that last one :S\nSo now the code is compiling. But I don't think Ive got it wired up correctly, I have the filter code in view did load. \nI have put break points in to both returns. They trigger on load, but not when I type anything in to the searchfield?\nI have also tried initialising an empty property to assign the search results to\n  var filteredItems = Property.init(value: Product)\nim then assigning to it in viewdidload\nBut as mentioned before the filter is not being triggered anyway. I have put a breakpoint in updateSearchResults\nThe breakpoint is triggering, but the filter is still \"\"\nSo I don't think the binding is working\nfunc updateSearchResults(for searchController: UISearchController) {\n    print(searchController.searchBar.text)\n}. Got it working.\n\nThanks for your help. I changed textValues to continuousTextValues and moved the code to viewDidAppear \nfilter <~ searchController.searchBar.reactive.continuousTextValues.map { $0 ?? \"\" }. ",
    "john-twigg-ck": "-Erased last message-\nI think I see how I can do it with flatMapError.\n1) map the current value to a new Value Type\n2) use flatMapError to then map the error into the new ValueType\n```\nlet producer = SignalProducer( ... ) \nenum MyStatus {\n   case success(Int)\n   case tryAgain\n}\nproducer.map { (data:Int) -> MyStatus in\n   return .success(data)\n}.flatMapError ( (error:MyError) -> SignalProducer in \n    return SignalProducer(value: .tryAgain)\n}\n```\n. ",
    "jasonboyle": "Hi @mdiep, thanks for the response.  I do want the steam's events to be delayed until the next run loop, at least those coming from valueStream in my code snippet.  However I want to combine these delayed events with non-delayed events from sampleStream.\nI've tried using .observe(on:) as follows, unfortunately without success:\nvalueStream.throttle(while: active.negate(), on: QueueScheduler.main)\n    .observe(on: UIScheduler())\n    .combineLatest(with: sampleStream)\n    .map { $0.0 }. It's using the default scheduler (created via Signal.pipe).. Ah, you're right!  The throttled valueStream was providing the same value when sampleStream fired (since it's next value had yet to arrive on the subsequent run loop).  I was able to solve my problem by using this stream to sample the original stream.  Thanks so much for your help @mdiep.. ",
    "rhysforyou": "I meant to open this on the ReactiiveCocoa repo sorry!. ",
    "mluisbrown": "I also think this is a great idea. Our codebase is littered with a convenience function which does:\nswift\nmap { transform($0).producer }.once()\nI would say that (in our codebase) maybe 50% or more of SignalProducers are single value (eg, network requests). To counter what @liscio said against this idea in #201 I think it's clearer for both someone writing code or reading it to have a distinction at the call site between single value producers and others that produce a stream of values.\nUPDATE: I also think that having Promise might make it easier for developers to transition from using Promise libraries like PromiseKit to ReactiveSwift.. > My personal stance is that we should have a cold entity, that isn't named Promise for sure to avoid confusion.\nI totally agree \ud83d\udc4d Promise would lead people to think you could use it just like a promise, which you can't. And it absolutely should be a cold entity.\n\nAs for naming, there is a dissent around \"inheriting\" the name Single from Rx (by @mdiep, @sharplet and part of @andersio). \n\nWhy is there dissent around using Single? Who cares if it's also used in Rx? I personally think Single is a perfect name, and much better than OneShot which seems like a contrived way to avoid using Single \ud83e\udd37\ud83c\udffc\u200d\u2640\ufe0f If Single is the most apt name, then surely it's only an advantage that it's already used to mean exactly the same thing in Rx?\n\nI also think that having Promise might make it easier for developers to transition from using Promise libraries like PromiseKit to ReactiveSwift.\n\nI think that having talked about Promise was perhaps a mistake and has introduced some confusion about this proposal. IMO the objective here is, as the title states, a \"Stream of one event\", not something that can be used just like a Promise. If this proposal goes ahead, it could then be used as the basis for creating a true Promise object on top of it, but I believe they are separate issues.\nAlternatively, the then operator could be overridden for this entity to provide the value, which would make it behave more like a Promise:\n```swift\nlet loadUser: Single\n// ...\nloadUser\n.then { user -> Single<[Post], NetworkError> in \n    posts(for: user)\n}\n.then { posts -> Single<[Comment]>, NetworkError> in \n    comments(for: posts.first)\n}\n``\n. How aboutOnce, instead ofOneShot` @andersio ?. @leonid-s-usov \n\nWhen exactly does the action behind loadUser actually \"fire\", with loadUser representing a cold entity?\n\nGood point. You would still have to start it.\n\nhow would I reuse the results of the loadUser to also update my UI once it's loaded, without actually logging in / loading again?\n\nUsing replayLazily(upTo:). > Anyway, this is way off-course from the original discussion now because this issue is not really trying to build a Future/Promise type, but rather a replacement for Rx's Single. \n\ud83d\udc4f \nCan we please forget about Promise and Future for this discussion (notwithstanding the naming of the prototype)?\nAs @liscio said, this issue is about creating an equivalent to Rx's Single. \n\nWhile I agree that Single / Signal might be easy to transpose while typing, I think that the strength of the meaning of Single outweighs that issue.\n\n\ud83d\udcaf \nAbsolutely agree. I don't see any reason why RAS should not also adopt the Single name. . @andersio the new test is passing without any changes to the code, so it looks like the test is not reproducing the problem \ud83d\ude15 . ",
    "wudijimao": "Same..... With ReactiveSwift 4.0.0  fixed.  I use 3.1.0 before.   I think it is a problem about \u201cmodular_headers\u201d setting in pod_file.. ",
    "andrei-kuzma": "Sorry It is part of ReactiveCocoa.\nWill submit issue there... ",
    "FranDepascuali": "@sharplet Thank you very much!. @mdiep Thanks! Basically, I want to send toasts. Those toasts can either be a single toast or an array of toasts.\nConsider this:\n```swift\nstruct Toast {\n    let duration: NSTimeInterval\n    ...\n}\nlet inputProducer: SignalProducer<[Toast], NoError>\n``\nI would like to emit every value of theinputProducerwith a timing based on thedurationproperty of theToast`.\nswift\noutputProducer: SignalProducer<Toast, NoError>\nExample: \nswift\nlet toast1 = Toast(duration: 3)\nlet toast2 = Toast(duration: 5)\nlet toast3 = Toast(duration: 2)\nlet inputProducer = SignalProducer([Toast 1, Toast 2, Toast 3])\noutputProducer should emit: Toast 1 -- 3 seconds -- Toast 2 --- 5 seconds --- Toast 3 --- 2\n. Thank you very much @mdiep @TimPapler !!. ",
    "ryanmeisters": "Yeah, I'm still getting my head around actions, but creating an action for this purpose felt like overkill\nthis is what I ended up doing\nbuttonItem.reactive.pressed = CocoaAction(Action<Void, Void, NoError> { [weak self] in\n    self?.dismiss(animated: true, completion: nil)\n    return .empty\n})\nand what I wanted was\nbuttonItem.reactive.tapped\n    .take(duringLifetimeOf: self)\n    .observeValues { [unowned self] _ in self.dismiss(animated: true) }\nwhich feels cleaner to me in this case\n. ",
    "dox-mark": "Any property that uses that init leaks for me too.. ```\nclass Test {\n    var urlProperty: Property\n    var anotherUrlProperty: Property\ninit() {\n\n    urlProperty = Property<URL>(value: URL(string: \"http://google.com\")!)\n\n    // Leak!\n    anotherUrlProperty = Property<URL>(urlProperty)\n}\n\n}\n```\nI just created a new project and instantiated this Test class and Instruments shows the second property leaking.. \nOn device I see this leak.. ",
    "TimPapler": "hello,\nmaybe something like this:\n```swift\nstruct Toast {\n    let duration: TimeInterval\n}\nlet (o, i) = Signal<[Toast], NoError>.pipe()\no.producer\n    .flatten()\n    .flatMap(.concat) { toast -> SignalProducer in\n        SignalProducer(value: toast)\n            .concat(SignalProducer.empty\n                .delay(toast.duration, on: QueueScheduler.main))\n}\n    .on(value: { toast in\n        // hide previous toast and show the new one\n    })\n    .startWithCompleted {\n        // hide last toast\n    }\ni.send(value: [Toast(duration: 3), Toast(duration: 1), Toast(duration: 2)])\ni.send(value: [Toast(duration: 1), Toast(duration: 3), Toast(duration: 4)])\ni.sendCompleted()\n```\nHope this is close to what you want to achieve. :-). ",
    "bitjeep": "I changed the redraw signal handler to the following:\nredrawSignal.sample(on: .timer(interval: 1, on: QueueScheduler.main)).skipRepeats() {\n    . . .\n}\nand now I'm getting this compiler error:\n\nerror: type 'Signal<(), NoError>' has no member 'timer'; did you mean 'timeout'?\n\nI can see that SignalProducer has a similar .timer function to the one you're using, but it doesn't fit in the context.  I'm certainly open to changing the structure of my code though.. I've got it working now.  Thanks @mdiep for the help!. ",
    "shoheiyokoyama": "@mdiep\nThanks \ud83d\udc4d . ",
    "zbencz3": "thanks @mdiep !\nthat makes sense.. ",
    "DevAndArtist": "\nWhat benefits do you see for this project having a forum on swift.org in addition to its existing GH Issues and Slack channel?\n\nWell obviously any possible discussion in the Slack workspace is potentially lost forever. So repeating questions will come up again and again and again. GH issues should really focus on real issues and not questions on how to do something. Because of former I was kind of forced to post my issue here on GitHub, but I really think it should go into the forums.\nSince this project aims to be as close as possible to the evolution of the language itself, I think it's a good idea to have a corner in the Swift forums as well where people can ask questions, discuss the evolution of the project, receive announcements or just get influenced by the Swift community itself. \nI mean I already spotted some projects contributor during some proposal reviews in the forums @mdiep  \ud83d\udc4b. Hi @mdiep thank you for answering my question and sorry about closing / re-opening the issue (I was testing GitHawk on the iPad while browsing this repo). I do not follow your point, can you elaborate further?\nThe misalignment that I discovered here is that when SerialDisposable is already disposed you can take a different Disposable (disposed or not, it does not matter) and assign to inner so it will still be retained. Sure this is unlikely to happen anywhere because doing that makes simply less sense, but it's a potential source for an issue by allowing retaining a new disposable on a already disposed SerialDisposable.. > Because SerialDisposable lets you assign to a property, it can't return a value that indicates whether your disposable was set as the inner disposable.\nWell I understand that semantics, but if the behavior of rejecting a new disposable after the SerialDisposable is disposed would be documented it should lead to a more predictable and less error prone state of the type, don't you think?. Can you provide a change suggestion and elaborate more why we need to do it, because I'm not sure I follow. I always thought that such operations should not be done in a multi-threading fashion, so it will be the users responsibility to serialize correctly.\nIf this PR gets approved, I'll add more documentations because this slightly changes the behavior of the type after it's disposed.. ",
    "anayini": "@mdiep can i land this?. ",
    "ShadyGhalab": "My bad, It turned out i need to do \"sudo xcode-select --switch /Applications/Xcode\\ 10.1.app\" before build the frameworks which's something i did afer running carthage. It works for me now.\n. ",
    "MathieuWhite": "@mdiep Thanks for the quick response.\nIn the example above, using combineLatest would send two events. The first one when the currentPlacemark is updated and the second when the placemarks are updated.\nWhat I am looking for is to have the map fire once, and have access to the most recent value for both signals. Using sample(with:) did give me the most recent value for the right side, but not the left. \n```swift\nplacemarks = loadAction.values\ncurrentPlacemark <~ placemarks.producer.map { $0.first } // $0 contains the latest values\nselectedIndex <~ placemarks.producer.sample(with: currentPlacemark).map { placemarks, current in\n  // current is the most recent value (updated on the line above)\n  // placemarks contains the values before the most recent update above\n}\n```\nWith the example above, I'm still not entirely sure why the map closure on placemarks.producer receives the most recent value, but the map closure on sample sends the previous value. The next time currentPlacemark sends an event, placemarks will have the most recent value.  \n-- EDIT --\nPerhaps the issue stems from the same producer being used to update the sampler? I just quickly tested creating a new MutableProperty and binding it to the load action. Then using that property's producer as the receiver for sample(with:) and that seems to be giving me the desired results. \nWould that be intentional? . Thanks @mdiep,\nYour comment about not being able to guarantee which would be the first to send an event has helped me better understand the problem. . ",
    "markvasiv": "Thank you! Is that possible to do the same but with any arbitrary mutable property?. ",
    "iruleonu": "I don't think it fits into it. Even though it has a similar implementation, it has a different behaviour which makes it a different concept from what we're expecting from a throttle. If the implementation was completely different (actually lets forget it), would the concept still fit into throttle? \nThoughts?. You're right it doesn't. Ill do the change.. Regarding the bottlenecked method name, if we play around with the name of the parameter we can use other alternatives:\n\nbottleneck( throughput: TimeInterval, on scheduler: DateScheduler)\nbuffer( deflateOneAfter: TimeInterval, on scheduler: DateScheduler)\nconstraint(_ minimumSpread: TimeInterval, on scheduler: DateScheduler)\n\nNow finding a good names for throttle strategies that shortly describe the behaviour is more complicated. Here's a suggestion that makes sense together:\n\nThrottle: ThrottleStrategy.beat since the speed at which the constraint (time interval) runs sets the \"beat\"\nDebounce: ThrottleStrategy.fluctuate since its last value received that starts the constraint\nBottlenecked: ThrottleStrategy.buffer or ThrottleStrategy.queue or ThrottleStrategy.enqueue or ThrottleStrategy.spread\n. We're getting somewhere :)\nTo give some space for the to be implemented suppress strategy (and others), should we rename all to queued instead?. I like that approach of just using throttle as the base operator with the combinations for the different strategies. \nI'll try to update this soon, although under a bit of a squeeze for time. Since there's a throttle(while:) option and only one implementation, Im going to need to add support for this option to the missing methods.. \n",
    "clayellis": "What if the master operator was regulate(over interval: TimeInterval, using strategy: RegulationStrategy, on scheduler: DateScheduler)?\nWhere the options for RegulationStrategy were:\n - .throttle\n - .debounce\n - .bottleneck\n - .suppress \n(.suppress is a new strategy I'm proposing in an upcoming PR that will forward the latest value on a scheduler immediately then wait until an interval has passed before sending more values; during the interval, values are suppressed and will not be forwarded after the interval expires. Each new value resets the duration.)\nThe major point is the regulate operator. The names of the individual strategies are obviously up for debate.\n. I think throttle would make sense as the base name. \n\nThrottle: a device controlling the flow of fuel or power to an engine.\n\nI think it makes more sense to include all of the proposed strategies under one operator, instead of a composition of multiple. That way the behaviors are explicit and easily discovered, whereas composition only highlight a few. \nI'm not sure about distance. Can we all agree on the base name as throttle? If we all come to a consensus on the base name then it's a matter of naming the strategies.\n\n[x] @clayellis\n[x] @andersio \n[x] @mdiep\n[ ] @iruleonu\n. @andersio ah, I see. I didn't realize .all, .latest were parameters to the strategy. . \n"
}