{
    "mishoo": "Thanks for the suggestions.  arguments is less used in v2's parse.js, but indeed that messy prog1 is still the same, and for no benefit.  I'll try some of your hacks, also have some other ideas on how to optimize v2 further.\n. I have speed-up the parser by about 30% using various hacks, including getting rid of arguments, prog1 and curry. ;-)  Version 2.1.0 is on NPM.\n. I'm sorry man, this \u201cscript\u201d is not yet for \u201cdummies\u201d. :-(\nIf you know how to install NodeJS, then if you just run the command line tool (bin/uglifyjs2) and pass as argument the path to the script you wish to compress, then it should just work.  You'll need a couple of libraries (source-map and optimist) \u2014\u00a0you can install those via NPM.\n. This got fixed as part of recent refactoring.\n. I'll add some quick notes to the README later today, which should suffice for what Grunt needs.  Full API docs will take a few more days.\n. So there, I wrote an API section in the README which describes how you go from original code to compressed/mangled code, how you keep comments if needed, how to generate a source map.  Hope it's useful.\nPlease let me know if you have any questions.  I'd love to see a Grunt task for UglifyJS2, even though I'm not a Grunt user myself.\n. How about UglifyJS.minify then?  Please let me know if you need any additions to it (it's quite simple for now, not many options supported).\n. Hmm, that's a hack I'm using to discard an annoying warning produced by newer Node.\nIf you want you can comment out these lines and it might work (but there might be other problems as well).  I'm not a Windows user and I've no Windows machine around to test this, so if there are other issues I hope someone else can jump in with a fix.\n. So the deprecation issue is no more.  Now if anyone could suggest a portable way to read the whole STDIN synchronously (that is without involving /dev/stdin, I don't like that either but I couldn't find any other way), then we should be Windows-proof.\n. I don't see why it would be better, but in any case, I can't adopt such a solution because the warning is not triggered by UglifyJS code, but instead in a library that some library that it depends on depends on, so to say. ;-)\nI would be happiest if NodeJS provided a clean programmatic way to dismiss the warnings; but it doesn't...\n. @ForbesLindesay True, that.  I'll try to figure out the exact lib (IIRC, it's an older version of RequireJS; the issue has been fixed there, but for some reason the source-map module still needs the old version).\nIn any case, I don't like to see the warning while running UglifyJS, that's why I'm working around it.  Do you think I should simply ignore it and let the warning come through?\n. @mourner what exactly is broken on Windows now?  (sorry, I'm not a Windows user).\nExcept reading input from STDIN (which should not be strictly necessary), everything else should work.  As for STDIN issue, I'd love to fix it but I've no idea how to read STDIN synchronously in Node.js in a portable way \u2014 currently I'm doing fs.readFileSync(\"/dev/stdin\") which works on all but one operating system, guess which one... :-\\\n. > Not sure why this issue is still open since UglifyJS2 works fine on Windows a few days after I reported the issue.\nit reminds me that reading input from STDIN is broken. ;-) [on Windows]\n. The minify function didn't make it on NPM yet, please use the Git source for now.\n. Released version 2.1.0 via NPM, it contains the minify function.\n. Any reason why you feel that's incorrect?\nIn any case, you can turn that off with -c sequences=false, but it's an important optimization that saves a lot of bytes.\n. Weird..  UglifyJS has always transformed consecutive simple statements into sequences (I mean since the very first versions, released two years ago).  Therefore I doubt that IE crashes because of this.\nAs I said, you can disable this optimization by passing -c sequences=false, please try that and let me know if it still crashes.\n. It is possible that you might have found a bug, in fact, but it's for sure not about the comma.  Could we see the generated code?  Also, please let me know what means \u201ccrashes\u201d \u2014 does the browser crash literally, or do you get a syntax error?  Does it work on other browsers?\nIt helps to know more details.\n. Well, syntactically it's valid.  You're getting a run-time error and that's definitely not related to the comma.  Sorry but i can't see how could I help, you'll need to figure it out...  Here are some suggestions:\n1. Try passing -c sequences=false, just to convince yourself that it's not about the sequences.  It should still fail, but if it doesn't it means it's related to the sequences somehow (optimizations cascade; with sequences on, other optimizations will perform better).\n2. Try getting unmangled and beautified output \u2014 pass -b and do not pass -m \u2014 to see exactly at which line/column is the error.\n3. Try getting a source map too, using --source-map (see the README).  Knowing at each line/column is the error in the compressed code, and having a source map, we can determine what in the original code has caused the problem.\nAH JUST NOTICED THIS. :-\\  Are you sure you have the String.prototype.trim defined somewhere?  Is see calls to a.trim() \u2014\u00a0but note it's only available in IE 9+ and Opera 10.5+: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim\n. The defines are evaluated, so it complains that a is not defined.  Evaluating arguments is probably not a good idea.\nAny case, global defines should be constant.  What would you actually expect from your sample, something like console.log(a,b)?\n. Ah, I see.  That almost works:\necho 'console.log(TEST)' | uglifyjs2 -cd TEST='\"a;b\"'\n\u2192 console.log(\"a;b\")\nThere's a bug currently if you include a comma, but it's just the command-line parser, nothing deep.  I'll fix that.\nAlso note that you need to double the quotes (the first level is dropped by your shell).\n. Recent commit 130c623be74ea010b11222d43eb23a181d36cd8a added new options to minify.  You should be able to pass for example:\njs\nUglifyJS.minify(files, {\n    output: {\n        comments: /^!/\n    }\n})\nto retain comments like that.\n. Fixed and pushed 2.1.1 on NPM.\n. OK if I add a function named minify_string instead?  Seems I can't overload minify without breaking existing code (though I don't know if anyone is using it yet).\n. > Btw, is UglifyJS production ready? Or should I stick to v1 for now?\nI'd say it's quite ready.\n. It works for me.  You're probably not using the latest code.\n. > Why save process.stderr.write? Isn't it just process.stderr.constructor.prototype.write?\nMaybe not, if others are doing the same weird hacks we do. :-)\n\nedit: Also, what's wrong with using the suggested node flag (--no-deprecation)?\n\nNothing, in fact I would prefer something like it.  Does anyone know a way to enable it from the program itself (rather than from Node's CLI arguments)?  I don't quite like this patch (didn't like my /dev/null hack either), but will merge it if there's no better option.\n. @curiousdannii is correct \u2014 the reason why it doesn't drop code inside the if in the original ticket is because there is var DEBUG in the code.  Take that out, and it should remove the function itself (though it should keep var create_some_function (as @michaelficarra points out).\nAt this time UglifyJS2 does not detect whether a function is a no-op to discard calls to it.  I can imagine how that would help coupled with --define.\n. > seems to add about 0.5MB to the memory on each call and never gets freed.\nJust wondering, how do you measure memory usage?  I know that's one tough thing to do in JS; nobody can tell exactly when the garbage collector kicks in, so it's possible that all that extra-memory gets freed at some point, if you're patient enough. ;-)\n\nI'm sure this is a good one to iron out before v2 is widely used.\n\nI think there are relatively few people who do uglification on the fly compared to those who do it in a build script.  Even if we have a bug here, this shouldn't prevent wide adoption of v2.\n\ntested streams/direct code output\n\nIf by this you mean replaced usage of OutputStream / print with print_to_string: internally it's the same thing.  print_to_string is just a shortcut which creates the output stream, prints to it, and returns a string.\nAny case, I will do some tests to see if I can reproduce the issue.  How big is the script that you're compressing?\n. Actually the main UglifyJS2 entry point for Node is in file tools/node.js \u2014 and it creates a new context and loads UglifyJS there. ;-)  Perhaps that's why the GC doesn't behave \u201cnormally\u201d?\n. This is a good catch, thanks!  UglifyJS1 worked around this IE issue, sorry for I forgot about it in version 2.  Published v2.1.4 at NPM containing the fix.\n. I'm running in Node 0.9.3-pre (it's perhaps one month old Git build).  Never tried on Windows though, but since nobody else reported such problem I'm inclined to think it's something related to your setup?\n. Will add.  However, note that the preferred way to compress multiple files with UglifyJS2 is to just pass all of them on the command line.  It will do the right thing (i.e. add semicolon between files as needed).  This option wasn't available in v1.\n. @ben-lin I don't fully understand what is the problem, but if you mean to enable the option that I just implemented \u2014\u00a0it's not an option; UglifyJS will just add the trailing semicolon now, unless the script ends with the closing bracket of some block (i.e. a function).\n. It works for me using the command-line tool (I do get the final semicolon), so I'm assuming you're not using the latest code.\n. The problem was introduced in the latest version of source-map, published today (https://github.com/mozilla/source-map/issues/14#issuecomment-9896645).  I sent a pull request: https://github.com/mozilla/source-map/pull/29\n. This appears to be caused by the source-map module, although the actual problem is the following:\n``` js\n\nfoo = {}\n{}\nfoo[\"proto\"] = 1\n1\nfoo.hasOwnProperty(\"proto\")\nfalse\n```\n\nJavaScript reminds me of https://www.destroyallsoftware.com/talks/wat on a daily basis. :-(\n. I sent a pull request: https://github.com/mozilla/source-map/pull/31\n. The source-map fix has been pushed and published to NPM.\n. Compressing \"require.js commented\" (from your link) works properly.  Am I missing something?\n. Just to be clear: your backtrace indicates a bug in UglifyJS; it's just that I can't reproduce it.  If you can provide me with details on how to repro, I'd be glad to look into it.\n. Tried that with the latest Git code and it works without error.\nA lot of issues have been fixed since 2.0.0 \u2014\u00a0version 2.1.6 is on NPM now.  Please try using that, or using the Git repository.\n. @sokra Thanks, fixed that one too.\n. @sokra indeed, noticed and fixed. ;) should be correct now but use the minimum number of parens.\n. Indeed, we have no tests for the code generator and mangler yet...  The current suite is only for the compressor.\n. Seems to work here.  Are you using the latest version of UglifyJS?  Can I see the file that you are trying to minify?\n. I got that too.  Should be fixed in e312c5c2a7d68de3da3bb7e8c9044e3183fe49d6\n. Because it's completely incompatible with 1.x (both AST and API are different) and it could break a lot of packages.  I do encourage people to switch, but this should be voluntary (not enforced by an automatic update) and in any case, v2 needs to be specifically targeted; programs written for v1 won't \"just work\".\n. OK, I will do this eventually.\n. @cowboy I know it's definitely possible, but that would mean merging the Github issues and pull requests as well.  That doesn't seem correct, but of course, they could be cleaned up.  On the other hand I can't see why this matter is so important.  Keeping both repos for now..\n. Right, well, I'll merge the repositories too at some point.  As for the npm issue, they've been merged today.\nJust wondering if it's possible to release an update to v1 via npm, should it be needed.  Anyone knows if npm allows to publish a package with a smaller major version than the latest?\n. @ForbesLindesay Thanks for the hint, I actually googled for this today without luck :-\\ The word \"deprecate\" didn't come to mind for some reason.  Done.\n. > Yeh, I think that argues in favour of merging the github repositories.\nI think, rather, it argues in favour of not merging the npm packages :-\\  But now it's done, so it will stay so.\n\nYou could also provide helpful warning messages when people call methods from the old uglify-us.\n\nThat doesn't sound pleasant..  It's not just a new version, it's a completely rewritten version.\nAnyway, I'll think of it.  Probably the best move now would to merge the repos.\n. No idea what's wrong for you, but that code minifies fine here.  Also, the way you call UglifyJS seems fine.\n. @rvanvelzen merged.\n. Sorry I neglected this.\nI don't think the same --prefix should apply to both source file paths and source mapping URL.  Perhaps we should support a --source-map-url parameter to decide how that comment ends up?\n. @Chevex but that was an edit, wasn't it?\n. I don't see how this is supposed to work, since UglifyJS will reorder function definitions, vars, etc.  Uglifying jquery-1.8.2 (compress but don't mangle) I get something like the following:\n```\n(function(window,undefined){    \u2190 at line 14\n// ... tons of newlines\nfunction createOptions(options){    \u2190 at line 911\nvar object=optionsCache[options]={};\nreturn jQuery.each(options.split(core_rspace),function(_,flag){object[flag]=!0}),object}\n// ... again newlines until line 1800\nfunction dataAttr(elem,key,data){   \u2190 at line 1800\n```\nThere's lots of code in the original jquery source between line 14 and line 911.  While it's true that the createOptions function in jquery is also on line 911, as in the output, the code in between has clearly lost any connection with the original.  Therefore, I really don't see why this helps...  Source maps is the only way to debug minified code.\nEDIT: made a mess of it. Just noticed you don't pass -c \u2014 so indeed, probably without compression it might be okay, although that would defeat some good optimizations.\n. Good Catch\u2122!  Thanks.\n. Using -b ascii_only=true works, but -b automatically implies \u201cbeautify\u201d.  One way around this is -b ascii_only=true,beautify=false.  I'll add a separate --ascii-only flag, since I imagine it will be a common need, but in the mean time you can use this hack (it'll continue to work).\n. That's more tricky because we don't store any information about how the actual string/regexp was written.  Perhaps --regexp-ascii-only would be an acceptable compromise?\n. Indeed, it won't help then..  If I think about it, in Acorn, except for those long regexps there's probably no other place where Unicode chars are used literally\u2014which means that even with an option to keep literals as they are in the original source, you won't get smaller output.  So I still don't see a good reason to implement this.\nHere's another suggestion.  I am assuming you compress multiple files and would like the ascii_only to apply only to Acorn.  I could add support for per-file compression options, specified in the source file.  So you'd add to acorn.js for example:\njs\n// this is a no-op statement, UglifyJS will drop it from the output\nUglifyJS: ({\n    codegen: {\n        ascii_only: true\n    }\n});\nThis isn't a trivial change either :( but perhaps it would be best in the long run.\n. > Feel free to close this bug, if you consider it a \"wont fix\".\nI don't; in fact I'd like to add an option to keep literals as in the original source, at some point, so let's keep the ticket open.\n. It's not absolutely required to pass -, for example this should work:\nsh\ncat script.js | uglifyjs -cm\n. This is most probably a usage issue, not a bug.  However, I can't help you guys out until you tell me how you're using UglifyJS. ;-)\n. That's because fs.readFileSync returns a Buffer if you're not passing the encoding, and UglifyJS expects a string.  Pass \"utf8\" as second argument.\nAlso see these tweets:\n- https://twitter.com/mcbazon/status/256284021682741248\n- https://twitter.com/mcbazon/status/270857132759449600\n. @mlarcher also, another problem with your code (I'm sure you'd figure it out quickly, but here goes): you should take compressing and mangling out of the loop (out of forEach that is).  You need forEach to parse all the files into toplevel, but you should compress/mangle/generate code only once.\nEdit: something like this, therefore:\n``` js\nfunction uglyTest(params) {\n    var toplevel = null;\n    var UglifyJS = require('uglify-js');\nparams.src.forEach(function (file) {\n    var code = _fs.readFileSync(file, \"utf8\");  // *** added \"utf8\"\n    toplevel = UglifyJS.parse(code, {\n        filename: file,\n        toplevel: toplevel\n    });\n}); // *** moved scope/compress/mangle/codegen out of the loop\n\ntoplevel.figure_out_scope();\n\nvar compressor = UglifyJS.Compressor();\nvar compressed_ast = toplevel.transform(compressor);\n\ncompressed_ast.figure_out_scope();\ncompressed_ast.compute_char_frequency();\ncompressed_ast.mangle_names();\n\nvar stream = UglifyJS.OutputStream();\ncompressed_ast.print(stream);\nvar minifiedCode = stream.toString(); // this is your minified code\n\nconsole.log(minifiedCode);\n\n}\n```\n. Function declarations are hoisted to the top, so it's possible that they appear mixed; however that doesn't alter the code logic.  All statements that have side-effects should run in the specified order.\n. As @michaelficarra points out, that expression is not a valid statement (i.e. you can't have it as toplevel expression).  JavaScript is not JSON.  The parser works fine.\n. There is an example of how to do this using the transformer API here: http://lisperator.net/uglifyjs/transform (at the bottom).  It could be improved (it doesn't do chunks, only full strings; also, it would be smarter to only transform if strings occur more than once) \u2014 however it's proven that this will worsen compression ratio after Gzip (simply put, we can't do better than Gzip on this one) so I don't plan on adding this feature to UglifyJS.\n. Works for me...\n. Do it like this:\njs\nast.print(stream);\nvar code = stream.toString();\n. I don't understand what the problem is?  What is the compression you get, and what would you expect instead?\nFor your last example I get this compressed output, which seems correct to me:\njs\nfunction t(a,b){var hasDiff;if(1===a);else{var child=b;child&&(hasDiff=!0)}}\nand beautified:\njs\nfunction t(a, b) {\n    var hasDiff;\n    if (1 === a) ; else {\n        var child = b;\n        child && (hasDiff = !0);\n    }\n}\n. Thanks, it's fixed now.\n. I updated it now.\n. This might seem simple enough to wonder \u201cis there a good reason not to do it?\u201d, but it's in fact quite complicated in the general case.\nDoing it only for the case var i = XXX, j = XXX is fairly simple, indeed, but won't probably save one byte in 99.9% of cases.  Doing it for the case var i = XXX; ...; var j = XXX requires data flow analysis, and there's some serious theory behind this term.  I investigated the possibilities but for the near future I don't think we'll have this (it's complicated by two issues: (1) closures, and (2) JS is a complex beast; normally compilers do DFA on a very simple intermediate language, not on the original source).\nThis comment also applies to mishoo/UglifyJS2#68 and mishoo/UglifyJS2#27 \u2014 data flow analysis would help dealing with them too.\n. main was already present in package.json; also, Node's require is already able to locate uglify-js in node_modules.  I see no reason for this patch.\n. AST_SymbolVar inherits from: AST_SymbolDeclaration \u2190 AST_Symbol \u2190 AST_Node.  Now, because there's no subtree in symbols, we don't need to write a dedicated method to walk them \u2014 instead they inherit the walker from AST_Node.  In your tree transformer, your before/after handlers are called for AST_SymbolVar nodes.\nSo... I'm sorry, I don't see what problem you report, would you care to detail?\n. We probably will at some point, but I have no immediate plans for JS 1.7.\n. Indeed, this is by design actually..  Passing comments: true will retain all comments.  The filtering for JSDoc-style comments is done in the CLI tool, see https://github.com/mishoo/UglifyJS2/blob/master/bin/uglifyjs#L130\nSo to keep only comments that contain @preserve or @license you'd pass a regexp:\njs\ncomments: /@license|@preserve/\n. I removed it some time back because it was buggy.  I re-implemented a version that should be safe, but note that it might not affect size at all on some code, and it might affect it adversely after gzip on other code (for example on jQuery 1.8.2, the size does get smaller before gzip by ~100 bytes, but bigger by ~600 bytes after gzip).\n. Perhaps this could be done for --unsafe, though I can't see much benefit...\nThe reason why it's not safe is that if you have code like this:\njs\nBoolean.prototype.foo = \"x\"\n// or even:\nObject.prototype.foo = \"x\"\nthen false.foo would not evaluate to undefined, but to \"x\".\n. This has been reported before.  I can't reproduce it on Linux though; the previous report also looked like it was on a Mac \u2014\u00a0perhaps there's a bug in /usr/bin/env on OSX, it seems to mess with stdin somehow.  UglifyJS reads the standard input from /dev/stdin.\nSorry but I don't have a Mac, therefore I've no idea how to investigate.\n. There are other cases too.  Generally, comments are lost if there is no AST node following them on the current nesting level.  More examples:\n``` js\nif (foo / lost comment / && bar / lost comment /) {\n    // this one is kept\n    bar();\n    / lost comment /\n}\n// comments right before EOF are lost as well\n```\nIt's a known problem and I kept thinking of it but there's no easy fix.\n. @fidian I don't see a good way to solve your problem, except perhaps by unpublishing uglify-js2.\nI'm sorry for the problem, it's entirely my fault.  I should have either overwritten \"uglify-js\" from the start, or stick with \"uglify-js2\" and two different packages.  The former would have been better, but I kinda did both, in the wrong order. :-(  Again, sorry about the mess.  Right now there seems to be no better solution than to upgrade your packages to refer to the new (old, that is) name.\nI'm not sure unpublishing the package right now is a good idea, perhaps others can jump in with opinions.\n. That would be embarrassing, but I can't reproduce it.  Are you sure you're using the latest version?  I'm on commit 16953c20648ee3b08cf55733ea1b3a2d1d5a80d2 which is v2.2.3.\n. Thanks, this does yield the problem. I'll look into it tomorrow.\n. A recent commit (130c623be74ea010b11222d43eb23a181d36cd8a) added support for compress, output and mangle options to minify, so essentially you can do with minify all that is possible from the command-line.  If anything else is needed, please reopen.\n. There's a fromString option for UglifyJS.minify, which makes it interpret the first argument as source code string (or list thereof) rather than file names.  I think this is what you need.  Sorry if the docs aren't clear enough about it.\n. I merged it.  Sorry for the delay.\n. I'm sorry that this issue dropped off the radar for so long.  Thanks but there's no need for the bounty, I just want to understand exactly what is needed and I'll do.\nCurrently you can pass the --source-map argument and whatever you pass there is added in the //@ sourceMappingURL= comment, unchanged.  Example:\nuglifyjs file1.js file2.js --source-map /foo/bar.js.min.map -o /foo/bar.min.js -cm\nwill produce the compressed output in /foo/bar.min.js and the source map in /foo/bar.js.min.map (which is also the value in the comment).  If you pass additionally --source-map-root http://domain/path/to/source/, that value goes unchanged into the sourceRoot parameter.  Therefore we can say that so far it works as you wish\u00a0(i.e. you can pass exactly the values that go there).\nNow, I can see how this can be awkward when you're running uglifyjs from a directory different than the output directory.  Ideally, I suppose, you'd like to drop the /foo/ part from above \u2014 do I get it correctly?\nI think what you need is to decouple the value that goes into the comment from the actual path where UglifyJS is writing the source map, right?  How about, for example, having a --source-map-except /foo/ argument which would cause UglifyJS to drop that prefix, would that be fine? (or perhaps --source-map-drop 1 to be similar to --prefix?).  Please suggest.\n. > Just let me know what your PayPal account is, please!\n@bdkjones Donations are of course greatly appreciated! ;-) Though as you can see, this particular feature was quite trivial.  My Paypal account is mihai.bazon@gmail.com .\n. Well, could you point out a scenario that can't be easily handled after addition of --source-map-url?\n. Ah, I see..  The --prefix option applies to the names of the original files (in your case lib/dropbox.js) \u2014 check the \"sources\" property of the source map, it should list only dropbox.js instead of lib/dropbox.js.\nThe file property, on the other hand, is always the name of the output file.  I'm not even sure what is it useful for, so far nobody asked for a way to customize it.  It doesn't necessarily make sense to apply the same prefix cutting there, it depends on the use case.\n. I think what UglifyJS should do in fact is to automatically drop from the file property any prefix that the filename has in common with the source map location.  Would that work?\n. Thanks, patch accepted for now.  Note though that --unsafe is enabled by default, you should probably compress with -c unsafe=false which will disable a host of other techniques that you might actually want to use.  I'm wondering if I should add a separate flag for this one...\n. It would be possible to add a feature that disables certain compression techniques for a block of code, but it's not there at the moment.\nHowever, the particular question that you're asking can't be easily solved\u2014there is no way for the parser to ignore a piece of code, it'll still be parsed, mangled and rewritten, even if you disable compression.  It'll still take time.  For your case you should simply minify separately only those files that need to be minified, and concat them later.\n. Published v2.2.4.\n. How about this change: we'll overload --prefix to support a string argument, rather than a number.  It will continue to work as before when the argument is a number, but when it is a string, it will strip any path from the file names and replace it with that prefix instead.  Example: --prefix shared/ would make file names appear in the source map as shared/bar.js, shared/baz.js etc.  Would this work?\nOf course, since you are collecting files from multiple locations I expect you should be careful about name clashes.\n. HTML comments are not valid JavaScript syntax, hence the most graceful handling is to throw a parse error.  You should wrap the call to parse in a try/catch block and deal with the errors.\n. Anyhow, it works now.  Please try using latest code from Git.\n. > I know this may well be bad practice\nIt's really pretty bad..  On the same topic, you could say I shouldn't rename inner functions because one can rely on:\njs\n(function(){\n    function FooBar(){ ... }\n    FooBar.name == \"FooBar\"; // \u2190 not really...\n})()\nLeaving this open and will consider it if there are more requests, but my gut feeling is \"won't fix\".  (or perhaps should we have a separate option for it?)\n. Two possible ways:\n1. run uglifyjs --self to get a build of UglifyJS that you can load in a browser (or in any JS environment) and you can use the API described here.\n2. load in your environment all files in the lib/ directory (load utils.js and ast.js first, the others can come in whatever order).  If you do this, everything will be global\u2014you can use the same API but there's no need to prefix stuff with UglifyJS..\nAlso you might want to look at tools/node.js to see how we load it in Node (as we're not using the standard require).\n. That is an edge case that indicates a bug in UglifyJS (I mean, the AST_Node.warn line shouldn't really be reached).  Can you provide some sample code where a warning is actually displayed?\n. Merged, thanks and sorry for the delay..\n. @ForbesLindesay thanks for taking the time to explain.\nWe could have this as an option but I've no interest to do it; will take a patch if someone bothers to write it.\n. The init actually got moved to the definition, so now you'd use node.definition().init.  I'll update the doc, but I still have to think if this is the right thing (we should probably keep an array of initializers, for cases where the same symbol is defined/initialized more than once).\n. It could be an UglifyJS bug, but I can't be sure \u2014\u00a0can you post a code sample and how you expect it to be minified?\nAlso, are you sure IE supports the const keyword?\n. Not sure I understand what you mean.\n. Handling this through an external tool like mapcat seems totally reasonable.\nPerhaps a good solution (at UglifyJS level) would be to scan the input files for the //@sourceMappingURL comment, and use that map if we can find it?  What do you think?  (it's somewhat tricky to implement, however).\n. @Inversion-des That's the plan.  I'll do that.\n. Thanks for the patch!  I don't have a Mac unfortunately so I can't test that it fixes the issue, will just take your word for it. :-)\nI'll probably refactor this at some point and make it use async reads, so that it works on Windows too.\n. Tricky catch!\nI'm not sure how to get the best of both worlds here...  Converting foo.toString() to \"\"+foo is generally a good optimization (known to be unsafe in certain cases, so it's affected by the unsafe setting, but such cases are infrequent enough so unsafe is enabled by default).\nSo to make it work properly in your case, you would pass -c unsafe=false.\nWe could disable unsafe by default, but it works so well on so many projects.  Undecided \u2014\u00a0opinions welcome.\n. Currently the only thing that --screw-ie does is to force correct (as per standard) scoping rules related to function expressions.  As far as I know, IE leaks the name of function expressions into the enclosing scope (when in fact it should be visible only inside the function expression body).  Are you saying that IE9 fixes this issue?\nIn any case, I'm not sure I understand your request \u2014\u00a0do you simply want us to rename the option to --screw-oldie?\n. Just one thing, I'd name it --screw-ie8 instead.  I think that makes it clear that the target is IE <= 8.  What do you say?\n. Thanks, merged.\n. I'm sorry, I don't understand this report.  Can you be more specific as to what exactly do you find broken?\n. If you use the following to compress:\nu2 q.js -m -o mq.js -b --comments=all -c\n(I used --comments to keep comments in the output, and passed -b to make it easier for me to follow the minified/compressed code).\nHere's what happens.  In the output (mq.js) at line 242, code looks like this:\njs\n        }, void 0, function t() {\n            return n;\n        });\nThat's the t that your if should refer to.  It corresponds to line 738 in the original code:\njs\n    }, void 0, function valueOf() {\n        return object;\n    });\nSo minification is correct.  The original code is wrong, of course, because that's not a function declaration\u2014it's a function expression instead, and so the valueOf name should simply not be visible in that if expression (in compliant engines at least; it will work in IE, but that's because IE is buggy.)\n. Ah, I understand..  And you are right \u2014 but UglifyJS behaves this way to be compliant with this quirk in Internet Explorer.  AFAIK, in IE the function expression on line 738 will take precedence in that scope and override the outer valueOf function.\nA simple solution would be for you to rename the function at line 738.\n. Or (sorry, I forgot, this was recently added) \u2014 another solution would be to pass --screw-ie.  Seriously. ;-)\n. Ah, IE-proof output is a code generator option that relates to something else.  The --screw-ie that I'm talking about is not exposed in the online demo yet, you'd have to use the command-line tool.\n. @SLaks heh, sorry about that.  The transformation is valid, so that's why it's doing it unconditionally.\nBTW, I see in a comment there \u201cUglify can't parse a naked function. Executing it allows Uglify to parse it properly\u201d.  It's not a parser issue, it's in the JS spec. (\u201cnaked\u201d functions must have a name, otherwise it's a syntax error; I suspect that is the problem).\n. Well, UglifyJS is designed to uglify programs, and a JS program is a sequence of statements.\nBut yeah, we could have an option to parse expressions.\n. The names of function expressions are leaked into the current scope, in order to comply with an Internet Explorer bug.  Since the current scope in your situation is the global scope, it is assumed to be a global.  Pass --screw-ie to enforce standards compliant behavior, that should fix your problem.\n. In fact, though that would work in IE < 9, it's a plain bug in compliant engines, they might report an error that NO_WAY is not defined.  I'm considering disabling support for this old IE bug by default.\n. Ahh, right, there seems to be another bug related to this in that version...  But the fix is unnecessary now, with the last commit.  Can you try using the latest Git code?  I don't want to push a new version to npm yet...\n. @Nami-Doc not exactly.  It's a block containing one labelled statement.  The statement is 0; and the label is a.\n. So, as @michaelficarra points out, a JSON expression is not always a valid JavaScript program (sometimes it is, for example this JSON is also valid JS: [ \"foo\", 1, 2 ]).  This said, we could indeed provide a CLI option to beautify JSON.  So I'm leaving this open, maybe I'll do sometime.\n. @RefinedSoftwareLLC  I'm sorry, looks like I misunderstood this ticket.  In fact, looking at the patch I can hardly figure out what it is that you need to do.  I thought you needed to parse JSON, but that's not the case since you don't touch the parser.  Your code would possibly work only for arrays, not when the JSON is an object literal.\nEither way, it seems it's something that can be done outside UglifyJS, and it's an isolate case that might be useful to you but not to anyone else out there.  So please do it in your code, not in UglifyJS.\n. > I haven't verified, but this is reported by @sokra in mozilla/source-map#50\nWell, next time do verify. ;-)  We do include the file prop.  It's the property that names the uglified JS file that the source map refers to, right?\n. > You cannot know the filename, so maybe it's the best solution to emit a error in that case, instead of writting a corrupted SourceMap.\nHmm, I don't think file is so important as to regard the source map \"corrupt\" and abort with an error.  After all, the source map is named from a JS file, and therefore a browser already knows what file does the source map refer to.  As far as I can see, file is just redundant information.\n\nOverall your SourceMaps are of very good quality... :smile:\n\nThanks. :-)\n. I'd too vote for it to be optional, but if it stays required then I'm open to make UglifyJS emit a warning, or an error, when the output is to stdout.  It's a rather contrived case anyway, normally whoever wants a source map will name the output file.\n. ... well, not to mention that if that's so important, then it's the source-map module who should abort with an error, to avoid generating a \u201ccorrupt\u201d source mapping. ;-)\n. Thanks for the note, I fixed it.\n. That's a subset of JS \u2014\u00a0I can't see what wouldn't work.  Try it and please report if you encounter any problems.\n. > Oh, I'm not aware of the specifics why the compressor might be reordering the bitwise operations but I'm sure someone from the core team of UglifyJS can answer that.\nIf this is the only problem, I can fix it.  Will do.\n. Sorry for the delay.  Can you verify now and see if anything else is needed?\nNote that statements like x = x | 0 will now end up x |= 0 \u2014 is asm mode happy with that, or should we disable this optimization too?\n. > I don't know whether it can be turned on without also turning on beautification.\nIt can, pass -b ascii_only=true,beautify=false.\nIndeed, looks like a server misconfiguration, so I'm closing this.\n. Merged this too, thanks.\n. @michaelficarra isn't that what it's doing?\n. Oh my God, such mess for a single async function! :-)\nThanks for the patch, I merged it.  For some reason this pull request didn't close automatically.\n. Most probably @papandreou is right.  There's no reading from /dev/stdin anymore.\n. Looks like a bug in Safari, isn't it?\n. It does that if you pass -c (compress).\n. Won't do.\n. Indeed, this could qualify as an \"unsafe\" transformation but I'm against adding it under that flag.  There are certain optimizations that are likely to break code that makes use of funny language features.  This is one of them.  Another one is dropping or mangling the names of function expressions:\njs\nvar a = function foo(){ ... }\n// \u2192 var a = function(){ ... }, if \"foo\" is not referenced in the function body\nassert(a.name == \"foo\"); // fails\nBut we could have a separate flag for people who prefer we don't mess with function names or arity.  I'll add that if there's more interest (or will take a pull request, anyone?).\n. Is it not an Esprima issue?\nAlso, can you provide an example I could test that shows the failure?\n. Well, even though we know that ! is a prefix operator, I think the prefix property should not be missing.  The SpiderMonkey AST docs seem to mandate its presence.  UpdateExpression is not always postfix, for example ++i is an UpdateExpression, but the operator is in prefix location.\nI don't think your patch is correct.\n. That's probably true, can't think of a case of postfix unary expression.  But the assertion that UpdateExpression is always postfix is false.\n. @indutny I pushed v2.3.0.\n. Thanks, I merged this though it wasn't the entirely correct fix.  Should be better after a6ed2c84ac65f68dc6cf102dffb44f3b00fd0277.\n. Merged, thanks.\n. Fixed in ad1fc3b71ad0c5d24fde1b5be5cfdbdeced1dedc\n. Thanks.  I didn't notice there was a pull request attached so I fixed it myself, but I did merge the test case thereafter.\n. Can you post the code that you are trying to compress?\n. It works for me.  It might be issue #199 that I fixed yesterday (after 2.3.1).  Can you check with the latest code from Git and see if you can reproduce it?\n. Nope.  In fact, it's not clear to me what's the requirement here.  I'm assuming you need to take a piece of JS code and transform it into a string containing that code, is that correct?  If so, it's quite trivial using the UglifyJS API.\n. You mean when using --wrap?\n. It's probably a very rare use case.  I don't see the benefits of this method, since parsing and evaluation will still occur eventually \u2014 seems worse for me to have to wait 3 seconds when I click something than waiting for the page to load \u2014 but nonetheless, it's doable so I implemented it.  You have to pass --unsafe.\n. Nope.  It's easy to do with the AST transform API, you don't even need to modify UglifyJS code \u2014\u00a0you can do it as a separate module.  I have no interest to include such a thing in UglifyJS (we're mostly about compression here, you know.. ;-)\n. Nope.  It's easy to do with the AST transform API, you don't even need to modify UglifyJS code \u2014\u00a0you can do it as a separate module.  I have no interest to include such a thing in UglifyJS (we're mostly about compression here, you know.. ;-)\n. The fix is also on NPM (v2.3.4).\n. Yeah, source-map-cat might help out.\nSorry, I won't add this to UglifyJS.  It was never meant to be a complete build tool, although to some extent it can be seen as one, now that it has source-maps and the ability to take multiple input files.  You're probably better off looking into specialized tools such as \"grunt\"? (just a thought.. I don't know it well enough)\n. That looks good, thanks!\n. I think it was fixed before, I do get a meaningful error here.  I just released v2.4.1, since I didn't push to NPM in while.  Please try upgrading and let me know if you still don't get an informative message for a parse error.\n. This was an old bug, but should be fixed now.  I can't reproduce with the latest version (version 2.3.6 on NPM should be fine), I get the following:\n``` js\nfunction makeClass(n, t) {\n    return n.prototype = t, n;\n}\nvar Class = function() {\n    return makeClass(function() {}, {\n        test: function() {\n            return new Class();\n        }\n    });\n}();\n```\nPlease reopen if you can still repro it with the latest UglifyJS code.\n. @lehni that would be great!\n. Well, it's not a bug then. :-)  Just wondering, what is your use case?  Why do you need to keep unused names around, yet still drop names of function expression when they're not used?\n. I see what you did there.  In the first 5 iterations you're minifying only jquery.js, but in the rest you mix in jquery-ui too.  It behaves that way because UglifyJS tries to optimize the names it generates for local variables depending on number of occurrences for \"unmangleable\" characters.  For example, the word function appears quite often in JS code, and we can't change this fact \u2014 therefore the letter n for instance is likely to appear more often than others, and if that's the case UglifyJS will prefer to use it for naming variables.  This of course is influenced by strings too, because they add unchangeable content.\nYou can do a small test, edit tools/node.js (from the uglify-js source) and search for compute_char_frequency() \u2014 comment out that line, and re-run your test.\nCurrently there's no API to reset the char frequency counters, but I can easily add it.\n. > It seems to me like the base54.reset() should be called every time the minify process is started\nRight, that seems to be a correct solution.  Done that.\n. > var code = '\\'\\\\\" NO WAY, JOSE \\\\\"\\'';\nAfter this line, your variable code will contain the following characters:\njs\n'\\\" NO WAY, JOSE \\\"'\nNow you're asking UglifyJS to parse that as code.  Copy/paste the above line in a file if you want and run UglifyJS on it, and you'll get the correct result:\njs\n'\" NO WAY, JOSE \"'\nBecause this thing starts with a quote ('), UglifyJS starts parsing a string.  Inside the string, the sequence \\\" simply means a \" character.  No bug there.\n. @rvanvelzen great minds think alike. ;-)\n. @doodeec nevermind, I merged/edited it.  Note though that your drop_unused will cause other unused variables to stay in the output as well (i.e. it won't affect only function arguments).\n@michaelficarra you're right that it affects Function.length, but it always did that before so I'd let it on by default.  Most code out there doesn't rely on Function.length after all.  Needs documentation.\n. Oops, and I reverted it.  Turns out we already had an option for this (unused).  Forgot about it.\nSorry guys, I'm a little distracted from this project lately..  I'll try to make a good pass through the existent issues in the following days.\n. Does -m toplevel=true work?\n. Without a var declaration, testThing is assumed to be \"undeclared\".  Undeclared globals are not mangled because they can possibly be declared/used in other files.  Add a var before testThing = {} and it should be mangled (it works here at least).\nEither way, just in case it's an old thing, I released v2.4.1 on NPM, try upgrading if it still doesn't work.\n. I don't think so...  But there's already an easy way to get a build for the browser, you just run uglify-js --self -cm.  Any reason why that doesn't suffice for you?\n. Nope, sorry, I'm not OK with this approach.\nSeems to me that your problem is that UglifyJS cannot be automatically \"browserified\", right?  Presumably, browserify tries to load node.js, notices that there's no require calls there (at least not for UglifyJS files) and just outputs that file, which of course won't work.\nWhat if a special behavior of uglifyjs --self would make it a CommonJS-compatible module?  This, coupled with a feature in browserify (which if it doesn't exist could be easy to implement, namely, the option to run a custom command to browserify certain projects) could automate things.  Hope I explained it properly?\n. Not exactly happy to add a dependency for this, but oh well...  Merged.\n. @rvanvelzen Right.  I can't remember why I wrote that but it was obviously wrong...\n. The prefix argument does not refer to the file property; instead, it refers to the names of the original sources.  For example if you say:\nuglifyjs /foo/bar/f1.js /foo/bar/f2.js -p 2 -o /tmp/compiled.min.js --source-map /tmp/compiled.min.js.map\nthen the source map will list original sources as f1.js and f2.js (drops 2 parts from the prefix), but its file property will be /tmp/compiled.min.js.  There's no option for now to drop the prefix from those names, but you can cd into that directory when running uglifyjs, and specify -o compiled.min.js --source-map compiled.min.js.map.\nWhat I could do is to add an option to drop the common prefix.  I think there are more tickets on this.  So the minified file will refer to the source map in the case above as //@ sourceMappingUrl compiled.min.js.map and the source map will (pointlessly, IMO) refer to the minified file as file: \"compiled.min.js\".  Would that help?\n. That's a good idea!  Should cover most use cases automatically.  Done, you can now use -p relative to trigger that behaviour.  Note though that it'll only work fine when the output file, source map and original sources share a common prefix.\n. Fixed the compressor to not discard the argument.  Not sure we should make the parser croak though, I see V8 for example doesn't have a problem about missing or too many args in setters/getters.\n. Bummer.  I'll look into a fix, for now the workaround is to pass negate_iife=false to the code generator, you can do like this:\nsh\nuglifyjs file.js ... -cmb beautify=false,negate_iife=false\n. It's time, yeah.  Will do later today.\n. Pushed v2.4.0.\n. BTW, was this fixed in IE9? https://github.com/mishoo/UglifyJS2/blob/master/lib/output.js#L759\nIt used to croak on code like this:\njs\nif (...) do ... while (cond); else ...;\n. Sorry for the delay.  @rvanvelzen thanks for the suggestion, I did it that way though I'm not too happy with my drop_unused code (should refactor that at some point).\n. I reverted this one before pushing 2.4.1 to npm, as some tests were failing and I couldn't see a quick fix (problem was generating invalid output, which is quite serious).  Reopening and I'll look more into it.\n. Nope, not right now.  Probably a quick fix would be to detect presence of AST_Undefined or void 0 in the tree and if found, assume the variable named undefined (if exists in scope) is in use.  Just a hack but would do for now.\nBut FYI, this whole function: https://github.com/mishoo/UglifyJS2/blob/master/lib/compress.js#L933 is on my \u201cshould get rid of this\u201d list. ;-)  Won't happen anytime soon though...\n. Thanks.  Keep'em coming! :-)\n. mangle: \"toplevel\" is not supported, not sure where you saw that.\nOtherwise, both compress and mangle work as expected to me.  In your sample compression has no effect anyway, pass some more complicated code to see the difference between compress: true and compress: false.\n. Maybe you're using older code?  It works for me (that is, it's not mangled if I pass false).\nNope, currently there's no option to mangle toplevel variables.\n. Ah, you are right...  I completely forgot that we have the option. :-)\nTry like this:\njs\n    mangle: { toplevel: true }\nAlso, please try with a newer version, 2.1 is rather old.\n. I don't see anything broken with that, it's valid code.  And the size of the output is 40% smaller.\n. Thanks for the patch!  I merged it, with a minor edit.\n. Looks like a serious issue, I'm pretty sure it won't propagate to stable.  Does anything at all work in \"strict\" mode? (I mean, other modules/apps than UglifyJS)\nThe KEYWORDS var is defined on line 47: https://github.com/mishoo/UglifyJS2/blob/master/lib/parse.js#L47 so it's definitely not our bug.\n. Did it for join as that's relatively common (pass -c unsafe=true to enable it), but I'm not sure we should bother for split; that will generally increase size.\n. I implemented it in a more rigorous way, hopefully.  Also, moved that and the code that deals with AST_Binary(+) from the evaluate function, because it badly affects the semantics of that inner ev function \u2014 it should return a constant if it's possible to evaluate, or throw def otherwise.  Overloading it to return a node wasn't really a good idea...\n. I realize the patch is trivial, but there is absolutely no reason why process or Buffer should be available in the UglifyJS global context.  If you could point out to me a good reason why this patch should be accepted, I might reconsider\u2026\n. Yep.  That's not a good reason.\n. None of the files in the lib directory (which is the core of UglifyJS, and all those files are loaded in the \"vm\") \u2014 so none of them reference process nor Buffer.  Therefore there is no solid reason why the vm global context should define those names.  Prove me otherwise and I'll publicly apologize.\n. > Sorry, I'm just in an irritable mood today\nSo am I, apparently, and it's midnight here.  I'll look closer into it tomorrow.\n. Pass -b beautify=false,ascii_only=true.  See README.\n. Is this the culprit?:\n\"undefined\" != typeof e && e.exports ? e.exports = r \u2026\n                                       ^^^^^^^^^^^^^\ncan you check?  That looks legit to me, if that's the issue then Safari is kinda broken...\n. Looks like a pretty nasty Safari issue, I filed a bug report: https://bugs.webkit.org/show_bug.cgi?id=123506\nI implemented a workaround for now in UglifyJS.\n. Can you post a sample of code that works before UglifyJS and not after?\nI really can't see the case. \u00a0If your code works, it means the tagSelected function is global.  But if it is, UglifyJS won't touch it \u2014\u00a0so there's no need for this feature.\n. Nope, not out of scope but very hard to get right in the general case.  A pull request is welcome. ;-)\n. Nope, absolutely not if the transformation is done properly. ;-)  But it's hard.  Good luck!\n. The minified output that UglifyJS generates will make JSLint cry like a newborn.  Even if you work around this particular case, without proper parsing I doubt JSMin will be able to deal with it.\nAny case, it's a \u201cwon't fix\u201d from our side.\n. Looks like an old issue, can't repro with the current UglifyJS code.  What version do you use?\n. Indeed, it's very slow.  It seems that the problem is trying to drop unused variables \u2014 for some reason that step is extremely slow on tinymce.min.js, although I am able to recompress with acceptable speed a 1MB minified file.  I need to further investigate what's special about tinymce.min.js that causes the slowness.\nIn the mean time you can pass these flags: -m -c unused=false \u2014 takes only 3 seconds here.\n. Looks good! :-)  Thanks.\n. The following code does not error out in Safari 6.0.5.  Could it be that the issue was fixed?\njs\n(function(){\n    \"use strict\";\n    function x(x) {\n        console.log(x);\n    }\n    x(10);\n})();\nI don't like the idea to cripple UglifyJS to work around browser bugs, though that's sometimes necessary.  Not sure we should \"fix\" this one, any more opinions?\n. Thanks, but I've done it in a different way.\n. > Uglify should be using regular modules and explicit exports, rather than this homegrown vm stuff.\nI'm not a big fan of CommonJS\u2026  Essentially, I'd like to have a way to split a module across multiple files, so that I can access stuff which is internal to my library unprefixed and without explicit exports/imports.  Because there was no way to do that, I invented one that works for me.\nSince I did not use undocumented APIs, I'd expect things to continue to work in new versions of Node (and if such API is to be deprecated, I'd expect a warning and sufficient time to fix my stuff before the API is dropped completely).\nOn the other hand, I'm glad it helped exposing such serious bug early. ;-)\n. Duplicate of #88, #180.\n. Duplicate of #329.  It's actually a Node issue.\n. I added it as a parameter to the code generator.  If you're using UglifyJS.minify function, you can pass for example:\noutput: {\n    preamble: \"// (c) ACME\"\n}\nA newline will be added after the preamble if one is not there already.\n. Yes, please send some files that I can test on.\n. UglifyJS assumes that the global undefined cannot be defined in any way, therefore I think it's safe to say that typeof undefined == \"undefined\".  Is there a situation where this doesn't stand?\n. ``` js\n$ node\n\nundefined = true\ntrue\nundefined\nundefined\ntypeof undefined\n'undefined'\n```\n\nHmm, where do I find an ES3 engine? :-)\n. Note that has_directive returns the scope where the directive is found (so it looks into the parent scope too), therefore if the directive is specified on the parent then: this.has_directive(\"use asm\") == this.parent_scope.has_directive(\"use asm\");\n. OK.  It's just that it's unclear to me what this whole patch does, can you explain in plain English?\nMy understanding is that you need to not shadow the name of the function where \"use asm\" is found, is that all?\n. Perhaps this could be merged \u2014 can you explain why was it needed?\n. Oh, it's an old browser bug: \"aaaa\".split(/a/) should return an array with 5 empty strings, but in IE8 it returns an empty array.  Screw it, since you are using a polyfill anyway, include this one as well.  People who still use IE8 must suffer increased download times.\n. I'm pretty sure I had a reason to clone() here, why did you remove it?\n. Yeah, noticed that the tests fail when I undo that.  I forgot why I was cloning there, for the time being I'm alright with the patch.\nThanks again for this and your past contributions!  If you are interested to have full commit rights, please ping me in private (my blog tells you how to find me).\n. ",
    "rvanvelzen": "To be very honest: they should just fix their compilers.\n. @ajkochanowicz @Jbudone Execute npm link in the uglifyjs directory.\n. I've started using UglifyJS2 in production environments. It seems to be quite safe, though I must add that I'm a bit adventurous :-)\n. (on a sidenote: jQuery is affected by this issue. I have hacked my version to not move anything into the for-init but it's not a nice solution)\n. Awesome!\n. This seems to be resolved in Opera.\n. @mishoo :+1: \n. No, you're not actually. I just didn't have time to actually play with it after discovering it needed some work.\n. That is a good point\u2026 When hoist_funs and hoist_vars are disabled, it may make sense. When functions and variables are reordered, in some cases you get the correct resulting lines, but in many cases (as you pointed out) it just results in a lot of useless whitespace.\n@michaelficarra: what seems ridiculous to you is not neccessarily ridiculous for others. I do not have the time to implement source maps into our deployment system, and this is a good alternative.\nedit: Of course I would never debug a minified library. It is mainly for automatic error reporting and indeed errors reported by end users.\n. Would it not be possible to keep the original source in the AST and when asked for output these instead of the newly constructed source?\n. This actually hinders gzip compression. It might be beneficial for speed, but I doubt it would be much.\n. The minify method is just a shortcut. If you need other options, you should just use the regular API.\n. This has to do with the code generator. Due to some transformations the while becomes a for, and the variable declarations are moved into it. However, the \"in\" expressions should be parenthesized in the code generator which they are not.\n. You need an argument for the wrap parameter.\n. Your example code uses two different files...\n. When is it not safe?\n. The problem is that \"use strict\" introduces certain semantics, which actually makes it harder in some cases to remove it.\n. Your test files do not correspond to real life scenario's. In those cases, it's obvious thev \"tokenizing\" approach works well because of the large occurences of common substrings.\n. That should be the point. There is no benefit in optimizing for a scarcely used scenario.\n. Why would you use the length property? I would argue that trusting on it is rather silly.\n. -e is used for enclosing your output code in an anonymous function. It expect a parameter, which you didn't supply.\n. @mishoo It displays the error message now. Cool!\n. This is expected, because \\\" in a single quotes string is equal to \". See also section 7.8.4 for the specifics of handling escape sequences.\n. > Inside the string, the sequence \\\" simply means a \" character. No bug there.\n\nThis was exactly what I was just typing. Funny.\n. Try to mimick the original style. Your camelcaps don't fit in. Also, the option should be documented and default to !false_by_default.\n. > when another third party JS library your site relies on iterates with \"i\" and forgets to declare the variable at a local scope\n\nI'm sorry, but that's ridiculous. Fix the code.\n. You can always prevent certain names from being mangled which may help. Besides that, global variables are not mangled unless you ask for it.\n\nIn a website with many js scripts you only uglify certain ones, for exmaple only yours (others may come from CDN hosts etc) ... you never know if a script will polute the global namespace with certain variable names.\n\nThat's why you don't pollute the global namespace by using IIFEs.\n\nSo don't be rude and consider my request.\n\nMy apologies.\n. The problem seems to be this line, which returns an array. The other _eval methods do not.\n. V8 is very lenient, but it is ES5 specific. Maybe just a warning?\n. [richard@annihilation lib]$ grep --no-filename --only-matching --basic-regexp 'new AST_[A-Za-z0-9_]*' parse.js | sort | uniq\nnew AST_Array\nnew AST_Assign\nnew AST_Binary\nnew AST_BlockStatement\nnew AST_Call\nnew AST_Case\nnew AST_Catch\nnew AST_Conditional\nnew AST_Const\nnew AST_Debugger\nnew AST_Default\nnew AST_Directive\nnew AST_Do\nnew AST_Dot\nnew AST_EmptyStatement\nnew AST_False\nnew AST_Finally\nnew AST_For\nnew AST_ForIn\nnew AST_If\nnew AST_LabeledStatement\nnew AST_New\nnew AST_Null\nnew AST_Number\nnew AST_Object\nnew AST_ObjectGetter\nnew AST_ObjectKeyVal\nnew AST_ObjectSetter\nnew AST_RegExp\nnew AST_Return\nnew AST_Seq\nnew AST_SimpleStatement\nnew AST_String\nnew AST_Sub\nnew AST_Switch\nnew AST_Throw\nnew AST_Token\nnew AST_Toplevel\nnew AST_True\nnew AST_Try\nnew AST_Undefined\nnew AST_Var\nnew AST_VarDef\nnew AST_While\nnew AST_With\n. It would be better to find out why those warnings are generated. This probably means that there is something wrong internally, and it should definitely not be ignored.\n. Could you perhaps give an example of offending code? There should be no problem with the default settings.\n. This seems to be a problem in the output generator, not the compressor.\nHowever, it seems the transformation creates a strange parse which isn't at all straightforward to output. Maybe the compressor should \"redo\" the parse tree at the end, to correct for precedence everywhere.\n. String is there already, Boolean and Number are trivial to add.\n. These transformations are only done when -c unsafe=true is passed. It is here, and actually could produce bad code is people were to pass more than one argument. :-)\n. At least IE10 seems to be fine with that syntax, not sure about IE9.\n. Line 87 should be dropped. It actually slows down compression, and in this case removes variables that may later be referenced which is a shame.\n(oh, and it does not change compression as far as I can tell. jQuery comes out the same with and without the line)\n. I'll try to look into it, if you aren't already working on it ;)\n. I have actually found the problem, I think. Pull request incoming. :)\nEdit: nope, but almost. unused_circular_references_2 is failing now. :(\n. The fix I have now brings the squeezing of jquery-2.0.3.js from 0.993 to 1.069 seconds. It works, but the speed difference is quite big, especially considering the hack you named would do the trick as well. :/\n. This issue would actually be resolved with the same fix I mentioned in #280.\n. I bet you're using a version before 4c4dc213, it was fixed in that commit.\n. But you could also write your code like that. Also, does it compress just as good after gzip?\nBesides, what if someone overwrites Array.prototype.indexOf? ;)\n. uglifyjs direcory/*.js --arg1 should do the trick.\n. If you need the non-printable characters to be escaped you can pass -b beautify=false,ascii-only=true. (see here)\n. This is not the fault of UglifyJS or JSMin. Do not use these tools together, it just doesn't work.\nJSMin does not actually parse the JS, and it's unreliable in the sense that if your code does not confirm to JSLint standards, it will get broken.\n. > My company has a system that just use JSMin to distribute js files to CDN servers.\nIt is very unwise to use JSMin over files that do not pass JSLint, as you are now experiencing.\n. This was fixed by 3a81f60982a7f20ef9bd75b851759793ffe1d270\n. What is the difference when not using -c or -m?\n. > By the way, consider disable cleanup of unused variables in uglifyjs by default. That looks like jshint task.\nA lot of the time you're not just compressing your own code, but plugins &c. as well. It is a safe transformation.\nIn the same sense you could ask why UglifyJS prints out parse errors. That's a job for your editor, right? ;)\n. What version of Safari are you running?\n. @mishoo: I've confirmed that this happens only with anonymous functions.\nThis will give the aforementioned error:\njs\n(function(){\n    \"use strict\";\n    (function x(x) {\n        console.log(x);\n    })(10);\n})();\n. I've just submitted a pull request with a fix that should do the trick. It isn't nice, but it seems to work. Could you please verify?\n. Doesn't matter, your solution is nicer. :)\n. There are some known problems with unicode support in IE (also in IE10). They are seemingly not rushing to fix this.\nThe best approach for now is to pass -b \"ascii-only=true\" when uglifying.\n. Upload it as as Gist at https://gist.github.com/\n. Why not just:\njs\n        if (!quote) quote = dq > sq ? \"'\" : '\"';\n        if (quote == \"'\") return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n        else return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n?\n. Perhaps call this has_angular_inject, for clarity.\n. This can probably just as well be expect, right? Is there a specific reason to use expect_exact here?\n. You could unconditionally assign this, since the OutputStream checks if it needs the literal value anyway.\n. Does it make sense to retain SCOPE_IS_NEEDED if it's always true?\nAlso: are there other locations where the same change may be needed, like .minify()?\n. You could use single quotes here to improve readability.\n. Quickly running this test, these lines don't seem strictly necessary?\n. I'll be darned.\n. Optimizing (0, x)() into x() is completely safe, unless x is eval. I.e.:\n``` js\nvar x = eval;\n// these calls are equal\n(0, x)();\nx();\nvar eval = global.eval;\n// these calls are not equal\n(0, eval)();\neval();\n``\n. Generally we don't. Just never optimize it, because it's really not common.\n. Isn'tself.value.print_to_string()self.value.namehere?\n. Maybe renameis_blocktois_block_scopeto prevent confusion about \"block statement\" vs \"block scope\"\n. Would it be useful to create a method onAST_Blockinstead of handling all the cases here?\n. Likecreates_block_scope, we could extract this into anAST_Node.is_block_scoped` method? Fine as-is though.\n. I don't believe this change was intentional, so I'll hold of merging to let @kzc verify.\n. I think these warnings are the ones I was worried about.\n. Done, good one!\n. This change was only needed to make the tests pass, although it probably also didn't work otherwise.\nI'm guessing that it has to do with the introduction of block scope in ES6.\n. This condition seems strange to me, can you add a comment to it? Or, preferable, extract it into a function.\n. Wouldn't this be easier to implement by not dropping expressions for yield*?\n. I believe we should assume that any AST we consume is valid. We could go on with small exceptions to the rule. ;-)\n(I know this is nitpicking, but it's important to me to keep things simple)\n. ",
    "trante": "Node.js! that's adeuqate for a start.\nThank you very much.\n. ",
    "Jbudone": "Hey guys, make sure to install the libraries (source-map and optimist) INSIDE uglifyjs/ \ncd uglifyjs/\nnpm install source-map\nnpm install optimist\n. Actually I grabbed uglifyjs via. the repository, and then linked it from /usr/local/bin\ngit clone https://github.com/mishoo/UglifyJS2/\nln -s path/to/uglifyjs2/bin/uglifyjs2 /usr/local/bin/uglifyjs\n. ",
    "adamjgrant": "I can't get it to work. After running\nnpm install uglify-js\nwith no errors, as well as @Jbudone 's suggestion, I still get\n-bash: uglifyjs: command not found\n. Yeah, that ended up working for me too.  \n\nAdam Kochanowicz\nSent with Sparrow (http://www.sparrowmailapp.com/?sig)\nOn Wednesday, November 28, 2012 at 11:53 AM, JB Braendel wrote:\n\nActually I grabbed uglifyjs via. the repository, and then linked it from /usr/local/bin\ngit clone https://github.com/mishoo/UglifyJS2/\nln -s path/to/uglifyjs2/bin/uglifyjs2 /usr/local/bin/uglifyjs  \n\u2014\nReply to this email directly or view it on GitHub (https://github.com/mishoo/UglifyJS2/issues/4#issuecomment-10810365).\n. \n",
    "ForbesLindesay": "surely the instructions \"for dummies\" are:\n1. Install the latest version of node\n2. Maybe restart your computer\n3. Open command prompt/terminal in the same folder as the file you want to minify.\n4. Run npm install -g uglify-js (-g makes it available as a command line application & npm will automatically fetch all dependencies)\n5. Run uglifyjs file.js --mangle --compress --output file.min.js where file.js is the name of the file you want to minify\n. @XhmikosR Definitely better in my opinion\n. The correct solution is still not to dismiss the warnings.  The correct solution is to submit a pr to the dependency that fixes it in the way that @XhmikosR suggests, otherwise it will break in a future version of node once the deprecated function is removed.\n. I'm inclined to say that for now, you should.  And if your pull request for source-map doesn't get accepted, you should, if need be, create a source-map-2 module that's updated to remove the warning.  Hopefully it won't come to that though.\n. :+1: This really should be the same package but with a different version number, people can easilly do\nnpm install uglifyjs@1.x.x\n. It should really be in the same github repository, with the old uglifyjs as a branch, although that's less important.\n. It would make things much clearer.  It would make it easier to see that it's the newer version of the same package and not somebody else having a go at their own version.  It would help a lot with google searches as there'd only be the one repo to index.\nThis isn't nearly as urgent as the nom issue though...any movement on that?\n. Yes, I'm pretty sure it does...there's a -f options which I think should do what you're after (it will also let you publish over an existing version though, so use with some caution)\n. It might just work without -f actually, I've not tested.  It would be great if you could also deprecate the uglify-js2 package in npm.  Just run:\nnpm deprecate uglify-js2 \"You can now install this using `npm install uglify-js -g`\"\nI would then suggest giving it about 6 months before unpublishing it completely:\nnpm unpublish uglify-js2\n. Yeh, npm docs are a little hard to find as they don't tend to be top of google searches (people keep making packages that have something to do with documentation)\n. It just needs to be changed to npm install uglify-js@1 -g\n. Yeh, I think that argues in favour of merging the github repositories.  You could also provide helpful warning messages when people call methods from the old uglify-us.\n. Yeh, the reality of upgrading to new versions is that it occasionally creates slight headaches for someone, but better this, than lots of people using to old version for brand new projects.\nAll you need is something like the following:\njavascript\nfunction deprecated() {\n  throw new Error('This method of uglify-js is deprecated, either specify version 1 as your dependency, or update to use the methods in version 2');\n}\nThen you could just do:\njavascript\nexports.parser = deprecated;\nand repeat that for any other obvious methods that no-longer exist.\n. A more useful (related) case would be to detect when string literals never escape a certain function context (e.g. Events on an event emitter that never leaves a certain function scope) and reduce the string literal to a short, unique string (such as 'a'). This would be much harder though.\n. In your local repository do:\ngit rebase -i HEAD~4\nWhich will let you take those 4 commit's and turn them into one.  Once you've checked that's fine you can do:\ngit push -f\nThe -f stands for force and is necessary because you are effectively re-writing history.\nThe files-changed lets you view a summary of the overall changes, but once merged in, these commits would still represent 4 separate commits.  It doesn't really matter except that it's not as neat when you go back through the log of commits to see what's changed when.\n. The optimisation above would be completely safe though\n. In general it is safe to optimise:\njavascript\nvar x = E, y = E;\nto\njavascript\nvar x = E, y = x;\nFor all E provided that E:\n1. has no side effects\n2. returns the same value every time\ne.g. The following would not be safe to optimise even though Math.random() has no side effects:\njavascript\nvar x =  Math.random(), y =  Math.random();\nThe following would be though:\njavascript\nfunction get() { return 5; }\nvar x =  get(), y =  get();\nThe follwoing would not because {} === {} is false\njavascript\nfunction get() { return {}; }\nvar x =  get(), y =  get();\nbut the following would be:\njavascript\nvar val = {};\nvar x = val, y = val;\n. Interestingly it would be safe with certain very specific side effects, but this is probably more in depth analysis than we'd want to do:\njavascript\nvar got = false;\nfunction get() {\n  return got = true;\n}\nvar x =  get(), y =  get();\nbecause although get has side effects, it doesn't have a side effect if you run it a second time having not reset got to false.\n. No worries @abody these things are tricky at the best of times, my initial intuition which I started writing down was completely false.\n. You wouldn't want it to run for anything that could be a getter, because that's way too likely to be unsafe.  Just code the optimisation so it only does it when we know it's safe (i.e. expressions that don't contain property accessors, function calls, object literals, array literals or regexp literals).\nPerhaps more significantly, it slows runtime performance if not done carefully: http://jsperf.com/optimizing-var-definitions (needs more runs to be statistically significant).\nI suspect it will have negligible or no affect on file size once gzip has done it's thing.  It may ultimately not be worth optimising, unless you want to handle the case of a call to a function which has no side affects and always returns the same value.  e.g. the performance gain of optimising the following would be huge:\njavascript\nfunction factorial(n) {\n  if (n === 0) return 1;\n  else if (n > 0) return n * factorial(n - 1);\n}\nvar a = factorial(50), b = factorial(50);\nHow often such code actually appears though I'm not sure.\nDo we know whether UglifyJS already tracks which functions are 'pure' functions (i.e. no side effects and always return the exact same value for the same input)?  If it does, this may be doable, if not then it's a fair bit of work for minimal gain.\n. OK, anything that can be a getter then, which should include all property accessors and any variable that's not found in the current scope (and therefore could be a property on the window)\n. this.defineGetter wouldn't make any difference, I've already said we should exempt property accessors and 'global' variables, this.name is a property accessor.\n. It might need to also be disabled inside with blocks or where there's  evals and new Functions, but virtually all optimisations are disabled inside with blocks etc.\n. For anyone else reading:\njavascript\nfunction test() {\n    this.__defineGetter__(\"x\", function() {\n        alert(\"This is evil.\");\n        return 5;\n    });\n    return x;\n}\nconsole.log(new test());\njust throws a reference error and if you're in stict mode then so does the above code.  The above code in non-strict mode is just assigning x as a property of the global object so the following is also fine:\njavascript\n(function () {\n  var x = 10;\n  function test() {\n    this.__defineGetter__(\"x\", function() {\n        alert(\"This is evil.\");\n        return 5;\n    });\n    return x;\n  }\n  console.log(test()); //logs 10\n}())\n. Given the classic test along the lines of:\njavascript\nif (typeof module == 'object' && typeof module.exports === 'object')\n  module.exports = foo;\nsetting module to undefined should work anyway.  If you just had:\njavascript\nif (typeof module.exports === 'object')\n  module.exports = foo;\nyou would be throwing an exception in non-commonJS environments pre-minification anyway.\n. Yes, uglify-js2 is deprecated, use uglify-js instead\n. uglify-js2 can easilly be unpublished by @mishoo the problem is there are currently libraries that still depend on it.  It shows an error that says it's deprecated when you install it.  I have opened pull requests on virtually all the libaries that still depend on the old package, so once those are updated it may make sense to un-publish uglify-js2.\nIt does not make sense to keep publishing updates for it as that will just perpetuate the problem of people depending on the wrong library.\n. It already emits a warning on installation\n. Yes, it already does that.  The only problem is it doesn't provide a warning for npm update or npm outdated (https://github.com/isaacs/npm/issues/3040)\nI think for now this is an issue for npm (i.e. npm should provide sterner warnings more frequently to people running deprecated packages).\nThe only remaining thing we could choose to do is un-publsih uglify-js2.  There are only a few packages that still depend on it, all of the ones that I could find a GitHub repo for have open pull requests to fix the issue, so if we removed uglify-js2 now then all they'd have to do is merge the pull requests.  There'd be a little bit of very brief pain from a few module authors, but it might be better to experience that little pain now than continue to have people getting confused for ever more.\nI'm :+1: for unpublishing uglify-js2 now.  I think in the long run that would result in the least pain.\n. I expect there will also be hundreds of private packages as well, but those will all be maintained by the people who use them, so they'll get fixed as soon as their users need them to get fixed.  In that sense I think only the public libraries are a problem.   (P.S. I have to admit that I didn't send a pull request to hoarders, even though I could find the GitHub repo - I don't think it matters if they fail to get the old version).\n. This is something that a bit of data-flow analysis would help with a lot.  We could attempt to track functions and only remove the arguments if we know it's safe.  That kind of thing would be a lot of work though, and would hurt performance.  I think a separate option may be merited.\n. ## Safety\nIt's not trivial to check for cases like the following, where it's not safe to remove \"use strict\";\n``` javascript\n\"use strict\";\nfunction Foo() {\n  if (typeof this === 'undefined') return new Foo();\n  this.val = 1;\n}\nFoo.prototype.getVal = function () {\n  return this.val;\n};\n// the following then works in strict mode\n// but leaks a global variable val in non-strict\n// mode\nFoo().getVal();\n```\nPerformance\nThe other reason not to do this is performance.  \"use strict\" serves two purposes.  The first is to prevent bad practices and fix some obvious mistakes.  The second is to aid performance optimizations.  Strict mode allows optimisers to assume certain techniques won't be used (Such as arguments.caller etc.).\nAs such, removing \"use strict\" may actually hurt performance.\n. After the initial \"use strict\" for any given scope, it should be pretty safe to just remove all string literals, numeric literals, boolean literals and regular expression literals, that aren't ever used.\n. There are no other valid directives:\njs\nfunction foo() {\n  \"foo bar\";\n  return 5;\n}\nis exactly equivalent to:\njs\nfunction foo() {\n  return 5;\n}\nThe only string literal (that I'm aware of) which has special meaning is \"use strict\"\n. @Intyuh thanks, I wasn't aware of that directive.  We could add exceptions for any that are potentially meaningful.\nhttp://ecma-international.org/ecma-262/5.1/#sec-14.1 States:\n\nA Directive Prologue is the longest sequence of ExpressionStatement productions occurring as the initial SourceElement productions of a Program or FunctionBody and where each ExpressionStatement in the sequence consists entirely of a StringLiteral token followed a semicolon.\n\nWhich means only string literals at the beginning of a function body suffer the problem of potentially being directives.\nIt also does indeed goes on to state:\n\nImplementations may define implementation specific meanings for ExpressionStatement productions which are not a Use Strict Directive and which occur in a Directive Prologue.\n\nso implementations can define implementation specific meanings as @michaelficarra suggests.\nIt's worth noting that only implementations can define such meaning, not users.  Essentially, providing you consider the list of known directives (and keep that up to date), it's no less safe than mangling variable names, since someone is always able to call foo.toString() when foo is a function.\nAs a final point, pretty much no code actually relies on these directives.  For example, code may actually run faster if the \"use asm\" directive is removed in production, since all it does is enforce strict type checking.  Code that relies on \"use strict\" would also fail pretty frequently at the moment if running in browser environments (the main target for UglifyJS).\n. Thanks for the advice, I had forgotten to add <meta charset=\"utf8\"/> to my html pages header.  Thanks @mishoo & @papandreou.  As ever, UglifyJS is an indispensable part of my tool-set :)\n. Yes, the reason is that I've written modules that use uglify-js as a dependency for parsing (e.g. with) and although they are primarily designed for server use, they still need to work on the client.  Most node.js modules can be made to run on the client by just using browserify.  This works with any node.js modules that don't do file system IO, use the VM or use native code.  Uglify only uses the file system and vm to bootstrap itself, so could be made to work in browserify fairly easily, but the current npm package does not.\nHow about replacing the current ./tools/node.js with a simple build script that outputs a commonJS module for use in node.js and CommonJS module systems such as browserify:\n./tools/node.js\n``` js\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar uglify;\ntry {\n    uglify = require('../index.js');\n} catch (ex) {\n    uglify = require('uglify-js');\n}\nvar FILES = exports.FILES = [\n    \"../lib/utils.js\",\n    \"../lib/ast.js\",\n    \"../lib/parse.js\",\n    \"../lib/transform.js\",\n    \"../lib/scope.js\",\n    \"../lib/output.js\",\n    \"../lib/compress.js\",\n    \"../lib/sourcemap.js\",\n    \"../lib/mozilla-ast.js\"\n].map(function(file){\n    return path.join(__dirname, file);\n});\nvar src = 'var sys = require(\"util\");\\nvar MOZ_SourceMap = require(\"source-map\");\\n' \n        + FILES.map(function (path) {\n          return fs.readFileSync(path, 'utf8');\n        }).join('\\n');\nvar ast = uglify.parse(src);\nast.figure_out_scope();\nvar functions = ast.functions\n    .map(function (node, name) {\n        return name\n    })\nvar variables = ast.variables\n    .map(function (node, name) {\n        return name\n    })\nsrc += '\\n\\n'\n     + variables.map(function (v) { return 'exports.' + v + ' = ' + v + ';\\n' }).join('')\n     + functions.map(function (v) { return 'exports.' + v + ' = ' + v + ';\\n' }).join('');\nsrc += fs.readFileSync(__dirname + '/node-suffix.js', 'utf8')\nfs.writeFileSync(__dirname + '/../index.js', src);\n```\n./tools/node-suffix.js\n``` js\nexports.AST_Node.warn_function = function(txt) {\n    sys.error(\"WARN: \" + txt);\n};\nexports.minify = function(files, options) {\n    options = exports.defaults(options, {\n        outSourceMap : null,\n        sourceRoot   : null,\n        inSourceMap  : null,\n        fromString   : false,\n        warnings     : false,\n        mangle       : {},\n        output       : null,\n        compress     : {}\n    });\n    if (typeof files == \"string\")\n        files = [ files ];\nexports.base54.reset();\n\n// 1. parse\nvar toplevel = null;\nfiles.forEach(function(file){\n    var code = options.fromString\n        ? file\n        : fs.readFileSync(file, \"utf8\");\n    toplevel = exports.parse(code, {\n        filename: options.fromString ? \"?\" : file,\n        toplevel: toplevel\n    });\n});\n\n// 2. compress\nif (options.compress) {\n    var compress = { warnings: options.warnings };\n    exports.merge(compress, options.compress);\n    toplevel.figure_out_scope();\n    var sq = exports.Compressor(compress);\n    toplevel = toplevel.transform(sq);\n}\n\n// 3. mangle\nif (options.mangle) {\n    toplevel.figure_out_scope();\n    toplevel.compute_char_frequency();\n    toplevel.mangle_names(options.mangle);\n}\n\n// 4. output\nvar inMap = options.inSourceMap;\nvar output = {};\nif (typeof options.inSourceMap == \"string\") {\n    inMap = fs.readFileSync(options.inSourceMap, \"utf8\");\n}\nif (options.outSourceMap) {\n    output.source_map = exports.SourceMap({\n        file: options.outSourceMap,\n        orig: inMap,\n        root: options.sourceRoot\n    });\n}\nif (options.output) {\n    exports.merge(output, options.output);\n}\nvar stream = exports.OutputStream(output);\ntoplevel.print(stream);\nreturn {\n    code : stream + \"\",\n    map  : output.source_map + \"\"\n};\n\n};\nexports.describe_ast = function() {\n    var out = exports.OutputStream({ beautify: true });\n    function doitem(ctor) {\n        out.print(\"AST_\" + ctor.TYPE);\n        var props = ctor.SELF_PROPS.filter(function(prop){\n            return !/^\\$/.test(prop);\n        });\n        if (props.length > 0) {\n            out.space();\n            out.with_parens(function(){\n                props.forEach(function(prop, i){\n                    if (i) out.space();\n                    out.print(prop);\n                });\n            });\n        }\n        if (ctor.documentation) {\n            out.space();\n            out.print_string(ctor.documentation);\n        }\n        if (ctor.SUBCLASSES.length > 0) {\n            out.space();\n            out.with_block(function(){\n                ctor.SUBCLASSES.forEach(function(ctor, i){\n                    out.indent();\n                    doitem(ctor);\n                    out.newline();\n                });\n            });\n        }\n    };\n    doitem(exports.AST_Node);\n    return out + \"\";\n};\n```\nThis outputs an index.js file that does not require fs, path or vm and so is simpler and faster, but still works prefectly in node.js and on the browser.  Then it would just be a case of changing \"main\" in package.json to point to index.js.\nIf you're OK with this, I'm happy to submit it as a pull request.\n. Yes, the problem is that UglifyJS cannot be automatically browserified.  Yes, browserify does it's best to provide shims for the modules it sees being required, but it's way too complicated (in the general case) to work out in advance which files will end up being requested when they aren't loaded using require.\nBrowserify does support specifying a transform, which essentially just requires a good programmatic (not command line) way of getting a commonJS version for browserify.\nI've implemented this for now and am submitting a pull request.  The idea is that, when given the file name of the node.js version, it returns a browserify version.\n. Is #253 an acceptable option?  If not, I'll explore alternatives?\nBy the way, I built an in browser demo of the parser so I could understand the generated AST better.  I think other people may find it useful http://demos.forbeslindesay.co.uk/uglify-js/  It relies on support for browserify though so at the moment it's using my fork.\n. Thanks\n. Thanks\n. ",
    "tap52384": "Thank you very much for the instructions for \"dummies.\" As soon as I added the -g to the install command, I was able to use uglifyjs on Windows. Thanks!\n. ",
    "jzaefferer": "That's a lot of low-level API surface. How about exporting one helper that encapsulates all of that?\n. That looks pretty good, thanks. I'll ping the grunt guys, they can create issues for specific issues they may find.\n. ",
    "XhmikosR": "It works. I only see one warning: path.existsSync is now called 'fs.existsSync' which is what those lines hide.\n. Thanks for the replies and possible workarounds, but I believe this should be addressed upstream. I'm sure I'm not the only Windows user out there :)\n. @mishoo: not sure if this is a better way or not to get rid of the warning...  https://github.com/GoalSmashers/enhance-css/commit/101d6684ecd195cb0209f4ac5cd411df7ed94d98\n. Not sure why this issue is still open since UglifyJS2 works fine on Windows a few days after I reported the issue.\n. :+1:  But maybe you should squash those two commits and maybe add an empty line after the end code characters.\n. I don't like #674, sorry. And I need this to make sure the warnings are fixed.\n. ",
    "michaelficarra": "@XhmikosR: It's a known problem with one of the dependencies (requireJS) of one of the dependencies (source-map).\n. Why save process.stderr.write? Isn't it just process.stderr.constructor.prototype.write?\nedit: Also, what's wrong with using the suggested node flag (--no-deprecation)?\n. Well, it's not entirely without side effects. Your code is equivalent to\n``` js\nvar DEBUG, create_some_function;\nDEBUG = false;\nif(DEBUG) {\n  create_some_function = function(){ ... };\n}\n```\nSo, as you can see, only the initialisation value could have been removed.\n. @Chevex: Yep. There hasn't been a commit for 2 whole days. @mishoo: where have you gone?!\n. This is ridiculous. It is beyond easy to consume and query source maps with Mozilla's source-map library.\nedit: There should be no need to debug using the minified library during development, anyway. The only use case I can see is debugging errors that are reported by end users (or their browsers).\n. If the parser sees a { in statement position, it should (according to spec) assume the start of a BlockStatement, not an ObjectExpression. The 1: is treated as a label, and 11, '2' is a valid CommaExpression.  Force the BlockStatement into expression position with parentheses or something to get the parser to treat it as an ObjectExpression. The parser is working fine.\nedit: more descriptive\n. I'd like to see a test that ensures [1,,] is transformed to [1,,].\n. @mishoo: I suggest a --nonconform for ignoring transformations that are completely safe according to ES5, but must be avoided in some non-conforming implementations (mostly IE). This bug and the common '\\v' === 'v' test should be hidden under that flag.\n. As it should. const is a Future Reserved Word, and the code you provided is not valid JavaScript.\n. @gera2ld: you have to use the appropriate options.\n. It's safe to remove duplicate directives, but not different ones like @ForbesLindesay suggests.\n. @ForbesLindesay: any string in directive position may be meaningful and must be preserved.\n. Disable unsafe by default. Only guaranteed transformations should be made unless the user opts in to possibly accidentally changing semantics of his program.\n. Passing the output of JSON.stringify to uglifyjs shouldn't even work. That's not a JavaScript program.\n. No. JSON-serialised objects are never valid JavaScript. This is not a JavaScript program:\njson\n{\"a\": 0}\nThis is, but probably not for the reason you think:\njs\n{a: 0}\nThat's a block with a labeled ExpressionStatement that contains 0.\njs\n({a: 0})\nAnd that's an object literal, identical to the JSON above. Have you never wondered why you have to put parentheses around JSON in order to eval it (treating it as JS)? It's because you need to put it in expression position. JSON is valid JavaScript if it's already in expression position.\n. @Nami-Doc: correct.\n@RefinedSoftwareLLC: :facepalm: Alright, you're right, JSON is obviously a subset of JS because the almighty Chrome tells us it is so. incorrect.\nedit: removed snarkiness\n. > So I do not get why JSON not working in the toplevel is an issue because JSON in the toplevel is completely useless \n@RefinedSoftwareLLC: Then why are you trying to parse it that way? Because you find some use in it. Unfortunately for you, your JSON is not valid JS, and can only be working now due to a bug in the UglifyJS parser.\nedit: elaborated\n. @RefinedSoftwareLLC: I think you're confusing function calls with macros. Function calls work with data structures. Macros with with strings of program text. When you call JSON.parse, it doesn't put a string of program text in that position literally.\nWe now see why UglifyJS was accepting your JSON as JS: you are serialising an array, which will produce perfectly valid JS.\nJust use JSON.stringify. It does a good job and works with the kind of data you want.\njs\nJSON.stringify(JSON.parse(your_json), null, 2);\nedit: If you really need the max line length, use UglifyJS like below so it is safe.\njs\nvar data = JSON.stringify(json_object);\ndata = UglifyJS.minify('(' + data + ')', {\n  fromString: true,\n  compress: false,\n  output: {\n    beautify: true,\n    quote_keys: true\n  }\n}).code;\ndata = data.replace(/\\(\\s*(.*)\\s*\\);?/, '$1');\n. @RefinedSoftwareLLC: see my edit above.\n. @mishoo: that's not the correct fix. Just use the \\uXXXX escapes instead of the \\xXX escapes for identifiers.\n. Whoops, sorry. You were right. I misread the diff.\n. The transformation is good according to spec. Screw old IE.\n. > somehow the left side of the inequality is evaluating to null, not undefined\nWell, that's not because of this transformation. Something somewhere else is causing it. The comma operator is just like a sequence in expression position. The semantics of contained expressions are not changed.\n. It's necessary for ES3 compatibility. Which really means old IE at this point. Maybe it should be hidden behind that flag?\n. Nice catch.\n. Nice. LGTM.\n. @mpal9000: Try master, this was fixed 5 days ago. Duplicate of #204.\n. (echo -n '// '; date; uglify input) > output. Why would you ever want uglifyjs doing this for you?\n. See https://github.com/mathiasbynens/mothereff.in/issues/16 and https://github.com/mathiasbynens/mothereff.in/commit/ef48f80b4b5739dc1871ac6365e85585f79ba4ef\nYou still need to use \\0, but only when it's not followed by [0-7]. See @mathiasbynens's fix here: https://github.com/mathiasbynens/mothereff.in/commit/fa6f85bfddc0a377d063e399cd23fccfb2e58a99\n. Constellation/esmangle does this: https://github.com/Constellation/esmangle/blob/master/lib/pass/transform-immediate-function-call.js\n. @lehni: Yes, please.\n. This is intentional. See https://github.com/mishoo/UglifyJS2/pull/213. Update chrome.\n. This can't be enabled by default because it has observable effects.\n. Same thing, but with delete:\njs\na.delete /= 1\nedit: also, void, in, typeof, instanceof, new.\n. That one appears to have taken care of it.\n. Wow, that's a pretty serious v8 bug. The test suite must include something as simple as that, no?\n. This one's not appropriate. Should be typeof void 0. We can't statically determine the value of typeof undefined outside of strict mode in ES3. It's worrying if this test case is already passing.\n. js\nundefined = true; // true\ntypeof undefined; // \"boolean\"\nedit: Whoops, appears to be ES3 only.\n. Is there no better IdentifierName test? This will disallow unicode characters and whatnot.\n. Should be 55. \"\\08\" === \"\\x008\".\n. Shouldn't this be str.charCodeAt(i + 1)? I don't see how this could work. Did you test it? Either way, you should add tests.\n. I would leave this the way it is. See https://github.com/mishoo/UglifyJS2/pull/674.\n. You have to parenthesise this if it is the variable named let.\n. As of ES6, these declarations are no longer allowed to have initialisers.\n. If you see a let here, you have to look ahead for either a [, {, or identifier to know it's a declaration. let.a is valid in this position.\n. Why would of be restricted?\n. of is not an operator\n. Do we care that this works in old/broken environments? If so, this should be \"\\\\x0B\" instead of \"\\\\v\". See https://github.com/mishoo/UglifyJS2/issues/6.\n. Yeah, probably.\njs\ncase \"\\x0B\": return output.option(\"screw_ie8\") ? \"\\\\v\" : \"\\\\x0B\";\n. I don't like this name. check_method_call?\n. Both the words \"lexical\" and \"scope\" have little to do with what's going on here. It's about the kind of Reference returned by the expression.\n. @alexlamsl That name works for me. Also, you are correct that parentheses don't change the Reference in any way, so they don't have an effect here.\n@kzv I've responded in https://github.com/mishoo/UglifyJS2/issues/973#issuecomment-184726712.\n. Not this part: && !scope.find_variable(\"eval\"). Because this is a direct eval:\njs\n(function(eval) {\n  eval(\"\");\n}(eval));\n. This will need to be changed, in case someone did console = global.eval elsewhere.\n. You're right to doubt it, but that is in fact different. See 12.3.4.1 step 4. JavaScript is crazy.\n. This is actually incorrect. The input contains two statements: a string literal and a function call. The expected result contains a directive and a function call. I would expect either a string literal and a function call or, if the useless string literal were dropped, just a function call.\n. Sure, but shouldn't we be concerned about this bug anyway?\n. :worried: I don't like to make those kinds of assumptions. \"good enough\" is rarely ever good enough.\n. Why only 21e3? Should be Math.pow(64, 3) + Math.pow(64, 2) + 64 or 266304.\n. Why not change is_constant itself?\n. I would say that you put the exception in those locations then, instead of this one, since it's clearly not a constant.\n. @kzc That use has nothing to do with it being \"constant\" (which it isn't); it can be reduced because it's the same AST. The same could be done with\njs\nreturn x ? typeof a : typeof a;\njs\nreturn x ? Math.pow(a, b) : Math.pow(a, b);\njs\nreturn x ? function (a) { return 1 + a; } : function (a) { return 1 + a; };\netc.\n. ",
    "Couto": "@XhmikosR node has an option to silence deprecation warnings...\nnode --no-deprecation <script.js>\nnot a fix, but it might help meanwhile. =)\n. ",
    "mourner": "+1, me too :)\n. This issue is REALLY disappointing considering the new broken version is now the default for uglify-js NPM package. Is there any progress on this?\n. Hmm, just tried and UglifyJS2 seems to work fine on Windows (at least through the API, didn't try the console tool).\n. Ha, sorry, should be safe to close now then :) I supposed it doesn't work because the issue was still open.\n. ",
    "FarSeeing": "One more thing:\nhttps://github.com/mishoo/UglifyJS2/blob/master/bin/uglifyjs2#L337\njavascript\nif (filename == \"-\") {\n        // XXX: this sucks.  How does one read the whole STDIN\n        // synchronously?\n        filename = \"/dev/stdin\";\n    }\n. Chrome also throws an error.\n. Did not found that String is already done. Also forgot to mention the argument itself:\njavascript\nfoo = String('foo') // just foo = 'foo', now it's foo=\"foo\"+\"\"\nbaz = Number() // just baz = 0\nbar = Boolean() // just bar = false\n. ",
    "Czarp": "I don't have a *nix machine, but assuming no flavors begin with \"win\":\nvar devnull = fs.createWriteStream(require(\"os\").platform().indexOf(\"win\") == 0 ? \"nul\" : \"/dev/null\");\n. Scratch that - it ends up creating a file \"nul\" in the location in which you execute the command and you really can't get rid of it.\n. Using \\nul puts it under C:, so at least it's at a system level. That's the solution I'm going to use for now.\n. ",
    "ricknpc": "@mishoo Instead of caching the entire process.stderr and replacing it with a /dev/null write stream then putting it back, what about caching process.stderr.write and replacing it with a function that does nothing but return true then putting that back? I'll put a pull request together shortly if that's okay. Works on my Windows box.\n. Created a pull request here. Sorry if I did something wrong, this is my first pull request, and I couldn't figure out how to attach it to this issue if it's even possible.\n. > Why save process.stderr.write? Isn't it just process.stderr.constructor.prototype.write?\nGood point, I was mirroring the cache/restore structure that was already there and hadn't thought of that. I'll update the pull request.\n\nAlso, what's wrong with using the suggested node flag (--no-deprecation)?\n\nSeems to work if you're running it or requiring it in your project, but is there a way that flag can be passed on a global install?\n\nI don't quite like this patch (didn't like my /dev/null hack either)\n\nI agree; I just need it to run on Windows (we have a few devs who will be using it regularly on different platforms), and since it was already a hack, I thought this might help. If there's a better way I'm all for it, I just need it to run.\nPersonally I wouldn't even mind just seeing the deprecation warning every time. But the first thing I looked into when it wouldn't run on Windows (and after seeing issue #9) was how to run the --no-deprecation flag from within the program, and I didn't have any luck either.\n. ",
    "wayneashleyberry": "Awesome, thanks for letting me know :)\n. ",
    "EyePulp": "Cool! Thanks much.  The new uglify seems to handle corner cases better than the old one.  Great work!\n. ",
    "kennethdevik": "It crashes on IE8\n. The browser doesn't actually crash. It's only a TypeError of some kind. The error message in IE developer tools is in Norwegian :/ and may be poorly translated, but I think it means that some property or expected function are missing.\nWe have tested in other modern browser like Chrome, FF and Safari. It works. But not in Opera. Latest Opera complains about the same the comma.\nCode generated:\njavascript\nvar vegkart=vegkart||{};(function(a){\"use strict\";function b(a){var b=a.split(c);return b}a.nvdb=a.nvdb||{},a.nvdb.lexer=a.nvdb.lexer||{};var c=\" \";a.nvdb.lexer.analyser=function(c,d,e){function f(){j++,k===j&&(/norge|noreg/i.test(h.query)?(h.lokasjon.fylke=[],h.lokasjon.kommune=[],h.lokasjon.norge=!0):h.objektTyper.length>0&&h.lokasjon.fylke.length===0&&h.lokasjon.kommune.length===0&&h.addBbox(),h.objektTyper.reverse(),h.lokasjon.fylke.reverse(),h.lokasjon.kommune.reverse(),_.isFunction(d)&&d.call(e||this,h))}function g(a){for(var b=[],c=a.length;c>0;c--)for(var d=0;a.length>d;d++){var e=\"\";if(a[c-1]==void 0)break;for(var f=d;c>f;f++)e+=a[f]+\" \";b.push(e)}return b}c=a.utils.removeUnwantedCharacters(c);var h=a.nvdb.newSokRequest(c);if(c==void 0)return h;c=a.nvdb.lexer.SlaSammenVegreferanserMedOrddeling(c);var i=a.utils.replaceSpecialCharactersWithWhitespace(c);i=b(i);var j=0,k=0;if(k+=i.length,i.length>=1){var l=g(i);k+=l.length,_.each(l,function(a){vegkart.nvdb.datakatalog.exactMatch(a.trim(),function(a){a!=void 0&&a.length===1&&h.addObjektType(a[0])},this),vegkart.nvdb.lokasjon.sok(a.trim(),{exactMatch:!0},function(a){a!=void 0&&a.length===1&&h.addLokasjon(a[0])},this),f()})}_.each(i,function(a){var b=null;/(^[erfkps]\\S+ve[ig]\\d*$|^[erfkps]\\d+$|^[erfkps]v\\d*$)/i.test(a)&&(a.toLowerCase()!=\"europaveg\"&&a.toLowerCase()!=\"fylkesveg\"&&a.toLowerCase()!=\"kommunalveg\"&&a.toLowerCase()!=\"riksveg\"&&a.toLowerCase()!=\"privatveg\"&&a.toLowerCase()!=\"skogsbilveg\"?(typeof a[2]==\"string\"?(b=a[0]+\"v\",/\\d+/.test(a)&&(b+=/\\d+/.exec(a))):a[1]!==\"v\"&&(b=a[0]+\"v\"+a.slice(1,a.length)),h.addVegreferanse(b.toUpperCase())):(b=a,b=b.charAt(0).toUpperCase()+b.slice(1).toLowerCase(),h.addVegreferanse(b))),f()},this)},a.nvdb.lexer.SlaSammenVegreferanserMedOrddeling=function(b){var c=b.match(/(europa\\s?ve[ig]\\s?\\d*|fylkes\\s?ve[ig]\\s?\\d*|kommunal\\s?ve[ig]\\s?\\d*|riks\\s?ve[ig]\\s?\\d*|skogsbil\\s?ve[ig]\\s?\\d*|privat\\s?ve[ig]\\s?\\d*)/gi);return _.each(c,function(a){a=a.trim();var c=a.replace(/\\s+/g,\"\");b=b.replace(a,c)}),a.log(\"Query etter sammensl\u00e5ing av vegreferanser med orddeling: \"+b),b}})(vegkart)\n. Nice notice btw. The problem was actually related to String.prototype.trim. We fixed the problem by using jQuery trim directly. THANKS!! :)\nIt's a little bit strange. Because we are using jQuery, and jQuery defines String.prototype.trim if it doesn't exists. This works on IE8 when we're not uglifying the javascripts. \n. ",
    "mal": "Not quite, I was hoping for console.log(\"a,b\");\nI use this as I have a dictionary in a text file which is easier to maintain using line breaks, so in my cake build script I read it, convert the newlines to commas, and use DICTIONARY.split(',') in my main code. For now I've worked around it by changing my delimiter, however it'd still be good to solve this problem when defining strings.\n. Yup, that's the work around I came to too! Thanks!\n. Also, if you could determine that x was read only and never used in scope after y had been mutated, or vice versa (or even that both were read only) you could potentially optimise one of the two variables away completely.\nHave to be careful of inner closures, probably pretty unsafe, could be fun though! :stuck_out_tongue:\n. ",
    "lydell": "I minify a few scripts with whose license comments are recognized by the first character being a '!', like so:\n/*!\n * Jade - Compiler\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\nCould  this be possible with the simple .minify function? Perhaps the comments option could be extended to accept a RegExp? I guess /^!/ should do the trick for me. Or if  /*! proves to be a common way to write license comments, perhaps there could be value called 'exclamation mark'.\n. Thanks! I didn't realize that the output option let you do that. For some reason I was scared off by its description:\n\noutput (default null) \u2014 pass an object if you wish to specify additional output options. The defaults are optimized for best compression.\n\nHowever, after reading a bit in the linked article it became clear ;)\nI consider preserving license comments to be an important feature. Perhaps a simple example could be added in the readme?\nI ended up using this regex, btw: /^!|@preserve|@license|@cc_on/\n. The readme file says that you should use this to install: \n\nnpm install uglify-js\n\nAnd from the version 1 readme:\n\nUglifyJS is now available through NPM \u2014 npm install uglify-js@1 should do the job.\nNOTE: The NPM package has been upgraded to UglifyJS2. If you need to install version 1.x you need to add @1 to the command, as I did above. I strongly suggest you to try to upgrade, though this might not be simple (v2 has a completely different AST structure and API).\n\nIn fact I just installed uglify:\n$ npm install --save uglify-js\nnpm http GET https://registry.npmjs.org/uglify-js\nnpm http 304 https://registry.npmjs.org/uglify-js\nnpm http GET https://registry.npmjs.org/source-map\nnpm http GET https://registry.npmjs.org/optimist\nnpm http 304 https://registry.npmjs.org/source-map\nnpm http 304 https://registry.npmjs.org/optimist\nnpm http GET https://registry.npmjs.org/wordwrap\nnpm http 304 https://registry.npmjs.org/wordwrap\nuglify-js@2.2.3 node_modules\\uglify-js\n\u251c\u2500\u2500 source-map@0.1.8\n\u2514\u2500\u2500 optimist@0.3.5 (wordwrap@0.0.2)\nWhich seems to be right. Still, having uglify-js2 available on the NPM is confusing.\n. ",
    "enyo": "Mh, what about an option? UglifyJs.minify(content, { fromString: true });\n. Btw, is UglifyJS production ready? Or should I stick to v1 for now?\n. Cool! Thanks a lot.\n. ",
    "dimitrii": "Thanks Michael.\nI use Google closure compiler & I am looking into UglifyJS2 because some of the libraries we need to compile can't run through Google closure compiler in ADVANCED mode. One thing closure compiler does which I think is amazing is it has the ability to remove code that doesn't do anything. For example closure compiler would remove all of this code if run in advanced mode:\n``` javascript\nvar DEBUG = false;\nvar log = function (str) {\n  if (DEBUG) {\n  // log is a cross browser console logging module\n  }\n};\n// deep inside code all log() functions are removed because they don't do anything\nlog ('here is a log');\n```\nDoes UglifyJS2 give you a way to remove all debug type code, not just console.log, during compilation when using -c? Currently when I compile all of my log() functions remain.\nThanks for reading.\n. ",
    "curiousdannii": "I don't think you're supposed to define the --define'd variables in the source code itself.\n. Alternatively, use JSON 3! :) http://bestiejs.github.com/json3/\n. You should consider using Grunt: http://gruntjs.com/\n. Yes it is, it's a side-effect free string literal.\n. Thanks, that looks like the right solution.\nI'm not sure what I was expecting... maybe that somehow the --define'd DEBUG would remain in scope even after being shadowed by var DEBUG?\n. gzip will deal with the redundancy much more effectively than UglifyJS can.\n. Well it's up to mishoo to decide, but previously gzip has won out: #56, #69. There are probably more in the UglifyJS issues list too. Actually this looks like a duplicate of #69, though you explained what you want a lot better than wyuenho did.\n. You should be able to pass an options object, with the list of protected names in an except property. This is how grunt-contrib-uglify does it: https://github.com/gruntjs/grunt-contrib-uglify#reserved-identifiers\n. How is it slow, and what do you propose doing with it?\n. Use the \"ascii-only\" beautifier option if you don't want that. If you need it to remain as JSON rather than an object literal, then you can use the --expr option. See the readme for more.\n. Yes.\n. ",
    "tJener": "This seems to be related, so I wanted to ask about expected behaviour in certain situations. These are all done on aebafad41eab48f43ed649ce8c77e8f1528b50da.\n:+1: Empty IIFE, works as intended:\n$ echo '(function(){}())' | bin/uglifyjs - -c\nWARN: Dropping side-effect-free statement [-:1,0]\n:+1: Empty IIFE with unused argument, works as intended:\n$ echo '(function(a){}())' | bin/uglifyjs - -c\nWARN: Dropping unused function argument a [-:1,10]\nWARN: Dropping side-effect-free statement [-:1,0]\n:question: Empty IIFE taking an argument, not as I expected. I would want this to also compress down to nothing:\n$ echo '(function(){}(a))' | bin/uglifyjs - -c\n(function(){})(a);\n:+1: Defined empty IIFE, works as intended:\n$ echo '(function(){ assert(); }())' | bin/uglifyjs - -c --define assert='(function(){})'\nWARN: Dropping side-effect-free statement [-:1,13]\nWARN: Dropping side-effect-free statement [-:1,0]\n:question: Similar to above, defined empty IIFE taking an argument, not as I expected:\n$ echo '(function(){ assert(a); }())' | bin/uglifyjs - -c --define assert='(function(){})'\n(function(){(function(){})(a)})();\n:exclamation: Maybe this is too much to handle, but an interesting case:\n```\n$ echo '(function(){ assert(a); }())' | bin/uglifyjs - -c --define assert='(function(a){})'\n/path/UglifyJS2/lib/scope.js:323\n    return this.definition().references.length == 0\n                            ^\nTypeError: Cannot read property 'references' of undefined\n    at AST_Node.unreferenced (/path/UglifyJS2/lib/scope.js:323:29)\n    at Object.before (/path/UglifyJS2/lib/compress.js:942:37)\n    at AST_Node.transform (/path/UglifyJS2/lib/transform.js:62:35)\n    at AST_Node.drop_unused (/path/UglifyJS2/lib/compress.js:1046:18)\n    at Object.merge.before (/path/UglifyJS2/lib/compress.js:85:18)\n    at AST_Node.transform (/path/UglifyJS2/lib/transform.js:62:35)\n    at make_node_from_constant (/path/UglifyJS2/lib/compress.js:148:49)\n    at /path/UglifyJS2/lib/compress.js:1826:24\n    at AST_Node.optimize (/path/UglifyJS2/lib/compress.js:112:23)\n    at Object.merge.before (/path/UglifyJS2/lib/compress.js:89:21)\n```\n:exclamation: And finally, what I hope to be able to do. Though the error is different, I suspect the root cause is probably related to the previous example:\n```\n$ echo '(function(){ assert(a); }());' | bin/uglifyjs - -c --define assert='(function(assertion){if(!assertion)throw new Error})'\n/path/UglifyJS2/lib/compress.js:923\n                in_use[i].orig.forEach(function(decl){\n                         ^\nTypeError: Cannot read property 'orig' of undefined\n    at AST_Node.drop_unused (/path/UglifyJS2/lib/compress.js:923:26)\n    at Object.merge.before (/path/UglifyJS2/lib/compress.js:85:18)\n    at AST_Node.transform (/path/UglifyJS2/lib/transform.js:62:35)\n    at make_node_from_constant (/path/UglifyJS2/lib/compress.js:148:49)\n    at /path/UglifyJS2/lib/compress.js:1826:24\n    at AST_Node.optimize (/path/UglifyJS2/lib/compress.js:112:23)\n    at Object.merge.before (/path/UglifyJS2/lib/compress.js:89:21)\n    at AST_Node.transform (/path/UglifyJS2/lib/transform.js:62:35)\n    at /path/UglifyJS2/lib/transform.js:173:43\n    at Object.merge.before (/path/UglifyJS2/lib/compress.js:88:9)\n``\n. I just realized that you'd need to verify that what's passed into an empty IIFE doesn't have any side effects,(function(){})(a)versus(function(){})(a.mutatorProperty)`. Well, that's a bummer.\n. ",
    "akumpf": "Thanks @mishoo.\nThe script we've been using for testing is about 60k unminified.\nAgreed that the garbage collector is unpredictable and that it's a bit tricky to really trace leaked memory. We use a process monitor (htop) and have about 20 node apps we keep an eye on. Typically, memory bumps up and down as apps run, but and the garbage collector seems to do its magic every 15-120 seconds.  The memory footprint when using UglifyJS2 jumps up and never seems to go down (waiting upwards of 30 minutes).\nAlso good to know that print_to_string is internally the same thing. I was just looking for alternatives in case the leak was happening on the stream end.\nAnything I should test in the meantime?\n. Arg. I stand corrected! :)\nI decided to just go forward with it and see what it did under heavy load (running back to back as fast as it could). Memory for UglifyJS2 jumps up, but levels off around 25MB.\nNot sure why the GC wasn't being invoked earlier. bah. :/\nAnyway, thanks for taking a look at it. I'm sure there's lots of possible optimizations if others use it like I am (focused on on-the-fly minification), but it's doing great for now.\nThanks for all the work on UglifyJS -- it's awesome!\n. Also, this was a fun experiment (running the code in a sandbox using vm) but didn't really make anything better in this case since there's just a lot hanging around waiting to be garbage collected.\n```\nvar vm = require('vm');\nfunction _minify(code){\n  var fn = function(code){\n    var UglifyJS  = require(\"uglify-js2\");\n    return UglifyJS.minify(code, {fromString: true}).code;\n  }\n  var context = {\n    require: require,\n    code: code\n  };\n  var result = vm.runInNewContext(\"(\"+fn.toString()+\")(code);\", context);\n  context = null;\n  return result;\n}\n```\n. ",
    "pedronasser": "I'm having the same problem.\nThere's no solution for it?\n. ",
    "lapo-luchini": "At least it seems to be working in IE9\u2026 in a few years you will be able to revert this commit. ;-)\n. ",
    "obenjiro": "Chrome Version 22.0.1229.94 m - dosn't work\n. ",
    "Irrelon": "If I run it without any other script, requires etc it works so you are right, some other module is interfering somehow. Time to start commenting and finding out which one it is!\n. ",
    "ben-lin": "I know, it works fine for me. However I do not know how other people use my libraries. I think this is important, for example if I use 2 libraries which are both already minified by uglifyjs2 and now if I minify them again there will be problems. This actually happens a lot of time when I use frameworks that has build-in assets management tools. So it would be good to have this option. I think most of the time stable is more important than the size.\n. Hi @mishoo I can't see how to make this option to true. Can you please take a look and give me some clue?\nhttps://github.com/dreamerslab/node.packer/blob/master/lib/packer.js#L86\n. Say I have 3 files \na.js\n;( function (){\n  var a = 'a';\n})();\nb.js\n;( function (){\n  var b = 'b';\n})();\nc.js\n;( function (){\n  var c = 'c';\n})();\nUglifyJS outputs\n(function(){var a=\"a\"})();(function(){var b=\"b\"})();(function(){var c=\"c\"})()\nStill does not have the trailing semicolon at the very end.\n. ",
    "paulirish": "Cool. You're all over it.\nThanks :)\n. FYI: jQuery ran into this one today.\ncc @dmethvin\n. ",
    "jmalonzo": "@mishoo Thanks a lot for fixing this quickly. Cheers...\n. ",
    "ErikV88": "+1\n. ",
    "jescalan": "For sure - writing up details for reproduction now. Thanks for the quick response and your amazing work on this project : )\n. Ok, this should reproduce (coffeescript/node) - this is exactly the code I'm running that's producing the error:\n```\n  contents = the_contents_of_require_js\nUglifyJS = require('uglify-js2') # version 2.0.0\n  toplevel_ast = UglifyJS.parse(contents)\n  toplevel_ast.figure_out_scope()\n  compressed_ast = toplevel_ast.transform(UglifyJS.Compressor())\n  compressed_ast.figure_out_scope()\n  compressed_ast.compute_char_frequency()\n  compressed_ast.mangle_names()\n  compressed_ast.print_to_string()\n```\n. Yep, upgrading to 2.1.6 did the trick. Thank you!\n. Awesome - thanks again for the quick fix!\n. ",
    "jsoverson": ":+1: This would be great. We had to duplicate a fair amount of the CLI logic in grunt-contrib-uglify in order to present a similarly rich api as the command line.\n. ",
    "dylang": "+1\n. ",
    "geddski": "Thanks @mishoo \n. ",
    "sokra": "Thx that case is solved :)\nHere is another example that still doesn't work.\njavascript\nnew (fn().x)\n// minify to\nnew fn().x()\n. javascript\nnew my.module(1);\nnew(my().module(1));\nnew my().module(1);\n\njavascript\nnew(my.module)(1),new(my().module(1)),(new my).module(1);\nThe first one could be shorter.\n. nice :smile:\n. You should write some tests for outputing stuff.\nI tried to write tests for those issues but they didn't fit into the current testing sheme.\n. Thanks for all that fast fixes :)\nNow I'm fine :smile:\n. I recently implemented some new features to the source-map library which should make it really easy to work with SourceMaps:\njavascript\n// Concatenating files including SourceMaps\nnew SourceNode(null, null, null, [\n  SourceNode.fromStringWithSourceMap(contentFile1, sourceMapFile1),\n  SourceNode.fromStringWithSourceMap(contentFile2, sourceMapFile2)\n]).toStringWithSourceMap()\n// => { code, map }\njavascript\n// Mutliple levels of SourceMaps (like coffee -> js -> min)\nvar aggregatedMap = SourceMapGenerator.fromSourceMap(sourceMapJsToMinJs);\naggregatedMap.applySourceMap(sourceMapCoffeeScriptToJs);\naggregatedMap.toString()\nEven if uglifyjs wouldn't support --in-source-file, one can easily build a small tool which aggregates the SourceMaps.\n\n@mishoo You can use this by just ignoring the inSourceMap while minimizing and apply all inSourceMaps after that process.\n. To be more clear:\nIt's included in this case:\ntext\nuglifyjs test.js --source-map test.map --output test.min.js\nBut it's not included in this case:\ntext\nuglifyjs test.js --source-map test.map > test.min.js\nYou cannot know the filename, so maybe it's the best solution to emit a error in that case, instead of writting a corrupted SourceMap.\nOverall your SourceMaps are of very good quality... :smile:\n. I totally aggree that the file property is redundant and should be optional. But currently it's not optional in the spec.\n@fitzgen Is it possible to add an optional to the file property in the spec?\nSome implementations (like mozilla/source-map) throw an error if the property is missing. (Which is correct, as it's not optional according to the spec :-( )\nSo according to the spec SourceMaps without file property are \"corrupt\"... sadly...\n. how ironic ^^\n. ",
    "sindresorhus": "Uhm, that's the point of the whole semver thing in NPM. It won't auto update a major version unless you've set the version to \"*\" which is wrong anyway. This whole thing allows you to do breaking changes in a controlled way and prevent breakage for users.\nThere's a reason it's express version 3.0.2 and not express3 version 1.0.2...\nhttp://semver.org\nhttps://npmjs.org/doc/json.html#dependencies\n\nAnd why is the package and the binary differently named?\n. ^ I would have done the same thing.\n. @mishoo Confusion comes to mind. And I don't see the big deal. It's currently 11 open issues and 2 PRs. I would be happy to move them for you.\n. ",
    "cowboy": "I am by no means a git master, so hopefully someone else will interject if they have a better idea, but here's mine:\nYou could create a 1.3-stable branch in the existing UglifyJS repo from its current master. This branch will always contain the latest 1.3.x, in case some late bug fixes are made there or whatever. After that, import master from this repo into the other repo, preserving its history.\nI just did something like this to test, and I ended up with the UglifyJS repo containing a master (Uglify2) branch as well as a 1.3-stable branch:\nshell\ngit clone git://github.com/mishoo/UglifyJS.git\ngit clone git://github.com/mishoo/UglifyJS2.git\ncd UglifyJS\ngit checkout master\ngit checkout -b 1.3-stable\ngit branch -D master\ngit remote add UglifyJS2 ../UglifyJS2\ngit fetch UglifyJS2\ngit checkout -b master UglifyJS2/master\ngit remote rm UglifyJS2\nThe downside here is that the new master doesn't track the old master in any way, but then, why would it? It was created from scratch in 562b12f021c8b26f5cb52fb322f6465dac4aadc9.\nAnyways, just a few ideas.\n. ",
    "shakiba": "Please update v1 wiki and add @version to npm install uglify-js. It wasn't easy for me to find that I should specify @version to get v1 instead of v2.\n. I have same problem but I didn't understand how you have solved your problem. Can you please explain a little more?\n. Thanks every body.\n. ",
    "kurtome": "Food for thought, I upgraded to v2 on accident on an old project and wasted an hour because I was looking at examples from the v1 github page. Luckily I read the README closely and found the right thing to do. For an hour I had no idea why require(\"uglify-js\").parser was returning nothing\n. > You could also provide helpful warning messages when people call methods from the old uglify-us\nThis seems completely reasonable and easy to implement. Would have saved me a fair amount of time if there were a helpful message printed or error thrown with the correct message when I called .parser\n. ",
    "staabm": "you should add a test for it\n. Do the source map generated by uglify not work for you?\n. The optimization is only safe when the vars contain primitives, isn't it?\n. @mishoo maybe you could publish an update on uglify-js2 npm package which states it as deprecated and give the users a hint which is the right npm module to use..?\nMaybe there is a flag or command for npm, so the package manager knows that the package should no longer be used and therefore outputs a WARNING.\nUpdate: found the following https://npmjs.org/doc/deprecate.html\n. see https://github.com/mishoo/UglifyJS2/issues/105\n. ",
    "scriby": "I'm not sure, and honestly I'm not using Uglify v2 now. I'll tell you what I want to do, and maybe you can tell me if the source maps would work.\nWe log errors that occur in the browser on our production system. I would like to be able to use the line numbers reported in those errors to look up which line of the original source had the error.\nThanks,\nChris\n. I forgot to say \"many thanks for putting this in\"!\n. The nice thing is that you can use the line number from the thrown error and match it up with the minified version of the source to get some idea of where the error came from. It doesn't really matter if that matches up with the original source or not.\nI know there are source maps, but this is just convenient when you just want something quick and easy.\n. ",
    "w00kie": "Am I really the only one with this issue?\nIf the sourceMappingURL in the minified javascript is not pointing to the right path for the source map, then the browser's debugger cannot find it by itself.\n. I see only a number of realistic use cases:\n1. You run uglifyjs from the target output directory with the sourcemap in the same directory: no need for any setting, everything is relative and works fine\n2. You run uglifyjs from the root of your project which is also the root of your site: you do not need a --prefix but you do need --source-map-root to apply to sourceMappingURL\n3. You run uglifyjs from the root of your project which is higher than the root of your site: you need both --prefix and --source-map-root to apply to sourceMappingURL\n4. You run uglifyjs with all full paths, still same as 3\nActually, thinking about it, the common point here is that the sourcemap needs to be in the same directory as the output uglified JS file. If they're not in the same directory, then things start breaking up with the --prefix and --source-map-root model...\nFor a simple case where you merge a couple JS files and compress them, I see no good reason not to have the map in the same directory as the output. However I wonder what happens if these JS files were compiled from coffeescript and have sourcemaps of their own which you reference and might be in other directories.\n. ",
    "dmethvin": "Perhaps I'm focusing too much on our use case, but it seems like it would be better for Uglify to strip the paths unless some other option specifically said to add them. I can see that this is tricky from Uglify's perspective though. \nWhen we release a new version, I want the exact bits in the already-tested jquery.js file to now be jquery-1.9.1.js (for example), so within the release script I will need to rename the paths in the map file in that case regardless. First-world problems. :smiley_cat: \n. ",
    "bdkjones": "Any progress here? This issue has sat open for 2 months. \nI could really use this fix!\n. Additionally, the current system does not even work correctly, because no matter what you pass, the SourceMappingURL path in the minified file never changes. \nSee issue #47 and the fix in #48 (which has been pending for 2 months).\n. Forget what I said above; I was incorrect. What I REALLY need is the ability to just flat-out pass any string I want to be set as the sourceMappingURL in the minified file's special comment.\nThe -p flag isn't going to work; I just want to pass Uglify a path of my choosing and have it spit that out as the sourceMappingURL comment in the minified file.\nIn other words, right now we can specify the exact path that should be used as the sourceMapRoot in the actual mapping file. We do this like this:\n---source-map path/to/file.map --source-map-root /path/I/want/as/this/parameter\nWhat I need is ANOTHER flag that allows me to do the exact same thing for the sourceMappingURL comment in the minified file. Something like this:\n--source-map path/to/file.map --source-mapping-url ./my-map-file-path.map\nThe special comment in the minfied file would then read:\n//@ sourceMappingURL=./my-map-file-path.map\nThe -p flag approach simply isn't working; what I really need is direct control over both of these parameters. \n. As for the bounty, I think it's definitely appropriate for me to kick in. \nIt will take you time and work to implement this request and CodeKit makes money by using (among many other tools) Uglify.js. I know the open source community isn't about profits, but you deserve to be compensated. And since I really need this change implemented to carry on with development of CodeKit, I'd like to chip in so that we can move this to the top of the to-do list!\nJust let me know what your PayPal account is, please!\n. Bounty fulfilled. Thanks for getting on this so quickly!\n. What would be awesome is if Uglify would simply make ALL paths relative to the *.map file.\nThis would be much simpler than the -p flag and associated counting of path components to drop, etc. Uglify knows where the .map file is being created. It knows the full path to every source file. It knows the full path to the minified output file. It's got all the information it needs to calculate relative paths between the .map file and each source file and between the *.map file and the minified output file (which is the one in the \"file\" parameter of the source map). \nWhat I'm seeing on my end is that the \"file\" parameter in the source map ends up being set to this:\n/Users/bjones/documents/testSites/site1/scripts/min/output.js\nIf I host this site on MAMP, this breaks because the \"root\" of the website becomes /Users/bjones/documents/testSites/site1 and the source map then attempts to reference a file at this path:\n/Users/bjones/documents/testSites/site1/Users/bjones/documents/testSites/site1/scripts/min/output.js\nNext, the \"sourceRoot\" parameter in the .map file is optional according to the spec. If Uglify just used relative paths from the .map file to the \"sources\" files, the sourceRoot parameter would not be needed. \nI propose a --source-map-relative-paths flag or some equivalent that would cause Uglify to simply make all paths in the source map file relative to the *.map file, which is the bulletproof way to do it.\n. Awesome! I'll try it out this afternoon and let you know how it goes!\n-Bryan\nSent from my iPhone\nOn Aug 7, 2013, at 1:45, Mihai Bazon notifications@github.com wrote:\n\nThat's a good idea! Should cover most use cases automatically. Done, you can now use -p relative to trigger that behaviour. Note though that it'll only work fine when the output file, source map and original sources share a common prefix.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "chevex": "I realize that I was being an ass and have deleted my comments. I will endeavor to wake up on the right side of my bed tmr. I apologize.\n. You mean other than the fact that when I debug my application while UglifyJS is being used I get 100 [ReferencError] messages?\nIf there's no reason it should be there then you should remove the file argument from vm.runInContext because it expects it to be there when you pass in that argument.\n. If you think this is a good experience for people using your library then I don't know what you would consider to be a bug.\n. Sorry, I'm just in an irritable mood today, my apologies. Did you read the stack overflow answer I wrote? It's a bug with node vm, which I have notified them about. In the meantime, if you pass in the third argument to creatInContext(code, context, file) then you must also pass in process and Buffer. Try it yourself and you'll see.\nIt's probably flown under the radar because most people don't usually pass in console as part of the context and would not see the error message; even then, many people don't pass in the third argument either so the chances of discovering it become even less. The file argument is used for stack traces which is why it only shows up during debugging.\n. At the very very least I'd suggest removing console from the context. At least that would suppress those messages, though I'm not sure what else that would affect for you. You do have the vm call wrapped in a try/catch where you print your own error messages to the console so I don't know if there is even a reason to give console to the vm context.\n. ",
    "KevinSheedy": "Agreed. Supporting tabs for indentation is essential. I can't use uglifyjs without it.\nThe alignment option would also be really nice to have. Maybe it should be a separate issue?\nHere's a great article on why to use tabs for indentation and spaces for alignment.\n. ",
    "guybedford": ":+1:\n. This use case is pretty fundamental for AMD usage. In many scenarios, this is the recommended way of writing modules with RequireJS.\nRequireJS then uses Function.toString to parse out the require statements.\njavascript\ndefine(function(require) {\n  var p = require('some-module');\n  return ...;\n});\nUglified, this becomes:\njavascript\n  define(function(n) {\n    var p = n('some-module');\n    return ...;\n  });\nIf not a general except handling, at least this use case needs to be catered for. It will start becoming more common as dynamic modules are loaded minified but without running builds with the r.js optimizer. For example jQuery core has this.\n. ",
    "lehni": "That's good to know! But what do you think of an option to preserve the strings as they are? Escaping all unicode chars will unnecessarily increase the size of these libraries by 4kb otherwise.\n. In this particular case, the regexps are constructed from strings, so I don't think that would work?\n. It's true that in Acorn, the size would not differ, since all unicode-chars are also escaped in the original file already.\nAs to the suggested change to allow configuring UglifyJS differently per file: This is not necessary for Paper.js, since we minify the library at the end, so we are just specifying \"-b ascii_only=true,beautify=false\" there now, and that works for us.\nFeel free to close this bug, if you consider it a \"wont fix\".\n. That's great! You're right, 2.3.6 handles this correctly. Apologies for not updating correctly first. I forgot the -g switch on NPM.\nIn the more complex real world example, it doesn't manage to omit the unused name of the named function, but doesn't reference it anywhere (just shortens it down to a 'g'). Shall I create a test-case for that and file a separate bug?\n. This was easier to track down than I expected.\nI need to pass unused=false to create paper-min.js, and when doing so, this is the outcome for the above code:\nfunction makeClass(n, t) {\n    return n.prototype = t, n\n}\nvar Class = function() {\n    return makeClass(function n() {}, {\n        test: function() {\n            return new Class\n        }\n    })\n}();\nI think the function's name should still allowed to be removed even with this setting though. It's a minor detail.\n. It's a little complicated to explain, but my class inheritance syntactic sugar library (https://github.com/lehni/straps.js) turns any bean-style getter / setter pair into accessors (e.g. #getValue() / #setValue(value) -> #value), but only if the getter function doesn't receive parameters. And some other methods following the get[A-Z].* naming convention were defining parameters, but were not directly accessing them (only through the arguments array). UglifyJS would get rid of these parameters, and straps.js would then turn the resulting method into a faulty accessor. I have found a way now to write the code differently to avoid this scenario, and don't need to pass unused=false anymore, so it's all good :)\n. ",
    "kriskowal": "This problem exists also for ES5-Shim/Sham and the workaround works. Thanks.\n. ",
    "Munter": "The problem exists when minifying SockJS as well: https://github.com/sockjs/sockjs-client/blob/3f7e5f4ef5673dc15d3d3db890bc82a725f0c91d/lib/utils.js#L182-L211\nThey solve it in a pre-minification step here: https://github.com/sockjs/sockjs-client/blob/master/bin/render.coffee#L33-L38\nHowever when I use their non-minified source and run my own minification i of course get in trouble.\nEspecially IE does not like this transformation:\njavascript\nvar foo = {\n    \"\\ufff0\": \"\\\\ufff0\",\n    \"\\ufff1\": \"\\\\ufff1\"\n};\nto\njavascript\nvar foo={\"\ufff0\":\"\\\\ufff0\",\"\ufff1\":\"\\\\ufff1\"};\nIE sees both property names as the same, firing a warning: multiple definitions of a property not allowed in strict mode\n. ",
    "michaelwsk": "While it's a good feature to have to preserve utf-8 as is in uglify, for those who arrived at this page looking for solution to the \"Invalid regular expression: range out of order in character class\", you can at least add charset=\"utf-8\" in your script tag's attribute, and also make sure you have  in your html mark up to get rid of the error.\n. ",
    "spocke": "Ahh, yes. It gets larger. My fault.\n. ",
    "bminer": "+1\n. ",
    "Jimbly": "It's not just a shortcut, it's a nice, clean API, and what the documentation instructs us to use.  It's unreasonable to have to duplicate 50+ complicated lines of code every time someone wants to change any option (other than the current set of 3 arbitrarily chosen options that are exposed).  Additionally, it seems reasonable that the primary, single-entry-point code API should simply take the essentially same options as the command line API (not require drastically more work or understanding just to change an output option).\n. ",
    "busticated": "thanks guys!\n. ",
    "mlarcher": "same here.\nI'm in a windows environement and the CLI works fine, but when trying to use uglify through a node script I get this error.\n. Here's how I'm using it :\n\nfunction uglyTest(params) {\n    var toplevel = null;\n    var UglifyJS = require('uglify-js');\n    params.src.forEach(function (file) {\n        var code = _fs.readFileSync(file);\n        toplevel = UglifyJS.parse(code, {\n            filename: file,\n            toplevel: toplevel\n        });\n        toplevel.figure_out_scope();\n        var compressor = UglifyJS.Compressor();\n        var compressed_ast = toplevel.transform(compressor);\n        compressed_ast.figure_out_scope();\n        compressed_ast.compute_char_frequency();\n        compressed_ast.mangle_names();\n        var stream = UglifyJS.OutputStream();\n        compressed_ast.print(stream);\n        var minifiedCode = stream.toString(); // this is your minified code\n        console.log(minifiedCode);\n    });\n}\nuglyTest({\n    src: filesArray.configs.app.dev,\n    dest: 'temp/toto.js'\n});\n\nwhere filesArray.configs.app.dev is an array that looks like [ '../js/file1.js', '../js/file2.js' ]\n. Thanks for the insight, mishoo.\nYou were spot on about the encoding_type for readFileSync.\nYou might wanna update the README.md file of the project with that snippet you just pasted :\nAll the code I provided is just copy and paste from there and I was using it to try a basic testcase before going further, so that'd make sense to have this in there as a working example to build upon.\n. thanks for the clarification !\n. ",
    "jpillora": "While we wait for this and for those struggling to use UglifyJS2 in the browser:\nhttps://gist.github.com/jpillora/5652641\n. Node Ftw :+1: !\nSent from my iPhone\nOn 27/05/2013, at 8:20 PM, Peter Paul Elfferich notifications@github.com\nwrote:\nThanks Jaime, I'll keep this in mind if I still get around to updating\nUglify in our Rhino based build scripts before just switching to Node like\neverybody else.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/mishoo/UglifyJS2/issues/67#issuecomment-18491990\n.\n. Here's one use case https://github.com/jpillora/compilejs\nOn Monday, July 8, 2013, Thom Blake wrote:\n\n@maxogden https://github.com/maxogden What is the use case for\nminifying in the browser?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/67#issuecomment-20578762\n.\n. Ah found it npm install uglify-js and uglifyjs --self -c -m -o ./uglifyjs.js\n. \n",
    "difosfor": "Thanks Jaime, I'll keep this in mind if I still get around to updating Uglify in our Rhino based build scripts before just switching to Node like everybody else.\n. ",
    "maxogden": "+1 to this issue, it would be awesome if minifying in the browser was supported by default and well documented\n. I just pushed an update to my app http://requirebin.com which minifies (using the code from @difosfor) and publishes to the Github Gist API (all client side using CORS).\nMinifying is essential for me because loading minified gists is way faster than unminified ones, and they show up nicer on the gist UI https://gist.github.com/maxogden/5945056\n. +1\n. ",
    "tamzinblake": "@maxogden What is the use case for minifying in the browser?\n. Note that you're almost certainly underestimating the number of projects that depend on uglify-js2; some of them will be private.\nThat said, it would be weird if anyone was doing anything serious with the unfinished old version, so it would probably be best to unpublish uglify-js2 in the near future.\n. IE definitely does not support const.  Also, the semantics of const will change with the new ECMA standard so it's not a great idea to use const in other js code for now.  Not sure what this issue is supposed to mean.\n. It is not an error in JS to declare a variable twice.  In fact, the following is perfectly cromulent:\njavascript\nvar a = 2\nconsole.log(a)\nvar a = 3\nconsole.log(a)\nconsole output:\n2\n3\n. Indeed - the frequency of letters in one file probably shouldn't matter when compressing another file... unless that's a feature for when you uglify separately and then concat and gzip.\n. ",
    "niyazpk": "Another one I noticed:\nFrom uglify2 output: This\nfunction (e, s) {\n    zovi.user.logout();\n    var a = s.user_name;\n    zovi.user.setGuestUserEmail(a)\n}\ncould be minified to:\nfunction (e, s) {\n    zovi.user.logout();\n    zovi.user.setGuestUserEmail(s.user_name)\n}\nAny reason it cannot be done? Looks like this transformation can be done regardless of the context outside this method.\n(Again, I apologize if this is not the right place to point these out)\n. ",
    "wyuenho": "I also wonder if this would make gzip perform worse or is duplicating what gzip already does.\n. I just ran into this problem too. I'm also on a Mac.\n. ",
    "arnaudlimbourg": "I had copy/pasted and removed some info. I started from scratch and I still have the error\n```\n$ mkvirtualenv uglifybug\n$ npm install uglify-js\n$ npm list\n  /Users/arnaud/.virtualenvs/uglifybug/lib\n\u2514\u2500\u252c uglify-js@2.2.2\n      \u251c\u2500\u252c optimist@0.3.5\n     \u2502   \u2514\u2500\u2500 wordwrap@0.0.2\n     \u2514\u2500\u252c source-map@0.1.8\n           \u2514\u2500\u2500 amdefine@0.0.4\n$ wget http://code.jquery.com/jquery-1.8.3.js\n$ cat jquery-1.8.3.js| /usr/bin/env uglifyjs                                                                                                                (env: uglifybug) \nWARN: ERROR: Unexpected token eof \u00abundefined\u00bb, expected punc \u00ab)\u00bb [-:2421,35]\n/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:199\n    throw new JS_Parse_Error(message, line, col, pos);\n          ^\nError\n    at new JS_Parse_Error (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:185:18)\n    at js_error (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:199:11)\n    at croak (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:630:9)\n    at token_error (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:638:9)\n    at expect_token (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:651:9)\n    at expect (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:654:36)\n    at parenthesised (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:670:9)\n    at if_ (/Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:918:20)\n    at /Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:758:24\n    at /Users/arnaud/.virtualenvs/uglifybug/lib/node_modules/uglify-js/lib/parse.js:677:24\n```\nRunning the following command does output any error\n$ /usr/bin/env uglifyjs jquery-1.8.3.js\nThis will hopefully help and make the issue clearer.\nI may be doing something wrong but I get this result consistently.\n@rvanvelzen sorry for messing up the copy/paste, it was indeed the same file.\n. @mishoo it is indeed on a mac, I somehow forgot to specify that. I will try to have a deeper look.\n. ",
    "obeattie": "I get this too. It seems compiling from stdin is completely broken.\n```\n$ cat jquery.js | uglifyjs\nWARN: ERROR: Unexpected token: eof (undefined) [-:1929,26]\n/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:199\n    throw new JS_Parse_Error(message, line, col, pos);\n          ^\nError\n    at new JS_Parse_Error (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:185:18)\n    at js_error (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:199:11)\n    at croak (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:630:9)\n    at token_error (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:638:9)\n    at unexpected (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:644:9)\n    at block_ (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:937:28)\n    at /usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:714:29\n    at /usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:677:24\n    at if_ (/usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:921:44)\n    at /usr/local/share/npm/lib/node_modules/uglify-js/lib/parse.js:758:24\n```\n. ",
    "ghost": "I have analyzed the problem futher. It also occurs for simpler structures like \njs\nfunction t(a,b) { \n    var hasDiff;\n    if (a===1) {\n    }\n    else {\n    var child = b\n    if (child) hasDiff = true;\n    }\n}\nwhere the alternative consists of several statements. The problem does not occur, when the \"bracketize\" option of the output stream is set, but then a lot of unnecessary braces will be set, too. I suggest the following change in the make_then function in output.js: Change the first if statement in this function from\njs\n        if (output.option(\"bracketize\")) {\n            make_block(self.body, output);\n            return;\n        }\nto\njs\n        if (output.option(\"bracketize\") || (self.alternative && (!self.body || !self.body.body))) {\n            make_block(self.body, output);\n            return;\n        }\nI am sure that this can be optimized.\n. Thank you for your answer. I have forgotten that this is only in combination with the semicolons option switched off. Then the compressed output looks like\njs\nfunction t(a,e){var f\nif(1===a)\nelse{var i=e\ni&&(f=!0)}}\nIn this case, the compressed output should look like\njs\nfunction t(a,e){var f\nif(1===a){}else{var i=e\ni&&(f=!0)}}\nThis means that the changed code could look like\njs\nif (output.option(\"bracketize\") || (!output.option(\"semicolons\") && self.alternative && (!self.body || !self.body.body)) ) {\n    make_block(self.body, output);\n    return;\n}\n. Thank you for the fix which is better than my suggestion\n. I think that this seems relevant to #320.\n. I believe that this is what the pure_funcs option is for. The assumption is that if someLogic() has some sort of side effect, that side effect will be taken into account at that line, then the value is separate.\nNow, in this case, the latter is obviously a better optimization. Perhaps, it could be assumed that functions with potential side effects can be moved around within code which has no side effects? Example:\njs\nvar x = 1;\nvar url = someLogic();\nvar something = Math.floor(x);\nreturn [url, something];\nwould be optimized to:\njs\nreturn [someLogic(), Math.floor(1)];\nUnder the assumption that Math.floor has no side effects. It notices that because the variables are only used once and their values have no side effects, they can be replaced in the expressions which use them.\n. I think that we're talking about the same thing. :P \nThe point that I was making is that your case falls into the large category of functions that can be moved around without affecting the end result. Pure functions can be moved around completely (and thus easily compressed), whereas the rules for functions with potential side effects should be to not move them around unless necessary, or in the case that you've shown where it would not effect the order of execution. If y were set after data to a different value, you would likely be unable to optimize it because the order of evaluation would change.\nI mean, this would be a very good optimization to have, and I think that it would reduce code size by a lot, but you have to be really careful on what you define as being a good choice to move around and what isn't.\n. ",
    "ulikoehler": "My original patch introduced extra indents for every syntax-highlighted  code block, so I removed that it the latest commit.\nPlease feel free to comment!\n. I added the newlines as you requested, but how do you mean \"squash the commits\"?\nDo you mean something like \"make one commit from the two (now four)\"? AFAIK the Github pull request feature already does this by providing the \"Files changed\" summary.\n. Sorry for the long delay, I will close this pull request and add a new one because it seems to be easier to re-apply syntax highlighting than to merge recent README.MD changes.\n. ",
    "Skalman": "Edit: Please ignore this comment. I just assumed that the online version would always be the current one. It works as expected.\nIf http://lisperator.net/uglifyjs/ is updated, this bug is not yet solved:\n``` js\n// source:\nf(new Array(1,2,3));\nf(Array(1,2,3));\n// actual ouput:\nf(Array(1,2,3)),f([1,2,3])\n// expected output:\nf([1,2,3]),f([1,2,3])\n``\n. A good solution would be for UglifyJS to identify when a variable just _is_ a constant, i.e. it's never written to and it's a non-object. Perhaps guards are also needed forevalandwith`.\n. I get the same result with uglify-js 2.2.5.\nWhile this could/should be resolved it is a logic error in the code - a is declared twice.\n. It's not a syntax error, but declaring a variable twice is unnecessary, possibly indicating that the author made a mistake or doesn't understand how var works.\nThat said, I do think this should be simplified, along with any other code of the construction:\njs\nvar a = something;\n// code without side effects\na = something_else;\n. What do you mean? I believe the goal of Closure Compiler is to minify, just like for UglifyJS.\nThat said, Closure Compiler has a setting \"advanced\", where it makes a lot of assumptions about the code in order to further minify, e.g. properties (my_var.my_property -> a.b). Is that what you mean by obfuscation?\nUglifyJS doesn't support that - it acts similar to Closure's \"simple\" option.\n. You should probably separate \"variables\" and \"properties\". You're talking about \"private\" properties. As you can see from a the this comment on the pull request, a lot of assumptions have to be made about the code, probably breaking a lot of code. For code that's a bit more complex, \"advanced\" requires lots of annotations, and often compiling code twice breaks it.\nE.g. the jQuery project decided that it wasn't worth trying to conform to how that works. If you need smaller code, consider refactoring by using \"project-global\" variables and functions.\n. No, that's not currently possible.\n. Do you have example code that causes that exception?\n. It should work by default. Do you have example code that doesn't work?\n. I think this is intentional, so that you can always concatenate scripts generated by Uglify.\n. You need to click \"copy\" and then press Ctrl+C.\nHowever, I've had that and other problems with Mishoo's online demo, so I created my own, very simple one:\nhttp://skalman.github.io/UglifyJS-online/\n. Yeah, that would be both unsafe and screw_ie8.\n. Still, [].indexOf works slightly differently: it uses ===, while your comparison was == (well !=). In the case of strings that cannot be coerced to numbers or the empty string and objects it's the same, but otherwise works differently.\nAlso this is quite a special case: no \"special\" strings, and only !=. I wouldn't think it's worth it.\n. I found that compressing [...].join() only when it can be completely evaluated defeats the purpose for me, since I very often include variables. So I fixed that and a few other things.\n. The second commit (1588538) fails for [variable, \"str\"].join() when variable == null (because then an empty string is used instead of \"undefined\" or \"null\").\nThe first commit (2b59abf) I, however, believe is correct.\n. I believe UglifyJS just uses parentheses when parsing, but doesn't keep the information, and I don't think there's any point for Uglify to accomodate JSMin.\nI'd suggest either disabling JSMin for these files, or writing clearer JS:\njs\njsonpid++;\nvar id = 'jsonp_' + jsonpid;\n. Here's a shorter PoC:\njs\n(function(a){\n    if (a) { a = 1; }\n    for (var b = 0; ;) {}\n})();\nOutput:\njs\n!function(f){for(f&&(f=1),;;);}();\nThe problem seems to be that when a useless statement in the left-most statement in the for is eliminated, any preceding , is not.\n. @fouber As a temporary fix, you can remove var zz = 0, as that variable isn't used anywhere anyway.\n. ",
    "chrisaljoudi": "@staabm I think it's safe when the expression-node being assigned to the variables has .has_side_effects() false.\n. @ForbesLindesay You're definitely right, sorry for being inaccurate.\n. @ForbesLindesay Yeah that's too deep an analysis -- you'd expect the person who's coding the above would optimize it himself/herself. I initially just thought about this optimization because I had initialized lots of variables to null.\n. @ForbesLindesay There are also cases where defined getters might have side effects, but it's too hard to spot those. That's why I suggested to just make the optimization disabled by default/unsafe.\n. @ForbesLindesay Oh interesting benchmark; I'm running Chrome 23 and actually the separate declaration is slower than either the remaining two. You can never really know if there's a getter defined; and it needn't be a property accessor to be unsafe (think about the case where you do window.__defineGetter__(\"something\", someFunctionThatDoesEvilStuff)).\nPerhaps you're right about the negligible difference in file size. I'm not sure whether UglifyJS keeps track of such 'pure' functions, perhaps @mishoo can clarify?\n. @ForbesLindesay Oh. Never mind about my previous comment. I completely missed the point. Sorry!\n. @mishoo  I see. Well, I just tested with the Google Closure Compiler (it actually took me some time to work around it optimizing away the variables and replacing them with their values). It appears it doesn't do such an optimization, either. Thanks for your explanation!\n. ",
    "adaptabi": "When using AjaxMinifier a minifier tool from microsoft, you are able to remove certain debug statements like this:\n``` javascript\ndebugger;\nWeb.Debug.Output(\"foo\");\n$Debug.Track(\"bar\");\nDebug.fail(\"debug fail\");\nWAssert(condition,message);\nvar wnd = new $Debug.DebugWindow();\n//Will be reduced to this:\nvar wnd={};\n```\nWould be great to add the same behavior to Uglify\n. Hai Mihai, d\u0103-i bice ! \nThis is a MUST have basic feature that needs to be supported when using with r.js\n. I can see that, however a generic use would not be helpful.\nI see it as a pattern, and usually code it like that for easier of debugging.\nMaybe that can be added in a new option?\n. ",
    "dsimard": "Oops... probably was on an older version of uglify. Sorry about that!\n. ",
    "kaelzhang": "I was focusing on a work migrating countless pieces of code into an entirely different framework, so sometimes, the situation I met was a bit complicated.\nWhen I was doing it with uglifyjs1, I wrote a walker myself, which was great that everything was under my control expect for comments. After uglifyjs2 released, I tried to refractor these codes for the long-expected comments and better grammatical accuracy. \nSuppose there's piece of code, we locate a SymbolVar  within before method. Notice that we could do the locating at this time, because during the transformation, the things arround the SymbolVar might be changed which make it impossible to locate a variable i want. Actually I also do a lot of such work in before, and only transform the code in after, because slices of code might have mutual dependencies - they should be transformed simultaneously.\nBut as we know, the node param inside after is a clone of the origin node, so i lost the connection between the located one in before and the node in after. \nSo, I added a property, then we would use if(node.cloned_from === located_var) in after\n. Yes, I care about the detail implementation of UglifyJS\uff0cand have read every lines of the source code.\nI thought it was a problem of maintainability, but not a bug or something.\nBesides, as a user, I didn't realize why my code like if(node instanceof UglifyJS.AST_SymbalVar) could not work until I read lib/transform.js\n. ",
    "jdalton": "The docs made me think that \"comments\": \"all\" would preserve all comments and so setting it to true would auto preserve comments with @license or @preserve.\n. Rad, I was just using comparisons: false, rock!\n. ",
    "qur2": "I also struggle with this problem on OSX, do you when a new version containing commit f83aca6 will be released to npm?\nThanks!\n. ",
    "fidian": "Then I shall amend my current issue and will update the subject line accordingly:\nWould you please ask the people at npm to de-list uglify-js2?\nWhile that is taking place, could you update uglify-js2 to be the latest codebase but somehow show an error or warning that this package is now deprecated?\n. Perhaps emit warnings?\n. I should clarify.  I was using uglify-js2 and did not have any updates.  After trying and trying to npm update to the newest version, I started pointing directly at a zip generated from github.  Then I found that the latest version was not listed in npm the way I had expected and started down this rabbit hole.\nThe bug I'm trying to get resolved is for others who don't even know that uniform-js2 is out of date and don't know that there's an upgrade path to switch to another package.  Us poor unfortunate folk don't see any hints anywhere as to why the website lists 2.2.x and npm lists 2.1.x and we figure that this project is falling by the wayside and the developers need prodding.\nWould you be able to somehow handle my situation?  Initially I installed uglify-js2 because I wanted the newer project.  I did not see anything in the documentation that I read regarding \"uglify-js2 will not be the official name in the future\" so I didn't know I should check uglify-js's version.  I did not see any warning from any install (or at least I don't remember seeing one - it's been quite a while and updates can happen automatically).  My project isn't on github, so I didn't get a bug filed against it by anyone here.  Lastly, npm update and npm outdated don't give me any helpful hints and proclaim that I have the latest version.  Is there a way a bug could be logged against npm to allow a 'succeededBy' property or similar?\n. ",
    "jrburke": "Ah, sorry, it was a particular file that failed with -c. I thought my simple test file would have caused it to fail, but got mixed up when doing some file renaming. \nIf the following file is used, the -c option causes the failure in 2.2.3:\nhttp://requirejs.org/bugs/github/mishoo/UglifyJS2/91/club.js\n. ",
    "lookfirst": "Thanks for fixing this, could you please do a new release sooner rather than later so that I can get @jrburke to upgrade r.js to this latest version?\n. ",
    "paulmillr": "thanks.\n. ",
    "glasser": "Oops, fixed. (And manually confirmed my fix, because the test I added actually passes even without it, because 'expected' is passed through the outputter too.)\n. Is there anything else you need here?\n. @mishoo I know you pulled this in 1529ab965a4a434e6024977a53f8460f6a474086 but it did not actually catch the case that @michaelficarra pointed out. I've updated the PR to only include the remaining code necessary to fix @michaelficarra 's case, and updated the commit message.\nUnfortunately the test suite doesn't really make it clear that the fix is necessary: the new test here passes with or without this patch because run-tests.js beautifys the expected output (in \"make_code\"), which does the incorrect transformation! If you make some manual change to arrays.js to make the test fail and see the INPUT and OUTPUT, then you can see that without this fix, [1,,] -> [1,], and with this fix it stays [1,,].\n. @mishoo Ping. Any chance of merging this? We're stuck using a fork of Uglify until you do.\n. ",
    "Chrazy": "It's already there -> https://github.com/gruntjs/grunt-contrib-uglify\n. ",
    "pwnall": "bash\nuglifyjs --compress --output lib/dropbox.min.js \\\n    --source-map lib/dropbox.min.map --prefix 1 \\\n    --source-map-url dropbox.min.map lib/dropbox.js\nThe file entry in the dropbox.min.map file says lib/dropbox.min.js. Apologies if I'm doing it work :(\n. That would solve my use cases. It seems harder to implement than a manual override, so what you want to do is up to you :)\nI'm not sure why file is there either. I just want my .map file to look like jQuery's :) I assume that map will be supported everywhere.\n. ",
    "akzhan": "Same problem found and partially corrected: https://github.com/gruntjs/grunt-contrib-uglify/issues/39#issuecomment-14856100\n. ",
    "soxofaan": "Same problem here.\nSeems like bin/uglifyjs only looks at source-map and source-map-url when available: (around line 308)\noutput += \"\\n/*\\n//@ sourceMappingURL=\" + (ARGS.source_map_url || ARGS.source_map) + \"\\n*/\";\nthe source-map-root option is not used there\n. ",
    "MikePeterson": "+1 for renaming private properties with the '_' prefix. Currently I have to use another app to perform this action before running UglifyJS.\n. ",
    "jtangelder": "A better way is with JSDoc I suppose. I believe Google Closure is using this also.\njavascript\n/**\n * this method does nothing\n * @private\n */\nfunction whatever() { \n    // really!\n}\n. ",
    "MarkKahn": "Would it be possible to also do this for entire objects?\njs\n/** @private **/\nvar obj = { someKey : 'foo', someOtherKey : 'bar' };\nwhich would yield:\n``` js\nvar a={b:'foo',c:'bar'};\n...\nfn(a.b);\n```\nThough I object to tacking onto something in JSDoc because although I'm perfectly okay obfuscating out a private method / object in my own code, it's very possible that doing this in general would break things because people do hook into and use things that would be \"private\" code in general libraries.  I suppose as long as it's an opt-in flag in uglifyjs it would be ok?\nThough I realize this entire concept is destructive, which uglifyjs is somewhat opposed to, so I'm not sure exactly how to handle it?  It's just ugly seeing my \"uglified\" code look like:\njs\nthis.__someMethod(this.__someProperty);\nwhen it could be:\njs\nthis.a(this.b);\n. ",
    "rtm": "How could that possibly work, when the program could access \"a[foo]\" where the value of foo is computed?\n. Function.length is not a \"funny\" language feature, or something that \"trusting is silly\". It's standard JS. For instance, I have a library which transforms functions into versions which are checked for being called with the right number of arguments. I hope no-one thinks that's silly. Uglify.js should not break this. \nIf you're going to add a flag, please make two separate ones, one for names and a different one for arity.\n. ",
    "maherbeg": "@rtm If you want to access a property via a[foo] you should access it via a['foo'] with a string literal and assign the property to a string literal.\n+1 for this. We can't switch from Closure to Uglify until this is an option. There is a 60KB difference in file size between the two right now.\n. ",
    "gibson042": "I've updated the description at #105, but basically it's not safe when the object is non-native, the property is a method, and the client is Internet Explorer version 8 or lower.\n. The thought had crossed our minds as well. Without pre-optimization to make the hit smaller (which we'll probably do in the long run), unsafe=false has the following effect on our file sizes:\n267643         (-)  dist/jquery.js                                         \n    138636      (+286)  dist/jquery.min.map                                    \n     93331      (+246)  dist/jquery.min.js                                     \n     33033       (+43)  dist/jquery.min.js.gz\n. ",
    "MathRobin": "I'm agree with you. But for the moment, the only problem is that I can't modify the process to concat after minify.\n. ",
    "dcramer": "I also realize --prefix exists, but that's not enough as the number of prefixes could vary per file.\n. ",
    "Page-": "Yeah, I meant more along the lines of it is bad practice but it is done and I was pretty confused why uglifyjs2 suddenly broke the code.  I'd agree with not changing the default (it definitely saves space and should be safe), but adding an option for just the args would be a great solution for me.\n. ",
    "ckknight": "Eh, seeing as the sourcemap filename is part of the text of the map, it does seem like it needs to be a written-out file, so that it can be parsed appropriately.\n. Actually, as long as the file doesn't reference any external files, it's irrelevant as to whether the file is written-out or not.\n. It occurs when there is an input source map that does not cover all lines within the .js file. In the case I have, a bunch of helper functions aren't mapped since they don't come from any source file the user created.\n. ",
    "tilgovi": "I think this is closed by #125\n. This is not necessarily an indication of something wrong internally. I've been exploring many different workflows for source maps and this warning often comes up when some lines don't have mappings. An example is UMD or other module wrappers that are inserted during a bundling process. There is no corresponding source file for these mappings. A valid source map need not map all positions. If that's what's going on here, I would like a way to disable it.\n. Thanks\nOn Oct 29, 2013 1:34 PM, \"tarruda\" notifications@github.com wrote:\n\nIf anyone is still looking for a solution, heres a simple way to disable\nwarnings:\nUglifyJS = require('uglify-js');UglifyJS.AST_Node.warn_function = function() {};\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/pull/265#issuecomment-27340730\n.\n. \n",
    "devongovett": "Is there a problem with this pull request that I should fix, or is this not something you would like included?  Any updates would be appreciated.  Thanks!\n. ",
    "doochik": "Is there any chance to fix this?\n. ",
    "rejeep": "Turned out json2 used eval. Changed to window.eval and it worked.\n. I changed this line (https://github.com/douglascrockford/JSON-js/blob/master/json2.js#L471), from:\nj = eval('(' + text + ')');\nto\nj = window.eval('(' + text + ')');\n. > What about the Apa and Bepa? I'm wondering what has been done to them...\nNothing\n. Once I changed the eval, it did mangle those for me automatically.\n. ",
    "Constellation": "Using indirect eval call, j = ('global', eval)('(' + text + ')'); is better because it works on node.js environment too.\n. Ah, I'll fix esprima side as a esprima committer :)\n. ",
    "gera2ld": "What about the Apa and Bepa? I'm wondering what has been done to them...\n. So is there any way to mangle the toplevel variables?\n. I tried but it only mangles when the variables are wrapped with something like (function(){...})();...\nDo you mean when xxx.js with code var Apa = function() { return \"apa\"; } is uglified, Apa will be mangled?\n. I see, it seems that this option is added recently... Thanks a lot. @mishoo @michaelficarra :)\n. ",
    "dcourtois": "Could you give me an example ? (I'm still quite new to Javascript ^^)\nyuicompressor removes it (I was using this tool before finding uglifyjs) so I assumed it could be safe, and also if it's avaiable through a command line option, the user might be free to use it or not, at his/her own risk ?\nAnyway for the moment I'm removing the \"use strict\"; statement as a step of my build process, before using uglifyjs. I just thought that it might be an option not too hard to add and that a few people might like to have.\n. Thanks a lot for the explanation, I'll need to grab a good javascript book one day to learn those things :)\n. @ForbesLindesay There is also \"use asm\" (see http://asmjs.org/spec/latest/)\n. ",
    "estahn": "Would it make sense to remove multiple \"use strict\" expressions?\n. ",
    "ernelli": "Ok, tried this and it works:\nif(node.thedef.orig[0].init) {\n    console.log(\"defined value: \" + node.thedef.orig[0].init[0].value.value);\n} else {\n    console.log(\"defined value: \", node.definition().init.value);\n}\nSo the value at init.value is the last defined value if there is multiple var statements, will definition x always be the last assigned value?\nI tried the following code with multiple var statements defining the same variable:\n```\nvar uglify = require(\"uglify-js\");\nvar multi = \"var x = 10;\\n\"+\n\"console.log(\\\"x is: \\\" + x);\\n\"+\n\"var x = 20;\\n\"+\n\"console.log(\\\"x is: \\\" + x);\\n\";\nconsole.log(\"code:\\n\" + multi);\nvar walker = new uglify.TreeWalker(function(node) {\n                                       if(node instanceof uglify.AST_SymbolRef) {\n                                           if(node.name && node.name === \"x\") {\n                                               console.log(\"ref x at line \" + node.start.line);\n                                               if(node.thedef.orig[0].init) {\n                                                   console.log(\"defined value: \" + node.thedef.orig[0].init[0].value.value);\n                                               } else {\n                                                   console.log(\"defined value: \", node.definition().init.value);\n                                               }\n                                           }\n                                       }\n                                   });\nvar ast = uglify.parse(code);\nast.figure_out_scope();\nast.walk(walker);\n```\nUglify-js prints out the defined value 20 in both places, but when running the code 10 is printed before 20. I know that scope analysis wont care about semantics and that the second var statement is internally executed as an assignment in the js engine, so to cope with wrong code like this, one has to interpret the parse-tree to track the two separate var declarations/assignments.\n. ",
    "benhughes": "It would great if you could add a licence document to the repo so legal can let us use the new version.\n. ",
    "marcello3d": "Awesome, thanks for the quick response!\n. ",
    "raix": "@mishoo: I'm 100% sure IE doesn't support it, guess only FF does - but IE is one of the few breaking the js code...\nWhy if one wants to declare constants for uglify to strip out etc. and then serve to clients one cant. (except if declaring constants by --define)\nWhy I sugest to a solution would be:\n- strip out constant definitions (at compilation end, if not used anywhere)\n- replace const with var after \"compiling\"? (not sure if even necessary)\n- add support for annotations defining constants (also see #132)\n@thomblake : The uglify doc refers to the const keyword, as a mean to define constants - I'm made this issue to make uglify work in a project - I'm well aware it's an unsupported keyword - hence the issue.\n. I think one should be able to have constants or variables thats only written to once - in objects. Trying keep a clean global scope.\nBut the problem is how to detect variables, (sometimes they are invoced as array element)\nWhy I suggest annotations in comments, should be easier to parse and as comments they are stripped by uglify, so they d\u00f3 no harm in the browsers.\n. ",
    "mgol": "It's a VERY bad idea to use const now in production code. Chrome does support it but doesn't optimize it in any way (yet) so your code will suffer from performance reasons.\nI don't see why UglifyJS would interfere here; const and var have different semantics, UglifyJS shouldn't change the code into a semantically different one, such actions could open a can full of worms.\n. Yes, IE9 doesn't leak here. A simple test case:\nhttp://jsfiddle.net/A3xvq/1/embedded/result/\nThe code is here:\nhttp://jsfiddle.net/A3xvq/1/\nIE9 doesn't leak, IE8 does.\nMaybe renaming to --screw-oldie would be good. I know currently this is the only workarounded issue. I'm just thinking about the future; I'd like to be able to safely use this option in projects dropping oldIE without worrying that a potential edge-case bug in IE9 you'll workaround in the future would cause the minified code to break when applying --screw-ie.\nAn entry in docs saying that this option drops workarounds for IE<9 (and not just \"for IE\") would be helpful, too.\n. I just thought it's sth that's worth to share before you tag the next stable version and it'll start to be used in the wild. :)\n. In case you'd agree with my suggested changes, I created a pull request: https://github.com/mishoo/UglifyJS2/pull/163\nI added a description in README.md, I modified existing command line description so that it says it disables IE6-8 quirks, not IE quirks and I renamed it from --screw-ie to --screw-oldie.\nLet me know if you have any remarks, I'll update my pull request (I care about this little option a lot :)).\n. Yes, that seams more reasonable. In some time IE9 will be old, so that naming would be more future-proof.\nI'll correct a pull request in a moment.\n. Pull request updated.\n. Sorry to bug you but any chance for a release soon? There were very short time periods between 2.2.4 & 2.2.5, 2.2.3 & 2.2.4 etc. and it's been 2 months since 2.2.5. I'd just love to have --screw-ie8 in the final release. :) Are there any problems needed to fix before you can release 2.2.6?\n. I think this would be a worthwile addition to UglifyJS2. However, one has to be aware that computing parameters of empty functions can have side effects so it's not as simple as just removing empty functions invocations since it would change code semantic.\nBut maybe behind a configuration flag?\n. ",
    "yoshuawuyts": "Well, when inserting jade into your online parser (I believe it goes by the name of \"in-browser online demo\") it does nothing but spew out a bunch of errors. Jade is a templating language for HTML (like Stylus is to CSS, sort of.). It would be great if Uglify could be used to beautify Jade documents since at this time being it appears it cannot do so correctly.\n. Thanks for your feedback, I was under the assumption that uglify was\nsimilar to beautify but with extended functionality but clearly I was\nmistaken.\nOn Feb 28, 2013 4:16 PM, \"Jack Moore\" notifications@github.com wrote:\n\nit does nothing but spew out a bunch of errors\n@yoshuawuyts https://github.com/yoshuawuyts, that would be the expected\nbehavior. Uglify is a tool for JavaScript, and Jade templates aren't\nJavaScript. Being able to beautify other languages is outside the scope of\nwhat Uglify should handle.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/134#issuecomment-14237969\n.\n. \n",
    "chrisdone": "Go home, @yoshuawuyts. You're drunk.\n. ",
    "jackmoore": "\nit does nothing but spew out a bunch of errors\n\n@yoshuawuyts, that would be the expected behavior.  Uglify is a tool for JavaScript, and Jade templates aren't JavaScript.  Being able to beautify other languages is outside the scope of what Uglify should handle.\n. ",
    "0b10011": "+1\nThere's also a lot of inconsistency between the CLI and the node API.\n. It should be noted that while these two commits fix a couple issues that have been mentioned, it's really only patching over another, larger problem: The CLI and node interfaces use different code to achieve the same thing, causing two almost-identical (well, should-be-identical) files to be maintained. However, whenever a change is made in on file and not the other, another bug will be created. It should be possible to merge both of these into a single file (maybe map ARGS to options, or vice-versa).\n. Is this going to be pulled in? Do changes need to be made before it will be accepted?\n. ",
    "trygve-lie": "+1. Same problem has hit me.\n. This is true. If using the API the value for outSourceMap is used for the \"file\" value but it should be the filename the map is associated with, iow the minified js file.\nFor \"file\" the spec says:\n\nThe name of the file that this source map is assocaiated with.\n\nThe doc in the readme under The simple way is probably wrong also. It says:\n\nThe value passed for outSourceMap is only used to set the file attribute in the source map\n\nand then shows an example of setting outSourceMap to a .map file.\nI've also tested the command line and this is not true any more: \n\nAs a side note, I also noticed that the commandline uglifyjs tool isn't writing the \"file\" key at all.\n\nThe command line does now set a value for \"file\" and it does correctly point to the minified js file which is correct according to the spec. This shows that its a mismatch between the command line and the API.\n. @tremby I sadly don't know when it was fixed but I did a test by creating a source map by the command line tool and it did indeed set a correct value for \"file\" in the .map file. I tested this with version 2.3.6.\n. ",
    "tonylukasavage": "Can someone confirm for me at least that what I've put forth in the issue here is true and that it should be resolved? I will investigate it myself if this is the case.\n. I hacked v1 to do the same. Don't forget to make sure large numbers don't use exponential format (10e23) as that will break JSON as well.\n. ",
    "benvanik": "I'd also like this feature. RE naming: Closure compiler calls this 'output_wrapper'.\n. ",
    "jharding": "@mishoo any thoughts?\n. ",
    "Delapouite": "Hi.\nThis enclosing command line option is quite useful.\nIs there a way to trigger it when calling Uglify through the API ?\n. ",
    "spadgos": "\\o/ wow awesome. Thanks.\n. ",
    "jasondavies": "Thanks for the quick response!  Will you also be tagging a new version that includes this soon?\n. Right, fixed.  I\u2019m not sure how to test this particular case, since the existing tests all seem to work on parse trees.\n. ",
    "tarruda": "I get something similar, but I'm not sure this is a uglifyjs bug. according to this bug report, it is a typescript issue\n. this is a useful and small patch, +1\n. If anyone is still looking for a solution, heres a simple way to disable warnings:\njs\nUglifyJS = require('uglify-js');\nUglifyJS.AST_Node.warn_function = function() {};\n. ",
    "justinTNT": "yes, it's a great tool, but this is sorely missing.\n. ",
    "pharcosyle": "+1\n. ",
    "edc": "For those interested, I created a very simple utility called mapcat that consolidates source map files while concatenating js files. It's very primitive at the moment, but I can use it as the step before UglifyJS2. Feel free to expand it as you see fit.\n. That is indeed tricky. How about just allow people to specify multiple --in-source-map, like:\nuglify --in-source-map module1.map --in-source-map module2.map\nYou could also allow regular JS - those hand-written and without associated map file - to be supplied as well:\nuglify --in-source-map module1.map --in-source-map module2.map module3.js\n(mapcat currently does not support this. otherwise it could be a used as a good preprocessor.)\n. ",
    "TheHippo": "+1 (or someone gets the coffeescript compiler to properly join multiple files and their source maps.)\n. ",
    "pyykkis": "Browserify took a bit different route (which I find quite compelling):\nbrowserify('main.coffee').transform(coffeeify).bundle({debug: true})\nbuilds a single file with main.coffee and all dependencies included. Source map is inlined at the end of result stream with base64 encoding. Works like a charm.\nCould Uglify decode the source map and replace it with a multilevel source map? I'd love to do something like\njavascript\nbrowserify('main.coffee')\n  .transform(coffeeify)\n  .bundle({debug: true})\n  .pipe(UglifyJS.transformStream({debug: true})\n  .pipe(fs.createWriteStream('dist.js'));\n..and have multilevel sourcemap inlined all the way.\n. ",
    "Inversion-des": "Also was surprised to find out than uglifyjs supports joining multiple files generated by CoffeeScript, but cannot use sourceMappingURL included in every such file (instead of using --in-source-map).\n. ",
    "mgutz": "I've been doing this for a while with projmate, which is a cross between grunt and browserify. See coffee-backbone-sourcemap example. Basically, the project compiles all CoffeeScript and JavaScript in a directory into a single CommonJS module (based on stitch) into a separate build directory. Most transpliers generate the map in the same directory which is annoying.\n. ",
    "russelldavis": "+1\n. ",
    "ashmoran": "I'm really new to JavaScript, never mind source maps, so I just ran unwittingly into this. It'd be a big help if UglifyJS could read multiple source maps, as it would remove the mapcat step from my build pipeline. Using mapcat works fine, but involved an hour or two of searching around and plugging it in. It's a shame UglifyJS can read in multiple JS files but not multiple source maps, as it makes the feature a bit asymmetric.\n. ",
    "celtric": "Given that this can be achieved easily using a build script, I'll close this issue so the devs can focus on more important things than this specific case.\n. ",
    "skotchio": "Thanks for the reply. Yes I mean this. Ok but does uglifyjs support mangle of \"private\" variables that starts with underscore?\nThere is pull request in uglifyjs https://github.com/mishoo/UglifyJS/pull/309\nCan you apply this patch to uglifyjs2 ?\n. So uglifyjs works fine?\n. Thanks for the response but how can I workaround it?\n. ",
    "SLaks": "Lines 685 - 687 of the original code are:\njs\n    object = valueOf(object);\n    // assimilate thenables, CommonJS/Promises/A\n    if (isPromiseAlike(object))\nUglify transforms that to:\njs\nif (n = t(n), v(n)) {\nThe problem is that the call to valueOf() becomes a call to the wrong function (t()):\njs\n    function t(n) {\n        return \"[object StopIteration]\" === he(n) || n instanceof se;\n    }\nt() is actually the mangled name of isStopIteration():\njs\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\nIt should have emitted a call to l() (which is the actual mangled name of valueOf():\njs\n    function l(n) {\n        return d(n) ? n.valueOf() : n;\n    }\nUnchecking the Mangle checkbox in the online demo causes it to emit correct code.\n. You're misunderstanding the original code.\nThe valueOf() function called by line 685 is not the function expression on line 738; it's the function declaration on line 563.\nhttps://github.com/kriskowal/q/blob/76afd7b7abaad30cbfee394c72227d9dc06154e6/q.js#L563-L568\nIt looks like Uglify is incorrectly making the valueOf() from the function expression visible in its parent scope.\n. I was wondering if that was the case, but unchecking IE-proof output doesn't fix it.\nI didn't write the original library, and I don't know if it works in IEs that have that bug.\n. For anyone else having this issue, just use Q v0.9+, which doesn't have the problem in the first place\n. @lefnire's issue is caused by transforming (function(){})() to !function(){}(), which Racer didn't expect.\nFixed by https://github.com/codeparty/racer/pull/130\n. Uglify is in the right here; you've saved one character.\nThe fundamental problem there is that Racer wants to uglify an expression (function expression), whereas Uglify is designed to uglify statements (and function declaration statements must have names).\nShould Uglify have a function to uglify expressions rather than statements?\n. ",
    "lefnire": "changes in 2.3.2 also caused this issue for me (SLak's link https://github.com/lefnire/habitrpg/issues/920). pinning to 2.3.1 fixed\n. ",
    "GreenImp": "I've not looked into Grunt too closely, but it seems a bit over the top, just to enable merging of JS.\nI was thinking of something more simple, like this script does: http://js-preprocessor.com/\nThe issue with that one, though, is that it doesn't seem to compress/minify the files at all.\nI guess that I could you js-prepocessor to combine them, then Uglify to compress them, but doing it all from one command would be nice.\n. ",
    "ppissanetzky": "Even when using --screw-ie, I see the behavior I posted above (in version 2.2.5)\n. Yes, with the latest from git it works fine either with or without the option. Good work.\n. ",
    "RefinedSoftwareLLC": "From my understanding JavaScript is a super set of JSON. Meaning that JSON is always valid JavaScript code but JavaScript is not always valid JSON code (JSON does not store pointers, functions, Infinite, NaN, etc). In this case a trailing semicolon breaks JSON, (the only semicolon in the whole returned string).\n. I am not using eval() to turn JSON strings to Objects that just store data. On Chrome I can do either of these just fine:\nconfigBill = {  a: 1,   b: 2,   c: 3 }\nconfigJill = { \"a\": 1, \"b\": 2, \"c\": 3 }\nfor the same results, a data object. So whether in a JavaScript code file or in a JSON file, they can look exactly the same to non-programmers that are changing configurations or doing data entry.\n. Well I am using NodeJS, which runs on Chrome V8, I haven't tested on other browsers. But I am not planing on having my clients changing settings in a JSON file in their HTML5 cache folder either. The following code seams quite useless as it doesn't do anything but take up CPU and Memory:\n{\"a\": 1}\nWhere as the following is useful:\nmyVar = {\"a\": 1}\nSo I do not get why JSON not working in the toplevel is an issue because JSON in the toplevel is completely useless because it doesn't have any functions only properties.\n. This is how a JSON file looks in a text file or as the string of a JSON text file:\n{\"a\": 1}\nThis is how you copy and paste this by hand into a JavaScript file:\nmyVar = {\"a\": 1}\nTo programmatically do this (like my config files) you use the following: \n/* text file looks like this:\n{\"a\": 1}\n*/\ndata = readFile();\nmyVar = JSON.parse(data); // data = \"{\\\"a\\\": 1}\"\nI would like to use UglifyJS2 to change the JSON text file from:\n[{\"a\":1,\"b\":2},{\"a\":1,\"b\":2}]\nto a readable form that is better then the other Beautifiers out there:\n[ {\n    \"a\": 1,\n    \"b\": 2\n}, {\n    \"a\": 1,\n    \"b\": 2\n} ]\n. Yes, I just checked using my hack above and it doesn't work if the top level is not an array.\nError\n    at new JS_Parse_Error (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:185:18)\n    at js_error (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:199:11)\n    at croak (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:630:9)\n    at token_error (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:638:9)\n    at unexpected (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:644:9)\n    at semicolon (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:664:43)\n    at simple_statement (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:822:73)\n    at C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:693:47\n    at C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:677:24\n    at block_ (C:\\projects\\webstorm\\mother\\node_modules\\uglify-js\\lib\\parse.js:938:20)\nI guess I can use:\nif (typeof data === \"string\") {\nJSON.stringify(JSON.parse(data), null, 4);\n} else {\nJSON.stringify(data, null, 4);\n};\nBut once again this does not beautify as well as UglifiyJS2 nor have advanced features like max line length.\nDoes anyone know a hack to fix the above error? maybe adding \"[\" and \"]\" to the beginning and end of the string then removing them after...\n. https://github.com/mishoo/UglifyJS2/pull/158\nOkay I just requested a pull of adding my feature:\nUglifyJS.beautifyJSON(files, options) { return beautifiedString; };\nto the master branch. I just spent all day working on it. I tried to keep it similar to your code while still keeping it readable and easy for me to follow. The biggest difference is that it supports giving it Objects and arrays of objects; and using JSON.stringifies replacer feature. What do people think of this feature?  I have already started using this like so:\nconsole.log(UglifyJS.beautifyJSON(object, { fromObject:true } ));\nI wish that the option fromFile:true wasn't the default (if it existed as it is currently implied), I kept this the default behavior though for consistency. \n. ",
    "vendethiel": "\nThis is, but probably not for the reason you think:\n{a: 0}\n\nTel me if I'm wrong -- this is a block with a label in it, right :p ?\n. > @Nami-Doc not exactly. It's a block containing one labelled statement. The statement is 0; and the label is a\nThat's what I meant ^^\n\nI am not using eval() to turn JSON strings to Objects that just store data. On Chrome I can do either of these just fine:\nconfigBill = { a: 1, b: 2, c: 3 }\nconfigJill = { \"a\": 1, \"b\": 2, \"c\": 3 }\nfor the same results, a data object. So whether in a JavaScript code file or in a JSON file, they can look exactly the same to non-programmers that are changing configurations or doing data entry.\n\nre-read what @michaelficarra said.\n{} on toplevel is a bloc. An assign is not toplevel. Try yourself in chrome.\n```\n\n{}\nundefined\n{a: 1}\n1\n({a: 1})\nObject {a: 1}\n``\n.filtering`?\n. \n",
    "fitzgen": "Opened discussion here: https://groups.google.com/forum/?fromgroups=#!topic/mozilla.dev.js-sourcemap/NeGKskH52Sw\n. ",
    "ziemkowski": "As a result of this change, the actual reason for the error is never output when using the CLI, making it rather difficult to debug the issue when using the CLI.\n. For reference, when you encounter a syntax error, this is all that is displayed by the uglifyjs CLI command ever since the fix for #159 was merged in and why this patch is so necessary for those of us using that script:\n/opt/local/lib/node_modules/uglify-js/lib/parse.js:204\n    throw new JS_Parse_Error(message, line, col, pos);\n          ^\nError\n    at new JS_Parse_Error (/opt/local/lib/node_modules/uglify-js/lib/parse.js:196:18)\n    at js_error (/opt/local/lib/node_modules/uglify-js/lib/parse.js:204:11)\n    at croak (/opt/local/lib/node_modules/uglify-js/lib/parse.js:636:9)\n    at token_error (/opt/local/lib/node_modules/uglify-js/lib/parse.js:644:9)\n    at expect_token (/opt/local/lib/node_modules/uglify-js/lib/parse.js:657:9)\n    at expect (/opt/local/lib/node_modules/uglify-js/lib/parse.js:660:36)\n    at expr_list (/opt/local/lib/node_modules/uglify-js/lib/parse.js:1137:44)\n    at subscripts (/opt/local/lib/node_modules/uglify-js/lib/parse.js:1271:30)\n    at subscripts (/opt/local/lib/node_modules/uglify-js/lib/parse.js:1248:20)\n    at expr_atom (/opt/local/lib/node_modules/uglify-js/lib/parse.js:1129:20)\n. @mishoo any thoughts on this? \nIt would be quite nice to have parse errors visible via the CLI again, one way or another.\n. ",
    "jstarrdewar": "What you want to do is put this line:\nif ( typeof DEBUG === 'undefined' ) DEBUG = true;\nOutside of the function scope where you are using strict mode.\n``` js\nif ( typeof DEBUG === 'undefined' ) DEBUG = true;\n(function(){\n    \"use strict\";\n    if ( DEBUG ) console.log( 'hello there!' );\n})();\n```\nWith DEBUG you are working with the global scope, and that's sort of the point.  Of course if you ever did run into a library that was using DEBUG for some other purpose, DEBUG is an arbitrary name and you can use anything else in its place:  if (typeof UNMOTH === 'undefined') ... You just have to pass that same name to Uglify.\n. ",
    "timmutton": "Hey, I gave it a try, and it mostly works however the compressor appears to reorder the bitwise operations, specifically \"| 0\", which needs to be in a particular order to validate\n. I've been playing around with the asm branch of lljs and that was the only\nissue I had (tested by manually fixing it and it worked), although the\noutput only had one closure. I also had to turn off sequences, function\nhoisting and variable joining but thats an easy enough fix\nOn Sun, Jun 2, 2013 at 9:43 AM, \u270c Makis Tracend notifications@github.comwrote:\n\nThat's great.\nCreating the variable fallbacks seems a straightforward problem to solve.\nMy main concern is in constructing the object matrix of all the closures.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/167#issuecomment-18799161\n.\n. Yeah, the dynamic aspect of javascript is really neat.\n\nMy understanding is that asm and lljs aren't meant to be a full replacement\nfor normal js, just a way to speed up arithmetic heavy parts (and the\nresults so far are impressive).\nThe fact that you can mix multiple languages/styles into one program is a\nfeature that's unique to javascript and probably one of its greater\nstrengths, I can certainly see it becoming common for a project to have\nsome files compiled by tsc, ljc and whatever the coffeescript compiler is\ncalled, then merged together/optimised by a program like uglifyjs or\nclosure (although id prefer uglifyjs because its in js and is more\nconfigurable)\nOn 02/06/2013 1:03 PM, \"\u270c Makis Tracend\" notifications@github.com wrote:\n\nI saw LLJS in your repos - really awesome stuff.\nAlthough my aptitude is in dynamic programming I do believe that the\nbridge for static typing in Javascript, and thus before runtime\ncompilation, can be automated with middleware.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/167#issuecomment-18801044\n.\n. You said before that fixing up the reordering of bitwise statements wouldn't be too hard, would you be able to point me in the right direction for fixing it up? Id like to have a crack at fixing it up, as I need it to get my other projects working\n. @tracend The bitwise operators are fine, its just asm requires them to be after the statement (eg a = b | 0 validates, but a = 0 | b doesnt)\n\n@mishoo Thank you, that would be greatly appreciated\n. Thanks for the update. Unfortunately it has to be the former. After further testing, I've come across two other issues. \nThe easier of the two is that asm uses the format x = +y to show that y is a double and therefore so should x (it also does this with constants eg +1 but 1.0 also works, not sure why) \nThe other (much more complicated) issue is that when removing unused variables, if the rhs is left it breaks asm eg var a = new Float32Array(b)  becomes new Float32Array(b) which unfortunately breaks\n. Sorry, I described that pretty badly, what I mean is something like that,\nbut for the internal api when embedding uglifyjs inside another application\nOn Wed, May 22, 2013 at 4:39 PM, johmoh notifications@github.com wrote:\n\nHmm, I thought that is what ...\n-r, --reserved Reserved names to exclude from mangling.\n... is for. Or have I misunderstood your question?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/214#issuecomment-18260025\n.\n. All good, I'll have to set aside some time and get familiar with the\ninternals\nOn 22/05/2013 5:10 PM, \"johmoh\" notifications@github.com wrote:\nAh, okay. Then I am sorry. I can not help you. If I were you I would take\na look at the implementation of the command line tool. Because if you can\nspecify reserved words with \"---reserved\" then there already must exist a\npossibility for reserved worlds in the api. - But I am sure, you know that\nalready.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/214#issuecomment-18261063\n.\n. Oh wow, I'll have to test that but it appears to be exactly what I'm after.\nIt might be worthwhile to put that in the section on mangle in the readme\n(under api - the simple way)\nOn 22/05/2013 5:25 PM, \"Dannii Willis\" notifications@github.com wrote:\nYou should be able to pass in a list with except. This is how\ngrunt-contrib-uglify does it:\nhttps://github.com/gruntjs/grunt-contrib-uglify#reserved-identifiers\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/214#issuecomment-18261558\n.\n. @sroussey Im just waiting for a commit regarding the re-ordering of bitwise statements and then I'll try the method curiousdannii suggested. It looks like it should do what I requested, I'll let you know how it goes though\n. \n",
    "tracend": "That's great. \nCreating the variable fallbacks seems a straightforward problem to solve. My main concern is in constructing the object matrix of all the closures.\n. I saw LLJS in your repos - really awesome stuff. \nAlthough my aptitude is in dynamic programming I do believe that the bridge for static typing in Javascript, and thus before runtime compilation, can be automated with middleware. \n. I agree with your first comment - it makes more sense (for now) to use it in contained routines, like the scripts we pass onto web workers which have a specific io. \nUglifyJS minification to asm.js would be my preference as well. \n. Oh, I'm not aware of the specifics why the compressor might be reordering the bitwise operations but I'm sure someone from the core team of UglifyJS can answer that. \nBut I had fun working with bitwise operators recently on three-obj (to convert OBJ to binary JSON)\nhttps://github.com/makesites/three-obj\nFor me the MDN page was quite helpful (if you need a basic reference): \nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\n. awesome, got it. a = 0 | b does look weird. \n. ",
    "tremby": "@trygve-lie, can you reference the commit or pull request or issue where that last bit was resolved? Or do you just know it not to now be the case? (I don't have time to test just now.)\n. ",
    "papandreou": "UglifyJS is unescaping the chars, which is perfectly legal and takes up less space. I get this output:\njavascript\nnew RegExp(\"[\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]\");\nNote that the output of uglifyjs is UTF-8. The output you're quoting looks like UTF-8 interpreted as iso-8859-1. Are you maybe serving the compressed files with a non-UTF8 charset?\n. There's also a --beautify ascii_only=true command line option that would keep those chars escaped in the output. I don't know whether it can be turned on without also turning on beautification.\n. There's a good chance this was fixed by https://github.com/mishoo/UglifyJS2/commit/69dde0462b409a709c4a8cddffc1bb8d641201e2 -- but it's not in a release yet. Could you try with the current master?\n. Looks like a duplicate of #180\n. ",
    "markmevans": "@mishoo Seems like it. I haven't found anything in the ECMA-262 5.1 that justifies Safari's behavior, but I am a JavaScript noob so I thought maybe it was a matter of interpretation of the spec.  Anyway, I wasn't sure and I thought it might be an issue that others would run into.  I ran into this \"minimizing\" an AngularJS project.  The code that's tripping up Safari is in AngularJS so I can't modify it. But it looks like I can work around this by using angular.min.js.\nIn case you're interested, that file is generated using Google's closure compiler which apparently converts the nested function into an anonymous function since there are no references to the function's name.  Something like:\n\"use strict\";function f1(){return function(n,t,u){}}\nMaybe that's a worthwhile enhancement?\n. Facepalm. Thanks.\n. Enabling mangle and compression worked around the Safari bug for me.\nuglify: {\n  options: {\n    mangle: true,\n    compress : true\n  }\n}\nOn Apr 9, 2013, at 2:31 AM, Eugene Bogomolny notifications@github.com wrote:\n\nHello!\nI use grunt task manager to build the project. I use the latest version of grunt-contrib-uglify. Project on AngularJS. I describe task in grunt:\nuglify: {\n        options: {\n        compress : false\n        }\n }\nbut it seems that it does not change anything. And this problem in Safari still exists. Any advise?\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "mgcrea": "Encountering this as well, options: { mangle: true, compress : true } did not work for me, I still get a function r() that breaks safari 6.\nThis can break many minified scripts, shouldn't this be handled by uglify in some way (through an option maybe), even it the behavior is safari-only?\nHow can I minify & avoid name collision breaking safari otherwise?\n. @ashclarke Thanks! Found that this error was indeed triggered by this code:\nvar CountdownFactory = function CountdownFactory(options) {\n. ",
    "ashclarke": "@mgcrea: On a side note (sorry it's not contributing anything):\nThanks for finding this! I found an issue with my own code whereby I was encountering a strict mode exception because I had the following:\nRow { // Object \n    show: function show(show) { //code }\n}\nThe parameter name show was conflicting with the named function, but only in Safari (My version happens to be 5.1.7 on Windows).\nThis bug report saved me a lot of searching time!\n. ",
    "tomByrer": "\nthis is bad because some people put the //@ sourceMappingUrl comment at the bottom of the file\n\nThis was true at first, but seems the *.min.map reference has switched to the second line, I assume to be compatible with Closure's & UglifyJS2's JSDoc-commenting http://code.jquery.com/jquery-2.0.3.min.js\n. ",
    "dmoses48": "I have seen other minifier/compressors that allow you to add an optional ignore global.  For example\n//Create a global\nvar debug = {\n    warn : function(args) { ... },\n    error : function(args) { ... },\n    exec : function(args) { ...}\n}\nAnd then they would have debug.warn(\"something\"); and the like sprinkled through the code.  You could then use a compressor option to remove all calls to anything in the debug object.  I know this is one of my major qualms with most compressors, I want to completely remove the logging code from my minified version, but I don't want to put if (DEBUG) statements all over my code.  And if you put the if (DEBUG) in a common method, than you have to do all the string formatting on the client even when you don't need it..\n. ",
    "pifantastic": "So, it looks like this project is the exact solution I was looking for! Feel free to close this issue unless you feel it's still a good idea.\n. ",
    "konfiot": "Hmm, How silly i am ...\nIn my real app, I just have to sort the filenames, then change them and place a number (e.g : 1-jquery.js) then Jquery will be placed on the top of the minified file\nAnyway, hope it could help other people ...\n. ",
    "bcherny": "@curiousdannii is this a consideration in which optimizations uglify does and doesn't? it seems to me that uglify's concern is minifying as effectively as possible, not necessarily usage in conjunction with other tools.\n. Nice find! Though that issue is a few months old, I wonder if the position has changed. In any case it should come down to the data I think - I'll run some size benchmarks and report back.\n. So I ran a few benchmarks, and the results were pretty conclusive - for files over 1k or so in size, tokenizing strings and minifying prior to gzipping consistently produced the smalles file sizes. For files under 1k, minifying+tokenizing (no gzip) produced the smallest file sizes. I'll write up a blog post about this soon :) For now, here's the data:\nSpreadsheet with data\nRepo with test runner and source files\n. Agreed, but that wasn't the point. I was trying to test whether there exists a scenario in which tokenization yields a size improvement, or if gzip always handles string minification better than uglify could. The tests revealed that in fact, tokenization is always more effective than gzip. For a next step I'll try to prototype a string minifier and see how it performs for something like jQuery.\n. After manually tokenizing the top 10 most repeated strings in jQuery (using esprima + node), my tests have come up inconclusive, and give little reason to implement a string tokenizer in Uglify.\nFor those interested (file sizes are in bytes):\njquery.js - 267012 (266786 tokenized) -> 0.08% smaller\njquery.min.js - 94250 (94078 tokenized) -> 0.2% smaller\njquery.min.js.gz - 79560 (79664 tokenized) -> 0.13% larger!\nThe 10 most commonly used strings were:\n1. \"\"\n2.  \"string\"\n3. \" \"\n4. \"object\"\n5. \"*\"\n6. \"undefined\"\n7. \"input\"\n8. \".\"\n9. \"boolean\"\n10. \")\"\nPerhaps the results would be different for libs with more repetition, larger strings, and if I had written a more sophisticated tokenizer with the ability to detect repetitive substrings rather than full strings - a suffix tree would be useful for anyone interested in looking into it further. For now, it seems that improvements are unlikely due to gzip's more efficient string tokenization (gzip's pointers are smaller byte-wise that we could write in javascript), and any improvement would be marginal.\n. ",
    "Qantas94Heavy": "That's an IE issue - put a semicolon after any do-while statement in old IE versions and you'll get that error.\n. Wouldn't there need to be a check for dependencies to properties defined in the original object literal?\n. Wouldn't we need to parse the code to check for scope issues?  IMO that's overkill.\n. Of course, too obvious - please close.\n. ",
    "jamesonquinn": "hmmm, you're right. I thought it was a bug in uglify because the chrome console's strange behaviour on a breakpoint here tricked me:\n\na = (e = Session.get(\"step\"), e)\n  null\ne\n  undefined\n\nBut now I see that such strange behavior is a bug in chrome:\n\ne = 123\n  123\ne\n  undefined\n\nSo who knows what's going on here, but I can fix it by checking against null as well as undefined, and it's not uglify's fault.\n. ",
    "macgyver": "Hmm, it seems there are a few other old implementations that apparently don't support it, according to  this http://kangax.github.io/es5-compat-table/#Reserved words as property names\nI'm pretty sure Rhino 1.7 is the current version.. not sure about the prevalence of the other unsupportive environments, but maybe this is a riskier change than I earlier thought..\n. ",
    "jedireza": "+1 thanks @bfrohs \n. ",
    "niclashoyer": "Waiting for this! I'm currently using sed in my Gruntfiles to strip out extra paths, because the prefix option is not supported\n. ",
    "indutny": "Well, not really. Its just inconsistency in esprima, not an issue, because UpdateExpression is used to denote postfix operations and UnaryExpression is used for all prefix operations. But I've opened pull request for it (esprima) too.\nExample:\n``` javascript\nvar ast = {\n  type: 'Program',\n  body: [{\n    type: 'ExpressionStatement',\n    expression: {\n      type: 'UnaryExpression',\n      operator: '!',\n      argument: { type: 'ThisExpression' }\n    }\n  }]\n};\nconsole.log(require('.').AST_Node.from_mozilla_ast(ast).print_to_string()); // 'this!'\n```\n. Right, I agree with you. Hadn't thought about that, though UnaryExpression is always prefix for obvious reasons.\n. Sure, no doubt it. It just would be a big help for me, if you'll account it in moz_parser, because I've some blocked stuff that waiting for either of two sides to fix it (and esprima is waiting for mozilla to fix their tests, so probably this side is way mooore slow than UglifyJS2).\n. @mishoo can I ask you to publish npm module with this fix?\n. Thank you!\n. ",
    "justin-lau": "It can now deal with unicode identifiers, good catch!\n. ",
    "treygriffith": "No problem, it was a quick fix anyway. Thanks for responding so quickly!\n. ",
    "Zugwalt": "Compressing via passing a list of file names. The files passed to uglify (and their order) is:\nhttp://minecraft.pinheadinstitute.org/js/jquery-1-9.js\nhttp://minecraft.pinheadinstitute.org/js/jquery-ui-1-10.js\nhttp://minecraft.pinheadinstitute.org/js/placeholder-support.js\nhttp://minecraft.pinheadinstitute.org/js/navbar.js\nhttp://minecraft.pinheadinstitute.org/js/home.js\nhttp://minecraft.pinheadinstitute.org/js/faq.js\nhttp://minecraft.pinheadinstitute.org/js/bootstrap.js\nhttp://minecraft.pinheadinstitute.org/js/pledge.js\nhttp://minecraft.pinheadinstitute.org/js/pledgeSearch.js\nhttp://minecraft.pinheadinstitute.org/js/registration.js\nhttp://minecraft.pinheadinstitute.org/js/stripe-checkout.js\nThe way I get the code is: js = uglifyjs.minify(fullFiles).code;  where uglifyjs is set via require('uglify-js') and fullFiles is the array of the javascript filenames above (except local server file paths instead of links).\n. ",
    "jonathanong": "the following is a commonjs example. instead of the following, which is done by default (i should have added this in the issue):\njs\nvar fn = function (require, module, exports) {\n  module.exports = \"something\";\n}\na builder might do the following instead:\njs\nvar fn = new Function('require', 'module', 'exports', 'module.exports = \"something\";')\nhowever, doing the second method will not result in minification although they are very similar. so the results might look like (just with variable obfucscation):\njs\nvar a = fn (b, c) {\n  c.exports = \"something\"\n}\nand \njs\nvar a = new Function('b', 'c', 'c.exports=\"something\"')\n\nI'm assuming you need to take a piece of JS code and transform it into a string containing that code\n\ni'm not sure what you mean by that. i'm creating a function using a constructor, argument names, and a string body instead of wrapping arbitrary code with a closure. \ndoes that make sense?\n. no. commonjs builds generally look like this:\n``` js\nrequire.define('uglifyjs', function (require, module, exports) {\n  module.exports = ...\n})\nrequire.define('underscore', function (require, module, exports) {\n  module.exports = ...\n})\n```\nthe idea is that a builder may want to use new Function('require', 'module', 'exports', 'some string body') to defer evaluation (since the string body is just a file, so it should really be just one, large string). however, uglifyjs won't minify it right now (as it's a string).\njs\nrequire.define('uglifyjs', new Function('require', 'module', 'exports', 'module.exports = ...'))\nyes, it's an edge-case, but i'm just throwing it out there. hopefully you get the idea, though.\n. Holy crap. Didn't expect you to do it so fast. I was just expecting an opinion. Awesome!\n. Holy crap. Didn't expect you to do it so fast. I was just expecting an opinion. Awesome!\n. ",
    "EliSnow": "@Qantas94Heavy \nYes a check would be necessary because\nvar a = {\n    foo : 26\n};\na.bar = a.foo;\ncannot be\nvar a={foo:26,bar:a.foo}\nAnother scenario to consider: \nvar obj = {\n    foo : 26\n};\n/* ...\n * Some code which utilizes obj\n * ...\n */\nobj.bar = 98;\nCombining the two in this case could break code, so there would need to be a check to see if between the object literal and the dot notation, does any code use the object.\n. ",
    "PunterSThompson": "Fast response, great!\n. ",
    "bpytlik": "I see now that the --overwrite option wasn't carried over from uglify 1.X. I'd still say that providing this option shouldn't cause a hang.\n. ",
    "ypanyukov": "yes) you right\n. ",
    "mattrobenolt": "Also see: https://bugzilla.mozilla.org/show_bug.cgi?id=870361\nAnd https://groups.google.com/forum/?fromgroups=#!topic/mozilla.dev.js-sourcemap/4uo7Z5nTfUY\n. @crocket  //@ has been deprecated in favor of //# since //@ caused issues in IE.\n. See https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit for the spec.\n. Also for the patch in Chromium: https://codereview.chromium.org/15832007\n. ",
    "johmoh": "Hmm, I thought that is what ...\n\n-r, --reserved     Reserved names to exclude from mangling.\n\n... is for. Or have I misunderstood your question?\n. Ah, okay. Then I am sorry. I can not help you. If I were you I would take a look at the implementation of the command line tool. Because if you can specify reserved words with \"---reserved\" then there already must exist a possibility for reserved worlds in the api. - But I am sure, you know that already.\n. ",
    "sroussey": "r.js embeds uglifyjs2 so having a command line option is not valuable in the same way\n. ",
    "natevw": "Hmm, it looks like https://github.com/g-k/source-map-cat is kind of what I'm asking for\u2026if it's in working condition maybe I can use to do that.\nIt'd be cool though if UglifyJS2 somehow gave per-file options to avoid multiple steps though, something just in one pass:\nuglify --no-parse ./vendor/d3.min.js --compress ./src/my.js ./src/app.js ./src/code.js --source-map ./output/app.js.map -o ./output/app.js\n. Understood, thanks!\n. ",
    "rooftopsparrow": "After beautifying and searching for missing declarations, I have found that the file that is reporting missing is actually declared, but way after expected.\nSo I compared the file outputs from both the Fedora machine and the mac and the wildcard pattern was different!\nTurns out what I though was standard with make-wildcard (returns in an alphabetical order) was an incorrect assumption as seen here: \n+ * WARNING: Backward-incompatibility!\n++  Wildcards were not documented as returning sorted values, but the results\n++  have been sorted up until this release..  If your makefiles require sorted\n++  results from wildcard expansions, use the $(sort ...)  function to request\n++  it explicitly.\nThe mac has GNU Make 3.81 and the Fedora has GNU Make 3.82.\nProblem solved!\n. ",
    "damianb": "That'd be it. Thanks.\n. ",
    "jpirkey": "Any reason why pull request #244 hasn't been merged in yet?  It is an important and time saving fix to address and debug CLI build failures.\n. ",
    "laino": "Same question\n. +1\n. ",
    "tkazec": "Okay, I see. The algorithm makes sense, but the real cause is that the base54 class is a singleton, and has global internal state across all calls? It seems to me like the base54.reset() should be called every time the minify process is started, but that's just my cursory opinion. If not, a reset option would be cool :)\nThanks!\n. Cool, thanks!\n. ",
    "stephenmathieson": "thoughts?\n. what about:\nsh\n$ uglifyjs -b foobar.js\n$ unexpand -t 2 foobar.js\n. ",
    "almosnow": "Yeah, well, I don't think those should get escaped.\nCheck this out:\nvar uglify = require('uglify-js');\nvar code = '\\'\\\\\" NO WAY, JOSE \\\\\"\\'';\nconsole.log('A:' + code);\ncode = uglify.parse(code).print_to_string();\nconsole.log('B: ' + code);\ncode = '\\'\" NO WAY, JOSE \"\\'';\nconsole.log('C:' + code);\ncode = uglify.parse(code).print_to_string();\nconsole.log('D: ' + code);\nAs you will see A != C but B == D, and that is wrong. Sure both strings are actually 'equivalent' (and I can imagine this as one of the reasons why this could've been purposedly coded as a feature), but they are not the same; and you can see in my first example that this situation leads to code that breaks.\n. K, got it now, thanks both.\n. bump\n. ",
    "westy": "Yeah, I agree that would be nice.\nI have many classes that are generated, that are analogous to C# enumerations, but many contain values that are never referenced in our client-side codebase.\nBe nice to be able to strip these out.\nThinking about it though, they're Ext classes, and overrides to boot, so Uglify would probably need knowledge of how Ext classes are defined and overridden, at least to cover my case.\ne.g.:\n```\n    Ext.define('Blah.enumeration.Data.Management.Generated.DataEvent', {\n        override: 'Blah.enumeration.Data.Management.DataEvent',\n    store: 2000,\n    update: 2001,\n    delete_: 2002,\n    read: 2003\n});\n\n```\nBlah.enumeration.Data.Management.DataEvent is the concrete, non-generated version of the class, that is in source control, and updateable if needed, and through which all actual uses go (e.g. Blah.enumeration.Data.Management.DataEvent.read).\nSorry if rambled a bit off topic, but just switched from Sencha Cmd's default YUI to try and save a few more bytes ;)\nCheers,\nWesty\n. ",
    "vohtaski": "Well, I actually found how I can do it:\nvar finalCode = UglifyJS.minify(file, { mangle: { except: [\"$super\"] } }).code\n. ",
    "fjsj": "up! I need parse erros on CLI.\n. ",
    "peterbowey": "+1\n. ",
    "doodeec": "maybe wrong title, this option is used to disable dropping unused params, which can have deeper meaning (like in AngularJS)\n. I'm quite new in here, is it possible to edit pull-requests? Or is it required to close this one and create new one with added documentation and small changes?\n. Sorry for that, I overlooked it also. I was finding around calling the drop function, not inside.\n. ",
    "adamRenny": "-m sort is causing me the same issue at the moment.\nRunning:\n0.10.17\nuglify-js@2.4.0\n. ",
    "tcgarvin": "Same issue here, v2.4.0\n. Afraid not. -m toplevel=true runs without actually mangling the toplevel variables.  (But then, -m notarealoption=true runs without errors, too)\nFor reference, here's an SO question describing the problem:  (Admittedly, this could be unrelated to the SymbolRef error that occurs without =true, but I halfway expect this to be a single options parsing issue)\n\nFor reasons which escape me, uglifyjs does not appear to be mangling top-level names.  What am I doing wrong?\nA simple testugly.js looks like this:\n language: lang-js \ntestThing={};\ntestThing.something = 1;\ntestThing.myfunction = function(alpha,beta,c) {\n    var dino = 5;\n    if (alpha > 2) {\n        dino = 6\n    }\n    return dino + beta * c \n}\nSimple enough.  If I run it through uglify without trying to mangle top-level variables, things go as expected:\n language-all: lang-sh \n```\n$ uglifyjs --version\nuglify-js 2.4.0\n$ uglifyjs testugly.js --mangle -c\ntestThing={},testThing.something=1,testThing.myfunction=function(t,n,i){var e=5;return t>2&&(e=6),e+n*i};\n```\nNow, I'd like to mangle the top-level variables as well,so I add toplevel=true.\n$ uglifyjs testugly.js --mangle toplevel=true -c\ntestThing={},testThing.something=1,testThing.myfunction=function(t,n,i){var e=5;return t>2&&(e=6),e+n*i};\nOr maybe I got that wrong, let's try the old -mt too.\n$ uglifyjs testugly.js -mt -c\ntestThing={},testThing.something=1,testThing.myfunction=function(t,n,i){var e=5;return t>2&&(e=6),e+n*i};\nWhat gives?  Shouldn't testThing be 'a' or something?\n. Adding var to the global declaration didn't help.\nBut: 2.4.1 fixes it!  My app is now utterly minuscule.  Thanks!\n. ",
    "JamesMGreene": "I also need an option to leave named function expressions' names intact, which I believe was the purpose of the -nmf (--no-mangle-functions) flag in UglifyJS (v1)... though perhaps that affected treatment of all function names rather than just named function expressions.\n. P.S. My use case:\nInput:\njs\nvar MyClass = function MyClass_() {\n  this.MyMethod = function MyClass_MyMethod() {\n    // Blah\n  };\n};\nOutput:\njs\nvar MyClass=function(){this.MyMethod=function(){}}\nI want the MyClass_ and MyClass_MyMethod named function expressions to retain those names (and not just for IE) as it is useful for the purpose of real-time logging and inspection of the function stack trace... otherwise they just show up as anonymous functions. :(\n. ",
    "arian": "I have the same problem in IE8, using this code:\n``` js\n(function(){\nfunction makeClass(proto) {\n    var ctor = proto.constructor;\n    ctor.prototype = proto;\n    return ctor;\n}\nvar MyClass = makeClass({\n    constructor: function MyClass(bar){\n        this.foo = bar;\n        console.log(MyClass.hi);\n    }\n});\nMyClass.hi = \"test\";\nnew MyClass(\"hi\");\n})();\n```\nWhich minifies to: (with uglifyjs test.js --beautify -m -o test.min.js)\njs\n(function() {\n    function o(o) {\n        var t = o.constructor;\n        t.prototype = o;\n        return t;\n    }\n    var t = o({\n        constructor: function n(o) {\n            this.foo = o;\n            console.log(n.hi);\n        }\n    });\n    t.hi = \"test\";\n    new t(\"hi\");\n})();\nIn node/chrome, this logs test, but in IE it logs undefined.\n. ",
    "benwick": "I'm sorry, but you are ridiculous. Even without my example it is integral to have some form of control over the mangled names. In a website with many js scripts you only uglify certain ones, for exmaple only yours (others may come from CDN hosts etc) ... you never know if a script will polute the global namespace with certain variable names. The possiblity of a name conflict is ALWAYS there. So don't be rude and consider my request.\n. ",
    "ben-ng": "e38b5a70e8e19f9cc95dd0ad35193d828db132bc escapes an additional character, found in lodash\n. +1 for getting this merged!\n. ",
    "valums": "It is correct, the source-map 1.7 package is required. I had the same problem installing uglifyjs and the solution is to update the nodejs. The version provided with Ubuntu LTS is not supported.\n. ",
    "ArBaDaCarBa": "Same issue here... with source-map version 0.1.7\n\n$ npm install uglify-js\nnpm http GET http://registry.npmjs.org/uglify-js\n[...]\nnpm ERR! error installing uglify-js@2.4.0\nnpm ERR! Error: No compatible version found: source-map@'>=0.1.7- <0.2.0-'\nnpm ERR! Valid install targets:\nnpm ERR! [\"0.0.0\",\"0.1.0\",\"0.1.1\",\"0.1.2\",\"0.1.3\"]\nnpm ERR!     at installTargetsError (/usr/share/npm/lib/cache.js:488:10)\nnpm ERR!     at next_ (/usr/share/npm/lib/cache.js:438:17)\nnpm ERR!     at next (/usr/share/npm/lib/cache.js:415:44)\nnpm ERR!     at /usr/share/npm/lib/cache.js:408:5\nnpm ERR!     at saved (/usr/share/npm/lib/utils/npm-registry-client/get.js:147:7)\nnpm ERR!     at Object.oncomplete (/usr/lib/nodejs/graceful-fs.js:230:7)\nnpm ERR! You may report this log at:\nnpm ERR!     http://bugs.debian.org/npm\nnpm ERR! or use\nnpm ERR!     reportbug --attach /[...]/npm-debug.log npm\nnpm ERR!\nnpm ERR! System Linux 3.2.0-48-generic\nnpm ERR! command \"node\" \"/usr/bin/npm\" \"i\" \"uglify-js\"\nnpm ERR! cwd /[...]\nnpm ERR! node -v v0.6.12\nnpm ERR! npm -v 1.1.4\nnpm ERR! message No compatible version found: source-map@'>=0.1.7- <0.2.0-'\nnpm ERR! message Valid install targets:\nnpm ERR! message [\"0.0.0\",\"0.1.0\",\"0.1.1\",\"0.1.2\",\"0.1.3\"]\nnpm ERR!\nnpm ERR! Additional logging details can be found in:\nnpm ERR!     /[...]/npm-debug.log\nnpm not ok\n. \n",
    "joelfillmore": "Yep, looks like a duplicate of issue #257. Thanks!\n. ",
    "lope": "Hi mishoo,\nThe string is still mangled even with the option mangle:false. (see below)\nIs it possible to mangle the toplevel as well using .minify?\nvar uglify = require('uglify-js2');\nstrJS=\"var notMangled = function () {\\n\\tvar mangledVar='foo';\\n\\tconsole.log('blah' + mangledVar);\\n};\\n\";\nreturn uglify.minify(strJS, {fromString: true,mangle:false}).code + '\\n';\nOutput:\nvar notMangled=function(){var o=\"foo\";console.log(\"blah\"+o)};\n. Hi mishoo,\nThanks,\nI'm using uglify-js2@2.1.11\nthe github page https://github.com/mishoo/UglifyJS2#mangler-options says:\n\"toplevel \u2014 mangle names declared in the toplevel scope (disabled by default).\"\nI tried to achieve toplevel mangling using this code\nvar uglify = require('uglify-js2');\nstrJS=\"var notMangled = function () {\\n\\tvar mangledVar='foo';\\n\\tconsole.log('blah' + mangledVar);\\n};\\n\";\nvar toplevel = uglify.parse(strJS,{\n    filename: 'foo',\n    toplevel: toplevel,\n    mangle:toplevel\n});\ntoplevel.figure_out_scope();\nvar compressor = uglify.Compressor({});\nvar compressed_ast = toplevel.transform(compressor);\ncompressed_ast.figure_out_scope();\ncompressed_ast.compute_char_frequency();\ncompressed_ast.mangle_names();\nconsole.log(compressed_ast.print_to_string());\nit outputs this:\nvar notMangled=function(){var o=\"foo\";console.log(\"blah\"+o)};\n. Okay I see I had the latest uglify-js2 package but it looks like you've renamed the uglify-js2 project back to uglify-js?\nhttps://github.com/mishoo/UglifyJS2/issues/290\nVery nice its working now!!!! THANK YOU!!!!\nfinal code:\nreturn uglify.minify(strJS, {fromString: true,mangle: {toplevel:true}}).code;\n. ",
    "mcspring": "OK! Thanks all!\nOn Fri, Sep 13, 2013 at 2:55 PM, Dannii Willis notifications@github.comwrote:\n\nUse the \"ascii-only\" beautifier option if you don't want that. If you need\nit to remain as JSON rather than an object literal, then you can use the\n--expr option. See the readme for more.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mishoo/UglifyJS2/issues/292#issuecomment-24376566\n.\n\n\nBest Regards!\n\n\n- Spring\n. ",
    "matonga": "However, I'd love to see this implemented when using --unsafe and --screw_ie8 :wink:\n. ",
    "glenjamin": "For reference, this is being tracked at https://github.com/joyent/node/issues/6235\n. ",
    "tolgaek": "@rvanvelzen Thanks, this seems to work but I can't get ./**/*.js to work with nested directories.. I'm kinda new at this, so i'm not even sure if this is possible\n. ",
    "crocket": "After installing nodejs 0.10.20, 0.1.3 is recognized as 0.1.30.\nI don't know why uglifyjs didn't print anything, but it started working after I removed \"node\"(amateur radio program installed by deafult on ubuntu) and \"nodejs\" and installed \"nodejs\" again.\nIt seemed \"node\" executable from \"node\" package interefered with \"node\" from \"nodejs\" package.\nThus, this issue is closed.\n. I think it should be reopened because reqshark reported his issue.\nreqshark, can you report the exact error?\n. reqshark : Do you have any issue left?\n. What about chromium?\nDo I need to upgrade chromium?\n. OK. I'm closing it.\n. ",
    "reqshark": "for sure this has been my experience. ubuntu 13.04 GNU/Linux 3.9.3-x86_64 is unhappy with the uglify-js module at the moment. however to me it doesn't seem like it has anything to do with an apt node package or even specific versions of node 0.10.x. \nwhatever, it's easy to fix. just install from git in the node_modules directory and the issue resolves. how about a one-liner that does the trick for me:\n(cd node_modules && git clone https://github.com/mishoo/UglifyJS2.git uglify-js && cd uglify-js && npm i)\n. I got npm ERR! tar.unpack untar error /home/shark/.npm/uglify-js/2.4.0/package.tgz so I went to my user's global .npm directory, removed uglify. Now just re-installed globally without any problem and now the npm install works on the other apps. This might not be an issue, probably just bad permissions like when you npm install -g on packages before installing nvm... \n. no sir we're probably good to close this.\n. ",
    "aplib": "I have an error on the line that contains the .DoT = r\nAlso Safari gives more other similar errors.\nUnfortunately, I do not have Mac and I can not properly reproduce the situation on my computer. Error messages  also reported from other users.\nNo errors on other browsers, Chrome, Opera, Firefox.\n. I corrected the error by replacing\n(function(){ return this || (0,eval)('this'); }()).doT = doT;\nwith\nthis.doT = doT;\nfunction(){ return this || (0,eval)('this'); }()\nin Safari under debug returns undefined\nBut, why this error occurs only after processing uglifyjs I did not understand, perhaps because of the brackets?\n. ",
    "grosch": "Ah, OK.  I was adding the toplevel option to -m to make the file as little as possible.  I guess I just shouldn't do that.  Interestingly if I remove it, uglifyjs gets an error.  I'm not using gzip for this so I'm adding the sort option.  I'm really new to minification, so if I'm just doing this wrong... :)\n% uglifyjs process.js -mtoplevel,sort -o p2.min.js\n% uglifyjs process.js -msort -o p2.min.js\n/usr/local/lib/node_modules/uglify-js/bin/uglifyjs:133\n    if (MANGLE) MANGLE.except = ARGS.r.replace(/^\\s+|\\s+$/g).split(/\\s_,+\\s_/)\n                                       ^\nTypeError: Object true has no method 'replace'\n    at Object. (/usr/local/lib/node_modules/uglify-js/bin/uglifyjs:133:40)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Function.Module.runMain (module.js:497:10)\n    at startup (node.js:119:16)\n    at node.js:901:3\n. ",
    "mbarkhau": "Is this out of scope for UglifyJS?\n. Ok cool. I'll see what I can do.\nDo you see any edge cases where this transformation might break code?\n. ",
    "duzy": "$ node -v\nv0.11.8-pre\n$ npm -v\n1.3.11\n. ",
    "Arnavion": "Reported later at https://github.com/mishoo/UglifyJS2/issues/329 and closed as a node bug.\n. ",
    "soulwu": "My company has a system that just use JSMin to distribute js files to CDN servers.\nBut our team use RequireJS and UglifyJS to combine and compress multi-files source\nIs there any solution to avoid the conflict, like let UglifyJS do not trim the parenthesis with some option?\n. ",
    "fouber": "@mishoo \nversion 2.4.0\uff0cusing npm install -g uglify-js\nlink: [https://npmjs.org/package/uglify-js]\n. npm install uglify-js\nthen using UglifyJS.minify to compress js code in nodejs\n``` javascript\nvar UglifyJS = require('uglify-js');\nvar code = '(function(){\\\n    var a = 1;\\\n    var c = 7;\\\n    var i = 0;\\\n    if(a < 0){\\\n        i = -7;\\\n    }\\\n    for (var zz = 0; i < c; i++) {\\\n        alert(i);\\\n    }\\\n})();';\nconsole.log(UglifyJS.minify(code, { fromString : true }).code);\n```\noutput:\njavascript\n!function(){var r=1,a=7,f=0;for(0>r&&(f=-7),;a>f;f++)alert(f)}();\n. ",
    "Krinkle": "Even if it does have side-effects, if the x variable is not referenced further in that scope, it shouldn't matter. Of course, if there is anything like eval() going on within a scope, all bets are off. But I suppose that is a problem already when mangling variable names, so we've already established that.\nInstead of:\njs\nvar x = 1;\nvar url = someLogic();\nvar something = Math.floor(x);\nreturn [url, something];\nLet's use:\njs\nfunction getName() {\n    return Number(Math.random().toString().slice(-10)).toString(36);\n}\nfunction floor(obj) {\n    obj.changed = true;\n    return { affected: obj };\n}\nvar x = {};\nvar url = getName();\nvar something = floor(x);\nreturn [url, something];\nNow, I don't know what information UglifyJS has available during its compression, but in theory I think it can know:\n- x is not referenced elsewhere so it can be substituted in the call to floor.\n- url and something are local variables not used elsewhere, and can be substituted in the array.\nDepending on whether its perception is updated, it might be able to only substitute either x or url and something.\njs\nfunction getName() {\n    return Number(Math.random().toString().slice(-10)).toString(36);\n}\nfunction floor(obj) {\n    obj.changed = true;\n    return { affected: obj };\n}\nreturn [getName(), floor({})];\nBut in simple cases like this:\njs\nfunction example() {\n    var data = JSON.stringify( x );\n    sendMessage( y, data );\n}\nIt would be able to drop the data variable.\n. Why is the input of this test changed?\n. ",
    "puzrin": "~ 1sec without flags. But full src cutted to 425k instead of 280k\n```\n$ time uglifyjs tinymce.js > noparams_full.js\nreal    0m1.055s\nuser    0m0.988s\nsys 0m0.068s\n$time uglifyjs tinymce.min.js > noparams_minified.js\nreal    0m1.090s\nuser    0m0.868s\nsys 0m0.116s\n```\nIf you need to reproduce result - take tiny mce dev/production versions here http://www.tinymce.com/download/download.php .\nProblem with minified src already was mentioned #216, but in wrong context (users asked options to skeep prosessing, instead of fixing speed).\n. Problem starts with -c option. With just -m all is ok.\n. Interesting. Thank you. You can also try minified d3 source, that's not tinymce-specific. d3.min.js was reported in the past, but with wrong request - asked some nasty options, instead of bad speed report.\nIn mincer's defaults i've completely disabled compression (-c) and left mangling (-m) only. In final result, if you compare gzipped file, there will be only 2% difference. Probably, disable processing unused variables is more clever solution.\nBy the way, consider disable cleanup of unused variables in uglifyjs by default. That looks like jshint task.\n. If problem is in example - i'll spend time to find a better one. Current situation is, that one of #321 or #326 should be fixed for safe deploy on production sites.\n1. We can't just send all safary users to hell. Safary is popular.\n2. We can't wait 5+ minutes on server start, due slowdown on minified files\n3. We can't expect, that developper will not try to process minified files. Because, in real projects some external vendor modules have no unminified sources. Manual uncompression will be a pain for mainenance.\n. Personally, i've tested in Safary 7, OSX. But here is confirmation for 6.1 too https://github.com/fontello/fontello/issues/225 (don't pay anttention on alert on screenshot, it's caused by broken script).\n. ",
    "joegoldbeck": "Yup, that does it. Thanks for the help!\n. ",
    "isaacs": "Aha, appears to be a V8 bug:\n```\n\nvar o = vm.createContext({}); vm.runInContext('function f(){}', o, 'f.js'); o.f\nundefined\nvar o = vm.createContext({}); vm.runInContext('var f = function f(){}', o, 'f.js'); o.f\n[Function: f]\n```\n\nFunction declarations should create globals, but apparently are not doing that.\n. Nope, this is not a V8 bug.  It's a Node bug.\nThe issue is that function declarations are not \"set\" operations, they're \"configure\" operations, and we're not catching those and handling them.\nhttps://gist.github.com/isaacs/7163071\n. Still, though, seriously... Uglify should be using regular modules and explicit exports, rather than this homegrown vm stuff.  What percentage of users of uglify are not running it on the command line with Node?\n. ",
    "theakman2": "I didn't see those. I solved the problem in my case by appending \\n'';\\n to the content before calling uglify.parse, but that won't be appropriate in every case.\n. ",
    "damianlado": "It only allows me to send images. How could I send you a js file? \n. Sorry, I'm new to GitHub. Could you specify where I should go? \nSorry for the inconvenience. \n. Ok, I have upload the file. Should I send you the link or you check that on my user Gists? \n. ",
    "voronoipotato": "make a repo labeled files for mishoo\n. ",
    "mathiasbynens": "Well, this discussion has not been resolved yet: https://bugs.ecmascript.org/show_bug.cgi?id=1553\nTechnically '\\08' is a malformed string literal (as per the current spec), and although it seems to work fine in some environments it does throw a SyntaxError in strict mode in IE/Chakra, Safari/JavaScriptCore, and Firefox/SpiderMonkey (as it\u2019s considered to be an octal escape sequence there for some reason).\nFor a minifier like UglifyJS I\u2019d prefer this safer version that includes all digits.\n. ",
    "vibornoff": "Take a closer look: pasm is set to true only if the current scope is nested into the asm scope.\nSo it's false for top-level asm scope even it has \"use asm\" directive.\n. ",
    "davidbau": "Oops, I just noticed this old pull request is almost identical to mine.  You could add a test similar to the one in that change.\nhttps://github.com/davidbau/UglifyJS2/commit/a21f31d46fb903fe1ce05f391dad299eb2f60b23\n. ",
    "shinnn": "Add one space\n''+ -> \"\" +\n. Replace the single quotes with double quotes because all other code uses double quotes.\n. Ah, sorry I didn't look through this file.\n. ",
    "jheusala": "Really? There are other places that use single quotes in that file. \nIf that is really necessary maybe it should be fixed completely at other places, too. However maybe that's not the point of this issue?\n. ",
    "Taritsyn": "In Internet Explorer 8 with the beautify option equal to true the following error occurs:\nUnable to get property 'length' of undefined or null reference\nvar a = str.split(/\\r?\\n/), n = a.length - 1;\ncurrent_line += n;\nif (n == 0) {\n    current_col += a[n].length;\n} else {\n    current_col = a[n].length;\n____^\n}\nMy patch fixes this error. It would be nice to merge it.\n. Thanks for the link!\n. ",
    "fabiosantoscode": "This marks { argsInObjects } as unmangleable.\n. I used expect_exact because it tests the print function too.\n. It also tests that the stuff inside ${} got compressed and as such not mistaken for the outside string.\n. Not when self.value was mangled. If it was mangled I need to call into the Symbol's print function because it gives me the correct string.\n. Certainly!\n. Cool, making it\nvar create_a_block_scope =\n            (options.screw_ie8 && node instanceof AST_Catch) ||\n            ((node instanceof AST_Block) && node.creates_block_scope())\nThere may be some nuances as to how ES6 modules behave in terms of the toplevel scope, so this might be useful for that too.\n. ",
    "jchbh-duplicate": "Thanks, I will try to remove and test it again.\n\nOn May 20, 2015, at 10:36 PM, Michael Ficarra notifications@github.com wrote:\nIn lib/parse.js https://github.com/mishoo/UglifyJS2/pull/716#discussion_r30773976:\n\n@@ -610,7 +613,7 @@ var PRECEDENCE = (function(a, ret){\n         [\"^\"],\n         [\"&\"],\n         [\"==\", \"===\", \"!=\", \"!==\"],\n-        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n-        [\"<\", \">\", \"<=\", \">=\", \"in\", \"of\", \"instanceof\"],\n  of is not an operator\n\n\u2014\nReply to this email directly or view it on GitHub https://github.com/mishoo/UglifyJS2/pull/716/files#r30773976.\n. good question, \nand I test var let={a:1};, let let={a:1}, let var={a:1}, \nonly the first pass in io.js 2.0. \n\nit seems that the let is not treated as an reserved keyword ,but in LetExpression is cannot contain let.\nmaybe it is because ES6 need back compatible with ES5.\n. And in strict mode, those 3 are all failed because let is an strict mode reserved word.\nThe draft of ES2015 has so much changes, I think some of code refactoring need to be done in order to support them. \nbut for people who is carefully using the generator, let and for-of, I think this patch might be work for them.\n. ",
    "SpainTrain": "When you wish to update dependencies in the future, running npm run shrinkwrap will update the shrinkwrap based on the ranges specified in package.json.  More info: https://docs.npmjs.com/cli/shrinkwrap\n. Not only does shrinkwrap pin the version, but also the provenance of the dependency.  Since the tarball for a package version is immutable in the npm registry, we can be certain the library user installs the exact same tarball.  Similarly, the resolved properties that reference git repos use the relevant commit SHA.\n. ",
    "kzc": "It was intentional. If tok.literal is set then it is output. It should only be set in cases when it is a floating point literal. Otherwise numbers would not be compacted in regular non-asm.js blocks.\n. Yeah, figure_out_scope() is required everywhere now.  I could drop SCOPE_IS_NEEDED if you want.\nPlease feel free to suggest or apply patches as I'm not familiar with the entire code base.\n. Also note that integers can still be compacted in asm.js blocks:\n$ echo '\"use asm\"; f(1.00,2e0,300e5);' | bin/uglifyjs\n\"use asm\";f(1.00,2,3e7);\n. What do you think about this - if tok.literal = num; is always set for every number (integer or float) and if there is no scope for a given AST_Number instance, then the original numeric string literal could be output unconditionally.  Then the asm.js blocks would still generate correct code even without scope.  The downside to this is that minified code without compression or mangling would not have compacted floating point numbers as they presently do.\n. Will leave literal property as is. It works as intended.\nIf you want to unconditionally set the literal property for all AST_Numbers then at output time you will have to check that a \".\" exists in the literal and it's in \"use asm\" scope before outputting the literal.\n. Perform the \"\\\\v\" transform only if output.option(\"screw_ie8\")?\n. That should do the trick.\n. The back story: https://github.com/avdg/UglifyJS2/commit/5ab518a526d7108aceebc86c6819852b7ad77fe6#commitcomment-15409326\n. No \"uglifyjs\" keyword?\n. I removed it because the code doesn't work with clone. No one was using the after callback; it seemed the right thing to do.\nI'd be curious If you could make it work and pass all tests with clone.\n. I'd prefer it be named something like fix_lexical_scope  or fix_expression_scope over check_function_call because it better conveys its action. It's not so much as a check as an AST fix up.\n. @michaelficarra It's the end effect that is being described. I'd also be okay with fix_call_expression.\nSide note, you seem to be familiar with the ECMAscript specs... do you happen to know the section(s) in the ES 5.1 spec that outlines this behavior?\n. @michaelficarra: JavaScript is crazy.\nCouldn't agree more. Every time common sense is applied to issues such as this, Javascript proves you wrong.\n. I would advise against trying to optimize (0, a)() into a() in any case.\n. A better input could be:\nvar x = ('(');\na( ('(') );\n. I don't follow. What's the bug?\n. I see you mean (\"string\"); shouldn't be a directive. I suppose, but it seems harmless enough. Unlikely for such code to be in the wild.\n. Because it takes too long to test. On my machine the mangle test for 21,000 variables is 1 second, but on Travis CI machine it is over 2 seconds. 266K vars would take around 24s or so on Travis CI.\n. The test looks for the symbols that had existed before and after the erroneously generated let. If the mangle algorithm changes, this test would have to be updated.\nBut if @mishoo or @rvanvelzen would be good with a 50 second npm test (2X estimated Travis CI run time) to test all 3 letter mangle var names, then we could do that.\nEdit: node 5.8.0 cannot handle running an uglifyjs mangle against a function with more than 126,000 variables - Maximum call stack size exceeded. So that's a no go.\n. I was just looking for result symmetry for tests with non-default compress flags. \nBefore patch:\n```\n$ echo 'a = condition() ? !0 : !-3.5;' | uglifyjs -c\na=!!condition();\n$ echo 'a = condition() ? !0 : !-3.5;' | uglifyjs -c evaluate=false\na=condition()?!0:!-3.5;\n```\nAfter patch:\n```\n$ echo 'a = condition() ? !0 : !-3.5;' | bin/uglifyjs -c\na=!!condition();\n$ echo 'a = condition() ? !0 : !-3.5;' | bin/uglifyjs -c evaluate=false\na=!!condition()||!-3.5;\n```\nThe functions is_true and is_false within lib/compress.js will recognize !0 and !1 as booleans because they are so commonly used in the wild. But I did not make that accommodation for negative constants which are actually AST_UnaryPrefix expressions with operator \"-\" when evaluate=false - not an AST_Constant with value -3.5.\nI wouldn't recommend disabling the evaluate compress flag in real-life uglifyjs use.\n. No worse than before - whether hoist_funs is enabled or not. Other issues can be opened for duplicate warnings and suboptimal compression. This is fine for the scope of this issue.\n. Can you add a /* @const */ var test as well?\n. Probably should throw in a regular var goog = goog || {}; test in for good measure.\n. Odd. A top level figure_out_scope() should have set the scope property on all refs as it does on master branch. I assume this change was necessary to get all collapse_vars tests to pass on the harmony branch? If so, something may be amiss with figure_out_scope() with new AST classes on that branch.\n. Your patch is probably fine if the tests pass, although collapse_vars may be slower as result. But the need for the fix points to a problem with figure_out_scope() in the harmony branch. \n. If options is not set then that means use default output options where comments is false. I think it's fine. Fewer conditions in this code path.\n. It's also used elsewhere in the code where an AST_RegExp literal is an acceptable AST_Constant. \nAlthough AST_RegExp is derived from AST_Constant it's more of a pseudo constant.\n. It's correct as is. If you studied the code, this is the other use of is_constant:\necho 'function f(x) { return x ? /foo/ : /foo/; }' | uglifyjs -c\nfunction f(x){return/foo/}\n. I'm aware of that. This is getting to be very off topic to this ticket, but here's some background: \nThe original code for the x?1:1 --> 1 conditionals optimization only checked for AST_Constants which includes AST_RegExp. That check was replaced with Node.is_constant() which is functionally the same as an instanceof AST_Constant check except it recognizes the very common !0 style expressions as well. The original author of the conditionals optimization probably did not want to waste CPU cycles comparing the ASTs of the consequent and alternative of every ternary operator if equivalence is less likely to occur. AST comparison is expensive and involves calling AST_Node.print_to_string() on both expressions and comparing the resultant strings.\nIn any case, this PR works correctly and there are no regressions in other parts of the code. If you have issue with other optimizations please open a new ticket.\n. The fix shouldn't rely on parse tokens; it should examine AST_Node derived instances. The code as is won't be guaranteed to work with spidermonkey AST import or the alternative acorn parser when they are eventually supported by the harmony branch as is the case with the master branch.\n. Also, a couple of test cases involving let use in case and default clauses would be useful.\n. None of these new conditions on lines 1288 - 1292 are exercised by your tests. Could you either add test support for them or drop this part of the patch?\n. When this part of the patch is reverted npm test still passes with the new tests. This suggests that those lines are not exercised/needed.\n. With your latest PR change I verified that test/mocha/new.js exercises this code now.\n. Lines 409-412 would be more efficient if written as:\njs\n                if (octal_len > 0) {\n                    if (ch !== \"0\" && next_token.has_directive(\"use strict\"))\n                        parse_error(\"Octal literals are not allowed in strict mode\");\n                    ch = String.fromCharCode(parseInt(ch, 8));\n                } else {\n                    ch = read_escaped_char(true);\n                }\n. Could you please add these boundary test cases as well?\njs\n            ['\"\\\\08\"', '\"\\\\x008\";'],\n            ['\"\\\\008\"', '\"\\\\x008\";'],\n            ['\"\\\\0008\"', '\"\\\\x008\";'],\n. Style in rest of code is to put ) { on line above.\n. Looking at your tests... I didn't realize that yield could be used in an expression context. If that's the case then AST_Yield should not be derived from AST_Statement - or derived from anything for that matter. Line 1258 should be:\n});\nMy apologies - this is the 3rd or 4th time I suggested the base class for AST_Yield be changed.\n. Just confirmed that all tests still pass with AST_Yield not being derived from a base class.\n. value should be renamed to expression to be consistent with other AST nodes like AST_Unary.\n. Another suggested test:\nfunction* f2() { yield undefined; }\n. typo: it's --> its\n. This description is incorrect. Should keep undefined without compression.\n. Good point. The expression is mandatory for a yield*.\nOPT(AST_Yield, function(self, compressor){\n-        if (self.expresssion instanceof AST_Undefined) {\n+        if (!self.is_star && self.expresssion instanceof AST_Undefined) {\n             self.expresssion = null;\n         }\n         return self;\n    });\nFWIW, I wasn't aware of yield* before this PR and don't know how it works. ;-)\nEdit: patch changed to fix spelling autocorrect.\n. > AST can come from multiple sources.\nI guess that's true. I don't know how it's encoded in ESTree format. But the suggested revision to OPT(AST_Yield) won't hurt AFAIK.\n. ",
    "avdg": "I'll push some tests, given #905 has been pushed to master. I've rebased the patch just before the pr just to take advantage of this.\n. Uhh...\n. Hmm.. maybe we still do need a reset parameter, but default on restoring state afterwards. Letting the options parameter decide is more like \"if you want a state reset, you must accept our way of dealing printing code\".\n. Need to check for side-effects, I think there aren't enough test cases to catch them\n. Yeah, there is a check needed to make sure a semicolon is following, which may be there already or auto-inserted\n. Done\n. Not perfect, but there is no way to store backslash newlines from string literals in tokens, unless the output processor uses the raw directives.\n. Hmm yeah, the best answer I have now is to let them pass some tests. That excuse won't work :-)\n. It's to distinguish if yield must be an expression or if it may be an identifier (or something). Of course, one needs to be able to understand this without looking at this comment so I will look for a fix. \n. Thanks\n. Done (woops, had to repush)\n. No worries, I don't expect things to be right even after a few reviews :-)\n. Yeah, this would be interesting to see if undefined could be dropped by compression or without. Especially with yield* as removing undefined might make the code invalid.\n. Undefined gets rewritten as void 0. Need to dive in the code generator and see if this statement could even be removed by default.\n. Of course, there will be yield* tests required after this\n. Lazy copy from my side\n. Done\n. meh\njs\nvar things = [ (... some content ...)];\nfor (var i = 0; i < 10; i++) {\n    yield things[i];\n}\nvs\njs\nvar things = [ (... some content) ... ];\nyield* things;\nProvided the js interpreter knows that array is iterable. It's a handy syntax sugar.\n. Not sure if the code generator should be guarded against ~~empty~~ lack of expressions. AST can come from multiple sources.\n. If we control all sources, it might be possible to drop this :-)\n. ",
    "dariocravero": "Oops... Sorry about that :/\n. ",
    "alexlamsl": "@kzc @michaelficarra how about maintain_this_binding(), as per reference?\n@kzc I think this might explain why (a.b)() isn't any different from a.b()...\n. Erm... how is this different from the follow?\n!function(a) {\n  a(\"\");\n}(eval);\n. @michaelficarra right you are:\n```\nfunction a(eval) {var b = 1; return eval('b')}\na(eval)\n// 1\na((0,eval))\n// 1\na(function(t){return eval(t)})\n// 'b' is undefined\n```\nThanks for the lesson! :+1: \n. I'm actually starting to worry now, because any (0, a)() can potentially be eval() which means I can't optimise it to a(), or am I just starting to see things and need :coffee: ?\n. @rvanvelzen I agree with you here, except in the context of this project, how do we know when a variable is not assigned eval? :sweat: \n. "
}